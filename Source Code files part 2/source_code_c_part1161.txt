***************************************************
;*
;*  Label definition macros
;*
;*  Usage:
;*	labelI	 Name, {PUBLIC, PASCAL, C}
;*
;***************************************************************

__MakePublic	macro	name, option	;; decides if a label should be
ifidni	<option>, <PUBLIC>		;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
	public	pascal name	;; make public if DEBUG
    endif
endif
		endm


if	@Version GE 600

MakeLabel   macro suffix, LabelType	;; makes all of the label* macros

%@CatStr(<label>,<suffix>)	macro	name, option
	__MakePublic	<name>,<option>
name	label	&LabelType
	endm

	endm

else	;!(@Version GE 600)

MakeLabel   macro suffix, LabelType	;; makes all of the label* macros

label&suffix	macro	name, option
	__MakePublic	<name>,<option>
name	label	&LabelType
	endm

	endm

endif	;!(@Version GE 600)


	MakeLabel   T, tbyte	; make labelT
	MakeLabel   Q, qword	; make labelQ
	MakeLabel   D, dword	; make labelD
	MakeLabel   W, word	; make labelW
	MakeLabel   B, byte	; make labelB

	MakeLabel   P, proc	; make labelP
	MakeLabel   FP, far	; make labelFP
	MakeLabel   NP, near	; make labelNP

%	MakeLabel   I, IWORD	; make labelI


labelDP macro	name, option		    ;; labelDP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeD
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeD
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm

labelCP macro	name, option		    ;; labelCP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeC
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeC
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16	macro	SegReg

ifdef I386
	nop
	db	66h	    ; operand size over-ride
endif	; I386

	push	SegReg
	endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro	label

ifndef I386
	error  <JMPFAR16 can only be used in a use32 code segment>
endif	;I386

	nop
	db	66h	    ;; operand size over-ride
	db	0eah	    ;; jmp far immediate op code
	dw	offset label
	dw	seg label
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\internal.h ===
/***
*internal.h - contains declarations of internal routines and variables
*
*	Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declares routines and variables used internally by the C run-time.
*	[Internal]
*
*Revision History:
*	05-18-87  SKS	Module created
*	07-15-87  JCR	Added _old_pfxlen and _tempoff
*	08-05-87  JCR	Added _getbuf (corrected by SKS)
*	11-05-87  JCR	Added _buferr
*	11-18-87  SKS	Add __tzset(), made _isindst() near, remove _dtoxmode
*	01-26-88  SKS	Make __tzset, _isindst, _dtoxtime near/far for QC
*	02-10-88  JCR	Cleaned up white space
*	06-22-88  SKS	_canonic/_getcdrv are now used by all models
*	06-29-88  JCR	Removed static buffers _bufout and _buferr
*	08-18-88  GJF	Revised to also work for the 386 (small model only).
*	09-22-88  GJF	Added declarations for _freebuf, _stbuf and _ftbuf.
*	01-31-89  JCR	Removed _canonic, _getcdrv, _getcdwd (see direct.h)
*	06-07-89  PHG	Added _dosret for i860 (N10) version of libs
*	07-05-89  PHG	Changed above to _dosmaperr, added startup variables
*	08-17-89  GJF	Cleanup, removed stuff not needed for 386
*	10-25-89  JCR	Added prototype for _getpath()
*	10-30-89  GJF	Fixed copyright
*	11-02-89  JCR	Changed "DLL" to "_DLL"
*	03-01-90  GJF	Added #ifndef _INC_INTERNAL and #include <cruntime.h>
*			stuff. Also, removed some (now) useless preprocessing
*			directives.
*	03-21-90  GJF	Put _CALLTYPE1 into prototypes.
*	03-26-90  GJF	Added prototypes for _output() and _input(). Filled
*			out the prototype for _openfile
*	04-05-90  GJF	Added prototype for __NMSG_WRITE() (C source build
*			only).
*	04-10-90  GJF	Added prototypes for startup functions.
*	05-28-90  SBM	Added _flush()
*	07-11-90  SBM	Added _commode, removed execload()
*	07-20-90  SBM	Changes supporting clean -W3 compiles (added _cftoe
*			and _cftof prototypes)
*	08-01-90  SBM	Moved _cftoe() and _cftof() to new header
*			<fltintrn.h>, formerly named <struct.h>
*	08-21-90  GJF	Changed prototypes for _amsg_exit() and _NMSG_WRITE().
*	11-29-90  GJF	Added some defs/decls for lowio under Win32.
*	12-04-90  SRW	Added _osfile back for win32.  Changed _osfinfo from
*                       an array of structures to an array of 32-bit handles
*			(_osfhnd)
*	04-06-91  GJF	Changed _heapinit to _heap_init.
*	08-19-91  JCR	Added _exitflag
*	08-20-91  JCR	C++ and ANSI naming
*	01-05-92  GJF	Added declaration for termination done flag [_WIN32_]
*	01-08-92  GJF	Added prototype for _GetMainArgs.
*	01-18-92  GJF	Added _aexit_rtn.
*	01-22-92  GJF	Fixed definitions of _acmdln and _aexit_rtn for the
*			of crtdll.dll, crtdll.lib.
*	01-29-92  GJF	Added support for linked-in options equivalent to
*			commode.obj and setargv.obj (i.e., special declarations
*			for _commode and _dowildcard).
*	02-14-92  GJF	Replace _nfile with _nhandle for Win32. Also, added
*			#define-s for _NHANDLE_.
*	03-17-92  GJF	Removed declaration of _tmpoff for Win32.
*	03-30-92  DJM	POSIX support.
*	04-27-92  GJF	Added prototypes for _ValidDrive (in stat.c).
*	05-28-92  GJF	Added prototype for _mtdeletelocks() for Win32.
*	06-02-92  SKS	Move prototype for _pgmptr to <DOS.H>
*	06-02-92  KRS	Added prototype for _woutput().
*	08-06-92  GJF	Function calling type and variable type macros.
*	08-17-92  KRS	Added prototype for _winput().
*	08-21-92  GJF	Merged last two changes above.
*	08-24-92  PBS	Added _dstoffset for posix TZ
*	10-24-92  SKS	Add a fourth parameter to _GetMainArgs: wildcard flag
*			_GetMainArgs => __GetMainArgs: 2 leading _'s = internal
*	10-24-92  SKS	Remove two unnecessary parameters from _cenvarg()
*	01-21-93  GJF	Removed support for C6-386's _cdecl.
*	03-30-93  GJF	__gmtotime_t supercedes _dtoxtime.
*	04-17-93  SKS	Add _mtterm
*	05-11-93  SKS	_mtinit now returns success (1) or failure (0)
*			_C_Termination_Done needed in all models (for DLLs)
*	06-02-93  CFW	Add _flswbuf, _filwbuf protos.
*       07-15-93  SRW   Added _capture_argv function prototype
*       09-22-93  CFW   Test for invalid MB chars using global preset flag.
*
****/

#ifndef _INC_INTERNAL

#ifdef __cplusplus
extern "C" {
#endif

#include <cruntime.h>

/* Define function type used in several startup sources */

typedef void (__cdecl *_PVFV)(void);


/*
 * Conditional macro definition for function calling type and variable type
 * qualifiers.
 */

#ifdef	_DLL
#define _commode    (*_commode_dll)
extern int * _commode_dll;
#else
#ifdef	CRTDLL
#define _commode    _commode_dll
#endif
extern int _commode;
#endif

#ifdef	_WIN32_

/*
 * Define the number of supported handles. This definition must exactly match
 * the one in os2dll.h.
 */
#ifdef	MTHREAD
#define _NHANDLE_   256
#else
#define _NHANDLE_   64
#endif

extern int _nhandle;		/* == _NHANDLE_, set in ioinit.c */

#else	/* ndef _WIN32_ */

extern int _nfile;

#endif	/* _WIN32_ */

extern char _osfile[];

#ifdef _WIN32_
extern	long _osfhnd[];
int __cdecl _alloc_osfhnd(void);
int __cdecl _free_osfhnd(int);
int __cdecl _set_osfhnd(int,long);
#endif	/* _WIN32_ */

#ifdef _POSIX_
extern long _dstoffset;
#endif /* _POSIX_ */

extern char __dnames[];
extern char __mnames[];

extern int _days[];
extern int _lpdays[];

#ifndef _TIME_T_DEFINED
typedef long time_t;		/* time value */
#define _TIME_T_DEFINED 	/* avoid multiple def's of time_t */
#endif

extern time_t __cdecl __gmtotime_t(int, int, int, int, int, int);

#ifdef	_TM_DEFINED
extern int __cdecl _isindst(struct tm *);
#endif

extern void __cdecl __tzset(void);
#ifdef _POSIX_
extern void __cdecl _tzset(void);
#endif

extern int __cdecl _ValidDrive(unsigned);


/**
** This variable is in the C start-up; the length must be kept synchronized
**  It is used by the *cenvarg.c modules
**/

extern char _acfinfo[]; /* "_C_FILE_INFO=" */

#define CFI_LENGTH  12	/* "_C_FILE_INFO" is 12 bytes long */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#if	defined(_ALPHA_)
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

/*
 * stdio internals
 */
#ifdef	_FILE_DEFINED

extern FILE * _lastiob;

FILE * __cdecl _getstream(void);
#ifdef _POSIX_
FILE * __cdecl _openfile(const char *, const char *, FILE *);
#else
FILE * __cdecl _openfile(const char *, const char *, int, FILE *);
#endif
void __cdecl _getbuf(FILE *);
int __cdecl _filwbuf (FILE *);
int __cdecl _flswbuf(int, FILE *);
void __cdecl _freebuf(FILE *);
int __cdecl _stbuf(FILE *);
void __cdecl _ftbuf(int, FILE *);
int __cdecl _output(FILE *, const char *, va_list);
int __cdecl _woutput(FILE *, const wchar_t *, va_list);
int __cdecl _input(FILE *, const unsigned char *, va_list);
int __cdecl _winput(FILE *, const wchar_t *, va_list);
int __cdecl _flush(FILE *);
void __cdecl _endstdio(void);

#endif

extern int __invalid_mb_chars;

extern int _cflush;

#ifdef	_CRUISER_
extern unsigned int _tmpoff;
#endif	/* _CRUISER_ */

extern unsigned int _tempoff;

extern unsigned int _old_pfxlen;

extern int _umaskval;		/* the umask value */

extern char _pipech[];		/* pipe lookahead */

extern char _exitflag;		/* callable termination flag */

#if	defined(_WIN32_)
extern int _C_Termination_Done; /* termination done flag */
#endif	/* _WIN32_ */

char * __cdecl _getpath(const char *, char *, unsigned);

/* startup set values */
extern char **__argv;		/* argument vector */
extern int __argc;		/* argument count */
extern char *_aenvptr;		/* environment ptr */

/* command line */
#ifdef	_DLL
#define _acmdln     (*_acmdln_dll)
extern char **_acmdln_dll;
#else
#ifdef	CRTDLL
#define _acmdln     _acmdln_dll
#endif
extern char *_acmdln;
#endif

/*
 * prototypes for internal startup functions
 */
int __cdecl _cwild(void);			/* wild.c */
char * __cdecl _find(char *);			/* stdarg.asm or stdargv.c */
#ifdef MTHREAD
int __cdecl _mtinit(void);			/* tidtable.asm */
int __cdecl _mtinitlocks(void);     /* mlock.asm */
void __cdecl _mtterm(void);			/* tidtable.asm */
void __cdecl _mtdeletelocks(void);		/* mlock.asm */
#endif

/*
 * C source build only!!!!
 *
 * more prototypes for internal startup functions
 */
void __cdecl _amsg_exit(int);			/* crt0.c */
void __cdecl _cinit(void);			/* crt0dat.c */
void __cdecl __doinits(void);			/* astart.asm */
void __cdecl __doterms(void);			/* astart.asm */
void __cdecl __dopreterms(void);		/* astart.asm */
void __cdecl _FF_MSGBANNER(void);
void __cdecl _fptrap(void);			/* crt0fp.c */
void __cdecl _heap_init(void);
#ifdef	_WIN32_
void __cdecl _ioinit(void);			/* crt0.c, crtlib.c */
#endif	/* _WIN32_ */
void __cdecl _NMSG_WRITE(int);
void __cdecl _setargv(void);			/* setargv.c, stdargv.c */
void __cdecl __setargv(void);			/* stdargv.c */
void __cdecl _setenvp(void);			/* stdenvp.c */

#ifdef	_DLL
#define _aexit_rtn  (*_aexit_rtn_dll)
extern void (__cdecl ** _aexit_rtn_dll)(int);
#else
#ifdef	CRTDLL
#define _aexit_rtn  _aexit_rtn_dll
#endif
extern void (__cdecl * _aexit_rtn)(int);
#endif

#ifdef	_WIN32_
#if	defined(_DLL) || defined(CRTDLL)
void __cdecl __GetMainArgs(int *, char ***, char ***, int);
#endif
#endif	/* _WIN32_ */

/*
 * C source build only!!!!
 *
 * map OS/2 errors into Xenix errno values -- for modules written in C
 */
extern void __cdecl _dosmaperr(unsigned long);

/*
 * internal routines used by the exec/spawn functions
 */

extern int __cdecl _dospawn(int, const char *, char *, char *);
extern int __cdecl _cenvarg(const char * const *, const char * const *,
	char **, char **, const char *);
extern char ** __cdecl _capture_argv(
    va_list *,
    const char *,
    char **,
    size_t
    );

#ifdef __cplusplus
}
#endif

#define _INC_INTERNAL
#endif	/* _INC_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\dllcrt0.c ===
/***
*dllcrt0.c - C runtime initialization routine for a DLL with linked-in C R-T
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This the startup routine for a DLL which is linked with its own
*	C run-time code.  It is similar to the routine _mainCRTStartup()
*	in the file CRT0.C, except that there is no main() in a DLL.
*
*Revision History:
*	05-04-92  SKS	Based on CRT0.C (start-up code for EXE's)
*	08-26-92  SKS	Add _osver, _winver, _winmajor, _winminor
*	09-16-92  SKS	This module used to be enabled only in LIBCMT.LIB,
*			but it is now enabled for LIBC.LIB as well!
*	09-29-92  SKS	_CRT_INIT needs to be WINAPI, not cdecl
*	10-16-92  SKS	Call _heap_init before _mtinit (fix copied from CRT0.C)
*	10-24-92  SKS	Call to _mtdeletelocks() must be under #ifdef MTHREAD!
*	04-16-93  SKS	Call _mtterm instead of _mtdeletelocks on
*			PROCESS_DETACH to do all multi-thread cleanup
*			It will call _mtdeletelocks and free up the TLS index.
*	04-27-93  GJF	Removed support for _RT_STACK, _RT_INTDIV,
*			_RT_INVALDISP and _RT_NONCONT.
*	05-11-93  SKS	Add _DllMainCRTStartup to co-exist with _CRT_INIT
*			_mtinit now returns 0 or 1, no longer calls _amsg_exit
*			Delete obsolete variable _atopsp
*	06-03-93  GJF	Added __proc_attached flag.
*	06-08-93  SKS	Clean up failure handling in _CRT_INIT
*	12-13-93  SKS	Free up per-thread CRT data on DLL_THREAD_DETACH
*			using a call to _freeptd() in _CRT_INIT()
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <process.h>


/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int __proc_attached = 0;


#pragma data_seg()

/*
 * User routine DllMain is called on all notifications
 */

extern BOOL WINAPI DllMain(
	HANDLE	hDllHandle,
	DWORD	dwReason,
	LPVOID	lpreserved
	) ;


/***
*BOOL WINAPI _CRT_INIT(hDllHandle, dwReason, lpreserved) - C Run-Time
*	initialization for a DLL linked with a C run-time library.
*
*Purpose:
*	This routine does the C run-time initialization.
*	For the multi-threaded run-time library, it also cleans up the
*	multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*	This routine should either be the entry-point for the DLL
*	or else be called by the entry-point routine for the DLL.
*
*******************************************************************************/

BOOL WINAPI _CRT_INIT(
	HANDLE	hDllHandle,
	DWORD	dwReason,
	LPVOID	lpreserved
	)
{
	/*
	 * Start-up code only gets executed when the process is initialized
	 */
	if ( dwReason != DLL_PROCESS_ATTACH ) {

		if ( dwReason == DLL_PROCESS_DETACH ) {
		    /*
		     * make sure there has been prior process attach
		     * notification!
		     */
		    if ( __proc_attached > 0 ) {
			__proc_attached--;

			if ( _C_Termination_Done == FALSE )
				/* do exit() time clean-up */
				_cexit();
		/*
		 * Any basic clean-up code that goes here must be duplicated
		 * below in _DllMainCRTStartup for the case where the user's
		 * DllMain() routine fails on a Process Attach notification.
		 * This does not include calling user C++ destructors, etc.
		 */
			/* delete MT locks, free TLS index, etc. */
			_mtterm();
		    }
		    else
			/* no prior process attach, just return */
			return FALSE;
		}

		return TRUE;
	}

	/*
	 * increment flag to indicate process attach notification has been
	 * received
	 */
	__proc_attached++;

	if(!_mtinit())			/* initialize multi-thread */
		return FALSE;		/* fail to load DLL */

	_cinit();				/* do C data initialize */

	return TRUE;				/* initialization succeeded */
}


/***
*BOOL WINAPI _DllMainCRTStartup(hDllHandle, dwReason, lpreserved) -
*	C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*	This routine does the C run-time initialization or termination
*	and then calls the user code notification handler "DllMain".
*	For the multi-threaded run-time library, it also cleans up the
*	multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*	This routine should be the entry point for the DLL if
*	the user is not supplying one and calling _CRT_INIT.
*
*******************************************************************************/
BOOL WINAPI _DllMainCRTStartup(
	HANDLE	hDllHandle,
	DWORD	dwReason,
	LPVOID	lpreserved
	)
{
    BOOL retcode = TRUE;
    
    /*
    * If this is a process attach notification, increment the process
    * attached flag. If this is a process detach notification, check
    * that there has been a prior process attach notification.
    */
    if ( dwReason == DLL_PROCESS_ATTACH ) {
        __proc_attached++;
    } else if ( dwReason == DLL_PROCESS_DETACH ) {
        if ( __proc_attached > 0 )
            __proc_attached--;
        else
            /*
            * no prior process attach notification. just return
            * without doing anything.
            */
            return FALSE;
    }
    
    if ( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH )
        retcode = _CRT_INIT(hDllHandle, dwReason, lpreserved);
    
    if ( retcode )
        retcode = DllMain(hDllHandle, dwReason, lpreserved);
    
    /*
    * If _CRT_INIT successfully handles a Process Attach notification
    * but the user's DllMain routine returns failure, we need to do
    * clean-up of the C run-time similar to what _CRT_INIT does on a
    * Process Detach Notification.
    */
    
    if ( retcode == FALSE && dwReason == DLL_PROCESS_ATTACH )
        {
            /* Failure to attach DLL - must clean up C run-time */
            _mtterm();
        }
    
    if ( dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH )
        {
            if ( _CRT_INIT(hDllHandle, dwReason, lpreserved) == FALSE )
                retcode = FALSE ;
        }
    
    return retcode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\isctype.c ===
/***
*isctype.c - support is* ctype functions/macros for two-byte multibyte chars
*
*	Copyright (c) 1991-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _isctype.c - support is* ctype functions/macros for
*	two-byte multibyte chars.
*
*Revision History:
*	10-11-91  ETC	Created.
*	12-08-91  ETC	Updated api; added multhread lock; check char masks.
*	04-06-92  KRS	Fix logic error in return value.
*	08-07-92  GJF	_CALLTYPE4 (bogus usage) -> _CRTAPI1 (legit).
*	01-19-93  CFW	Change C1_* to new names, call new APIs.
*	03-04-93  CFW	Removed CTRL-Z.
*	04-01-93  CFW	Remove EOF test (handled by array), return masked.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*
*******************************************************************************/
#include <windows.h>
#include <cruntime.h>
#include <setlocal.h>

#if defined(_INTL) && !defined(_NTSUBSET_)

/*
 *  Use GetCharType() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if	_UPPER   != C1_UPPER 		|| \
	   _LOWER   != C1_LOWER		   || \
	   _DIGIT   != C1_DIGIT		   || \
	   _SPACE   != C1_SPACE		   || \
	   _PUNCT   != C1_PUNCT	      || \
	   _CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif

/***
*_isctype - support is* ctype functions/macros for two-byte multibyte chars
*
*Purpose:
*	This function is called by the is* ctype functions/macros
*	(e.g. isalpha()) when their argument is a two-byte multibyte char.
*	Returns true or false depending on whether the argument satisfies
*	the character class property encoded by the mask.
*
*Entry:
*	int c - the multibyte character whose type is to be tested
*	unsigned int mask - the mask used by the is* functions/macros
*		       corresponding to each character class property
*
*	The leadbyte and the trailbyte should be packed into the int c as:
*
*	H.......|.......|.......|.......L
*	    0       0   leadbyte trailbyte
*
*Exit:
*	Returns non-zero if c is of the character class.
*	Returns 0 if c is not of the character class.
*
*Exceptions:
*	Returns 0 on any error.
*
*******************************************************************************/

int __cdecl _isctype (
	int c,
	int mask
	)
{
	wchar_t widechar[2], chartype;
	char buffer[3];

	/* c valid between -1 and 255 */
	if (((unsigned)(c + 1)) <= 256)
	    return _pctype[c] & mask;
	
//	_mlock (_LC_CTYPE_LOCK);

   if (isleadbyte(c>>8 & 0xff))
   {
      buffer[0] = (c>>8 & 0xff); /* put lead-byte at start of str */
      buffer[1] = (char)c;
      buffer[2] = 0;
   }
   else
   {
      buffer[0] = (char)c;
      buffer[1] = 0;
   }
   if (MultiByteToWideChar(_lc_codepage, MB_PRECOMPOSED,
         buffer, -1, widechar, 2) == 0)
      return 0;

//	_munlock (_LC_CTYPE_LOCK);

	if (GetStringTypeW(CT_CTYPE1, widechar, 2, &chartype) != NO_ERROR) {
		return 0;
	}

	return (int)(chartype & mask);
}

#else /* defined(_INTL) && !defined(_NTSUBSET_) */

int __cdecl _isctype (
	int c,
	int mask
	)
{
    return 0;
}

#endif /* _INTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\nlsdata1.c ===
/***
*nlsdata1.c - globals for international library - small globals
*
*	Copyright (c) 1991-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module contains the globals:  __mb_cur_max, _decimal_point,
*	_decimal_point_length.  This module is always required.
*	This module is separated from nlsdatax.c for granularity.
*
*Revision History:
*	12-01-91  ETC	Created.
*	04-03-92  PLM	Changes tdef.h to tchar.h
*	08-18-92  KRS	Rip out _tflag--not used.
*
*******************************************************************************/


/*
 *  Value of MB_CUR_MAX macro.
 */
unsigned short __mb_cur_max = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;	Copyright (c) 1987-1994, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file contains definitions of a number of macros which
;	make the writing of memory model dependent code for the
;	386 a little easier and more portable.
;
;Revision History:
;	05-18-89  SKS	Removed ES references from pointer macros -- DS is used
;	09-01-89  GJF	Fixed copyright date.
;	11-19-93  SMK	Modified for 32 bit hosting.
;
;*******************************************************************************

; general code & data size constants & macros

DAT_ADDR_SZ =	4
BDAT_ADDR_SZ =	2

TXT_ADDR_SZ =	4

; Big/Little Endian Definitions for Long Integers

ifdef	bigend			; Big Endian (hi word at low address)
LOWORD	equ	[4]
HIWORD	equ	[0]
else				; Little Endian (low word at low address)
LOWORD	equ	[0]
HIWORD	equ	[4]
endif


; All Model Definitions

BPARGBAS equ	TXT_ADDR_SZ+4	; offset from BP to first argument
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\nlsdata2.c ===
/***
*nlsdata2.c - globals for international library - locale handles and code page
*
*	Copyright (c) 1991-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module defines the locale handles and code page.  The handles are
*	required by almost all locale dependent functions.  This module is
*	separated from nlsdatax.c for granularity.
*
*Revision History:
*	12-01-91  ETC	Created.
*
*******************************************************************************/

#include <windows.h>
#include <setlocal.h>

/*
 *  Code page.
 */
UINT _lc_codepage = _CLOCALECP;		/* CP_ACP */

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\mlock.c ===
#ifdef MTHREAD

/***
*mlock.c - Multi-thread locking routines
*
*	Copyright (c) 1987-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*	05-07-90  JCR	Module created.
*	06-04-90  GJF	Changed error message interface.
*	08-08-90  GJF	Removed 32 from API names.
*	08-08-90  SBM	_lockmap no longer 8 times required size
*	10-08-90  GJF	New-style function declarators. Removed questionable
*			return statements from void functions (weren't needed
*			and the compiler was bitching).
*	10-09-90  GJF	Thread ids are unsigned longs.
*	06-06-91  GJF	Adapted for Win32 [_WIN32_].
*	09-29-91  GJF	Fixed infinite recursion problem with DEBUG version
*			of _lock [_WIN32_].
*	03-06-92  GJF	Removed _[un]lock_fh() and _[un]lock_stream for Win32
*			targets.
*	05-28-92  GJF	Added _mtdeletelocks() for Win32 for DLLs with contain
*			the C runtime (e.g., crtdll.dll).
*	10-06-92  SRW	Make _locktable an array of PCRITICAL_SECTION pointers
*			instead of structures.	Allocate each critical section
*			as it is needed.
*	02-25-93  GJF	Substantially revised. Restored static critical section
*			structures for some locks. Replaced bit-array scheme
*			of keeping track of locks. Removed Cruiser support and
*			replaced obsolete DEBUG code.
*	03-03-93  GJF	Made CRITICAL_SECTION structure for _HEAP_LOCK static.
*	03-08-93  SKS	Fix ptr use error in DEBUG version of _mtdeletelocks
*	03-08-93  SKS	Fix deletion of the special critical sections,
*			especially the heap lock.
*	05-05-93  GJF	Turned DEBUG code off.
*       06-03-93  SRW   Disable FPO optimizations for this file so it can call
*                       CriticalSection routines on a checked build even though
*                       the C Runtimes are compiled free.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <cruntime.h>
#include <internal.h>
#include <os2dll.h>
#include <assert.h>


/*
 * Local routines
 */
void __cdecl _lockerr_exit(char *);


/*
 * Global Data
 */

/*
 * Statically allocated critical section structures for _LOCKTAB_LOCK,
 * _EXIT_LOCK1.
 */
static CRITICAL_SECTION xlcritsect;

/*
 * Lock Table
 * This table contains a pointer to the critical section management structure
 * for each lock.
 */
PCRITICAL_SECTION _locktable[_TOTAL_LOCKS] = {
	NULL,		/* 0  == no lock defined   *** OBSOLETE ***	*/
	&xlcritsect	/* 1 == _EXIT_LOCK1	   */
	};

#pragma data_seg()

#pragma optimize("y",off)

/***
*_mtinitlocks() - Initialize multi-thread lock scheme
*
*Purpose:
*	Perform whatever initialization is required for the multi-thread
*	locking (synchronization) scheme. This routine should be called
*	exactly once, during startup, and this must be before any requests
*	are made to assert locks.
*
*	NOTES: In Win32, the multi-thread locks are created individually,
*	each upon its first use. That is when any particular lock is asserted
*	for the first time, the underlying critical section is then allocated,
*	initialized and (finally) entered. This allocation and initialization
*	is protected under _LOCKTAB_LOCK. It is _mtinitlocks' job to set up
*	_LOCKTAB_LOCK. _EXIT_LOCK1 is also set up by _mtinitlock
*
*Entry:
*       <none>
*
*Exit:
*       returns TRUE on success, FALSE otherwise
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocks (
        void
        )
{

        /*
	 * All we need to do is initialize _EXIT_LOCK1.
	 */
	LONG status;
	status = RtlInitializeCriticalSection( _locktable[_EXIT_LOCK1] );
	return NT_SUCCESS(status) ? TRUE : FALSE;
}


/***
*_mtdeletelocks() - Delete all initialized locks
*
*Purpose:
*       Walks _locktable[] and _lockmap, and deletes every 'lock' (i.e.,
*       critical section) which has been initialized.
*
*       This function is intended for use in DLLs containing the C runtime
*       (i.e., crtdll.dll and user DLLs built using libcmt.lib and the
*       special startup objects). It is to be called from within the DLL's
*       entrypoint function when that function is called with
*       DLL_PROCESS_DETACH.
*
*Entry:
*       <none>
*
*Exit:
*
*Exceptions:
*       behavior undefined/unknown if a lock is being held when this routine
*       is called.
*
*******************************************************************************/

void __cdecl _mtdeletelocks(
        void
        )
{
	// No need to check for lock validity, this function will not get called
	// unless we successfully loaded the dll
	DeleteCriticalSection( _locktable[_EXIT_LOCK1] );
}


/***
* _lock - Acquire a multi-thread lock
*
*Purpose:
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock (
        int locknum
        )
{
        assert (_locktable[locknum]);

	EnterCriticalSection( _locktable[locknum] );
}


/***
* _unlock - Release multi-thread lock
*
*Purpose:
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to release
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock (
        int locknum
        )
{
        /*
         * leave the critical section.
         */
	LeaveCriticalSection( _locktable[locknum] );
}

#pragma optimize("y",on)

#endif  /* MTHREAD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\os2dll.h ===
/***
*os2dll.h - DLL/Multi-thread include
*
*	Copyright (c) 1987-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*	10-27-87  JCR	Module created.
*	11-13-87  SKS	Added _HEAP_LOCK
*	12-15-87  JCR	Added _EXIT_LOCK
*	01-07-88  BCM	Added _SIGNAL_LOCK; upped MAXTHREADID from 16 to 32
*	02-01-88  JCR	Added _dll_mlock/_dll_munlock macros
*	05-02-88  JCR	Added _BHEAP_LOCK
*	06-17-88  JCR	Corrected prototypes for special mthread debug routines
*	08-15-88  JCR	_check_lock now returns int, not void
*	08-22-88  GJF	Modified to also work for the 386 (small model only)
*	06-05-89  JCR	386 mthread support
*	06-09-89  JCR	386: Added values to _tiddata struc (for _beginthread)
*	07-13-89  JCR	386: Added _LOCKTAB_LOCK
*	08-17-89  GJF	Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*	10-30-89  GJF	Fixed copyright
*	01-02-90  JCR	Moved a bunch of definitions from os2dll.inc
*	04-06-90  GJF	Added _INC_OS2DLL stuff and #include <cruntime.h>. Made
*			all function _CALLTYPE2 (for now).
*	04-10-90  GJF	Added prototypes for _[un]lockexit().
*	08-16-90  SBM	Made _terrno and _tdoserrno int, not unsigned
*	09-14-90  GJF	Added _pxcptacttab, _pxcptinfoptr and _fpecode fields
*			to _tiddata struct.
*	10-09-90  GJF	Thread ids are of type unsigned long.
*	12-06-90  SRW	Added _OSFHND_LOCK
*	06-04-91  GJF	Win32 version of multi-thread types and prototypes.
*	08-15-91  GJF	Made _tdoserrno an unsigned long for Win32.
*	08-20-91  JCR	C++ and ANSI naming
*	09-29-91  GJF	Conditionally added prototypes for _getptd_lk
*			and  _getptd1_lk for Win32 under DEBUG.
*	10-03-91  JCR	Added _cvtbuf to _tiddata structure
*	02-17-92  GJF	For Win32, replaced _NFILE_ with _NHANDLE_ and
*			_NSTREAM_.
*	03-06-92  GJF	For Win32, made _[un]mlock_[fh|stream]() macros
*			directly call _[un]lock().
*	03-17-92  GJF	Dropped _namebuf field from _tiddata structure for
*			Win32.
*	08-05-92  GJF	Function calling type and variable type macros.
*	12-03-91  ETC	Added _wtoken to _tiddata, added intl LOCK's;
*			added definition of wchar_t (needed for _wtoken).
*	08-14-92  KRS	Port ETC's _wtoken change from other tree.
*	08-21-92  GJF	Merged 08-05-92 and 08-14-92 versions.
*	12-03-92  KRS	Added _mtoken field for MTHREAD _mbstok().
*	01-21-93  GJF	Removed support for C6-386's _cdecl.
*	02-25-93  GJF	Purged Cruiser support and many outdated definitions
*			and declarations.
*	12-14-93  SKS	Add _freeptd(), which frees per-thread CRT data
*
****/

#ifndef _INC_OS2DLL

#ifdef __cplusplus
extern "C" {
#endif

#include <cruntime.h>

/* Lock symbols */

#define _EXIT_LOCK1	1	/* lock #1 for exit code		*/

#define _TOTAL_LOCKS	   (_EXIT_LOCK1+1)		/* Total number of locks */

#define _LOCK_BIT_INTS	   (_TOTAL_LOCKS/(sizeof(unsigned)*8))+1   /* # of ints to hold lock bits */


/* need wchar_t for _wtoken field in _tiddata */
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* macros */

#define _mlock(l)			_lock(l)
#define _munlock(l)			_unlock(l)


/* multi-thread routines */

void __cdecl _lock(int);
void __cdecl _lockexit(void);
void __cdecl _unlock(int);
void __cdecl _unlockexit(void);


#ifdef __cplusplus
}
#endif

#define _INC_OS2DLL
#endif	/* _INC_OS2DLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\purevirt.c ===
/***
*purevirt.c - stub to trap pure virtual function calls
*
*	Copyright (c) 1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _purecall() -
*
*Revision History:
*	09-30-92  GJF	Module created
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>

/***
*void _purecall(void) -
*
*Purpose:
*
*Entry:
*	No arguments
*
*Exit:
*	Never returns
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _purecall(
	void
	)
{
#if DBG==1
    MessageBoxA (NULL  
                 "Pure virtual function call attempted",
                 "OLE runtime error",
                 MB_ICONSTOP | MB_OK | MB_TASKMODAL);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\onexit.c ===
/***
*onexit.c - save function for execution on exit
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _onexit(), atexit() - save function for execution at exit
*

*Revision History:
*	06-30-89  PHG	module created, based on asm version
*	03-15-90  GJF	Replace _cdecl with _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also,
*			cleaned up the formatting a bit.
*	05-21-90  GJF	Fixed compiler warning.
*	10-04-90  GJF	New-style function declarators.
*	12-28-90  SRW	Added casts of func for Mips C Compiler
*	01-21-91  GJF	ANSI naming.
*	09-09-91  GJF	Revised for C++ needs.
*	03-20-92  SKS	Revamped for new initialization model
*	04-23-92  DJM	POSIX support.
*	12-02-93  SKS	Add __dllonexit for DLLs using CRTDLL.DLL
*
*******************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <cruntime.h>
#include <internal.h>
#include <os2dll.h>


#ifndef _CHICAGO_
extern void DbgBreakPoint();
#endif

typedef void (_CALLTYPE1 *PF)(void);	   /* pointer to function */


//
//      Keep this really simple: just have a vector of functions to be
//      called.  We use a fixed length vector, since this is a special
//      application
//

#define MAX_EXIT_NOTIFICATIONS 48

PF NotificationTable[MAX_EXIT_NOTIFICATIONS];

extern PF * __onexitbegin;
extern PF * __onexitend;


/*
 * Define increment (in entries) for growing the _onexit/atexit table
 */
#define ONEXITTBLINCR	4


/***
*_onexit(func), atexit(func) - add function to be executed upon exit
*
*Purpose:
*	The _onexit/atexit functions are passed a pointer to a function
*	to be called when the program terminate normally.  Successive
*	calls create a register of functions that are executed last in,
*	first out.
*
*Entry:
*	void (*func)() - pointer to function to be executed upon exit
*
*Exit:
*	onexit:
*		Success - return pointer to user's function.
*		Error - return NULL pointer.
*	atexit:
*		Success - return 0.
*		Error - return non-zero value.
*
*Notes:
*	This routine depends on the behavior of _initterm() in CRT0DAT.C.
*	Specifically, _initterm() must not skip the address pointed to by
*	its first parameter, and must also stop before the address pointed
*	to by its second parameter.  This is because _onexitbegin will point
*	to a valid address, and _onexitend will point at an invalid address.
*
*Exceptions:
*
*******************************************************************************/


_onexit_t _CALLTYPE1 _onexit (
    _onexit_t func
    )

{
    PF	*p;
    
    _lockexit();			/* lock the exit code */
    
    // If the notification table hasn't been initialized, do so
    
    if (__onexitbegin == NULL) {
        __onexitbegin = __onexitend = NotificationTable;
    } else if (__onexitend >= &NotificationTable[MAX_EXIT_NOTIFICATIONS]) {
        //  No space...
#if DBG
        OutputDebugString ("(common\\cruntime\\onexit.c\\_onexit) Too many exit notifications!\n");
        DebugBreak ();
#endif
        return NULL;
    }
    
    
    //
    // Put the new entry into the table and update the end-of-table
    // pointer.
    //
    
    *(__onexitend++) = (PF)func;
    
    _unlockexit();
    
    return func;
    
}

int _CALLTYPE1 atexit (
    PF func
    )
{
    return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*	Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the modeflag values for spawnxx calls.
*	Only P_WAIT and P_OVERLAY are currently implemented on MS-DOS.
*	Also contains the function argument declarations for all
*	process control related routines.
*
*Revision History:
*	08/24/87  JCR	Added P_NOWAITO
*	10/20/87  JCR	Removed "MSC40_ONLY" entries and "MSSDK_ONLY" comments
*	12-11-87  JCR	Added "_loadds" functionality
*	12-18-87  JCR	Added _FAR_ to declarations
*	01-11-88  JCR	Added _beginthread/_endthread
*	01-15-88  JCR	Got rid of _p_overlay for MTRHEAD/DLL
*	02-10-88  JCR	Cleaned up white space
*	05-08-88  SKS	Removed bogus comment about "DOS 4"; Added "P_DETACH"
*	08-22-88  GJF	Modified to also work for the 386 (small model only)
*	09-14-88  JCR	Added _cexit and _c_exit declarations
*	05-03-89  JCR	Added _INTERNAL_IFSTRIP for relinc usage
*	06-08-89  JCR	386 _beginthread does NOT take a stackpointer arg
*	08-01-89  GJF	Cleanup, now specific to OS/2 2.0 (i.e., 386 flat model)
*	10-30-89  GJF	Fixed copyright
*	11-02-89  JCR	Changed "DLL" to "_DLL"
*	11-17-89  GJF	Added const attribute to appropriate arg types
*	03-01-90  GJF	Added #ifndef _INC_PROCESS and #include <cruntime.h>
*			stuff. Also, removed some (now) useless preprocessor
*			directives.
*	03-21-90  GJF	Replaced _cdecl with _CALLTYPE1 or _CALLTYPE2 in
*			prototypes.
*	04-10-90  GJF	Replaced remaining instances of _cdecl (with _CALLTYPE1
*			or _VARTYPE1, as appropriate).
*	10-12-90  GJF	Changed return type of _beginthread() to unsigned long.
*	01-17-91  GJF	ANSI naming.
*	08-20-91  JCR	C++ and ANSI naming
*	08-26-91  BWM	Added prototypes for _loaddll, unloaddll, and
*			_getdllprocaddr.
*	09-28-91  JCR	ANSI names: DOSX32=prototypes, WIN32=#defines for now
*	07-22-92  GJF	Deleted references to _wait for Win32.
*	08-05-92  GJF	Function calling type and variable type macros.
*	08-28-92  GJF	#ifdef-ed out for POSIX.
*	09-03-92  GJF	Merged two changes above.
*	01-21-93  GJF	Removed support for C6-386's _cdecl.
*
****/

#ifndef _INC_PROCESS

#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _INTERNAL_IFSTRIP_
#include <cruntime.h>
#endif	/* _INTERNAL_IFSTRIP_ */

/* modeflag values for _spawnxx routines */

#ifndef MTHREAD
extern int _CRTVAR1 _p_overlay;
#endif

#define _P_WAIT 	0
#define _P_NOWAIT	1
#ifdef	MTHREAD
#define _P_OVERLAY	2
#else
#define _P_OVERLAY	_p_overlay
#endif
#define _OLD_P_OVERLAY	2
#define _P_NOWAITO	3
#define _P_DETACH	4


/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with OS/2 */

#define _WAIT_CHILD	 0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef MTHREAD
unsigned long  __cdecl _beginthread (void (__cdecl *) (void *),
	unsigned, void *);
void __cdecl _endthread(void);
#endif
void __cdecl abort(void);
void __cdecl _cexit(void);
void __cdecl _c_exit(void);
int __cdecl _cwait(int *, int, int);
int __cdecl _execl(const char *, const char *, ...);
int __cdecl _execle(const char *, const char *, ...);
int __cdecl _execlp(const char *, const char *, ...);
int __cdecl _execlpe(const char *, const char *, ...);
int __cdecl _execv(const char *, const char * const *);
int __cdecl _execve(const char *, const char * const *, const char * const *);
int __cdecl _execvp(const char *, const char * const *);
int __cdecl _execvpe(const char *, const char * const *, const char * const *);
void __cdecl exit(int);
void __cdecl _exit(int);
int __cdecl _getpid(void);
int __cdecl _spawnl(int, const char *, const char *, ...);
int __cdecl _spawnle(int, const char *, const char *, ...);
int __cdecl _spawnlp(int, const char *, const char *, ...);
int __cdecl _spawnlpe(int, const char *, const char *, ...);
int __cdecl _spawnv(int, const char *, const char * const *);
int __cdecl _spawnve(int, const char *, const char * const *,
	const char * const *);
int __cdecl _spawnvp(int, const char *, const char * const *);
int __cdecl _spawnvpe(int, const char *, const char * const *,
	const char * const *);
int __cdecl system(const char *);
#ifndef _WIN32_
int __cdecl _wait(int *);
#endif
int __cdecl _loaddll(char *);
int __cdecl _unloaddll(int);
int (__cdecl * __cdecl _getdllprocaddr(int, char *, int))();

#ifdef _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *	The preferred method is for the user to provide DllMain() which will
 *	be called automatically by the DLL entry point defined by the C run-
 *	time library code.  If the user wants to define the DLL entry point
 *	routine, the user's entry point must call _CRT_INIT on all types of
 *	notifications, as the very first thing on attach notifications and
 *	as the very last thing on detach notifications.
 */
#ifdef _WINDOWS_	/* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
#else
#ifdef _M_IX86
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
#else
int DllMain(void *, unsigned, void *);
int _CRT_INIT(void *, unsigned, void *);
#endif
#endif /* _WINDOWS_ */
#endif /* _DECL_DLLMAIN */

#if !__STDC__
/* Non-ANSI names for compatibility */

#define P_WAIT		_P_WAIT
#define P_NOWAIT	_P_NOWAIT
#define P_OVERLAY	_P_OVERLAY
#define OLD_P_OVERLAY	_OLD_P_OVERLAY
#define P_NOWAITO	_P_NOWAITO
#define P_DETACH	_P_DETACH

#define WAIT_CHILD	_WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

#ifndef _DOSX32_
#define cwait	 _cwait
#define execl	 _execl
#define execle	 _execle
#define execlp	 _execlp
#define execlpe  _execlpe
#define execv	 _execv
#define execve	 _execve
#define execvp	 _execvp
#define execvpe  _execvpe
#define getpid	 _getpid
#define spawnl	 _spawnl
#define spawnle  _spawnle
#define spawnlp  _spawnlp
#define spawnlpe _spawnlpe
#define spawnv	 _spawnv
#define spawnve  _spawnve
#define spawnvp  _spawnvp
#define spawnvpe _spawnvpe
#ifndef _WIN32_
#define wait	 _wait
#endif
#else
int __cdecl cwait(int *, int, int);
int __cdecl execl(const char *, const char *, ...);
int __cdecl execle(const char *, const char *, ...);
int __cdecl execlp(const char *, const char *, ...);
int __cdecl execlpe(const char *, const char *, ...);
int __cdecl execv(const char *, const char * const *);
int __cdecl execve(const char *, const char * const *, const char * const *);
int __cdecl execvp(const char *, const char * const *);
int __cdecl execvpe(const char *, const char * const *, const char * const *);
int __cdecl getpid(void);
int __cdecl spawnl(int, const char *, const char *, ...);
int __cdecl spawnle(int, const char *, const char *, ...);
int __cdecl spawnlp(int, const char *, const char *, ...);
int __cdecl spawnlpe(int, const char *, const char *, ...);
int __cdecl spawnv(int, const char *, const char * const *);
int __cdecl spawnve(int, const char *, const char * const *,
	const char * const *);
int __cdecl spawnvp(int, const char *, const char * const *);
int __cdecl spawnvpe(int, const char *, const char * const *,
	const char * const *);
#ifndef _WIN32_
int __cdecl wait(int *);
#endif
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif	/* _POSIX_ */

#define _INC_PROCESS
#endif	/* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\setlocal.h ===
/***
*setlocal.h - internal definitions used by locale-dependent functions.
*
*	Copyright (c) 1991-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains internal definitions/declarations for locale-dependent
*	functions, in particular those required by setlocale().
*	[Internal]
*
*Revision History:
*	10-16-91  ETC	32-bit version created from 16-bit setlocal.c
*	12-20-91  ETC	Removed GetLocaleInfo structure definitions.
*	08-18-92  KRS	Make _CLOCALEHANDLE == LANGNEUTRAL HANDLE = 0.
*	12-17-92  CFW	Added LC_ID, LCSTRINGS, and GetQualifiedLocale
*	12-17-92  KRS	Change value of NLSCMPERROR from 0 to INT_MAX.
*	01-08-93  CFW	Added LC_*_TYPE and _getlocaleinfo (wrapper) prototype.
*	01-13-93  KRS	Change LCSTRINGS back to LC_STRINGS for consistency.
*			Change _getlocaleinfo prototype again.
*	02-08-93  CFW	Added time defintions from locale.h, added 'const' to
*			GetQualifiedLocale prototype, added _lconv_static_*.
*	02-16-93  CFW	Changed time defs to long and short.
*	03-17-93  CFW	Add language and country info definitions.
*  03-23-93  CFW	Add _ to GetQualifiedLocale prototype.
*  03-24-93  CFW	Change to _get_qualified_locale.
*
****/

#ifndef _INC_SETLOCAL

#ifdef __cplusplus
extern "C" {
#endif

#define _CLOCALECP	CP_ACP		/* "C" locale Code page (ANSI 8859) */

extern UINT _lc_codepage;	/* code page */

#ifdef __cplusplus
}
#endif

#define _INC_SETLOCAL
#endif	/* _INC_SETLOCAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\qsort.c ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	To implement the qsort() routine for sorting arrays.
*
*Revision History:
*	06-22-84  RN	author
*	03-25-85  RN	added pre-check for elements already in order to
*			eliminate worst-case behavior.
*	05-18-86  TC	changed to recurse on the smallest piece to avoid
*			piece. unneccesary stack usage, and to iterate on
*			largest
*	01-09-87  BCM	fixed huge-array case where (num-1) * wid computation
*			was overflowing (large/compact models only)
*	06-13-89  PHG	made more efficient, many more comments, removed
*			recursion
*	10-30-89  JCR	Added _cdecl to prototypes
*	03-15-90  GJF	Replaced _cdecl with _CALLTYPE1 and added #include
*			<cruntime.h>. Also, fixed the copyright.
*	04-05-90  GJF	Made shortsort() and swap() _CALLTYPE4. Also, added
*			#include <search.h>.
*	10-04-90  GJF	New-style function declarators.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragmas
*	01-24-91  SRW	Added missing close comment in swap procedure
*	11-19-91  GJF	Do the swap one character at a time to avoid alignment
*			woes.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <search.h>

/* prototypes for local routines */
static void _CALLTYPE4 shortsort(char *lo, char *hi, unsigned width,
		      int (_CALLTYPE1 *comp)(const void *, const void *));
static void _CALLTYPE4 swap(char *p, char *q, unsigned int width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8	    /* testing shows that this is good value */


/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*	quicksort the array of elements
*	side effects:  sorts in place
*
*Entry:
*	char *base = pointer to base of array
*	unsigned num  = number of elements in the array
*	unsigned width = width in bytes of each array element
*	int (*comp)() = pointer to function returning analog of strcmp for
*		strings, but supplied by user for comparing the array elements.
*		it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*		1=2, pos if 1>2.
*
*Exit:
*	returns void
*
*Exceptions:
*
*******************************************************************************/

#ifdef	_CRUISER_
#pragma check_stack(on) 	/* lots of locals */
#endif  /* ndef _CRUISER_ */

/* sort the array between lo and hi (inclusive) */

void _CALLTYPE1 qsort (
    void *base,
    unsigned num,
    unsigned width,
    int (_CALLTYPE1 *comp)(const void *, const void *)
    )
{
    char *lo, *hi;		/* ends of sub-array currently sorting */
    char *mid;			/* points to middle of subarray */
    char *loguy, *higuy;	/* traveling pointers for partition step */
    unsigned size;		/* size of the sub-array */
    char *lostk[30], *histk[30];
    int stkptr; 		/* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
	return; 		/* nothing to do */

    stkptr = 0; 		/* initialize stack */

    lo = base;
    hi = (char *)base + width * (num-1);	/* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;	 /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
	 shortsort(lo, hi, width, comp);
    }
    else {
	/* First we pick a partititioning element.  The efficiency of the
	   algorithm demands that we find one that is approximately the
	   median of the values, but also that we select one fast.  Using
	   the first one produces bad performace if the array is already
	   sorted, so we use the middle one, which would require a very
	   wierdly arranged array for worst case performance.  Testing shows
	   that a median-of-three algorithm does not, in general, increase
	   performance. */

	mid = lo + (size / 2) * width;	    /* find middle element */
	swap(mid, lo, width);		    /* swap it to beginning of array */

	/* We now wish to partition the array into three pieces, one
	   consisiting of elements <= partition element, one of elements
	   equal to the parition element, and one of element >= to it.	This
	   is done below; comments indicate conditions established at every
	   step. */

	loguy = lo;
	higuy = hi + width;

	/* Note that higuy decreases and loguy increases on every iteration,
	   so loop must terminate. */
	for (;;) {
	    /* lo <= loguy < hi, lo < higuy <= hi + 1,
	       A[i] <= A[lo] for lo <= i <= loguy,
	       A[i] >= A[lo] for higuy <= i <= hi */

	    do	{
		loguy += width;
	    } while (loguy <= hi && comp(loguy, lo) <= 0);

	    /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
	       either loguy > hi or A[loguy] > A[lo] */

	    do	{
		higuy -= width;
	    } while (higuy > lo && comp(higuy, lo) >= 0);

	    /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
	       either higuy <= lo or A[higuy] < A[lo] */

	    if (higuy < loguy)
		break;

	    /* if loguy > hi or higuy <= lo, then we would have exited, so
	       A[loguy] > A[lo], A[higuy] < A[lo],
	       loguy < hi, highy > lo */

	    swap(loguy, higuy, width);

	    /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
	       of loop is re-established */
	}

	/*     A[i] >= A[lo] for higuy < i <= hi,
	       A[i] <= A[lo] for lo <= i < loguy,
	       higuy < loguy, lo <= higuy <= hi
	   implying:
	       A[i] >= A[lo] for loguy <= i <= hi,
	       A[i] <= A[lo] for lo <= i <= higuy,
	       A[i] = A[lo] for higuy < i < loguy */

	swap(lo, higuy, width);     /* put partition element in place */

	/* OK, now we have the following:
	      A[i] >= A[higuy] for loguy <= i <= hi,
	      A[i] <= A[higuy] for lo <= i < higuy
	      A[i] = A[lo] for higuy <= i < loguy    */

	/* We've finished the partition, now we want to sort the subarrays
	   [lo, higuy-1] and [loguy, hi].
	   We do the smaller one first to minimize stack usage.
	   We only sort arrays of length 2 or more.*/

	if ( higuy - 1 - lo >= hi - loguy ) {
	    if (lo + width < higuy) {
		lostk[stkptr] = lo;
		histk[stkptr] = higuy - width;
		++stkptr;
	    }				/* save big recursion for later */

	    if (loguy < hi) {
		lo = loguy;
		goto recurse;		/* do small recursion */
	    }
	}
	else {
	    if (loguy < hi) {
		lostk[stkptr] = loguy;
		histk[stkptr] = hi;
		++stkptr;		/* save big recursion for later */
	    }

	    if (lo + width < higuy) {
		hi = higuy - width;
		goto recurse;		/* do small recursion */
	    }
	}
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
	lo = lostk[stkptr];
	hi = histk[stkptr];
	goto recurse;		/* pop subarray from stack */
    }
    else
	return; 		/* all subarrays done */
}

#ifdef	_CRUISER_
#pragma check_stack()	    /* revert to command line behaviour */
#endif  /* ndef _CRUISER_ */


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*	sorts the sub-array of elements between lo and hi (inclusive)
*	side effects:  sorts in place
*	assumes that lo < hi
*
*Entry:
*	char *lo = pointer to low element to sort
*	char *hi = pointer to high element to sort
*	unsigned width = width in bytes of each array element
*	int (*comp)() = pointer to function returning analog of strcmp for
*		strings, but supplied by user for comparing the array elements.
*		it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*		1=2, pos if 1>2.
*
*Exit:
*	returns void
*
*Exceptions:
*
*******************************************************************************/

static void _CALLTYPE4 shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (_CALLTYPE1 *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
	/* A[i] <= A[j] for i <= j, j > hi */
	max = lo;
	for (p = lo+width; p <= hi; p += width) {
	    /* A[i] <= A[max] for lo <= i < p */
	    if (comp(p, max) > 0) {
		max = p;
	    }
	    /* A[i] <= A[max] for lo <= i <= p */
	}

	/* A[i] <= A[max] for lo <= i <= hi */

	swap(max, hi, width);

	/* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

	hi -= width;

	/* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*	swaps the two array elements of size width
*
*Entry:
*	char *a, *b = pointer to two elements to swap
*	unsigned width = width in bytes of each array element
*
*Exit:
*	returns void
*
*Exceptions:
*
*******************************************************************************/

static void _CALLTYPE4 swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
	/* Do the swap one character at a time to avoid potential alignment
	   problems. */
	while ( width-- ) {
	    tmp = *a;
	    *a++ = *b;
	    *b++ = tmp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\ctime.h ===
/***
*ctime.h - constant for dates and times
*
*	Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Include file used by the ctime routines containing definitions of
*	various constants used in determining dates and times.
*	[Internal]
*
*Revision History:
*	03-??-84  RLB	written
*	05-??-84  DFW	split out the constant from each routine into this file
*	07-27-89  GJF	Fixed copyright
*	10-30-89  GJF	Fixed copyright (again)
*	02-28-90  GJF	Added #ifndef _INC_CTIME stuff.
*	03-29-93  GJF	Revised constants.
*
****/

#ifndef _INC_CTIME

#define _DAY_SEC	   (24L * 60L * 60L)	/* secs in a day */

#define _YEAR_SEC	   (365L * _DAY_SEC)	/* secs in a year */

#define _FOUR_YEAR_SEC	   (1461L * _DAY_SEC)	/* secs in a 4 year interval */

#define _DEC_SEC	   315532800L		/* secs in 1970-1979 */

#define _BASE_YEAR	   70L			/* 1970 is the base year */

#define _BASE_DOW	   4			/* 01-01-70 was a Thursday */

#define _LEAP_YEAR_ADJUST  17L			/* Leap years 1900 - 1970 */

#define _MAX_YEAR	   138L			/* 2038 is the max year */


#define _INC_CTIME
#endif	/* _INC_CTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\tidtable.c ===
/***
*tidtable.c - Access thread data table
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module contains the following routines for multi-thread
*	data support:
*
*	_mtinit        = Initialize the mthread data
*	_getptd        = get the pointer to the per-thread data structure for
*			 the current thread
*	_freeptd       = free up a per-thread data structure and its
*			 subordinate structures
*	__threadid     = return thread ID for the current thread
*	__threadhandle = return pseudo-handle for the current thread
*
*Revision History:
*	05-04-90  JCR	Translated from ASM to C for portable 32-bit OS/2
*	06-04-90  GJF	Changed error message interface.
*	07-02-90  GJF	Changed __threadid() for DCR 1024/2012.
*	08-08-90  GJF	Removed 32 from API names.
*	10-08-90  GJF	New-style function declarators.
*	10-09-90  GJF	Thread ids are of type unsigned long! Also, fixed a
*			bug in __threadid().
*	10-22-90  GJF	Another bug in __threadid().
*	12-04-90  SRW	Changed to include <oscalls.h> instead of <doscalls.h>
*	12-06-90  SRW	Added _CRUISER_ and _WIN32 conditionals.
*	05-31-91  GJF	Win32 version [_WIN32_].
*	07-18-91  GJF	Fixed many errors [_WIN32_].
*	09-29-91  GJF	Conditionally added _getptd_lk/_getptd1_lk so that
*			DEBUG version of mlock doesn't infinitely recurse
*			the first time _THREADDATA_LOCK is asserted [_WIN32_].
*	01-30-92  GJF	Must init. _pxcptacttab field to _XcptActTab.
*	02-25-92  GJF	Initialize _holdrand field to 1.
*	02-13-93  GJF	Revised to use TLS API. Also, purged Cruiser support.
*	03-26-93  GJF	Initialize ptd->_holdrand to 1L (see thread.c).
*	04-16-93  SKS	Add _mtterm to do multi-thread termination
*			Set freed __tlsindex to -1 again to prevent mis-use
*	12-13-93  SKS	Add _freeptd(), which frees up the per-thread data
*			maintained by the C run-time library.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <internal.h>

/****
*_mtinit() - Init multi-thread data bases
*
*Purpose:
*	(1) Call _mtinitlocks to create/open all lock semaphores.
*	(2) Allocate a TLS index to hold pointers to per-thread data
*	    structure.
*
*	NOTES:
*	(1) Only to be called ONCE at startup
*	(2) Must be called BEFORE any mthread requests are made
*
*Entry:
*	<NONE>
*Exit:
*	returns TRUE on success
*	returns FALSE on failure
*		user code should call _amsg_exit if failure is returned
*
*Uses:
*	<any registers may be modified at init time>
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinit (
	void
	)
{


	/*
	 * Initialize the mthread lock data base
	 */

	return _mtinitlocks();

}


/****
*_mtterm() - Clean-up multi-thread data bases
*
*Purpose:
*	(1) Call _mtdeletelocks to free up all lock semaphores.
*	(2) Free up the TLS index used to hold pointers to
*	    per-thread data structure.
*
*	NOTES:
*	(1) Only to be called ONCE at termination
*	(2) Must be called AFTER all mthread requests are made
*
*Entry:
*	<NONE>
*Exit:
*	returns
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _mtterm (
      void
      )
{
	/*
	 * Clean up the mthread lock data base
	 */

	_mtdeletelocks();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\strtol.c ===
/***
*strtol.c - Contains C runtimes strtol and strtoul
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	strtol - convert ascii string to long signed integer
*	strtoul - convert ascii string to long unsigned integer
*
*Revision History:
*	06-05-89  PHG	Module created, based on strtol.asm
*	03-06-90  GJF	Fixed calling type, added #include <cruntime.h>
*			and fixed the copyright. Also, cleaned up the
*			formatting a bit.
*	03-07-90  GJF	Fixed compiler warnings (added const qualifier to
*			an arg type and local var type).
*	03-23-90  GJF	Made strtoxl() _CALLTYPE4.
*	08-13-90  SBM	Compiles cleanly with -W3
*	09-27-90  GJF	New-style function declarators.
*	10-24-91  GJF	Had to cast LONG_MAX to unsigned long in expr. to
*			mollify MIPS compiler.
*	10-21-92  GJF	Made char-to-int conversions unsigned.
*	04-21-93  GJF	Removed assumption that LONG_MIN == -LONG_MAX.
*	05-10-93  GJF	Fixed error check.
*	05-20-93  GJF	Nothing like taking ugly code and making prettier...
*			and wrong. Fixed bug introduced on 5-10.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>


/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*	int.
*
*Purpose:
*	Convert an ascii string to a long 32-bit value.  The base
*	used for the caculations is supplied by the caller.  The base
*	must be in the range 0, 2-36.  If a base of 0 is supplied, the
*	ascii string must be examined to determine the base of the
*	number:
*		(a) First char = '0', second char = 'x' or 'X',
*		    use base 16.
*		(b) First char = '0', use base 8
*		(c) First char in range '1' - '9', use base 10.
*
*	If the 'endptr' value is non-NULL, then strtol/strtoul places
*	a pointer to the terminating character in this value.
*	See ANSI standard for details
*
*Entry:
*	nptr == NEAR/FAR pointer to the start of string.
*	endptr == NEAR/FAR pointer to the end of the string.
*	ibase == integer base to use for the calculations.
*
*	string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*	Good return:
*		result
*
*	Overflow return:
*		strtol -- LONG_MAX or LONG_MIN
*		strtoul -- ULONG_MAX
*
*	No digits or bad base return:
*		0
*		endptr = nptr*
*
*Exceptions:
*	None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG	      2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl strtoxl (
	const char *nptr,
	const char **endptr,
	int ibase,
	int flags
	)
{
	const char *p;
	char c;
	unsigned long number;
	unsigned digval;
	unsigned long maxval;

	p = nptr;			/* p is our scanning pointer */
	number = 0;			/* start with zero */

	c = *p++;			/* read char */
	while ( isspace((int)(unsigned char)c) )
		c = *p++;		/* skip whitespace */

	if (c == '-') {
		flags |= FL_NEG;	/* remember minus sign */
		c = *p++;
	}
	else if (c == '+')
		c = *p++;		/* skip sign */

	if (ibase < 0 || ibase == 1 || ibase > 36) {
		/* bad base! */
		if (endptr)
			/* store beginning of string in endptr */
			*endptr = nptr;
		return 0L;		/* return 0 */
	}
	else if (ibase == 0) {
		/* determine base free-lance, based on first two chars of
		   string */
		if (c != '0')
			ibase = 10;
		else if (*p == 'x' || *p == 'X')
			ibase = 16;
		else
			ibase = 8;
	}

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
		if (c == '0' && (*p == 'x' || *p == 'X')) {
			++p;
			c = *p++;	/* advance past prefix */
		}
	}

	/* if our number exceeds this, we will overflow on multiply */
	maxval = ULONG_MAX / ibase;


	for (;;) {	/* exit in middle of loop */
		/* convert c to value */
		if ( isdigit((int)(unsigned char)c) )
			digval = c - '0';
		else if ( isalpha((int)(unsigned char)c) )
			digval = toupper(c) - 'A' + 10;
		else
			break;
		if (digval >= (unsigned)ibase)
			break;		/* exit loop if bad digit found */

		/* record the fact we have read one digit */
		flags |= FL_READDIGIT;

		/* we now need to compute number = number * base + digval,
		   but we need to know if overflow occured.  This requires
		   a tricky pre-check. */

		if (number < maxval || (number == maxval &&
		(unsigned long)digval <= ULONG_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			flags |= FL_OVERFLOW;
		}

		c = *p++;		/* read next digit */
	}

	--p;				/* point to place that stopped scan */

	if (!(flags & FL_READDIGIT)) {
		/* no number there; return 0 and point to beginning of
		   string */
		if (endptr)
			/* store beginning of string in endptr later on */
			p = nptr;
		number = 0L;		/* return 0 */
	}
	else if ( (flags & FL_OVERFLOW) ||
		  ( !(flags & FL_UNSIGNED) &&
		    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
		      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
	{
		/* overflow or signed overflow occurred */
		if ( flags & FL_UNSIGNED )
			number = ULONG_MAX;
		else if ( flags & FL_NEG )
			number = (unsigned long)(-LONG_MIN);
		else
			number = LONG_MAX;
	}

	if (endptr != NULL)
		/* store pointer to char that stopped the scan */
		*endptr = p;

	if (flags & FL_NEG)
		/* negate result if there was a neg sign */
		number = (unsigned long)(-(long)number);

	return number;			/* done. */
}

long __cdecl strtol (
	const char *nptr,
	char **endptr,
	int ibase
	)
{
	return (long) strtoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl strtoul (
	const char *nptr,
	char **endptr,
	int ibase
	)
{
	return strtoxl(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\atox.c ===
/***
*atox.c - atoi and atol conversion
*
*       Copyright (c) 1989-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into an int or long.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <ctype.h>

/***
*long atol(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       Overflow is not detected.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       return long int value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long __cdecl atol(
        const char *nptr
        )
{
        int c;              /* current char */
        long total;         /* current total */
        int sign;           /* if '-', then negative, otherwise positive */

        /* skip whitespace */
        while ( isspace((int)(unsigned char)*nptr) )
            ++nptr;

        c = (int)(unsigned char)*nptr++;
        sign = c;           /* save sign indication */
        if (c == '-' || c == '+')
            c = (int)(unsigned char)*nptr++;    /* skip sign */

        total = 0;

        while (isdigit(c)) {
            total = 10 * total + (c - '0');     /* accumulate digit */
            c = (int)(unsigned char)*nptr++;    /* get next char */
        }

        if (sign == '-')
            return -total;
        else
            return total;   /* return result, negated if necessary */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\xtow.c ===
/***
*xtow.c - convert integers/longs to wide char string
*
*	Copyright (c) 1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The module has code to convert integers/longs to wide char strings.
*
*Revision History:
*	09-10-93  CFW	Module created, based on ASCII version.
*
*******************************************************************************/

#include <windows.h>
#include <stdlib.h>

#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40

/***
*BOOL our_ultow(val, buf, bufsize, radix) - convert binary int to wide
*	char string
*
*Purpose:
*	Converts an int to a wide character string.
*
*Entry:
*	val - number to be converted (int, long or unsigned long)
*	int radix - base to convert into
*	wchar_t *buf - ptr to buffer to place result
*	int bufsize - size of buffer pointed to by buf, in characters
*
*Exit:
*	calls ASCII version to convert, converts ASCII to wide char into buf
*	returns TRUE if char. conversion succeeded, FALSE otherwise.
*
*Exceptions:
*
*******************************************************************************/

BOOL __cdecl our_ultow(
	unsigned long val,
	wchar_t *buf,
	int bufsize,
	int radix
	)
{
   char astring[LONG_SIZE_LENGTH];

   _ultoa (val, astring, radix);
   return (MultiByteToWideChar(CP_ACP, 
                               MB_PRECOMPOSED, 
                               astring, 
                               -1,
                               buf, 
                               bufsize) == 0 ? FALSE : TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\days.c ===
/***
*days.c - static arrays with days from beg of year for each month
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains static arrays used by gmtime and statconv to determine
*	date and time values.  Shows days from beg of year.
*
*Revision History:
*	03-??-84  RLB	initial version
*	05-??-84  DFW	split out definitions from ctime routines
*	07-03-89  PHG	removed _NEAR_ for 386
*	03-20-90  GJF	Fixed copyright.
*
*******************************************************************************/

#include <internal.h>

int _lpdays[] = {
	-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
};

int _days[] = {
	-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\makefile.inc ===
i386\memmove.asm: i386\memcpy.asm

i386\strcspn.asm: i386\strspn.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\dtoxtime.c ===
/***
*dtoxtime.c - convert broken-down UTC time to time_t
*
*	Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines __gmtotime_t() - convert broken-down UTC time to internal
*	format (time_t).
*
*Revision History:
*	03-??-84  RLB	written
*	11-18-87  SKS	change tzset() to __tzset(), change source file name
*			make _dtoxtime a near procedure
*	01-26-88  SKS	_dtoxtime is no longer a near procedure (for QC)
*	03-20-90  GJF	Made calling type _CALLTYPE1, added #include
*			<cruntime.h>, removed #include <register.h> and
*			fixed the copyright. Also, cleaned up the formatting
*			a bit.
*	10-04-90  GJF	New-style function declarator.
*	01-21-91  GJF	ANSI naming.
*	05-19-92  DJM	ifndef for POSIX build.
*	03-30-93  GJF	Revised. Old _dtoxtime is replaced by __gmtotime_t,
*			which is more useful on Win32.
*	04-06-93  GJF	Rewrote computation to avoid compiler warnings.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*time_t __gmtotime_t(yr, mo, dy, hr, mn, sc) - convert broken down time (UTC)
*   to time_t
*
*Purpose:
*	Converts a broken down UTC (GMT) time to time_t. This is similar to
*	_mkgmtime() except there is minimal overflow checking and no updating
*	of the input values (i.e., the fields of tm structure).
*
*Entry:
*	int yr, mo, dy -	date
*	int hr, mn, sc -	time
*
*Exit:
*	returns time_t value
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __gmtotime_t (
	int yr,     /* 0 based */
	int mo,     /* 1 based */
	int dy,     /* 1 based */
	int hr,
	int mn,
	int sc
	)
{
	int tmpdays;
	long tmptim;

	/*
	 * Do a quick range check on the year and convert it to a delta
	 * off of 1900.
	 */
	if ( ((long)(yr -= 1900) < _BASE_YEAR) || ((long)yr > _MAX_YEAR) )
		return (time_t)(-1);

	/*
	 * Compute the number of elapsed days in the current year minus
	 * one. Note the test for leap year and the would fail in the year 2100
	 * if this was in range (which it isn't).
	 */
	tmpdays = dy + _days[mo - 1];
	if ( !(yr & 3) && (mo > 2) )
		/*
		 * in a leap year, after Feb. add one day for elapsed
		 * Feb 29.
		 */
		tmpdays++;

	/*
	 * Compute the number of elapsed seconds since the Epoch. Note the
	 * computation of elapsed leap years would break down after 2100
	 * if such values were in range (fortunately, they aren't).
	 */
	tmptim = /* 365 days for each year */
		 (((long)yr - _BASE_YEAR) * 365L

		 /* one day for each elapsed leap year */
		 + (long)((yr - 1) >> 2) - _LEAP_YEAR_ADJUST

		 /* number of elapsed days in yr */
		 + tmpdays)

		 /* convert to hours and add in hr */
		 * 24L + hr;

	tmptim = /* convert to minutes and add in mn */
		 (tmptim * 60L + mn)

		 /* convert to seconds and add in sec */
		 * 60L + sc;

	return (tmptim >= 0) ? (time_t)tmptim : (time_t)(-1);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\time.c ===
/***
*time.c - get current system time
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines time() - gets the current system time and converts it to
*			 internal (time_t) format time.
*
*Revision History:
*	06-07-89  PHG	Module created, based on asm version
*	03-20-90  GJF	Made calling type _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	07-25-90  SBM	Removed '32' from API names
*	10-04-90  GJF	New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*	05-19-92  DJM	ifndef for POSIX build.
*	03-30-93  GJF	Replaced dtoxtime() reference by __gmtotime_t. Also
*			purged Cruiser support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <windows.h>
#include <cruntime.h>
#include <time.h>
#include <internal.h>

/***
*time_t time(timeptr) - Get current system time and convert to time_t value.
*
*Purpose:
*	Gets the current date and time and stores it in internal (time_t)
*	format. The time is returned and stored via the pointer passed in
*	timeptr. If timeptr == NULL, the time is only returned, not stored in
*	*timeptr. The internal (time_t) format is the number of seconds since
*	00:00:00, Jan 1 1970 (UTC).
*
*Entry:
*	time_t *timeptr - pointer to long to store time in.
*
*Exit:
*	returns the current time.
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl time (
	time_t *timeptr
	)
{
	time_t tim;

        SYSTEMTIME dt;

	/* ask Win32 for the time, no error possible */

	GetSystemTime(&dt);

	/* convert using our private routine */
	tim = __gmtotime_t((int)dt.wYear,
			   (int)dt.wMonth,
			   (int)dt.wDay,
			   (int)dt.wHour,
			   dt.wMinute,
			   dt.wSecond);

	if (timeptr)
		*timeptr = tim;		/* store time if requested */

	return tim;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\towlower.c ===
/***
*towlower.c - convert wide character to lower case
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines towlower().
*
*Revision History:
*	10-11-91  ETC	Created.
*	12-10-91  ETC	Updated nlsapi; added multithread.
*	04-06-92  KRS	Make work without _INTL also.
*       01-19-93  CFW   Changed LCMapString to LCMapStringW.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*	06-11-93  CFW	Fix error handling bug.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>

/***
*wchar_t towlower(c) - convert wide character to lower case
*
*Purpose:
*	towlower() returns the lowercase equivalent of its argument
*
*Entry:
*	c - wchar_t value of character to be converted
*
*Exit:
*	if c is an upper case letter, returns wchar_t value of lower case
*	representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/

wchar_t _CALLTYPE1 towlower (
	wchar_t c
 	)
{

    //  If we're in the first 128 characters, it's just ANSII...

    if (c < 128) {
	return (wchar_t)CharLowerA((LPSTR)c);
    } else {
	WCHAR wBuffer[2];
	CHAR Buffer[8];
	int Length;
	BOOL fDefaultChar;

	wBuffer[0] = c;
	Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, &fDefaultChar);
	if (fDefaultChar == FALSE)
	{
	    Buffer[Length] = '\0';
	    CharLowerA (Buffer);
	    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, Buffer, Length, wBuffer, 1);
	}
	return wBuffer[0];
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\labs.c ===
/***
*labs.c - find absolute value of a long integer
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines labs() - find absolute value of a long integer.
*
*Revision History:
*	03-15-84  RN	initial version
*	04-22-87  JMB	added function pragma for conversion to C 5.0 compiler
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	03-14-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h> and fixed the copyright. Also, cleaned
*			up the formatting a bit.
*	10-04-90  GJF	New-style function declarator.
*       12-28-90  SRW   Added _CRUISER_ conditional around function pragma
*       04-01-91  SRW   Enable #pragma function for i386 _WIN32_ builds too.
*       03-09-94  RDL   Enable #pragma function for i386 _WIN32_ builds too.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma function(labs)
#endif

/***
*long labs(lnumber) - find absolute value of long.
*
*Purpose:
*	Find the absolute value of a long integer (lnumber if lnumber >= 0),
*	-lnumber if lnumber < 0).
*
*Entry:
*	long lnumber - number to find absolute value of
*
*Exit:
*	returns the absolute value of lnumber
*
*Exceptions:
*
*******************************************************************************/

long _CALLTYPE1 labs (
	long lnumber
	)
{
	return( lnumber>=0L ? lnumber : -lnumber );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\toupper.c ===
/***
*toupper.c - convert character to uppercase
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines function versions of _toupper() and toupper().
*
*Revision History:
*	11-09-84  DFW	created
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	02-23-89  GJF	Added function version of _toupper and cleaned up.
*	03-26-89  GJF	Migrated to 386 tree
*	03-06-90  GJF	Fixed calling type, added #include <cruntime.h> and
*			fixed copyright.
*	09-27-90  GJF	New-style function declarators.
*	10-11-91  ETC	Locale support for toupper under _INTL switch.
*	12-10-91  ETC	Updated nlsapi; added multithread.
*	12-17-92  KRS	Updated and optimized for latest NLSAPI.  Bug-fixes.
*       01-19-93  CFW   Fixed typo.
*       03-25-93  CFW   _toupper now defined when _INTL.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*	09-15-93  CFW	Change buffer to unsigned char to fix nasty cast bug.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
*       11-14-95  JAE   Use Win32 API
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>

/* remove macro definitions of _toupper() and toupper()
 */
#undef	_toupper
#undef	toupper

/* define function-like macro equivalent to _toupper()
 */
#define mkupper(c)	( (c)-'a'+'A' )


/***
*int toupper(c) - convert character to uppercase
*
*Purpose:
*	toupper() is simply a function version of the macro of the same name.
*
*Entry:
*	c - int value of character to be converted
*
*Exit:
*	if c is a lower case letter, returns int value of uppercase
*	representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/


int _CALLTYPE1 toupper (
	int c
	)
{
    return (int)CharUpper ((LPTSTR)c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\iswctype.c ===
/***
*iswctype.c - support isw* wctype functions/macros for wide characters
*
*	Copyright (c) 1991-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines iswctype - support isw* wctype functions/macros for
*	wide characters (esp. > 255).
*
*Revision History:
*	10-11-91   ETC	Created.
*	12-08-91   ETC	Updated api; check type masks.
*	04-06-92   KRS	Change to match ISO proposal.  Fix logic error.
*	08-07-92   GJF	_CALLTYPE4 (bogus usage) -> _CRTAPI1 (legit).
*	08-20-92   KRS	Activated NLS support.
*	08-22-92   SRW	Allow INTL definition to be conditional for building ntcrt.lib
*	09-02-92   SRW	Get _INTL definition via ..\crt32.def
*	09-03-92   GJF	Merged last 4 changes.
*	01-15-93   CFW	Put #ifdef _INTL around wint_t d def to avoid warnings
*	02-12-93   CFW	Return d not c, remove CTRL-Z.
*	02-17-93   CFW	Include locale.h.
*	05-05-93   CFW	Change name from is_wctype to iswctype as per ISO.
*       06-02-93   SRW   ignore _INTL if _NTSUBSET_ defined.
*       06-26-93   CFW	Support is_wctype forever.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <ctype.h>
#include <stdio.h>
#include <locale.h>
#include <setlocal.h>

/*
 *  Use GetStringTypeW() API so check that character type masks agree between
 *  ctype.h and winnls.h
 */
#if defined(_INTL) && !defined(_NTSUBSET_)
#if	_UPPER != C1_UPPER 	|| \
	_LOWER != C1_LOWER	|| \
	_DIGIT != C1_DIGIT	|| \
	_SPACE != C1_SPACE	|| \
	_PUNCT != C1_PUNCT	|| \
	_CONTROL != C1_CNTRL
#error Character type masks do not agree in ctype and winnls
#endif
#endif


/***
*iswctype - support isw* wctype functions/macros.
*
*Purpose:
*	This function is called by the isw* wctype functions/macros
*	(e.g. iswalpha()) when their argument is a wide character > 255.
*	It is also a standard ITSCJ (proposed) ISO routine and can be called
*	by the user, even for characters < 256.
*	Returns true or false depending on whether the argument satisfies
*	the character class property encoded by the mask.  Returns 0 if the
*	argument is WEOF.
*
*	NOTE: The isw* functions are neither locale nor codepage dependent.
*
*Entry:
*	wchar_t c    - the wide character whose type is to be tested
*	wchar_t mask - the mask used by the isw* functions/macros
*		       corresponding to each character class property
*
*Exit:
*	Returns non-zero if c is of the character class.
*	Returns 0 if c is not of the character class.
*
*Exceptions:
*	Returns 0 on any error.
*
*******************************************************************************/

int __cdecl iswctype (
	wchar_t c,
	wctype_t mask
	)
{
	wint_t d;

	if (c == WEOF)
	    return 0;

	if (c < 256)	/* consider: necessary? */
	    d = _pwctype[c];
	else
	{
	    // Convert to MBS and ask Win9x

	    WCHAR wBuffer[2];
	    CHAR Buffer[8];
	    USHORT usResults[8];
	    int Length;

	    wBuffer[0] = c;
	    Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, NULL);
	    GetStringTypeA (GetThreadLocale (), CT_CTYPE1, Buffer, Length, usResults);
	    d = usResults[0];
	}

	return (int)(d & mask);
}


/***
*is_wctype - support obsolete name
*
*Purpose:
*	Name changed from is_wctype to iswctype. is_wctype must be supported.
*
*Entry:
*	wchar_t c    - the wide character whose type is to be tested
*	wchar_t mask - the mask used by the isw* functions/macros
*		       corresponding to each character class property
*
*Exit:
*	Returns non-zero if c is of the character class.
*	Returns 0 if c is not of the character class.
*
*Exceptions:
*	Returns 0 on any error.
*
*******************************************************************************/
int __cdecl is_wctype (
	wchar_t c,
	wctype_t mask
	)
{
	return iswctype(c, mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\towupper.c ===
/***
*towupper.c - convert wide character to upper case
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines towupper().
*
*Revision History:
*	10-11-91  ETC	Created.
*	12-10-91  ETC	Updated nlsapi; added multithread.
*	04-06-92  KRS	Make work without _INTL also.
*       01-19-93  CFW   Changed LCMapString to LCMapStringW.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*	06-11-93  CFW	Fix error handling bug.
*       01-14-94  SRW   if _NTSUBSET_ defined call Rtl functions
#       11-14-95  JAE   Use Win32 function
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>

/***
*wchar_t towupper(c) - convert wide character to upper case
*
*Purpose:
*	towupper() returns the uppercase equivalent of its argument
*
*Entry:
*	c - wchar_t value of character to be converted
*
*Exit:
*	if c is a lower case letter, returns wchar_t value of upper case
*	representation of c. otherwise, it returns c.
*
*Exceptions:
*
*******************************************************************************/

wchar_t _CALLTYPE1 towupper (
	wchar_t c
	)
{

    //  If we're in the first 128 characters, it's just ANSII...

    if (c < 128) {
	return (wchar_t)CharUpperA((LPSTR)c);
    } else {
	WCHAR wBuffer[2];
	CHAR Buffer[8];
	int Length;
	BOOL fDefaultChar;

	wBuffer[0] = c;
	Length = WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wBuffer, 1, Buffer, sizeof (Buffer), NULL, &fDefaultChar);
	if (fDefaultChar == FALSE)
	{
	    Buffer[Length] = '\0';
	    CharUpperA (Buffer);
	    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, Buffer, Length, wBuffer, 1);
	}
	return wBuffer[0];
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcscat.c ===
/***
*wcscat.c - contains wcscat() and wcscpy()
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcscat() appends one wchar_t string onto another.
*	wcscpy() copies one wchar_t string into another.
*
*	wcscat() concatenates (appends) a copy of the source string to the
*	end of the destination string, returning the destination string.
*	Strings are wide-character strings.
*
*	wcscpy() copies the source string to the spot pointed to be
*	the destination string, returning the destination string.
*	Strings are wide-character strings.
*
*Revision History:
*	09-09-91   ETC	Created from strcat.c.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcscat(dst, src) - concatenate (append) one wchar_t string to another
*
*Purpose:
*	Concatenates src onto the end of dest.	Assumes enough
*	space in dest.
*
*Entry:
*	wchar_t *dst - wchar_t string to which "src" is to be appended
*	const wchar_t *src - wchar_t string to be appended to the end of "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

wchar_t * _CALLTYPE1 wcscat (
	wchar_t * dst,
	const wchar_t * src
	)
{
	wchar_t * cp = dst;

	while( *cp )
		cp++;			/* find end of dst */

	while( *cp++ = *src++ ) ;	/* Copy src to end of dst */

	return( dst );			/* return dst */

}


/***
*wchar_t *wcscpy(dst, src) - copy one wchar_t string over another
*
*Purpose:
*	Copies the wchar_t string src into the spot specified by
*	dest; assumes enough room.
*
*Entry:
*	wchar_t * dst - wchar_t string over which "src" is to be copied
*	const wchar_t * src - wchar_t string to be copied over "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*******************************************************************************/

wchar_t * _CALLTYPE1 wcscpy(wchar_t * dst, const wchar_t * src)
{
	wchar_t * cp = dst;

	while( *cp++ = *src++ )
		;		/* Copy src over dst */

	return( dst );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcscmp.c ===
/***
*wcscmp.c - routine to compare two wchar_t strings (for equal, less, or greater)
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Compares two wide-character strings, determining their lexical order.
*
*Revision History:
*	09-09-91   ETC	Created from strcmp.c.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*wcscmp - compare two wchar_t strings,
*	 returning less than, equal to, or greater than
*
*Purpose:
*	wcscmp compares two wide-character strings and returns an integer
*	to indicate whether the first is less than the second, the two are
*	equal, or whether the first is greater than the second.
*
*	Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*	say that Null wchar_t(0) is less than any other character.
*
*Entry:
*	const wchar_t * src - string for left-hand side of comparison
*	const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*	returns -1 if src <  dst
*	returns  0 if src == dst
*	returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE1 wcscmp (
	const wchar_t * src,
	const wchar_t * dst
	)
{
	int ret = 0 ;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcschr.c ===
/***
*wcschr.c - search a wchar_t string for a given wchar_t character
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcschr() - search a wchar_t string for a wchar_t character
*
*Revision History:
*	09-09-91   ETC	Created from strchr.c.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcschr(string, c) - search a string for a wchar_t character
*
*Purpose:
*	Searches a wchar_t string for a given wchar_t character,
*	which may be the null character L'\0'.
*
*Entry:
*	wchar_t *string - wchar_t string to search in
*	wchar_t c - wchar_t character to search for
*
*Exit:
*	returns pointer to the first occurence of c in string
*	returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

wchar_t * _CALLTYPE1 wcschr (
	const wchar_t * string,
	wchar_t ch
	)
{
	while (*string && *string != (wchar_t)ch)
		string++;

	if (*string == (wchar_t)ch)
		return((wchar_t *)string);
	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcslen.c ===
/***
*wcslen.c - contains wcslen() routine
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcslen returns the length of a null-terminated wide-character string,
*	not including the null wchar_t itself.
*
*Revision History:
*	09-09-91   ETC	Created from strlen.c.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*wcslen - return the length of a null-terminated wide-character string
*
*Purpose:
*	Finds the length in wchar_t's of the given string, not including
*	the final null wchar_t (wide-characters).
*
*Entry:
*	const wchar_t * wcs - string whose length is to be computed
*
*Exit:
*	length of the string "wcs", exclusive of the final null wchar_t
*
*Exceptions:
*
*******************************************************************************/

size_t _CALLTYPE1 wcslen (
	const wchar_t * wcs
	)
{
	const wchar_t *eos = wcs;

	while( *eos++ ) ;

	return( (size_t)(eos - wcs - 1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcslwr.c ===
/***
*wcslwr.c - routine to map upper-case characters in a wchar_t string 
*	to lower-case
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Converts all the upper case characters in a wchar_t string 
*	to lower case, in place.
*
*Revision History:
*	09-09-91   ETC	Created from strlwr.c.
*	04-06-92   KRS	Make work without _INTL also.
*	08-19-92   KRS	Activate NLS support.
*	08-22-92   SRW	Allow INTL definition to be conditional for building ntcrt.lib
*	09-02-92   SRW	Get _INTL definition via ..\crt32.def
*       06-02-93   SRW  ignore _INTL if _NTSUBSET_ defined.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>

/***
*wchar_t *_wcslwr(string) - map upper-case characters in a string to lower-case
*
*Purpose:
*	wcslwr converts upper-case characters in a null-terminated wchar_t 
*	string to their lower-case equivalents.  The result may be longer or
*	shorter than the original string.  Assumes enough space in string
*	to hold the result.
*
*Entry:
*	wchar_t *wsrc - wchar_t string to change to lower case
*
*Exit:
*	input string address
*
*Exceptions:
*	on an error, the original string is unaltered
*
*******************************************************************************/

wchar_t * _CALLTYPE1 _wcslwr (
	wchar_t * wsrc
	)
{

    wchar_t * p;

    //  Prescan the buffer. If all this is in the first 128 characters, it's just
    //  ANSII, and we can do it ourselves...

    for (p = wsrc; *p; p++) 
    {
	if (*p < 128) 
	{
	    *p = (wchar_t)CharLowerA((LPSTR)*p);
	} 
	else 
	{

	    //  We can't handle this character in place, so convert the remainder of the string
	    //  to MBS, lower-case it, and convert it back to Unicode.

	    int wLength = lstrlenW (p);
	    int mbsLength;
	    CHAR * mbsBuffer = (CHAR *)LocalAlloc (LMEM_FIXED, 2 * sizeof (CHAR) * wLength + 1);
	    if (mbsBuffer == NULL) 
	    {
		return NULL;
	    }
	    mbsLength = WideCharToMultiByte (CP_ACP, 
					     WC_COMPOSITECHECK, 
					     p, 
					     wLength, 
					     mbsBuffer, 
					     2 * sizeof (CHAR) * wLength, 
					     NULL, 
					     NULL);
	    if (mbsLength == 0)
	    {
		// We don't know what happened, but it wasn't good
		return NULL;
	    }
	    mbsBuffer[mbsLength] = '\0';
	    CharLowerA (mbsBuffer);
	    if (MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, mbsBuffer, mbsLength, p, wLength) == 0) 
	    {
		return NULL;
	    }
	    break;
	}
    }

    return wsrc;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcsncmp.c ===
/***
*wcsncmp.c - compare first n characters of two wide-character strings
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncmp() - compare first n characters of two wchar_t strings
*	for lexical order.
*
*Revision History:
*	09-09-91   ETC	Created from strncmp.c.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*int wcsncmp(first, last, count) - compare first count chars of wchar_t strings
*
*Purpose:
*	Compares two strings for lexical order.  The comparison stops
*	after: (1) a difference between the strings is found, (2) the end
*	of the strings is reached, or (3) count characters have been
*	compared (wide-character strings).
*
*Entry:
*	wchar_t *first, *last - strings to compare
*	size_t count - maximum number of characters to compare
*
*Exit:
*	returns <0 if first < last
*	returns  0 if first == last
*	returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE1 wcsncmp (
	const wchar_t * first,
	const wchar_t * last,
	size_t count
	)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return((int)(*first - *last));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcsicmp.c ===
/***
*wcsicmp.c - contains case-insensitive wide string comp routine _wcsicmp
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains _wcsicmp()
*
*Revision History:
*	09-09-91   ETC	Created from stricmp.c.
*	12-09-91   ETC	Use C for neutral locale.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*	08-19-92   KRS	Actived use of CompareStringW.
*	08-22-92   SRW	Allow INTL definition to be conditional for building ntcrt.lib
*	09-02-92   SRW	Get _INTL definition via ..\crt32.def
*	12-15-92   KRS	Added robustness to non-_INTL code.  Optimize.
*       06-02-93   SRW  ignore _INTL if _NTSUBSET_ defined.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <string.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <os2dll.h>

/***
*int _wcsicmp(dst, src) - compare wide-character strings, ignore case
*
*Purpose:
*	_wcsicmp perform a case-insensitive wchar_t string comparision.
*	_wcsicmp is independent of locale.
*
*	*** NOTE: the comparison should be done in a neutral locale,
*	provided by the NLSAPI. ****
*
*Entry:
*	wchar_t *dst, *src - strings to compare
*
*Return:
*	<0 if dst < src
*	 0 if dst = src
*	>0 if dst > src
*	This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE1 _wcsicmp (
	const wchar_t * dst,
	const wchar_t * src
	)
{
	wchar_t f,l;
	int ret;

#if defined(_INTL) && !defined(_NTSUBSET_)
/*	_mlock (_LC_CTYPE_LOCK); */

	if ((_lc_handle[LC_CTYPE] == _CLOCALEHANDLE) &&
	    (_lc_codepage == _CLOCALECP))
	    {
#endif	/* _INTL */
	    do  {
		f = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst + ((wchar_t)(L'a' - L'A'))
			: *dst;
		l = ((*src <= L'Z') && (*src >= L'A'))
			? *src + ((wchar_t)(L'a' - L'A'))
			: *src;
		dst++;
		src++;
	    	} while ((f) && (f == l));
	    ret = (int)((unsigned int)f - (unsigned int)l);
#if defined(_INTL) && !defined(_NTSUBSET_)
	    }
	else
	    {
	    ret = CompareStringW(LANG_NEUTRAL,NORM_IGNORECASE,dst,-1,src,-1);
	    /* map return into normal CMP area (-1,0, 1 or ERROR) */
	    ret = (ret) ? (ret-2) : NLSCMPERROR;
	    }

/*	_munlock (_LC_CTYPE_LOCK); */
#endif	/* _INTL */

	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcsncpy.c ===
/***
*wcsncpy.c - copy at most n characters of wide-character string
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncpy() - copy at most n characters of wchar_t string
*
*Revision History:
*	09-09-91   ETC	Created from strncpy.c.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsncpy(dest, source, count) - copy at most n wide characters
*
*Purpose:
*	Copies count characters from the source string to the
*	destination.  If count is less than the length of source,
*	NO NULL CHARACTER is put onto the end of the copied string.
*	If count is greater than the length of sources, dest is padded
*	with null characters to length count (wide-characters).
*
*
*Entry:
*	wchar_t *dest - pointer to destination
*	wchar_t *source - source string for copy
*	size_t count - max number of characters to copy
*
*Exit:
*	returns dest
*
*Exceptions:
*
*******************************************************************************/

wchar_t * _CALLTYPE1 wcsncpy (
	wchar_t * dest,
	const wchar_t * source,
	size_t count
	)
{
	wchar_t *start = dest;

	while (count && (*dest++ = *source++))	  /* copy string */
		count--;

	if (count)				/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcsnicmp.c ===
/***
*wcsnicmp.c - compare n chars of wide-character strings, ignoring case
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsnicmp() - Compares at most n characters of two wchar_t 
*	strings, without regard to case.
*
*Revision History:
*	09-09-91   ETC	Created from strnicmp.c and wcsicmp.c.
*	12-09-91   ETC	Use C for neutral locale.
*	04-07-92   KRS	Updated and ripped out _INTL switches.
*       06-02-93   SRW  ignore _INTL if _NTSUBSET_ defined.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#ifdef _INTL
#include <setlocal.h>
#include <os2dll.h>
#endif

/***
*int _wcsnicmp(first, last, count) - compares count wchar_t of strings, 
*	ignore case
*
*Purpose:
*	Compare the two strings for lexical order.  Stops the comparison
*	when the following occurs: (1) strings differ, (2) the end of the
*	strings is reached, or (3) count characters have been compared.
*	For the purposes of the comparison, upper case characters are
*	converted to lower case (wide-characters).
*
*	*** NOTE: the comparison should be done in a neutral locale,
*	provided by the NLSAPI.  Currently, the comparison is done
*	in the C locale. ***
*
*Entry:
*	wchar_t *first, *last - strings to compare
*	size_t count - maximum number of characters to compare
*
*Exit:
*	-1 if first < last
*	 0 if first == last
*	 1 if first > last
*	This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE1 _wcsnicmp (
	const wchar_t * first,
	const wchar_t * last,
	size_t count
	)
{
	wchar_t f,l;
	int result = 0;

	if (count)
	{
#if defined(_INTL) && !defined(_NTSUBSET_)

		_mlock (_LC_CTYPE_LOCK);
#endif

		do
		{
			f = iswupper(*first)
				? *first - (wchar_t)L'A' + (wchar_t)L'a'
				: *first;
			l = iswupper(*last)
				? *last - (wchar_t)L'A' + (wchar_t)L'a'
				: *last;
			first++;
			last++;
		} while (--count && f && l && f == l);

#if defined(_INTL) && !defined(_NTSUBSET_)
		_munlock (_LC_CTYPE_LOCK);
#endif

		result = (int)(f - l);
	}
	return result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcstol.c ===
/***
*wcstol.c - Contains C runtimes wcstol and wcstoul
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcstol - convert wchar_t string to long signed integer
*	wcstoul - convert wchar_t string to long unsigned integer
*
*Revision History:
*	06-15-92  KRS	Module created, based on strtol.c
*	04-21-93  GJF	Removed assumption that LONG_MIN == -LONG_MAX.
*	05-10-93  GJF	Fixed error check.
*	05-20-93  GJF	Nothing like taking ugly code and making prettier...
*			and wrong. Fixed bug introduced on 5-10.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>

/***
*wcstol, wcstoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*	int.
*
*Purpose:
*	Convert an ascii string to a long 32-bit value.  The base
*	used for the caculations is supplied by the caller.  The base
*	must be in the range 0, 2-36.  If a base of 0 is supplied, the
*	ascii string must be examined to determine the base of the
*	number:
*		(a) First char = '0', second char = 'x' or 'X',
*		    use base 16.
*		(b) First char = '0', use base 8
*		(c) First char in range '1' - '9', use base 10.
*
*	If the 'endptr' value is non-NULL, then wcstol/wcstoul places
*	a pointer to the terminating character in this value.
*	See ANSI standard for details
*
*Entry:
*	nptr == NEAR/FAR pointer to the start of string.
*	endptr == NEAR/FAR pointer to the end of the string.
*	ibase == integer base to use for the calculations.
*
*	string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*	Good return:
*		result
*
*	Overflow return:
*		wcstol -- LONG_MAX or LONG_MIN
*		wcstoul -- ULONG_MAX
*
*	No digits or bad base return:
*		0
*		endptr = nptr*
*
*Exceptions:
*	None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG	      2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long __cdecl wcstoxl (
	const wchar_t *nptr,
	const wchar_t **endptr,
	int ibase,
	int flags
	)
{
	const wchar_t *p;
	wchar_t c;
	unsigned long number;
	unsigned digval;
	unsigned long maxval;

	p = nptr;			/* p is our scanning pointer */
	number = 0;			/* start with zero */

	c = *p++;			/* read char */
	while (iswspace(c))
		c = *p++;		/* skip whitespace */

	if (c == '-') {
		flags |= FL_NEG;	/* remember minus sign */
		c = *p++;
	}
	else if (c == '+')
		c = *p++;		/* skip sign */

	if (ibase < 0 || ibase == 1 || ibase > 36) {
		/* bad base! */
		if (endptr)
			/* store beginning of string in endptr */
			*endptr = nptr;
		return 0L;		/* return 0 */
	}
	else if (ibase == 0) {
		/* determine base free-lance, based on first two chars of
		   string */
		if (c != L'0')
			ibase = 10;
		else if (*p == L'x' || *p == L'X')
			ibase = 16;
		else
			ibase = 8;
	}

	if (ibase == 16) {
		/* we might have 0x in front of number; remove if there */
		if (c == L'0' && (*p == L'x' || *p == L'X')) {
			++p;
			c = *p++;	/* advance past prefix */
		}
	}

	/* if our number exceeds this, we will overflow on multiply */
	maxval = ULONG_MAX / ibase;


	for (;;) {	/* exit in middle of loop */
		/* convert c to value */
		if (iswdigit(c))
			digval = c - L'0';
		else if (iswalpha(c))
			digval = towupper(c) - L'A' + 10;
		else
			break;
		if (digval >= (unsigned)ibase)
			break;		/* exit loop if bad digit found */

		/* record the fact we have read one digit */
		flags |= FL_READDIGIT;

		/* we now need to compute number = number * base + digval,
		   but we need to know if overflow occured.  This requires
		   a tricky pre-check. */

		if (number < maxval || (number == maxval &&
		(unsigned long)digval <= ULONG_MAX % ibase)) {
			/* we won't overflow, go ahead and multiply */
			number = number * ibase + digval;
		}
		else {
			/* we would have overflowed -- set the overflow flag */
			flags |= FL_OVERFLOW;
		}

		c = *p++;		/* read next digit */
	}

	--p;				/* point to place that stopped scan */

	if (!(flags & FL_READDIGIT)) {
		/* no number there; return 0 and point to beginning of
		   string */
		if (endptr)
			/* store beginning of string in endptr later on */
			p = nptr;
		number = 0L;		/* return 0 */
	}
	else if ( (flags & FL_OVERFLOW) ||
		  ( !(flags & FL_UNSIGNED) &&
		    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
		      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
	{
		/* overflow or signed overflow occurred */
		if ( flags & FL_UNSIGNED )
			number = ULONG_MAX;
		else if ( flags & FL_NEG )
			number = (unsigned long)(-LONG_MIN);
		else
			number = LONG_MAX;
	}

	if (endptr != NULL)
		/* store pointer to char that stopped the scan */
		*endptr = p;

	if (flags & FL_NEG)
		/* negate result if there was a neg sign */
		number = (unsigned long)(-(long)number);

	return number;			/* done. */
}

long __cdecl wcstol (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	)
{
	return (long) wcstoxl(nptr, endptr, ibase, 0);
}

unsigned long __cdecl wcstoul (
	const wchar_t *nptr,
	wchar_t **endptr,
	int ibase
	)
{
	return wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcstok.cxx ===
/***
*wcstok.c - tokenize a wide-character string with given delimiters
*
*	Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcstok() - breaks wide-character string into series of token
*	via repeated calls.
*
*Revision History:
*	09-09-91   ETC	Created from strtok.c.
*	08-17-92   KRS	Activate multithread support.
*	02-17-93   GJF	Changed for new _getptd().
*       11-14-95   JAE  Break dependence on C RTL's per-thread data
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <string.h>
#include <ole2.h>
#include <debnot.h>
#include "tls.h"



/***
*wchar_t *wcstok(string, control) - tokenize string with delimiter in control
*	(wide-characters)
*
*Purpose:
*	wcstok considers the string to consist of a sequence of zero or more
*	text tokens separated by spans of one or more control chars. the first
*	call, with string specified, returns a pointer to the first wchar_t of
*	the first token, and will write a null wchar_t into string immediately
*	following the returned token. subsequent calls with zero for the first
*	argument (string) will work thru the string until no tokens remain. the
*	control string may be different from call to call. when no tokens remain
*	in string a NULL pointer is returned. remember the control chars with a
*	bit map, one bit per wchar_t. the null wchar_t is always a control char
*	(wide-characters).
*
*Entry:
*	wchar_t *string - wchar_t string to tokenize, or NULL to get next token
*	wchar_t *control - wchar_t string of characters to use as delimiters
*
*Exit:
*	returns pointer to first token in string, or if string
*	was NULL, to next token
*	returns NULL when no more tokens remain.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcstok (
	wchar_t * string,
	const wchar_t * control
	)
{
        COleTls TlsContext;
	wchar_t *token;
	const wchar_t *ctl;


	/* If string==NULL, continue with previous string */
	if (!string)
            string = (wchar_t *)TlsContext->pWcstokContext;


	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets string to point to the terminal
	 * null (*string == '\0') */

	while (*string) {
		for (ctl=control; *ctl && *ctl != *string; ctl++)
			;
		if (!*ctl) break;
		string++;
	}

	token = string;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *string ; string++ ) {
		for (ctl=control; *ctl && *ctl != *string; ctl++)
			;
		if (*ctl) {
			*string++ = '\0';
			break;
		}
	}

	/* Update nextoken (or the corresponding field in the per-thread data
	 * structure */

        TlsContext->pWcstokContext = string;


	/* Determine if a token has been found. */
	if ( token == string )
		return NULL;
	else
		return token;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wtox.c ===
/***
*wtox.c - _wtoi and _wtol conversion
*
*       Copyright (c) 1993-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a wide character string into an int or long.
*
*******************************************************************************/


#include <windows.h>
#include <stdlib.h>

#define INT_SIZE_LENGTH   20
#define LONG_SIZE_LENGTH  40
#define I64_SIZE_LENGTH     80

/***
*long _wtol(wchar_t *nptr) - Convert wide string to long
*
*Purpose:
*       Converts wide string pointed to by nptr to binary.
*       Overflow is not detected.  Because of this, we can just use
*       atol().
*
*Entry:
*       nptr = ptr to wide string to convert
*
*Exit:
*       return long value of the string
*
*Exceptions:
*       None - overflow is not detected.
*
*******************************************************************************/

long __cdecl _wtol(
        const wchar_t *nptr
        )
{
        char astring[INT_SIZE_LENGTH];

        WideCharToMultiByte (CP_ACP, 0, nptr, -1,
                            astring, INT_SIZE_LENGTH, NULL, NULL);

        return (atol(astring));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\xtoa.c ===
/***
*xtoa.c - convert integers/longs to ASCII string
*
*	Copyright (c) 1989-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The module has code to convert integers/longs to ASCII strings.  See
*
*Revision History:
*	06-06-89  PHG	Module created, based on asm version
*	03-06-90  GJF	Fixed calling type, added #include <cruntime.h> and
*			fixed copyright.
*	03-23-90  GJF	Made xtoa() _CALLTYPE4.
*	09-27-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <limits.h>

/***
*char *_itoa, *_ltoa, *_ultoa(val, buf, radix) - convert binary int to ASCII
*	string
*
*Purpose:
*	Converts an int to a character string.
*
*Entry:
*	val - number to be converted (int, long or unsigned long)
*	int radix - base to convert into
*	char *buf - ptr to buffer to place result
*
*Exit:
*	fills in space pointed to by buf with string result
*	returns a pointer to this buffer
*
*Exceptions:
*
*******************************************************************************/

/* helper routine that does the main job. */

static void _CALLTYPE4 xtoa (
	unsigned long val,
	char *buf,
	unsigned radix,
	int is_neg
	)
{
	char *p;		/* pointer to traverse string */
	char *firstdig; 	/* pointer to first digit */
	char temp;		/* temp char */
	unsigned digval;	/* value of digit */

	p = buf;

	if (is_neg) {
		/* negative, so output '-' and negate */
		*p++ = '-';
		val = (unsigned long)(-(long)val);
	}

	firstdig = p;		/* save pointer to first digit */

	do {
		digval = (unsigned) (val % radix);
		val /= radix;	/* get next digit */

		/* convert to ascii and store */
		if (digval > 9)
			*p++ = (char) (digval - 10 + 'a');	/* a letter */
		else
			*p++ = (char) (digval + '0');		/* a digit */
	} while (val > 0);

	/* We now have the digit of the number in the buffer, but in reverse
	   order.  Thus we reverse them now. */

	*p-- = '\0';		/* terminate string; p points to last digit */

	do {
		temp = *p;
		*p = *firstdig;
		*firstdig = temp;	/* swap *p and *firstdig */
		--p;
		++firstdig;		/* advance to next two digits */
	} while (firstdig < p); /* repeat until halfway */
}


/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

char * _CALLTYPE1 _itoa (
	int val,
	char *buf,
	int radix
	)
{
	if (radix == 10 && val < 0)
		xtoa((unsigned long)val, buf, radix, 1);
	else
		xtoa((unsigned long)(unsigned int)val, buf, radix, 0);
	return buf;
}

char * _CALLTYPE1 _ltoa (
	long val,
	char *buf,
	int radix
	)
{
	xtoa((unsigned long)val, buf, radix, (radix == 10 && val < 0));
	return buf;
}

char * _CALLTYPE1 _ultoa (
	unsigned long val,
	char *buf,
	int radix
	)
{
	xtoa(val, buf, radix, 0);
	return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\_ctype.c ===
/***
*_ctype.c - function versions of ctype macros
*
*	Copyright (c) 1989-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This files provides function versions of the character
*	classification and conversion macros in ctype.h.
*
*Revision History:
*	06-05-89  PHG	Module created
*	03-05-90  GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	09-27-90  GJF	New-style function declarators.
*	01-16-91  GJF	ANSI naming.
*	02-03-92  GJF	Got rid of #undef/#include-s, the MIPS compiler didn't
*			like 'em.
*	08-07-92  GJF	Fixed function calling type macros.
*
*******************************************************************************/

/***
*ctype - Function versions of ctype macros
*
*Purpose:
*	Function versions of the macros in ctype.h.  In order to define
*	these, we use a trick -- we undefine the macro so we can use the
*	name in the function declaration, then re-include the file so
*	we can use the macro in the definition part.
*
*	Functions defined:
*	    isalpha	isupper     islower
*	    isdigit	isxdigit    isspace
*	    ispunct	isalnum     isprint
*	    isgraph	isctrl	    __isascii
*	    __toascii	__iscsym    __iscsymf
*
*Entry:
*	int c = character to be tested
*Exit:
*	returns non-zero = character is of the requested type
*		   0 = character is NOT of the requested type
*
*Exceptions:
*	None.
*
*******************************************************************************/

#include <cruntime.h>
#define __STDC__ 1
#include <ctype.h>

int (__cdecl isalpha) (
	int c
	)
{
	return isalpha(c);
}

int (__cdecl isupper) (
	int c
	)
{
	return isupper(c);
}

int (__cdecl islower) (
	int c
	)
{
	return islower(c);
}

int (__cdecl isdigit) (
	int c
	)
{
	return isdigit(c);
}

int (__cdecl isxdigit) (
	int c
	)
{
	return isxdigit(c);
}

int (__cdecl isspace) (
	int c
	)
{
	return isspace(c);
}

int (__cdecl ispunct) (
	int c
	)
{
	return ispunct(c);
}

int (__cdecl isalnum) (
	int c
	)
{
	return isalnum(c);
}

int (__cdecl isprint) (
	int c
	)
{
	return isprint(c);
}

int (__cdecl isgraph) (
	int c
	)
{
	return isgraph(c);
}

int (__cdecl iscntrl) (
	int c
	)
{
	return iscntrl(c);
}

int (__cdecl __isascii) (
	int c
	)
{
	return __isascii(c);
}

int (__cdecl __toascii) (
	int c
	)
{
	return __toascii(c);
}

int (__cdecl __iscsymf) (
	int c
	)
{
	return __iscsymf(c);
}

int (__cdecl __iscsym) (
	int c
	)
{
	return __iscsym(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\wcsupr.c ===
/***
*wcsupr.c - routine to map lower-case characters in a wchar_t string
*	to upper-case
*
*	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Converts all the lower case characters in a wchar_t string
*	to upper case, in place.
*
*Revision History:
*	09-09-91   ETC	Created from strupr.c and wcslwr.c
#	04-06-92   KRS	Make work without _INTL also.
#	08-19-92   KRS	Activate NLS support.
*	08-22-92   SRW	Allow INTL definition to be conditional for building ntcrt.lib
*	09-02-92   SRW	Get _INTL definition via ..\crt32.def
*	02-16-93   CFW	Optimize test for lowercase in "C" locale.
*       06-02-93   SRW  ignore _INTL if _NTSUBSET_ defined.
*
*******************************************************************************/

#include <windows.h>
#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <os2dll.h>

/***
*wchar_t *_wcsupr(string) - map lower-case characters in a string to upper-case
*
*Purpose:
*	wcsupr converts lower-case characters in a null-terminated wchar_t 
*	string to their upper-case equivalents.  The result may be longer or
*	shorter than the original string.  Assumes enough space in string
*	to hold the result.
*
*Entry:
*	wchar_t *wsrc - wchar_t string to change to upper case
*
*Exit:
*	input string address
*
*Exceptions:
*	on an error, the original string is unaltered
*
*******************************************************************************/

wchar_t * _CALLTYPE1 _wcsupr (
	wchar_t * wsrc
	)
{
#if defined(_INTL) && !defined(_NTSUBSET_)
	wchar_t *p;		/* traverses string for C locale conversion */
	wchar_t *wdst = NULL;	/* wide version of string in alternate case */
	int srclen;		/* general purpose length of source string */
	int dstlen;		/* len of wdst string, wide chars, no null  */

	_mlock (_LC_CTYPE_LOCK);

	if (_lc_handle[LC_CTYPE] == _CLOCALEHANDLE) {
		_munlock (_LC_CTYPE_LOCK);
		for (p=wsrc; *p; p++)
		{
			if (*p >= (wchar_t)L'a' && *p <= (wchar_t)L'z')
				*p = *p - (L'a' - L'A');
		}
		return (wsrc);
	} /* C locale */

	/* Inquire size of wdst string */
	srclen = wcslen(wsrc) + 1;
	if ((dstlen=LCMapStringW(_lc_handle[LC_CTYPE], LCMAP_UPPERCASE, wsrc, 
		srclen, wdst, 0)) == 0)
		goto error_cleanup;

	/* Allocate space for wdst */
	if ((wdst = (wchar_t *) malloc(dstlen*sizeof(wchar_t))) == NULL)
		goto error_cleanup;

	/* Map wrc string to wide-character wdst string in alternate case */
	if (LCMapStringW(_lc_handle[LC_CTYPE], LCMAP_UPPERCASE, wsrc,
		srclen, wdst, dstlen) == 0)
		goto error_cleanup;

	/* Copy wdst string to user string */
	wcscpy (wsrc, wdst);

error_cleanup:
	_munlock (_LC_CTYPE_LOCK);
	free (wdst);
#else
	wchar_t * p;

	for (p=wsrc; *p; ++p)
	{
		if (L'a' <= *p && *p <= L'z')
			*p += (wchar_t)(L'A' - L'a');
	}

#endif /* _INTL */
	return (wsrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\exsup.asm ===
;***
;exsup.asm
;
;	Copyright (c) 1993-1994 Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This file contains those routines
;	common to both C8.0 and C9.0.
;
;Notes:
;
;Revision History:
;	04-13-93  JWM	setjmp(), longjmp() & raisex() moved to setjmp.asm;
;                       common data definitions moved to exsup.inc.
;	10-18-93  GJF	Ensure direction flag is clear in _except_handler2
;	12-16-93  PML	Accept <0,0,>0 from except filter, not just -1,0,+1
;	01-10-94  PML	Moved C8-specific __except_handler2 to exsup2.inc.
;			Only C8/C9 common routines left here.
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not
;			0.
;
;*******************************************************************************

;hnt = -D_WIN32_ -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

ifdef _WIN32_
_WIN32_OR_POSIX_ equ 1
endif
ifdef _POSIX_
_WIN32_OR_POSIX_ equ 1
endif

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.mas
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

ifdef _WIN32_OR_POSIX_
extrn _RtlUnwind@16:near
endif

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
_EXCEPTION_REGISTRATION_COMMON struc           ; C8.0/C9.0 common only
                    dd      ?       ; prev (OS-req, def'd in exsup.inc)
                    dd      ?       ; handler (ditto)
scopetable          dd      ?       ; C8/C9 common
trylevel            dd      ?       ; C8/C9 common
_EXCEPTION_REGISTRATION_COMMON ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

assumes DS,DATA
assumes FS,DATA

public __except_list
__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE
if	@Version LT 600
ifdef _WIN32_OR_POSIX_
;this needs to go here to work around a masm5 bug. (emits wrong fixup)
assumes CS,FLAT
else
assumes CS,CODE
endif
endif

ifdef _WIN32_OR_POSIX_          ;{

;NB: call to RtlUnwind appears to trash ebx! and possibly others so just
; to be save, we save all callee save regs.
cProc _global_unwind2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  stop
cBegin
        push    0                       ; ReturnValue
        push    0                       ; ExceptionRecord
        push    offset flat:_gu_return  ; TargetIp
        push    stop                    ; TargetFrame

        call    _RtlUnwind@16
_gu_return:
cEnd

else            ;}{

;/* _GLOBAL_UNWIND2 - */
;void _global_unwind2(PEXCEPTION_REGISTRATION *stop)
;{
;    for(xr=__except_list; xr!=stop; xr=xr->prev){
;       assert(xr!=NULL);
;       /* NOTE: must set ebp to this scopes frame before call */
;       _local_unwind2(xr, -1);
;    }
;}
cProc _global_unwind2,<C,PUBLIC>,<ISI,IDI>
        parmDP  stop
        localV  xr,SIZEOF_EXCEPTION_RECORD
cBegin
        ;build an EXCEPTION_RECORD to pass to language handler for unwinding
        lea     esi, xr
        mov     [esi.exception_number], 0
        mov     [esi.exception_flags], EXCEPTION_UNWIND_CONTEXT
        ;REVIEW: fill in the rest of the struct?

        mov     edi, dword ptr fs:__except_list
_gu_top:
        cmp     edi, stop
        je      short _gu_done
	cmp	edi, -1 		; -1 means no higher-level handler
        je      short _gu_error

        push    edi
        push    esi
        call    [edi.handler]
        add     esp, 8

        mov     edi, [edi.prev]
        mov     dword ptr fs:__except_list, edi
        jmp     short _gu_top

_gu_error:
        ;assert(0);

_gu_done:
cEnd

endif           ;}

;_unwind_handler(
;  PEXCEPTION_RECORD xr,
;  PREGISTRATION_RECORD establisher,
;  PCONTEXT context,
;  PREGISTRATION_RECORD dispatcher);
;
;this is a special purpose handler used to guard our local unwinder.
; its job is to catch collided unwinds.
;
;NB: this code is basically stolen from the NT routine xcptmisc.asm
; and is basically the same method used by the system unwinder (RtlUnwind).
;
cProc _unwind_handler,<C>
cBegin
        mov     ecx, dword ptr [esp+4]
        test    dword ptr [ecx.exception_flags], EXCEPTION_UNWIND_CONTEXT
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jz      short _uh_return

    ; We collide in a _local_unwind.  We set the dispatched to the
    ; establisher just before the local handler so we can unwind
    ; any future local handlers.

        mov     eax, [esp+8]            ; Our establisher is the one
                                        ; in front of the local one

        mov     edx, [esp+16]
        mov     [edx], eax              ; set dispatcher to local_unwind2

        mov     eax, DISPOSITION_COLLIDED_UNWIND
_uh_return:
cEnd

;/* _LOCAL_UNWIND2 - run all termination handlers listed in the scope table
; * associated with the given registration record, from the current lexical
; * level through enclosing levels up to, but not including the given 'stop'
; * level.
; */
;void _local_unwind2(PEXCEPTION_REGISTRATION xr, int stop)
;{
;    int ix;
;
;    for(ix=xr->trylevel; ix!=-1 && ix!=stop; ix=xr->xscope[i].enclosing_level){
;       /* NULL indicates that this entry is for a termination handler */
;       if(xr->xscope[i].filter==NULL){
;           /* NB: call to the termination handler may trash callee save regs */
;           (*xr->xscope[i].specific_handler)();
;       }
;    }
;    xr->trylevel=stop;
;}
;/* NOTE: frame (ebp) is setup by caller of __local_unwind2 */
cProc _local_unwind2,<C,PUBLIC>
cBegin
        push    ebx
        push    esi
        push    edi     ;call to the handler may trash, so we must save it

        mov     eax, [esp+16]           ; (eax) = PEXCEPTION_REGISTRATION

        ;link in a handler to guard our unwind
	push	eax
        push    TRYLEVEL_INVALID
        push    OFFSET FLAT:__unwind_handler
        push    fs:__except_list
        mov     fs:__except_list, esp

_lu_top:
        mov     eax, [esp+32]           ; (eax) = PEXCEPTION_REGISTRATION
        mov     ebx, [eax.scopetable]
        mov     esi, [eax.trylevel]

        cmp     esi, -1                 ; REVIEW: do we need this extra check?
        je      short _lu_done
        cmp     esi, [esp+36]
        je      short _lu_done

        lea     esi, [esi+esi*2]        ; esi*= 3

        mov     ecx, [(ebx+esi*4).enclosing_level]
        mov     [esp+8], ecx            ; save enclosing level
        mov     [eax.trylevel], ecx

        cmp     dword ptr [(ebx+esi*4).filter], 0
        jnz     short _lu_continue

        call    [(ebx+esi*4).specific_handler]

_lu_continue:
        jmp     short _lu_top

_lu_done:
        pop     fs:__except_list
        add     esp, 4*3                ; cleanup stack

        pop     edi                     ; restore c-runtime registers
        pop     esi
        pop     ebx
cEnd

;/* _ABNORMAL_TERMINATION - return TRUE if __finally clause entered via
; * _local_unwind2.
; */
;BOOLEAN _abnormal_termination(void);
cProc _abnormal_termination,<C,PUBLIC>
cBegin
        xor     eax, eax                ; assume FALSE

        mov     ecx, fs:__except_list
        cmp     [ecx.handler], offset FLAT:__unwind_handler
        jne     short _at_done          ; UnwindHandler first?

        mov     edx, [ecx+12]           ; establisher of local_unwind2
        mov     edx, [edx.trylevel]     ; is trylevel the same as the
        cmp     [ecx+8], edx            ; local_unwind level?
        jne     short _at_done          ; no - then FALSE

        mov     eax, 1                  ; currently in _abnormal_termination
_at_done:
cEnd


EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\exsup.inc ===
;***
;exsup.inc
;
;	Copyright (C) 1993, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Common data structures & definitions for exsup.asm and other
;	Structured Exception Handling support modules.
;
;Revision History:
;	04-13-93  JWM	Initial version
;	12-05-93  PML	Update for C9.0
;	01-12-94  PML	Move jmp_buf struct here, add new fields
;
;******************************************************************************


;handler dispositions
DISPOSITION_DISMISS             equ     0
DISPOSITION_CONTINUE_SEARCH     equ     1
DISPOSITION_NESTED_EXCEPTION    equ     2
DISPOSITION_COLLIDED_UNWIND     equ     3

;filter return codes
FILTER_ACCEPT           equ     1
FILTER_DISMISS          equ     -1
FILTER_CONTINUE_SEARCH  equ     0

;handler flags settings..
EXCEPTION_UNWINDING     equ     2
EXCEPTION_EXIT_UNWIND   equ     4
EXCEPTION_UNWIND_CONTEXT equ    EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

TRYLEVEL_NONE           equ     -1
TRYLEVEL_INVALID        equ     -2

;callback interface codes (mimimal required set)
CB_GET_MAX_CODE		equ	0
CB_DO_LOCAL_UNWIND	equ	1
CB_GET_FRAME_EBP	equ	2
CB_GET_SCOPE_INDEX	equ	3
CB_GET_SCOPE_DATA	equ	4
MAX_CALLBACK_CODE	equ	4

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_EXCEPTION_REGISTRATION struc
    prev                dd      ?
    handler             dd      ?
_EXCEPTION_REGISTRATION ends

;setjmp/longjmp buffer
_JMP_BUF struc
    saved_ebp           dd      ?
    saved_ebx           dd      ?
    saved_edi           dd      ?
    saved_esi           dd      ?
    saved_esp           dd      ?
    saved_return        dd      ?
    saved_xregistration dd      ?
    saved_trylevel      dd      ?
    ; following only found in C9.0 or later jmp_buf
    version_cookie	dd	?
    unwind_func		dd	?
    unwind_data		dd	6 dup(?)
_JMP_BUF ends

; Cookie placed in the jmp_buf to identify the new, longer form
JMPBUF_COOKIE	equ	'VC20'

; Offset of TryLevel in a C8.0 SEH registration node
C8_TRYLEVEL	equ	12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\exsup3.asm ===
;***
;exsup3.asm
;
;	Copyright (c) 1994 Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This is just the C9.0 version of
;	the language-specific exception handler.  The C8.0 version is
;	found in exsup2.asm, and the routines common to both C8 and C9
;	are found in exsup.asm.
;
;Notes:
;
;Revision History:
;	01-10-94  PML	Create VC/C++ 2.0 (C9.0) version from C8.0 original
;
;*******************************************************************************

;hnt = -D_WIN32_ -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

ifdef _WIN32_
_WIN32_OR_POSIX_ equ 1
endif
ifdef _POSIX_
_WIN32_OR_POSIX_ equ 1
endif

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.mas
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;/* _esp, xpointers at negative offset */
;     int _esp;
;     PEXCEPTION_POINTERS xpointers;
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
;private (at negative offsets from node ptr)
    _esp		=	-8
    xpointers		=	-4
_C9_EXCEPTION_REGISTRATION struc	; C9.0 version
;public:
                        dd      ?	; prev (common)
                        dd      ?	; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
_C9_EXCEPTION_REGISTRATION ends
FRAME_EBP_OFFSET equ 16

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE
if	@Version LT 600
ifdef _WIN32_OR_POSIX_
;this needs to go here to work around a masm5 bug. (emits wrong fixup)
assumes CS,FLAT
else
assumes CS,CODE
endif
endif

;/* _EXCEPT_HANDLER3 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler3(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
	db	'VC20'	;; VC/C++ 2.0/32-bit (C9.0) version
	db	'XC00'	;; so debugger can recognize this proc (cuda:3936)
cProc _except_handler3,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  xrecord
        parmDP  registration
        parmDP  context
        parmDP  dispatcher
        localV  xp,SIZEOF_EXCEPTION_POINTERS
cBegin
	;4*4b for callee saves + 4b return address + 4b param = 24

	;DF in indeterminate state at time of exception, so clear it
	cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     short _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

	lea	ebp, FRAME_EBP_OFFSET[ebx]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

	; Accept <0, 0, >0 instead of just -1, 0, +1
	or	eax, eax
	jz	short _lh_continue
	js	short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
	lea	ebp, FRAME_EBP_OFFSET[ebx]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8

        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3
; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
	lea	ebp, FRAME_EBP_OFFSET[ebx]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
cEnd

public __seh_longjmp_unwind@4
__seh_longjmp_unwind@4 proc near
	push	ebp
	mov	ecx, 8[esp]
	mov	ebp, [ecx.saved_ebp]
	mov	eax, [ecx.saved_trylevel]
	push	eax
	mov	eax, [ecx.saved_xregistration]
	push	eax
	call	__local_unwind2
	add	esp, 8
	pop	ebp
	ret	4
__seh_longjmp_unwind@4 endp

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\memmove.asm ===
;***
;memmove.asm -
;
;	Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	memmove() copies a source memory buffer to a destination buffer.
;	Overlapping buffers are treated specially, to avoid propogation.
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

MEM_MOVE EQU 1
INCLUDE I386\MEMCPY.ASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\pversion.inc ===
;	SCCSID = "@(#)pversion.inc:1.8"
?PLM = 1
?WIN = 0
REALFAR = 0		; used for QC only
ifdef large
 ?LARGE		equ	1
endif
ifdef compact
 ?COMPACT	equ	1
endif
ifdef medium
 ?MEDIUM	equ	1
endif
ifdef small
 ?SMALL		equ	1
endif
ifdef small32
 ?SMALL32	equ	1
 memS32		=	1
else
 memS32		=	0
endif
ifdef flat32
 ?FLAT32	equ	1
 memF32		=	1
else
 memF32		=	0
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\memcmp.asm ===
page	,132
	title	memcmp - compare to blocks of memory
;***
;memcmp.asm - compare two blocks of memory
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines memcmp() - compare two memory blocks lexically and
;	find their order.
;
;Revision History:
;	05-16-83  RN	initial version
;	07-20-87  SKS	rewritten for speed
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int memcmp(buf1, buf2, count) - compare memory for lexical order
;
;Purpose:
;	Compares count bytes of memory starting at buf1 and buf2
;	and find if equal or which one is first in lexical order.
;
;	Algorithm:
;	int
;	memcmp (buf1, buf2, count)
;		char *buf1, *buf2;
;		unsigned count;
;	{
;		if (!count)
;			return(0);
;		while (--count && *buf1 == *buf2)
;			{
;			buf1++;
;			buf2++;
;			}
;		return(*buf1 - *buf2);
;	}
;
;Entry:
;	char *buf1, *buf2 - pointers to memory sections to compare
;	unsigned count - length of sections to compare
;
;Exit:
;	returns -1 if buf1 < buf2
;	returns  0 if buf1 == buf2
;	returns +1 if buf1 > buf2
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memcmp
memcmp	proc \
	uses edi esi, \
	buf1:ptr byte, \
	buf2:ptr byte, \
	count:IWORD

	mov	esi,buf1	; si = buf1
	mov	edi,buf2	; di = buf2

;
; choose ds:si=buf1 and es:di=buf2 so that the CARRY flag
; gets the right way by the REP CMPSB instruction below.
;
	xor	eax,eax
	mov	ecx,count
	jecxz	short done

	repe	cmpsb		; compare while equal, at most "count" bytes
	je	short done	; buf1 == buf2?  (AX = 0)
				;	buf1 < buf2	buf1 > buf2
	sbb	eax,eax 	;	AX=-1, CY=1	AX=0, CY=0
	sbb	eax,-1		;	AX=-1		AX=1
done:

ifdef	_STDCALL_
	ret	2*DPSIZE + ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

memcmp	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\memcpy.asm ===
page    ,132
        title   memcpy - Copy source memory bytes to destination
;***
;memcpy.asm - contains memcpy and memmove routines
;
;       Copyright (c) 1986-1991, Microsoft Corporation. All right reserved.
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are not treated specially, so propogation may occur.
;       memmove() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are treated specially, to avoid propogation.
;
;Revision History:
;       02-06-87  JCR   Added memmove entry
;       04-08-87  JCR   Conditionalized memmove/memcpy entries
;       06-30-87  SKS   Rewritten for speed and size
;       08-21-87  SKS   Fix return value for overlapping copies
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-19-88  JCR   Minor 386 corrections/enhancements
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       11-13-92  SRW   Make it fast with unaligned arguments
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

M_EXIT  macro
        mov     eax,[dst]       ; return pointer to destination
ifdef   _STDCALL_
        ret     2*DPSIZE + ISIZE ; _stdcall return
else
        ret                     ; _cdecl return
endif
        endm    ; M_EXIT

        CODESEG

page
;***
;memcpy - Copy source buffer to destination buffer
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination memory buffer.
;       This routine does NOT recognize overlapping buffers, and thus can lead
;       to propogation.
;       For cases where propogation must be avoided, memmove() must be used.
;
;       Algorithm:
;
;       void * memcpy(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               /*
;                * copy from lower addresses to higher addresses
;                */
;               while (count--)
;                       *dst++ = *src++;
;
;               return(ret);
;       }
;
;memmove - Copy source buffer to destination buffer
;
;Purpose:
;       memmove() copies a source memory buffer to a destination memory buffer.
;       This routine recognize overlapping buffers to avoid propogation.
;       For cases where propogation is not a problem, memcpy() can be used.
;
;   Algorithm:
;
;       void * memmove(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               if (dst <= src || dst >= (src + count)) {
;                       /*
;                        * Non-Overlapping Buffers
;                        * copy from lower addresses to higher addresses
;                        */
;                       while (count--)
;                               *dst++ = *src++;
;                       }
;               else {
;                       /*
;                        * Overlapping Buffers
;                        * copy from higher addresses to lower addresses
;                        */
;                       dst += count - 1;
;                       src += count - 1;
;
;                       while (count--)
;                               *dst-- = *src--;
;                       }
;
;               return(ret);
;       }
;
;
;Entry:
;       void *dst = pointer to destination buffer
;       const void *src = pointer to source buffer
;       size_t count = number of bytes to copy
;
;Exit:
;       Returns a pointer to the destination buffer in AX/DX:AX
;
;Uses:
;       CX, DX
;
;Exceptions:
;*******************************************************************************

ifdef	MEM_MOVE
        _MEM_     equ <memmove>
else
 	_MEM_	  equ <memcpy>
endif

%       public  _MEM_
_MEM_   proc \
        uses edi esi, \
        dst:ptr byte, \
        src:ptr byte, \
        count:IWORD

              ; destination pointer
              ; source pointer
              ; number of bytes to copy

        mov     esi,[src]       ; esi = source
        mov     edi,[dst]       ; edi = dest
        mov     ecx,[count]     ; ecx = number of bytes to move

;
; Check for overlapping buffers:
;       If (dst <= src) Or (dst >= src + Count) Then
;               Do normal (Upwards) Copy
;       Else
;               Do Downwards Copy to avoid propagation
;

        cmp     edi,esi         ; dst <= src ?
        jbe     short CopyUp    ; yes, copy toward higher addresses

        mov     eax,esi
        add     eax,ecx
        cmp     edi,eax         ; dst >= (src + count) ?
        jnae    CopyDown        ; no, copy toward lower addresses

;
; Copy toward higher addresses.
;
CopyUp:

;
; The algorithm for forward moves is to align the destination to a dword
; boundary and so we can move dwords with an aligned destination.  This
; occurs in 3 steps.
;
;   - move x = ((4 - Dest & 3) & 3) bytes
;   - move y = ((L-x) >> 2) dwords
;   - move (L - x - y*4) bytes
;
        test    edi,11b          ; destination dword aligned?
        jnz     short byterampup ; if we are not dword aligned already, align

        mov     edx,ecx         ; byte count
        and     edx,11b         ; trailing byte count
        shr     ecx,2           ; shift down to dword count
        rep     movsd           ; move all of our dwords

        jmp     dword ptr TrailingVecs[edx*4]

        align   @WordSize
TrailingVecs    dd      Trail0, Trail1, Trail2, Trail3

        align   @WordSize
Trail3:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        mov     [edi+2],al

        M_EXIT

        align   @WordSize
Trail2:
        mov     ax,[esi]
        mov     [edi],ax

        M_EXIT

        align   @WordSize
Trail1:
        mov     al,[esi]
        mov     [edi],al

Trail0:
        M_EXIT

;
; Code to do optimal memory copies for non-dword-aligned destinations.
;
        align   @WordSize
byterampup:

; The following length check is done for two reasons:
;
;    1. to ensure that the actual move length is greater than any possiale
;       alignment move, and
;
;    2. to skip the multiple move logic for small moves where it would
;       be faster to move the bytes with one instruction.
;
; Leading bytes could be handled faster via split-out optimizations and
; a jump table (as trailing bytes are), at the cost of size.
;
; At this point, ECX is the # of bytes to copy, and EDX is the # of leading
; bytes to copy.
;
        cmp     ecx,12                  ; check for reasonable length
        jbe     short ShortMove         ; do short move if appropriate
        mov     edx,edi
        neg     edx
        and     edx,11b                 ; # of leading bytes
        sub     ecx,edx                 ; subtract out leading bytes
        mov     eax,ecx                 ; # of bytes remaining after leading
        mov     ecx,edx                 ; # of leading bytes
        rep     movsb                   ; copy leading bytes
        mov     ecx,eax                 ; compute number of dwords to move
        and     eax,11b                 ; # of trailing bytes
        shr     ecx,2                   ; # of whole dwords
        rep     movsd                   ; move whole dwords
        jmp     dword ptr TrailingVecs[eax*4] ; copy trailing bytes

;
; Simple copy, byte at a time. This could be faster with a jump table and
; split-out optimizations, copying as much as possible a dword/word at a
; time and using MOV with displacements, but such short cases are unlikely
; to be called often (it seems strange to call a function to copy less than
; three dwords).
;
        align   @WordSize
ShortMove:
        rep movsb

        M_EXIT

;
; Copy down to avoid propogation in overlapping buffers.
;
        align   @WordSize
CopyDown:
        std                     ; Set Direction Flag = Down
        add     esi,ecx         ; point to byte after end of source buffer
        add     edi,ecx         ; point to byte after end of dest buffer
;
; See if the destination start is dword aligned
;

        test    edi,11b
        jnz     short byterampup_copydown       ; not dword aligned
;
; Destination start is dword aligned
;
        mov     edx,ecx         ; set aside count of bytes to copy
        and     edx,11b         ; # of trailing bytes to copy
        sub     esi,4           ; point to start of first dword to copy
        sub     edi,4           ; point to start of first dword to copy to
        shr     ecx,2           ; dwords to copy
        rep     movsd           ; copy as many dwords as possible
        jmp     dword ptr TrailingVecs_copydown[edx*4] ;do any trailing bytes

        align   @WordSize
TrailingVecs_copydown   label   dword
        dd      Trail0_copydown
        dd      Trail1_copydown
        dd      Trail2_copydown
        dd      Trail3_copydown

        align   @WordSize
Trail3_copydown:
        mov     ax,[esi+2]
        mov     [edi+2],ax
        mov     al,[esi+1]
        mov     [edi+1],al
        cld                     ; Set Direction Flag = Up

        M_EXIT

        align   @WordSize
Trail2_copydown:
        mov     ax,[esi+2]
        mov     [edi+2],ax
        cld                     ; Set Direction Flag = Up

        M_EXIT

        align   @WordSize
Trail1_copydown:
        mov     al,[esi+3]
        mov     [edi+3],al
Trail0_copydown:
        cld                     ; Set Direction Flag = Up

        M_EXIT

;
; Destination start is not dword aligned.
;
; Leading bytes could be handled faster via split-out optimizations and
; a jump table (as trailing bytes are), at the cost of size.
;
; At this point, ECX is the # of bytes to copy, and EDX is the # of leading
; bytes to copy.
;
        align   @WordSize
byterampup_copydown:
        dec     esi             ; point to first leading src byte
        dec     edi             ; point to first leading dest byte
        cmp     ecx,12          ; check for reasonable length
        jbe     short ShortMove_copydown ; do short move if appropriate
        neg     edx
        and     edx,11b
        sub     ecx,edx         ; # of bytes after leading bytes
        mov     eax,ecx         ; set aside # of bytes remaining
        mov     ecx,edx         ; # of leading bytes
        rep     movsb           ; copy leading odd bytes
        mov     ecx,eax         ; # of remaining bytes
        and     eax,11b         ; # of trailing bytes
        sub     esi,3           ; point to start of first whole src dword
        sub     edi,3           ; point to start of first whole dest dword
        shr     ecx,2           ; # of whole dwords
        rep     movsd           ; copy whole dwords
        jmp     dword ptr TrailingVecs_copydown[eax*4]

        align   @WordSize
ShortMove_copydown:
        rep     movsb
        cld                     ; Set Direction Flag = Up

        M_EXIT

_MEM_   endp
        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\memset.asm ===
page	,132
	title	memset - set sections of memory all to one byte
;***
;memset.asm - set a section of memory to all one byte
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	contains the memset() routine
;
;Revision History:
;	05-07-84  RN	initial version
;	06-30-87  SKS	faster algorithm
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-19-88  JCR	Enable word alignment code for all models/CPUs,
;			Some code improvement
;	10-25-88  JCR	General cleanup for 386-only code
;	10-27-88  JCR	More optimization (dword alignment, no ebx usage, etc)
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
;
;Purpose:
;	Sets the first "count" bytes of the memory starting
;	at "dst" to the character value "val".
;
;	Algorithm:
;	char *
;	memset (dst, val, count)
;		char *dst;
;		char val;
;		unsigned int count;
;		{
;		char *start = dst;
;
;		while (count--)
;			*dst++ = val;
;		return(start);
;		}
;
;Entry:
;	char *dst - pointer to memory to fill with val
;	char val - value to put in dst bytes
;	int count - number of bytes of dst to fill
;
;Exit:
;	returns dst, with filled bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memset
memset proc \
	uses edi, \
	dst:ptr byte, \
	value:byte, \
	count:IWORD

	mov	ecx,[count]	; cx = count
	jecxz	short toend	; if no work to do

	; set all 4 bytes of eax to [value]
	mov	al,[value]	; the byte value to be stored
	mov	ah,al		; store it as a word
	mov	edx,eax 	; lo 16 bits dx=ax=val/val
	ror	eax,16		; move val/val to hi 16-bits
	mov	ax,dx		; eax = all 4 bytes = [value]

; Align address on dword boundary

	mov	edi,[dst]	; di = dest pointer
	mov	edx,edi 	; dx = di = *dst
	neg	edx
	and	edx,(ISIZE-1)	; dx = # bytes before dword boundary
	jz	short dwords	; jump if address already aligned

	cmp	ecx,edx 	; count >= # leading bytes??
	jb	short tail	; nope, just move ecx bytes

	sub	ecx,edx 	; cx = adjusted count (for later)
	xchg	ecx,edx 	; cx = leading byte count / dx = adjusted count
	rep	stosb		; store leading bytes
	mov	ecx,edx 	; cx = count of remaining bytes
	;jecxz	short toend	; jump out if nothing left to do

; Move dword-sized blocks

dwords:
	mov	edx,ecx 	; save original count
	shr	ecx,ISHIFT	; cx = dword count
	rep	stos IWORD ptr [edi]	; fill 'em up
	mov	ecx,edx 	; retrieve original byte count

; Move remaining bytes

tail:				; store remaining 1,2, or 3 bytes
	and	ecx,(ISIZE-1)	; get byte count
	rep	stosb		; store remaining bytes, if necessary

; Done

toend:
	mov	eax,[dst]	; return dest pointer

ifdef	_STDCALL_
	ret	DPSIZE + 2*ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

memset	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strchr.asm ===
page	,132
	title	strchr - search string for given character
;***
;strchr.asm - search a string for a given character
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strchr() - search a string for a character
;
;Revision History:
;	10-27-83  RN	initial version
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *strchr(string, c) - search a string for a character
;
;Purpose:
;	Searches a string for a given character, which may be the
;	null character '\0'.
;
;	Algorithm:
;	char *
;	strchr (string, ch)
;	      char *string, ch;
;	      {
;	      while (*string && *string != ch)
;		      string++;
;	      if (*string == ch)
;		      return(string);
;	      return((char *)0);
;	      }
;
;Entry:
;	char *string - string to search in
;	char c - character to search for
;
;Exit:
;	returns pointer to the first occurence of c in string
;	returns NULL if c does not occur in string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strchr
strchr	proc \
	uses edi, \
	string:ptr char, \
	chr:byte

	mov	edi,[string]	; edi = string

	push	edi		; save string pointer
	xor	eax,eax 	; null byte to search for
	mov	ecx, -1
repne	scasb			; find string length by scanning for null
	not	ecx		; cx = length of string
	mov	al,[chr]	; al=byte to search for
	pop	edi		; restore saved string pointer
repne	scasb			; find that byte (if it exists)!
				; edi points one past byte which stopped scan
	dec	edi		; edi points to byte which stopped scan

	cmp	[edi],al	; take one last look to be sure
	je	short retdi	; return edi if it matches
	xor	edi,edi 	; no match, so return NULL
retdi:
	mov	eax,edi 	; ret value: pointer to matching byte

ifdef	_STDCALL_
	ret	DPSIZE + ISIZE	; _stdcall return
else
	ret			; _cdecl return
endif

strchr	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strcat.asm ===
page	,132
	title	strcat - concatenate (append) one string to another
;***
;strcat.asm - contains strcat() and strcpy() routines
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	STRCAT concatenates (appends) a copy of the source string to the
;	end of the destination string, returning the destination string.
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	07-27-88  SJM	Rewritten to be 386-specific and to include strcpy
;	08-29-88  JCR	386 cleanup...
;	10-07-88  JCR	Correct off-by-1 strcat bug; optimize ecx=-1
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list


page
;***
;char *strcat(dst, src) - concatenate (append) one string to another
;
;Purpose:
;	Concatenates src onto the end of dest.	Assumes enough
;	space in dest.
;
;	Algorithm:
;	char * strcat (char * dst, char * src)
;	{
;	    char * cp = dst;
;
;	    while( *cp )
;		    ++cp;	    /* Find end of dst */
;	    while( *cp++ = *src++ )
;		    ;		    /* Copy src to end of dst */
;	    return( dst );
;	}
;
;Entry:
;	char *dst - string to which "src" is to be appended
;	const char *src - string to be appended to the end of "dst"
;
;Exit:
;	The address of "dst" in AX/DX:AX
;
;Uses:
;	BX, CX, DX
;
;Exceptions:
;
;*******************************************************************************

page
;***
;char *strcpy(dst, src) - copy one string over another
;
;Purpose:
;	Copies the string src into the spot specified by
;	dest; assumes enough room.
;
;	Algorithm:
;	char * strcpy (char * dst, char * src)
;	{
;	    char * cp = dst;
;
;	    while( *cp++ = *src++ )
;		    ;		    /* Copy src over dst */
;	    return( dst );
;	}
;
;Entry:
;	char * dst - string over which "src" is to be copied
;	const char * src - string to be copied over "dst"
;
;Exit:
;	The address of "dst" in AX/DX:AX
;
;Uses:
;	BX, CX, DX
;
;Exceptions:
;*******************************************************************************


    CODESEG

%   public  strcat, strcpy	; make both functions available

strcat	label proc	;--- strcat ---

	clc			; carry clear = append
	jmp	short _docat

	align	@wordsize	; want to come in on a nice boundary...
strcpy	label proc	;--- strcpy ---

	stc			; carry set = don't append to end of string
	;fall thru


; --- Common code ---

_docat	proc private \
	uses esi edi, \
	dst:ptr byte, \
	src:ptr byte

	mov	edi, dst	; di = dest pointer
	jc	short @F	; jump if not appending

	; now skip to end of destination string

	xor	eax, eax	; search for the null terminator
	or	ecx,-1		; ecx = -1
repne	scasb
	dec	edi		; edi points to null terminator

	; copy source string

@@:	mov	esi, src
	xchg	esi, edi	; now ds:esi->dst and es:edi->src
	xor	eax, eax	; search for null
	or	ecx,-1		; ecx = -1

repne	scasb			; find the length of the src string
	not	ecx
	sub	edi, ecx
	xchg	esi, edi	; now es:edi->dst and ds:esi->src

	mov	eax, ecx
	shr	ecx, ISHIFT	; get the double-word count
rep	movsd
	and	eax, (ISIZE-1)	; get the byte cound
	xchg	ecx, eax
rep	movsb			; move remaining bytes, if any
	mov	eax, dst	; returned address

ifdef	_STDCALL_
	ret	2*DPSIZE	; _stdcall return
else
	ret			; _cdecl return
endif

_docat	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strcspn.asm ===
;***
;strcspn.asm -
;
;	Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines strcspn()- finds the length of the initial substring of
;	a string consisting entirely of characters not in a control string.
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

SSTRCSPN EQU 1
INCLUDE I386\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strcmp.asm ===
page	,132
	title	strcmp.asm - compare two strings
;***
;strcmp.asm - routine to compare two strings (for equal, less, or greater)
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	STRCMP compares two strings and returns an integer
;	to indicate whether the first is less than the second, the two are
;	equal, or whether the first is greater than the second, respectively.
;	Comparison is done byte by byte on an UNSIGNED basis, which is to
;	say that Null (0) is less than any other character (1-255).
;
;Revision History:
;	04-21-87  SKS	Module rewritten to be fast and small
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	Minor 386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;strcmp - compare two strings, returning less than, equal to, or greater than
;
;Purpose:
;	Compares two string, determining their lexical order.  Unsigned
;	comparison is used.
;
;	Algorithm:
;	   int strcmp ( src , dst )
;		   unsigned char *src;
;		   unsigned char *dst;
;	   {
;		   int ret = 0 ;
;
;		   while( ! (ret = *src - *dst) && *dst)
;			   ++src, ++dst;
;
;		   if ( ret < 0 )
;			   ret = -1 ;
;		   else if ( ret > 0 )
;			   ret = 1 ;
;
;		   return( ret );
;	   }
;
;Entry:
;	const char * src - string for left-hand side of comparison
;	const char * dst - string for right-hand side of comparison
;
;Exit:
;	AX < 0, 0, or >0, indicating whether the first string is
;	Less than, Equal to, or Greater than the second string.
;
;Uses:
;	CX, DX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	.lall

	public	strcmp
strcmp	proc \
	uses edi esi, \
	src:ptr byte, \
	dst:ptr byte


	mov	esi,[src]	; si = source
	xor	eax,eax 	; mingle register instr with mem instr.
	mov	edi,[dst]	; di = dest

	or	ecx,-1		; cx = -1
	repne	scasb		; compute length of "dst"
	not	ecx		; CX = strlen(dst)+1
	sub	edi,ecx 	; restore DI = dst
	repe	cmpsb		; compare while equal, at most length of "dst"
	je	short toend	; dst == src?  (AX = 0)
				;	dst < src	dst > src
	sbb	eax,eax 	;	AX=-1, CY=1	AX=0, CY=0
	sbb	eax,-1		;	AX=-1		AX=1
toend:

ifdef	_STDCALL_
	ret	2*DPSIZE	; _stdcall return
else
	ret			; _cdecl return
endif

strcmp	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strlen.asm ===
page	,132
	title	strlen - return the length of a null-terminated string
;***
;strlen.asm - contains strlen() routine
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	strlen returns the length of a null-terminated string,
;	not including the null byte itself.
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-02-88  SJM	Add 32 bit code, use cruntime vs cmacros
;	08-23-88  JCR	386 cleanup
;	10-05-88  GJF	Fixed off-by-2 error.
;	10-10-88  JCR	Minor improvement
;	10-25-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;strlen - return the length of a null-terminated string
;
;Purpose:
;	Finds the length in bytes of the given string, not including
;	the final null character.
;
;	Algorithm:
;	int strlen (const char * str)
;	{
;	    int length = 0;
;
;	    while( *str++ )
;		    ++length;
;
;	    return( length );
;	}
;
;Entry:
;	const char * str - string whose length is to be computed
;
;Exit:
;	AX = length of the string "str", exclusive of the final null byte
;
;Uses:
;	CX, DX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strlen
strlen	proc \
	uses edi, \
	string:ptr byte

	mov	edi,string	; edi -> string
	xor	eax,eax 	; null byte
	or	ecx,-1		; set ecx to -1
repne	scasb			; scan for null, ecx = -(1+strlen(str))
	not	ecx
	dec	ecx		; ecx = strlen(str)
	mov	eax,ecx 	; eax = strlen(str)

ifdef	_STDCALL_
	ret	DPSIZE		; _stdcall return
else
	ret			; _cdecl return
endif

strlen	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\daytona\dummy.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strnicmp.asm ===
page	,132
	title	strnicmp - compare n chars of strings, ignore case
;***
;strnicmp.asm - compare n chars of strings, ignoring case
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strnicmp() - Compares at most n characters of two strings,
;	without regard to case.
;
;Revision History:
;	04-04-85  RN	initial version
;	07-11-85  TC	zeroed cx, to allow correct return value if not equal
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup and improved return value sequence
;	10-26-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list


page
;***
;int _strnicmp(first, last, count) - compares count char of strings, ignore case
;
;Purpose:
;	Compare the two strings for lexical order.  Stops the comparison
;	when the following occurs: (1) strings differ, (2) the end of the
;	strings is reached, or (3) count characters have been compared.
;	For the purposes of the comparison, upper case characters are
;	converted to lower case.
;
;	Algorithm:
;	int
;	_strncmpi (first, last, count)
;	      char *first, *last;
;	      unsigned int count;
;	      {
;	      int f,l;
;	      int result = 0;
;
;	      if (count) {
;		      do      {
;			      f = tolower(*first);
;			      l = tolower(*last);
;			      first++;
;			      last++;
;			      } while (--count && f && l && f == l);
;		      result = f - l;
;		      }
;	      return(result);
;	      }
;
;Entry:
;	char *first, *last - strings to compare
;	unsigned count - maximum number of characters to compare
;
;Exit:
;	returns <0 if first < last
;	returns 0 if first == last
;	returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strnicmp
_strnicmp proc \
	uses edi esi ebx, \
	first:ptr byte, \
	last:ptr byte, \
	count:IWORD


	mov	esi,[first]	; si = first string
	mov	edi,[last]	; di = last string

	mov	ecx,[count]	; cx = byte count
	jecxz	short toend	; if count=0

	mov	bh,'A'
	mov	bl,'Z'
	mov	dh,'a'-'A'	; add to cap to make lower

lupe:
	mov	ah,[esi]	; *first
	mov	al,[edi]	; *last

	or	ah,ah		; see if *first is null
	jz	short eject	;   jump if so

	or	al,al		; see if *last is null
	jz	short eject	;   jump if so

	inc	esi		; first++
	inc	edi		; last++

	cmp	ah,bh		; 'A'
	jb	short skip1

	cmp	ah,bl		; 'Z'
	ja	short skip1

	add	ah,dh		; make lower case

skip1:
	cmp	al,bh		; 'A'
	jb	short skip2

	cmp	al,bl		; 'Z'
	ja	short skip2

	add	al,dh		; make lower case

skip2:
	cmp	ah,al		; *first == *last ??
	jne	short differ

	loop	lupe

eject:
	xor	ecx,ecx
	cmp	ah,al		; compare the (possibly) differing bytes
	je	short toend	; both zero; return 0

differ:
	mov	ecx,-1		; assume last is bigger (* can't use 'or' *)
	jb	short toend	; last is, in fact, bigger (return -1)
	neg	ecx		; first is bigger (return 1)

toend:
	mov	eax,ecx

ifdef	_STDCALL_
	ret	2*DPSIZE + ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

_strnicmp endp
	 end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strncpy.asm ===
page	,132
	title	strncpy - copy at most n characters of string
;***
;strncpy.asm - copy at most n characters of string
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strncpy() - copy at most n characters of string
;
;Revision History:
;	10-25-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *strncpy(dest, source, count) - copy at most n characters
;
;Purpose:
;	Copies count characters from the source string to the
;	destination.  If count is less than the length of source,
;	NO NULL CHARACTER is put onto the end of the copied string.
;	If count is greater than the length of sources, dest is padded
;	with null characters to length count.
;
;	Algorithm:
;	char *
;	strncpy (dest, source, count)
;	      char *dest, *source;
;	      unsigned count;
;	      {
;	      char *start = dest;
;
;	      while (count && (*dest++ = *source++))
;		      count--;
;	      if (count)
;		      while (--count)
;			      *dest++ = '\0';
;	      return(start);
;	      }
;
;Entry:
;	char *dest - pointer to spot to copy source, enough space
;	is assumed.
;	char *source - source string for copy
;	unsigned count - characters to copy
;
;Exit:
;	returns dest, with the character copied there.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strncpy
strncpy proc \
	uses edi esi, \
	dest:ptr byte, \
	sorc:ptr byte, \
	count:IWORD


	mov	edi,[dest]	; di=pointer to dest
	mov	esi,[sorc]	; si=pointer to source

	mov	edx,edi 	; dx saves dest pointer
	mov	ecx,[count]	; get the max char count
	jecxz	short toend	; don't do loop if nothing to move

lupe:
	lodsb			; get byte into al and kick si
	or	al,al		; see if we just moved a null
	jz	short outlupe	; end of string

	stosb			; store byte from al and kick di
	loop	lupe		; dec cx & jmp to lupe if nonzero
				; else drop out
outlupe:
	xor	al,al		; null byte to store
rep	stosb			; store null for all cx>0

toend:
	mov	eax,edx 	; return value: dest addr

ifdef	_STDCALL_
	ret	2*DPSIZE + ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

strncpy endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strrchr.asm ===
page	,132
	title	strrchr - find last occurence of character in string
;***
;strrchr.asm - find last occurrence of character in string
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strrchr() - find the last occurrence of a given character
;	in a string.
;
;Revision History:
;	10-27-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *strrchr(string, ch) - find last occurrence of ch in string
;
;Purpose:
;	Finds the last occurrence of ch in string.  The terminating
;	null character is used as part of the search.
;
;	Algorithm:
;	char *
;	strrchr (string, ch)
;	      char *string, ch;
;	      {
;	      char *start = string;
;
;	      while (*string++)
;		      ;
;	      while (--string != start && *string != ch)
;		      ;
;	      if (*string == ch)
;		      return(string);
;	      return(NULL);
;	      }
;
;Entry:
;	char *string - string to search in
;	char ch - character to search for
;
;Exit:
;	returns a pointer to the last occurrence of ch in the given
;	string
;	returns NULL if ch does not occurr in the string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strrchr
strrchr proc \
	uses edi, \
	string:ptr byte, \
	chr:byte

	mov	edi,[string]	; di = string
	xor	eax,eax 	; al=null byte
	or	ecx,-1		; cx = -1
repne	scasb			; find the null & count bytes
	inc	ecx		; cx=-byte count (with null)
	neg	ecx		; cx=+byte count (with null)
	dec	edi		; di points to terminal null
	mov	al,chr		; al=search byte
	std			; count 'down' on string this time
repne	scasb			; find that byte
	inc	edi		; di points to byte which stopped scan

	cmp	[edi],al	; see if we have a hit
	je	short returndi	; yes, point to byte

	xor	eax,eax 	; no, return NULL
	jmp	short toend	; do return sequence

returndi:
	mov	eax,edi 	; ax=pointer to byte

toend:
	cld

ifdef	_STDCALL_
	ret	DPSIZE + ISIZE	; _stdcall return
else
	ret			; _cdecl return
endif

strrchr endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\stricmp.asm ===
page	,132
	title	stricmp
;***
;strcmp.asm - contains case-insensitive string comparision routine
;	_stricmp/_strcmpi
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	contains _stricmpi(), also known as _strcmpi()
;
;Revision History:
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	Minor 386 cleanup
;	10-10-88  JCR	Added strcmpi() entry for compatiblity with early revs
;	10-25-88  JCR	General cleanup for 386-only code
;	10-27-88  JCR	Shuffled regs so no need to save/restore ebx
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int _stricmp(dst, src), _strcmpi(dst, src) - compare strings, ignore case
;
;Purpose:
;	_stricmp/_strcmpi perform a case-insensitive string comparision.
;	For differences, upper case letters are mapped to lower case.
;	Thus, "abc_" < "ABCD" since "_" < "d".
;
;	Algorithm:
;
;	int _strcmpi (char * dst, char * src)
;	{
;		int f,l;
;
;		do {
;			f = tolower(*dst);
;			l = tolower(*src);
;			dst++;
;			src++;
;		} while (f && f == l);
;
;		return(f - l);
;	}
;
;Entry:
;	char *dst, *src - strings to compare
;
;Exit:
;	AX = -1 if dst < src
;	AX =  0 if dst = src
;	AX = +1 if dst > src
;
;Uses:
;	CX, DX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strcmpi	; alternate entry point for compatibility
_strcmpi label	 proc

	public	_stricmp
_stricmp proc \
	uses esi, \
	dst:ptr, \
	src:ptr


	mov	esi,[src]	; SI = src
	mov	edx,[dst]	; DX = dst
	mov	al,-1		; fall into loop

chk_null:
	or	al,al
	jz	short done
again:
	lodsb			; al = next source byte
	mov	ah,[edx]	; ah = next dest byte
	inc	edx

	cmp	ah,al		; first try case-sensitive comparision
	je	short chk_null	; match

	sub	al,'A'
	cmp	al,'Z'-'A'+1
	sbb	cl,cl
	and	cl,'a'-'A'
	add	al,cl
	add	al,'A'		; tolower(*dst)

	xchg	ah,al		; operations on AL are shorter than AH

	sub	al,'A'
	cmp	al,'Z'-'A'+1
	sbb	cl,cl
	and	cl,'a'-'A'
	add	al,cl
	add	al,'A'		; tolower(*src)

	cmp	al,ah		; inverse of above comparison -- AL & AH are swapped
	je	short chk_null
				; dst < src	dst > src
	sbb	al,al		; AL=-1, CY=1	AL=0, CY=0
	sbb	al,-1		; AL=-1 	AL=1
done:
	movsx	eax,al		; extend al to eax

ifdef	_STDCALL_
	ret	2*DPSIZE	; _stdcall return
else
	ret			; _cdecl return
endif

_stricmp endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strstr.asm ===
page	,132
	title	strstr - search for one string inside another
;***
;strstr.asm - search for one string inside another
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strstr() - search for one string inside another
;
;Revision History:
;	02-02-88  SKS	Rewritten from scratch.  Now works correctly with
;			strings > 32 KB in length.  Also smaller and faster.
;	03-01-88  SKS	Ensure that ES = DS right away (Small/Medium models)
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-18-88  PHG	Corrected return value when src is empty string
;			to conform with ANSI.
;	08-23-88  JCR	Minor 386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *strstr(string1, string2) - search for string2 in string1
;
;Purpose:
;	finds the first occurrence of string2 in string1
;
;Entry:
;	char *string1 - string to search in
;	char *string2 - string to search for
;
;Exit:
;	returns a pointer to the first occurrence of string2 in
;	string1, or NULL if string2 does not occur in string1
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strstr
strstr proc \
	uses esi edi ebx, \
	dst:ptr byte, \
	src:ptr byte

	local	srclen:IWORD


	mov	edi, (src)	; di = src
	xor	eax,eax 	; Scan for null at end of (src)
	or	ecx,-1		; cx = -1
repnz	scasb
	not	ecx
	dec	ecx
	jecxz	short empty_src ; src == "" ?
	dec	ecx		; CX = strlen(src)-1
	mov	(srclen),ecx

	mov	edi,(dst)
	mov	ebx,edi 	; BX will keep the current offset into (dst)

	xor	eax,eax 	; Scan for null at end of (dst)
	or	ecx,-1		; cx = -1
repnz	scasb
	not	ecx
	dec	ecx		; CX = strlen(dst)

	mov	edx,ecx 	; Save strlen(dst) in DX

	sub	edx,(srclen)	; DX = strlen(dst) - (strlen(src)-1)
	jbe	short not_found ; strlen(dst) <= (strlen(src)-1)
				; target is longer than source?
	mov	edi,ebx 	; restore ES:DI = (dst)

findnext:
	mov	esi,IWORD ptr (src)
	lodsb			; Get the first byte of the source
	mov	edi,ebx 	; restore position in source
	mov	ecx,edx 	; count of possible starting bytes in src
;
;	CX, DX = number of bytes left in source where target can still fit
;	DI, BX = current position in (dst)
;	DS:SI = (src) + 1
;	AL = *(src)
;

repne	scasb			; find next occurrence of *(target) in dst
	jne	short not_found ; out of string -- return NULL

	mov	edx,ecx 	; update count of acceptable bytes left in dst
	mov	ebx,edi 	; save current offset in dst

	mov	ecx,(srclen)
	jecxz	short match	; single character src string?

repe	cmpsb
	jne	short findnext

;
; Match!  Return (BX-1)
;
match:
	lea	eax,[ebx-1]
	jmp	short retval

empty_src:			; empty src string, return dst (ANSI mandated)
	mov	eax,(dst)	; eax = dst
	jmp	short retval	; return

not_found:
	xor	eax,eax

retval:

ifdef	_STDCALL_
	ret	2*DPSIZE	; _stdcall return
else
	ret			; _cdecl return
endif

strstr	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strupr.asm ===
page	,132
	title	strupr - map string to upper-case
;***
;strupr.asm - routine to map lower-case characters in a string to upper-case
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	_strupr() converts lower-case characters in a null-terminated string
;	to their upper-case equivalents.  Conversion is done in place and
;	characters other than lower-case letters are not modified.
;
;	This function modifies only 7-bit ASCII characters
;	in the range 0x61 through 0x7A ('a' through 'z').
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-19-88  JCR	Minor optimization
;	10-10-88  JCR	Changed an 'xchg' to 'mov'
;	10-26-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strupr(string) - map lower-case characters in a string to upper-case
;
;Purpose:
;	Converts all the lower case characters in string to upper case
;	in place.
;
;	Algorithm:
;	char * _strupr (char * string)
;	{
;	    char * cp = string;
;
;	    while( *cp )
;	    {
;		if ('a' <= *cp && *cp <= 'z')
;		    *cp += 'A' - 'a';
;		++cp;
;	    }
;	    return(string);
;	}
;
;Entry:
;	char *string - string to change to upper case
;
;Exit:
;	The input string address is returned in AX or DX:AX
;
;Uses:
;	BX, CX, DX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strupr
_strupr proc \
	string:ptr byte


	mov	ecx,[string]	; cx = *string
	mov	edx,ecx 	; save return value
	jmp	short first_char; jump into the loop

	align	@WordSize
check_char:
	sub	al,'a'		; 'a' <= al <= 'z' ?
	cmp	al,'z'-'a'+1
	jnb	short next_char
	add	al,'A'		; map to upper case
	mov	[ecx],al	; and store new value
next_char:
	inc	ecx		; bump pointer
first_char:
	mov	al,[ecx]	; get next character
	or	al,al
	jnz	short check_char

done:
	mov	eax,edx 	; ax = return value ("string")

ifdef	_STDCALL_
	ret	DPSIZE		; _stdcall return
else
	ret			; _cdecl return
endif

_strupr endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\chicago\i386\strspn.asm ===
page	,132
	title	strspn - search for init substring of chars from control str
;***
;strspn.asm - find length of initial substring of chars from a control string
;
;	Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strspn() - finds the length of the initial substring of
;	a string consisting entirely of characters from a control string.
;
;	defines strcspn()- finds the length of the initial substring of
;	a string consisting entirely of characters not in a control string.
;
;	defines strpbrk()- finds the index of the first character in a string
;	that is not in a control string
;
;Revision History:
;	10-28-83  RN	initial version
;	06-30-87  SKS	Faster version -- also reentrant
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-02-88  SJM	Created 386-specific version.
;	08-23-88  JCR	386 cleanup
;	10-10-88  JCR	Misc bug fixes
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	09-25-91  JCR	Build "strspn" if no other directives are given
;	01-17-92  GJF	Fixed build of "strspn".
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int strspn(string, control) - find init substring of control chars
;
;Purpose:
;	Finds the index of the first character in string that does belong
;	to the set of characters specified by control.	This is
;	equivalent to the length of the initial substring of string that
;	consists entirely of characters from control.  The '\0' character
;	that terminates control is not considered in the matching process.
;
;	Algorithm:
;	int
;	strspn (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		if (*string)
;		{
;			while (map[*string >> 3] & (1 << (*string & 7)))
;			{
;				count++;
;				string++;
;			}
;			return(count);
;		}
;		return(0);
;	}
;
;Entry:
;	char *string - string to search
;	char *control - string containing characters not to search for
;
;Exit:
;	returns index of first char in string not in control
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;int strcspn(string, control) - search for init substring w/o control chars
;
;Purpose:
;	returns the index of the first character in string that belongs
;	to the set of characters specified by control.	This is equivalent
;	to the length of the length of the initial substring of string
;	composed entirely of characters not in control.  Null chars not
;	considered.
;
;	Algorithm:
;	int
;	strcspn (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		map[0] |= 1;
;		while (!(map[*string >> 3] & (1 << (*string & 7))))
;		{
;			count++;
;			string++;
;		}
;		return(count);
;	}
;
;Entry:
;	char *string - string to search
;	char *control - set of characters not allowed in init substring
;
;Exit:
;	returns the index of the first char in string
;	that is in the set of characters specified by control.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;char *strpbrk(string, control) - scans string for a character from control
;
;Purpose:
;	Finds the first occurence in string of any character from
;	the control string.
;
;	Algorithm:
;	char *
;	strpbrk (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		while (*string)
;		{
;			if (map[*string >> 3] & (1 << (*string & 7)))
;				return(string);
;			string++;
;		}
;		return(NULL);
;	}
;
;Entry:
;	char *string - string to search in
;	char *control - string containing characters to search for
;
;Exit:
;	returns a pointer to the first character from control found
;	in string.
;	returns NULL if string and control have no characters in common.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


ifdef SSTRCSPN

    _STRSPN_ equ <strcspn>

elseifdef SSTRPBRK

    _STRSPN_ equ <strpbrk>

else

; Default is to build strspn()

    SSTRSPN equ 1
    _STRSPN_ equ <strspn>

endif

% public  _STRSPN_

    CODESEG

_STRSPN_ proc \
	uses edi esi, \
	string:ptr byte, \
	control:ptr byte

	local	map[8]:dword	; 8*4*8 = 256 bits

; Zero out char bit map

	mov	ecx, 8		; clear the 256 bits
	xor	eax, eax
	lea	edi, [map]
rep	stosd

; Set control char bits in map

	mov	esi,control	; si = control string

	align	@WordSize
lab listnext			; init char bit map
	lodsb
	or	al,al
	jz	short listdone
	bts	map, eax
	jmp	short listnext

lab listdone

; Loop through comparing source string with control bits

	mov	esi, string	; si = string

_ifnd	SSTRPBRK <dec	 ecx>	; set ecx to -1

	align	@WordSize
lab dstnext

_ifnd	SSTRPBRK <inc	 ecx>

	lodsb
	or	al,al
	jz	short dstdone
	bt	map, eax

ifdef SSTRSPN
	jc	short dstnext	; strspn: found char, continue
elseifdef SSTRCSPN
	jnc	short dstnext	; strcspn: did not find char, continue
elseifdef SSTRPBRK
	jnc	short dstnext	; strpbrk: did not find char, continue
	lea	eax,[esi-1]	; found char, return address of it
	jmp	short done
endif

; Return code

lab dstdone

ifndef	SSTRPBRK
	mov	eax,ecx 	; strspn/strcspn: return index
else
	xor	eax,eax 	; strpbrk: no chars in common, return NULL
done:

endif

ifdef	_STDCALL_
	ret	2*DPSIZE	; _stdcall return
else
	ret			; _cdecl return
endif

_STRSPN_ endp
	 end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\daytona\i386\atlssup.asm ===
; SCCSID = \%Z\%\%M\%:\%I\%

;hnt = -D_WIN32_ -Dsmall32 -Dflat32 -Mx $this;

.xlist
include cruntime.inc
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

		public	_tls_array 
_tls_array 	equ	2Ch	  ; TEB.ThreadLocalStoragePointer

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\i386\chkstk.asm ===
page	,132
	title	chkstk - C stack checking routine
;***
;chkstk.asm - C stack checking routine
;
;	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Provides support for automatic stack checking in C procedures
;	when stack checking is enabled.
;
;Revision History:
;	04-21-87  SKS	Added conditional assembly switch for STKHQQ = 0
;	07-23-87  MAG	[1] Added run-time CS:IP error processing for QC
;	08-17-87  JLS	[2] Remove all references to DGROUP
;	08-25-87  JLS	[3] Shift include files
;	11-13-87  SKS	OS/2 Reentrant version, add thread ID check
;	11-18-87  SKS	Make STKHQQ an array (oops!)
;	12-14-87  SKS	add .286p to allow PUSH immediate value
;	02-19-88  SKS	Change minimum bottom limit to STACKSLOP, not 0
;	06-01-88  PHG	Merge DLL and normal versions
;	09-21-88  WAJ	initial 386 version
;	10-18-88  JCR	Chkstk was trashing bx... not good on 386
;	06-06-89  JCR	386 mthread support
;	06-20-89  JCR	386: Removed _LOAD_DGROUP code
;	04-06-90  GJF	Fixed the copyright.
;	06-21-90  GJF	Rewritten to probe pages
;	10-15-90  GJF	Restored _end and STKHQQ.
;	03-19-91  GJF	Revised to preserve all registers except eax. Note
;			this is _rchkstk functionality so there is no longer
;			a separate _rchkstk routine.
;	08-01-91  GJF	Got rid of _end and STKHQQ, except for Cruiser
;			(probably not needed for Cruiser either) [_WIN32_].
;	09-27-91  JCR	Merged Stevewo' changes from NT tree
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

; size of a page of memory

_PAGESIZE_	equ	1000h


ifdef	_CRUISER_

	.data

extrn pascal _end:dword 	; stack bottom

ifndef	MTHREAD

public pascal STKHQQ			  ; used by parasitic heap
STKHQQ	dd	dataoffset _end+STACKSLOP ; initial value

endif	;MTHREAD

endif	;_CRUISER_

	CODESEG

page
;***
;_chkstk - check stack upon procedure entry
;
;Purpose:
;	Provide stack checking on procedure entry. Method is to simply probe
;	each page of memory required for the stack in descending order. This
;	causes the necessary pages of memory to be allocated via the guard
;	page scheme, if possible. In the event of failure, the OS raises the
;	_XCPT_UNABLE_TO_GROW_STACK exception.
;
;	NOTE:  Currently, the (EAX < _PAGESIZE_) code path falls through
;	to the "lastpage" label of the (EAX >= _PAGESIZE_) code path.  This
;	is small; a minor speed optimization would be to special case
;	this up top.  This would avoid the painful save/restore of
;	ecx and would shorten the code path by 4-6 instructions.
;
;Entry:
;	EAX = size of local frame
;
;Exit:
;	ESP = new stackframe, if successful
;
;Uses:
;	EAX
;
;Exceptions:
;	_XCPT_GUARD_PAGE_VIOLATION - May be raised on a page probe. NEVER TRAP
;				     THIS!!!! It is used by the OS to grow the
;				     stack on demand.
;	_XCPT_UNABLE_TO_GROW_STACK - The stack cannot be grown. More precisely,
;				     the attempt by the OS memory manager to
;				     allocate another guard page in response
;				     to a _XCPT_GUARD_PAGE_VIOLATION has
;				     failed.
;
;*******************************************************************************

labelP	_alloca_probe, PUBLIC
labelP	_chkstk,       PUBLIC

	push	ecx			; save ecx
	mov	ecx,esp 		; compute new stack pointer in ecx
	add	ecx,8			; correct for return address and saved
					; ecx value
probepages:
	cmp	eax,_PAGESIZE_		; more than one page requested?
	jb	short lastpage		;   no
	sub	ecx,_PAGESIZE_		; yes, move down a page and...
	or	dword ptr [ecx],0	; ...probe it
	sub	eax,_PAGESIZE_		; adjust request
	jmp	probepages

lastpage:
	sub	ecx,eax 		; move stack down by eax and do a...
	or	dword ptr [ecx],0	; ...probe in case a page was crossed
	mov	eax,esp 		; save pointer to current tos
	mov	esp,ecx 		; set the new stack pointer
	mov	ecx,dword ptr [eax]	; recover ecx
	mov	eax,dword ptr [eax + 4] ; recover return address
	jmp	eax			; return

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\daytona\tlssup.c ===
#ifdef	_MSC_VER


/* tlssup.c - Thread Local Storage runtime support module */

#include <nt.h>

/* Thread Local Storage index for this .EXE or .DLL */

ULONG _tls_index = 0;

/* Special symbols to mark start and end of Thread Local Storage area.
 * By convention, we initialize each with a pointer to it's own address. 
 */ 

#pragma data_seg(".tls")

PVOID _tls_start = &_tls_start;

#pragma data_seg(".tls$ZZZ")

PVOID _tls_end = &_tls_end;

/* Start and end sections for Threadl Local Storage CallBack Array.
 * Actual array is constructed using .CRT$XLA, .CRT$XLC, .CRT$XLL, 
 * .CRT$XLU, .CRT$XLZ similar to the way global
 *         static initializers are done for C++.
 */

#pragma data_seg(".CRT$XLA")

PIMAGE_TLS_CALLBACK __xl_a = 0;

#pragma data_seg(".CRT$XLZ")

PIMAGE_TLS_CALLBACK __xl_z = 0;


#pragma data_seg(".rdata$T")

IMAGE_TLS_DIRECTORY _tls_used =
{
	(ULONG) &_tls_start,	// start of tls data
	(ULONG) &_tls_end,	// end of tls data
	&_tls_index,		// address of tls_index
	&__xl_a, 		// pointer to call back array
	(ULONG) 0,		// size of tls zero fill
	(ULONG) 0		// characteristics
};


#endif	/* _MSC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\common\cruntime\i386\llshr.asm ===
title	llshr - long shift right
;***
;llshr.asm - long shift right
;
;	Copyright (c) 1985-1994, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	define signed long shift right routine 
;	    __allshr
;
;Revision History:
;	11-??-83  HS	initial version
;	11-30-83  DFW	added medium model support
;	03-12-84  DFW	broke apart; added long model support
;	06-01-84  RN	modified to use cmacros
;	11-28-89  GJF	Fixed copyright
;	11-19-93  SMK	Modified to work on 64 bit integers
;	01-17-94  GJF	Minor changes to build with NT's masm386.
;	07-08-94  GJF	Faster, fatter version for NT.
;	07-13-94  GJF	Further improvements from JonM.
;
;*******************************************************************************


.xlist
include cruntime.inc
include mm.inc
.list

;***
;llshr - long shift right
;
;Purpose:
;	Does a signed Long Shift Right 
;	Shifts a long right any number of bits.
;
;Entry:
;	EDX:EAX - long value to be shifted
;	CL    - number of bits to shift by
;
;Exit:
;	EDX:EAX - shifted value
;
;Uses:
;	CL is destroyed.
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

_allshr	PROC NEAR

;
; Handle shifts of 64 bits or more (if shifting 64 bits or more, the result
; depends only on the high order bit of edx).
;
	cmp	cl,64
	jae	short RETSIGN

;
; Handle shifts of between 0 and 31 bits
;
	cmp	cl, 32
	jae	short MORE32
	shrd	eax,edx,cl
	sar	edx,cl
	ret

;
; Handle shifts of between 32 and 63 bits
;
MORE32:
	mov	eax,edx
	sar	edx,31
	and	cl,31
	sar	eax,cl
	ret

;
; Return double precision 0 or -1, depending on the sign of edx
;
RETSIGN:
	sar	edx,31
	mov	eax,edx
	ret

_allshr	ENDP

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\addupgrd.h ===
#if !defined(AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
#define AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddUpgrd.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade dialog

class CAddUpgrade : public CDialog
{
// Construction
public:
        CAddUpgrade(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CAddUpgrade)
	enum { IDD = IDD_FIND_UPGRADE };
        int             m_iUpgradeType;
	int		m_iSource;
	//}}AFX_DATA
        std::map<long, BOOL> * m_pUpgradeList;
        std::map<CString, long> * m_pNameIndex;
        BOOL m_fUninstall;
        long m_cookie;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CAddUpgrade)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CAddUpgrade)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDUPGRD_H__7D8EB948_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\addupgrd.cpp ===
// AddUpgrd.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade dialog


CAddUpgrade::CAddUpgrade(CWnd* pParent /*=NULL*/)
        : CDialog(CAddUpgrade::IDD, pParent)
{
        //{{AFX_DATA_INIT(CAddUpgrade)
        m_iUpgradeType = 1; // default to rip-and-replace
        m_iSource = 0;  // default to current container
        //}}AFX_DATA_INIT
}


void CAddUpgrade::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAddUpgrade)
        DDX_Radio(pDX, IDC_RADIO4, m_iUpgradeType);
        DDX_Radio(pDX, IDC_RADIO1, m_iSource);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddUpgrade, CDialog)
        //{{AFX_MSG_MAP(CAddUpgrade)
	ON_LBN_DBLCLK(IDC_LIST1, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddUpgrade message handlers

BOOL CAddUpgrade::OnInitDialog()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    // add all elements that aren't already in the upgrade list
    std::map<CString, long>::iterator i;
    for (i = m_pNameIndex->begin(); i != m_pNameIndex->end(); i++)
    {
        if (m_pUpgradeList->end() == m_pUpgradeList->find(i->second))
        {
            pList->AddString(i->first);
        }
    }
    pList->SetCurSel(0);

    CDialog::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddUpgrade::OnOK()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        CString sz;
        pList->GetText(iSel, sz);
        m_cookie = (*m_pNameIndex)[sz];
        m_fUninstall = (m_iUpgradeType == 1);
        // only allow the dialog to close with IDOK if a selection has been made
        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\category.cpp ===
// Category.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCategory property page

IMPLEMENT_DYNCREATE(CCategory, CPropertyPage)

CCategory::CCategory() : CPropertyPage(CCategory::IDD)
{
        //{{AFX_DATA_INIT(CCategory)
        //}}AFX_DATA_INIT
}

CCategory::~CCategory()
{
    *m_ppThis = NULL;
}

void CCategory::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCategory)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCategory, CPropertyPage)
        //{{AFX_MSG_MAP(CCategory)
        ON_BN_CLICKED(IDC_BUTTON1, OnAssign)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCategory message handlers

void CCategory::OnAssign()
{
        // TODO: Add your control notification handler code here

}

void CCategory::OnRemove()
{
        // TODO: Add your control notification handler code here

}

BOOL CCategory::OnApply()
{
        // TODO: Add your specialized code here and/or call the base class

        return CPropertyPage::OnApply();
}

BOOL CCategory::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        // unmarshal the IClassAdmin interface
        HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CCategory::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\category.h ===
#if !defined(AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Category.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCategory dialog

class CCategory : public CPropertyPage
{
        DECLARE_DYNCREATE(CCategory)

// Construction
public:
        CCategory();
        ~CCategory();

        CCategory ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CCategory)
        enum { IDD = IDD_CATEGORY };
        //}}AFX_DATA
        APP_DATA *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        IStream *       m_pIStream;
        long            m_hConsoleHandle;
        DWORD           m_cookie;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCategory)
	public:
        virtual BOOL OnApply();
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CCategory)
        afx_msg void OnAssign();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CATEGORY_H__DE2C8018_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\appmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Mar 12 06:53:36 1997
 */
/* Compiler settings for appmgr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __appmgr_h__
#define __appmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __APPMGRLib_LIBRARY_DEFINED__
#define __APPMGRLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: APPMGRLib
 * at Wed Mar 12 06:53:36 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_APPMGRLib;
#endif /* __APPMGRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\catlist.cpp ===
// CatList.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCatList property page

IMPLEMENT_DYNCREATE(CCatList, CPropertyPage)

CCatList::CCatList() : CPropertyPage(CCatList::IDD)
{
        //{{AFX_DATA_INIT(CCatList)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CCatList::~CCatList()
{
    *m_ppThis = NULL;
}
void CCatList::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCatList)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCatList, CPropertyPage)
        //{{AFX_MSG_MAP(CCatList)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCatList message handlers

void CCatList::OnAdd()
{
        // TODO: Add your control notification handler code here

}

void CCatList::OnRemove()
{
        // TODO: Add your control notification handler code here

}

LRESULT CCatList::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\catlist.h ===
#if !defined(AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CatList.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCatList dialog

class CCatList : public CPropertyPage
{
        DECLARE_DYNCREATE(CCatList)

// Construction
public:
        CCatList();
        ~CCatList();

        CCatList ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CCatList)
        enum { IDD = IDD_CATEGORIES };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CCatList)
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CCatList)
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CATLIST_H__5A23FB9D_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\data.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       data.cpp
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:    CAppData
//
//  Functions:
//
//  History:    05-27-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

APP_DATA::APP_DATA()
{
    pProduct = NULL;
    pDeploy = NULL;
    pLocPkg = NULL;
    pCategory = NULL;
    pXforms = NULL;
    pPkgDetails = NULL;
}

APP_DATA::~APP_DATA()
{
    if (pProduct)
    {
        // NOTE: we only need to send this message to one page because this
        //       action will close the entire property sheet.
        pProduct->SendMessage(WM_USER_CLOSE, 0, 0);
    }
}

void APP_DATA::NotifyChange(void)
{
    if (pProduct)
    {
        pProduct->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (pDeploy)
    {
        pDeploy->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (pLocPkg)
    {
        pLocPkg->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (pCategory)
    {
        pCategory->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (pXforms)
    {
        pXforms->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    if (pPkgDetails)
    {
        pPkgDetails->SendMessage(WM_USER_REFRESH, 0, 0);
    }
}

void APP_DATA::InitializeExtraInfo(void)
{
    MSIHANDLE hProduct;
    UINT uiReturn;
    return; // BUGBUG - there is apparently some really wierd MSI error that
            // pops up here in certain circumstances.  I don't pretend to
            // really understand it but I'll disable it for now.
    uiReturn = MsiOpenPackage(pDetails->pInstallInfo->pszScriptPath,
                              &hProduct);
    if (uiReturn)
    {
        return;
    }
    WCHAR buffer[256];
    DWORD cch = 256;
    MsiGetProductProperty(hProduct,
                          INSTALLPROPERTY_PUBLISHER,
                          buffer,
                          &cch);
    szPublisher = buffer;
    MsiCloseHandle(hProduct);
}

void APP_DATA::GetSzDeployment(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    int id;
    if (pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
        id = IDS_ASSIGNED;
    else
    if (!(pDetails->pInstallInfo->dwActFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall)))
        id = IDS_DISABLED;
    else
        id = IDS_PUBLISHED;
    sz.LoadString(id);
}

void APP_DATA::GetSzAutoInstall(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    sz.LoadString((pDetails->pInstallInfo->dwActFlags & ACTFLG_OnDemandInstall) ? IDS_YES : IDS_NO);
}

void APP_DATA::GetSzLocale(CString &sz)
{
    TCHAR szBuffer[256];
    sz = "";
    UINT i = 0;
    while (i < pDetails->pPlatformInfo->cLocales)
    {
        if (i > 0)
        {
            sz += ", ";
        }
        GetLocaleInfo(pDetails->pPlatformInfo->prgLocale[i], LOCALE_SLANGUAGE, szBuffer, 256);
        sz += szBuffer;
        GetLocaleInfo(pDetails->pPlatformInfo->prgLocale[i], LOCALE_SCOUNTRY, szBuffer, 256);
        sz += _T(" - ");
        sz += szBuffer;
        i++;
    }
}

void APP_DATA::GetSzPlatform(CString &sz)
{
    TCHAR szBuffer[256];
    sz = "";
    UINT i = 0;
    while (i < pDetails->pPlatformInfo->cPlatforms)
    {
        if (i > 0)
        {
            sz += ", ";
        }
#if 0       // I'm only going to display the processor to simplify the display
        ::LoadString(ghInstance, IDS_OS + pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId + 1, szBuffer, 256);
        sz += szBuffer;
        wsprintf(szBuffer, _T(" %u.%u/"), pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi, pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo);
        sz += szBuffer;
#endif
        ::LoadString(ghInstance, IDS_HW + pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch, szBuffer, 256);
        sz += szBuffer;
        i++;
    }
}

void APP_DATA::GetSzRelation(CString &sz, CComponentDataImpl * pCDI)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    UINT n = pDetails->pInstallInfo->cUpgrades;
    long cookie = 0;
    BOOL fFound = FALSE;
    while (n--)
    {
        // BUGBUG - eventually we'll want to try and look this up on other
        // OUs as well.
        std::map<CString,long>::iterator i = pCDI->m_ScriptIndex.find(pDetails->pInstallInfo->prgUpgradeScript[n]);
        if (pCDI->m_ScriptIndex.end() != i)
        {
            if (fFound)
            {
                // found more than one app in this OU that I'm upgrading
                sz.LoadString(IDS_MULTIPLE);
                return;
            }
            cookie = i->second;
            fFound = TRUE;
        }
    }
    if (fFound)
    {
        // found exactly one app in this OU that I'm upgrading
        sz = pCDI->m_AppData[cookie].pDetails->pszPackageName;
    }
    else
    {
        // didn't find any apps in this OU that I'm upgrading
        sz.LoadString(IDS_NONE);
    }
}

void APP_DATA::GetSzStage(CString &sz, CComponentDataImpl * pCDI)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    UINT n = pDetails->pInstallInfo->cUpgrades;
    if (n)
    {
        // Make sure at least one of the upgrade scripts is actually
        // deployed in this CS.  Otherwise, we have to say the app is
        // deployed regardless of its state because we don't know if the
        // thing it upgrades has been removed or just exists on another OU.
        // BUGBUG - probably want to search other OUs here as well.
        while (n--)
        {
            std::map<CString,long>::iterator i = pCDI->m_ScriptIndex.find(pDetails->pInstallInfo->prgUpgradeScript[n]);
            if (pCDI->m_ScriptIndex.end() != i)
            {
                // found a match
                ULONG flags = pDetails->pInstallInfo->dwActFlags;
                flags &= ACTFLG_Assigned + ACTFLG_Published + ACTFLG_OnDemandInstall;
                if (flags == ACTFLG_Published)
                {
                    // this is only true if the upgrading app is Published and !OnDemandInstall
                    sz.LoadString(IDS_PILOT);
                }
                else
                {
                    sz.LoadString(IDS_ROLLOUT);
                }
                return;
            }
        }

    }
    sz.LoadString(IDS_DEPLOYED);
}

void APP_DATA::GetSzVersion(CString &sz)
{
    TCHAR szBuffer[256];
    wsprintf(szBuffer, _T("%u.%u"), pDetails->pInstallInfo->dwVersionHi, pDetails->pInstallInfo->dwVersionLo);
    sz = szBuffer;
}

void APP_DATA::GetSzSource(CString &sz)
{
    if (1 <= pDetails->cSources)
    {
        sz = pDetails->pszSourceList[0];
    }
    else
        sz = "";
}

void APP_DATA::GetSzMods(CString &sz)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if (2 < pDetails->cSources)
    {
        sz.LoadString(IDS_MULTIPLE);
    }
    else
    {
        if (2 == pDetails->cSources)
        {
            sz = pDetails->pszSourceList[1];
        }
        else
            sz = "";
    }
}

int APP_DATA::GetImageIndex(CComponentDataImpl * pCDI)
{
    UINT n = pDetails->pInstallInfo->cUpgrades;
    BOOL fFound = FALSE;
    if (0 < sUpgrades.size())
    {
        fFound = TRUE;
    }
    while (n-- && ! fFound)
    {
        // BUGBUG - eventually we'll want to try and look this up on other
        // OUs as well.
        std::map<CString,long>::iterator i = pCDI->m_ScriptIndex.find(pDetails->pInstallInfo->prgUpgradeScript[n]);
        if (pCDI->m_ScriptIndex.end() != i)
        {
            fFound = TRUE;
        }
    }
    if (fFound)
    {
        // I am involed in an upgrade relationship
        return IMG_UPGRADE;
    }
    if (pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned)
        return IMG_ASSIGNED;
    else
    if (!(pDetails->pInstallInfo->dwActFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall)))
        return IMG_DISABLED;
    else
        return IMG_PUBLISHED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "precomp.hxx"

#include "process.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LRESULT SetPropPageToDeleteOnClose(void * vpsp);

HRESULT UpdateClassStore(
    IClassAdmin * pIClassAdmin,
    char *  szFilePath,
    char *  szAuxPath,
    char *  szPackageName,
    DWORD   cchPackageName,
    DWORD   dwFlags,
    HWND    hwnd);

long CSnapin::lDataObjectRefCount = 0;

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"APPMGR_INTERNAL";

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// Utility function to delete an registry key and all of it's children
LONG RegDeleteTree(HKEY hKey, LPCTSTR lpSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, lpSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, lpSubKey);
}


INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    INTERNAL* internal = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    if (!lpDataObject)
        return NULL;


    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        internal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);

                if (internal == NULL)
                        break;

        } while (FALSE);

    return internal;
}

/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CSnapin::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { CDataObject::m_cfNodeType, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(GUID));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        GUID* nodeType = reinterpret_cast<GUID*>(stgmedium.hGlobal);

                if (nodeType == NULL)
                        break;

        // Is this my main node (static folder node type)
        if (*nodeType == cNodeType)
            bResult = TRUE;

        } while (FALSE);


    // Free resources
        if (stgmedium.hGlobal != NULL)
                GlobalFree(stgmedium.hGlobal);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation

STDMETHODIMP CSnapin::GetResultViewType(long cookie,  BSTR* ppViewType, LONG * pViewOptions)
{
    // Use default view
    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    hr = m_pConsole->QueryInterface(IID_IPropertySheetProvider,
                        (void **)&m_pIPropertySheetProvider);

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr = S_OK;
    long cookie;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            cookie = 0;
        }
        else
        {
            cookie = pInternal->m_cookie;
        }


        switch(event)
        {
        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_CLICK:
            hr = OnResultItemClkOrDblClk(cookie, FALSE);
            break;

        case MMCN_DBLCLICK:
            if (pInternal->m_type == CCT_RESULT)
                hr = OnResultItemClkOrDblClk(cookie, TRUE);
            else
                hr = S_FALSE;
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow(cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_SELECT:
            hr = OnSelect(pInternal->m_type, cookie, arg, param);
            break;

        // Note - Future expansion of notify types possible
        default:
            ASSERT(FALSE);  // Handle new messages
            hr = E_UNEXPECTED;
            break;
        }

        FREE_INTERNAL(pInternal);
    }

    return hr;
}

STDMETHODIMP CSnapin::Destroy(long cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);
        SAFE_RELEASE(m_pConsoleVerb);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        if (m_pComponentData)
        {
            ((IComponentData*)m_pComponentData)->Release(); // QI'ed in IComponentDataImpl::CreateComponent
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapin::QueryDataObject(long cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    CSnapin::lDataObjectRefCount = 0;
    m_lViewMode = LVS_REPORT;
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);

    Construct();

    ASSERT(CSnapin::lDataObjectRefCount == 0);
}

void CSnapin::Construct()
{
#if DBG
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;
}

CString szExtension;
CString szFilter;

void CSnapin::LoadResources()
{
    // Load strings from resources

    m_column1.LoadString(IDS_NAME);
    m_column2.LoadString(IDS_VERSION);
    m_column3.LoadString(IDS_STAGE);
    m_column4.LoadString(IDS_RELATION);
    m_column5.LoadString(IDS_STATE);
    m_column6.LoadString(IDS_AUTOINST);
    m_column7.LoadString(IDS_LOC);
    m_column8.LoadString(IDS_MACH);
    m_column9.LoadString(IDS_SOURCE);
    m_column10.LoadString(IDS_MODS);
    m_column11.LoadString(IDS_PUB);
    szExtension.LoadString(IDS_DEF_EXTENSION);
    szFilter.LoadString(IDS_EXTENSION_FILTER);
    m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
}

HRESULT CSnapin::InitializeHeaders(long cookie)
{
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);

    // Put the correct headers depending on the cookie
    // Note - cookie ignored for this sample
    m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, 150);    // name
    m_pHeader->InsertColumn(1, m_column2, LVCFMT_LEFT, 50);     // version
    m_pHeader->InsertColumn(2, m_column3, LVCFMT_LEFT, 85);     // stage
    m_pHeader->InsertColumn(3, m_column4, LVCFMT_LEFT, 125);    // relation
    m_pHeader->InsertColumn(4, m_column5, LVCFMT_LEFT, 100);    // state
    m_pHeader->InsertColumn(5, m_column6, LVCFMT_LEFT, 75);     // auto-inst
    m_pHeader->InsertColumn(6, m_column7, LVCFMT_LEFT, 75);     // loc
    m_pHeader->InsertColumn(7, m_column8, LVCFMT_LEFT, 75);     // mach
    m_pHeader->InsertColumn(8, m_column9, LVCFMT_LEFT, 150);    // source
    m_pHeader->InsertColumn(9, m_column10, LVCFMT_LEFT, 150);   // mods
    m_pHeader->InsertColumn(10, m_column11, LVCFMT_LEFT, 150);  // pub

    return hr;
}

HRESULT CSnapin::InitializeBitmaps(long cookie)
{
    ASSERT(m_pImageResult != NULL);

    CBitmap bmp16x16;
    CBitmap bmp32x32;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    m_pImageResult->ImageListSetStrip(reinterpret_cast<long*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<long*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    return m_pComponentData->
        AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}

STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    return m_pComponentData->
        Command(nCommandID, pDataObject);
}

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
: m_bIsDirty(TRUE)
{
    HKEY hKey;
    DWORD dwDisp;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    m_pToolDefs = NULL;
    m_pCatList = NULL;
    m_pFileExt = NULL;

    m_fMachine = FALSE;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_pIClassAdmin = NULL;
    m_fLoaded = FALSE;
    m_fExtension = FALSE;
    m_pIGPEInformation = NULL;
    m_lLastAllocated = 0;
    m_ToolDefaults.NPBehavior = NP_WIZARD;
    m_ToolDefaults.fAutoInstall = FALSE;
    m_ToolDefaults.UILevel = INSTALLUILEVEL_DEFAULT;
    m_ToolDefaults.szStartPath = L"";   // UNDONE - need to come up with a
                                        // good default setting for this
    m_ToolDefaults.iDebugLevel = 0;
    m_ToolDefaults.fShowPkgDetails = 0;

    //
    // This creates the magic "GPTSupport" key in HKCR so that Darwin
    // generates full link files.
    //

    if (RegCreateKeyEx (HKEY_CLASSES_ROOT, TEXT("GPTSupport"), 0, NULL,
                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey,
                  &dwDisp) == ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
    }
}

CComponentDataImpl::~CComponentDataImpl()
{

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);
    ASSERT(CSnapin::lDataObjectRefCount == 0);
}
#include <msi.h>

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    return S_OK;
}

HRESULT CSnapin::OnAddImages(long cookie, long arg, long param)
{
    if (arg == 0)
    {
        return E_INVALIDARG;
    }

    // add the images for the scope tree
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    LPIMAGELIST lpScopeImage = (LPIMAGELIST)arg;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<long*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<long*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    m_pSnapin = pObject;


    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        SaveToolDefaults();
        hr = OnProperties(param);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
        long cookie = 0;
        if (pInternal != NULL)
        {
            cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
        }
        else
        {
            // only way we could not be able to extract our own format is if we're operating as an extension
            m_fExtension = TRUE;
        }

        if (m_pIGPEInformation == NULL)
        {
            hr = lpDataObject->QueryInterface(IID_IGPEInformation,
                            reinterpret_cast<void**>(&m_pIGPEInformation));
            if (SUCCEEDED(hr))
            {
                WCHAR szBuffer[MAX_PATH];
                do
                {
                    hr = m_pIGPEInformation->GetDSPath(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, MAX_PATH);
                    if (FAILED(hr))
                    {
                        break;
                    }
                    m_szLDAP_Path = szBuffer;

                    hr = GetClassStore();

                    hr = m_pIGPEInformation->GetFileSysPath(m_fMachine ? GPO_SECTION_MACHINE : GPO_SECTION_USER, szBuffer, MAX_PATH);
                    if (FAILED(hr)) break;
                    m_szGPT_Path = szBuffer;

                    // find the last element in the path
                    int iBreak = m_szGPT_Path.ReverseFind(L'{');
                    m_szGPT_Path += L"\\Applications";
                    // m_szGPTRoot gets everything before the '\\' found above...
                    m_szGPTRoot = m_szGPT_Path.Left(iBreak-1);
                    // m_szScriptRoot gets everything after the '\\' found above...
                    m_szScriptRoot = m_szGPT_Path.Mid(iBreak);
                    if (CreateNestedDirectory ((LPOLESTR)((LPCOLESTR)m_szGPT_Path), NULL))
                    {
                        m_fLoaded = TRUE;
#if UGLY_SUBDIRECTORY_HACK
                        CString sz = m_szGPT_Path;
                        sz += L"\\assigned\\x86";
                        CreateNestedDirectory((LPOLESTR)((LPCOLESTR)sz), NULL);
                        sz = m_szGPT_Path;
                        sz += L"\\assigned\\alpha";
                        CreateNestedDirectory((LPOLESTR)((LPCOLESTR)sz), NULL);
#endif
                    }
                    LoadToolDefaults();
                } while (0);
            }
        }


        switch(event)
        {
        case MMCN_DELETE:
            hr = OnDelete(cookie, arg, param);
            break;

        case MMCN_RENAME:
            hr = OnRename(cookie, arg, param);
            break;

        case MMCN_EXPAND:
            {
                hr = OnExpand(cookie, arg, param);
            }
            break;

        case MMCN_SELECT:
            hr = OnSelect(cookie, arg, param);
            break;

        case MMCN_CONTEXTMENU:
            hr = OnContextMenu(cookie, arg, param);
            break;

        default:
            break;
        }

    }
    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    // Delete enumerated scope items
    DeleteList();

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pIClassAdmin);
    SAFE_RELEASE(m_pIGPEInformation);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    pObject->m_fMachine = m_fMachine;
    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStreamInit interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    if (m_fMachine)
        *pClassID = CLSID_MachineSnapin;
    else
        *pClassID = CLSID_Snapin;

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    ASSERT(pStm);

    // Read the string
    TCHAR psz[MAX_PATH];        // BUGBUG - really should be WCHAR to avoid problems in case
                                //          it's ever compiled for MBCS
    ULONG nBytesRead;
    ULONG cb;
    HRESULT hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
    if (SUCCEEDED(hr))
    {
        hr = pStm->Read(psz, cb, &nBytesRead);
        if (SUCCEEDED(hr))
        {
            if (cb > MAX_PATH * sizeof(TCHAR))
            {
                return E_FAIL;
            }
            m_szLDAP_Path = psz;

            hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
            if (SUCCEEDED(hr))
            {
                if (cb > MAX_PATH * sizeof(TCHAR))
                {
                    return E_FAIL;
                }
                hr = pStm->Read(psz, cb, &nBytesRead);

                if (SUCCEEDED(hr))
                {
                    m_szGPT_Path = psz;
                    // find the last element in the path
                    int iBreak = m_szGPT_Path.ReverseFind(L'{');
                    // m_szGPTRoot gets everything before the '\\' found above...
                    m_szGPTRoot = m_szGPT_Path.Left(iBreak-1);
                    // m_szScriptRoot gets everything after the '\\' found above...
                    m_szScriptRoot = m_szGPT_Path.Mid(iBreak);
                    m_fLoaded = TRUE;
                    ClearDirty();
                    LoadToolDefaults();
                }
            }
        }
    }
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    ULONG cb = (m_szLDAP_Path.GetLength() + 1) * sizeof(TCHAR);
    HRESULT hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szLDAP_Path, cb, &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    cb = (m_szGPT_Path.GetLength() + 1) * sizeof(TCHAR);
    hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szGPT_Path, cb, &nBytesWritten);

    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    ULONG cb = (m_szLDAP_Path.GetLength() + m_szGPT_Path.GetLength() + 2) * sizeof(TCHAR) + 2 * sizeof(ULONG);
    // Set the size of the string to be saved
    ULISet32(*pcbSize, cb);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::InitNew(void)
{
    return S_OK;
}

void CComponentDataImpl::LoadToolDefaults()
{
    CString szFileName = m_szGPT_Path;
    szFileName += L"\\";
    szFileName += CFGFILE;
    FILE * f = _wfopen(szFileName, L"rt");
    if (f)
    {
        WCHAR sz[256];
        CString szData;
        CString szKey;
        while (fgetws(sz, 256, f))
        {
            szData = sz;
            szKey = szData.SpanExcluding(L"=");
            szData = szData.Mid(szKey.GetLength()+1);
            szData.TrimRight();
            szData.TrimLeft();
            szKey.TrimRight();
            if (0 == szKey.CompareNoCase(KEY_NPBehavior))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.NPBehavior);
            }
            else if (0 == szKey.CompareNoCase(KEY_fAutoInstall))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fAutoInstall);
            }
            else if (0 == szKey.CompareNoCase(KEY_UILevel))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.UILevel);
            }
            else if (0 == szKey.CompareNoCase(KEY_szStartPath))
            {
                m_ToolDefaults.szStartPath = szData;
            }
            else if (0 == szKey.CompareNoCase(KEY_iDebugLevel))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.iDebugLevel);
            }
            else if (0 == szKey.CompareNoCase(KEY_fShowPkgDetails))
            {
                swscanf(szData, L"%i", &m_ToolDefaults.fShowPkgDetails);
            }
        }
        fclose(f);
    }
}

void CComponentDataImpl::SaveToolDefaults()
{
    CString szFileName = m_szGPT_Path;
    szFileName += L"\\";
    szFileName += CFGFILE;
    FILE * f = _wfopen(szFileName, L"wt");
    if (f)
    {
        fwprintf(f, L"%s=%i\n", KEY_NPBehavior, m_ToolDefaults.NPBehavior);
        fwprintf(f, L"%s=%i\n", KEY_fAutoInstall, m_ToolDefaults.fAutoInstall);
        fwprintf(f, L"%s=%i\n", KEY_UILevel, m_ToolDefaults.UILevel);
        fwprintf(f, L"%s=%s\n", KEY_szStartPath, m_ToolDefaults.szStartPath);
        if (m_ToolDefaults.iDebugLevel > 0)
        {
            fwprintf(f, L"%s=%i\n", KEY_iDebugLevel, m_ToolDefaults.iDebugLevel);
        }
        if (m_ToolDefaults.fShowPkgDetails > 0)
        {
            fwprintf(f, L"%s=%i\n", KEY_fShowPkgDetails, m_ToolDefaults.fShowPkgDetails);
        }
        fclose(f);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::GetClassStore
//
//  Synopsis:   gets the IClassAdmin interface and creates a class store if
//              it doesn't already exist.
//
//  Arguments:  (none)
//
//  Returns:
//
//  Modifies:   m_pIClassAdmin
//
//  Derivation:
//
//  History:    2-11-1998   stevebl   Created
//
//  Notes:      Assumes m_szLDAP_Path contains the path to the class store
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::GetClassStore(void)
{
    HRESULT hr;
    IADsPathname * pADsPathname = NULL;
    hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = pADsPathname->Set((LPOLESTR)((LPCOLESTR)m_szLDAP_Path), ADS_SETTYPE_FULL);
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    hr = pADsPathname->AddLeafElement(L"CN=Class Store");
    if (FAILED(hr))
    {
        pADsPathname->Release();
        return hr;
    }

    BSTR bstr;

    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);

    pADsPathname->Release();
    if (FAILED(hr))
    {
        return hr;
    }

    CString szCSPath = bstr;

    SysFreeString(bstr);

    // UNDONE - build class store path
    hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&m_pIClassAdmin);
    if (FAILED(hr))
    {
        hr = CsCreateClassStore((LPOLESTR)((LPCOLESTR)m_szLDAP_Path), L"CN=Class Store");
        if (SUCCEEDED(hr))
        {
            hr = CsGetClassStore((LPOLESTR)((LPCOLESTR)szCSPath), (LPVOID*)&m_pIClassAdmin);
            // If this fails then we've really got problems and we'll just
            // have to return the failure.
        }
    }
    return hr;
}

UINT CComponentDataImpl::CreateNestedDirectory (LPTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        SetLastError(ERROR_INVALID_DATA);
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnAdd(long cookie, long arg, long param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnDelete(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRename(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(long cookie, long arg, long param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(cookie,
            param);
    }

    return S_OK;
}

HRESULT CComponentDataImpl::OnSelect(long cookie, long arg, long param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnContextMenu(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnProperties(long param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);

    return S_OK;
}


void CComponentDataImpl::EnumerateScopePane(long cookie, HSCOPEITEM pParent)
{
    // We only have one folder so this is really easy.
    if (cookie != NULL)
        return ;

    if (m_fExtension)
    {
        // if we're an extension then add a root folder to hang everything off of
        SCOPEDATAITEM * m_pScopeItem = new SCOPEDATAITEM;
        memset(m_pScopeItem, 0, sizeof(SCOPEDATAITEM));
        m_pScopeItem->mask = SDI_STR | SDI_PARAM;
        m_pScopeItem->relativeID = pParent;
        m_pScopeItem->displayname = (unsigned short *)-1;
        m_pScopeItem->lParam = -1; // made up cookie for my main folder
        m_pScope->InsertItem(m_pScopeItem);
    }
}

void CComponentDataImpl::DeleteList()
{
    return;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    if (pScopeDataItem->lParam == -1)
    {
        m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
    }
    else
    {
        ASSERT(pScopeDataItem->mask == TVIF_TEXT);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_AppData[pScopeDataItem->lParam].pDetails->pszPackageName);
    }

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

// Result item property pages:
STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    long handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (m_pIClassAdmin)
    {
        HRESULT hr;

        DWORD cookie = pInternal->m_cookie;
        APP_DATA & data = m_pComponentData->m_AppData[cookie];
        FREE_INTERNAL(pInternal);

        //
        // Create the Product property page
        //
        data.pProduct = new CProduct();
        data.pProduct->m_ppThis = &data.pProduct;
        data.pProduct->m_pData = &data;
        data.pProduct->m_cookie = cookie;
        data.pProduct->m_hConsoleHandle = handle;
        data.pProduct->m_pAppData = &m_pComponentData->m_AppData;
        // marshal the IClassAdmin interface to the page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(data.pProduct->m_pIStream));
        if (SUCCEEDED(hr))
        {
            hr = SetPropPageToDeleteOnClose(&data.pProduct->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hProduct = CreatePropertySheetPage(&data.pProduct->m_psp);
                if (hProduct == NULL)
                    return E_UNEXPECTED;
                lpProvider->AddPage(hProduct);
            }
        }

        //
        // Create the Depeployment property page
        //
        data.pDeploy = new CDeploy();
        data.pDeploy->m_ppThis = &data.pDeploy;
        data.pDeploy->m_pData = &data;
        data.pDeploy->m_cookie = cookie;
        data.pDeploy->m_hConsoleHandle = handle;
#ifdef UGLY_SUBDIRECTORY_HACK
        data.pDeploy->m_szGPTRoot = m_pComponentData->m_szGPTRoot;
#endif
        // marshal the IClassAdmin interface to the page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(data.pDeploy->m_pIStream));
        if (SUCCEEDED(hr))
        {
            hr = SetPropPageToDeleteOnClose(&data.pDeploy->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hDeploy = CreatePropertySheetPage(&data.pDeploy->m_psp);
                if (hDeploy == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hDeploy);
            }
        }

        //
        // Create the locale property page
        //
        data.pLocPkg = new CLocPkg();
        data.pLocPkg->m_ppThis = &data.pLocPkg;
        data.pLocPkg->m_pData = &data;
        data.pLocPkg->m_cookie = cookie;
        data.pLocPkg->m_hConsoleHandle = handle;
        // marshal the IClassAdmin interface to the page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(data.pLocPkg->m_pIStream));
        if (SUCCEEDED(hr))
        {
            hr = SetPropPageToDeleteOnClose(&data.pLocPkg->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hLocPkg = CreatePropertySheetPage(&data.pLocPkg->m_psp);
                if (hLocPkg == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hLocPkg);
            }
        }

        //
        // Create the Category property page
        //
        data.pCategory = new CCategory();
        data.pCategory->m_ppThis = &data.pCategory;
        data.pCategory->m_pData = &data;
        data.pCategory->m_cookie = cookie;
        data.pCategory->m_hConsoleHandle = handle;
        // marshal the IClassAdmin interface to the page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(data.pCategory->m_pIStream));
        if (SUCCEEDED(hr))
        {
            hr = SetPropPageToDeleteOnClose(&data.pCategory->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hCategory = CreatePropertySheetPage(&data.pCategory->m_psp);
                if (hCategory == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hCategory);
            }
        }

        //
        // Create the Xforms property page
        //
        data.pXforms = new CXforms();
        data.pXforms->m_ppThis = &data.pXforms;
        data.pXforms->m_pData = &data;
        data.pXforms->m_cookie = cookie;
        data.pXforms->m_hConsoleHandle = handle;
        // marshal the IClassAdmin interface to the page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(data.pXforms->m_pIStream));
        if (SUCCEEDED(hr))
        {
            hr = SetPropPageToDeleteOnClose(&data.pXforms->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hXforms = CreatePropertySheetPage(&data.pXforms->m_psp);
                if (hXforms == NULL)
                {
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hXforms);
            }
        }

        if (m_pComponentData->m_ToolDefaults.fShowPkgDetails)
        {
            //
            // Create the Package Details page (debug only)
            //
            data.pPkgDetails = new CPackageDetails();
            data.pPkgDetails->m_ppThis = &data.pPkgDetails;
            data.pPkgDetails->m_hConsoleHandle = handle;
            data.pPkgDetails->m_pData = &data;
            hr = SetPropPageToDeleteOnClose(&data.pPkgDetails->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hDetails = CreatePropertySheetPage(&data.pPkgDetails->m_psp);

                if (hDetails == NULL)
                    return E_UNEXPECTED;
                lpProvider->AddPage(hDetails);
            }
        }
    }
    else
        return S_FALSE;

    return S_OK;
}

// Result items property pages:
STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (CCT_RESULT == pInternal->m_type)
    {
        FREE_INTERNAL(pInternal);
        return S_OK;
    }

    FREE_INTERNAL(pInternal);
    return S_FALSE;
}

// Scope item property pages:
STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    long handle,
                    LPDATAOBJECT lpIDataObject)
{
    HRESULT hr;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

    DWORD cookie = pInternal->m_cookie;
    FREE_INTERNAL(pInternal);

    //
    // Create the ToolDefs property page
    //
    m_pToolDefs = new CToolDefs();
    m_pToolDefs->m_ppThis = &m_pToolDefs;
    m_pToolDefs->m_pToolDefaults = & m_ToolDefaults;
    m_pToolDefs->m_cookie = cookie;
    m_pToolDefs->m_hConsoleHandle = handle;
    hr = SetPropPageToDeleteOnClose(&m_pToolDefs->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hToolDefs = CreatePropertySheetPage(&m_pToolDefs->m_psp);
        if (hToolDefs == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hToolDefs);
    }

    //
    // Create the CatList property page
    //
    m_pCatList = new CCatList();
    m_pCatList->m_ppThis = &m_pCatList;
    hr = SetPropPageToDeleteOnClose(&m_pCatList->m_psp);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hCatList = CreatePropertySheetPage(&m_pCatList->m_psp);
        if (hCatList == NULL)
            return E_UNEXPECTED;
        lpProvider->AddPage(hCatList);
    }

    //
    // Create the FileExt property page
    //
    m_pFileExt = new CFileExt();
    m_pFileExt->m_ppThis = &m_pFileExt;
    m_pFileExt->m_pCDI = this;
    // marshal the IClassAdmin interface to the page
    hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(m_pFileExt->m_pIStream));
    if (SUCCEEDED(hr))
    {
        hr = SetPropPageToDeleteOnClose(&m_pFileExt->m_psp);
        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hFileExt = CreatePropertySheetPage(&m_pFileExt->m_psp);
            if (hFileExt == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hFileExt);
        }
    }

    return S_OK;
}

// Scope item property pages:
STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (CCT_SCOPE == pInternal->m_type)
    {
        FREE_INTERNAL(pInternal);
        return S_OK;
    }

    FREE_INTERNAL(pInternal);
    return S_FALSE;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

    if (pInternal->m_type == CCT_SCOPE)
        bResult = TRUE;

    FREE_INTERNAL(pInternal);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              LONG * pInsertionAllowed)
{
    HRESULT hr = S_OK;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

    CONTEXTMENUITEM menuitem;
    WCHAR szName[256];
    WCHAR szStatus[256];
    menuitem.strName = szName;
    menuitem.strStatusBarText = szStatus;
    menuitem.fFlags = 0;
    menuitem.fSpecialFlags = 0;

    do {

        if ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_NEW)
        {
            //
            // Add Application menu item
            //
            ::LoadString(ghInstance, IDM_ADD_APP, szName, 256);
            ::LoadString(ghInstance, IDS_ADD_APP_DESC, szStatus, 256);
            menuitem.lCommandID = IDM_ADD_APP;
            menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;

            hr = pContextMenuCallback->AddItem(&menuitem);

            if (FAILED(hr))
                    break;
        }


        //
        // Update & Remove application if this is a result pane item
        //

        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA & data = m_AppData[pInternal->m_cookie];
            DWORD dwFlags = data.pDetails->pInstallInfo->dwActFlags;

            if ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TOP)
            {
                ::LoadString(ghInstance, IDM_AUTOINST, szName, 256);
                ::LoadString(ghInstance, IDS_AUTOINST_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_AUTOINST;
                menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;

                // only enable for published apps
                if ((dwFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall)) && !(dwFlags & ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                if (dwFlags & ACTFLG_OnDemandInstall)
                    menuitem.fFlags += MFS_CHECKED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_ASSIGN, szName, 256);
                ::LoadString(ghInstance, IDS_ASSIGN_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ASSIGN;
                if (dwFlags & ACTFLG_Assigned)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_PUBLISH, szName, 256);
                ::LoadString(ghInstance, IDS_PUBLISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_PUBLISH;
                if ((dwFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall)) && !(dwFlags & ACTFLG_Assigned))
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_DISABLE, szName, 256);
                ::LoadString(ghInstance, IDS_DISABLE_DESC, szStatus, 256);

                if (dwFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall | ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                menuitem.lCommandID = IDM_DISABLE;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
            if ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TASK)
            {
                ::LoadString(ghInstance, IDM_ASSIGN, szName, 256);
                ::LoadString(ghInstance, IDS_ASSIGN_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_ASSIGN_T;
                menuitem.fSpecialFlags = 0;
                if (dwFlags & ACTFLG_Assigned)
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_PUBLISH, szName, 256);
                ::LoadString(ghInstance, IDS_PUBLISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_PUBLISH_T;
                if ((dwFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall)) && !(dwFlags & ACTFLG_Assigned))
                    menuitem.fFlags = MFS_DISABLED;
                else
                    menuitem.fFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_DISABLE, szName, 256);
                ::LoadString(ghInstance, IDS_DISABLE_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_DISABLE_T;
                if (dwFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall | ACTFLG_Assigned))
                    menuitem.fFlags = 0;
                else
                    menuitem.fFlags = MFS_DISABLED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_DEL_APP, szName, 256);
                ::LoadString(ghInstance, IDS_DEL_APP_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_DEL_APP;
                menuitem.fFlags = 0;
                menuitem.fSpecialFlags = 0;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
                //
                // Upgrade support menu items.
                //

                // Migrate - enable only on the new app (the old app might
                // get upgraded by more than one app and it doesn't make
                // sense to migrate them all at once).

                // Finish Upgrade - Enable on both apps.
                // If selected on an app that is both an upgrade and is
                // being upgraded, then the older relationship takes
                // precidence.
                // Example: C upgrades B which upgrades A.  User chooses
                //          "Finish Upgrade" on B.  ADE removes A and sets B
                //          to the "deployed" state.  User chooses "Finish
                //          Upgrade" on B again.  This time ADE removes B
                //          and sets C to the deployed state.

                // Check upgrade relationships for apps I'm upgrading and
                // apps that are upgrading me.
                BOOL fIUpgrade = FALSE;
                UINT n = data.pDetails->pInstallInfo->cUpgrades;
                while (n-- && ! fIUpgrade)
                {
                    // BUGBUG - eventually we'll want to try and look this up on other
                    // OUs as well.
                    std::map<CString,long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
                    if (m_ScriptIndex.end() != i)
                    {
                        fIUpgrade = TRUE;
                    }
                }

                BOOL fIAmBeingUpgraded = 0 < data.sUpgrades.size();

                ::LoadString(ghInstance, IDM_MIGRATE, szName, 256);
                ::LoadString(ghInstance, IDS_MIGRATE_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_MIGRATE;
                menuitem.fFlags = fIUpgrade ? 0 : MFS_DISABLED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                ::LoadString(ghInstance, IDM_FINISH, szName, 256);
                ::LoadString(ghInstance, IDS_FINISH_DESC, szStatus, 256);
                menuitem.lCommandID = IDM_FINISH;
                menuitem.fFlags = (fIUpgrade | fIAmBeingUpgraded) ? 0 : MFS_DISABLED;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;

                menuitem.lCommandID = 0;
                menuitem.fFlags = MFT_SEPARATOR;
                menuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
                hr = pContextMenuCallback->AddItem(&menuitem);
                if (FAILED(hr))
                        break;
            }
        }

        if ((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TASK)
        {
            ::LoadString(ghInstance, IDM_REFRESH, szName, 256);
            ::LoadString(ghInstance, IDS_REFRESH_DESC, szStatus, 256);
            menuitem.lCommandID = IDM_REFRESH;
            menuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            menuitem.fFlags = 0;
            menuitem.fSpecialFlags = 0;
            hr = pContextMenuCallback->AddItem(&menuitem);

            if (FAILED(hr))
                    break;
        }

    } while (FALSE);


    FREE_INTERNAL(pInternal);
    return hr;
}

HRESULT CComponentDataImpl::InitializeClassAdmin()
{
    HRESULT hr = S_OK;
    BOOL fCancel = FALSE;
    do
    {
        if (!m_pIClassAdmin)
        {
            // get the IClassAdmin
            hr = GetClassStore();
            // make sure directories are created:
            if (SUCCEEDED(hr))
            {
                hr = CreateNestedDirectory ((LPOLESTR)((LPCOLESTR)m_szGPT_Path), NULL);
#if UGLY_SUBDIRECTORY_HACK
                CString sz = m_szGPT_Path;
                sz += L"\\assigned\\x86";
                CreateNestedDirectory((LPOLESTR)((LPCOLESTR)sz), NULL);
                sz = m_szGPT_Path;
                sz += L"\\assigned\\alpha";
                CreateNestedDirectory((LPOLESTR)((LPCOLESTR)sz), NULL);
#endif
            }
            if (FAILED(hr))
            {
                m_fLoaded = FALSE;
                TCHAR szBuffer[256];
                if (!m_pIClassAdmin)
                {
                    ::LoadString(ghInstance, IDS_CSADMINFAILED, szBuffer, 256);
                }
                else
                {
                    m_pIClassAdmin->Release();
                    m_pIClassAdmin = NULL;
                    ::LoadString(ghInstance, IDS_GPTFAILED, szBuffer, 256);
                }
                int iReturn = ::MessageBox(NULL, m_szLDAP_Path,
                                   szBuffer,
                                   MB_RETRYCANCEL);
                if (iReturn == IDCANCEL)
                {
                    fCancel = TRUE;
                }
            }
        }
    } while ((!fCancel) && (!m_pIClassAdmin));
    return hr;
}

#include <list>

typedef struct tagCABLIST
{
    FILETIME ft;
    CString szPath;
    bool operator<(const struct tagCABLIST& st)
        {
            return CompareFileTime(&ft, &st.ft) < 0;
        }
} CABLIST;


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);

    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.

    // Handle each of the commands.
    switch (nCommandID)
    {
    case IDM_AUTOINST:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags ^ ACTFLG_OnDemandInstall;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_ASSIGN:
    case IDM_ASSIGN_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~(ACTFLG_Published | ACTFLG_UserInstall);
            dwNewFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_PUBLISH:
    case IDM_PUBLISH_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~ACTFLG_Assigned;
            dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_DISABLE:
    case IDM_DISABLE_T:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA &data = m_AppData[pInternal->m_cookie];
            DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
            dwNewFlags &= ~(ACTFLG_OnDemandInstall | ACTFLG_Assigned | ACTFLG_UserInstall);
            dwNewFlags |= ACTFLG_Published;
            ChangePackageState(data, dwNewFlags, TRUE);
        }
        break;
    case IDM_MIGRATE:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA &data = m_AppData[pInternal->m_cookie];
            // Walk the list of things that I am upgrading, making flag
            // changes as necessary.  Take note if anything I'm
            // upgrading is assigned.
            BOOL fAssigned = FALSE;

            UINT n = data.pDetails->pInstallInfo->cUpgrades;
            while (n--)
            {
                // BUGBUG - eventually we'll want to try and look this up on other
                // OUs as well.
                std::map<CString,long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
                if (m_ScriptIndex.end() != i)
                {
                    // found something
                    APP_DATA & data_old = m_AppData[i->second];
                    DWORD dwActFlags = data_old.pDetails->pInstallInfo->dwActFlags;
                    if (dwActFlags & ACTFLG_Assigned)
                    {
                        // old app is assigned
                        fAssigned = TRUE;
                    }
                    else
                    {
                        // old app is published - turn off auto-install
                        dwActFlags &= ~ACTFLG_OnDemandInstall;
                        ChangePackageState(data_old, dwActFlags, FALSE);
                    }
                }
            }
            if (fAssigned)
            {
                DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
                dwNewFlags &= ~(ACTFLG_Published | ACTFLG_UserInstall);
                dwNewFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
                ChangePackageState(data, dwNewFlags, FALSE);
            }
            else
            {
                DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
                dwNewFlags &= ~ACTFLG_Assigned;
                dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                ChangePackageState(data, dwNewFlags, FALSE);
            }
        }
        break;
    case IDM_FINISH:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA &data = m_AppData[pInternal->m_cookie];
            // If selected on an app that is both an upgrade and is
            // being upgraded, then the older relationship takes
            // precidence.
            // Example: C upgrades B which upgrades A.  User chooses
            //          "Finish Upgrade" on B.  ADE removes A and sets B
            //          to the "deployed" state.  User chooses "Finish
            //          Upgrade" on B again.  This time ADE removes B
            //          and sets C to the deployed state.
            BOOL fIUpgrade = FALSE;
            BOOL fAssigned = FALSE;
            UINT n = data.pDetails->pInstallInfo->cUpgrades;
            while (n--)
            {
                // BUGBUG - eventually we'll want to try and look this up on other
                // OUs as well.
                std::map<CString,long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
                if (m_ScriptIndex.end() != i)
                {
                    fIUpgrade = TRUE;
                    APP_DATA & data_old = m_AppData[i->second];
                    DWORD dwActFlags = data_old.pDetails->pInstallInfo->dwActFlags;
                    if (dwActFlags & ACTFLG_Assigned)
                        fAssigned = TRUE;
                    RemovePackage(i->second);
                }
            }
            if (fIUpgrade)
            {
                // Everything I upgrade has been deleted, now I just set
                // the appropriate flags on me.
                if (fAssigned)
                {
                    DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
                    dwNewFlags &= ~(ACTFLG_Published | ACTFLG_UserInstall);
                    dwNewFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
                    ChangePackageState(data, dwNewFlags, FALSE);
                }
                else
                {
                    DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
                    dwNewFlags &= ~ACTFLG_Assigned;
                    dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                    ChangePackageState(data, dwNewFlags, FALSE);
                }
            }
            else
            {
                // I didn't upgrade anyone so I need to delete myself
                // and set the appropriate flags on anyone that upgrades
                // me.
                BOOL fAssigned = data.pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned;
                std::set<long>::iterator i;
                for (i = data.sUpgrades.begin(); i != data.sUpgrades.end(); i++)
                {
                    APP_DATA & data_new = m_AppData[*i];
                    if (fAssigned)
                    {
                        DWORD dwNewFlags = data_new.pDetails->pInstallInfo->dwActFlags;
                        dwNewFlags &= ~(ACTFLG_Published | ACTFLG_UserInstall);
                        dwNewFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
                        ChangePackageState(data_new, dwNewFlags, FALSE);
                    }
                    else
                    {
                        DWORD dwNewFlags = data_new.pDetails->pInstallInfo->dwActFlags;
                        dwNewFlags &= ~ACTFLG_Assigned;
                        dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                        ChangePackageState(data_new, dwNewFlags, FALSE);
                    }
                }
                RemovePackage(pInternal->m_cookie);
            }
        }
        break;
    case IDM_ADD_APP:
        {
            // start browsing in the default start path
            CString szFileName;

            CFileDialog cfd(TRUE,
                            szExtension,
                            szFileName,
                            OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST,
                            szFilter);

            cfd.m_ofn.lpstrInitialDir = m_ToolDefaults.szStartPath;

            if (IDOK == cfd.DoModal())
            {
                // user selected an application
                UNIVERSAL_NAME_INFO * pUni = new UNIVERSAL_NAME_INFO;
                ULONG cbSize = sizeof(UNIVERSAL_NAME_INFO);
                HRESULT hr = WNetGetUniversalName(cfd.m_ofn.lpstrFile,
                                                  UNIVERSAL_NAME_INFO_LEVEL,
                                                  pUni,
                                                  &cbSize);
                if (ERROR_MORE_DATA == hr)  // we expect this to be true
                {
                    delete [] pUni;
                    pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
                    hr = WNetGetUniversalName(cfd.m_ofn.lpstrFile,
                                              UNIVERSAL_NAME_INFO_LEVEL,
                                              pUni,
                                              &cbSize);
                }

                CString szPackagePath;

                if (S_OK == hr)
                {
                    szPackagePath = pUni->lpUniversalName;
                }
                else
                {
                    // BUGBUG Do we put up an error message here?
                    szPackagePath = cfd.m_ofn.lpstrFile;
                }
                delete[] pUni;

                hr = AddMSIPackage(szPackagePath, cfd.m_ofn.lpstrFileTitle);

                // Notify clients of change
                if (SUCCEEDED(hr) && m_pIGPEInformation)
                {
                    m_pIGPEInformation->PolicyChanged();
                }
            }
        }
        break;

    case IDM_REFRESH:
        if (m_pIClassAdmin)
        {

            std::map <long, APP_DATA>::iterator i;
            for (i=m_AppData.begin(); i != m_AppData.end(); i++)
            {
                m_pSnapin->m_pResult->DeleteItem(i->second.itemID, 0);
                FreePackageDetail(i->second.pDetails);
                m_AppData.erase(i);
            }
            m_ScriptIndex.erase(m_ScriptIndex.begin(), m_ScriptIndex.end());
            m_lLastAllocated = 0;
            m_pSnapin->EnumerateResultPane(0);
        }
        break;
    case IDM_DEL_APP:
        if (pInternal->m_type == CCT_RESULT)
        {
            APP_DATA & data = m_AppData[pInternal->m_cookie];
            CRemove dlg;
            // Check to see if there is an upgrade relationship.
            // NOTE: I am only checking to see if this app is
            //       being upgraded by another, not if this app
            //       upgrades another.  It makes sense that if
            //       the user chose "remove" then he
            //       specifically meant to remove this app.
            if (0 == data.sUpgrades.size())
            {
                // there is no upgrade relationship here
                dlg.m_iState = 1;
            }
            int iReturn = dlg.DoModal();

            if (IDOK == iReturn)
            {
                switch (dlg.m_iState)
                {
                case 0:
                    // force upgrade
                    {
                        BOOL fAssigned = data.pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned;
                        std::set<long>::iterator i;
                        for (i = data.sUpgrades.begin(); i != data.sUpgrades.end(); i++)
                        {
                            APP_DATA & data_new = m_AppData[*i];
                            if (fAssigned)
                            {
                                DWORD dwNewFlags = data_new.pDetails->pInstallInfo->dwActFlags;
                                dwNewFlags &= ~(ACTFLG_Published | ACTFLG_UserInstall);
                                dwNewFlags |= (ACTFLG_Assigned | ACTFLG_OnDemandInstall);
                                ChangePackageState(data_new, dwNewFlags, FALSE);
                            }
                            else
                            {
                                DWORD dwNewFlags = data_new.pDetails->pInstallInfo->dwActFlags;
                                dwNewFlags &= ~ACTFLG_Assigned;
                                dwNewFlags |= ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                                ChangePackageState(data_new, dwNewFlags, FALSE);
                            }
                        }
                        RemovePackage(pInternal->m_cookie);
                    }
                    break;
                case 1:
                    // remove app
                    RemovePackage(pInternal->m_cookie);
                    break;
                case 2:
                    // disable app
                    DWORD dwNewFlags = data.pDetails->pInstallInfo->dwActFlags;
                    dwNewFlags &= ~(ACTFLG_OnDemandInstall | ACTFLG_Assigned | ACTFLG_UserInstall);
                    dwNewFlags |= ACTFLG_Published;
                    ChangePackageState(data, dwNewFlags, TRUE);
                    break;
                }
            }
        }
        break;

    default:
        break;
    }
    return S_OK;
}

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = ((pA->m_type == pB->m_type) && (pA->m_cookie == pB->m_cookie)) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

STDMETHODIMP CSnapin::Compare(long lUserParam, long cookieA, long cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;

    *pnResult = 0;

    APP_DATA & dataA = m_pComponentData->m_AppData[cookieA];
    APP_DATA & dataB = m_pComponentData->m_AppData[cookieB];
    // compare the two based on column and the cookies
    CString szA, szB;

    switch (nCol)
    {
    case 0:
        szA = dataA.pDetails->pszPackageName;
        szB = dataB.pDetails->pszPackageName;
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 1:
        dataA.GetSzVersion(szA);
        dataB.GetSzVersion(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 2:
        dataA.GetSzStage(szA, m_pComponentData);
        dataB.GetSzStage(szB, m_pComponentData);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 3:
        dataA.GetSzRelation(szA, m_pComponentData);
        dataB.GetSzRelation(szB, m_pComponentData);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 4:
        dataA.GetSzDeployment(szA);
        dataB.GetSzDeployment(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 5:
        dataA.GetSzAutoInstall(szA);
        dataB.GetSzAutoInstall(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 6:
        dataA.GetSzLocale(szA);
        dataB.GetSzLocale(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 7:
        dataA.GetSzPlatform(szA);
        dataB.GetSzPlatform(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 8:
        dataA.GetSzSource(szA);
        dataB.GetSzSource(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 9:
        dataA.GetSzMods(szA);
        dataB.GetSzMods(szB);
        *pnResult = szA.CompareNoCase(szB);
        break;
    case 10:
        szA = dataA.szPublisher;
        szB = dataB.szPublisher;
        *pnResult = szA.CompareNoCase(szB);
        break;
    }
    return S_OK;
}


STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    static CString sz;
    ASSERT(pResult != NULL);
    if (pResult)
    {
        if (pResult->lParam == -1)
        {
            switch (pResult->nCol)
            {
            case 0:
                pResult->str = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
                break;
            default:
                pResult->str = (BSTR)_T("");
                break;
            }
        }
        else
        {
            std::map<long, APP_DATA>::iterator i = m_pComponentData->m_AppData.find(pResult->lParam);
            if (i != m_pComponentData->m_AppData.end())
            {
                APP_DATA & data = i->second;
                switch (pResult->nCol)
                {
                case 0:
                    sz = data.pDetails->pszPackageName;
                    break;
                case 1:
                    data.GetSzVersion(sz);
                    break;
                case 2:
                    data.GetSzStage(sz, m_pComponentData);
                    break;
                case 3:
                    data.GetSzRelation(sz, m_pComponentData);
                    break;
                case 4:
                    data.GetSzDeployment(sz);
                    break;
                case 5:
                    data.GetSzAutoInstall(sz);
                    break;
                case 6:
                    data.GetSzLocale(sz);
                    break;
                case 7:
                    data.GetSzPlatform(sz);
                    break;
                case 8:
                    data.GetSzSource(sz);
                    break;
                case 9:
                    data.GetSzMods(sz);
                    break;
                case 10:
                    sz = data.szPublisher;
                    break;
                default:
                    sz = "";
                    break;
                }
                pResult->str = (unsigned short *)((LPCOLESTR)sz);
            }
        }
    }

    return S_OK;
}

// This code is needed to ensure that property pages get cleaned up properly.
// This ensures that when the property sheet is closed all my of property
// pages that are associated with that property sheet will get deleted.
LPFNPSPCALLBACK _MMCHookProp;

UINT CALLBACK HookPropertySheetProp(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookProp(hwnd, uMsg, ppsp);
    switch (uMsg)
    {
    case PSPCB_RELEASE:
        delete (CPropertyPage *) ppsp->lParam;
        return TRUE;
    default:
        break;
    }
    return i;
}

LRESULT SetPropPageToDeleteOnClose(void * vpsp)
{
    HRESULT hr = MMCPropPageCallback(vpsp);
    if (SUCCEEDED(hr))
    {
        if (vpsp == NULL)
            return E_POINTER;

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

        if ((void*)psp->pfnCallback == (void*)HookPropertySheetProp)
            return E_UNEXPECTED;

        _MMCHookProp = psp->pfnCallback;

        psp->pfnCallback = HookPropertySheetProp;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin


#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#include "objidl.h"
#include "data.h"
#include "gpedit.h"
#include "csadmin.hxx"
#include "iads.h"

// Uncomment the following line to turn on machine app deplyoment (user app
// deployment is always on)
#define UGLY_SUBDIRECTORY_HACK 1

// private notifications
#define WM_USER_REFRESH     WM_USER
#define WM_USER_CLOSE       (WM_USER + 1)

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
extern HINSTANCE ghInstance;

extern const CLSID CLSID_Snapin;
extern CLSID CLSID_Temp;
extern const wchar_t * szCLSID_Snapin;
extern const CLSID CLSID_MachineSnapin;
extern const wchar_t * szCLSID_MachineSnapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;

typedef enum NEW_PACKAGE_BEHAVIORS
{
    NP_WIZARD = 0,
    NP_PROPPAGE,
    NP_DISABLED,
    NP_PUBLISHED,
    NP_ASSIGNED
} NEW_PACKAGE_BEHAVIOR;

#define IMG_FOLDER    0
#define IMG_DISABLED  1
#define IMG_PUBLISHED 2
#define IMG_ASSIGNED  3
#define IMG_UPGRADE   4

#define CFGFILE _T("ADE.CFG")

//
// MACROS for allocating and freeing memory via OLE's common allocator: IMalloc.
//
extern IMalloc * g_pIMalloc;

// UNDONE - throw exception on failure

//#define OLEALLOC(x) new char [x]
#define OLEALLOC(x) g_pIMalloc->Alloc(x)

//#define OLESAFE_DELETE(x) if (x) {delete x; x = NULL;}
#define OLESAFE_DELETE(x) if (x) {g_pIMalloc->Free(x); x = NULL;}

#define OLESAFE_COPYSTRING(szO, szI) {if (szI) {int i = wcslen(szI); szO=(OLECHAR *)OLEALLOC(sizeof(OLECHAR) * (i+1)); wcscpy(szO, szI);} else szO=NULL;}

// Keys used in the CFG file.
//
// The CFG file is found in the Applications directory of the SysVol (which
// is the same directory as the script files).
//
// The format of an entry in the CFG file is:
//
//      %key%=%data%
//
// where %data% is either an integer or a string as appropriate.
//
// Order is not important and if a key is not present in the CFG file then
// the default setting will be used.  Some keys (iDebugLevel and
// fShowPkgDetails) will only be saved in the CFG file if their values are
// different from the default settings.
//
#define KEY_NPBehavior      L"New Package Behavior"
#define KEY_fAutoInstall    L"Auto Install"
#define KEY_UILevel         L"UI Level"
#define KEY_szStartPath     L"Start Path"
#define KEY_iDebugLevel     L"Debug Level"
#define KEY_fShowPkgDetails L"Package Details"

typedef struct tagTOOL_DEFAULTS
{
    NEW_PACKAGE_BEHAVIOR    NPBehavior;
    BOOL                    fAutoInstall;
    INSTALLUILEVEL          UILevel;
    CString                 szStartPath;
    int                     iDebugLevel;
    BOOL                    fShowPkgDetails;
} TOOL_DEFAULTS;

/////////////////////////////////////////////////////////////////////////////
// Snapin

typedef std::set<long> EXTLIST;

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CToolDefs;
class CCatList;
class CFileExt;

class CComponentDataImpl:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public CComObjectRoot,
    public IExtendPropertySheet
{

    friend class CSnapin;
    friend class CDataObject;

public:
        CComponentDataImpl();
        ~CComponentDataImpl();

protected:
    LPGPEINFORMATION    m_pIGPEInformation;  // Interface pointer to the GPT

public:
    virtual IUnknown * GetMyUnknown() = 0;

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStreamInit interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)(VOID);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        long handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
// Notify handler declarations
private:
    HRESULT OnAdd(long cookie, long arg, long param);
    HRESULT OnDelete(long cookie, long arg, long param);
    HRESULT OnRename(long cookie, long arg, long param);
    HRESULT OnExpand(long cookie, long arg, long param);
    HRESULT OnSelect(long cookie, long arg, long param);
    HRESULT OnContextMenu(long cookie, long arg, long param);
    HRESULT OnProperties(long param);
    STDMETHOD(ChangePackageState)(APP_DATA & data, DWORD dwNewFlags, BOOL fShowUI);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    void DeleteList();
    void EnumerateScopePane(long cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    HRESULT InitializeClassAdmin();
    HRESULT AddMSIPackage(LPCOLESTR szPackagePath,
                          LPCOLESTR lpFileTitle);
    void GetUniquePackageName(CString &sz);
    HRESULT RemovePackage(long cookie);


private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;
    BOOL                    m_bIsDirty;
    IClassAdmin *           m_pIClassAdmin;
    BOOL m_fExtension;
    BOOL m_fLoaded;

    // global property pages
    CToolDefs *             m_pToolDefs;
    CCatList *              m_pCatList;
    CFileExt *              m_pFileExt;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(long cookie);
    UINT CreateNestedDirectory (LPTSTR lpPath, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    HRESULT GetClassStore(void);
    void LoadToolDefaults();
    void SaveToolDefaults();
    HRESULT PopulateUpgradeLists();
    HRESULT InsertUpgradeEntry(long cookie, APP_DATA &data);
    HRESULT RemoveUpgradeEntry(long cookie, APP_DATA &data);
    HRESULT PopulateExtensions();
    HRESULT InsertExtensionEntry(long cookie, APP_DATA &data);
    HRESULT RemoveExtensionEntry(long cookie, APP_DATA &data);
    HRESULT PrepareExtensions(PACKAGEDETAIL &pd);

    CSnapin * m_pSnapin;

public:
    CString m_szGPT_Path;
    CString m_szGPTRoot;
    CString m_szScriptRoot;
    CString m_szLDAP_Path;
    CString m_szFolderTitle;
    std::map <long, APP_DATA> m_AppData;    // One entry for each
                                            // application in the class
                                            // store.  Maps cookies to
                                            // application packages.
    std::map <CString, EXTLIST> m_Extensions;   // Maps extensions to the
                                                // list of apps that support
                                                // them.
    std::map <CString, long> m_ScriptIndex;     // Maps script names to the
                                                // apps that they belong to.
    TOOL_DEFAULTS m_ToolDefaults;
    BOOL        m_fMachine;

    long m_lLastAllocated;
};

class CMachineComponentDataImpl:
    public CComponentDataImpl,
    public CComCoClass<CMachineComponentDataImpl, &CLSID_MachineSnapin>
{
public:

    DECLARE_REGISTRY(CSnapin, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CMachineComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

    CMachineComponentDataImpl()
    {
        m_fMachine = TRUE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CUserComponentDataImpl:
    public CComponentDataImpl,
    public CComCoClass<CUserComponentDataImpl, &CLSID_Snapin>
{
public:

DECLARE_REGISTRY(CSnapin, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
BEGIN_COM_MAP(CUserComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

    CUserComponentDataImpl()
    {
        m_fMachine = FALSE;
    }
    virtual IUnknown * GetMyUnknown() {return GetUnknown();};
};

class CSnapin :
    public IComponent,
    public IExtendContextMenu,       // Step 3
//    public IExtendControlbar,
    public IExtendPropertySheet,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
        CSnapin();
        ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)       // Step 3
//    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;


// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHOD(Destroy)(long cookie);
    STDMETHOD(GetResultViewType)(long cookie,  BSTR* ppViewType, LONG * pViewOptions);
    STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(long lUserParam, long cookieA, long cookieB, int* pnResult);

// IExtendControlbar
//    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
//    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, long arg, long param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        long handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(long cookie, long arg, long param);
    HRESULT OnShow(long cookie, long arg, long param);
    HRESULT OnActivate(long cookie, long arg, long param);
    HRESULT OnMinimize(long cookie, long arg, long param);
    HRESULT OnSelect(DATA_OBJECT_TYPES type, long cookie, long arg, long param);
    HRESULT OnPropertyChange(long param); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(long cookie, BOOL fDblClick);
    HRESULT OnAddImages(long cookie, long arg, long param);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// End step 3

// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(long cookie);

    void Enumerate(long cookie, HSCOPEITEM pParent);
    HRESULT InitializeBitmaps(long cookie);

public:
    void EnumerateResultPane(long cookie);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    CComponentDataImpl * m_pComponentData;
    IPropertySheetProvider * m_pIPropertySheetProvider;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LONG                m_lViewMode;    // View mode
public:
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list


protected:
//    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
//    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
//    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars

//    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
//    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar
    IClassAdmin * m_pIClassAdmin;

// Header titles for each nodetype(s)
protected:
    CString m_column1;
    CString m_column2;
    CString m_column3;
    CString m_column4;
    CString m_column5;
    CString m_column6;
    CString m_column7;
    CString m_column8;
    CString m_column9;
    CString m_column10;
    CString m_column11;

    CString m_szAddApp;
    CString m_szDelApp;
    CString m_szUpdateApp;
    CString m_szAddFromIe;
    CString m_szShowData;
    CString m_szAddAppDesc;
    CString m_szDelAppDesc;
    CString m_szUpdateAppDesc;
    CString m_szAddFromIeDesc;
    CString m_szShowDataDesc;
    CString m_szFolderTitle;
    CString m_szRefresh;
    CString m_szRefreshDesc;
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetMyUnknown();
    HRESULT hr;

    LPCOMPONENTDATA lpcd;
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&lpcd));
    ASSERT(hr == S_OK);
    m_pComponentData = dynamic_cast<CComponentDataImpl*>(lpcd);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

class CHourglass
{
    private:
    HCURSOR m_hcurSaved;

    public:
    CHourglass()
    {
        m_hcurSaved = ::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    ~CHourglass()
    {
        ::SetCursor(m_hcurSaved);
    };
};

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\data.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       data.h
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:
//
//  Functions:  SetStringData
//
//  History:    5-27-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#ifndef _DATA_H_
#define _DATA_H_

#define _NEW_
#include <map>
#include <set>
#include <algorithm>

typedef enum DEPLOYMENT_TYPES
{
    DT_ASSIGNED = 0,
    DT_PUBLISHED
} DEPLOYMENT_TYPE;

class CComponentDataImpl;
class CProduct;
class CDeploy;
class CLocPkg;
class CCategory;
class CXforms;
class CPackageDetails;

class APP_DATA
{
public:
    APP_DATA();
    ~APP_DATA();

// data
    PACKAGEDETAIL *     pDetails;
    CString             szPublisher;
    long                itemID;

    // property pages:  (NULL unless property pages are being displayed)
    CProduct *          pProduct;
    CDeploy *           pDeploy;
    CLocPkg *           pLocPkg;
    CCategory *         pCategory;
    CXforms *           pXforms;
    CPackageDetails *   pPkgDetails;
    void                NotifyChange(void);

    std::set<long>      sUpgrades;      // set of apps that are upgrades to this one

// methods - NOTE: all methods require a valid pDetails
    void                InitializeExtraInfo(void);
    void                GetSzDeployment(CString &);
    void                GetSzAutoInstall(CString &);
    void                GetSzLocale(CString &);
    void                GetSzPlatform(CString &);
    void                GetSzStage(CString &, CComponentDataImpl *);
    void                GetSzRelation(CString &, CComponentDataImpl *);
    void                GetSzVersion(CString &);
    void                GetSzMods(CString &);
    void                GetSzSource(CString &);
    int                 GetImageIndex(CComponentDataImpl *);
};


#endif // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject : public IDataObject, public CComObjectRoot
{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() {};
    ~CDataObject() {};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfInternal; // Step 3

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(long cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    BOOL    m_fMachine;

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;    // Step 3
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

// Step 3
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

        return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
        return E_NOTIMPL;
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
        return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
                    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_fMachine)
        return Create((LPVOID)&CLSID_MachineSnapin, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_Snapin, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\deploy.cpp ===
// Deploy.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeploy property page

IMPLEMENT_DYNCREATE(CDeploy, CPropertyPage)

CDeploy::CDeploy() : CPropertyPage(CDeploy::IDD)
{
        //{{AFX_DATA_INIT(CDeploy)
        m_fAutoInst = FALSE;
        m_iDeployment = -1;
        m_hConsoleHandle = NULL;
        m_iUI = -1;
        //}}AFX_DATA_INIT
}

CDeploy::~CDeploy()
{
    *m_ppThis = NULL;
    MMCFreeNotifyHandle(m_hConsoleHandle);
}

void CDeploy::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDeploy)
        DDX_Check(pDX, IDC_CHECK2, m_fAutoInst);
        DDX_Radio(pDX, IDC_RADIO6, m_iDeployment);
        DDX_Radio(pDX, IDC_RADIO3, m_iUI);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeploy, CPropertyPage)
        //{{AFX_MSG_MAP(CDeploy)
        ON_BN_CLICKED(IDC_RADIO6, OnDisable)
        ON_BN_CLICKED(IDC_RADIO2, OnPublished)
        ON_BN_CLICKED(IDC_RADIO1, OnAssigned)
        ON_BN_CLICKED(IDC_CHECK2, OnAutoInstall)
        ON_BN_CLICKED(IDC_RADIO3, OnBasic)
        ON_BN_CLICKED(IDC_RADIO4, OnMax)
        ON_BN_CLICKED(IDC_RADIO5, OnDefault)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdvanced)
        ON_WM_DESTROY()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeploy message handlers

BOOL CDeploy::OnApply()
{
    DWORD dwActFlags = m_pData->pDetails->pInstallInfo->dwActFlags;
    dwActFlags &= ~(ACTFLG_Assigned | ACTFLG_Published | ACTFLG_OnDemandInstall | ACTFLG_UserInstall);
    switch (m_iDeployment)
    {
    case 0:
        // Disabled
        dwActFlags |= ACTFLG_Published;
        break;
    case 1:
        // Published
        dwActFlags |= ACTFLG_Published | ACTFLG_UserInstall;
        if (m_fAutoInst)
        {
            dwActFlags |= ACTFLG_OnDemandInstall;
        }
        break;
    case 2:
        // Assigned
        dwActFlags |= (ACTFLG_Assigned  | ACTFLG_OnDemandInstall);
        break;
    default:
        break;
    }
    HRESULT hr = m_pIClassAdmin->ChangePackageProperties(m_pData->pDetails->pszPackageName,
                                                         NULL,
                                                         &dwActFlags,
                                                         NULL,
                                                         NULL,
                                                         NULL);
    if (SUCCEEDED(hr))
    {
        m_pData->pDetails->pInstallInfo->dwActFlags = dwActFlags;
#if UGLY_SUBDIRECTORY_HACK
        {
            CString sz = m_szGPTRoot;
            sz += L"\\";
            sz += m_pData->pDetails->pInstallInfo->pszScriptPath;
            // copy to subdirectories
            CString szRoot;
            CString szFile;
            int i = sz.ReverseFind(L'\\');
            szRoot = sz.Left(i);
            szFile = sz.Mid(i+1);
            CString szTemp;
            if (0 != (m_pData->pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned))
            {
                for (i = m_pData->pDetails->pPlatformInfo->cPlatforms; i--;)
                {
                    if (PROCESSOR_ARCHITECTURE_INTEL == m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
                    {
                        szTemp = szRoot;
                        szTemp += L"\\assigned\\x86\\";
                        szTemp += szFile;
                        CopyFile(sz, szTemp, FALSE);
                    }
                    if (PROCESSOR_ARCHITECTURE_ALPHA == m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
                    {
                        szTemp = szRoot;
                        szTemp += L"\\assigned\\alpha\\";
                        szTemp += szFile;
                        CopyFile(sz, szTemp, FALSE);
                    }
                }
            }
            else
            {
                szTemp = szRoot;
                szTemp += L"\\assigned\\x86\\";
                szTemp += szFile;
                DeleteFile(szTemp);
                szTemp = szRoot;
                szTemp += L"\\assigned\\alpha\\";
                szTemp += szFile;
                DeleteFile(szTemp);
            }
        }
#endif
        MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
    }

    return CPropertyPage::OnApply();
}

BOOL CDeploy::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    // unmarshal the IClassAdmin interface
    HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CDeploy::OnDisable()
{
    SetModified();
    m_fAutoInst = FALSE;
    GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
}

void CDeploy::OnPublished()
{
    SetModified();
    GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
}

void CDeploy::OnAssigned()
{
    SetModified();
    m_fAutoInst = TRUE;
    GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
}

void CDeploy::OnAutoInstall()
{
    SetModified();
}

void CDeploy::OnBasic()
{
    SetModified();
}

void CDeploy::OnMax()
{
    SetModified();
}

void CDeploy::OnDefault()
{
    SetModified();
}

void CDeploy::OnAdvanced()
{
        // TODO: Add your control notification handler code here

}

LRESULT CDeploy::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        RefreshData();
        UpdateData(FALSE);
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CDeploy::RefreshData(void)
{
    DWORD dwActFlags = m_pData->pDetails->pInstallInfo->dwActFlags;
    m_fAutoInst = (0 != (dwActFlags & ACTFLG_OnDemandInstall));

    if (dwActFlags & ACTFLG_Assigned)
    {
        m_iDeployment = 2;
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    }
    else if (dwActFlags & (ACTFLG_OnDemandInstall | ACTFLG_UserInstall))
    {
        m_iDeployment = 1;
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
    }
    else
    {
        m_iDeployment = 0;
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    }
    SetModified(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__CA9BAE5D_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_DLLDATAX_H__CA9BAE5D_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__CA9BAE5D_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dmppkg.h ===
void
DumpOneClass(FILE * stream,  CLASSDETAIL * pClassDetail );

void
DumpOnePackage(
        FILE * stream,
        PACKAGEDETAIL * p,
        CLASSDETAIL * rgClassDetails);

/*************************************
void
DumpOneAppDetail(
        FILE * stream,
        APPDETAIL * pA,
        CLASSDETAIL * rgClassDetails);
**************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dmppkg.cxx ===
#include "precomp.hxx"

char *
StringToULong(
    char * pString,
    unsigned long * pNumber )
    {
    unsigned long Number;
    int           Count;

    // There will be 8 characters int a string that converts into a long.

    for( Count = 0; Count < 8; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }

char *
StringToUShort(
    char          * pString,
    unsigned short * pNumber )
    {
    unsigned short Number;
    int           Count;

    // There will be 4 characters int a string that converts into a short.

    for( Count = 0; Count < 4; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }
char *
StringToUChar(
    char          * pString,
    unsigned char * pNumber )
    {
    unsigned char Number;
    int           Count;

    // There will be 2 characters int a string that converts into a char.

    for( Count = 0; Count < 2; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }

char *
StringToCLSID(
    char    *   pString,
    CLSID   *   pClsid )
    {

    pString = StringToULong( pString, &pClsid->Data1 );
    pString++; // skip -

    pString = StringToUShort( pString, &pClsid->Data2 );
    pString++; // skip -

    pString = StringToUShort( pString, &pClsid->Data3 );
    pString++; // skip -

    pString = StringToUChar( pString, &pClsid->Data4[0] );
    pString = StringToUChar( pString, &pClsid->Data4[1] );
    pString++; // skip -

    pString = StringToUChar( pString, &pClsid->Data4[2] );
    pString = StringToUChar( pString, &pClsid->Data4[3] );
    pString = StringToUChar( pString, &pClsid->Data4[4] );
    pString = StringToUChar( pString, &pClsid->Data4[5] );
    pString = StringToUChar( pString, &pClsid->Data4[6] );
    pString = StringToUChar( pString, &pClsid->Data4[7] );

    return pString;
    }

void
CLSIDToString(
    CLSID * pClsid,
    char  * pString )
    {
    sprintf( pString,
             "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             pClsid->Data1,
             pClsid->Data2,
             pClsid->Data3,
             pClsid->Data4[0],
             pClsid->Data4[1],
             pClsid->Data4[2],
             pClsid->Data4[3],
             pClsid->Data4[4],
             pClsid->Data4[5],
             pClsid->Data4[6],
             pClsid->Data4[7] );
    }

void
DumpOneClass(FILE * stream, CLASSDETAIL * pClassDetail )
        {
#if 0 ///////////////////////////////////////////////////////////////////////
        char  Buffer[ _MAX_PATH ];
        DWORD count;

        CLSIDToString( &pClassDetail->Clsid, &Buffer[0] );
        fprintf(stream, "\n\t\t\tCLSID = %s", &Buffer[0] );


        fwprintf(stream, L"\n\t\t\tDescription = %s", pClassDetail->pszDesc );
        fwprintf(stream, L"\n\t\t\tIconPath = %s", pClassDetail->pszIconPath );

//        CLSIDToString( &pClassDetail->TypelibID, &Buffer[0] );
//        fprintf(stream, "\n\t\t\tTypelibID = %s", &Buffer[0] );

        CLSIDToString( &pClassDetail->TreatAsClsid, &Buffer[0] );
        fprintf(stream, "\n\t\t\tTreatAsClsid = %s", &Buffer[0] );

        CLSIDToString( &pClassDetail->AutoConvertClsid, &Buffer[0] );
        fprintf(stream, "\n\t\t\tAutoConvertClsid = %s", &Buffer[0] );

        if( pClassDetail->cFileExt )
                {
                for(count = 0;
                        count < pClassDetail->cFileExt;
                        count++
                        )
                        {
                        fwprintf(stream, L"\n\t\t\tFileExt = %s", pClassDetail->prgFileExt[ count ] );
                        }
                }
        else
                {
                fprintf(stream, "\n\t\t\tOtherFileExt = None" );
                }

        fwprintf(stream, L"\n\t\t\tMimeType = %s", pClassDetail->pMimeType );
        fwprintf(stream, L"\n\t\t\tDefaultProgid = %s", pClassDetail->pDefaultProgId );

        if( pClassDetail->cOtherProgId )
                {
                for(count = 0;
                        count < pClassDetail->cOtherProgId;
                        count++
                        )
                        {
                        fwprintf(stream, L"\n\t\t\tOtherProgId = %s", pClassDetail->prgOtherProgId[ count ] );
                        }
                }
        else
                {
                fprintf(stream, "\n\t\t\tOtherProgId = None" );
                }
        fprintf(stream, "\n");
#endif // 0 //////////////////////////////////////////////////////////////////
        }

void
DumpOnePackage(
        FILE * stream,
        PACKAGEDETAIL * p,
        CLASSDETAIL * rgClassDetails)
        {
#if 0 /////////////////////////////////////////////////////////////////
        DWORD count;

//        fprintf(stream, "\n++++++++++++++++++++++++++++++++++++++++++++++++++");

        fprintf(stream, "ClassPathType = %d", p->PathType );
        fwprintf(stream, L"\nPackagePath = %s", p->pszPath );
        fwprintf(stream, L"\nIconPath = %s", p->pszIconPath );
        fwprintf(stream, L"\nSetup Command = %s", p->pszSetupCommand );
        fprintf(stream, "\nActFlags = %d", p->dwActFlags );
        fwprintf(stream, L"\nVendor = %s", p->pszVendor );
        fwprintf(stream, L"\nPackageName = %s", p->pszPackageName );
        fwprintf(stream, L"\nProductName = %s", p->pszProductName );
        fwprintf(stream, L"\ndwContext = %d", p->dwContext );
        fwprintf(stream, L"\nPlatform.dwProcessorArch = 0x%x", p->Platform.dwProcessorArch );
        fwprintf(stream, L"\ndwLocale = 0x%x", p->Locale );
        fwprintf(stream, L"\ndwVersionHi = %d", p->dwVersionHi );
        fwprintf(stream, L"\ndwVersionLo = %d", p->dwVersionLo );
        fwprintf(stream, L"\nCountOfApps = %d", p->cApps );

        for( count = 0;
                 count < p->cApps;
                 ++count )
                {
/*************************
DumpOneAppDetail(stream, &p->pAppDetail[count], rgClassDetails);
**************************/
                // advance to the set of class detail structures for the next app
                rgClassDetails += p->pAppDetail[count].cClasses;
                }
//        fprintf(stream, "\n--------------------------------------------------");
#endif // 0 //////////////////////////////////////////////////////////
        }


void
DumpOneAppDetail(
        FILE * stream,
//        APPDETAIL * pA,
        void * pA,
        CLASSDETAIL * rgClassDetails)
        {
#if 0 ///////////////////////////////////////////////////////////////
        char Buffer[ 100 ];
        DWORD count;


        CLSIDToString( &pA->AppID, &Buffer[0] );
        fprintf(stream, "\n\t\tAPPID = %s", &Buffer[0] );

        if( pA->cClasses )
                {
                for( count = 0;
                         count < pA->cClasses;
                         ++count )
                        {
                        DumpOneClass(stream, &rgClassDetails[count]);
                        }
                }
#endif // 0 ////////////////////////////////////////////////////////
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\deploy.h ===
#if !defined(AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Deploy.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeploy dialog

class CDeploy : public CPropertyPage
{
        DECLARE_DYNCREATE(CDeploy)

// Construction
public:
        CDeploy();
        ~CDeploy();

        CDeploy ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CDeploy)
        enum { IDD = IDD_DEPLOYMENT };
        BOOL    m_fAutoInst;
        int             m_iDeployment;
        int             m_iUI;
        //}}AFX_DATA
        APP_DATA *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        IStream *       m_pIStream;
        long            m_hConsoleHandle;
        DWORD           m_cookie;
#ifdef UGLY_SUBDIRECTORY_HACK
        CString         m_szGPTRoot;
#endif


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CDeploy)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CDeploy)
        virtual BOOL OnInitDialog();
        afx_msg void OnDisable();
        afx_msg void OnPublished();
        afx_msg void OnAssigned();
        afx_msg void OnAutoInstall();
        afx_msg void OnBasic();
        afx_msg void OnMax();
        afx_msg void OnDefault();
        afx_msg void OnAdvanced();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        void RefreshData(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEPLOY_H__745C0AF0_8C70_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "appmgr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dplapp.cpp ===
// DplApp.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeployApp dialog


CDeployApp::CDeployApp(CWnd* pParent /*=NULL*/)
        : CDialog(CDeployApp::IDD, pParent)
{
        //{{AFX_DATA_INIT(CDeployApp)
        m_iDeployment = 0;
        //}}AFX_DATA_INIT
}


void CDeployApp::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDeployApp)
        DDX_Radio(pDX, IDC_RADIO1, m_iDeployment);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeployApp, CDialog)
        //{{AFX_MSG_MAP(CDeployApp)
                // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeployApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT CSnapin::OnFolder(long cookie, long arg, long param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CSnapin::OnShow(long cookie, long arg, long param)
{
    HRESULT hr = S_OK;
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        ASSERT(m_pComponentData != NULL);
        hr = m_pComponentData->InitializeClassAdmin();
        if (SUCCEEDED(hr))
        {
            m_pResult->SetViewMode(m_lViewMode);
            InitializeHeaders(cookie);
            InitializeBitmaps(cookie);
            Enumerate(cookie, param);
        }
    }
    else
    {
        m_pResult->GetViewMode(&m_lViewMode);
    }

    return hr;
}

HRESULT CSnapin::OnActivate(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CSnapin::OnResultItemClkOrDblClk(long cookie, BOOL fDblClick)
{
    return S_FALSE;
}

HRESULT CSnapin::OnMinimize(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CSnapin::OnSelect(DATA_OBJECT_TYPES type, long cookie, long arg, long param)
{
    if (m_pConsoleVerb)
    {
        // If it's in the result pane then "properties" should be the
        // default action.  Otherwise "open" should be the default action.
        if (type == CCT_RESULT)
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
        else
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
        // Set the default verb to open


        // Enable the properties verb.
        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    }

    return S_OK;
}

HRESULT CSnapin::OnPropertyChange(long param)   // param is the cookie of the item that changed
{
    HRESULT hr = S_OK;
    RESULTDATAITEM rd;
    memset(&rd, 0, sizeof(rd));
    rd.mask = RDI_IMAGE;
    rd.itemID = m_pComponentData->m_AppData[param].itemID;
    rd.nImage = m_pComponentData->m_AppData[param].GetImageIndex(m_pComponentData);
    m_pResult->SetItem(&rd);
    m_pResult->Sort(0, 0, -1);
    return hr;
}

HRESULT CSnapin::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CSnapin::Enumerate(long cookie, HSCOPEITEM pParent)
{
    EnumerateResultPane(cookie);
}

void CSnapin::EnumerateResultPane(long cookie)
{
    // put up an hourglass (this could take a while)
    CHourglass hourglass;

    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);
    ASSERT(m_pComponentData->m_pIClassAdmin != NULL);
    RESULTDATAITEM resultItem;
    memset(&resultItem, 0, sizeof(RESULTDATAITEM));

    // Right now we only have one folder and it only
    // contains a list of application packages so this is really simple.

    if (m_pComponentData->m_AppData.begin() == m_pComponentData->m_AppData.end())  // test to see if the data has been initialized
    {
        IClassAdmin * pICA = m_pComponentData->m_pIClassAdmin;
        m_pIClassAdmin = pICA;
        CSPLATFORM csPlatform;
        memset(&csPlatform, 0, sizeof(CSPLATFORM));

        IEnumPackage * pIPE = NULL;

        HRESULT hr = pICA->EnumPackages(
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &pIPE);
        if (SUCCEEDED(hr))
        {
            hr = pIPE->Reset();
            while (SUCCEEDED(hr))
            {
                ULONG nceltFetched;
                PACKAGEDETAIL * pd = new PACKAGEDETAIL;
                PACKAGEDISPINFO * pi = new PACKAGEDISPINFO;

                hr = pIPE->Next(1, pi, &nceltFetched);
                if (nceltFetched)
                {
                    pICA->GetPackageDetails(pi->pszPackageName, pd);
                    APP_DATA data;
                    data.pDetails = pd;

                    data.InitializeExtraInfo();

                    m_pComponentData->m_AppData[++m_pComponentData->m_lLastAllocated] = data;
                    m_pComponentData->m_ScriptIndex[data.pDetails->pInstallInfo->pszScriptPath] = m_pComponentData->m_lLastAllocated;
                }
                else
                {
                    delete pd;
                    break;
                }
                if (pi)
                {
                    delete pi;
                }
            }
            SAFE_RELEASE(pIPE);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pComponentData->PopulateExtensions();
            if (SUCCEEDED(hr))
            {
                hr = m_pComponentData->PopulateUpgradeLists();
            }
        }
    }
    std::map<long, APP_DATA>::iterator i = m_pComponentData->m_AppData.begin();
    while (i != m_pComponentData->m_AppData.end())
    {
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.str = MMC_CALLBACK;
        resultItem.nImage = i->second.GetImageIndex(m_pComponentData);
        resultItem.lParam = i->first;
        m_pResult->InsertItem(&resultItem);
        i->second.itemID = resultItem.itemID;
        i++;
    }

    m_pResult->Sort(0, 0, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\dplapp.h ===
#if !defined(AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
#define AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DplApp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeployApp dialog

class CDeployApp : public CDialog
{
// Construction
public:
	CDeployApp(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeployApp)
	enum { IDD = IDD_DEPLOY_APP_DIALOG };
	int		m_iDeployment;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeployApp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeployApp)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DPLAPP_H__0C66A59F_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\fileext.cpp ===
// FileExt.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileExt property page

IMPLEMENT_DYNCREATE(CFileExt, CPropertyPage)

CFileExt::CFileExt() : CPropertyPage(CFileExt::IDD)
{
        //{{AFX_DATA_INIT(CFileExt)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CFileExt::~CFileExt()
{
    *m_ppThis = NULL;
}

void CFileExt::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CFileExt)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileExt, CPropertyPage)
        //{{AFX_MSG_MAP(CFileExt)
        ON_BN_CLICKED(IDC_BUTTON1, OnMoveUp)
        ON_BN_CLICKED(IDC_BUTTON2, OnMoveDown)
        ON_CBN_SELCHANGE(IDC_COMBO1, OnExtensionChanged)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileExt message handlers

void CFileExt::OnMoveUp()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i > 0)
    {
        // change the selection
        CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
        CString sz;
        pCombo->GetLBText(pCombo->GetCurSel(), sz);
        EXT & Ext = m_Extensions[sz];
        Ext.fDirty = TRUE;
        EXTEL t = Ext.v[i-1];
        Ext.v[i-1] = Ext.v[i];
        Ext.v[i] = t;
        pList->GetText(i, sz);
        pList->DeleteString(i);
        pList->InsertString(i-1, sz);
        pList->SetCurSel(i-1);
        SetModified();
    }
}

void CFileExt::OnMoveDown()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int i = pList->GetCurSel();
    if (i < pList->GetCount()-1)
    {
        // change the selection
        CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
        CString sz;
        pCombo->GetLBText(pCombo->GetCurSel(), sz);
        EXT & Ext = m_Extensions[sz];
        Ext.fDirty = TRUE;
        EXTEL t = Ext.v[i+1];
        Ext.v[i+1] = Ext.v[i];
        Ext.v[i] = t;
        pList->GetText(i+1, sz);
        pList->DeleteString(i+1);
        pList->InsertString(i, sz);
        pList->SetCurSel(i+1);
        SetModified();
    }
}

void CFileExt::OnExtensionChanged()
{
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    CString szExt;
    pCombo->GetLBText(pCombo->GetCurSel(), szExt);
    pList->ResetContent();

    // First check to see if we already have set up our own data for this extension.
    if (m_Extensions.end() == m_Extensions.find(szExt))
    {
        // need to set up our list
        EXT Ext;
        Ext.fDirty = FALSE;

        EXTLIST::iterator i;
        EXTLIST & ExtList = m_pCDI->m_Extensions[szExt];
        for (i = ExtList.begin(); i != ExtList.end(); i++)
        {
            EXTEL ExtEl;
            ExtEl.lCookie = *i;

            // look for the entry that matches this file extension
            APP_DATA & data = m_pCDI->m_AppData[*i];
            UINT n2 = data.pDetails->pActInfo->cShellFileExt;
            while (n2--)
            {
                if (0 == szExt.CompareNoCase(data.pDetails->pActInfo->prgShellFileExt[n2]))
                {
                    break;
                }
            }
            ExtEl.lPriority = data.pDetails->pActInfo->prgPriority[n2];
            Ext.v.push_back(ExtEl);
        }
        order_EXTEL func;
        std::sort(Ext.v.begin(), Ext.v.end(), func);
        m_Extensions[szExt] = Ext;
    }
    std::vector<EXTEL>::iterator i;
    EXT & Ext = m_Extensions[szExt];
    for (i = Ext.v.begin(); i != Ext.v.end(); i++)
    {
        CString sz = m_pCDI->m_AppData[i->lCookie].pDetails->pszPackageName;
        pList->AddString(sz);
    }
    pList->SetCurSel(0);
}

BOOL CFileExt::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    // unmarshal the IClassAdmin interface
    HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CFileExt::OnApply()
{
    std::map <CString, EXT>::iterator iExt;
    // walk the list looking for dirty entries
    for (iExt = m_Extensions.begin(); iExt != m_Extensions.end(); iExt++)
    {
        if (iExt->second.fDirty)
        {
            ULONG uPriority = iExt->second.v.size();
            std::vector<EXTEL>::iterator i;
            for (i = iExt->second.v.begin(); i != iExt->second.v.end(); i++)
            {
                APP_DATA & data = m_pCDI->m_AppData[i->lCookie];
                CString sz = data.pDetails->pszPackageName;
                m_pIClassAdmin->SetPriorityByFileExt((LPOLESTR)((LPCOLESTR)sz), (LPOLESTR)((LPCOLESTR)iExt->first), --uPriority);

                // look for the entry that matches this file extension
                UINT n2 = data.pDetails->pActInfo->cShellFileExt;
                while (n2--)
                {
                    if (0 == iExt->first.CompareNoCase(data.pDetails->pActInfo->prgShellFileExt[n2]))
                    {
                        break;
                    }
                }
                data.pDetails->pActInfo->prgPriority[n2] = uPriority;
            }
            iExt->second.fDirty = FALSE;
        }
    }

    return CPropertyPage::OnApply();
}


LRESULT CFileExt::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CFileExt::RefreshData(void)
{
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_COMBO1);
    pCombo->ResetContent();
    std::map <CString, EXTLIST>::iterator iExt;
    for (iExt=m_pCDI->m_Extensions.begin(); iExt != m_pCDI->m_Extensions.end(); iExt++)
    {
        pCombo->AddString(iExt->first);
    }
    pCombo->SetCurSel(0);
    // clear the record of extension changes
    m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
    // and populate the list box
    SetModified(FALSE);

    OnExtensionChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\genpage.h ===
// genpage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage dialog

class CGeneralPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CGeneralPage)

// Construction
public:
        CGeneralPage();
        ~CGeneralPage();

// Dialog Data
        //{{AFX_DATA(CGeneralPage)
        enum { IDD = IDD_GENERAL };
        CComboBox       m_cbDeploy;
        CComboBox       m_cbOS;
        CComboBox       m_cbCPU;
        CString m_szName;
        CString m_szDeploy;
        CString m_szDescription;
        CString m_szLocale;
        CString m_szPath;

        // to remember the strings placed in the combo box for later comparison:
        CString m_szPublished;
        CString m_szAssigned;

        // to remember the strings in the CPU combo box
        CString m_rgszCPU[2];
        CString m_rgszOS[3];

        APP_DATA * m_pData;
        DWORD   m_cookie;
        CString m_szVer;
        IStream * m_pIStream;     // copy of the pointer to the marshalling stream for unmarshalling IClassAdmin
        IClassAdmin * m_pIClassAdmin;
        IStream * m_pIStreamAM;
        IAppManagerActions * m_pIAppManagerActions;
        int    m_fShow;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CGeneralPage)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CGeneralPage)
        virtual BOOL OnInitDialog();
        afx_msg void OnChangeName();
        afx_msg void OnChangeVersion();
        afx_msg void OnChangeOS();
        afx_msg void OnChangeCPU();
        afx_msg void OnChangePath();
        afx_msg void OnChangeDescription();
        afx_msg void OnSelchangeDeploy();
        afx_msg void OnChangeShow();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

public:
    long    m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\genpage.cpp ===
// genpage.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage property page

IMPLEMENT_DYNCREATE(CGeneralPage, CPropertyPage)

CGeneralPage::CGeneralPage() : CPropertyPage(CGeneralPage::IDD)
{
    //{{AFX_DATA_INIT(CGeneralPage)
    m_szName = _T("");
    m_szDeploy = _T("");
    m_szDescription = _T("");
    m_szLocale = _T("");
    m_szPath = _T("");
    m_szVer = _T("");
    m_fShow = TRUE;
    //}}AFX_DATA_INIT

    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
}

CGeneralPage::~CGeneralPage()
{
}

void CGeneralPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGeneralPage)
    DDX_Control(pDX, IDC_DEPLOY, m_cbDeploy);
    DDX_CBString(pDX, IDC_DEPLOY, m_szDeploy);
    DDX_Text(pDX, IDC_NAME, m_szName);
    DDX_Text(pDX, IDC_DESCRIPTION, m_szDescription);
    DDX_Text(pDX, IDC_LOCALE, m_szLocale);
    DDX_Text(pDX, IDC_PATH, m_szPath);
    DDX_Text(pDX, IDC_VERSION, m_szVer);
    DDX_Control(pDX, IDC_CPU, m_cbCPU);
    DDX_Control(pDX, IDC_OS, m_cbOS);
    DDX_Check(pDX, IDC_CHECK1, m_fShow);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGeneralPage, CPropertyPage)
    //{{AFX_MSG_MAP(CGeneralPage)
    ON_WM_DESTROY()
    ON_EN_CHANGE(IDC_NAME, OnChangeName)
    ON_EN_CHANGE(IDC_PATH, OnChangePath)
    ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
    ON_BN_CLICKED(IDC_CHECK1, OnChangeShow)
    ON_CBN_SELCHANGE(IDC_DEPLOY, OnSelchangeDeploy)
    ON_CBN_SELCHANGE(IDC_OS, OnChangeOS)
    ON_CBN_SELCHANGE(IDC_CPU, OnChangeCPU)
    ON_EN_CHANGE(IDC_VERSION, OnChangeVersion)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CGeneralPage::OnApply()
{
#if 0
    if (m_pIAppManagerActions == NULL || m_pIClassAdmin == NULL)
    {
        return FALSE;
    }
    // put up an hourglass (this could take a while)
    CHourglass hourglass;

    CString szNewScriptPath;
    CString szOldScriptPath;

    HRESULT hr;
    if (m_bUpdate == TRUE)
    {
        PACKAGEDETAIL NewDetails;
        hr = m_pIClassAdmin->GetPackageDetails(m_pData->szName,
            &NewDetails.InstallInfo,
            &NewDetails.PlatformInfo);
        memcpy(&NewDetails, m_pData->pDetails, sizeof(PACKAGEDETAIL));

        // UNDONE - validate the data

        NewDetails.pszPackageName = (LPOLESTR) ((LPCTSTR)m_szName);

        swscanf((LPOLESTR)((LPCTSTR)m_szVer), _T("%u.%u"),&(NewDetails.Platform.dwVersionHi),&(NewDetails.Platform.dwVersionLo));
        NewDetails.Platform.dwPlatformId = m_cbOS.GetCurSel();
        NewDetails.Platform.dwProcessorArch = m_cbCPU.GetCurSel() == 1 ? PROCESSOR_ARCHITECTURE_ALPHA : PROCESSOR_ARCHITECTURE_INTEL;

        NewDetails.dwActFlags = (m_pData->pDetails->dwActFlags & (! (ACTFLG_Published | ACTFLG_Assigned | ACTFLG_UserInstall)));
        BOOL fAssign = FALSE;
        if (m_szDeploy == m_szPublished)
        {
            NewDetails.dwActFlags |= ACTFLG_Published;
        }
        else
        {
            NewDetails.dwActFlags |= ACTFLG_Assigned;
            fAssign = TRUE;
        }

        NewDetails.dwActFlags |= ((!m_fShow) ? 0 : ACTFLG_UserInstall);
        BOOL fMoveScript = (NewDetails.dwActFlags & (ACTFLG_Assigned | ACTFLG_Published))
            != (m_pData->pDetails->dwActFlags & (ACTFLG_Assigned | ACTFLG_Published))
            || (NewDetails.Platform.dwProcessorArch != m_pData->pDetails->Platform.dwProcessorArch);
        if (fMoveScript)
        {
            // Find out if script file can in fact be moved
            BOOL fCanMoveScript = FALSE;

            szOldScriptPath = m_pData->szPath;
            CString szTemp = szOldScriptPath;
            szTemp.MakeLower();
            int i = szTemp.Find(_T("\\published\\"));
            if (i < 0)
            {
                i = szTemp.Find(_T("\\assigned\\")); // cover all the bases
            }
            if (i >= 0)
            {
                // finally make sure it's got an .aas extension
                if (szTemp.Right(4) == _T(".aas"))
                {
                    DWORD dwAttributes =  GetFileAttributes(m_pData->szPath);
                    if ((dwAttributes != 0xffffffff) && ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
                    {
                        fCanMoveScript = TRUE;
                    }
                }
            }
            if (fCanMoveScript)
            {
                // Build new path

                szNewScriptPath = szOldScriptPath;
                // Strip off everything up to "\\published" or "\\assigned"
                szNewScriptPath = szNewScriptPath.Left(i);
                szNewScriptPath +=
                    (NewDetails.dwActFlags & ACTFLG_Assigned) != 0
                    ? _T("\\Assigned") : _T("\\Published");
                szNewScriptPath +=
                    NewDetails.Platform.dwProcessorArch == PROCESSOR_ARCHITECTURE_ALPHA
                    ? _T("\\Alpha\\") : _T("\\x86\\");
                {
                    TCHAR Name [_MAX_FNAME];
                    TCHAR Ext [_MAX_EXT];
                    TCHAR ScriptNameAndPath[_MAX_PATH ];
                    _tsplitpath( szOldScriptPath, NULL, NULL, Name, Ext );

                    szNewScriptPath += Name;
                    szNewScriptPath += Ext;
                }

                // Try and move it

                if (!MoveFileEx(szOldScriptPath,
                                szNewScriptPath,
                                MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH))
                {
                    // wasn't moved
                    fMoveScript = FALSE;

                    // UNDONE - put up a message that the scrip file wasn't moved?
                }
                else
                {
                    m_pData->szPath = szNewScriptPath;
                    NewDetails.pszScriptPath = (LPOLESTR)(LPCOLESTR)m_pData->szPath;
                }
            }
            else
            {
                // wasn't moved so make sure we don't try and move it back later
                fMoveScript = FALSE;
            }
        }

        NewDetails.pszProductName = (LPOLESTR) ((LPCTSTR)m_szDescription);

        BOOL fPathChanged = m_szPath != m_pData->szPath;
        if (fPathChanged)
        {
            // user changed the path
            NewDetails.pszScriptPath = (LPOLESTR)((LPCTSTR)m_szPath);
        }


        hr = m_pIClassAdmin->DeletePackage(m_pData->pDetails->pszPackageName);
        if (SUCCEEDED(hr))
        {
            hr = m_pIClassAdmin->AddPackage(m_szName, &NewDetails);
        }
        if (FAILED(hr))
        {
            if (fMoveScript)
            {
                // changed location for deployment back to what it was
                // before we failed to change the info in the class store
                // (Note that we're assuming that if we could change it one way
                // we can change it back.)

                if (MoveFileEx(szNewScriptPath,
                               szOldScriptPath,
                               MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH))
                {
                    m_pData->szPath = szOldScriptPath;
                    m_pData->pDetails->pszScriptPath = (LPOLESTR)(LPCOLESTR)m_pData->szPath;
                }

            }
            hr = m_pIClassAdmin->AddPackage(m_szName, m_pData->pDetails);
            // need to move this message
            ::MessageBox(NULL,
                         L"Couldn't apply changes.  Verify that the class store's server is active.",
                         L"ERROR",
                         MB_OK);
            return FALSE;
        }
        else
        {
            if (fMoveScript)
            {
                // Notify clients of change
                if (m_pIAppManagerActions)
                {
                    m_pIAppManagerActions->NotifyClients(FALSE);
                }
            }
        }

        memcpy(m_pData->pDetails, &NewDetails, sizeof(PACKAGEDETAIL));
        if (m_pData->pDetails->dwActFlags & ACTFLG_Assigned)
        {
            m_pData->type = DT_ASSIGNED;
        }
        else
        {
            m_pData->type = DT_PUBLISHED;
        }
        m_pData->szType = m_szDeploy;
        // Up above, we set NewDetails.pszPackageName to m_szName.
        // We can't leave it set to that because m_szName is a member
        // variable of this property sheet class object and will be released
        // when the property sheet goes away.  We need to copy it to
        // m_pData->szName (which is a CString and therefore has it's own
        // memory store) and then set the details back to it so it doesn't
        // get freed from under us.
        m_pData->szName = m_szName;
        m_pData->pDetails->pszPackageName = (LPOLESTR)((LPCTSTR)m_pData->szName);
        // same problem with szDesc
        m_pData->szDesc = m_szDescription;
        m_pData->pDetails->pszProductName = (LPOLESTR)((LPCTSTR)m_pData->szDesc);
        if (fPathChanged)
        {
            m_pData->szPath = m_szPath;
            m_pData->pDetails->pszScriptPath = (LPOLESTR)((LPCTSTR)m_pData->szPath);
        }
        if (m_szPath != m_pData->szPath)
        {
            // user changed the path
            m_pData->szPath = m_szPath;
            m_pData->pDetails->pszScriptPath = (LPOLESTR)((LPCTSTR)m_pData->szPath);
        }

        SetStringData(m_pData);

        MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);

        m_bUpdate = FALSE;
    }
#endif
    return CPropertyPage::OnApply();
}

BOOL CGeneralPage::OnInitDialog()
{
    TCHAR szBuffer[256];
    m_szName = m_pData->pDetails->pszPackageName;
    m_szDescription = _T("");
    m_szLocale = _T("");
    m_szPath = m_pData->pDetails->pInstallInfo->pszScriptPath;
    m_szDeploy = _T("");
    // wsprintf(szBuffer, _T("%u.%u"), m_pData->pDetails->Platform.dwVersionHi, m_pData->pDetails->Platform.dwVersionLo);
    m_szVer = szBuffer;
    m_fShow =  m_pData->pDetails->pInstallInfo->dwActFlags & ACTFLG_UserInstall ? 1 : 0;
    CPropertyPage::OnInitDialog();

    // unmarshal the IAppManagerActions interface
    HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStreamAM, IID_IAppManagerActions, (void **) &m_pIAppManagerActions);
    if (!SUCCEEDED(hr))
    {
#if DBG == 1
        ::MessageBox(NULL,
                     L"Couldn't marshal IAppManagerActions",
                     L"DEBUG ERROR",
                     MB_OK);
#endif
        m_pIAppManagerActions = NULL;
        return FALSE;
        // BUGBUG - what should I do here?  Disallow changes?
    }

    // unmarshal the IClassAdmin interface
    hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);
    if (!SUCCEEDED(hr))
    {
#if DBG == 1
        ::MessageBox(NULL,
                     L"Couldn't marshal IClassAdmin",
                     L"DEBUG ERROR",
                     MB_OK);
#endif
        m_pIClassAdmin = NULL;
        // BUGBUG - what should I do here?  Disallow changes?
    }

    ::LoadString(ghInstance, IDS_ASSIGNED, szBuffer, 256);
    m_szAssigned = szBuffer;
    // Test to be sure it can be assigned.
    // If it's not a Darwin package then it can't be assigned and
    // the option won't even be presented to the user.

    if (m_pIAppManagerActions)
    {
        hr = m_pIAppManagerActions->CanPackageBeAssigned(m_cookie);
    }
    if (hr == ERROR_SUCCESS)
    {
        m_cbDeploy.AddString(szBuffer);
    }
    ::LoadString(ghInstance, IDS_PUBLISHED, szBuffer, 256);
    m_szPublished = szBuffer;
    m_cbDeploy.AddString(szBuffer);
    m_cbDeploy.SelectString(0, m_szDeploy);
#if 0
    int i;
    for (i = 0; i < (sizeof(m_rgszOS) / sizeof(m_rgszOS[0])); i++)
    {
        ::LoadString(ghInstance, IDS_OS + i + 1, szBuffer, 256);
        m_rgszOS[i] = szBuffer;
        m_cbOS.AddString(szBuffer);
    }
    m_cbOS.SetCurSel(m_pData->pDetails->Platform.dwPlatformId);

    for (i = 0; i < (sizeof(m_rgszCPU) / sizeof(m_rgszCPU[0])); i++)
    {
        ::LoadString(ghInstance, IDS_HW + (i == 0 ? PROCESSOR_ARCHITECTURE_INTEL : PROCESSOR_ARCHITECTURE_ALPHA), szBuffer, 256);
        m_rgszCPU[i] = szBuffer;
        m_cbCPU.AddString(szBuffer);
    }
    m_cbCPU.SetCurSel(m_pData->pDetails->Platform.dwProcessorArch == PROCESSOR_ARCHITECTURE_ALPHA ? 1 : 0);
#endif
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CGeneralPage::OnChangeShow()
{
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CPropertyPage::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.

    // TODO: Add your control notification handler code here

    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangePath()
{
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeCPU()
{
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeOS()
{
    TCHAR * rgszVer[] =
    {
        _T("3.1"),
        _T("4.1"),
        _T("5.0")
    };
    int i = m_cbOS.GetCurSel();
    m_szVer = rgszVer[i];
    GetDlgItem(IDC_VERSION)->SetWindowText(m_szVer);
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeVersion()
{
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeName()
{
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CPropertyPage::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.

    // TODO: Add your control notification handler code here

    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeDescription()
{
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CPropertyPage::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.

    // TODO: Add your control notification handler code here
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnSelchangeDeploy()
{
    // TODO: Add your control notification handler code here
    SetModified();
    m_bUpdate = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\initdlg.cpp ===
// InitDlg.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInitDlg dialog


CInitDlg::CInitDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CInitDlg::IDD, pParent)
{
        //{{AFX_DATA_INIT(CInitDlg)
        m_szLDAP_Path = _T("");
        m_szGPT_Path = _T("");
        //}}AFX_DATA_INIT
}


void CInitDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CInitDlg)
        DDX_Text(pDX, IDC_EDIT1, m_szLDAP_Path);
        DDV_MaxChars(pDX, m_szLDAP_Path, 260);
        DDX_Text(pDX, IDC_EDIT2, m_szGPT_Path);
        DDV_MaxChars(pDX, m_szGPT_Path, 260);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInitDlg, CDialog)
        //{{AFX_MSG_MAP(CInitDlg)
                // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInitDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\fileext.h ===
#if !defined(AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// FileExt.h : header file
//

typedef struct tagEXTEL
{
    long lCookie;
    long lPriority;
} EXTEL;

typedef struct tagEXT
{
    std::vector<EXTEL> v;
    bool              fDirty;
} EXT;

// Comparitor used to sort the vector of EXTEL elements.
// This ensures that the item with the highest priority is put at the top of
// the list.
class order_EXTEL : public std::binary_function <const EXTEL&, const EXTEL&, bool>
{
public:
    bool operator () (const EXTEL& a, const EXTEL& b) const
    {
        return a.lPriority > b.lPriority;
    }
};

/////////////////////////////////////////////////////////////////////////////
// CFileExt dialog

class CFileExt : public CPropertyPage
{
        DECLARE_DYNCREATE(CFileExt)

// Construction
public:
        CFileExt();
        ~CFileExt();
        CComponentDataImpl * m_pCDI;
        std::map<CString, EXT> m_Extensions;
        IClassAdmin *   m_pIClassAdmin;
        IStream *       m_pIStream;

        CFileExt ** m_ppThis;

        void RefreshData(void);

// Dialog Data
        //{{AFX_DATA(CFileExt)
        enum { IDD = IDD_FILE_EXT };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CFileExt)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL
        //
protected:
        // Generated message map functions
        //{{AFX_MSG(CFileExt)
        afx_msg void OnMoveUp();
        afx_msg void OnMoveDown();
        afx_msg void OnExtensionChanged();
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILEEXT_H__5A23FB9E_92BB_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\initdlg.h ===
#if !defined(AFX_INITDLG_H__CA9BAE60_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_INITDLG_H__CA9BAE60_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InitDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInitDlg dialog

class CInitDlg : public CDialog
{
// Construction
public:
	CInitDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CInitDlg)
	enum { IDD = IDD_INITIALIZATION };
	CString	m_szLDAP_Path;
	CString	m_szGPT_Path;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CInitDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INITDLG_H__CA9BAE60_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\lcidpick.cpp ===
// LcidPick.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLcidPick dialog


CLcidPick::CLcidPick(CWnd* pParent /*=NULL*/)
        : CDialog(CLcidPick::IDD, pParent)
{
        //{{AFX_DATA_INIT(CLcidPick)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


void CLcidPick::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CLcidPick)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLcidPick, CDialog)
        //{{AFX_MSG_MAP(CLcidPick)
        ON_BN_CLICKED(IDC_BUTTON1, OnRemove)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLcidPick message handlers

void CLcidPick::OnRemove()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        pList->DeleteString(iSel);
        std::set<LCID>::iterator i = m_psLocales->begin();
        while (iSel--)
        {
            i++;
        }
        m_psLocales->erase(*i);
    }
}

BOOL CLcidPick::OnInitDialog()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    TCHAR szBuffer[256];

    // for every item in m_psLocales
    std::set<LCID>::iterator i;
    for (i = m_psLocales->begin(); i != m_psLocales->end(); i++)
    {
        // UNDONE - convert to a human readable string (not a number)
        CString sz;
        GetLocaleInfo(*i, LOCALE_SLANGUAGE, szBuffer, 256);
        sz += szBuffer;
        sz += _T(" - ");
        GetLocaleInfo(*i, LOCALE_SCOUNTRY, szBuffer, 256);
        sz += szBuffer;
        pList->AddString(sz);
    }

    CDialog::OnInitDialog();


    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\packages.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       packages.h
//
//  Contents:   Methods on CComponentDataImpl related to package deployment
//              and maintenence of the various index and cross-reference
//              structures.
//
//  Classes:
//
//  Functions:  CopyPackageDetail
//              FreePackageDetail
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

void CopyPackageDetail(PACKAGEDETAIL * & ppdOut, PACKAGEDETAIL * & ppdIn);

void FreePackageDetail(PACKAGEDETAIL * & ppd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\lcidpick.h ===
#if !defined(AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
#define AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LcidPick.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLcidPick dialog

class CLcidPick : public CDialog
{
// Construction
public:
        CLcidPick(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CLcidPick)
        enum { IDD = IDD_LOCALE_PICKER };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA
        std::set<LCID> * m_psLocales;


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CLcidPick)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CLcidPick)
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCIDPICK_H__0C66A5A0_9C1B_11D1_9852_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\pkgdtl.h ===
#if !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// pkgdtl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails dialog

class CPackageDetails : public CPropertyPage
{
        DECLARE_DYNCREATE(CPackageDetails)

// Construction
public:
        CPackageDetails();
        ~CPackageDetails();

        CPackageDetails ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CPackageDetails)
        enum { IDD = IDD_PACKAGE_DETAILS };
        CListBox        m_cList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPackageDetails)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        void RefreshData(void);

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CPackageDetails)
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
        void DumpDetails(FILE *);
        void DumpClassDetail(FILE *, CLASSDETAIL *);

        public:
            long    m_hConsoleHandle; // Handle given to the snap-in by the console
            APP_DATA * m_pData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\pkgdtl.cpp ===
// pkgdtl.cpp : implementation file
//

#include "precomp.hxx"

#include "fcntl.h"
#include "io.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails property page

IMPLEMENT_DYNCREATE(CPackageDetails, CPropertyPage)

CPackageDetails::CPackageDetails() : CPropertyPage(CPackageDetails::IDD)
{
        //{{AFX_DATA_INIT(CPackageDetails)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_hConsoleHandle = NULL;
}

CPackageDetails::~CPackageDetails()
{
    *m_ppThis = NULL;
}

void CPackageDetails::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPackageDetails)
        DDX_Control(pDX, IDC_LIST1, m_cList);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPackageDetails, CPropertyPage)
        //{{AFX_MSG_MAP(CPackageDetails)
        ON_WM_DESTROY()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails message handlers


// removes tabs and \n characters
void Convert(WCHAR * wsz, CString &sz)
{
    sz="";

    int iIn=0;
    int iOut=0;
    WCHAR ch;
    while (ch = wsz[iIn++])
    {
        switch (ch)
        {
        case L'\t':
            iOut++;
            sz += ' ';
            while (iOut % 4)
            {
                iOut++;
                sz += ' ';
            }
            break;
        case L'\n':
            break;
        default:
            iOut++;
            sz += ch;
            break;
        }
    }
}

void CPackageDetails::DumpClassDetail(FILE * stream, CLASSDETAIL * pClass)
{
    WCHAR wsz[256];
    StringFromGUID2(pClass->Clsid, wsz, 256);
    fwprintf(stream, L"\t\tClsid = %s\n",wsz);
    StringFromGUID2(pClass->TreatAs, wsz, 256);
    fwprintf(stream, L"\t\tTreatAs = %s\n",wsz);
    fwprintf(stream, L"\t\tcProgId = %u\n",pClass->cProgId);
    int i;
    for (i = 0; i < pClass->cProgId; i++)
    {
        fwprintf(stream, L"\t\tprgProgId[%u] = %s\n",i, pClass->prgProgId[i]);
    }
}

void CPackageDetails::DumpDetails(FILE * stream)
{
    PACKAGEDETAIL * pDetails = m_pData->pDetails;
    WCHAR wsz[256];
    fwprintf(stream, L"pszPackageName = %s\n", pDetails->pszPackageName);
    fwprintf(stream, L"cSources = %u\n",pDetails->cSources);
    int i;
    for (i = 0; i < pDetails->cSources; i++)
    {
        fwprintf(stream, L"pszSourceList[%u] = %s\n",i, pDetails->pszSourceList[i]);
    }
    fwprintf(stream, L"cCategories = %u\n",pDetails->cCategories);
    for (i = 0; i < pDetails->cCategories; i++)
    {
        StringFromGUID2(pDetails->rpCategory[i], wsz, 256);
        fwprintf(stream, L"rpCategory[%u]\n", i, wsz);
    }
    fwprintf(stream,L"pActInfo = \n{\n");

    ACTIVATIONINFO * pActInfo = pDetails->pActInfo;
    fwprintf(stream,L"\tcClasses = %u\n",pActInfo->cClasses);
    for (i = 0; i < pActInfo->cClasses; i++)
    {
        fwprintf(stream, L"\tpClasses[%u] = \n\t{\n",i);
        DumpClassDetail(stream, &pActInfo->pClasses[i]);
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream,L"\tcShellFileExt = %u\n",pActInfo->cShellFileExt);
    for (i = 0; i < pActInfo->cShellFileExt; i++)
    {
        fwprintf(stream, L"\tprgShellFileExt[%u] = %s\n", i, pActInfo->prgShellFileExt[i]);
        fwprintf(stream, L"\tprgPriority[%u] = %u\n", i, pActInfo->prgPriority[i]);
    }
    fwprintf(stream, L"\tcInterfaces = %u\n", pActInfo->cInterfaces);
    for (i = 0; i < pActInfo->cInterfaces; i++)
    {
        StringFromGUID2(pActInfo->prgInterfaceId[i], wsz, 256);
        fwprintf(stream, L"\tprgInterfaceId[%u] = %s\n", i, wsz);
    }
    fwprintf(stream, L"\tcTypeLib = %u\n", pActInfo->cTypeLib);
    for (i = 0; i < pActInfo->cTypeLib; i++)
    {
        StringFromGUID2(pActInfo->prgTlbId[i], wsz, 256);
        fwprintf(stream, L"\tprgTlbId[%u] = %s\n", i, wsz);
    }

    fwprintf(stream,L"}\npPlatformInfo = \n{\n");

    PLATFORMINFO * pPlatformInfo = pDetails->pPlatformInfo;
    fwprintf(stream, L"\tcPlatforms = %u\n",pPlatformInfo->cPlatforms);
    for (i = 0; i < pPlatformInfo->cPlatforms; i++)
    {
        fwprintf(stream, L"\tprgPlatform[%u] = \n\t{\n",i);
        fwprintf(stream, L"\t\tdwPlatformId = 0x%04X\n", pPlatformInfo->prgPlatform[i].dwPlatformId);
        fwprintf(stream, L"\t\tdwVersionHi = %u\n", pPlatformInfo->prgPlatform[i].dwVersionHi);
        fwprintf(stream, L"\t\tdwVersionLo = %u\n", pPlatformInfo->prgPlatform[i].dwVersionLo);
        fwprintf(stream, L"\t\tdwProcessorArch = 0x%04X\n", pPlatformInfo->prgPlatform[i].dwProcessorArch);
        fwprintf(stream, L"\t}\n");
    }
    fwprintf(stream, L"\tcLoacles = %u\n", pPlatformInfo->cLocales);
    for (i = 0; i < pPlatformInfo->cLocales; i++)
    {
        fwprintf(stream, L"\tprgLocale[%u] = 0x%04X\n", i, pPlatformInfo->prgLocale[i]);
    }

    fwprintf(stream,L"}\npInstallInfo = \n{\n");

    INSTALLINFO * pInstallInfo = pDetails->pInstallInfo;
    fwprintf(stream, L"\tdwActFlags = 0x%04X\n", pInstallInfo->dwActFlags);
    fwprintf(stream, L"\tPathType = %u\n", pInstallInfo->PathType);
    fwprintf(stream, L"\tpszScriptPath = %s\n", pInstallInfo->pszScriptPath);
    fwprintf(stream, L"\tpszSetupCommand = %s\n",pInstallInfo->pszSetupCommand);
    fwprintf(stream, L"\tpszUrl = %s\n",pInstallInfo->pszUrl);
    fwprintf(stream, L"\tUsn = %I64u\n",pInstallInfo->Usn);
    fwprintf(stream, L"\tdwComClassContext = %u\n", pInstallInfo->dwComClassContext);
    fwprintf(stream, L"\tInstallUiLevel = %u\n", pInstallInfo->InstallUiLevel);
    wsz[0] = 0;
    if (pInstallInfo->pClsid)
    {
        StringFromGUID2(*pInstallInfo->pClsid, wsz, 256);
    }
    fwprintf(stream, L"\tpClsid = %s\n", wsz);
    StringFromGUID2(pInstallInfo->ProductCode, wsz, 256);
    fwprintf(stream, L"\tProductCode = %s\n", wsz);
    fwprintf(stream, L"\tdwVersionHi = %u\n", pInstallInfo->dwVersionHi);
    fwprintf(stream, L"\tdwVersionLo = %u\n", pInstallInfo->dwVersionLo);
    fwprintf(stream, L"\tcUpgrades = %u\n", pInstallInfo->cUpgrades);
    for (i = 0; i < pInstallInfo->cUpgrades; i++)
    {
        fwprintf(stream, L"\tprgUpgradeScript[%u] = %s\n", i, pInstallInfo->prgUpgradeScript[i]);
        fwprintf(stream, L"\tprgUpgradeFlag[%u] = %u\n", i, pInstallInfo->prgUpgradeFlag[i]);
    }
    fwprintf(stream, L"\tcScriptLen = %u\n", pInstallInfo->cScriptLen);
    fwprintf(stream,L"}\n");
}

BOOL CPackageDetails::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        RefreshData();

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CPackageDetails::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        RefreshData();
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CPackageDetails::RefreshData(void)
{
    m_cList.ResetContent();

    // Dump the m_pData->pDetails structure here

    FILE * stream = tmpfile();
    _setmode(_fileno(stream), _O_TEXT);

    DumpDetails(stream);

    rewind(stream);

    WCHAR wsz[256];
    CString szTemp;
    int cWidth = 0;

    while (fgetws(wsz, 256, stream))
    {
        Convert(wsz, szTemp);
        CSize csExtent = m_cList.GetDC()->GetTextExtent(szTemp);
        m_cList.GetDC()->LPtoDP(&csExtent);
        if (cWidth < csExtent.cx)
        {
            cWidth = csExtent.cx;
        }
        m_cList.AddString(szTemp);
    }
    m_cList.SetHorizontalExtent(cWidth);
    fclose(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\packages.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       packages.cpp
//
//  Contents:   Methods on CComponentDataImpl related to package deployment
//              and maintenence of the various index and cross-reference
//              structures.
//
//  Classes:
//
//  Functions:
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

// UNDONE - put in exception handling for low memory conditions

#include "precomp.hxx"

IMalloc * g_pIMalloc = NULL;

void CopyPlatformInfo(PLATFORMINFO * &ppiOut, PLATFORMINFO * & ppiIn)
{
    if (NULL == ppiIn)
    {
        ppiOut = NULL;
        return;
    }
    ppiOut = (PLATFORMINFO *)OLEALLOC(sizeof(PLATFORMINFO));
    memcpy(ppiOut, ppiIn, sizeof(PLATFORMINFO));
    UINT n = ppiIn->cPlatforms;
    if (n)
    {
        ppiOut->prgPlatform = (CSPLATFORM*) OLEALLOC(sizeof(CSPLATFORM) * n);
        memcpy(ppiOut->prgPlatform, ppiIn->prgPlatform, sizeof(CSPLATFORM) * n);
    }
    n = ppiIn->cLocales;
    if (n)
    {
        ppiOut->prgLocale = (LCID *) OLEALLOC(sizeof(LCID) * n);
        memcpy(ppiOut->prgLocale, ppiIn->prgLocale, sizeof(LCID) * n);
    }
}

void CopyActInfo(ACTIVATIONINFO * & paiOut, ACTIVATIONINFO * & paiIn)
{
    if (NULL == paiIn)
    {
        paiOut = NULL;
        return;
    }
    paiOut = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
    memcpy(paiOut, paiIn, sizeof(ACTIVATIONINFO));
    UINT n = paiIn->cClasses;
    if (n)
    {
        paiOut->pClasses = (CLASSDETAIL *) OLEALLOC(sizeof(CLASSDETAIL) * n);
        memcpy(paiOut->pClasses, paiIn->pClasses, sizeof(CLASSDETAIL) * n);
        while (n--)
        {
            UINT n2 = paiIn->pClasses[n].cProgId;
            if (n2)
            {
                paiOut->pClasses[n].prgProgId = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n2);
                while (n2--)
                {
                    OLESAFE_COPYSTRING(paiOut->pClasses[n].prgProgId[n2], paiIn->pClasses[n].prgProgId[n2]);
                }
            }
        }
    }
    n = paiIn->cShellFileExt;
    if (n)
    {
        paiOut->prgPriority = (UINT *) OLEALLOC(sizeof(UINT) * n);
        memcpy(paiOut->prgPriority, paiIn->prgPriority, sizeof(UINT) * n);
        paiOut->prgShellFileExt = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        while (n--)
        {
            OLESAFE_COPYSTRING(paiOut->prgShellFileExt[n], paiIn->prgShellFileExt[n]);
        }
    }
    n = paiIn->cInterfaces;
    if (n)
    {
        paiOut->prgInterfaceId = (IID *) OLEALLOC(sizeof(IID) * n);
        memcpy(paiOut->prgInterfaceId, paiIn->prgInterfaceId, sizeof(IID) * n);
    }
    n = paiIn->cTypeLib;
    if (n)
    {
        paiOut->prgTlbId = (GUID *) OLEALLOC(sizeof(GUID) * n);
        memcpy(paiOut->prgTlbId, paiIn->prgTlbId, sizeof(GUID) * n);
    }
}

void CopyInstallInfo(INSTALLINFO * & piiOut, INSTALLINFO * & piiIn)
{
    if (NULL == piiIn)
    {
        piiOut = NULL;
        return;
    }
    piiOut = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
    memcpy(piiOut, piiIn, sizeof(INSTALLINFO));
    OLESAFE_COPYSTRING(piiOut->pszScriptPath, piiIn->pszScriptPath);
    OLESAFE_COPYSTRING(piiOut->pszSetupCommand, piiIn->pszSetupCommand);
    OLESAFE_COPYSTRING(piiOut->pszUrl, piiIn->pszUrl);
    if (piiIn->pClsid)
    {
        piiOut->pClsid = (GUID *) OLEALLOC(sizeof(GUID));
        memcpy(piiOut->pClsid, piiIn->pClsid, sizeof(GUID));
    }
    UINT n = piiIn->cUpgrades;
    if (n)
    {
        piiOut->prgUpgradeScript = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        piiOut->prgUpgradeFlag = (DWORD *) OLEALLOC(sizeof(DWORD) * n);
        memcpy(piiOut->prgUpgradeFlag, piiIn->prgUpgradeFlag, sizeof(DWORD) * n);
        while (n--)
        {
            OLESAFE_COPYSTRING(piiOut->prgUpgradeScript[n], piiIn->prgUpgradeScript[n]);
        }
    }
}

void CopyPackageDetail(PACKAGEDETAIL * & ppdOut, PACKAGEDETAIL * & ppdIn)
{
    if (NULL == ppdIn)
    {
        ppdOut = NULL;
        return;
    }
    ppdOut = new PACKAGEDETAIL;
    memcpy(ppdOut, ppdIn, sizeof(PACKAGEDETAIL));
    OLESAFE_COPYSTRING(ppdOut->pszPackageName, ppdIn->pszPackageName);
    UINT n = ppdIn->cSources;
    if (n)
    {
        ppdOut->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        while (n--)
        {
            OLESAFE_COPYSTRING(ppdOut->pszSourceList[n], ppdIn->pszSourceList[n]);
        }
    }
    n = ppdIn->cCategories;
    if (n)
    {
        ppdOut->rpCategory = (GUID *)OLEALLOC(sizeof(GUID) * n);
        memcpy(ppdOut->rpCategory, ppdIn->rpCategory, sizeof(GUID) * n);
    }
    CopyActInfo(ppdOut->pActInfo, ppdIn->pActInfo);
    CopyPlatformInfo(ppdOut->pPlatformInfo, ppdIn->pPlatformInfo);
    CopyInstallInfo(ppdOut->pInstallInfo, ppdIn->pInstallInfo);
}

void FreeActInfo(ACTIVATIONINFO * & pai)
{
    if (pai)
    {
        UINT n = pai->cClasses;
        while (n--)
        {
            UINT n2 = pai->pClasses[n].cProgId;
            while (n2--)
            {
                OLESAFE_DELETE(pai->pClasses[n].prgProgId[n2]);
            }
            OLESAFE_DELETE(pai->pClasses[n].prgProgId);
        }
        OLESAFE_DELETE(pai->pClasses);
        n = pai->cShellFileExt;
        while (n--)
        {
            OLESAFE_DELETE(pai->prgShellFileExt[n]);
        }
        OLESAFE_DELETE(pai->prgShellFileExt);
        OLESAFE_DELETE(pai->prgPriority);
        OLESAFE_DELETE(pai->prgInterfaceId);
        OLESAFE_DELETE(pai->prgTlbId);
        OLESAFE_DELETE(pai);
    }
}

void FreePlatformInfo(PLATFORMINFO * &ppi)
{
    if (ppi)
    {
        OLESAFE_DELETE(ppi->prgPlatform);
        OLESAFE_DELETE(ppi->prgLocale);
        OLESAFE_DELETE(ppi);
    }
}

void FreeInstallInfo(INSTALLINFO * &pii)
{
    if (pii)
    {
        OLESAFE_DELETE(pii->pszScriptPath);
        OLESAFE_DELETE(pii->pszSetupCommand);
        OLESAFE_DELETE(pii->pszUrl);
        OLESAFE_DELETE(pii->pClsid);
        UINT n = pii->cUpgrades;
        while (n--)
        {
            OLESAFE_DELETE(pii->prgUpgradeScript[n]);
        }
        if (pii->cUpgrades > 0)
        {
            OLESAFE_DELETE(pii->prgUpgradeScript);
            OLESAFE_DELETE(pii->prgUpgradeFlag);
        }
        OLESAFE_DELETE(pii);
    }
}

void FreePackageDetail(PACKAGEDETAIL * & ppd)
{
    if (ppd)
    {
        OLESAFE_DELETE(ppd->pszPackageName);
        UINT n = ppd->cSources;
        while (n--)
        {
            OLESAFE_DELETE(ppd->pszSourceList[n]);
        }
        OLESAFE_DELETE(ppd->rpCategory);
        FreeActInfo(ppd->pActInfo);
        FreePlatformInfo(ppd->pPlatformInfo);
        FreeInstallInfo(ppd->pInstallInfo);
        delete ppd;
        ppd = NULL;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::GetUniquePackageName
//
//  Synopsis:   Returns a unique package name.
//
//  Arguments:  [sz] - [in]  the name of the package
//                     [out] the new name, guaranteed unique on this cs
//
//  History:    1-23-1998   stevebl   Created
//
//  Notes:      First the input name is checked for uniqueness.  If it is
//              already unique it is returned unchanged.  If it is not
//              unique then a new name is formed by adding " (2)" to the end
//              of the string, then " (3)" and " (4)" and so on until a
//              unique name is found.
//
//---------------------------------------------------------------------------

void CComponentDataImpl::GetUniquePackageName(CString &sz)
{
    std::map<long, APP_DATA>::iterator i;
    std::set<CString> sNames;
    int cch = sz.GetLength();
    for (i=m_AppData.begin(); i != m_AppData.end(); i++)
    {
        // As an optimization, I'm only going to add names that might match
        // this one to the set.
        LPOLESTR szName = i->second.pDetails->pszPackageName;
        if (0 == wcsncmp(sz, szName, cch))
            sNames.insert(szName);
    }
    CString szRoot = sz;
    int index = 2; // start trying new names by adding (2) to the end
    // now check for a match
    do
    {
        if (sNames.end() == sNames.find(sz))
        {
            // we are unique
            return;
        }
        // try a different name
        sz.Format(L"%s (%i)", (LPCTSTR)szRoot, index++);
    } while (TRUE);
}


//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::AddMSIPackage
//
//  Synopsis:   Add's one or more packages to the class store and adds the
//              appropriate entries to the result pane.
//
//  Arguments:  [szPackagePath] - Full path to the Darwin package.
//              [lpFileTitle]   - file title from the open file dialog (used
//                                 for UI)
//
//  Returns:    S_OK    - succeeded
//              E_FAIL  - benign failure (probably a cancellation or something)
//              other   - significant failure
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::AddMSIPackage(LPCOLESTR szPackagePath, LPCOLESTR lpFileTitle)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = E_FAIL;
    if (m_pIClassAdmin)
    {
        ASSERT(m_pConsole);
        {
            BOOL fShowPropertySheet = FALSE;
            BOOL fShowUpgradeDialog = FALSE;
            GUID guid;
            PACKAGEDETAIL  *ppd = new PACKAGEDETAIL;
            memset(ppd, 0, sizeof(PACKAGEDETAIL));
            INSTALLINFO * pii = (INSTALLINFO *) OLEALLOC(sizeof(INSTALLINFO));
            memset(pii, 0, sizeof(INSTALLINFO));
            PLATFORMINFO * ppi = (PLATFORMINFO *) OLEALLOC(sizeof(PLATFORMINFO));
            memset(ppi, 0, sizeof(PLATFORMINFO));
            ACTIVATIONINFO * pai = (ACTIVATIONINFO *) OLEALLOC(sizeof(ACTIVATIONINFO));
            memset(pai, 0, sizeof(ACTIVATIONINFO));
            ppd->pActInfo = pai;
            ppd->pPlatformInfo = ppi;
            ppd->pInstallInfo = pii;
            // If appropriate, use the deployment wizard to set the
            // deployment type, otherwise use the default settings
            switch (m_ToolDefaults.NPBehavior)
            {
            case NP_WIZARD:
                {
                    CDeployApp dlgDeployApp;
                    if (IDCANCEL == dlgDeployApp.DoModal())
                    {
                        FreePackageDetail(ppd);
                        return E_FAIL;
                    }
                    switch (dlgDeployApp.m_iDeployment)
                    {
                    case 0: // upgrade
                        fShowUpgradeDialog = TRUE;
                        pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall;
                        break;
                    case 1: //published
                        pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall | ACTFLG_OnDemandInstall;
                        break;
                    case 2: // assigned
                        pii->dwActFlags = ACTFLG_Assigned | ACTFLG_OnDemandInstall;
                        break;
                    case 4: // custom
                        fShowPropertySheet = TRUE;
                        // fall through to disabled
                    case 3: // disabled
                    default:
                        pii->dwActFlags = ACTFLG_Published;
                        break;
                    }
                }
                break;
            case NP_PUBLISHED:
                pii->dwActFlags = ACTFLG_Published | ACTFLG_UserInstall;
                if (m_ToolDefaults.fAutoInstall)
                {
                    pii->dwActFlags |= ACTFLG_OnDemandInstall;
                }
                break;
            case NP_ASSIGNED:
                pii->dwActFlags = ACTFLG_Assigned | ACTFLG_OnDemandInstall;
                break;
            case NP_PROPPAGE:
                fShowPropertySheet = TRUE;
                // fall through to disabled
            case NP_DISABLED:
            default:
                pii->dwActFlags = ACTFLG_Published;
                break;
            }
            pii->PathType = DrwFilePath;
            pii->InstallUiLevel = m_ToolDefaults.UILevel;
            std::set<LCID> sLocales;
            // Use MsiSummaryInfoGetProperty to get platform and locale info.
            {
                MSIHANDLE hSummaryInfo;
                UINT msiReturn = MsiGetSummaryInformation(0, szPackagePath, 0, &hSummaryInfo);
                if (ERROR_SUCCESS == msiReturn)
                {
                    TCHAR szBuffer[256];
                    DWORD dwSize = 256;
                    msiReturn = MsiSummaryInfoGetProperty(hSummaryInfo,
                                                          7, // PID_TEMPLATE
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          szBuffer,
                                                          &dwSize);
                    if (ERROR_SUCCESS == msiReturn)
                    {
                        // break out the locale and platform properties
                        CString szLocales = szBuffer;
                        CString szPlatforms = szLocales.SpanExcluding(L";");
                        szLocales = szLocales.Mid(szPlatforms.GetLength()+1);
                        CString szTemp;
                        std::set<DWORD> sPlatforms;
                        while (szPlatforms.GetLength())
                        {
                            szTemp = szPlatforms.SpanExcluding(L",");
                            if (0 == szTemp.CompareNoCase(L"alpha"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_ALPHA);
                            }
                            else if (0 == szTemp.CompareNoCase(L"intel"))
                            {
                                sPlatforms.insert(PROCESSOR_ARCHITECTURE_INTEL);
                            }
                            szPlatforms = szPlatforms.Mid(szTemp.GetLength()+1);
                        }
                        while (szLocales.GetLength())
                        {
                            szTemp = szLocales.SpanExcluding(L",");
                            LCID lcid;
                            swscanf(szTemp, L"%i", &lcid);
                            sLocales.insert(lcid);
                            szLocales = szLocales.Mid(szTemp.GetLength()+1);
                        }
                        if (0 == sLocales.size() || 0 == sPlatforms.size())
                        {
                            // either not enough locales or platforms
                            FreePackageDetail(ppd);
                            return E_FAIL;  // need better error message?
                        }
                        ppi->cPlatforms = sPlatforms.size();
                        ppi->prgPlatform = (CSPLATFORM *) OLEALLOC(sizeof(CSPLATFORM) * (ppi->cPlatforms));;
                        std::set<DWORD>::iterator iPlatform;
                        INT n = 0;
                        for (iPlatform = sPlatforms.begin(); iPlatform != sPlatforms.end(); iPlatform++, n++)
                        {
                            ppi->prgPlatform[n].dwPlatformId = VER_PLATFORM_WIN32_NT;
                            ppi->prgPlatform[n].dwVersionHi = 5;
                            ppi->prgPlatform[n].dwVersionLo = 0;
                            ppi->prgPlatform[n].dwProcessorArch = *iPlatform;
                        }
                    }
                    MsiCloseHandle(hSummaryInfo);
                }
                if (ERROR_SUCCESS != msiReturn)
                {
                    FreePackageDetail(ppd);
                    return HRESULT_FROM_WIN32(msiReturn);
                }
            }
            ppi->cLocales = 1;
            ppi->prgLocale = (LCID *) OLEALLOC(sizeof(LCID));
            ppd->cSources = 1;
            ppd->pszSourceList = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR));
            OLESAFE_COPYSTRING(ppd->pszSourceList[0], szPackagePath);
            // UNDONE - check to see if we can detect any upgrade relationships

            if (fShowUpgradeDialog)
            {
                CUpgrades dlgUpgrade;
                dlgUpgrade.m_pAppData = &m_AppData;
                if (IDCANCEL == dlgUpgrade.DoModal())
                {
                    FreePackageDetail(ppd);
                    return E_FAIL;
                }
                UINT n = dlgUpgrade.m_UpgradeList.size();
                if (n)
                {
                    pii->cUpgrades = n;
                    pii->prgUpgradeScript = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
                    pii->prgUpgradeFlag = (DWORD *) OLEALLOC(sizeof(DWORD) * n);
                    std::map<long, BOOL>::iterator i = dlgUpgrade.m_UpgradeList.begin();
                    while (n--)
                    {
                        if (i->second)
                        {
                            pii->prgUpgradeFlag[n] = UPGFLG_Uninstall;
                        }
                        else
                        {
                            pii->prgUpgradeFlag[n] = UPGFLG_NoUninstall;
                        }
                        LPOLESTR sz = m_AppData[i->first].pDetails->pInstallInfo->pszScriptPath;
                        OLESAFE_COPYSTRING(pii->prgUpgradeScript[n], sz);
                        i++;
                    }
                }
            }

            // Put up the locale dialog and allow the user to remove locales
            // from the list if he so desires.
            if (1 < sLocales.size())
            {
                CLcidPick dlgLcidPick;
                dlgLcidPick.m_psLocales = &sLocales;
                int iReturn = dlgLcidPick.DoModal();
                if (IDCANCEL == iReturn || 0 == sLocales.size())
                {
                    FreePackageDetail(ppd);
                    return E_FAIL;
                }
            }

            // For each locale left in the list, publish a package and add
            // it to the class store.
            int nLocales = sLocales.size();
            std::set<LCID>::iterator iLocale;
            for (iLocale = sLocales.begin(); iLocale != sLocales.end(); iLocale++)
            {
                ppi->prgLocale[0] = *iLocale;

                // set the script path
                hr = CoCreateGuid(&guid);
                if (FAILED(hr))
                {
                    FreePackageDetail(ppd);
                    return hr;
                }
                OLECHAR sz [256];
                StringFromGUID2(guid, sz, 256);
                CString szScriptPath = m_szScriptRoot;
                szScriptPath += L"\\";
                szScriptPath += sz;
                szScriptPath += L".aas";
                OLESAFE_DELETE(pii->pszScriptPath);
                OLESAFE_COPYSTRING(pii->pszScriptPath, szScriptPath);

                // set the package name
                {
                    MSIHANDLE hProduct;
                    UINT msiReturn = MsiOpenPackage(szPackagePath, &hProduct);
                    if (ERROR_SUCCESS == msiReturn)
                    {
                        DWORD dw = 256;
                        OLECHAR szBuffer[256];
                        msiReturn = MsiGetProductProperty(hProduct, INSTALLPROPERTY_PRODUCTNAME, szBuffer, &dw);
                        if (ERROR_SUCCESS == msiReturn)
                        {
                            CString sz = szBuffer;
                            // If there is more than one locale in the
                            // locale list, then append the locale to the
                            // name to help distinguish it.
                            if (1 < nLocales)
                            {
                                sz += L" (";
                                GetLocaleInfo(ppi->prgLocale[0], LOCALE_SLANGUAGE, szBuffer, 256);
                                sz += szBuffer;
                                GetLocaleInfo(ppi->prgLocale[0], LOCALE_SCOUNTRY, szBuffer, 256);
                                sz += _T(" - ");
                                sz += szBuffer;
                                sz += L")";
                            }
                            // make sure the name is unique
                            GetUniquePackageName(sz);
                            OLESAFE_DELETE(ppd->pszPackageName);
                            OLESAFE_COPYSTRING(ppd->pszPackageName, sz);
                        }
                        MsiCloseHandle(hProduct);
                    }
                    if (ERROR_SUCCESS != msiReturn)
                    {
                        FreePackageDetail(ppd);
                        return HRESULT_FROM_WIN32(msiReturn);
                    }
                }
                HWND hwnd;
                m_pConsole->GetMainWindow(&hwnd);
                hr = BuildScriptAndGetActInfo(m_szGPTRoot, *ppd);
                if (SUCCEEDED(hr))
                {
                    hr = PrepareExtensions(*ppd);
                    if (SUCCEEDED(hr))
                    {
                        // put the script in the class store
                        hr = m_pIClassAdmin->AddPackage(ppd->pszPackageName, ppd);
                    }
                }
                if (S_OK != hr)
                {
                    TCHAR szBuffer[256];
                    ::LoadString(ghInstance, IDS_ADDFAILED, szBuffer, 256);
    #if DBG
                    TCHAR szDebugBuffer[256];
                    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                             NULL,
                                             hr,
                                             0,
                                             szDebugBuffer,
                                             sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                             NULL);
                    if (0 == dw)
                    {
                        wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
                    }
                    wcscat(szBuffer, szDebugBuffer);
    #endif
                    m_pConsole->MessageBox(szBuffer,
                                       lpFileTitle,
                                       MB_OK, NULL);
                    FreePackageDetail(ppd);
                    return hr;
                }
                else
                {
                    APP_DATA data;
                    CopyPackageDetail(data.pDetails, ppd);

                    data.InitializeExtraInfo();

                    m_lLastAllocated++;
                    m_AppData[m_lLastAllocated] = data;

                    RESULTDATAITEM resultItem;

                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = data.GetImageIndex(this);
                    // BUGBUG - need to make sure that m_lLastAllocated
                    // hasn't already been used!
                    resultItem.lParam = m_lLastAllocated;
                    hr = m_pSnapin->m_pResult->InsertItem(&resultItem);
                    if (SUCCEEDED(hr))
                    {
#if UGLY_SUBDIRECTORY_HACK
                        if (0 != (data.pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned))
                        {
                            CString sz = m_szGPTRoot;
                            sz += L"\\";
                            sz += data.pDetails->pInstallInfo->pszScriptPath;
                            // copy to subdirectories
                            CString szRoot;
                            CString szFile;
                            int i = sz.ReverseFind(L'\\');
                            szRoot = sz.Left(i);
                            szFile = sz.Mid(i+1);
                            CString szTemp;
                            for (i = data.pDetails->pPlatformInfo->cPlatforms; i--;)
                            {
                                if (PROCESSOR_ARCHITECTURE_INTEL == data.pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
                                {
                                    szTemp = szRoot;
                                    szTemp += L"\\assigned\\x86\\";
                                    szTemp += szFile;
                                    CopyFile(sz, szTemp, FALSE);
                                }
                                if (PROCESSOR_ARCHITECTURE_ALPHA == data.pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
                                {
                                    szTemp = szRoot;
                                    szTemp += L"\\assigned\\alpha\\";
                                    szTemp += szFile;
                                    CopyFile(sz, szTemp, FALSE);
                                }
                            }
                        }
#endif
                        m_AppData[m_lLastAllocated].itemID = resultItem.itemID;
                        InsertExtensionEntry(m_lLastAllocated, m_AppData[m_lLastAllocated]);
                        if (m_pFileExt)
                        {
                            m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
                        }
                        InsertUpgradeEntry(m_lLastAllocated, m_AppData[m_lLastAllocated]);
                        m_ScriptIndex[data.pDetails->pInstallInfo->pszScriptPath] = m_lLastAllocated;
                        // if this is an upgrade, set icons for upgraded apps to
                        // the proper icon.
                        UINT n = data.pDetails->pInstallInfo->cUpgrades;
                        while (n--)
                        {
                            std::map<CString, long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
                            if (i != m_ScriptIndex.end())
                            {
                                RESULTDATAITEM rd;
                                memset(&rd, 0, sizeof(rd));
                                rd.mask = RDI_IMAGE;
                                rd.itemID = m_AppData[i->second].itemID;
                                rd.nImage = IMG_UPGRADE;
                                m_pSnapin->m_pResult->SetItem(&rd);
                            }
                        }
                        m_pSnapin->m_pResult->Sort(0, 0, -1);
                    }
                }
            }
            FreePackageDetail(ppd);
        }
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::RemovePackage
//
//  Synopsis:   Removes a package from the class store and the result pane.
//
//  Arguments:  [pDataObject] - data object for this result pane item
//
//  Returns:    S_OK - success
//
//  History:    2-03-1998   stevebl   Created
//
//  Notes:      bAssigned is used
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::RemovePackage(long cookie)
{
    BOOL fAssigned;
    HRESULT hr = E_FAIL;
    // put up an hourglass (this could take a while)
    CHourglass hourglass;
    APP_DATA & data = m_AppData[cookie];

    // We need to make sure it gets removed from
    // the GPT before we delete it from the class store.

    CString sz = m_szGPTRoot;
    sz += L"\\";
    sz += data.pDetails->pInstallInfo->pszScriptPath;
    DeleteFile(sz);
#if UGLY_SUBDIRECTORY_HACK
    {
        // delete from subdirectories
        CString szRoot;
        CString szFile;
        int i = sz.ReverseFind(L'\\');
        szRoot = sz.Left(i);
        szFile = sz.Mid(i+1);
        CString szTemp;
        szTemp = szRoot;
        szTemp += L"\\assigned\\x86\\";
        szTemp += szFile;
        DeleteFile(szTemp);
        szTemp = szRoot;
        szTemp += L"\\assigned\\alpha\\";
        szTemp += szFile;
        DeleteFile(szTemp);
    }
#endif

    if (0 != (data.pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned))
    {
        fAssigned = TRUE;
    }
    else
    {
        fAssigned = FALSE;
    }
    hr = m_pIClassAdmin->RemovePackage((LPOLESTR)((LPCOLESTR)(data.pDetails->pszPackageName)));

    if (SUCCEEDED(hr))
    {
        hr = m_pSnapin->m_pResult->DeleteItem(data.itemID, 0);
        if (SUCCEEDED(hr))
        {
            // remove its entries in the extension table
            RemoveExtensionEntry(cookie, data);
            if (m_pFileExt)
            {
                m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
            }
            RemoveUpgradeEntry(cookie, data);
            m_ScriptIndex.erase(data.pDetails->pInstallInfo->pszScriptPath);
            // If this thing upgraded other apps, make sure that
            // they get the proper icons.
            UINT n = data.pDetails->pInstallInfo->cUpgrades;
            while (n--)
            {
                std::map<CString, long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
                if (i != m_ScriptIndex.end())
                {
                    RESULTDATAITEM rd;
                    memset(&rd, 0, sizeof(rd));
                    rd.mask = RDI_IMAGE;
                    rd.itemID = m_AppData[i->second].itemID;
                    rd.nImage = m_AppData[i->second].GetImageIndex(this);
                    m_pSnapin->m_pResult->SetItem(&rd);
                }
            }
            // If other apps were upgrading this app, do the same.
            std::set<long>::iterator i;
            for (i = data.sUpgrades.begin(); i != data.sUpgrades.end(); i++)
            {
                RESULTDATAITEM rd;
                memset(&rd, 0, sizeof(rd));
                rd.mask = RDI_IMAGE;
                rd.itemID = m_AppData[*i].itemID;
                rd.nImage = m_AppData[*i].GetImageIndex(this);
                m_pSnapin->m_pResult->SetItem(&rd);
            }
            FreePackageDetail(data.pDetails);
            m_AppData.erase(cookie);
            m_pSnapin->m_pResult->Sort(0, 0, -1);
            // Notify clients of change
            if (m_pIGPEInformation && fAssigned)
            {
                m_pIGPEInformation->PolicyChanged();
            }
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::PopulateUpgradeLists
//
//  Synopsis:   Walks the list of apps, making sure that all the upgrade
//              tables are complete.
//
//  Arguments:  none
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::PopulateUpgradeLists()
{
    HRESULT hr = S_OK;
    // For each app in the list, insert an entry in the upgrade tables of
    // the apps it upgrades.
    std::map <long, APP_DATA>::iterator iAppData;
    for (iAppData=m_AppData.begin(); iAppData != m_AppData.end(); iAppData++)
    {
        hr = InsertUpgradeEntry(iAppData->first, iAppData->second);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::InsertUpgradeEntry
//
//  Synopsis:   For every app that this app upgrades, place an entry in its
//              upgrades set so that it points back to this one.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//  Notes:      Needs to be able to deal with scripts that might not be in
//              this OU.
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::InsertUpgradeEntry(long cookie, APP_DATA & data)
{
    UINT n = data.pDetails->pInstallInfo->cUpgrades;
    while (n--)
    {
        std::map<CString,long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
        if (m_ScriptIndex.end() != i)
        {
            m_AppData[i->second].sUpgrades.insert(cookie);
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::RemoveUpgradeEntry
//
//  Synopsis:   For every app that this app upgraded, remove the entry from
//              its upgrades set.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    2-02-1998   stevebl   Created
//
//  Notes:      Needs to be able to deal with scripts that might not be in
//              this OU.
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::RemoveUpgradeEntry(long cookie, APP_DATA & data)
{
    UINT n = data.pDetails->pInstallInfo->cUpgrades;
    while (n--)
    {
        std::map<CString,long>::iterator i = m_ScriptIndex.find(data.pDetails->pInstallInfo->prgUpgradeScript[n]);
        if (m_ScriptIndex.end() != i)
        {
            m_AppData[i->second].sUpgrades.erase(cookie);
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::PopulateExtensions
//
//  Synopsis:   Builds the file extension table from the list of applications.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::PopulateExtensions()
{
    HRESULT hr = S_OK;
    // first erase the old extension list
    m_Extensions.erase(m_Extensions.begin(), m_Extensions.end());
    // now add each app's extensions to the table
    std::map <long, APP_DATA>::iterator iAppData;
    for (iAppData=m_AppData.begin(); iAppData != m_AppData.end(); iAppData++)
    {
        hr = InsertExtensionEntry(iAppData->first, iAppData->second);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    if (m_pFileExt)
    {
        m_pFileExt->SendMessage(WM_USER_REFRESH, 0, 0);
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::InsertExtensionEntry
//
//  Synopsis:   Adds a single entry to the extension tables.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::InsertExtensionEntry(long cookie, APP_DATA & data)
{
    UINT n = data.pDetails->pActInfo->cShellFileExt;
    while (n--)
    {
        m_Extensions[data.pDetails->pActInfo->prgShellFileExt[n]].insert(cookie);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::RemoveExtensionEntry
//
//  Synopsis:   Removes ane entry from the extension tables.
//
//  Arguments:  [cookie] -
//              [data]   -
//
//  Returns:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::RemoveExtensionEntry(long cookie, APP_DATA & data)
{
    UINT n = data.pDetails->pActInfo->cShellFileExt;
    while (n--)
    {
        m_Extensions[data.pDetails->pActInfo->prgShellFileExt[n]].erase(cookie);
        if (m_Extensions[data.pDetails->pActInfo->prgShellFileExt[n]].empty())
        {
            m_Extensions.erase(data.pDetails->pActInfo->prgShellFileExt[n]);
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::PrepareExtensions
//
//  Synopsis:   Sets extension priorities so that this data can be inserted
//              into the extension list with the proper priority.
//
//  Arguments:  [pd] -
//
//  Returns:
//
//  Modifies:
//
//  Derivation:
//
//  History:    1-29-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentDataImpl::PrepareExtensions(PACKAGEDETAIL &pd)
{
    UINT n = pd.pActInfo->cShellFileExt;
    while (n--)
    {
        // For each extension that is going to be added, we need to assign
        // it a priority that is one larger than the largest priority
        // already added.

        // NOTE: The odds of this number rolling over to 0 are so
        // unlikely that it would be pointless to check for it.  In any case
        // the results of such a bug would be easy for the admin to remedy
        // via the file extension priority dialog.

        pd.pActInfo->prgPriority[n] = 0;
        EXTLIST::iterator i;
        CString sz = pd.pActInfo->prgShellFileExt[n];
        for (i= m_Extensions[sz].begin(); i != m_Extensions[sz].end(); i++)
        {
            // look for the entry that matches this file extension
            APP_DATA & data = m_AppData[*i];
            UINT n2 = data.pDetails->pActInfo->cShellFileExt;
            while (n2--)
            {
                if (0 == sz.CompareNoCase(data.pDetails->pActInfo->prgShellFileExt[n2]))
                {
                    break;
                }
            }
            if (data.pDetails->pActInfo->prgPriority[n2] >= pd.pActInfo->prgPriority[n])
            {
                pd.pActInfo->prgPriority[n] = data.pDetails->pActInfo->prgPriority[n2] + 1;
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentDataImpl::ChangePackageState
//
//  Synopsis:   Changes the state of a package and puts up advisory message
//              boxes informing the admin about the effects of the change.
//
//  Arguments:  [data]       - entry to change
//              [dwNewState] - new state
//
//  History:    2-03-1998   stevebl   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP CComponentDataImpl::ChangePackageState(APP_DATA &data, DWORD dwNewState, BOOL fShowUI)
{
    HRESULT hr = S_OK;

    // first detect what's changed
    DWORD dwOldState = data.pDetails->pInstallInfo->dwActFlags;
    DWORD dwChange = dwOldState ^ dwNewState;

    if (dwChange)
    {
        // something changed
        if (fShowUI)
        {
            // Build a notification message
            CString szNotify = L"";
            WCHAR szBuffer [256];

            BOOL fAskAboutAutoInstall = FALSE;

            // changes we care about:
            //
            // Assigned flag changed:
            // UserInstall flag changed:
            // OnDemandInstall flag changed:  (We only care about this if we
            //                                aren't going to ask)

            if (dwChange & (ACTFLG_Assigned | ACTFLG_Published))
            {
                if (dwNewState & ACTFLG_Assigned)
                {
                    ::LoadString(ghInstance, IDS_TO_ASSIGNED, szBuffer, 256);
                }
                else
                {
                    ::LoadString(ghInstance, IDS_TO_PUBLISHED, szBuffer, 256);
                    if (dwNewState & (ACTFLG_UserInstall | ACTFLG_OnDemandInstall))
                        fAskAboutAutoInstall = TRUE;
                }
                szNotify += szBuffer;
            }

            if (dwChange & ACTFLG_UserInstall)
            {
                if (dwNewState & ACTFLG_UserInstall)
                {
                    ::LoadString(ghInstance, IDS_USERINSTALL_ON, szBuffer, 256);

                    // This check takes care of making sure we ask about
                    // AutoInstall when moving from the Disabled to the
                    // Published state.

                    if ((!(dwNewState & ACTFLG_Assigned)) && !(dwOldState & ACTFLG_OnDemandInstall))
                        fAskAboutAutoInstall = TRUE;
                }
                else
                {
                    ::LoadString(ghInstance, IDS_USERINSTALL_OFF, szBuffer, 256);
                }
                szNotify += szBuffer;
            }

            if (fAskAboutAutoInstall)
            {
                ::LoadString(ghInstance, IDS_ASK_AUTOINSTALL, szBuffer, 256);
                szNotify += szBuffer;
                int iReturn = ::MessageBox(NULL,
                                           szNotify,
                                           data.pDetails->pszPackageName,
                                           MB_YESNOCANCEL);
                if (IDCANCEL == iReturn)
                {
                    return E_ABORT;
                }

                if (IDYES == iReturn)
                    dwNewState |= ACTFLG_OnDemandInstall;
                else
                    dwNewState &= ~ACTFLG_OnDemandInstall;
            }
            else
            {
                if ((!(dwNewState & ACTFLG_Assigned)) && (dwChange & ACTFLG_OnDemandInstall))
                {
                    if (dwNewState & ACTFLG_OnDemandInstall)
                    {
                        ::LoadString(ghInstance, IDS_AUTOINSTALL_ON, szBuffer, 256);
                    }
                    else
                    {
                        ::LoadString(ghInstance, IDS_AUTOINSTALL_OFF, szBuffer, 256);
                    }
                    szNotify += szBuffer;
                }

                int iReturn = ::MessageBox(NULL,
                                           szNotify,
                                           data.pDetails->pszPackageName,
                                           MB_OKCANCEL);

                if (IDCANCEL == iReturn)
                {
                    return E_ABORT;
                }
            }
        }
        // commit changes
        hr = m_pIClassAdmin->ChangePackageProperties(data.pDetails->pszPackageName, NULL, &dwNewState, NULL, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            data.pDetails->pInstallInfo->dwActFlags = dwNewState;
            RESULTDATAITEM rd;
            memset(&rd, 0, sizeof(rd));
            rd.mask = RDI_IMAGE;
            rd.itemID = data.itemID;
            rd.nImage = data.GetImageIndex(this);
            m_pSnapin->m_pResult->SetItem(&rd);
            m_pSnapin->m_pResult->Sort(0, 0, -1);
            data.NotifyChange();
#if UGLY_SUBDIRECTORY_HACK
            {
                CString sz = m_szGPTRoot;
                sz += L"\\";
                sz += data.pDetails->pInstallInfo->pszScriptPath;
                // copy to subdirectories
                CString szRoot;
                CString szFile;
                int i = sz.ReverseFind(L'\\');
                szRoot = sz.Left(i);
                szFile = sz.Mid(i+1);
                CString szTemp;
                if (0 != (data.pDetails->pInstallInfo->dwActFlags & ACTFLG_Assigned))
                {
                    for (i = data.pDetails->pPlatformInfo->cPlatforms; i--;)
                    {
                        if (PROCESSOR_ARCHITECTURE_INTEL == data.pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
                        {
                            szTemp = szRoot;
                            szTemp += L"\\assigned\\x86\\";
                            szTemp += szFile;
                            CopyFile(sz, szTemp, FALSE);
                        }
                        if (PROCESSOR_ARCHITECTURE_ALPHA == data.pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
                        {
                            szTemp = szRoot;
                            szTemp += L"\\assigned\\alpha\\";
                            szTemp += szFile;
                            CopyFile(sz, szTemp, FALSE);
                        }
                    }
                }
                else
                {
                    szTemp = szRoot;
                    szTemp += L"\\assigned\\x86\\";
                    szTemp += szFile;
                    DeleteFile(szTemp);
                    szTemp = szRoot;
                    szTemp += L"\\assigned\\alpha\\";
                    szTemp += szFile;
                    DeleteFile(szTemp);
                }
            }
#endif
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\locpkg.cpp ===
// LocPkg.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLocPkg property page

IMPLEMENT_DYNCREATE(CLocPkg, CPropertyPage)

CLocPkg::CLocPkg() : CPropertyPage(CLocPkg::IDD)
{
        //{{AFX_DATA_INIT(CLocPkg)
        m_fAlpha = FALSE;
        m_fX86 = FALSE;
        //}}AFX_DATA_INIT
}

CLocPkg::~CLocPkg()
{
    *m_ppThis = NULL;
}

void CLocPkg::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CLocPkg)
        DDX_Check(pDX, IDC_CHECK1, m_fAlpha);
        DDX_Check(pDX, IDC_CHECK2, m_fX86);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLocPkg, CPropertyPage)
        //{{AFX_MSG_MAP(CLocPkg)
        ON_BN_CLICKED(IDC_CHECK1, OnChange)
        ON_BN_CLICKED(IDC_CHECK2, OnChange)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLocPkg message handlers

BOOL CLocPkg::OnApply()
{
    PLATFORMINFO * pPlatformInfo = m_pData->pDetails->pPlatformInfo;
    UINT i = 0;
    if (m_fX86)
    {
        i++;
    }
    if (m_fAlpha)
    {
        i++;
    }
    if (i == 0)
    {
        CString szTitle;
        szTitle.LoadString(IDS_BADDATA);
        CString szText;
        szText.LoadString(IDS_PLATFORMREQUIRED);
        MessageBox(szText, szTitle, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    m_pData->pDetails->pPlatformInfo = new PLATFORMINFO;
    m_pData->pDetails->pPlatformInfo->cPlatforms = i;
    m_pData->pDetails->pPlatformInfo->prgPlatform = new CSPLATFORM[i];
    m_pData->pDetails->pPlatformInfo->cLocales = pPlatformInfo->cLocales;
    m_pData->pDetails->pPlatformInfo->prgLocale = pPlatformInfo->prgLocale;
    i = 0;
    if (m_fX86)
    {
        m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId = VER_PLATFORM_WIN32_NT;
            m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi = 5;
        m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo = 0;
        m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch = PROCESSOR_ARCHITECTURE_INTEL;
        i++;
    }
    if (m_fAlpha)
    {
        m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwPlatformId = VER_PLATFORM_WIN32_NT;
            m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwVersionHi = 5;
        m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwVersionLo = 0;
        m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch = PROCESSOR_ARCHITECTURE_ALPHA;
    }
#if 0
    HRESULT hr = m_pIClassAdmin->UpgradePackage(m_pData->pDetails->pszPackageName,
                                                m_pData->pDetails);
    if (FAILED(hr))
    {
        PLATFORMINFO * pTemp = m_pData->pDetails->pPlatformInfo;
        m_pData->pDetails->pPlatformInfo = pPlatformInfo;
        pPlatformInfo = pTemp;
    }
    else
        MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
#endif
    delete [] pPlatformInfo->prgPlatform;
    delete pPlatformInfo;

    return CPropertyPage::OnApply();
}

BOOL CLocPkg::OnInitDialog()
{
    UINT i;
    for (i = m_pData->pDetails->pPlatformInfo->cPlatforms; i--;)
    {
        switch (m_pData->pDetails->pPlatformInfo->prgPlatform[i].dwProcessorArch)
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            m_fX86 = TRUE;
            break;
        case PROCESSOR_ARCHITECTURE_ALPHA:
            m_fAlpha = TRUE;
            break;
        default:
            break;
        }
    }
    TCHAR szBuffer[256];
    CString sz;
    i = 0;
    while (i < m_pData->pDetails->pPlatformInfo->cLocales)
    {
        GetLocaleInfo(m_pData->pDetails->pPlatformInfo->prgLocale[i], LOCALE_SLANGUAGE, szBuffer, 256);
        sz = szBuffer;
        GetLocaleInfo(m_pData->pDetails->pPlatformInfo->prgLocale[i], LOCALE_SCOUNTRY, szBuffer, 256);
        sz += _T(" - ");
        sz += szBuffer;
        i++;
        ((CListBox *)GetDlgItem(IDC_LIST1))->AddString(sz);
    }

    CPropertyPage::OnInitDialog();

    // unmarshal the IClassAdmin interface
    HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CLocPkg::OnChange()
{
    SetModified();
}

LRESULT CLocPkg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\locpkg.h ===
#if !defined(AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LocPkg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLocPkg dialog

class CLocPkg : public CPropertyPage
{
        DECLARE_DYNCREATE(CLocPkg)

// Construction
public:
        CLocPkg();
        ~CLocPkg();

        CLocPkg ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CLocPkg)
        enum { IDD = IDD_LOCALE_PACKAGE };
        BOOL    m_fAlpha;
        BOOL    m_fX86;
        //}}AFX_DATA
        APP_DATA *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        IStream *       m_pIStream;
        long            m_hConsoleHandle;
        DWORD           m_cookie;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CLocPkg)
	public:
        virtual BOOL OnApply();
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CLocPkg)
        virtual BOOL OnInitDialog();
        afx_msg void OnChange();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOCPKG_H__DE2C8019_91E4_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\product.h ===
#if !defined(AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Product.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProduct dialog

class CProduct : public CPropertyPage
{
        DECLARE_DYNCREATE(CProduct)

// Construction
public:
        CProduct();
        ~CProduct();

        CProduct ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CProduct)
        enum { IDD = IDD_PRODUCT };
        CString m_szVersion;
        CString m_szPublisher;
        CString m_szLanguage;
        CString m_szContact;
        CString m_szPhone;
        CString m_szURL;
        CString m_szName;
        //}}AFX_DATA

        APP_DATA * m_pData;
        IClassAdmin *   m_pIClassAdmin;
        IStream *       m_pIStream;
        long            m_hConsoleHandle;
        DWORD           m_cookie;
        std::map<long, APP_DATA> * m_pAppData;

// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CProduct)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        void RefreshData(void);

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CProduct)
        afx_msg void OnChangeName();
        virtual BOOL OnInitDialog();
        afx_msg void OnKillfocusEdit1();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRODUCT_H__2601C6D8_8C6B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\product.cpp ===
// Product.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProduct property page

IMPLEMENT_DYNCREATE(CProduct, CPropertyPage)

CProduct::CProduct() : CPropertyPage(CProduct::IDD)
{
        //{{AFX_DATA_INIT(CProduct)
        m_szVersion = _T("");
        m_szPublisher = _T("");
        m_szLanguage = _T("");
        m_szContact = _T("");
        m_szPhone = _T("");
        m_szURL = _T("");
        m_szName = _T("");
        //}}AFX_DATA_INIT
}

CProduct::~CProduct()
{
    *m_ppThis = NULL;
}

void CProduct::DoDataExchange(CDataExchange* pDX)
{
    // Make sure the variables have the correct info
    m_pData->GetSzVersion(m_szVersion);
    m_szPublisher = m_pData->szPublisher;
    m_pData->GetSzLocale(m_szLanguage);
    m_szContact = "n/a";
    m_szPhone = "n/a";
    m_szURL = m_pData->pDetails->pInstallInfo->pszUrl;

        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CProduct)
        DDX_Text(pDX, IDC_STATIC2, m_szVersion);
        DDX_Text(pDX, IDC_STATIC3, m_szPublisher);
        DDX_Text(pDX, IDC_STATIC4, m_szLanguage);
        DDX_Text(pDX, IDC_STATIC5, m_szContact);
        DDX_Text(pDX, IDC_STATIC6, m_szPhone);
        DDX_Text(pDX, IDC_STATIC7, m_szURL);
        DDX_Text(pDX, IDC_EDIT1, m_szName);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProduct, CPropertyPage)
        //{{AFX_MSG_MAP(CProduct)
        ON_EN_CHANGE(IDC_EDIT1, OnChangeName)
        ON_EN_KILLFOCUS(IDC_EDIT1, OnKillfocusEdit1)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CProduct::OnApply()
{
    CString szOldName = m_pData->pDetails->pszPackageName;
    if (0 != szOldName.Compare(m_szName))
    {
        // remove old package
        HRESULT hr = m_pIClassAdmin->RemovePackage(m_pData->pDetails->pszPackageName);
        if (SUCCEEDED(hr))
        {
            // change name
            OLESAFE_DELETE(m_pData->pDetails->pszPackageName);
            OLESAFE_COPYSTRING(m_pData->pDetails->pszPackageName, m_szName);
            // deploy new package
            hr = m_pIClassAdmin->AddPackage(m_pData->pDetails->pszPackageName, m_pData->pDetails);
            if (SUCCEEDED(hr))
            {
                MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);
            }
            else
            {
                // try and set it back
                m_szName = szOldName;
                OLESAFE_DELETE(m_pData->pDetails->pszPackageName);
                OLESAFE_COPYSTRING(m_pData->pDetails->pszPackageName, m_szName);
                hr = m_pIClassAdmin->AddPackage(m_pData->pDetails->pszPackageName, m_pData->pDetails);
            }
        }
    }
    return CPropertyPage::OnApply();
}

void CProduct::OnChangeName()
{
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT1);
    CString sz;
    pEdit->GetWindowText(sz);
    if (0 != sz.Compare(m_pData->pDetails->pszPackageName))
        SetModified();
    else
        SetModified(FALSE);
}

BOOL CProduct::OnInitDialog()
{
    RefreshData();

    CPropertyPage::OnInitDialog();

    // unmarshal the IClassAdmin interface
    HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProduct::OnKillfocusEdit1()
{
    // check that the new name is legitimate
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT1);
    CString sz;
    pEdit->GetWindowText(sz);
    if (0 != sz.Compare(m_pData->pDetails->pszPackageName))
    {
        std::map<long, APP_DATA>::iterator i;
        for (i = m_pAppData->begin(); i != m_pAppData->end(); i++)
        {
            if (0 == sz.Compare(i->second.pDetails->pszPackageName))
            {
                // another package has the same name
                // UNDONE: Put up a box warining why the name's being reset.
                pEdit->SetWindowText(m_pData->pDetails->pszPackageName);
                SetModified(FALSE);
                return;
            }
        }
    }
}

LRESULT CProduct::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        RefreshData();
        UpdateData(FALSE);
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}

void CProduct::RefreshData(void)
{
    m_szName = m_pData->pDetails->pszPackageName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\remove.cpp ===
// Remove.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemove dialog


CRemove::CRemove(CWnd* pParent /*=NULL*/)
        : CDialog(CRemove::IDD, pParent)
{
        //{{AFX_DATA_INIT(CRemove)
        m_iState = 0;
        //}}AFX_DATA_INIT
}


void CRemove::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CRemove)
        DDX_Radio(pDX, IDC_RADIO1, m_iState);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemove, CDialog)
        //{{AFX_MSG_MAP(CRemove)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CRemove::OnInitDialog()
{
        CDialog::OnInitDialog();

        if (1 == m_iState)
        {
            GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        }
        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\remove.h ===
#if !defined(AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Remove.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRemove dialog

class CRemove : public CDialog
{
// Construction
public:
        CRemove(CWnd* pParent = NULL);   // standard constructor
// Dialog Data
        //{{AFX_DATA(CRemove)
        enum { IDD = IDD_REMOVE };
        int             m_iState;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CRemove)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CRemove)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVE_H__E0F2E944_8915_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppDepEd.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_VERSION                     3
#define IDS_STAGE                       4
#define IDS_RELATION                    5
#define IDS_STATE                       6
#define IDS_AUTOINST                    7
#define IDS_LOC                         8
#define IDS_MACH                        9
#define IDS_MODS                        10
#define IDS_PUB                         11
#define IDS_SOURCE                      12
#define IDS_NODENAME                    13
#define IDS_ADD_APP_DESC                14
#define IDS_DEL_APP_DESC                15
#define IDS_REFRESH_DESC                16
#define IDS_AUTOINST_DESC               17
#define IDS_ASSIGN_DESC                 18
#define IDS_PUBLISH_DESC                19
#define IDS_DISABLE_DESC                20
#define IDS_MIGRATE_DESC                21
#define IDS_FINISH_DESC                 22
#define IDS_FOLDER_TITLE                30
#define IDS_ASSIGNED                    31
#define IDS_PUBLISHED                   32
#define IDS_DISABLED                    33
#define IDS_ARCHITECTURES               40
#define IDS_ALPHA                       41
#define IDD_UPGRADE                     101
#define IDD_DEPLOY_APP_DIALOG           102
#define IDD_PRODUCT                     106
#define IDD_GENERAL                     107
#define IDD_INSTALLATION                108
#define IDD_ENVIRONMENT                 109
#define IDD_DEPLOYMENT                  110
#define IDD_MODIFICATIONS               111
#define IDD_AUTO_INSTALL                112
#define IDD_CATEGORY                    113
#define IDD_SECURITY                    114
#define IDD_TOOL_DEFAULTS               115
#define IDD_LOCALE_PLATFORM             116
#define IDD_CATEGORIES                  117
#define IDD_FILE_EXT                    118
#define IDD_LOCALE_PACKAGE              119
#define IDD_FIND_UPGRADE                120
#define IDD_FIND_PACKAGE_UPGRADE        121
#define IDC_NAME                        201
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDC_EDIT2                       203
#define IDC_DEPLOY                      204
#define IDI_FOLDER                      205
#define IDC_CPU                         205
#define IDC_DESCRIPTION                 206
#define IDB_TOOLBAR1                    207
#define IDC_PATH                        207
#define IDB_TOOLBAR2                    208
#define IDC_LOCALE                      208
#define IDD_INITIALIZATION              209
#define IDC_BROWSE                      209
#define IDD_PACKAGE_DETAILS             210
#define IDC_OS                          211
#define IDD_REMOVE                      211
#define IDC_VERSION                     212
#define IDD_LOCALE_PICKER               213
#define IDM_ADD_APP                     300
#define IDM_REFRESH                     301
#define IDM_DEL_APP                     302
#define IDM_AUTOINST                    303
#define IDM_ASSIGN                      304
#define IDM_PUBLISH                     305
#define IDM_DISABLE                     306
#define IDM_MIGRATE                     307
#define IDM_FINISH                      308
#define IDS_DEF_EXTENSION               309
#define IDS_EXTENSION_FILTER            310
#define IDS_CSADMINFAILED               311
#define IDS_GPTFAILED                   312
#define IDS_ADDFAILED                   313
#define IDS_CABCAPTION                  314
#define IDS_CABWARNING                  315
#define IDS_URLMONERROR                 316
#define IDS_CLASSSTOREERROR             317
#define IDS_SPAWNMSG                    318
#define IDS_SPAWNCAPTION                319
#define IDS_NOCOMSVR                    320
#define IDS_ADDEXISTSALREADY            321
#define IDS_CLSIDCONFLICT1              322
#define IDS_CLSIDCONFLICT2              323
#define IDS_BOGUS_EXTENSION             324
#define IDS_NO                          325
#define IDS_YES                         326
#define IDS_MULTIPLE                    327
#define IDS_NONE                        328
#define IDS_DEPLOYED                    329
#define IDS_PILOT                       330
#define IDS_ROLLOUT                     331
#define IDS_OS                          400
#define IDS_HW                          410
#define IDM_ASSIGN_T                    504
#define IDM_PUBLISH_T                   505
#define IDM_DISABLE_T                   506
#define IDS_AUTOINSTALL_ON              600
#define IDS_AUTOINSTALL_OFF             601
#define IDS_ASK_AUTOINSTALL             602
#define IDS_USERINSTALL_ON              603
#define IDS_USERINSTALL_OFF             604
#define IDS_TO_PUBLISHED                605
#define IDS_TO_ASSIGNED                 606
#define IDS_BADDATA                     607
#define IDS_PLATFORMREQUIRED            608
#define IDC_LIST1                       1000
#define IDC_EDIT1                       1002
#define IDC_RADIO1                      1003
#define IDC_RADIO2                      1004
#define IDC_CHECK1                      1005
#define IDC_CHECK2                      1006
#define IDC_RADIO3                      1007
#define IDC_RADIO4                      1008
#define IDC_BUTTON1                     1009
#define IDC_BUTTON2                     1010
#define IDC_BUTTON3                     1011
#define IDC_BUTTON4                     1012
#define IDC_RADIO5                      1013
#define IDC_RADIO6                      1014
#define IDC_RADIO7                      1015
#define IDC_RADIO8                      1016
#define IDC_RADIO9                      1017
#define IDC_LIST2                       1018
#define IDC_COMBO1                      1019
#define IDC_STATIC1                     1020
#define IDC_STATIC2                     1021
#define IDC_STATIC3                     1022
#define IDC_STATIC4                     1023
#define IDC_STATIC5                     1024
#define IDC_CN                          1025
#define IDC_STATIC6                     1026
#define IDC_STATIC7                     1027
#define IDC_STATIC8                     1028

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        214
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\script.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       script.cpp
//
//  Contents:   Functions for working with Darwin files, both packages,
//              transforms and scripts.
//
//  Classes:
//
//  Functions:  BuildScriptAndGetActInfo
//
//  History:    1-14-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#define REG_TEMP L"temporary key created by ADE"

HRESULT GetShellExtensions(HKEY hkey, PACKAGEDETAIL &pd);

HRESULT GetCLSIDs(HKEY hkey, PACKAGEDETAIL &pd);

HRESULT GetIIDs(HKEY hkey, PACKAGEDETAIL &pd);

HRESULT GetTLBs(HKEY hkey, PACKAGEDETAIL &pd);

//+--------------------------------------------------------------------------
//
//  Function:   RegDeleteTree
//
//  Synopsis:   deletes a registry key and all of its children
//
//  Arguments:  [hKey]     - handle to the key's parent
//              [szSubKey] - name of the key to be deleted
//
//  Returns:    ERROR_SUCCESS
//
//  History:    1-14-1998   stevebl   Moved from old project
//
//---------------------------------------------------------------------------

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, szSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, szSubKey);
}

//+--------------------------------------------------------------------------
//
//  Function:   BuildScriptAndGetActInfo
//
//  Synopsis:   Builds the script file and fills in the ACTINFO structure
//              member in the PACKAGEDETAIL structure.
//
//  Arguments:  [szScriptRoot] - [in] the subdirectory that the script file
//                                should be place in.
//              [pd]           - [in/out] package detail structure - see
//                                notes for complete list of fields that
//                                should be filled in and the list of fields
//                                that are set on return
//
//  Returns:    S_OK - success
//              <other> - error
//
//  Modifies:   all fields under pd.pActInfo (only on success)
//              also modifies pd.pInstallInfo->cScriptLen
//
//  History:    1-14-1998   stevebl   Created
//
//  Notes:      On input:
//              pd.cSources must be >= 1.
//              pd.pszSourceList[] contains the MSI package and the list of
//              (if any) transforms to be applied.
//              pd.pPlatformInfo should be completely filled in (only one
//              locale).
//              pd.pInstallInfo->pszScriptFile contains the name of the
//              script file to be generated.
//
//              On output:
//              The script file will be generated under the appropriate name
//              and in the appropriate directory.
//              pd.pActInfo will be completely filled in.
//
//---------------------------------------------------------------------------

HRESULT BuildScriptAndGetActInfo(CString szScriptRoot, PACKAGEDETAIL & pd)
{
    CHourglass hourglass;
    HRESULT hr;
    UINT uMsiStatus;
    LONG error;
    int i;
    CString szScriptPath = szScriptRoot;
    szScriptPath += L"\\";
    szScriptPath += pd.pInstallInfo->pszScriptPath;
    CString szTransformList = L"";
    for (i = 1; i < pd.cSources; i++)
    {
        if (i < 1)
        {
            szTransformList += L";";
        }
        szTransformList += pd.pszSourceList[i];
    }

    // disable MSI ui
    MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

    // build the script file

    uMsiStatus = MsiAdvertiseProduct(pd.pszSourceList[0],
                                    szScriptPath,
                                    szTransformList,
                                    LANGIDFROMLCID(pd.pPlatformInfo->prgLocale[0]));
    if (uMsiStatus)
    {
        // an error occured
        return HRESULT_FROM_WIN32((long)uMsiStatus);
    }

    // get script file length
    HANDLE hFile = CreateFile(szScriptPath,
                              GENERIC_READ,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        pd.pInstallInfo->cScriptLen = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
    }

    //
    // dump everyting into the registry
    //

    // nuke old temporary registry key just to be safe:
    RegDeleteTree(HKEY_CLASSES_ROOT, REG_TEMP);

    // create temporary registry key

    DWORD dwDisp;
    HKEY hkey;

    error = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                           REG_TEMP,
                           0,
                           L"REG_SZ",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           0,
                           &hkey,
                           &dwDisp);

    hr = HRESULT_FROM_WIN32(error);
    if (SUCCEEDED(hr))
    {
        uMsiStatus = MsiProcessAdvertiseScript(szScriptPath,
                                               0,
                                               hkey,
                                               FALSE,
                                               FALSE);

        hr = HRESULT_FROM_WIN32(uMsiStatus);
        if (SUCCEEDED(hr))
        {
            // fill in the ActInfo
            GetShellExtensions(hkey, pd);
            GetCLSIDs(hkey, pd);
            GetIIDs(hkey, pd);
            GetTLBs(hkey, pd);
        }
        RegCloseKey(hkey);
        RegDeleteTree(HKEY_CLASSES_ROOT, REG_TEMP);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetShellExtensions
//
//  Synopsis:   fills the shell extension part of the PACKAGEDETAIL structure
//
//  Arguments:  [hkey] - key containing the registry info
//              [pd]   - PACKAGEDETAIL structure
//
//  History:    1-15-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT GetShellExtensions(HKEY hkey, PACKAGEDETAIL &pd)
{
    std::vector<CString> v;
    TCHAR szName[256];
    LONG lResult;
    UINT n = 0;
    while (ERROR_SUCCESS == RegEnumKey(hkey, n++, szName, 256))
    {
        if (szName[0] == L'.')
        {
            v.push_back(szName);
        }
    }
    n = v.size();
    pd.pActInfo->cShellFileExt = n;
    if (n > 0)
    {
        pd.pActInfo->prgShellFileExt = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * n);
        pd.pActInfo->prgPriority = (UINT *) OLEALLOC(sizeof(UINT) * n);
        while (n--)
        {
            CString &sz = v[n];
            sz.MakeLower();
            OLESAFE_COPYSTRING(pd.pActInfo->prgShellFileExt[n], sz);
            pd.pActInfo->prgPriority[n] = 0;
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetCLSIDs
//
//  Synopsis:   fills the CLSID part of the PACKAGEDETAIL structure
//
//  Arguments:  [hkey] - key containing the registry info
//              [pd]   - PACKAGEDETAIL structure
//
//  History:    1-15-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT GetCLSIDs(HKEY hkey, PACKAGEDETAIL &pd)
{
    HRESULT hr;
    LONG lResult;
    HKEY hkeyNew;
    lResult = RegOpenKey(hkey, L"CLSID", &hkeyNew);
    if (lResult == ERROR_SUCCESS)
    {
        // Find all the CLSID entries and add them to our vector
        UINT n = 0;
        std::vector<CLASSDETAIL> v;
        TCHAR szName[256];
        while (ERROR_SUCCESS == RegEnumKey(hkeyNew, n++, szName, 256))
        {
            CLASSDETAIL cd;
            memset(&cd, 0, sizeof(CLASSDETAIL));
            hr = CLSIDFromString(szName, &cd.Clsid);
            if (SUCCEEDED(hr))
            {
                HKEY hkeyCLSID;
                lResult = RegOpenKey(hkeyNew, szName, &hkeyCLSID);
                if (ERROR_SUCCESS == lResult)
                {
                    HKEY hkeySub;
                    DWORD dw;
                    lResult = RegOpenKey(hkeyCLSID, L"TreatAs", &hkeySub);
                    if (ERROR_SUCCESS == lResult)
                    {
                        dw = 256 * sizeof(TCHAR);
                        lResult = RegQueryValueEx(hkeySub, L"", 0, NULL, (LPBYTE) szName, &dw);
                        if (ERROR_SUCCESS == lResult)
                        {
                            CLSIDFromString(szName, &cd.TreatAs);
                        }
                        RegCloseKey(hkeySub);
                    }
                    TCHAR szProgID[256];
                    szProgID[0] = 0;
                    TCHAR szVersionIndependentProgID[256];
                    szVersionIndependentProgID[0] = 0;
                    lResult = RegOpenKey(hkeyCLSID, L"ProgID", &hkeySub);
                    if (ERROR_SUCCESS == lResult)
                    {
                        dw = 256 * sizeof(TCHAR);
                        RegQueryValueEx(hkeySub, L"", 0, NULL, (LPBYTE) szProgID, &dw);
                        RegCloseKey(hkeySub);
                    }
                    lResult = RegOpenKey(hkeyCLSID, L"VersionIndependentProgID", &hkeySub);
                    if (ERROR_SUCCESS == lResult)
                    {
                        dw = 256 * sizeof(TCHAR);
                        RegQueryValueEx(hkeySub, L"", 0, NULL, (LPBYTE) szVersionIndependentProgID, &dw);
                        RegCloseKey(hkeySub);
                    }
                    DWORD cProgId = 0;
                    if (szProgID[0])
                    {
                        cProgId++;
                    }
                    if (szVersionIndependentProgID[0])
                    {
                        cProgId++;
                    }
                    if (cProgId > 0)
                    {
                        cd.cProgId = cProgId;
                        cd.prgProgId = (LPOLESTR *) OLEALLOC(sizeof(LPOLESTR) * cProgId);
                        cProgId = 0;
                        if (szProgID[0])
                        {
                            OLESAFE_COPYSTRING(cd.prgProgId[cProgId], szProgID);
                            cProgId++;
                        }
                        if (szVersionIndependentProgID[0])
                        {
                            OLESAFE_COPYSTRING(cd.prgProgId[cProgId], szVersionIndependentProgID);
                        }
                    }
                    RegCloseKey(hkeyCLSID);
                }
                v.push_back(cd);
            }
        }
        RegCloseKey(hkeyNew);
        // create the list of CLASSDETAIL structures
        n = v.size();
        pd.pActInfo->cClasses = n;
        if (n > 0)
        {
            pd.pActInfo->pClasses = (CLASSDETAIL *) OLEALLOC(sizeof(CLASSDETAIL) * n);
            while (n--)
            {
                pd.pActInfo->pClasses[n] = v[n];
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIIDs
//
//  Synopsis:   fills in the Interface section of the PACKAGEDETAIL structure
//
//  Arguments:  [hkey] - key containing the registry info
//              [pd]   - PACKAGEDETAIL structure
//
//  History:    1-15-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT GetIIDs(HKEY hkey, PACKAGEDETAIL &pd)
{
    HRESULT hr;
    LONG lResult;
    HKEY hkeyNew;
    lResult = RegOpenKey(hkey, L"Interface", &hkeyNew);
    if (lResult == ERROR_SUCCESS)
    {
        // Find all the IID entries and add them to our vector
        UINT n = 0;
        std::vector<GUID> v;
        TCHAR szName[256];
        while (ERROR_SUCCESS == RegEnumKey(hkeyNew, n++, szName, 256))
        {
            GUID g;
            hr = CLSIDFromString(szName, &g);
            if (SUCCEEDED(hr))
            {
                v.push_back(g);
            }
        }
        RegCloseKey(hkeyNew);
        // create the list
        n = v.size();
        pd.pActInfo->cInterfaces = n;
        if (n > 0)
        {
            pd.pActInfo->prgInterfaceId = (IID *) OLEALLOC(sizeof(IID) * n);
            while (n--)
            {
                pd.pActInfo->prgInterfaceId[n] = v[n];
            }
        }
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetTLBs
//
//  Synopsis:   fills in the type library section of the PACKAGEDETAIL struct
//
//  Arguments:  [hkey] - key containing the registry info
//              [pd]   - PACKAGEDETAIL structure
//
//  History:    1-15-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT GetTLBs(HKEY hkey, PACKAGEDETAIL &pd)
{
    HRESULT hr;
    LONG lResult;
    HKEY hkeyNew;
    lResult = RegOpenKey(hkey, L"TypeLib", &hkeyNew);
    if (lResult == ERROR_SUCCESS)
    {
        // Find all the TLB entries and add them to our vector
        UINT n = 0;
        std::vector<GUID> v;
        TCHAR szName[256];
        while (ERROR_SUCCESS == RegEnumKey(hkeyNew, n++, szName, 256))
        {
            GUID g;
            hr = CLSIDFromString(szName, &g);
            if (SUCCEEDED(hr))
            {
                v.push_back(g);
            }
        }
        RegCloseKey(hkeyNew);
        // create the list
        n = v.size();
        pd.pActInfo->cTypeLib = n;
        if (n > 0)
        {
            pd.pActInfo->prgTlbId = (GUID *) OLEALLOC(sizeof(GUID) * n);
            while (n--)
            {
                pd.pActInfo->prgTlbId[n] = v[n];
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\script.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       script.h
//
//  Contents:   Functions for working with Darwin files, both packages,
//              transforms and scripts.
//
//  Classes:
//
//  Functions:  BuildScriptAndGetActInfo
//
//  History:    1-14-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#define _NEW_
#include <vector>

LONG RegDeleteTree(HKEY hKey, TCHAR * szSubKey);
HRESULT BuildScriptAndGetActInfo(CString szScriptRoot, PACKAGEDETAIL & pd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "safereg.hxx"


//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;
    ULONG   ulType;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszPathBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
    }
    else if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\upgrades.cpp ===
// Upgrades.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUpgrades dialog


CUpgrades::CUpgrades(CWnd* pParent /*=NULL*/)
        : CDialog(CUpgrades::IDD, pParent)
{
        //{{AFX_DATA_INIT(CUpgrades)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


void CUpgrades::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CUpgrades)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUpgrades, CDialog)
        //{{AFX_MSG_MAP(CUpgrades)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnEdit)
        ON_BN_CLICKED(IDC_BUTTON3, OnRemove)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUpgrades message handlers

void CUpgrades::OnAdd()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    CAddUpgrade dlgAdd;
    dlgAdd.m_pUpgradeList = & m_UpgradeList;
    dlgAdd.m_pNameIndex = & m_NameIndex;
//    dlgAdd.m_pAppData = m_pAppData;
    if (IDOK == dlgAdd.DoModal())
    {
        // add the chosen app
        m_UpgradeList[dlgAdd.m_cookie] = dlgAdd.m_fUninstall;
        CString sz = (*m_pAppData)[dlgAdd.m_cookie].pDetails->pszPackageName;
        pList->AddString(sz);
    }
}

void CUpgrades::OnEdit()
{
        // TODO: Add your control notification handler code here

}

void CUpgrades::OnRemove()
{
    CListBox * pList = (CListBox *)GetDlgItem(IDC_LIST1);
    int iSel = pList->GetCurSel();
    if (iSel != LB_ERR)
    {
        CString sz;
        pList->GetText(iSel, sz);
        m_UpgradeList.erase(m_NameIndex[sz]);
        pList->DeleteString(iSel);
    }
}

BOOL CUpgrades::OnInitDialog()
{
    // Walk the APPDATA map and build m_NameIndex.
    // UNDONE - also build the upgrade list by adding apps
    std::map<long, APP_DATA>::iterator i;
    for (i = m_pAppData->begin(); i != m_pAppData->end(); i++)
    {
        CString sz = i->second.pDetails->pszPackageName;
        m_NameIndex[sz] = i->first;
    }
    // UNDONE - pre-populate list box with the apps in the upgrade list

    CDialog::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\tooldefs.h ===
#if !defined(AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
#define AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ToolDefs.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CToolDefs dialog

class CToolDefs : public CPropertyPage
{
// Construction
public:
        CToolDefs(CWnd* pParent = NULL);   // standard constructor
        ~CToolDefs();

// Dialog Data
        //{{AFX_DATA(CToolDefs)
        enum { IDD = IDD_TOOL_DEFAULTS };
        CString m_szStartPath;
        BOOL    m_fAutoInstall;
        int             m_iDeployment;
        int             m_iUI;
        //}}AFX_DATA
        TOOL_DEFAULTS * m_pToolDefaults;
        long            m_hConsoleHandle;
        DWORD           m_cookie;

        CToolDefs ** m_ppThis;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CToolDefs)
	public:
        virtual BOOL OnApply();
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CToolDefs)
        virtual BOOL OnInitDialog();
        afx_msg void OnBrowse();
        afx_msg void OnUseWizard();
        afx_msg void OnUsePropPage();
        afx_msg void OnDeployDisabled();
        afx_msg void OnDeployPublished();
        afx_msg void OnDeployAssigned();
        afx_msg void OnBasicUI();
        afx_msg void OnMaxUI();
        afx_msg void OnDefaultUI();
        afx_msg void OnChangePath();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TOOLDEFS_H__B6FBC88D_8B7B_11D1_984D_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\snapin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Oct 03 17:06:29 1996
 */
/* Compiler settings for Snapin.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Snapin_h__
#define __Snapin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IComponent : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponent_INTERFACE_DEFINED__ */



#ifndef __SNAPINLib_LIBRARY_DEFINED__
#define __SNAPINLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SNAPINLib
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SNAPINLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Snapin;

class Snapin;
#endif
#endif /* __SNAPINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\tooldefs.cpp ===
// ToolDefs.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolDefs dialog


CToolDefs::CToolDefs(CWnd* pParent /*=NULL*/)
    : CPropertyPage(CToolDefs::IDD)
{
    //{{AFX_DATA_INIT(CToolDefs)
    m_szStartPath = _T("");
    m_fAutoInstall = FALSE;
    m_iDeployment = -1;
    m_iUI = -1;
    //}}AFX_DATA_INIT
}

CToolDefs::~CToolDefs()
{
    *m_ppThis = NULL;
}

void CToolDefs::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CToolDefs)
    DDX_Text(pDX, IDC_EDIT1, m_szStartPath);
    DDX_Check(pDX, IDC_CHECK1, m_fAutoInstall);
    DDX_Radio(pDX, IDC_RADIO1, m_iDeployment);
    DDX_Radio(pDX, IDC_RADIO7, m_iUI);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolDefs, CDialog)
    //{{AFX_MSG_MAP(CToolDefs)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_BN_CLICKED(IDC_RADIO1, OnUseWizard)
    ON_BN_CLICKED(IDC_RADIO2, OnUsePropPage)
    ON_BN_CLICKED(IDC_RADIO4, OnDeployDisabled)
    ON_BN_CLICKED(IDC_RADIO5, OnDeployPublished)
    ON_BN_CLICKED(IDC_RADIO6, OnDeployAssigned)
    ON_BN_CLICKED(IDC_RADIO8, OnBasicUI)
    ON_BN_CLICKED(IDC_RADIO7, OnMaxUI)
    ON_BN_CLICKED(IDC_RADIO9, OnDefaultUI)
    ON_EN_CHANGE(IDC_EDIT1, OnChangePath)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolDefs message handlers

BOOL CToolDefs::OnInitDialog()
{
    m_fAutoInstall = m_pToolDefaults->fAutoInstall;
    m_szStartPath = m_pToolDefaults->szStartPath;
    switch (m_pToolDefaults->NPBehavior)
    {
    case NP_DISABLED:
        m_iDeployment = 1;
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        break;
    case NP_PUBLISHED:
        m_iDeployment = 2;
        GetDlgItem(IDC_CHECK1)->EnableWindow(TRUE);
        break;
    case NP_ASSIGNED:
        m_iDeployment = 3;
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        break;
    case NP_PROPPAGE:
        m_iDeployment = 4;
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        break;
    case NP_WIZARD:
    default:
        m_iDeployment = 0;
        GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
        break;
    }

    switch (m_pToolDefaults->UILevel)
    {
    case INSTALLUILEVEL_FULL:
        m_iUI = 0;
        break;
    case INSTALLUILEVEL_BASIC:
        m_iUI = 1;
        break;
    case INSTALLUILEVEL_DEFAULT:
    default:
        m_iUI = 2;
        break;
    }

    CPropertyPage::OnInitDialog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CToolDefs::OnBrowse()
{
    // TODO: Add your control notification handler code here

}

void CToolDefs::OnUseWizard()
{
    GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    SetModified();
}

void CToolDefs::OnUsePropPage()
{
    GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    SetModified();
}

void CToolDefs::OnDeployDisabled()
{
    GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    m_fAutoInstall = FALSE;
    SetModified();
}

void CToolDefs::OnDeployPublished()
{
    GetDlgItem(IDC_CHECK1)->EnableWindow(TRUE);
    SetModified();
}

void CToolDefs::OnDeployAssigned()
{
    GetDlgItem(IDC_CHECK1)->EnableWindow(FALSE);
    m_fAutoInstall = TRUE;
    SetModified();
}

void CToolDefs::OnBasicUI()
{
    SetModified();
}

void CToolDefs::OnMaxUI()
{
    SetModified();
}

void CToolDefs::OnDefaultUI()
{
    SetModified();
}

BOOL CToolDefs::OnApply()
{
    m_pToolDefaults->fAutoInstall = m_fAutoInstall;
    m_pToolDefaults->szStartPath = m_szStartPath;
    switch (m_iDeployment)
    {
    case 1:
        m_pToolDefaults->NPBehavior = NP_DISABLED;
        break;
    case 2:
        m_pToolDefaults->NPBehavior = NP_PUBLISHED;
        break;
    case 3:
        m_pToolDefaults->NPBehavior = NP_ASSIGNED;
        break;
    case 4:
        m_pToolDefaults->NPBehavior = NP_PROPPAGE;
        break;
    case 0:
    default:
        m_pToolDefaults->NPBehavior = NP_WIZARD;
        break;
    }

    switch (m_iUI)
    {
    case 0:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_FULL;
        break;
    case 1:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_BASIC;
        break;
    case 2:
    default:
        m_pToolDefaults->UILevel = INSTALLUILEVEL_DEFAULT;
    }

    MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);

    return CPropertyPage::OnApply();
}


void CToolDefs::OnChangePath()
{
    SetModified();
}

LRESULT CToolDefs::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#ifdef DBG
//
// ATL's implementation of Release always returns 0 unless _DEBUG is
// defined. The debug version of OLE.DLL asserts Release() != 0 in certain
// circumstances.  I don't want to define _DEBUG because it brings in a
// whole lot of baggage from MMC that I don't want to deal with, but I do
// want to avoid this assertion in OLE, so on debug builds, I'll go ahead
// and define _DEBUG for the appropriate ATL header file but I'll undefine
// it again right afterward.  This is a little flakey but it is relatively
// safe and it achieves the desired goal.
//
// - SteveBl
//
#define _DEBUG
#endif
#include <atlcom.h>
#ifdef DBG
#undef _DEBUG
#endif

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

const long UNINITIALIZED = -1;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    long                m_cookie;   // What object the cookie represents
    CString             m_string;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\xforms.cpp ===
// Xforms.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXforms property page

IMPLEMENT_DYNCREATE(CXforms, CPropertyPage)

CXforms::CXforms() : CPropertyPage(CXforms::IDD)
{
        //{{AFX_DATA_INIT(CXforms)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}

CXforms::~CXforms()
{
        *m_ppThis = NULL;
}

void CXforms::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CXforms)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CXforms, CPropertyPage)
        //{{AFX_MSG_MAP(CXforms)
        ON_BN_CLICKED(IDC_BUTTON3, OnMoveUp)
        ON_BN_CLICKED(IDC_BUTTON4, OnMoveDown)
        ON_BN_CLICKED(IDC_BUTTON1, OnAdd)
        ON_BN_CLICKED(IDC_BUTTON2, OnRemove)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXforms message handlers

void CXforms::OnMoveUp()
{
        // TODO: Add your control notification handler code here

}

void CXforms::OnMoveDown()
{
        // TODO: Add your control notification handler code here

}

void CXforms::OnAdd()
{
        // TODO: Add your control notification handler code here

}

void CXforms::OnRemove()
{
        // TODO: Add your control notification handler code here

}

BOOL CXforms::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        // TODO: Add extra initialization here

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CXforms::OnApply()
{
        // TODO: Add your specialized code here and/or call the base class

        return CPropertyPage::OnApply();
}

LRESULT CXforms::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_USER_REFRESH:
        // UNDONE
        return 0;
    case WM_USER_CLOSE:
        return GetOwner()->SendMessage(WM_CLOSE);
    default:
        return CPropertyPage::WindowProc(message, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\snapin.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       snapin.cpp
//
//  Contents:   DLL support routines, class factory and registration
//              functions.
//
//  Classes:
//
//  Functions:
//
//  History:    2-12-1998   stevebl   comment header added
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "initguid.h"
#include "gpedit.h"

extern const CLSID CLSID_Snapin = {0xBACF5C8A,0xA3C7,0x11D1,{0xA7,0x60,0x00,0xC0,0x4F,0xB9,0x60,0x3F}};
extern const wchar_t * szCLSID_Snapin = L"{BACF5C8A-A3C7-11D1-A760-00C04FB9603F}";
extern const CLSID CLSID_MachineSnapin = {0x942A8E4F,0xA261,0x11D1,{0xA7,0x60,0x00,0xc0,0x4f,0xb9,0x60,0x3f}};
extern const wchar_t * szCLSID_MachineSnapin = L"{942A8E4F-A261-11D1-A760-00C04FB9603F}";

// Main NodeType GUID on numeric format
extern const GUID cNodeType = {0xF8B3A900,0X8EA5,0X11D0,{0X8D,0X3C,0X00,0XA0,0XC9,0X0D,0XCA,0XE7}};

// Main NodeType GUID on string format
extern const wchar_t*  cszNodeType = L"{F8B3A900-8EA5-11D0-8D3C-00A0C90DCAE7}";


#include "safereg.hxx"

#define BREAK_ON_FAIL_HRESULT(hr) if (FAILED(hr)) break

#define PSBUFFER_STR    L"AppManagementBuffer"
#define THREADING_STR   L"Apartment"

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Snapin, CUserComponentDataImpl)
        OBJECT_ENTRY(CLSID_MachineSnapin, CMachineComponentDataImpl)
END_OBJECT_MAP()

CLSID CLSID_Temp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSnapinApp theApp;

HINSTANCE ghInstance;

BOOL CSnapinApp::InitInstance()
{
        ghInstance = m_hInstance;
        _Module.Init(ObjectMap, m_hInstance);
        CoGetMalloc(1, &g_pIMalloc);
        return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

        g_pIMalloc->Release();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

const wchar_t * szUser_Namespace = L"{59849DF9-A256-11D1-A760-00C04FB9603}";
const wchar_t * szMachine_Namespace = L"{4D53F093-A260-11D1-A760-00C04FB9603F}";
const wchar_t * szMachineAppName = L"Application Deployment Editor (Computers)";
const wchar_t * szUserAppName = L"Application Deployment Editor (Users)";
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CSafeReg    shk;
    CSafeReg    shkCLSID;
    CSafeReg    shkServer;
    CSafeReg    shkTemp;
    HRESULT hr = S_OK;
    do
    {
        CLSID_Temp = CLSID_Snapin;
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);


        hr = shkCLSID.Create(szCLSID_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szUser_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();

        hr = shkCLSID.Create(szCLSID_MachineSnapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szMachine_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkServer.Close();
        shkTemp.Close();
        shk.Close();
        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szUser_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        hr = shkCLSID.Create(szMachine_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        WCHAR szGUID[50];
        StringFromGUID2 (NODEID_User, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szUserAppName,
                          sizeof(WCHAR) * (lstrlen(szUserAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();

        StringFromGUID2 (NODEID_Machine, szGUID, 50);

        hr = shkCLSID.Create(szGUID, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_MachineSnapin,
                          REG_SZ,
                          (CONST BYTE *) szMachineAppName,
                          sizeof(WCHAR) * (lstrlen(szMachineAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();


        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    CLSID_Temp = CLSID_Snapin;
    _Module.UnregisterServer();

    HKEY hkey;
    CString sz;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_Snapin));
    RegCloseKey(hkey);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szUser_Namespace));
    RegCloseKey(hkey);
    WCHAR szGUID[50];
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_User, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    RegDeleteValue(hkey, szCLSID_Snapin);
    RegCloseKey(hkey);

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(hkey, (LPOLESTR)((LPCOLESTR)szCLSID_MachineSnapin));
    RegCloseKey(hkey);
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes\\", 0, KEY_WRITE, &hkey);
    RegDeleteTree(HKEY_LOCAL_MACHINE, (LPOLESTR)((LPCOLESTR)szMachine_Namespace));
    RegCloseKey(hkey);
    sz = L"Software\\Microsoft\\MMC\\NodeTypes\\";
    StringFromGUID2 (NODEID_Machine, szGUID, 50);
    sz += szGUID;
    sz += L"\\Extensions\\NameSpace";
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_WRITE, &hkey);
    RegDeleteValue(hkey, szCLSID_MachineSnapin);
    RegCloseKey(hkey);

    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//              5-09-1997   SteveBl    Modified for use with AppMgr
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\upgrades.h ===
#if !defined(AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
#define AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Upgrades.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CUpgrades dialog

class CUpgrades : public CDialog
{
// Construction
public:
        CUpgrades(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CUpgrades)
        enum { IDD = IDD_UPGRADE };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA

        // m_UpgradeList: entry for the cookie of each thing to be upgraded
        //                BOOL is true if Uninstall is requred.
        std::map<long, BOOL> m_UpgradeList;

        // m_NameIndex: maps names to cookies
        std::map<CString, long> m_NameIndex;

        std::map<long, APP_DATA> * m_pAppData;

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CUpgrades)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CUpgrades)
        afx_msg void OnAdd();
        afx_msg void OnEdit();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_UPGRADES_H__7D8EB947_9E76_11D1_9854_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\admin\ui\xforms.h ===
#if !defined(AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_)
#define AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Xforms.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CXforms dialog

class CXforms : public CPropertyPage
{
        DECLARE_DYNCREATE(CXforms)

// Construction
public:
        CXforms();
        ~CXforms();

        CXforms ** m_ppThis;

// Dialog Data
        //{{AFX_DATA(CXforms)
        enum { IDD = IDD_MODIFICATIONS };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA
        APP_DATA *      m_pData;
        IClassAdmin *   m_pIClassAdmin;
        IStream *       m_pIStream;
        long            m_hConsoleHandle;
        DWORD           m_cookie;


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CXforms)
	public:
        virtual BOOL OnApply();
	protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CXforms)
        afx_msg void OnMoveUp();
        afx_msg void OnMoveDown();
        afx_msg void OnAdd();
        afx_msg void OnRemove();
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XFORMS_H__7AC6D087_9383_11D1_984E_00C04FB9603F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\catreg.cxx ===
//
//  Author: ushaji
//  Date:   December/Jan 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for ICatRegister interfaces.
//
//      Refer Doc "Design for Support of File Types and Component Categories
//    in Class Store" ? (or may be Class Store Schema)
//
//----------------------------------------------------------------------------

#include "cstore.hxx"

//-------------------------------------------------------------
// RegisterCategories:
//        registering categories in the class store.
//        cCategories:        Number of Categories
//        rgCategoryInfo:        Size cCategories
//
// Returns as soon as one of them fails.
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CClassContainer::RegisterCategories(/* [in] */ ULONG cCategories,
                                    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ])
{
    /* Registering a list of Category ID in the Class Store */
    
    HRESULT           hr = S_OK;
    HANDLE            hADs = NULL;
    STRINGGUID        szCatid;
    ULONG             i, j, cdesc = 0, posn, cAttr = 0, cgot = 0;
    LPOLESTR         *pszDescExisting = NULL, pszDesc = NULL;
    WCHAR             localedescription[128+16];
    // sizeof description + seperator length + locale in hex
    WCHAR            *szFullName = NULL, szRDN[_MAX_PATH];
    LPOLESTR          AttrName = {LOCALEDESCRIPTION};
    ADS_ATTR_INFO    *pAttrGot = NULL, pAttr[6];
    BOOL              fExists = TRUE;
    
    if (!IsValidReadPtrIn(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }
    
    if (!IsValidReadPtrIn(rgCategoryInfo, sizeof(rgCategoryInfo[0])*cCategories))
    {
        return E_INVALIDARG; // gd
    }
    
    if (!m_fOpen)
        return E_FAIL;
    
    for (i = 0; i < cCategories; i++)
    {
        wsprintf(localedescription, L"%x %s %s", rgCategoryInfo[i].lcid, CAT_DESC_DELIMITER,
            rgCategoryInfo[i].szDescription);
        
        RDNFromGUID(rgCategoryInfo[i].catid, szRDN);
        
        BuildADsPathFromParent(m_szCategoryName, szRDN, &szFullName);
        
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
            &hADs);
        
        if (SUCCEEDED(hr))
        {
            hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttrGot, &cgot);
            fExists = TRUE;
        }
        else {
            fExists = FALSE;
            PackStrToAttr(pAttr, OBJECTCLASS, CLASS_CS_CATEGORY); 
            cAttr++;

            PackGUIDToAttr(pAttr+cAttr, CATEGORYCATID, &(rgCategoryInfo[i].catid));
            cAttr++;

            hr = ADSICreateDSObject(m_ADsCategoryContainer, szRDN, pAttr, cAttr);

            for (j = 0; j < cAttr; j++)
                FreeAttr(pAttr[j]);
            cAttr = 0;

            hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                                    &hADs);
        }
        
        ERROR_ON_FAILURE(hr);

        if (fExists)
        {
            if (cgot)
                UnpackStrArrFrom(pAttrGot[0], &pszDescExisting, &cdesc);
            
            // Existing list of descriptions
                        
            if (posn = FindDescription(pszDescExisting, cdesc, &(rgCategoryInfo[i].lcid), NULL, 0))
            {   // Delete the old value
                PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, pszDescExisting+(posn-1), 1, FALSE); cAttr++;
            }
			CoTaskMemFree(pszDescExisting);
        }
        
        
        pszDesc = localedescription;

        PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, &pszDesc, 1, TRUE);
        cAttr++;
        
        DWORD cModified = 0;

        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);        

        CSDBGPrint((L"After Set, hr = 0x%x", hr));

        if (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS))
            hr = S_OK;


        ERROR_ON_FAILURE(hr);

        for (j = 0; j < cAttr; j++)
            FreeAttr(pAttr[j]);
        cAttr = 0;
                
        if (pAttrGot)
            FreeADsMem(pAttrGot);
        
        pAttrGot = NULL;
        
        if (szFullName)
            FreeADsMem(szFullName);
        
        szFullName = NULL;
        
        if (hADs)
            ADSICloseDSObject(hADs);
        
        hADs = NULL;
    }

Error_Cleanup:
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    if (szFullName)
        FreeADsMem(szFullName);
    
    if (hADs)
        ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);
} /* RegisterCategories */


//--------------------------------------------------------
// Unregistering categories from the class store
//        cCategories:        Number of Categories
//        rgcatid:            catids of the categories.
//
// Stops after any one of them returns a error.
// Doesn't remove the category ids from each of the class ids.

HRESULT STDMETHODCALLTYPE 
CClassContainer::UnRegisterCategories(/* [in] */ ULONG cCategories,
                                      /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    STRINGGUIDRDN   szRDN;
    ULONG           i;
    HRESULT         hr = S_OK;
    
    
    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }
    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)) {
        return E_INVALIDARG;
    }
    // Checking whether the caller has permissions
    
    if (!m_fOpen)
        return E_FAIL;
    
    for (i = 0; i < cCategories; i++)
    {
        RDNFromGUID(rgcatid[i], szRDN);
        hr = ADSIDeleteDSObject(m_ADsCategoryContainer, szRDN);
    }
    return S_OK;
} /* UnRegisterCategories */

//------------------------------------------------------------------
// RegisterClassXXXCategories:
//        rclsid:            This category will be registered with this clsid.
//        cCategories:    The number of categories to be added.
//        rgcatid            The categories to be added (cCategories)
//        impl_or_req        The property to which this category will be added.
//                            "Implemented Categories" or "Required Categories"
//
//
// add all the categories given to the class store for this class.
// The previous entries will be lost and on error it would not be
// restored or made empty. A PRIVATE METHOD called by the 2 public methods.
//------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CClassContainer::RegisterClassXXXCategories(/* [in] */ REFCLSID                      rclsid,
                                            /* [in] */ ULONG                         cCategories,
                                            /* [size_is][in] */ CATID __RPC_FAR      rgcatid[  ],
                                                       BSTR                          impl_or_req)
{
    HRESULT       hr = S_OK;
    STRINGGUIDRDN szRDN;
    HANDLE        hADs = NULL;
    ULONG         i, j;
    STRINGGUID    szGUID;
    ADS_ATTR_INFO pAttr[4];
    DWORD         cAttr = 0;
    WCHAR        *szFullName = NULL;
    
    if (!m_fOpen)
        return E_FAIL;
    
    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }
    
    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)) {
        return E_INVALIDARG; // gd
    }
    
    if (IsNullGuid(rclsid))
        return E_INVALIDARG;
    
    // Get the ADs interface corresponding to the clsid that is mentioned.
    StringFromGUID(rclsid, szGUID);
    wsprintf(szRDN, L"CN=%s", szGUID);
    
    BuildADsPathFromParent(m_szClassName, szRDN, &szFullName);
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADs);
            
    // if it didn't exist create it.
    if (FAILED(hr)) {
        
        PackStrToAttr(pAttr+cAttr, OBJECTCLASS, CLASS_CS_CLASS);
        cAttr++;
        
        PackStrToAttr(pAttr+cAttr, CLASSCLSID, szGUID);
        cAttr++;

        hr = ADSICreateDSObject(m_ADsClassContainer, szRDN, pAttr, cAttr);
        for (i = 0; i < cAttr; i++)
            FreeAttr(pAttr[i]);

        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                &hADs);

        ERROR_ON_FAILURE(hr);
    }

    for (i = 0; i < cCategories; i++)
    {
        DWORD cModified=0;

        PackGUIDArrToAttrEx(pAttr, impl_or_req, rgcatid+i, 1, TRUE);
        hr = ADSISetObjectAttributes(hADs, pAttr, 1, &cModified);
        FreeAttr(pAttr[0]);

        if (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS))  // we are not supposed to return error
            hr = S_OK;                                   // if the category already exists.

        ERROR_ON_FAILURE(hr);
    }
    
    
Error_Cleanup:    
    if (szFullName)
        FreeADsMem(szFullName);
        
    if (hADs)
        ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);
} /* RegisterClassXXXCategories */


//---------------------------------------------------------------------
// UnRegisterClassXXXCategories
//        rclsid:            classid from which the categories have to be removed.
//        cCategories:    Number of Categories
//        rgcatid:        Categories
//        impl_or_req:    The property to which this has to be added.
//
// Presently gets all the categories from the class. parses through it
// removes the ones that match in rgcatid and reregister the category.
//---------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CClassContainer::UnRegisterClassXXXCategories(/* [in] */ REFCLSID rclsid,
                                              /* [in] */ ULONG    cCategories,
                                              /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ],
                                              BSTR     impl_or_req)
{
    HRESULT         hr = S_OK;
    STRINGGUIDRDN   szRDN;
    HANDLE          hADs = NULL;
    ULONG           i, j, cModified = 0;
    WCHAR          *szFullName=NULL;
    ADS_ATTR_INFO   pAttr[1];   
    
    // BUGBUG:: Have to decide some way of removing clsids once all categories
    //          are unregistered.
    
    if (!m_fOpen)
        return E_FAIL;
    
    if (IsNullGuid(rclsid))
        return E_INVALIDARG;
    
    if (cCategories == 0)
        return S_OK;
    
    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }
    
    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG; // gd
    }
    
    if (cCategories == 0)
        return S_OK;
    
    // Get all the catids corresp to this clsid.
    // Get the ADs interface corresponding to the clsid that is mentioned.
    RDNFromGUID(rclsid, szRDN);
    BuildADsPathFromParent(m_szClassName, szRDN, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            &hADs);
    CSDBGPrint((L"After Open in unRegXXX returned 0x%x", hr));
    ERROR_ON_FAILURE(hr);
        
    // reregister this.
    
    for (i = 0; i < cCategories; i++) {
        PackGUIDArrToAttrEx(pAttr, impl_or_req, rgcatid+i, 1, FALSE);

        hr = ADSISetObjectAttributes(hADs, pAttr, 1, &cModified);
        FreeAttr(pAttr[0]);

        // we do not want to return error if the catids are not actually present.
        
        if ((hr == E_ADS_PROPERTY_NOT_SET) || (hr == E_ADS_PROPERTY_NOT_FOUND) ||
            (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE)))
            hr = S_OK;

        CSDBGPrint((L"After SetObjAtt in UnRegXXX returned 0x%x", hr));
        ERROR_ON_FAILURE(hr);
    }
    
Error_Cleanup:

    if (szFullName)
        FreeADsMem(szFullName);
        
    if (hADs)
        ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);

} /* UnRegisterClassXXXCategories */



HRESULT STDMETHODCALLTYPE 
CClassContainer::RegisterClassImplCategories(/* [in] */ REFCLSID rclsid,
                                             /* [in] */ ULONG cCategories,
                                             /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid,
        IMPL_CATEGORIES);
} /* RegisterClassImplCategories */


HRESULT STDMETHODCALLTYPE 
CClassContainer::UnRegisterClassImplCategories(/* [in] */ REFCLSID rclsid,
                                               /* [in] */ ULONG cCategories,
                                               /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid,
        IMPL_CATEGORIES);
    
} /* UnRegisterClassImplCategories */




HRESULT STDMETHODCALLTYPE 
CClassContainer::RegisterClassReqCategories(/* [in] */ REFCLSID rclsid,
                                            /* [in] */ ULONG cCategories,
                                            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid,
        REQ_CATEGORIES);
    
} /* RegisterClassReqCategories */




HRESULT STDMETHODCALLTYPE 
CClassContainer::UnRegisterClassReqCategories(/* [in] */ REFCLSID rclsid,
                                              /* [in] */ ULONG cCategories,
                                              /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid,
        REQ_CATEGORIES);
    
} /* UnRegisterClassReqCategories */



//--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\cclsto.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclsto.cxx
//
//  Contents:    Class Factory and IUnknown methods for CAppContainer
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//
// Constructor for App Container Class factory
//
unsigned long gulcappcon = 0;

extern      CRITICAL_SECTION    ClassStoreBindList;
ClassStoreCacheType ClassStoreCache;

CAppContainerCF::CAppContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcappcon );

    ClassStoreCache.sz = 0;
    ClassStoreCache.start = 0;
    ClassStoreCache.end = 0;
}


void ReleaseBindings(BindingsType *pbd)
{
    CSDBGPrint((L"Cleaning up entry in Cache. %s", pbd->szStorePath));
    if (pbd->pIClassAccess)
    {
        (pbd->pIClassAccess)->Release();
    }
    CoTaskMemFree(pbd->Sid);
    CoTaskMemFree(pbd->szStorePath);
}

//
// Destructor
//
CAppContainerCF::~CAppContainerCF()
{
    //
    // Cleanup the cache
    //
    for (UINT i=ClassStoreCache.start; i  != ClassStoreCache.end; 
                        i = (i+1)%(MAXCLASSSTORES))
    {
        ReleaseBindings(ClassStoreCache.Bindings+i);
    }
    
    InterlockedDecrement((long *) &gulcappcon );
}

HRESULT  __stdcall  CAppContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
        {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//
// IClassFactory Overide
//
HRESULT  __stdcall  CAppContainerCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid, 
                                                                    void  ** ppvObject)
{
    CAppContainer *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CAppContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
             pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//---------------------------------------------------------------
//
//  Function:   CreateConnectedInstance
//
//  Synopsis:   Returns IClassAccess Pointer, given a class store 
//              path.
//
//  Arguments:
//  [in]    
//      pszPath Class Store Path without the leading ADCS:
//           
//      pUserSid     
//              Sid under which the calling thread is running.
//      fCache
//              Boolean that decides whether to use a cached pointer or 
//              not.
//  [out]
//      ppvObject     
//              IClassAccess Interface pointer 
//   
//  Returns:
//      S_OK, E_NOINTERFACE, E_OUTOFMEMORY, CS_E_XXX
//
//  if (fCache)
//      Looks in the cache to see if we have already tried to bind to the same
//      ClassStore Path under the same SID. If it finds it, then we just QI for
//      IClassAccess and return. o/w create a new class store pointer and caches it.  
//  else
//      Just binds to a new ClassStore and returns.
//----------------------------------------------------------------
HRESULT  __stdcall  
CAppContainerCF::CreateConnectedInstance(LPOLESTR pszPath, PSID pUserSid,
                                         BOOL fCache,  void ** ppvObject)
{
    CAppContainer   *   pIUnk = NULL;
    SCODE               sc = S_OK;
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;

    if (fCache)
    {
        //
        // Look in cache
        //
        EnterCriticalSection (&ClassStoreBindList);
        for (UINT i=ClassStoreCache.start; i  != ClassStoreCache.end; 
                        i = (i+1)%(MAXCLASSSTORES))
        {
            // compare cached sids and Class Store path
            if ((wcscmp(pszPath, ClassStoreCache.Bindings[i].szStorePath) == 0) &&
                (EqualSid(pUserSid, ClassStoreCache.Bindings[i].Sid)))
            {
                //
                // Found in cache
                //
                CSDBGPrint((L"Found %s in Cache.", pszPath));
                fFound = TRUE;
                if (ClassStoreCache.Bindings[i].pIClassAccess)
                {
                    sc = (ClassStoreCache.Bindings[i].pIClassAccess)->
                                    QueryInterface( IID_IClassAccess, ppvObject );
                }
                else
                {
                    sc = ClassStoreCache.Bindings[i].Hr;
                    // return the same error code.
                }
                break;
            }
        }
        
        LeaveCriticalSection (&ClassStoreBindList);

        if (fFound)
            return sc;
    }

    if ((pIUnk = new CAppContainer(pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAccess, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        else
            CSDBGPrint((L"Connect to Store Failed. hr = 0x%x", sc));

            pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;

    //
    // Store the result in the cache 
    //
    if (fCache)
    {
        //
        // Should not cache situations out of network failures
        // BUGBUG: For now we are only caching successes OR CS does not exist cases
        //
        if ((sc == S_OK) || (sc == CS_E_OBJECT_NOTFOUND))
        {
            EnterCriticalSection (&ClassStoreBindList);

            for (UINT i=ClassStoreCache.start; i  != ClassStoreCache.end; 
                        i = (i+1)%(MAXCLASSSTORES))
            {
                if ((wcscmp(pszPath, ClassStoreCache.Bindings[i].szStorePath) == 0) &&
                    (EqualSid(pUserSid, ClassStoreCache.Bindings[i].Sid)))
                {
                    //
                    // Found in cache after bind attempt
                    //
                    CSDBGPrint((L"Found in Cache after binding !!!."));

                    //
                    // If we already got an existing object, release the one we grabbed 
                    // above
                    //
                    if (*ppvObject) {

                        ((IClassAccess *)(*ppvObject))->Release();
                        *ppvObject = NULL;

                    } else {
                        ASSERT(CS_E_OBJECT_NOTFOUND == sc);
                    }

                    //
                    // Now we can get the object from the cache to satisfy
                    // the caller's request
                    //
                    if (ClassStoreCache.Bindings[i].pIClassAccess)
                    {
                        sc = (ClassStoreCache.Bindings[i].pIClassAccess)->
                            QueryInterface( IID_IClassAccess, ppvObject );
                    }
                    else
                    {
                        sc = ClassStoreCache.Bindings[i].Hr;
                        // return the same error code. 
                    }
                    
                }
            }

            if (i == ClassStoreCache.end)
            {                       
                if (ClassStoreCache.sz == (MAXCLASSSTORES-1)) 
                {
                    ReleaseBindings(ClassStoreCache.Bindings+ClassStoreCache.start);
                    ClassStoreCache.start = (ClassStoreCache.start+1)%MAXCLASSSTORES;
                    ClassStoreCache.sz--;
                }

                // allocate space for the guid and the Class store path.
                ClassStoreCache.Bindings[i].szStorePath = 
                    (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (wcslen (pszPath) + 1));
                
                
                UINT dwBytesRequired = GetLengthSid(pUserSid);
                ClassStoreCache.Bindings[i].Sid = CoTaskMemAlloc(dwBytesRequired);
                
                // if memory was allocated.
                if ((ClassStoreCache.Bindings[i].szStorePath) && 
                    (ClassStoreCache.Bindings[i].Sid))
                {
                    // copy the class store path.
                    wcscpy (ClassStoreCache.Bindings[i].szStorePath, pszPath);
                    
                    ClassStoreCache.Bindings[i].pIClassAccess = NULL;
                    
                    // get the IClassAccess pointer and cache it.
                    if (sc == S_OK)
                    {
                        ((IClassAccess *)(*ppvObject))->QueryInterface( IID_IClassAccess, 
                            (void **)&ClassStoreCache.Bindings[i].pIClassAccess);
                    }
                    
                    ClassStoreCache.Bindings[i].Hr = sc;
                    
                    // copy the SIDs
                    CopySid(dwBytesRequired, ClassStoreCache.Bindings[i].Sid, pUserSid);
                    
                    ClassStoreCache.sz++;
                    ClassStoreCache.end = (ClassStoreCache.end + 1)% MAXCLASSSTORES;
                }
            }
            LeaveCriticalSection (&ClassStoreBindList);
        }
    }

    return (sc);
}


HRESULT  __stdcall  CAppContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcappcon ); }
    else
    { InterlockedDecrement((long *) &gulcappcon ); }
    return(S_OK);
}

//
// IUnknown methods for CAppContainer
//
//

HRESULT  __stdcall  CAppContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
     else  if( IsEqualIID( IID_IClassAccess, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    /*
    else  if( IsEqualIID( IID_IClassRefresh, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassRefresh *)this;
    }
    else  if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    */
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\cclsacc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclsacc.cxx
//
//  Contents:    Class factory and IUnknown methods for CClassAccess
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


HRESULT  __stdcall  CClassAccess::QueryInterface(REFIID riid, void  * * ppvObject)
    
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    else  if( IsEqualIID( IID_IClassAccess, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    /*
    else  if( IsEqualIID( IID_IClassRefresh, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassRefresh *)this;
    }
    */
    else   
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);

}

ULONG __stdcall  CClassAccess::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccess::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


//
// Constructor 
//
unsigned long gulcClassFactory = 0;

CClassAccessCF::CClassAccessCF() 
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcClassFactory );
}

//
// Destructor 
//
CClassAccessCF::~CClassAccessCF()
{
    InterlockedDecrement((long *) &gulcClassFactory );
}

HRESULT  __stdcall  CClassAccessCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else   
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassAccessCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccessCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}

//
// IClassFactory Overide
//
HRESULT  __stdcall  CClassAccessCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void  * * ppvObject)
{
    CClassAccess *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassAccess()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}

HRESULT  __stdcall  CClassAccessCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcClassFactory ); }
    else
    { InterlockedDecrement((long *) &gulcClassFactory ); }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\catinfo.cxx ===
//
//  Author: ushaji
//  Date:   December 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for ICatInformation interfaces.                             
//
//      Refer Doc "Design for Support of File Types and Component Categories
//      in Class Store" ? (or may be Class Store Schema)
//


#include "cstore.hxx"

//---------------------------------------------------------------
// EnumCategories:
//      returns the enumerator to enumerate categories.
//        lcid:                    locale id.
//        ppenumcategoryinfo:        Enumerator that is returned.
//
// ppEnumCategoryInfo value is undefined if an error occurs
//---------------------------------------------------------------

HRESULT __stdcall CClassContainer::EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo)
{
    HRESULT                 hr = S_OK;
    CSCEnumCategories      *pEnum = NULL;
    
    if (!m_fOpen)
        return E_FAIL;
    
    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;
    
    if (!IsValidPtrOut(ppenumCategoryInfo, sizeof(IEnumCATEGORYINFO *)))
        return E_INVALIDARG;
    
    *ppenumCategoryInfo=NULL;
    
    // get the enumerator object.
    pEnum=new CSCEnumCategories;
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    // initialize the enumerator object with the name.
    hr = pEnum->Initialize(m_szCategoryName, lcid);
    ERROR_ON_FAILURE(hr);
    
    hr = pEnum->QueryInterface(IID_IEnumCATEGORYINFO, (void**)ppenumCategoryInfo);
    ERROR_ON_FAILURE(hr);

    return S_OK;
Error_Cleanup:
    if (pEnum)
        delete pEnum;
    
    return RemapErrorCode(hr, m_szContainerName);
} /* EnumCategories */

//---------------------------------------------------------------
// GetCategoryDesc:
//        returns the description of a given category.
//        rcatid:         category id.
//        lcid:           locale id.
//        ppszDesc        pointer to the description string to be returned.
//                        Allocated by the function. to be freed by client.
//--------------------------------------------------------------------------
HRESULT __stdcall CClassContainer::GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc)
{
    STRINGGUIDRDN       szRDN;
    ULONG               cdesc = 0, i, cgot = 0;
    LPOLESTR          * localedesc = NULL;
    HANDLE              hADs = NULL;
    HRESULT             hr = S_OK;
    WCHAR             * szFullName = NULL;
    LPOLESTR            AttrName = LOCALEDESCRIPTION;
    ADS_ATTR_INFO     * pAttr = NULL;
    
    if (!IsValidPtrOut(ppszDesc, sizeof(LPOLESTR)))
        return E_INVALIDARG;
    
    if (IsNullGuid(rcatid))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;
    
    RDNFromGUID(rcatid, szRDN);
    
    BuildADsPathFromParent(m_szCategoryName, szRDN, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADs);
    
    if (FAILED(hr))
        return CAT_E_CATIDNOEXIST;
    
    // get the array of localized descriptions
    hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttr, &cgot);
    
    if (FAILED(hr) || (!cgot))
        return CAT_E_NODESCRIPTION;
    
    hr = UnpackStrArrFrom(pAttr[0], &localedesc, &cdesc);
    
    if (hr == E_OUTOFMEMORY)
        return hr;
    
    *ppszDesc = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR)*128);
    if (!(*ppszDesc))
        return E_OUTOFMEMORY;
    
    // get a description closest to the locale we need.
    GetCategoryLocaleDesc(localedesc, cdesc, &lcid, *ppszDesc);
    
    CoTaskMemFree(localedesc);
    
    ADSICloseDSObject(hADs);
    
    FreeADsMem(pAttr);
    
    FreeADsMem(szFullName);
    
    return S_OK;
    
} /* GetCategoryDesc */


//---------------------------------------------------------------
// EnumClassesOfCategories:
//        returns the enumerator for classes that implements given catids and
//                requires some given catids.
//
//        cImplemented    number of implemented categories.
//                        (0 is error and -1 is ignore implemented.
//        rgcatidImpl        list of implemented categories.
//                        should be NULL in the two cases mentioned above.
//
//        cRequired:        number of required categories.
//                        (0 is requiring nothing and -1 is ignore required.
//        rgcatidReq        list of required categories.
//                        should be NULL in the two cases mentioned above.
//
//        ppenumClsid        the enumerator of class ids.
//--------------------------------------------------------------------------

HRESULT __stdcall CClassContainer::EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[],
                                                           ULONG cRequired, CATID rgcatidReq[],
                                                           IEnumGUID **ppenumClsid)
{
    ULONG                          i;
    CSCEnumClassesOfCategories    *penumclasses = NULL;
    HRESULT                        hr = S_OK;
    
    if (!IsValidPtrOut(ppenumClsid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;
    
    if ((rgcatidImpl == NULL) && (cImplemented != 0) && (cImplemented != -1))
        return E_INVALIDARG;
    
    if ((rgcatidReq == NULL) && (cRequired != 0) && (cRequired != -1))
        return E_INVALIDARG;
    
    if ((cImplemented == -1) && (rgcatidImpl != NULL))
        return E_POINTER;
    
    if ((cRequired == -1) && (rgcatidReq != NULL))
        return E_POINTER;
    
    if (cImplemented == 0)
        return E_INVALIDARG;
    
    if ((rgcatidImpl) && (!IsValidReadPtrIn(rgcatidImpl, sizeof(CATID)*cImplemented)))
    {
        return E_INVALIDARG;
    }
    
    if ((rgcatidReq) && (!IsValidReadPtrIn(rgcatidReq, sizeof(CATID)*cRequired)))
    {
        return E_INVALIDARG;
    }
    
    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;
    
    penumclasses = new CSCEnumClassesOfCategories;
    if (!penumclasses)
    {
        return E_OUTOFMEMORY;
    }
    
    // initialize the enumerator
    hr = penumclasses->Initialize(cRequired, rgcatidReq, cImplemented, rgcatidImpl,
        m_szClassName);
    ERROR_ON_FAILURE(hr);
    
    hr = penumclasses->QueryInterface(IID_IEnumCLSID, (void **)ppenumClsid);
    ERROR_ON_FAILURE(hr);

    return S_OK;

Error_Cleanup:
    if (penumclasses)
        delete penumclasses;
    
    return RemapErrorCode(hr, m_szContainerName);
} /* EnumClassesOfCategories */

//---------------------------------------------------------------
// EnumReqCategoriesOfClass:
//        see below EnumCategoriesofClass
//
//---------------------------------------------------------------

HRESULT CClassContainer::EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)

{
    if (!IsValidReadPtrIn(this, sizeof(*this)))
        return E_ACCESSDENIED;
    
    if (IsNullGuid(rclsid))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(ppenumCatid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;
    
    return EnumCategoriesOfClass(rclsid, REQ_CATEGORIES, ppenumCatid);
    
} /* EnumReqClassesOfCategories */

//---------------------------------------------------------------
// EnumImplCategoriesOfClass:
//        see below EnumCategoriesofClass
//
//---------------------------------------------------------------
HRESULT CClassContainer::EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
    if (!IsValidReadPtrIn(this, sizeof(*this)))
        return E_ACCESSDENIED;
    
    if (IsNullGuid(rclsid))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(ppenumCatid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;
    
    return EnumCategoriesOfClass(rclsid, IMPL_CATEGORIES, ppenumCatid);
    
} /* EnumimplClassesOfCategories */

//---------------------------------------------------------------
// EnumCategoriesOfClass:
//        returns the enumerator for the implemented or required
//    rclsid:            the class id.
//    impl_or_req        the type of category to enumerated.
//    ppenumcatid        the enumerator that is returned.
// Prefetches all the catids and then enumerates them.
//---------------------------------------------------------------

HRESULT CClassContainer::EnumCategoriesOfClass(REFCLSID rclsid, BSTR impl_or_req,
                                               IEnumGUID **ppenumCatid)
{
    STRINGGUIDRDN                szRDN;
    HANDLE                       hADs = NULL;
    ULONG                        i;
    ULONG                        cCatid = 0, cgot = 0;
    CATID                      * Catid = NULL;
    CSCEnumCategoriesOfClass   * pEnumCatid = NULL;
    HRESULT                      hr = S_OK;
    WCHAR                      * szFullName = NULL;
    ADS_ATTR_INFO              * pAttr = NULL;
    
    if (!m_fOpen)
        return E_FAIL;
    
    // Get the ADs interface corresponding to the clsid that is mentioned.
    RDNFromGUID(rclsid, szRDN);
    
    BuildADsPathFromParent(m_szClassName, szRDN, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADs);
    RETURN_ON_FAILURE(hr);
    
    // get the implemented or required cateogory list.
    hr = ADSIGetObjectAttributes(hADs, &impl_or_req, 1, &pAttr, &cgot);
    ERROR_ON_FAILURE(hr);
    
    if (cgot)
        hr = UnpackGUIDArrFrom(pAttr[0], &Catid, &cCatid);
    
    pEnumCatid = new CSCEnumCategoriesOfClass;
    
    if (!pEnumCatid)
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }
    
    // initialize the enumerator
    hr = pEnumCatid->Initialize(Catid, cCatid);
    ERROR_ON_FAILURE(hr);
    
    hr =  pEnumCatid->QueryInterface(IID_IEnumCATID, (void **)ppenumCatid);
    
Error_Cleanup:
    if (Catid)
        CoTaskMemFree(Catid);
    
    if (FAILED(hr)) {
        delete pEnumCatid;
        return hr;
    }
    
    if (szFullName)
        FreeADsMem(szFullName);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (hADs)
        ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);

}
//---------------------------------------------------------------
// IsClassOfCategories:
//    similar to EnumClassesOfCategories but returns S_OK/S_FALSE for the
//    clsid rclsid. Finds the first class that implements these categories
//    and is of this clsid and checks its required.
//---------------------------------------------------------------

HRESULT __stdcall CClassContainer::IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented,
                                                       CATID __RPC_FAR rgcatidImpl[  ],
                                                       ULONG cRequired, CATID __RPC_FAR rgcatidReq[ ])
{
    HRESULT             hr = S_OK;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    WCHAR               szfilter[_MAX_PATH];
    LPOLESTR            AttrNames[] = {IMPL_CATEGORIES, REQ_CATEGORIES, L"cn"};
    DWORD               cAttr = 3;
    STRINGGUID          szClsid;
    
    if (IsNullGuid(rclsid))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;
    
    if (cImplemented == 0)
        return E_INVALIDARG;
    
    if ((rgcatidImpl == NULL) && (cImplemented != 0) && (cImplemented != -1))
        return E_INVALIDARG;
    
    if ((rgcatidReq == NULL) && (cRequired != 0) && (cRequired != -1))
        return E_INVALIDARG;
    
    if ((cImplemented == -1) && (rgcatidImpl != NULL))
        return E_POINTER;
    
    if ((cRequired == -1) && (rgcatidReq != NULL))
        return E_POINTER;
    
    if ((rgcatidImpl) && (!IsValidReadPtrIn(rgcatidImpl, sizeof(CATID)*cImplemented)))
    {
        return E_INVALIDARG;
    }
    
    if ((rgcatidReq) && (!IsValidReadPtrIn(rgcatidReq, sizeof(CATID)*cRequired)))
    {
        return E_INVALIDARG;
    }
    
    StringFromGUID(rclsid, szClsid);
    
    wsprintf(szfilter, L"(cn=%s)", szClsid);
    
    // doing a search so that we can pass the same parameters to the
    // xxxSatisfied functions below.
    hr = ADSIExecuteSearch(m_ADsClassContainer, szfilter, AttrNames, cAttr, &hADsSearchHandle);
    RETURN_ON_FAILURE(hr);
    
    hr = ADSIGetFirstRow(m_ADsClassContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        ERROR_ON_FAILURE(hr);
    }
    
    hr = ImplSatisfied(cImplemented, rgcatidImpl, m_ADsClassContainer, hADsSearchHandle);
    ERROR_ON_FAILURE(hr);
    
    if (hr == S_OK)
    {
        hr = ReqSatisfied(cRequired, rgcatidReq, m_ADsClassContainer, hADsSearchHandle);
        ERROR_ON_FAILURE(hr);
    }
    
    if (hr != S_OK)
        hr =  S_FALSE;
    
Error_Cleanup:
    ADSICloseSearchHandle(m_ADsClassContainer, hADsSearchHandle);
    return hr;
    
} /* IsClassOfCategories */


//--------------------------------------------------------------------------------
//    ReqSatisfied:
//        Returns S_OK/S_FALSE depending on whether the clsid satisfies the required
//        condition for the clsid.
//    clsid:                Class ID of the class.
//    cAvailReq:            Number of Available required classes.
//    AvailReq:            Avail required classes.
//    calls the enumerator and sees whether there is any required class not present in
//    the available list. returns S_OK if cAvailReq = -1.
//--------------------------------------------------------------------------------

HRESULT ReqSatisfied(ULONG cAvailReq, CATID *AvailReq,
                     HANDLE hADs,
                     ADS_SEARCH_HANDLE hADsSearchHandle)
{
    HRESULT             hr = S_OK;
    ADS_SEARCH_COLUMN   column;
    GUID              * ReqGuid = NULL;
    DWORD               i, j, cReq = 0;
    
    if (cAvailReq == -1)
        return S_OK;
    
    hr = ADSIGetColumn(hADs, hADsSearchHandle, REQ_CATEGORIES, &column);
    if (FAILED(hr))
        return S_OK;
    
    hr = S_OK;
    
    UnpackGUIDArrFrom(column, &ReqGuid, &cReq);
    
    for (j = 0; j < cReq; j++) {
        /// check if the required categories are available
        for (i = 0; i < cAvailReq; i++)
            if (IsEqualGUID(ReqGuid[j], AvailReq[i]))
                break;
            if (i == cAvailReq) {
                hr = S_FALSE;
                break;
            }
    }
    
    CoTaskMemFree(ReqGuid);
    
    ADSIFreeColumn(hADs, &column);
    
    return hr;
}

//--------------------------------------------------------------------------------
//    Implements:
//        Returns S_OK/S_FALSE depending on whether the clsid satisfies the required
//        condition for the clsid.
//    clsid:                Class ID of the class.
//    cImplemented:         Number of Implemented categories.
//    ImplementedList:      Implemented Categories.
//    calls the enumerator and sees whether there is any required class not present in
//    the available list. returns S_OK if cImplemented = -1.
//--------------------------------------------------------------------------------

HRESULT ImplSatisfied(ULONG cImplemented, CATID *ImplementedList,
                      HANDLE hADs,
                      ADS_SEARCH_HANDLE hADsSearchHandle)
{
    ADS_SEARCH_COLUMN   column;
    GUID              * ImplGuid = NULL;
    ULONG               i, j, cImpl = 0;
    HRESULT             hr = S_FALSE;
    
    if (cImplemented == -1)
        return S_OK;
    
    hr = ADSIGetColumn(hADs, hADsSearchHandle, IMPL_CATEGORIES, &column);
    if (FAILED(hr))
        return S_FALSE;
    
    hr = S_FALSE;
    
    UnpackGUIDArrFrom(column, &ImplGuid, &cImpl);
    
    for (j = 0;j < cImpl; j++) {
        // check if it implements any of the categories requested.
        for (i = 0; i < cImplemented; i++)
            if (IsEqualGUID(ImplGuid[j], ImplementedList[i]))
                break;
            if (i < cImplemented) {
                hr = S_OK;
                break;
            }
    }
    
    CoTaskMemFree(ImplGuid);
    
    ADSIFreeColumn(hADs, &column);
    
    return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\cclstor.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclstor.cxx
//
//  Contents:Class Factory and IUnknown methods for CClassContainer
//
//  Author:  DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//
// Constructor for Class Container Class factory
//
unsigned long gulcInstances = 0;


CClassContainerCF::CClassContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcInstances );
}

//
// Destructor
//
CClassContainerCF::~CClassContainerCF()
{
    InterlockedDecrement((long *) &gulcInstances );
}

HRESULT  __stdcall  CClassContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }
    
    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;
    
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateInstance
//
//  Synopsis:
//              This is the default create instance on the class factory.
//
//  Arguments:  pUnkOuter - Should be NULL
//              riid      - IID of interface wanted
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
//
HRESULT  __stdcall  CClassContainerCF::CreateInstance(
                                                      IUnknown    *   pUnkOuter,
                                                      REFIID          riid,
                                                      void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE              sc = S_OK;
    
    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateConnectedInstance
//
//  Synopsis:
//              This method is called by the ParseDisplayName implementation
//              on the ClassFactory object.
//              When a display name is used to bind to a Class Store
//              an IClassAdmin is returned after binding to the container.
//              This method fails if the bind fails.
//
//  Arguments:  pszPath  - DisplayName of Class Store Container
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

HRESULT  __stdcall  CClassContainerCF::CreateConnectedInstance(
                                                               LPOLESTR        pszPath,
                                                               void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE              sc = S_OK;
    HRESULT            hr = S_OK;
    
    if ((pIUnk = new CClassContainer(pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAdmin, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        else
            printf ("Connect to Store Failed. hr = 0x%x.\n", sc);
        
        pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;
    
    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::ParseDisplayName
//
//  Synopsis:   Parse a display name and create a pointer moniker.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

STDMETHODIMP CClassContainerCF::ParseDisplayName(
                                                 IBindCtx  * pbc,
                                                 LPOLESTR    pszDisplayName,
                                                 ULONG     * pchEaten,
                                                 IMoniker ** ppmkOut)
{
    HRESULT         hr = S_OK;
    LPOLESTR        pch = pszDisplayName;
    IClassAdmin   * pOleClassStore = NULL;
    DWORD ClassStoreId;
    
    //Validate parameters.
    *pchEaten = 0;
    *ppmkOut = NULL;
    
    //Eat the prefix.
    while (*pch != '\0' && *pch != ':')
    {
        pch++;
    }
    
    if(':' == *pch)
    {
        pch++;
    }
    else
    {
        return MK_E_SYNTAX;
    }
    
    hr = CreateConnectedInstance(pch, (void **) &pOleClassStore);
    
    if(SUCCEEDED(hr))
    {
        hr = CreatePointerMoniker(pOleClassStore, ppmkOut);
        if(SUCCEEDED(hr))
        {
            *pchEaten = lstrlenW(pszDisplayName);
        }
        
        pOleClassStore->Release();
    }
    
    return hr;
}


HRESULT  __stdcall  CClassContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcInstances ); }
    else
    { InterlockedDecrement((long *) &gulcInstances ); }
    return(S_OK);
}

//
// IUnknown methods for CClassContainer
//
//

HRESULT  __stdcall  CClassContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE     sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_IClassAdmin, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_ICatRegister, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatRegister *)this;
    }
    else if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    else {
        sc = (E_NOINTERFACE);
    }
    
    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;
    
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\cscaten.cxx ===
//
//  Author: ushaji
//  Date:   December 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for Enumerator Interfaces.
//
//      Refer Doc "Design for Support of File Types and Component Categories
//    in Class Store" ? (or may be Class Store Schema). Most of these uses
//  OLE DB interfaces within the interfaces.
//
//----------------------------------------------------------------------------

#include "cstore.hxx"


//
// Private defines
//

#define MAX_ADS_FILTERS   10
#define MAX_ADS_ENUM      100

HRESULT GetCategoryProperty (HANDLE            hADs,
                             ADS_SEARCH_HANDLE hSearchHandle,
                             CATEGORYINFO     *pcategoryinfo,
                             LCID              lcid)
{
    HRESULT            hr = S_OK;
    WCHAR             *szName = NULL;
    LPOLESTR          *pdesc = NULL;
    ULONG              i, cdesc = 0;
    ADS_SEARCH_COLUMN  column;
    
    hr = ADSIGetColumn(hADs, hSearchHandle, CATEGORYCATID, &column);
    RETURN_ON_FAILURE(hr);
    
    hr = UnpackGUIDFrom(column, &(pcategoryinfo->catid));
    RETURN_ON_FAILURE(hr);
        
    ADSIFreeColumn(hADs, &column);
    
    hr = ADSIGetColumn(hADs, hSearchHandle, LOCALEDESCRIPTION, &column);
    RETURN_ON_FAILURE(hr);
    
    UnpackStrArrAllocFrom(column, &pdesc, &cdesc);
    
    pcategoryinfo->lcid = lcid;
    
    hr = GetCategoryLocaleDesc(pdesc, cdesc, &(pcategoryinfo->lcid),
        (pcategoryinfo->szDescription));
    
    ADSIFreeColumn(hADs, &column);
    
    for (i = 0; i < cdesc; i++) 
		CoTaskMemFree(pdesc[i]);
	CoTaskMemFree(pdesc);
    
    if (FAILED(hr))
        *(pcategoryinfo->szDescription) = L'\0';
    
    return S_OK;
}
//----------------------------------------------


//    IEnumCATEGORYINFO:
//    IUnknown methods
HRESULT CSCEnumCategories::QueryInterface(REFIID riid, void** ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumCATEGORYINFO))
    {
        *ppObject=(IUnknown *)(IEnumCATEGORYINFO*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumCategories::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumCategories::Release()
{
    ULONG dwRefCount;
    
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATEGORYINFO methods
//--------------------------------------------------------------------
// Next:
//        celt:            Number of elements to be fetched.
//        rgelt:           Buffer to return the elements.
//        pceltFetched:    ptr to Number of elements actually fetched.
//                         Takes care of that being NULL.
// Uses OLE DS interfaces to get the next enumerators.
//--------------------------------------------------------------------

HRESULT CSCEnumCategories::Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched)
{
    HRESULT             hr = S_OK;
    ULONG               dwCount = 0, cElems = 0;
    
    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;
    
    if (pceltFetched)
        (*pceltFetched) = 0;
    
    if (celt < 0)
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(rgelt, sizeof(CATEGORYINFO)*celt))
        return E_INVALIDARG;
    
    for ((dwCount) = 0; (dwCount) < celt;)
    {
        if ((!m_dwPosition) && (!cElems))
            hr = ADSIGetFirstRow(m_hADs, m_hADsSearchHandle);
        else
            hr = ADSIGetNextRow(m_hADs, m_hADsSearchHandle);
        
        cElems++;
        
        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;
        
        hr = GetCategoryProperty(m_hADs, m_hADsSearchHandle, &(rgelt[dwCount]), m_lcid);
        
        if (FAILED(hr))
            continue;
        
        (dwCount)++;
    }
    
    m_dwPosition += dwCount;
    
    if (pceltFetched)
        (*pceltFetched) = dwCount;

    if (dwCount == celt)
        return S_OK;
    return S_FALSE;

}

//---------------------------------------------------
// skip:
//            skips elements.
//    celt    Number of elements to skip.
//---------------------------------------------------

HRESULT CSCEnumCategories::Skip(ULONG celt)
{
    CATEGORYINFO *dummy = NULL;
    ULONG         got = 0;
    HRESULT       hr = S_OK;
    
    dummy = new CATEGORYINFO[celt];
    if (!dummy)
        return E_OUTOFMEMORY;
    
    hr = Next(celt, dummy, &got);
    delete dummy;
    return hr;
}

//---------------------------------------------------
// Reset:
//     Resets the pointer.
//---------------------------------------------------
HRESULT CSCEnumCategories::Reset(void)
{
    HRESULT     hr = S_OK;
    WCHAR       szfilter[_MAX_PATH];
    
    m_dwPosition = 0;

    if (m_hADsSearchHandle)
    {
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
        m_hADsSearchHandle = NULL;
    }

    wsprintf(szfilter, L"(objectClass=%s)", CLASS_CS_CATEGORY);
    hr = ADSIExecuteSearch(m_hADs, szfilter, pszCategoryAttrNames, cCategoryAttr, &m_hADsSearchHandle);
    return RemapErrorCode(hr, m_szCategoryName);
}
//--------------------------------------------------------------
//    Clone:
//        returns another interface which points to the same data.
//        ppenum:        enumerator
//--------------------------------------------------------------

HRESULT CSCEnumCategories::Clone(IEnumCATEGORYINFO **ppenum)
{
    CSCEnumCategories* pClone=NULL;
    
    if (!IsValidPtrOut(ppenum, sizeof(IEnumCATEGORYINFO *))) {
        return E_INVALIDARG;
    }
    
    pClone=new CSCEnumCategories();
    
    if (!pClone)
    {
        return E_OUTOFMEMORY;
    }
    
    if (FAILED(pClone->Initialize(m_szCategoryName, m_lcid)))
    {
        delete pClone;
        return E_UNEXPECTED;
    }
    
    pClone->Skip(m_dwPosition);
    
    if (SUCCEEDED(pClone->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenum)))
    {
        return S_OK;
    }
    
    delete pClone;
    return E_UNEXPECTED;
}

CSCEnumCategories::CSCEnumCategories()
{
    m_dwRefCount=0;
    m_hADs = NULL;
    m_hADsSearchHandle = NULL;
    wcscpy(m_szCategoryName, L"");
    m_lcid = 0;
    m_dwPosition = 0;
}

// clone will go over the wire again.
// reference counting will be good.

HRESULT CSCEnumCategories::Initialize(WCHAR *szCategoryName, LCID lcid)
{
    HRESULT             hr = S_OK;
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    
    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = 20;
   
    wcscpy(m_szCategoryName, szCategoryName);
    
    hr = ADSIOpenDSObject(m_szCategoryName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &m_hADs);
    RETURN_ON_FAILURE(hr);
    
    hr = ADSISetSearchPreference(m_hADs, SearchPrefs, 2);
    RETURN_ON_FAILURE(hr);
    
    wsprintf(szfilter, L"(objectClass=%s)", CLASS_CS_CATEGORY);
    
    hr = ADSIExecuteSearch(m_hADs, szfilter, pszCategoryAttrNames, cCategoryAttr, &m_hADsSearchHandle);
    RETURN_ON_FAILURE(hr);
    
    m_lcid = lcid;
    return S_OK;
    
} /* EnumCategories */


CSCEnumCategories::~CSCEnumCategories()
{
    if (m_hADs)
        ADSICloseDSObject(m_hADs);
    
    if (m_hADsSearchHandle)
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
}

// CSCEnumCategoriesOfClass:
// IUnknown methods
HRESULT CSCEnumCategoriesOfClass::QueryInterface(REFIID riid, void** ppObject)
{
    if ((riid==IID_IUnknown) || (riid==IID_IEnumCATID))
    {
        *ppObject=(IEnumCATID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumCategoriesOfClass::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumCategoriesOfClass::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATID methods
HRESULT CSCEnumCategoriesOfClass::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    ULONG dwCount;
    
    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;
    
    if (pceltFetched)
        (*pceltFetched) = 0;
    
    if (celt < 0)
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(rgelt, sizeof(GUID)*celt))
        return E_INVALIDARG;
    
    for ( (dwCount) = 0; (((dwCount) < celt) && (m_dwPosition < m_cCatid));
    (dwCount)++, m_dwPosition++)
        rgelt[(dwCount)] = m_catid[m_dwPosition];
    
    if (pceltFetched)
        (*pceltFetched) = dwCount;
    if (dwCount == celt)
        return S_OK;
    return S_FALSE;
}

HRESULT CSCEnumCategoriesOfClass::Skip(ULONG celt)
{
    if (m_cCatid >= (celt + m_dwPosition)) {
        m_dwPosition += celt;
        return S_OK;
    }
    m_dwPosition = m_cCatid;
    return S_FALSE;
}


HRESULT CSCEnumCategoriesOfClass::Reset(void)
{
    m_dwPosition = 0;
    return S_OK;
}

HRESULT CSCEnumCategoriesOfClass::Clone(IEnumGUID **ppenum)
{
    HRESULT                         hr = S_OK;
    CSCEnumCategoriesOfClass       *pEnumClone = NULL;
    
    if (!IsValidPtrOut(ppenum, sizeof(IEnumGUID *)))
        return E_POINTER;
    
    pEnumClone = new CSCEnumCategoriesOfClass;
    if (pEnumClone == NULL)
        return E_OUTOFMEMORY;
    
    pEnumClone->Initialize(m_catid, m_cCatid);
    pEnumClone->m_dwPosition = m_dwPosition;
    if (SUCCEEDED(hr = pEnumClone->QueryInterface(IID_IEnumCATID, (void**) ppenum)))
        return S_OK;
    
    delete pEnumClone;
    return hr;
}


CSCEnumCategoriesOfClass::CSCEnumCategoriesOfClass()
{
    m_dwRefCount=0;
    m_dwPosition = 0;
    m_catid = NULL;
}

HRESULT CSCEnumCategoriesOfClass::Initialize(CATID catid[], ULONG cCatid)
{
    ULONG   i;
    
    m_catid = new CATID[cCatid];
    if ((cCatid) && (!m_catid))
        return E_OUTOFMEMORY;
    m_cCatid = cCatid;
    for (i = 0; i < cCatid; i++)
        m_catid[i] = catid[i];
    m_dwPosition = 0;
    return S_OK;
}

CSCEnumCategoriesOfClass::~CSCEnumCategoriesOfClass()
{
    if (m_catid)
        delete m_catid;
}

// CEnumClassesOfCategories:
// IUnknown methods
HRESULT CSCEnumClassesOfCategories::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCLSID)
    {
        *ppObject=(IEnumCLSID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumClassesOfCategories::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumClassesOfCategories::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumGUID methods
HRESULT CSCEnumClassesOfCategories::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    ULONG               i, dwCount=0;
    HRESULT             hr = S_OK;
    CLSID               clsid;
    WCHAR             * szClsid = NULL;
    DWORD               cElems = 0;
    ADS_SEARCH_COLUMN   column;
    
    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;
    
    if (pceltFetched)
        (*pceltFetched) = 0;
    
    if ((celt < 0) || (!IsValidPtrOut(rgelt, sizeof(GUID)*celt)))
        return E_INVALIDARG;
    
    for ((dwCount) = 0; (dwCount) < celt;)
    {
        if ((!m_dwPosition) && (!cElems))
            hr = ADSIGetFirstRow(m_hADs, m_hADsSearchHandle);
        else
            hr = ADSIGetNextRow(m_hADs, m_hADsSearchHandle);
        
        cElems++;
        
        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
        {
            if (pceltFetched)
                *pceltFetched = dwCount;
            return S_FALSE;
        }
        
        hr = ADSIGetColumn(m_hADs, m_hADsSearchHandle, CLASSCLSID, &column);
        if (FAILED(hr))
        {
            if (pceltFetched)
                *pceltFetched = dwCount;
            return S_FALSE;
        }
        
        UnpackStrFrom(column, &szClsid);
        
        GUIDFromString(szClsid, &clsid);
        
        if ((ImplSatisfied(m_cImplemented, m_rgcatidImpl, m_hADs, m_hADsSearchHandle) == S_OK) &&
            (ReqSatisfied(m_cRequired, m_rgcatidReq, m_hADs, m_hADsSearchHandle) == S_OK))
        {
            rgelt[dwCount] = clsid;
            (dwCount)++;
        }
    }
    
    m_dwPosition += dwCount;
    
    if (pceltFetched)
        *pceltFetched = dwCount;
    
    return S_OK;
}

HRESULT CSCEnumClassesOfCategories::Skip(ULONG celt)
{
    CLSID       *dummyclasses=NULL;
    ULONG        celtFetched=0;
    HRESULT      hr=S_OK;
    
    dummyclasses = new CLSID[celt];
    hr = Next(celt, dummyclasses, &celtFetched);
    delete dummyclasses;
    return hr;
}

HRESULT CSCEnumClassesOfCategories::Reset()
{
    LPOLESTR            AttrNames[] = {CLASSCLSID, IMPL_CATEGORIES, REQ_CATEGORIES};
    DWORD               cAttrs = 3;
    WCHAR               szfilter[_MAX_PATH];
    HRESULT             hr = S_OK;

    m_dwPosition = 0;
        
    if (m_hADsSearchHandle)
    {
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
        m_hADsSearchHandle = NULL;
    }

    wsprintf(szfilter, L"(objectClass=%s)", CLASS_CS_CLASS);
    
    hr = ADSIExecuteSearch(m_hADs, szfilter, AttrNames, cAttrs, &m_hADsSearchHandle);

    return RemapErrorCode(hr, m_szClassName);
}

HRESULT CSCEnumClassesOfCategories::Clone(IEnumGUID **ppenum)
{
    HRESULT                        hr=S_OK;
    CSCEnumClassesOfCategories    *pEnumClone=NULL;
    
    if (!ppenum)
        return E_INVALIDARG;
    
    pEnumClone = new CSCEnumClassesOfCategories;
    if (!pEnumClone)
        return E_OUTOFMEMORY;
    
    hr = pEnumClone->Initialize(m_cRequired,    m_rgcatidReq,
        m_cImplemented, m_rgcatidImpl,
        m_szClassName);
    if (FAILED(hr))
    {
        delete pEnumClone;
        return hr;
    }
    
    pEnumClone->Skip(m_dwPosition);
    
    hr = pEnumClone->QueryInterface(IID_IEnumCLSID, (void **)ppenum);
    if (FAILED(hr))
    {
        delete pEnumClone;
    }
    
    return hr;
}

CSCEnumClassesOfCategories::CSCEnumClassesOfCategories()
{
    m_dwRefCount = 0;
    m_rgcatidReq = NULL;
    m_rgcatidImpl = NULL;
    wcscpy(m_szClassName,L"");
    m_dwPosition = 0;
    m_hADs = NULL;
    m_hADsSearchHandle = NULL;
}

HRESULT CSCEnumClassesOfCategories::Initialize(ULONG cRequired, CATID rgcatidReq[],
                                               ULONG cImplemented, CATID rgcatidImpl[],
                                               WCHAR *szClassName)
{
    ULONG               i;
    HRESULT             hr = S_OK;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    LPOLESTR            AttrNames[] = {CLASSCLSID, IMPL_CATEGORIES, REQ_CATEGORIES};
    DWORD               cAttrs = 3;
    WCHAR               szfilter[_MAX_PATH];
    
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = 20;
    
    wcscpy(m_szClassName, szClassName);
    
    hr = ADSIOpenDSObject(m_szClassName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &m_hADs);
    ERROR_ON_FAILURE(hr);
    
    hr = ADSISetSearchPreference(m_hADs, SearchPrefs, 2);
    ERROR_ON_FAILURE(hr);
    
    wsprintf(szfilter, L"(objectClass=%s)", CLASS_CS_CLASS);
    
    hr = ADSIExecuteSearch(m_hADs, szfilter, AttrNames, cAttrs, &m_hADsSearchHandle);
    ERROR_ON_FAILURE(hr);
    
    m_cRequired = cRequired;
    if (cRequired != -1)
    {
        m_rgcatidReq = new CATID[cRequired];
        if (!m_rgcatidReq) {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        
        for (i = 0; i < m_cRequired; i++)
            m_rgcatidReq[i] = rgcatidReq[i];
    }
    
    m_cImplemented = cImplemented;
    if (cImplemented != -1)
    {
        m_rgcatidImpl = new CATID[cImplemented];
        if (!m_rgcatidImpl) {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        for (i = 0; i < m_cImplemented; i++)
            m_rgcatidImpl[i] = rgcatidImpl[i];
    }
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szClassName);
}

CSCEnumClassesOfCategories::~CSCEnumClassesOfCategories()
{
    if (m_rgcatidReq)
        delete m_rgcatidReq;
    
    if (m_rgcatidImpl)
        delete m_rgcatidImpl;
    
    if (m_hADsSearchHandle)
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
    
    if (m_hADs)
        ADSICloseDSObject(m_hADs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csacc.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//  File:   csacc.cxx
//
//      Class Store Manager implementation for a client desktop.
//
//      This source file contains implementations for IClassAccess
//      interface for CClassAccess object.
//      It also contains the IEnumPackage implementation for the 
//      aggregate of all class containers seen by the caller.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

IClassAccess *GetNextValidClassStore(CLASSCONTAINER **pStoreList, 
                                     DWORD     cStores, 
                                     PSID      pUserSid,
                                     uCLSSPEC* pClassSpec,
                                     BOOL      fCache,
                                     DWORD*    pcount);


extern HRESULT GetUserClassStores(
                           PCLASSCONTAINER     **ppStoreList,
                           DWORD                *pcStores,
                           BOOL                 *pfCache,
                           PSID                 *ppUserSid);



//
// Link list pointer for Class Containers Seen
//
extern CLASSCONTAINER *gpContainerHead;

//
// Link list pointer for User Profiles Seen
//
extern USERPROFILE *gpUserHead;

//
// Global Class Factory for Class Container
//
extern CAppContainerCF *pCF;

//
// Critical Section used during operations on list of class stores
//
extern CRITICAL_SECTION    ClassStoreBindList;

//
// CClassAccess implementation
//

CClassAccess::CClassAccess()

{
     m_uRefs = 1;
     m_cCalls = 0;
     pStoreList = NULL;
     cStores = 0;
}

CClassAccess::~CClassAccess()

{
    DWORD i;
    for (i = 0; i < cStores; i++) 
    {
        if (pStoreList[i]->gpClassStore)
        {
            (pStoreList[i]->gpClassStore)->Release();
            pStoreList[i]->gpClassStore = NULL;
            CSDBGPrint((L"Found open container and closed."));
        }

        if (pStoreList[i]->pszClassStorePath)
        {
            CoTaskMemFree (pStoreList[i]->pszClassStorePath);
            pStoreList[i]->pszClassStorePath = NULL;
        }
        CoTaskMemFree(pStoreList[i]);
        pStoreList[i] = NULL;

    }
    CoTaskMemFree(pStoreList);
    cStores = NULL;
}

//----------------------------------------------------------------------
//
// 

void PrintClassSpec(
      uCLSSPEC       *   pclsspec         // Class Spec (GUID/Ext/MIME)
     )
{
    STRINGGUID szClsid;

    if (pclsspec->tyspec == TYSPEC_CLSID)
    {
        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);
        CSDBGPrint((L" ... GetAppInfo by CLSID = %s", szClsid));
    }

    if (pclsspec->tyspec == TYSPEC_PROGID)
    {
        CSDBGPrint((L" ... GetAppInfo by ProgID = %s",
            pclsspec->tagged_union.pProgId));
    }

    if (pclsspec->tyspec == TYSPEC_MIMETYPE)
    {
        CSDBGPrint((L" ... GetAppInfo by MimeType = %s",
            pclsspec->tagged_union.pMimeType));
    }

    if (pclsspec->tyspec == TYSPEC_FILEEXT)
    {
        CSDBGPrint((L" ... GetAppInfo by FileExt = %s",
            pclsspec->tagged_union.pFileExt));
    }

    if (pclsspec->tyspec == TYSPEC_IID)
    {
        StringFromGUID (pclsspec->tagged_union.iid, szClsid);
        CSDBGPrint((L" ... GetAppInfo by IID = %s", szClsid));
    }
}

//----------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
CClassAccess::GetAppInfo(
         uCLSSPEC           *   pclsspec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT       *   pQryContext,         // Query Attributes
         PACKAGEDISPINFO    *   pPackageInfo
        )

        //
        // This is the most common method to access the Class Store.
        // It queries the class store for implementations for a specific
        // Class Id, or File Ext, or ProgID or MIME type.
        //
        // If a matching implementation is available for the object type,
        // client architecture, locale and class context pointer to the
        // binary is returned.
{

    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //
    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr = S_OK;
    ULONG               i = 0, j = 0, k= 0;
    IClassAccess    *   pICA = NULL;
    BOOL                fCache = FALSE;
    PSID                pUserSid = NULL;
    BOOL                fFound = FALSE;
    QUERYCONTEXT        QueryContext;

        
    // added later.
    if (gDebug)
    {
        WCHAR   Name[32];
        DWORD   NameSize = 32;
   
        if ( ! GetUserName( Name, &NameSize ) )
            CSDBGPrint((L"GetAppInfo GetUserName failed 0x%x", GetLastError()));
        else
            CSDBGPrint((L"GetAppInfo as %s", Name));
    }

    if ((!pPackageInfo) ||
        (!IsValidReadPtrIn(pPackageInfo, sizeof(PACKAGEDISPINFO))))
            return E_INVALIDARG;

    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    if ( pQryContext )
    {
        QueryContext = *pQryContext;
    }
    else
    {
        // gets the default information.
        QueryContext.dwContext = CLSCTX_ALL;
        GetDefaultPlatform( &QueryContext.Platform );
        QueryContext.Locale = MAKELCID(GetUserDefaultLangID(), SUBLANG_NEUTRAL);
        QueryContext.dwVersionHi = (DWORD) -1;
        QueryContext.dwVersionLo = (DWORD) -1;
    }    

    if (gDebug)
        PrintClassSpec(pclsspec);

    if (!pStoreList)
        hr = GetUserClassStores(
                    &pStoreList,
                    &cStores,
                    &fCache,
                    &pUserSid);


    ERROR_ON_FAILURE(hr);

    for (i=0; i < cStores; i++)
    {

        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, pUserSid, pclsspec, fCache, &i)))
            continue;

        //
        // Call method on this store
        //

        pICA->AddRef();

        hr = pICA->GetAppInfo(
            pclsspec,
            &QueryContext,
            pPackageInfo);

        // Release it after use.

        pICA->Release();

        //
        // Special case error return E_INVALIDARG
        // Do not continue to look, return this.
        //
        if (hr == E_INVALIDARG)
        {
            ERROR_ON_FAILURE(hr);
        }

        //
        // maintain access counters
        //
        (pStoreList[i])->cAccess++;

        //
        // We are iterating through the class stores from highest precedence to lowest --
        // thus, the first container to return success will be our choice.
        //
        if (SUCCEEDED(hr))
        {
            fFound = TRUE;
            break;
        }
        else
        {
            (pStoreList[i])->cNotFound++;
            CSDBGPrint((L"CClassAccess::GetAppInfo() returned 0x%x", hr));
        }
        hr = S_OK;
    }

 Error_Cleanup:
 
     if (pUserSid)
        CoTaskMemFree (pUserSid);
    if (fFound)
    {
        CSDBGPrint((L"Returning Package %s", pPackageInfo->pszPackageName));
        return S_OK;
    }
    if (!SUCCEEDED(hr))
        return hr;
    return CS_E_PACKAGE_NOTFOUND;
}

#define MAX_GUID_CCH 38
//
// IsClassStoreForPolicy
//

BOOL IsClassStoreForPolicy(CLASSCONTAINER* pClassStore,
                           LPWSTR          wszPolicyId)
{
    LPWSTR pszPolicyGuid;

    // Path looks like:
    // LDAP://CN=<Class Store Name>,CN=<user-or-machine>,CN=<{policy-guid}>,...

    //
    // Look for ',' first
    //
    pszPolicyGuid = wcschr(pClassStore->pszClassStorePath, L',');

    if (!pszPolicyGuid)
    {
        return FALSE;
    }

    //
    // Look for the second ','
    //
    pszPolicyGuid = wcschr(pszPolicyGuid + 1, L',');

    if (!pszPolicyGuid)
    {
        return FALSE;
    }

    //
    // Now get to '{' at start of guid -- it is 4 chars
    // past the ',' which we are currently at.  Use wcschr
    // to make sure we don't go past the end of the string
    // and that our assumptions about the structure of the
    // path are correct
    //
    if (wcschr(pszPolicyGuid, L'{') == (pszPolicyGuid + 4))
    {

        pszPolicyGuid += 4;

        //
        // Now that we have the '{', we are at the start of the guid
        // and can compare with the requested policy id
        //
        if (_wcsnicmp(pszPolicyGuid, wszPolicyId, MAX_GUID_CCH) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//
// GetNextValidClassStore
//
//

IClassAccess *GetNextValidClassStore(CLASSCONTAINER** pStoreList, 
                                     DWORD            cStores, 
                                     PSID             pUserSid,
                                     uCLSSPEC*        pClassSpec,
                                     BOOL             fCache,
                                     DWORD *          pcount)
{
    IClassAccess *pretICA = NULL;
    BOOL          bSpecificPolicy;
    LPWSTR        wszPolicyGuid;
    HRESULT       hr;

    wszPolicyGuid = NULL;

    hr = S_OK;

    bSpecificPolicy = pClassSpec ? TYSPEC_PACKAGENAME == pClassSpec->tyspec : FALSE;

    if (bSpecificPolicy)
    {
        hr = StringFromCLSID(pClassSpec->tagged_union.ByName.PolicyId, &wszPolicyGuid);
    }

    if (SUCCEEDED(hr))
    {
        for (pStoreList += (*pcount); (*pcount) < cStores; (*pcount)++, pStoreList++)
        {
            if ((*pStoreList)->gpClassStore != NULL)
            {
                break;
            }

            if (bSpecificPolicy &&
                !IsClassStoreForPolicy(*pStoreList, wszPolicyGuid))
            {
                continue;
            }

            if (FALSE) // ((*pStoreList)->cBindFailures >= MAX_BIND_ATTEMPTS)
            {
                // Number of continuous failures have reached MAX_BIND_ATTEMPTS
                // for this container.
                // Will temporarily disable lookups in this container.
                // Report it in EventLog once
                //

                if ((*pStoreList)->cBindFailures == MAX_BIND_ATTEMPTS)
                {
                    //LogCsPathError((*pStoreList)->pszClassStorePath, hr);
                    (*pStoreList)->cBindFailures++;
                }
            continue;
            }
            else
            { 
                CSDBGPrint((L"CS: .. Connecting to Store %d ... %s..",
                            (*pcount),
                            (*pStoreList)->pszClassStorePath));
                //
                // Bind to this Class Store
                //

                if ((wcsncmp ((*pStoreList)->pszClassStorePath, L"ADCS:", 5) == 0) ||
                    (wcsncmp ((*pStoreList)->pszClassStorePath, L"LDAP:", 5) == 0))
                {
                    //
                    // If the Storename starts with ADCS or LDAP
                    // it is NTDS based implementation. Call directly.
                    //
    
                    IClassAccess *pCA = NULL;
                    LPOLESTR szClassStore = (*pStoreList)->pszClassStorePath;

                    // skipping ADCS:
                    if (wcsncmp ((*pStoreList)->pszClassStorePath, L"ADCS:", 5) == 0)
                        szClassStore += 5;

                    hr = pCF->CreateConnectedInstance(
                        szClassStore,
                        pUserSid,
                        fCache,
                        (void **)&pCA);

                    if (SUCCEEDED(hr))
                    {
                        EnterCriticalSection (&ClassStoreBindList);
                        
                        if ((*pStoreList)->gpClassStore != NULL)
                        {
                            pCA->Release();
                            pCA = NULL;
                        }
                        else
                        {
                            (*pStoreList)->gpClassStore = pCA;
                            pCA = NULL;
                        }
                        
                        LeaveCriticalSection (&ClassStoreBindList);
                    }
                }
                else
                {
                    //
                    // Support for Third Party Pluggable
                    // Class Stores is not in Beta2.
                    //
                    
                    ReportEventCS(hr = CS_E_INVALID_PATH, CS_E_INVALID_PATH, (*pStoreList)->pszClassStorePath);
                }

                if (SUCCEEDED(hr))
                {
                    (*pStoreList)->cBindFailures = 0;
                    hr = S_OK;
                    break;
                }

                if (!SUCCEEDED(hr))
                {
                    CSDBGPrint((L"Failed to connect to this store"));
                    
                    if ((*pStoreList)->cBindFailures == 0)
                    {
                        // First failue or First failure after successful
                        // binding.
                        // Report it in EventLog
                        //

                        //LogCsPathError((*pStoreList)->pszClassStorePath, hr);
                    }
                    
                    ((*pStoreList)->cBindFailures) ++;
                    continue;
                }
            }
        }
    }

    if (wszPolicyGuid)
    {
        CoTaskMemFree(wszPolicyGuid);
    }

    if ((*pcount) != cStores)
        pretICA = (*pStoreList)->gpClassStore;


    return pretICA;
}




HRESULT STDMETHODCALLTYPE CClassAccess::EnumPackages(
        LPOLESTR        pszPackageName, 
        GUID            *pCategory,
        ULONGLONG       *pLastUsn,
        DWORD           dwAppFlags,      // AppType options
        IEnumPackage    **ppIEnumPackage)
{
    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr = S_OK;
    ULONG               i;
    IEnumPackage       *Enum[MAXCLASSSTORES];
    ULONG               cEnum = 0;
    CMergedEnumPackage *EnumMerged = NULL;
    IClassAccess       *pICA = NULL;
    ULONGLONG          LastUsn, CopyLastUsn, *pCopyLastUsn;
    BOOL               fCache = FALSE;
    PSID               pUserSid = NULL;

    // added later.
    if (gDebug)
    {
        WCHAR   Name[32];
        DWORD   NameSize = 32;
   
        if ( ! GetUserName( Name, &NameSize ) )
            CSDBGPrint((L"EnumPackage GetUserName failed 0x%x", GetLastError()));
        else
            CSDBGPrint((L"EnumPackage as %s", Name));
    }

    LastUsn = 0;

    if (pLastUsn)
    {
        //
        // Check pLastUsn
        //
        if (!IsValidReadPtrIn(pLastUsn, sizeof(ULONGLONG)))
            return E_INVALIDARG;

        pCopyLastUsn = &CopyLastUsn;
        *pCopyLastUsn = *pLastUsn;
    }
    else
        pCopyLastUsn = NULL;
    
    //
    // Get the list of Class Stores for this user
    //
    if (!pStoreList)
        hr = GetUserClassStores(
                        &pStoreList,
                        &cStores,
                        &fCache,
                        &pUserSid);
    

    *ppIEnumPackage = NULL;


    if ((hr == S_OK) && (cStores == 0))
    {
        hr = CS_E_NO_CLASSSTORE;
    }

    if (!SUCCEEDED(hr))
    {
        //
        // Free the Sid
        //
        if (pUserSid)
            CoTaskMemFree (pUserSid);
        return hr;
    }

    for (i=0; i < cStores; i++)
    {
        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, pUserSid, NULL, fCache, &i)))
            continue;
        //
        // Call method on this store
        //

        hr = pICA->EnumPackages (pszPackageName, 
            pCategory,
            pCopyLastUsn,
            dwAppFlags,
            &(Enum[cEnum]));

        if (hr == E_INVALIDARG)
        {
            break;
        }

        if (pCopyLastUsn)
        {
            if (LastUsn < *pCopyLastUsn)
                LastUsn = *pCopyLastUsn;
            *pCopyLastUsn = *pLastUsn;
        }
        if (SUCCEEDED(hr))
            cEnum++;
    }
    
    if (SUCCEEDED(hr))
    {
        
        EnumMerged = new CMergedEnumPackage;
        hr = EnumMerged->Initialize(Enum, cEnum);
        
        if (FAILED(hr))
        {
            for (i = 0; i < cEnum; i++)
                Enum[i]->Release();
            delete EnumMerged;
        }
        else
        {
            hr = EnumMerged->QueryInterface(IID_IEnumPackage, (void **)ppIEnumPackage);
            if (FAILED(hr))
                delete EnumMerged;
        }
        
        if (pLastUsn)
        {
            if (LastUsn > *pLastUsn)
                *pLastUsn = LastUsn;
        }
    }

    if (pUserSid)
        CoTaskMemFree (pUserSid);
    return hr;
}


//--------------------------------------------------------------

CMergedEnumPackage::CMergedEnumPackage()
{
    m_pcsEnum = NULL;
    m_cEnum = 0;
    m_csnum = 0;
    m_dwRefCount = 0;
}

CMergedEnumPackage::~CMergedEnumPackage()
{
    ULONG    i;
    for (i = 0; i < m_cEnum; i++)
        m_pcsEnum[i]->Release();
    CoTaskMemFree(m_pcsEnum);
}

HRESULT  __stdcall  CMergedEnumPackage::QueryInterface(REFIID riid,
                                            void  * * ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumPackage))
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG  __stdcall  CMergedEnumPackage::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}



ULONG  __stdcall  CMergedEnumPackage::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


HRESULT  __stdcall CMergedEnumPackage::Next(
            ULONG             celt,
            PACKAGEDISPINFO   *rgelt,
            ULONG             *pceltFetched)
{
    ULONG count=0, total = 0;
    HRESULT hr;

    for (; m_csnum < m_cEnum; m_csnum++)
    {
        count = 0;
        hr = m_pcsEnum[m_csnum]->Next(celt, rgelt+total, &count);

        if (hr == E_INVALIDARG)
        {
            return hr;
        }

        total += count;
        celt -= count;

        if (!celt)
            break;
    }
    if (pceltFetched)
        *pceltFetched = total;
    if (!celt)
        return S_OK;
    return S_FALSE;
}

HRESULT  __stdcall CMergedEnumPackage::Skip(
            ULONG             celt)
{
    PACKAGEDISPINFO *pPackageInfo = NULL;
    HRESULT          hr = S_OK;
    ULONG            cgot = 0, i;

    pPackageInfo = (PACKAGEDISPINFO *)CoTaskMemAlloc(sizeof(PACKAGEDISPINFO)*celt);
    if (!pPackageInfo)
        return E_OUTOFMEMORY;

    hr = Next(celt, pPackageInfo, &cgot);

    for (i = 0; i < cgot; i++)
        ReleasePackageInfo(pPackageInfo+i);
    CoTaskMemFree(pPackageInfo);
    
    return hr;
}

HRESULT  __stdcall CMergedEnumPackage::Reset()
{
    ULONG i;
    for (i = 0; ((i <= m_csnum) && (i < m_cEnum)); i++)
        m_pcsEnum[i]->Reset(); // ignoring all error values
    m_csnum = 0;
    return S_OK;
}

HRESULT  __stdcall CMergedEnumPackage::Clone(IEnumPackage   **ppIEnumPackage)
{
    ULONG i;
    CMergedEnumPackage *pClone;
    IEnumPackage **pcsEnumCloned=NULL;

    pClone = new CMergedEnumPackage;
    pcsEnumCloned = (IEnumPackage **)CoTaskMemAlloc(sizeof(IEnumPackage *)*m_cEnum);
    if (!pcsEnumCloned)
        return E_OUTOFMEMORY;

    for ( i = 0; i < m_cEnum; i++)
        m_pcsEnum[i]->Clone(&(pcsEnumCloned[i]));

    pClone->m_csnum = m_csnum;
    pClone->Initialize(pcsEnumCloned, m_cEnum);
    *ppIEnumPackage = (IEnumPackage *)pClone;
    pClone->AddRef();
    CoTaskMemFree(pcsEnumCloned);
    return S_OK;
}

HRESULT  CMergedEnumPackage::Initialize(IEnumPackage **pcsEnum, ULONG cEnum)
{
    ULONG i;
    m_csnum = 0;
    m_pcsEnum = (IEnumPackage **)CoTaskMemAlloc(sizeof(IEnumPackage *) * cEnum);
    if (!m_pcsEnum)
        return E_OUTOFMEMORY;
    for (i = 0; i < cEnum; i++)
        m_pcsEnum[i] = pcsEnum[i];
    m_cEnum = cEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csenum.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       csenum.cxx
//
//  Contents:   Per Class Container Package Enumeration
//
//
//  History:    09-09-96  DebiM   created
//              11-01-97  DebiM   modified, moved to cstore
//
//----------------------------------------------------------------------------

#include "cstore.hxx"

//IEnumPackage implementation.

HRESULT CEnumPackage::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumPackage)
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CEnumPackage::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CEnumPackage::Release()
{
    ULONG dwRefCount=m_dwRefCount-1;
    if (InterlockedDecrement((long*) &m_dwRefCount)==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


//
// CEnumPackage::Next
// ------------------
//
//
//
//  Synopsis:       This method returns the next celt number of packages
//                  within the scope of the enumeration.
//                  Packages are returned in the alphabetical name order.
//
//  Arguments:      [in]  celt - Number of package details to fetch
//                  INSTALLINFO *rgelt - Package detail structure
//                  ULONG *pceltFetched - Number of packages returned
//
//  Returns:        S_OK or S_FALSE if short of packages
//
//
//

HRESULT CEnumPackage::Next(ULONG               celt,
                           PACKAGEDISPINFO    *rgelt,
                           ULONG              *pceltFetched)
                           
{
    ULONG          cgot = 0, i, j;
    HRESULT        hr = S_OK;
    
    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;
    
    if (pceltFetched)
        (*pceltFetched) = 0;
    
    if (!IsValidPtrOut(rgelt, sizeof(PACKAGEDISPINFO)*celt))
        return E_INVALIDARG;
    
    if (gDebug)
    {
        WCHAR   Name[32];
        DWORD   NameSize = 32;
   
        if ( ! GetUserName( Name, &NameSize ) )
            CSDBGPrint((L"CEnumPackage::Next GetUserName failed 0x%x", GetLastError()));
        else
            CSDBGPrint((L"CEnumPackage::Next as %s", Name));
    }
    
    hr = FetchPackageInfo (m_hADs, m_hADsSearchHandle,
        m_dwAppFlags,
        m_pPlatform, celt, &cgot, rgelt,
        &m_fFirst);
    ERROR_ON_FAILURE(hr);
    
    m_dwPosition += cgot;
    
    if (pceltFetched)
        *pceltFetched = cgot;

    if (cgot != celt)
        hr = S_FALSE;
    else
        hr = S_OK;

    for (i=0; i < cgot; ++i)
    {
        memcpy (&(rgelt[i].GpoId), &m_PolicyId, sizeof(GUID));
        if (m_szPolicyName[0])
        {
            rgelt[i].pszPolicyName = (LPOLESTR) CoTaskMemAlloc(sizeof(WCHAR) * (1+wcslen(&m_szPolicyName[0])));
            if (rgelt[i].pszPolicyName)
                wcscpy (rgelt[i].pszPolicyName, &m_szPolicyName[0]);
            else {
                for (j = 0; j < cgot; j++)
                    ReleasePackageInfo(rgelt+j);
                if (pceltFetched)
                    *pceltFetched = 0;
                return E_OUTOFMEMORY;
            }
        }
    }
    return hr;
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szPackageName);
}


HRESULT CEnumPackage::Skip(ULONG celt)
{
    ULONG               celtFetched = NULL, i;
    HRESULT             hr = S_OK;
    PACKAGEDISPINFO    *pIf = NULL;
    
    pIf = new PACKAGEDISPINFO[celt];
    hr = Next(celt, pIf, &celtFetched);
    for (i = 0; i < celtFetched; i++)
        ReleasePackageInfo(pIf+i);
    delete pIf;
    
    return hr;
}

HRESULT CEnumPackage::Reset()
{
    HRESULT    hr = S_OK;

    m_dwPosition = 0;
    m_fFirst = TRUE;

    // execute the search and keep the handle returned.

    if (m_hADsSearchHandle)
    {
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
        m_hADsSearchHandle = NULL;
    }

    hr = ADSIExecuteSearch(m_hADs, m_szfilter, pszPackageInfoAttrNames,
                               cPackageInfoAttr, &m_hADsSearchHandle);

    return RemapErrorCode(hr, m_szPackageName);
}

HRESULT CEnumPackage::Clone(IEnumPackage **ppenum)
{
    CEnumPackage *pClone = new CEnumPackage;
    HRESULT       hr = S_OK;
    
    hr = pClone->Initialize(m_szPackageName, m_szfilter, m_dwAppFlags, m_pPlatform);
    if (FAILED(hr)) {
        delete pClone;
        return hr;
    }
    
    hr = pClone->QueryInterface(IID_IEnumPackage, (void **)ppenum);
    
    if (m_dwPosition)
        pClone->Skip(m_dwPosition);
    // we do not want to return the error code frm skip.
    return hr;
}

CEnumPackage::CEnumPackage()
{
    m_dwRefCount = 0;
    m_fFirst = TRUE;
    m_szfilter = NULL;
    wcscpy(m_szPackageName, L"");
    m_dwPosition = 0;
    m_dwAppFlags = 0;
    m_pPlatform = NULL;
    m_hADs = NULL;
    m_hADsSearchHandle = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));
    m_szPolicyName[0] = NULL;
}

CEnumPackage::CEnumPackage(GUID PolicyId, LPOLESTR pszPolicyName)
{
    m_dwRefCount = 0;
    m_fFirst = TRUE;
    m_szfilter = NULL;
    wcscpy(m_szPackageName, L"");
    m_dwPosition = 0;
    m_dwAppFlags = 0;
    m_pPlatform = NULL;
    m_hADs = NULL;
    m_hADsSearchHandle = NULL;
    memcpy (&m_PolicyId, &PolicyId, sizeof(GUID));
    m_szPolicyName[0] = NULL;
    if (pszPolicyName)
        wcscpy (&m_szPolicyName[0], pszPolicyName);
}


HRESULT CEnumPackage::Initialize(WCHAR      *szPackageName,
                                 WCHAR      *szfilter,
                                 DWORD       dwAppFlags,
                                 CSPLATFORM *pPlatform)
{
    HRESULT             hr = S_OK;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    
    m_szfilter = (LPOLESTR)CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(szfilter)+1));
    if (!m_szfilter)
        return E_OUTOFMEMORY;
    
    // copy the filters, package name, flags and locale.
    wcscpy(m_szfilter, szfilter);
    
    wcscpy(m_szPackageName, szPackageName);
    
    m_dwAppFlags = dwAppFlags;
        
    if (gDebug)
    {
        WCHAR   Name[32];
        DWORD   NameSize = 32;
    
        if ( ! GetUserName( Name, &NameSize ) )
            CSDBGPrint((L"CEnumPackage::Initialize GetUserName failed 0x%x", GetLastError()));
        else
            CSDBGPrint((L"CEnumPackage::Initialize as %s", Name));
    }
    
    // open the package container.
    hr = ADSIOpenDSObject(szPackageName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
        &m_hADs);
    ERROR_ON_FAILURE(hr);
    
    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = 20;

	
    hr = ADSISetSearchPreference(m_hADs, SearchPrefs, 2);
    ERROR_ON_FAILURE(hr);
    
    // copy platform
    if (pPlatform)
    {
        m_pPlatform = (CSPLATFORM *) CoTaskMemAlloc(sizeof(CSPLATFORM));
        if (!m_pPlatform)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        memcpy (m_pPlatform, pPlatform, sizeof(CSPLATFORM));
    }
    
    // execute the search and keep the handle returned.
    hr = ADSIExecuteSearch(m_hADs, szfilter, pszPackageInfoAttrNames,
        cPackageInfoAttr, &m_hADsSearchHandle);

Error_Cleanup:
    return RemapErrorCode(hr, m_szPackageName);
}

CEnumPackage::~CEnumPackage()
{
    if (m_hADsSearchHandle)
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
    
    if (m_hADs)
        ADSICloseDSObject(m_hADs);
    
    if (m_szfilter)
        CoTaskMemFree(m_szfilter);
    
    if (m_pPlatform)
        CoTaskMemFree(m_pPlatform);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\cslang.cxx ===
//+--------------------------------------------------------------------
//
//  Author: AdamEd
//  Date:   October 1998
//
//  Implementation of language support
//  in the Class Store interface module
//
//
//---------------------------------------------------------------------


#include "cstore.hxx"

LANGID gSystemLangId;


//+--------------------------------------------------------------------
//
// InitializeLanguageSupport
//
// Routine Description: 
//
//     Called at dll init to initialize globals necessary for
//     language support
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     none
//---------------------------------------------------------------------
void InitializeLanguageSupport()
{
    gSystemLangId = GetSystemDefaultLangID();
}


DWORD GetLanguagePriority(LANGID PackageLangId, DWORD dwActFlags)
{
    //
    // If the activation flags indicate that we should always
    // match regardless of language, this package gets the highest
    // precedence
    //
    if (dwActFlags & ACTFLG_IgnoreLanguage) {
        return PRI_LANG_ALWAYSMATCH;
    }

    //
    // The ignore language flag was not specified by the admin,
    // so now we must examine the language id of the package to
    // determine its desirability.
    //

    //
    // First, match against the system locale's language --
    // exact matches get highest priority
    //
    if (gSystemLangId == PackageLangId)
    {
        return PRI_LANG_SYSTEMLOCALE;
    }

    //
    // Try English -- English should function on all systems
    //
    if (LANG_ENGLISH == PRIMARYLANGID(PackageLangId))
    {
        return PRI_LANG_ENGLISH;
    }

    //
    // If we couldn't get better matches, accept language neutral
    // packages as a last resort
    //
    if (LANG_NEUTRAL == PackageLangId) {
        return PRI_LANG_NEUTRAL;
    }

    //
    // We couldn't find a match -- return the smallest priority
    //

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csds.cxx ===
//
//  Author: DebiM
//  Date:   January 97
//  Revision History:
//          Made Changes for reimplementation with adsldpc interfaces.
//          UShaji, Mar 1998
//
//      Class Access Implementation
//
//      This source file contains implementations for IClassAccess
//      interface on CAppContainer object.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------
//

#include "cstore.hxx"

void
GetDefaultPlatform(CSPLATFORM *pPlatform);

HRESULT 
UsnGet(ADS_ATTR_INFO Attr, CSUSN *pUsn);

extern      CRITICAL_SECTION    ClassStoreBindList;

long CompareUsn(CSUSN *pUsn1, CSUSN *pUsn2)
{
    return CompareFileTime((FILETIME *)pUsn1, (FILETIME *)pUsn2);
}
 
//
// CAppContainer implementation
//
CAppContainer::CAppContainer()

{
    m_fOpen = FALSE;

    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;

    m_szPackageName = NULL;
    m_szClassName = NULL;

    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));

    m_KnownMissingClsidCache.sz = 0;
    m_KnownMissingClsidCache.start = 0;
    m_KnownMissingClsidCache.end = 0;
    
    m_uRefs = 1;
}


//
// CAppContainer implementation
// 

/*----------------------------------------------------------------------*
CAppContainer Constructor:

  Parameters:
  [in]  szStoreName:    The Class Store Name without 'ADCS:' moniker
  [out] phr             The Error Code returned.
  
    Remarks: Tries to Bind to Base Class Store Container, get the version
    Number and Packages and Classes container underneath.
    
      Initializes members corresp. to their Names
      
        Return Codes:
        Success     S_OK
        Failures    CS_E_INVALID_VERSION
        Look at RemapErrorCodes
        
*----------------------------------------------------------------------*/
CAppContainer::CAppContainer(LPOLESTR szStoreName,
                             HRESULT  *phr)
                             
{
    LPOLESTR            pszName = NULL;
    DWORD               dwStoreVersion = 0;
    LPOLESTR            AttrNames[] = {STOREVERSION, POLICYDN, POLICYNAME};
    DWORD               posn = 0, cgot = 0;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    ADS_ATTR_INFO     * pAttrsGot = NULL;
    
    *phr = S_OK;
    
    // set the search preference for the search Handle
    
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = 20;
        
    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));

    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szPackageName = NULL;
    m_szClassName = NULL;

    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));

    m_KnownMissingClsidCache.sz = 0;
    m_KnownMissingClsidCache.start = 0;
    m_KnownMissingClsidCache.end = 0;

    m_uRefs = 1;
    //
    // For every interface pointer, we create a separate session
    //
    
    
    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);
    
    *phr = ADSIOpenDSObject(m_szContainerName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
        &m_ADsContainer);
    
    ERROR_ON_FAILURE(*phr);    
    //
    // Check the Schema Version of this container
    //
    
    *phr = ADSIGetObjectAttributes(m_ADsContainer, AttrNames, 3, &pAttrsGot, &cgot);
    
    if ((SUCCEEDED(*phr)) && (cgot))
    {

        posn = GetPropertyFromAttr(pAttrsGot, cgot, STOREVERSION);
        dwStoreVersion = 0;
        if (posn < cgot)
        {
            UnpackDWFrom(pAttrsGot[posn], &dwStoreVersion);
        }
        
        if (dwStoreVersion != SCHEMA_VERSION_NUMBER)
        {
            CSDBGPrint((L"CS: .. Wrong Version of Class Container:%s",
                m_szContainerName));
            *phr = CS_E_INVALID_VERSION;
        }
        
        
        if (SUCCEEDED(*phr))
        {
            LPOLESTR        szPolicyPath = NULL, szPolicyName = NULL;

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYDN);
            if (posn < cgot)
            {
                LPOLESTR        szParentPath = NULL, szPolicyGuid = NULL;
                
                UnpackStrFrom(pAttrsGot[posn], &szPolicyPath); 
                //

                BuildADsParentPath(szPolicyPath, &szParentPath, &szPolicyGuid);
                if (szParentPath)
                    FreeADsMem(szParentPath);

                if (szPolicyGuid)
                {
                    if (wcslen(szPolicyGuid) == 41)
                    {
                        // valid GUID

                        GUIDFromString(&szPolicyGuid[4], &m_PolicyId);
                    }
                    FreeADsMem(szPolicyGuid);
                }
            }

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYNAME);
            if (posn < cgot)
            {
                UnpackStrAllocFrom(pAttrsGot[posn], &m_szPolicyName); 
            }
               
        }
    }
    else
    {
        if (SUCCEEDED(*phr))
        {
            CSDBGPrint((L"CS: .. Wrong Version of Class Container:%s",
                       m_szContainerName));
            *phr = CS_E_INVALID_VERSION;
        }
    }
    
    if (pAttrsGot)
        FreeADsMem(pAttrsGot);
    
    ERROR_ON_FAILURE(*phr);
    
    m_szClassName = NULL;
    
    BuildADsPathFromParent(m_szContainerName, CLASSCONTAINERNAME, &m_szClassName);
            
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    BuildADsPathFromParent(m_szContainerName, PACKAGECONTAINERNAME, &m_szPackageName);
    
    m_ADsPackageContainer = NULL;
    

    *phr = ADSIOpenDSObject(m_szPackageName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
        &m_ADsPackageContainer);

    ERROR_ON_FAILURE(*phr);

    CSDBGPrint((L"PackageContainer handle 0x%x", m_ADsPackageContainer));
    
    
    *phr = ADSISetSearchPreference(m_ADsPackageContainer, SearchPrefs, 2);
    ERROR_ON_FAILURE(*phr);
    
    m_fOpen = TRUE;
    CSDBGPrint((L".. Connected to Class Container:%s",
        m_szContainerName));
    
    m_uRefs = 1;
    
Error_Cleanup:
    *phr = RemapErrorCode(*phr, m_szContainerName);
    return;
}


/*----------------------------------------------------------------------*
CAppContainer Destructor:

  
    Parameters:
      None

    Function:
      Destroys CAppContainer object.
    
    Remarks:
     Frees all the members.
     Return Codes
*----------------------------------------------------------------------*/


CAppContainer::~CAppContainer(void)
{
    UINT i;
    
    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }
    
    if (m_szClassName)
    {
        FreeADsMem(m_szClassName);
    }
  

    if (m_ADsPackageContainer)
    {
        ADSICloseDSObject(m_ADsPackageContainer);
        m_ADsPackageContainer = NULL;
        FreeADsMem(m_szPackageName);
    }
    
    if (m_ADsContainer)
    {
        ADSICloseDSObject(m_ADsContainer);
        m_ADsContainer = NULL;
    }
    
    if (m_szPolicyName)
    {
        CoTaskMemFree(m_szPolicyName);
    }
}

/*----------------------------------------------------------------------*
GetPackageDetails:

  Parameters:
  [in]  pszPackageName:    The Package Name
  [out] pPackageDetail     Package Detail Structure.
  
    Functionality:
    Returns the PackageDetail corresp. to a Package given
    by pszPackageName.
    
      Remarks:  
      It constructs the Full Package Name
      and calls GetPackageDetail
      
        Return Codes:
        Success     S_OK
        Failures    Look at RemapErrorCodes
        
*----------------------------------------------------------------------*/
        
// This is not being called currently by anybody and hence is still using PackageId.
HRESULT CAppContainer::GetPackageDetails (
                                          LPOLESTR         pszPackageId,
                                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL, szRDN[_MAX_PATH];
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot;
    
    if ((!pszPackageId) || IsBadStringPtr(pszPackageId, _MAX_PATH))
        return E_INVALIDARG;
    
    wsprintf(szRDN, L"CN=%s", pszPackageId);
    CSDBGPrint((L"GetPackageDetails called for %s", szRDN));
    
    BuildADsPathFromParent(m_szPackageName, szRDN, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hADs);
    ERROR_ON_FAILURE(hr);
    
    hr = GetPackageDetail (hADs, m_szClassName, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        FreeADsMem(szFullName);
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}
        

/*----------------------------------------------------------------------*
EnumPackages

  Parameters:
  [in] pszPackageName     Substring match for a package name
  [in] pCategory          Package Category.
  [in] pLastUsn           Last modification time.
  [in] dwAppFlags         Set the following bits to select specific ones
  Published Only  APPINFO_PUBLISHED
  Assigned Only   APPINFO_ASSIGNED
  Msi Only        APPINFO_MSI
  Visible         APPINFO_VISIBLE
  Auto-Install    APPINFO_AUTOINSTALL
  
    All Locale      APPINFO_ALLLOCALE
    All Platform    APPINFO_ALLPLATFORM
    
      [out] ppIEnumPackage   Returns the Enumerator 
      
        Functionality
        Obtains an enumerator for packages in the app container.
        
          Remarks:
          
*----------------------------------------------------------------------*/

HRESULT CAppContainer::EnumPackages (
                                     LPOLESTR        pszPackageName,
                                     GUID            *pCategory,
                                     ULONGLONG       *pLastUsn,
                                     DWORD           dwAppFlags,      // AppType options
                                     IEnumPackage    **ppIEnumPackage
                                     )
{
    HRESULT                 hr = S_OK;
    CEnumPackage           *pEnum = NULL;
    WCHAR                   szLdapFilter [2000];
    UINT                    len = 0;
    UINT                    fFilters = 0;
    CSPLATFORM              *pPlatform = NULL, Platform;
    
    //
    // Validate
    //
    
    if (!IsValidPtrOut(ppIEnumPackage, sizeof(IEnumPackage *)))
        return E_INVALIDARG;
    
    if (pszPackageName && (IsBadStringPtr(pszPackageName, _MAX_PATH)))
        return E_INVALIDARG;
    
    if (pCategory && !IsValidReadPtrIn(pCategory, sizeof(GUID)))
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    //pEnum = new CEnumPackage;
    pEnum = new CEnumPackage(m_PolicyId, m_szPolicyName);
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a LDAP Search Filter based on input params
    //
    
    // Count Filters    
    if (pszPackageName && (*pszPackageName))
        fFilters++;
    if ((pLastUsn) && (*pLastUsn))
        fFilters++;
    if (pCategory)
        fFilters++;
    if (dwAppFlags & APPINFO_ASSIGNED)  
        fFilters++;
    
    if (fFilters == 0)
    {
        // No Conditionals
        wsprintf (szLdapFilter,
            L"(%s=%s)", OBJECTCLASS, CLASS_CS_PACKAGE);
        
        len = wcslen (szLdapFilter);
    }
    else
    {
        
        if (fFilters > 1)
        {
            wsprintf (szLdapFilter, L"(&");
            len = wcslen (szLdapFilter);
        }
        else
            len = 0;
        
        if (pszPackageName)
        {
            //
            // Validate 
            //
            
            if (IsBadStringPtr(pszPackageName, _MAX_PATH))
                return E_INVALIDARG;
            
            if (*pszPackageName)
            {
                wsprintf (&szLdapFilter[len], 
                    L"(%s=*%s*)", 
                    PACKAGENAME,
                    pszPackageName);
                
                len = wcslen (szLdapFilter);
            }
        }
        
        if ((pLastUsn) && (*pLastUsn))
        {
            //
            // Validate 
            //
            
            SYSTEMTIME SystemTime;
            
            if (!IsValidReadPtrIn(pLastUsn, sizeof(ULONGLONG)))
                return E_INVALIDARG;
            
            FileTimeToSystemTime(
                (CONST FILETIME *) pLastUsn, 
                &SystemTime);  
            
            wsprintf (&szLdapFilter[len], 
                L"(%s>=%04d%02d%02d%02d%02d%02d)", 
                PKGUSN,
                SystemTime.wYear,
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond+1);
            
            len = wcslen (szLdapFilter);
        }
        
        if (pCategory)
        {
            //
            // Validate 
            //
            STRINGGUID szCat;
            
            if (!IsValidReadPtrIn(pCategory, sizeof(GUID)))
                return E_INVALIDARG;
            
            StringFromGUID (*pCategory, szCat);
            wsprintf (&szLdapFilter[len], 
                L"(%s=%s)", 
                PKGCATEGORYLIST,
                szCat);
            
            len = wcslen (szLdapFilter);
        }
        
        if (dwAppFlags & APPINFO_ASSIGNED)  
            // if only Assigned Packages are in demand
        {
            wsprintf (&szLdapFilter[len], 
                L"(%s>=%d)", 
                PACKAGEFLAGS,
                (ACTFLG_Assigned));
            
            len = wcslen (szLdapFilter);
        }
        
        if (fFilters > 1)
        {
            szLdapFilter[len] = L')';
            szLdapFilter[++len] = NULL;
        }
    }     
    

    CSDBGPrint((L"EnumPackage Called:: Search filter created is %s, Appflags = %d", szLdapFilter, dwAppFlags));

    //
    // Check all local/platform flags
    //
    
    if (dwAppFlags & APPINFO_ALLPLATFORM)
    {
        pPlatform = NULL;
    }
    else
    {
        pPlatform = &Platform;
        GetDefaultPlatform(pPlatform);
    }
    
    if (pLastUsn)
    {
        //
        // Find the current store USN and return it
        //
        LPOLESTR            AttrName = STOREUSN;
        ADS_ATTR_INFO     * pAttr = NULL;
        DWORD               cgot = 0;
        
        hr = ADSIGetObjectAttributes(m_ADsContainer, &AttrName, 1, &pAttr, &cgot);
        if ((SUCCEEDED(hr)) && (cgot))
        {
            UsnGet(*pAttr, (CSUSN *)pLastUsn);
            if (pAttr)
                FreeADsMem(pAttr);
        }
    }
    
    hr = pEnum->Initialize(m_szPackageName, szLdapFilter, dwAppFlags, pPlatform);
    ERROR_ON_FAILURE(hr);
    
    hr = pEnum->QueryInterface(IID_IEnumPackage,(void**) ppIEnumPackage);
    ERROR_ON_FAILURE(hr);    
    
    return S_OK;
    
Error_Cleanup:
    if (pEnum)
        delete pEnum;
    *ppIEnumPackage = NULL;
    
    return RemapErrorCode(hr, m_szContainerName);
}


DWORD GetTime()
{
    return (GetTickCount()/1000);
}

BOOL IsExpired(DWORD dwCurrentTime, DWORD Time, DWORD Tolerance)
{
    if (Time > dwCurrentTime)
        return TRUE;
     
    if ((Time+Tolerance) < dwCurrentTime) 
        return TRUE;

    return FALSE;
}

// choosing the best package that can be returned after returning from the DS
DWORD CAppContainer::ChooseBestFit(PACKAGEDISPINFO *PackageInfo, UINT *rgPriority, DWORD cRowsFetched)
{
    DWORD i=0, k=0, j = 0, temp = 0;
    DWORD index[10];
    
    CSDBGPrint((L"Entering ChooseBestFit")); 

    // initialising the indices
    for (i = 0; (i <  cRowsFetched); i++)
        index[i] = i;
    
    // sort the index based on priority and time stamp
    for (i = 0; (i < (cRowsFetched-1)); i++)
    {
        DWORD Pri = rgPriority[i];
        k = i;
        // max element's index is in k
        for (j=(i+1); (j < cRowsFetched); ++j)
        {
            // order first by weight and then by time stamp.
            if ((rgPriority[index[j]] > Pri) || 
                ((rgPriority[index[j]] == Pri) && 
                 (CompareUsn((FILETIME *)&PackageInfo[index[j]].Usn, (FILETIME *)&PackageInfo[index[k]].Usn) == 1))) 
            {
                Pri = rgPriority[index[j]];
                k = j;
            }
        }

        if (k != i)
        {
            temp = index[k];
            index[k] = index[i];
            index[i] = temp;
        }
    }

    DWORD dwPackage;
    DWORD dwBestPackage;

    dwBestPackage = 0;

    //
    // Now the packages are sorted in order from highest precedence to lowest.
    // We will now check for upgrades for each package
    //
    for (dwPackage = 0; (dwPackage < cRowsFetched); dwPackage++)
    {
        DWORD            dwPossibleUpgrader;
        PACKAGEDISPINFO* pBestPackage;

        pBestPackage = PackageInfo+index[dwBestPackage];        

        CSDBGPrint((L"Processing Package %s", pBestPackage->pszPackageName));

        //
        // Now search for someone that upgrades the current choice -- look at all packages
        // after the current one since we've already determined that the packages before
        // this one got upgraded (otherwise we wouldn't be here).
        //
        for (dwPossibleUpgrader = dwPackage + 1; dwPossibleUpgrader < cRowsFetched; dwPossibleUpgrader ++)
        {
            PACKAGEDISPINFO* pUpgraderCandidate;

            //
            // Obviously, we don't need to check the current choice
            // to see if it upgrades itself, so skip it
            //
            if (dwPossibleUpgrader == dwBestPackage) 
            {
                continue;
            }

            pUpgraderCandidate = PackageInfo + index[dwPossibleUpgrader];

            //
            // See if the upgrader candidate has any upgrades, if not, keep looking
            //
            if (0 == pUpgraderCandidate->cUpgrades) 
            {
                continue;
            }

            //
            // Now we have to see if any of those upgrades apply to the package we have
            // currently selected as the best
            //
            DWORD dwUpgrade;
            BOOL  fFoundUpgrade;

            fFoundUpgrade = FALSE;

            for (dwUpgrade = 0; dwUpgrade < pUpgraderCandidate->cUpgrades; dwUpgrade++) 
            {
                DWORD dwValidUpgradeMask;

                dwValidUpgradeMask = UPGFLG_Uninstall |
                    UPGFLG_NoUninstall |
                    UPGFLG_Enforced;

                //
                // If this is a valid upgrade
                //
                if (pUpgraderCandidate->prgUpgradeInfoList[dwUpgrade].Flag & dwValidUpgradeMask)
                {
                    //
                    // Does it upgrade the package we think is best at this point? We only
                    // consider upgrades in this container, as we no longer allow upgrades from lower
                    // precedence class stores -- the caller who iterates through each container from
                    // highest precedence to lowest will simply choose the app from the first container in which
                    // we have a match.
                    // 
                    // We use memcmp to compare guids to see if the best choice package's guid is listed
                    // as being upgraded by this upgrade candidate
                    //
                    if (memcmp(&((pUpgraderCandidate->prgUpgradeInfoList)[dwUpgrade].PackageGuid),
                               &(pBestPackage->PackageGuid), sizeof(GUID) == 0))
                    {
                        //
                        // We have a match -- reset the current best choice to the upgrade candidate
                        //
                        dwBestPackage = dwPossibleUpgrader;
                    
                        //
                        // another package upgrades this -- no need to look any further, so we quit
                        //
                        CSDBGPrint((L"Ignoring Package %s because it is getting upgraded in the same store", pBestPackage->pszPackageName));
                        break;
                    }
                }
            }

            //
            // If we found an upgrade in the list above, we can stop abort the search for an upgrade now --
            // if we found another, it would just be a lower precedence app since we're iterating from highest to lowest,
            // and we want the highest predecence app that upgrades the currently chosen best app
            //
            if (fFoundUpgrade) 
            {
                break;
            }
        }
    }

    DWORD dwChoice;
     
    dwChoice = index[dwBestPackage];

    CSDBGPrint((L"Selecting Package %s as the Best Fit", PackageInfo[dwChoice].pszPackageName)); 

    return dwChoice;
}

//
// CAppContainer::GetAppInfo
// -----------------------------
//
//
//
//  Synopsis:       This is the most common access point to the Class Store.
//                  It receives a CLSID and a QUERYCONTEXT.
//                  It looks up the Class Store container for a matching set
//                  of packages with in the context of the QUERYCONTEXT.
//
//                  QUERYCONTEXT includes
//                      Execution Context
//                      Locale Id
//                      Platform/OS
//
//                  If i finds an app that matches the requirements, it returns
//                  an PACKAGEDISPINFO structure containing installation details.
//
//  Arguments:      [in]  clsid
//                  [in]  pQryContext
//                  [out] pPackageInfo
//
//  Returns:        CS_E_PACKAGE_NOTFOUND
//                  S_OK
//
//
//

HRESULT STDMETHODCALLTYPE
CAppContainer::GetAppInfo(
                          uCLSSPEC       *   pclsspec,          // Class Spec (GUID/Ext/MIME)
                          QUERYCONTEXT   *   pQryContext,       // Query Attributes
                          PACKAGEDISPINFO    *   pPackageInfo
                          )
                          
                          //
                          // This is the most common method to access the Class Store.
                          // It queries the class store for implementations for a specific
                          // Class Id, or File Ext, or ProgID.
                          //
                          // If a matching implementation is available (for the object type,
                          // client architecture, locale and class context) then the installation
                          // parameters of the package is returned.
{
    GUID        clsid;
    WCHAR       szfilter[1000];
    STRINGGUID  szClsid;
    UINT        i, iClsid = 0;
    ULONG       cRead;
    HRESULT     hr;
    ULONG       cSize = _MAX_PATH;
    BOOL        fFound = FALSE;
    PLATFORMINFO PlatformInfo;
    LPOLESTR    pFileExt = NULL;
    BOOL        OnDemandInstallOnly = TRUE;
    WCHAR       FileExtLower [10];
    DWORD       dwCurrentTime = GetTime();

    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));
    
    if (!m_fOpen)
        return E_FAIL;
    
    //
    // Check if the TypeSpec is MIMEType
    // then map it to a CLSID
    //
    
    if (pclsspec->tyspec == TYSPEC_MIMETYPE)
    {
        //
        // BUGBUG.
        //     Considering removal of MimeType support from Class Store
        //     Till it is decided the code is OUT.
        
        return E_NOTIMPL;
        
        /*
        if (IsBadStringPtr(pclsspec->tagged_union.pMimeType, _MAX_PATH))
        return E_INVALIDARG;
        
          if ((pclsspec->tagged_union.pMimeType == NULL) ||
          (*(pclsspec->tagged_union.pMimeType) == NULL))
          return E_INVALIDARG;
          
            wsprintf (szfilter,
            L"<%s>;(%s=%s);name",
            m_szClassName, MIMETYPES, pclsspec->tagged_union.pMimeType);
        */
    }
    
    switch (pclsspec->tyspec)
    {
    case TYSPEC_TYPELIB:        // leaving it here. 
        if (IsNullGuid(pclsspec->tagged_union.typelibID))
            return E_INVALIDARG;
        StringFromGUID (pclsspec->tagged_union.typelibID, szClsid);
        wsprintf (szfilter,
            L"(%s=%s)", PKGTLBIDLIST, szClsid);
        break;
        
    case TYSPEC_IID:
        if (IsNullGuid(pclsspec->tagged_union.iid))
            return E_INVALIDARG;
        StringFromGUID (pclsspec->tagged_union.iid, szClsid);
        wsprintf (szfilter,
            L"(%s=%s)", PKGIIDLIST, szClsid);
        break;
        
    case TYSPEC_CLSID:

        if (IsNullGuid(pclsspec->tagged_union.clsid))
            return E_INVALIDARG;
        //
        // Check against known missing ones
        //
       
        hr = S_OK;

        EnterCriticalSection (&ClassStoreBindList);

        for (iClsid=m_KnownMissingClsidCache.start; (iClsid  != m_KnownMissingClsidCache.end); 
                        iClsid = (iClsid+1)%(CLSIDCACHESIZE))
        {
            if (IsExpired(dwCurrentTime, m_KnownMissingClsidCache.ElemArr[iClsid].Time, CACHE_PURGE_TIME))
            {
                // all the prev. elems must have expired.

                // delete this element
                m_KnownMissingClsidCache.start = (m_KnownMissingClsidCache.start+1)%CLSIDCACHESIZE;
                m_KnownMissingClsidCache.sz--;

                CSDBGPrint((L"Expiring element in CLSID Cache"));
                // iClsid will be moved automatically.
                continue;
            }

            if ((IsEqualGUID(pclsspec->tagged_union.clsid, 
                            m_KnownMissingClsidCache.ElemArr[iClsid].Clsid)) && 
                ((pQryContext->dwContext) == m_KnownMissingClsidCache.ElemArr[iClsid].Ctx))
            {
                CSDBGPrint((L"Clsid Found in MISSING Cache"));
                hr = CS_E_PACKAGE_NOTFOUND;
                break;
            }
        }

        LeaveCriticalSection (&ClassStoreBindList);

        if (hr == CS_E_PACKAGE_NOTFOUND)
            return hr;        

        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);
        wsprintf (szfilter, L"(%s=%s*)", PKGCLSIDLIST, szClsid);
        break;
        
    case TYSPEC_FILEEXT:
        
        if (IsBadStringPtr(pclsspec->tagged_union.pFileExt, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.pFileExt == NULL) ||
            (*(pclsspec->tagged_union.pFileExt) == NULL))
            return E_INVALIDARG;
        
      
        if (wcslen(pclsspec->tagged_union.pFileExt) > 9)
            return E_INVALIDARG;

        wcscpy (&FileExtLower[0], pclsspec->tagged_union.pFileExt);
        _wcslwr (&FileExtLower[0]);
        
        wsprintf (szfilter,
            L"(%s=%s*)",
            PKGFILEEXTNLIST, &FileExtLower[0]);
        
        pFileExt = &FileExtLower[0];
        break;
        
        
    case TYSPEC_PROGID:
        
        if (IsBadStringPtr(pclsspec->tagged_union.pProgId, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.pProgId == NULL) ||
            (*(pclsspec->tagged_union.pProgId) == NULL))
            return E_INVALIDARG;
        
        wsprintf (szfilter,
            L"(%s=%s)", PKGPROGIDLIST, pclsspec->tagged_union.pProgId);
        break;
        
    case TYSPEC_PACKAGENAME:
        //
        // Validate package name
        //
        
        if (IsBadStringPtr(pclsspec->tagged_union.ByName.pPackageName, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.ByName.pPackageName == NULL) ||
            (*(pclsspec->tagged_union.ByName.pPackageName) == NULL))
            return E_INVALIDARG;
        
        wsprintf (szfilter, L"(%s=%s)", PACKAGENAME, pclsspec->tagged_union.ByName.pPackageName);             
        OnDemandInstallOnly = FALSE;
        break;
    
    case TYSPEC_SCRIPTNAME:
        //
        // Validate script name
        //
        
        if (IsBadStringPtr(pclsspec->tagged_union.ByScript.pScriptName, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.ByScript.pScriptName == NULL) ||
            (*(pclsspec->tagged_union.ByScript.pScriptName) == NULL))
            return E_INVALIDARG;
        
        wsprintf (szfilter, L"(%s=*%s*)", SCRIPTPATH, pclsspec->tagged_union.ByScript.pScriptName);             

        OnDemandInstallOnly = FALSE;
        break;
        
    default:
        return E_NOTIMPL;
    }
    
    //
    //
    ULONG              cRowsFetched;
    PACKAGEDISPINFO    PackageInfo[10];
    UINT               rgPriority [10];

    ADS_SEARCH_HANDLE  hADsSearchHandle = NULL;
    
    CSDBGPrint((L"PackageContainer handle 0x%x", m_ADsPackageContainer));

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, pszInstallInfoAttrNames, cInstallInfoAttr, &hADsSearchHandle);
    CSDBGPrint((L"CAppContainer::GetAppInfo  search filter %s", szfilter));
    ERROR_ON_FAILURE(hr);    
    
    //
    // BUGBUG. Currently limited to 10.
    // Must put a loop to retry more in future.
    //
    hr = FetchInstallData(m_ADsPackageContainer,
        hADsSearchHandle,
        pQryContext,
        pclsspec,
        pFileExt,
        10,
        &cRowsFetched,
        &PackageInfo[0],
        &rgPriority[0],
        OnDemandInstallOnly
        );
    
    CSDBGPrint((L"CAppContainer::FetchInstallData returned 0x%x", hr));
    CSDBGPrint((L"CAppContainer::FetchInstallData returned %d Packages", cRowsFetched));
    
    if (cRowsFetched == 0)
    {
        hr = CS_E_OBJECT_NOTFOUND;
        //
        // If CLSID was passed cache the miss
        //
        if (pclsspec->tyspec == TYSPEC_CLSID)
        {
            EnterCriticalSection (&ClassStoreBindList);

            if (m_KnownMissingClsidCache.sz < (CLSIDCACHESIZE-1))
            {
                memcpy (&m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Clsid, 
                        &(pclsspec->tagged_union.clsid), sizeof(GUID));

                m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Ctx
                                    = pQryContext->dwContext;

                m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Time 
                                    = dwCurrentTime;
                                    
                m_KnownMissingClsidCache.sz++;

                m_KnownMissingClsidCache.end = (m_KnownMissingClsidCache.end+1) % CLSIDCACHESIZE;

                CSDBGPrint((L"Adding Element to the clsid cache"));

            }
            LeaveCriticalSection (&ClassStoreBindList);
        }
    }
    else
    {
        DWORD dwChoice = 0;

        if (cRowsFetched > 1)
        {            
            dwChoice = ChooseBestFit(PackageInfo, rgPriority, cRowsFetched);
        }
        

        memcpy (pPackageInfo, &PackageInfo[dwChoice], sizeof(PACKAGEDISPINFO));
        memset (&PackageInfo[dwChoice], NULL, sizeof(PACKAGEDISPINFO));
        
        // Clean up all allocations
        for (i=0; i < cRowsFetched; i++)
        {
            ReleasePackageInfo(&PackageInfo[i]);
        }
    }
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    
    //
    // fill in PolicyID and Name
    //
    if (SUCCEEDED(hr))
    {
        memcpy (&(pPackageInfo->GpoId), &m_PolicyId, sizeof(GUID));
        if (m_szPolicyName && (*m_szPolicyName))
        {
            pPackageInfo->pszPolicyName = (LPOLESTR) CoTaskMemAlloc(sizeof(WCHAR) * (1+wcslen(m_szPolicyName)));
            if (pPackageInfo->pszPolicyName)
                wcscpy (pPackageInfo->pszPolicyName, m_szPolicyName);
            else {
                ReleasePackageInfo(pPackageInfo);
                memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));
                return E_OUTOFMEMORY;
            }
        }
    }
    
Error_Cleanup:
    CSDBGPrint((L"CAppContainer::GetAppInfo returning 0x%x", RemapErrorCode(hr, m_szContainerName)));
    return RemapErrorCode(hr, m_szContainerName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csdsadm.cxx ===
//
//  Author: DebiM
//  Date:   January 97
//
//
//      Class Store Administration Implementation
//
//      This source file contains implementations for
//      IClassAdmin interface.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------

#include "cstore.hxx"

// utility functions
HRESULT UpdateStoreUsn(HANDLE hADs, LPOLESTR szUsn)
{
    ADS_ATTR_INFO       pAttr[1];   
    DWORD               cModified = 0;
    HRESULT             hr = S_OK;
    
    PackStrToAttr(pAttr, STOREUSN, szUsn);
    hr = ADSISetObjectAttributes(hADs, pAttr, 1, &cModified);
    FreeAttr(pAttr[0]);
    return hr;
}



//----------------------------------------------------------
// Implementation for CClassContainer
//----------------------------------------------------------
//
CClassContainer::CClassContainer()

{
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_ADsCategoryContainer = NULL;
    m_szCategoryName = NULL;
    m_szPackageName = NULL;
    m_szClassName = NULL;

    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));
    
    m_uRefs = 1;
}


//---------------------------------------------------------------
//
//  Function:   Constructor
//
//  Synopsis:   Binds to the ClassStore given a class store path.
//
//  Arguments:
//  [in]    
//      szStoreName
//              Class Store Path without the leading ADCS:
//           
//  [out]
//      phr     
//              Sucess code.
//
//  Does an ADSI bind at the class store container and matches the
//  version numbers. if the version numbers match then it binds to the
//  class, package and category containers and keeps the bind handles.
//----------------------------------------------------------------

CClassContainer::CClassContainer(LPOLESTR szStoreName,
                                 HRESULT  *phr)
                                 
{
    DWORD               dwStoreVersion = 0;
    LPOLESTR            AttrNames[] = {STOREVERSION, POLICYDN, POLICYNAME};
    ADS_ATTR_INFO     * pAttrsGot = NULL;
    DWORD               cgot = 0, posn = 0;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    
    // set the search preference to one level search
    // and make the results come back in batches of size
    // 20 as default.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = 20;
    // BUGBUG: This should be defined as a constant.

    // initialising.
    *phr = S_OK;

    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_ADsCategoryContainer = NULL;
    m_szCategoryName = NULL;
    m_szPackageName = NULL;
    m_szClassName = NULL;    
    
    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));

    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);
    
    *phr = ADSIOpenDSObject(m_szContainerName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &m_ADsContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    //
    // Check the Schema Version of this container
    //
    
    *phr = ADSIGetObjectAttributes(m_ADsContainer, AttrNames, 3, &pAttrsGot, &cgot);
    
    if ((SUCCEEDED(*phr)) && (cgot))
    {
        posn = GetPropertyFromAttr(pAttrsGot, cgot, STOREVERSION);
        dwStoreVersion = 0;
        if (posn < cgot)
        {
            UnpackDWFrom(pAttrsGot[posn], &dwStoreVersion);
        }
        
        if ((!SUCCEEDED(*phr)) ||
            (dwStoreVersion != SCHEMA_VERSION_NUMBER))
        {
            *phr = CS_E_INVALID_VERSION;
        }

        if (SUCCEEDED(*phr))
        {
            LPOLESTR        szPolicyPath = NULL, szPolicyName = NULL;

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYDN);
            if (posn < cgot)
            {
                LPOLESTR        szParentPath = NULL, szPolicyGuid = NULL;
                
                UnpackStrFrom(pAttrsGot[posn], &szPolicyPath); 
                //

                BuildADsParentPath(szPolicyPath, &szParentPath, &szPolicyGuid);
                if (szParentPath)
                    FreeADsMem(szParentPath);

                if (szPolicyGuid)
                {
                    if (wcslen(szPolicyGuid) == 41)
                    {
                        // valid GUID

                        GUIDFromString(&szPolicyGuid[4], &m_PolicyId);
                    }
                    FreeADsMem(szPolicyGuid);
                }
            }

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYNAME);
            if (posn < cgot)
            {
                UnpackStrAllocFrom(pAttrsGot[posn], &m_szPolicyName); 
            }
        }
    }
    else
    {
        *phr = CS_E_INVALID_VERSION;
    }
    
    if (pAttrsGot)
        FreeADsMem(pAttrsGot);

    ERROR_ON_FAILURE(*phr);
    
    //
    // Bind to the class container Object
    // Cache the interface pointer
    //
    
    // get the class container name.
    BuildADsPathFromParent(m_szContainerName, CLASSCONTAINERNAME, &m_szClassName);
    
    m_ADsClassContainer = NULL;
    
    // bind to the class container.
    *phr = ADSIOpenDSObject(m_szClassName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &m_ADsClassContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    // set the search preference on the handle.
    *phr = ADSISetSearchPreference(m_ADsClassContainer, SearchPrefs, 2);
    
    ERROR_ON_FAILURE(*phr);
    
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    // get the package container name.
    BuildADsPathFromParent(m_szContainerName, PACKAGECONTAINERNAME, &m_szPackageName);
    
    m_ADsPackageContainer = NULL;
    
    // bind to the package container.
    *phr = ADSIOpenDSObject(m_szPackageName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            &m_ADsPackageContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    // set the search preference.
    *phr = ADSISetSearchPreference(m_ADsPackageContainer, SearchPrefs, 2);
    ERROR_ON_FAILURE(*phr);
    
    //
    // Bind to the category container Object
    // Cache the interface pointer
    //

    // get the category container name
    BuildADsPathFromParent(m_szContainerName, CATEGORYCONTAINERNAME, &m_szCategoryName);
    
    m_ADsCategoryContainer = NULL;
    
    // bind to the category container.
    *phr = ADSIOpenDSObject(m_szCategoryName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                            &m_ADsCategoryContainer);    
    ERROR_ON_FAILURE(*phr);
    
    // set the search preferences.
    *phr = ADSISetSearchPreference(m_ADsCategoryContainer, SearchPrefs, 2);
    ERROR_ON_FAILURE(*phr);
    
    m_fOpen = TRUE;
    m_uRefs = 1;
    
Error_Cleanup:
    *phr = RemapErrorCode(*phr, m_szContainerName);
    return;
}


CClassContainer::~CClassContainer(void)
{
    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }
    
    if (m_ADsClassContainer)
    {
        ADSICloseDSObject(m_ADsClassContainer);
        m_ADsClassContainer = NULL;
    }
    // the bind might have failed while we succeeded in getting a path.
    if (m_szClassName)
        FreeADsMem(m_szClassName);

    if (m_ADsPackageContainer)
    {
        ADSICloseDSObject(m_ADsPackageContainer);
        m_ADsPackageContainer = NULL;
    }

    if (m_szPackageName)
        FreeADsMem(m_szPackageName);
    
    if (m_ADsCategoryContainer)
    {
        ADSICloseDSObject(m_ADsCategoryContainer);
        m_ADsCategoryContainer = NULL;
    }
    
    if (m_szCategoryName)
        FreeADsMem(m_szCategoryName);

    if (m_ADsContainer)
    {
        ADSICloseDSObject(m_ADsContainer);
        m_ADsContainer = NULL;
    }
}

// currently unused.
BOOL InvalidDSName(LPWSTR pName)
{

    if (wcslen(pName) >= 56)
        return TRUE;

    while (*pName)
    {
        if ((*pName == L':') ||
            (*pName == L',') ||
            (*pName == L';') ||
            (*pName == L'/') ||
            (*pName == L'<') ||
            (*pName == L'>') ||
            (*pName == L'\\')||
            (*pName == L'+'))
            return TRUE;
        ++pName;
    }

    return FALSE;
}

HRESULT  CClassContainer::GetGPOInfo(GUID *pGPOId, LPOLESTR *pszPolicyName)
{
    if ((!pGPOId) || (!IsValidPtrOut(pGPOId, sizeof(GUID))))
        return E_INVALIDARG;

    if ((!pszPolicyName) || (!IsValidPtrOut(pszPolicyName, sizeof(LPOLESTR))))
        return E_OUTOFMEMORY;

    memcpy(pGPOId, &m_PolicyId, sizeof(GUID));

    if (m_szPolicyName)
    {
        *pszPolicyName = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(1+wcslen(m_szPolicyName)));
        if (!(*pszPolicyName))
            return E_INVALIDARG;
        wcscpy(*pszPolicyName, m_szPolicyName);
    }
    else
    {
        *pszPolicyName = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*2);
        if (!(*pszPolicyName))
            return E_OUTOFMEMORY;

        (*pszPolicyName)[0] = L'\0';
    }
    return S_OK;
}

//
// Removing a class from the database
//

//---------------------------------------------------------------
//
//  Function:   DeleteClass
//
//  Synopsis:   Internal function. Deletes the clsid from the ClassContainer.
//
//  UsedBy      RemovePackage
//
//
//  Arguments:
//  [in]    
//      szClsid
//              Stringised Clsid
//   
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the clsid object under the class container.
//  and decrements the reference count. If the reference
//  count goes to zero, then it deletes the clsid.
//  BUGBUG: If 2 objects try to delete it at the same
//  time this might not work properly.
//----------------------------------------------------------------

HRESULT CClassContainer::DeleteClass (LPOLESTR szClsid)
{
    WCHAR           szName[_MAX_PATH], *szFullName = NULL;
    HRESULT         hr = S_OK;
    DWORD           refcount = 0, cgot = 0, cAttr = 1, cModified = 0;
    HANDLE          hADs = NULL;
    LPOLESTR        AttrName = CLASSREFCOUNTER;
    ADS_ATTR_INFO * pAttr = NULL;
    ADS_ATTR_INFO   Attr;
    
    if (!m_fOpen)
        return E_FAIL;
        
    // constructs the fullname from the clsid and class container Name.
    wsprintf(szName, L"CN=%s", szClsid);
    BuildADsPathFromParent(m_szClassName, szName, &szFullName);
    
    // binds to the class object.
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADs);
    
    if (szFullName)
        FreeADsMem(szFullName);

    ERROR_ON_FAILURE(hr);

    // gets the reference count attribute.
    hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttr, &cgot);
    
    if ((SUCCEEDED(hr)) && (cgot))
        UnpackDWFrom(pAttr[0], (DWORD *)&refcount);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (refcount <= 1) {
        // Delete the object if the reference count is less than zero.
        hr = ADSIDeleteDSObject(m_ADsClassContainer, szName);
        if (hADs)
            ADSICloseDSObject(hADs);
    }
    else {
        // Decrement the reference count and store it back.
        refcount--;
        PackDWToAttr(&Attr, CLASSREFCOUNTER, refcount);
        hr = ADSISetObjectAttributes(hADs, &Attr, cAttr, &cModified);
        ADSICloseDSObject(hADs);
        FreeAttr(Attr);
    }
        
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//
//  Function:   EnumPackages
//
//  Synopsis:   Returns an Enumerator for all the packages that satisfies
//              the query.
//
//  UsedBy      Add/Remove Programs
//
//  Arguments:
//  [in]    
//      pszFileExt
//              FileExt that has to be queried on. ignored if NULL.
//      pCategory
//              Category that has to be queried on. ignored if NULL.
//      dwAppFlags
//              One of the APPINFO_XXX. ignored if it is APPINFO_ALL.
//      pdwLocale
//              Locale that has to be queried on. Ignored if NULL.
//      pPlatform
//              Platform that has to be queried on. Ignored if NULL.
//              
//  [out]
//      ppIEnumPackage
//              Enumerator is returned. 
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Validates the inputs, Creates a EnumPackage object, makes up the
//  search string made up of file extension, category.
//----------------------------------------------------------------
HRESULT CClassContainer::EnumPackages(
                                      LPOLESTR           pszFileExt,
                                      GUID              *pCategory,
                                      DWORD              dwAppFlags,
                                      DWORD             *pdwLocale,
                                      CSPLATFORM        *pPlatform,
                                      IEnumPackage     **ppIEnumPackage
                                      )
{
    HRESULT                     hr = S_OK;
    CEnumPackage               *pEnum = NULL;
    WCHAR                       szfilter[1000], szQry[1000];

    if (pszFileExt && IsBadStringPtr(pszFileExt, _MAX_PATH))
        return E_INVALIDARG;
    
    if (pCategory && !IsValidReadPtrIn(pCategory, sizeof(GUID)))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(ppIEnumPackage, sizeof(IEnumPackage *)))
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    pEnum = new CEnumPackage(m_PolicyId, m_szPolicyName);
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a CommandText
    //
    wsprintf(szfilter, L"(& (objectClass=%s) ", CLASS_CS_PACKAGE);
        
    if (pszFileExt)
    {
        wsprintf(szQry, L"(%s=%s*) ", PKGFILEEXTNLIST, pszFileExt);
        wcscat(szfilter, szQry);
    }
    
    if (pCategory)
    {
        STRINGGUID szCat;
        StringFromGUID (*pCategory, szCat);
        wsprintf(szQry, L"(%s=%s) ", PKGCATEGORYLIST, szCat);
        wcscat(szfilter, szQry);
    }
    
    wcscat(szfilter, L")");
    
    hr = pEnum->Initialize(m_szPackageName, szfilter,
        dwAppFlags, pPlatform);
    
    ERROR_ON_FAILURE(hr);
    
    hr = pEnum->QueryInterface(IID_IEnumPackage, (void**)ppIEnumPackage);
    ERROR_ON_FAILURE(hr);
    
    return S_OK;
    
Error_Cleanup:
    if (pEnum)
        delete pEnum;
    *ppIEnumPackage = NULL;
    
    return RemapErrorCode(hr, m_szContainerName);
}

HRESULT CClassContainer::GetDNFromPackageName(LPOLESTR pszPackageName, LPOLESTR *szDN)
{
    HRESULT             hr = S_OK;
    WCHAR               szfilter[_MAX_PATH];
    LPOLESTR            AttrNames[] = {OBJECTCLASS, PACKAGEFLAGS, OBJECTDN};
    DWORD               cAttr = 3;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;
    DWORD               dwFlags = 0;

    wsprintf(szfilter, L"%s=%s", PACKAGENAME, pszPackageName);

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, AttrNames, cAttr, &hADsSearchHandle);
    RETURN_ON_FAILURE(hr);    

    for (hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
	            ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS));
	            hr = ADSIGetNextRow(m_ADsPackageContainer, hADsSearchHandle))
    {
        hr = ADSIGetColumn(m_ADsPackageContainer, hADsSearchHandle, PACKAGEFLAGS, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwFlags);
            
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        else
            continue;

        if ((dwFlags & ACTFLG_Orphan) || (dwFlags & ACTFLG_Uninstall))
            continue;

        hr = ADSIGetColumn(m_ADsPackageContainer, hADsSearchHandle, OBJECTDN, &column);
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, szDN);
            
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        else
            continue;

        break;

    }
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    
    return hr;
}

// Gets the RDN of a package given the package Guid. 
HRESULT CClassContainer::BuildDNFromPackageGuid(GUID PackageGuid, LPOLESTR *szDN)
{
    HRESULT             hr = S_OK;
    LPOLESTR            AttrName = {OBJECTDN};
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;
    LPWSTR              EncodedGuid = NULL;

    hr = ADsEncodeBinaryData((PBYTE)&PackageGuid, sizeof(GUID), &EncodedGuid);

    wsprintf(szfilter, L"(%s=%s)", OBJECTGUID, EncodedGuid);

    FreeADsMem(EncodedGuid);

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, &AttrName, 1, &hADsSearchHandle);

    RETURN_ON_FAILURE(hr);

    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        ERROR_ON_FAILURE(hr = CS_E_PACKAGE_NOTFOUND);
    }

    hr = ADSIGetColumn(m_ADsPackageContainer, hADsSearchHandle, AttrName, &column);
    ERROR_ON_FAILURE(hr);

    if (SUCCEEDED(hr))
    {
        UnpackStrAllocFrom(column, szDN);
    }

    ADSIFreeColumn(m_ADsPackageContainer, &column);

Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    return hr;
}

HRESULT CClassContainer::GetPackageGuid(WCHAR *szRDN, GUID *pPackageGuid)
{
    HRESULT             hr = S_OK;
    LPOLESTR            AttrName = {OBJECTGUID};
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szRDN, &AttrName, 1, &hADsSearchHandle);

    RETURN_ON_FAILURE(hr);

    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        ERROR_ON_FAILURE(hr = CS_E_PACKAGE_NOTFOUND);
    }

    hr = ADSIGetColumn(m_ADsPackageContainer, hADsSearchHandle, AttrName, &column);
    ERROR_ON_FAILURE(hr);

    if (SUCCEEDED(hr))
        UnpackGUIDFrom(column, pPackageGuid);

    ADSIFreeColumn(m_ADsPackageContainer, &column);

Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    return hr;
}
//---------------------------------------------------------------
//
//  Function:   GetPackageDetails
//
//  Synopsis:   Returns the PackageDetail corresponding to the PackageName.
//
//  Arguments:
//  [in]    
//      pszPackageId
//              Id of the Package.
//  [out]
//      pPackageDetail
//              PackageDetail info that is returned.
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the Package object and calls GetPackageDetail with it.
//----------------------------------------------------------------
HRESULT CClassContainer::GetPackageDetails (
                                            LPOLESTR          pszPackageName,
                                            PACKAGEDETAIL   * pPackageDetail
                                            )
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL;
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot = 0;
    
    // this can be made into a search based API. Not required for the time being.
    // Should change it if perf is a big issue.
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    // binding to the package object.    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hADs);
    ERROR_ON_FAILURE(hr);
    
    // calling GetPackageDetail.
    hr = GetPackageDetail (hADs, m_szClassName, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        CoTaskMemFree(szFullName);
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//
//  Function:   GetPackageDetails
//
//  Synopsis:   Returns the PackageDetail corresponding to the PackageName.
//
//  Arguments:
//  [in]    
//      pszPackageId
//              Id of the Package.
//  [out]
//      pPackageDetail
//              PackageDetail info that is returned.
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the Package object and calls GetPackageDetail with it.
//----------------------------------------------------------------
HRESULT CClassContainer::GetPackageDetailsFromGuid (
                                                    GUID            PkgGuid,
                                                    PACKAGEDETAIL  *pPackageDetail
                                                   )
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL, szRDN[_MAX_PATH];
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot = 0;
    
    // this can be made into a search based API. Not required for the time being.
    // Should change it if perf is a big issue.
    if (IsNullGuid(PkgGuid))
        return E_INVALIDARG;

    BuildDNFromPackageGuid(PkgGuid, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    // binding to the package object.
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION, &hADs);
    ERROR_ON_FAILURE(hr);
    
    // calling GetPackageDetail.
    hr = GetPackageDetail (hADs, m_szClassName, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        CoTaskMemFree(szFullName);

Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}

#define FREEARR(ARR, SZ) {                                          \
                DWORD curIndex;                                     \
                for (curIndex = 0; curIndex < (SZ); curIndex++)     \
                    CoTaskMemFree((ARR)[curIndex]);                 \
                CoTaskMemFree(ARR);                                 \
                ARR = NULL;                                         \
        }                                                           \


//---------------------------------------------------------------
//
//  Function:   ChangePackageUpgradeInfoIncremental
//
//  Synopsis:   Mark the package as upgraded by another package
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Package Guid to identify the package.
//      szUpgradedByClassStore
//              Class Store where the package that upgrades exists
//      UpgradedByPackageGuid
//              The Guid of the package that upgrades
//      Add     Add or remove the upgradedByrelation
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Otherwise it packs all the required attributes in the ATTR_INFO
//  structure and sends it to the Directory.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageUpgradeInfoIncremental(
                         GUID           PackageGuid,
                         UPGRADEINFO    UpgradeInfo,
                         DWORD          OpFlags
                      )
{
    HRESULT         hr = S_OK;
    HANDLE          hADs = NULL;
    WCHAR          *szFullName=NULL, szGuid[_MAX_PATH], szUsn[20];
    LPOLESTR        pProp = NULL;
    ADS_ATTR_INFO   pAttr[2];
    DWORD           cAttr = 0, cModified = 0, i=0;
    UINT            len=0;

    hr = BuildDNFromPackageGuid(PackageGuid, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    // Bind to the Package Object.
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hADs);
    ERROR_ON_FAILURE(hr);

    StringFromGUID(UpgradeInfo.PackageGuid, szGuid);

    len = wcslen(UpgradeInfo.szClassStore);
    pProp = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) *(36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2+1));
                    // Guid size+::+length++:+flagDigit+2 

    wsprintf(pProp, L"%s%s%s%s%02x", UpgradeInfo.szClassStore, PKG_UPG_DELIMITER1, szGuid, PKG_UPG_DELIMITER2, UpgradeInfo.Flag%16);

    PackStrArrToAttrEx(pAttr+cAttr, UPGRADESPACKAGES, &pProp, 1, OpFlags?TRUE:FALSE);
    cAttr++;

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);

    if (hADs)
        ADSICloseDSObject(hADs);
    
    // ignore it if the property already exists.
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS))
        hr = S_OK;

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    
Error_Cleanup:
    if (szFullName)
        CoTaskMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//
//  Function:   ChangePackageProperties
//
//  Synopsis:   Change Various (most commonly changed) properties 
//              for a given package.
//
//  Arguments:
//  [in]    
//      PackageId
//              Package Id to identify the package.
//      pszNewname
//              new Name for the Package. If it is being renamed
//              all other changes should be NULL.
//      pdwFlags
//              The Deployment Flags. Should be ACTFLG_XXX
//              Ignored if NULL.
//      pszUrl
//              Help Url for the Package. Ignored if NULL.
//      pszScriptPath
//              Script Path for the Package. Ignored if NULL.
//      pInstallUiLevel
//              The InstallationUiLevel. Ignored if NULL.
//      pdwRevision
//              REVISION. Ignored if NULL.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Otherwise it packs all the required attributes in the ATTR_INFO
//  structure and sends it to the Directory.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageProperties(
                                                 LPOLESTR       pszPackageName,
                                                 LPOLESTR       pszNewName,
                                                 DWORD         *pdwFlags,
                                                 LPOLESTR       pszUrl,
                                                 LPOLESTR       pszScriptPath,
                                                 UINT          *pInstallUiLevel,
                                                 DWORD         *pdwRevision
                                                 )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szRDN=NULL, *szFullName=NULL;
    WCHAR       szUsn[20];
    ADS_ATTR_INFO pAttr[7];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;

    // if no properties have to be changed.
    if (!(pszScriptPath || pszUrl || pdwFlags || pInstallUiLevel || pdwRevision || pszNewName))
        return E_INVALIDARG;

    if (pszNewName)
    {
        // rename package

        WCHAR    szNewRDN[_MAX_PATH];
        BOOL     GenerateGuid = FALSE;
        GUID     PackageGuidId;
        WCHAR    pszPackageNewId[_MAX_PATH], *szJunk = NULL;   

        if (IsBadStringPtr(pszNewName, _MAX_PATH))
            return E_INVALIDARG;
        
        if (pszScriptPath || pszUrl || pdwFlags || pInstallUiLevel || pdwRevision)
            return E_INVALIDARG;

        // see whether the new name is valid.
//        GenerateGuid = InvalidDSName(pszNewName);

        // see whether the newName already exists. Notice that if the same package name is 
        // entered it will return error.
        hr = GetDNFromPackageName(pszNewName, &szJunk);

        if (szJunk)
            CoTaskMemFree(szJunk);
        szJunk = NULL;

        ERROR_ON_FAILURE(hr);

        if (hr == S_OK)
            return CS_E_OBJECT_ALREADY_EXISTS;
/*
        packages are going to have a guid as a name and nothing else.        
        // generate guid if required.
        if (GenerateGuid)
        {
            CoCreateGuid(&PackageGuidId);
            StringFromGUID(PackageGuidId, pszPackageNewId);
        }
        else 
            wcscpy(pszPackageNewId, pszNewName);
        
        // generate the new RDN
        wsprintf(szNewRDN, L"CN=%s", pszPackageNewId);

        BuildADsParentPath(szFullName, &szJunk, &szRDN);
        
        if (szJunk)
            FreeADsMem(szJunk);

        hr = ADSIModifyRdn(m_ADsPackageContainer, szRDN, szNewRDN);  

        if (szRDN)
            FreeADsMem(szRDN);

        ERROR_ON_FAILURE(hr);

        if (szFullName)
            CoTaskMemFree(szFullName);
        szFullName = NULL;

        // construct the Full Path for the Package.
        BuildADsPathFromParent(m_szPackageName, szNewRDN, &szFullName);
*/
        // Bind to the Package Object.
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
                          &hADs);
        if (szFullName)
            FreeADsMem(szFullName);
        szFullName = NULL;

        ERROR_ON_FAILURE(hr);
    }
    else 
    {
        // Bind to the Package Object.
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
            &hADs);
        ERROR_ON_FAILURE(hr);

        if (szFullName)
            CoTaskMemFree(szFullName);
        szFullName = NULL;
    }
    
    // Just change some properties.
    //
    // Update the TimeStamp
    //
    
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    //
    // Change Package Flags
    //
    if (pdwFlags)
    {
        PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS, *pdwFlags);
        cAttr++;
    }
    
    //
    // Change Package Script
    //
    if (pszScriptPath) 
    {
        PackStrToAttr(pAttr+cAttr, SCRIPTPATH, pszScriptPath);
        cAttr++;
    }
    
    //
    // Change Package Help URL
    //
    if (pszUrl) 
    {
        PackStrToAttr(pAttr+cAttr, HELPURL, pszUrl);
        cAttr++;
    }
    
    //
    // Change Package UI Level.
    //
    if (pInstallUiLevel) 
    {
        PackDWToAttr (pAttr+cAttr, UILEVEL, *pInstallUiLevel);
        cAttr++;
    }
    
    //
    // Change Revision.
    //
    if (pdwRevision) 
    {
        PackDWToAttr (pAttr+cAttr, REVISION, *pdwRevision);
        cAttr++;
    }
    
    if (pszNewName)
    {
        PackStrToAttr(pAttr+cAttr, PACKAGENAME, pszNewName);
        cAttr++;
    }

    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);

    if (hADs)
        ADSICloseDSObject(hADs);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (SUCCEEDED(hr))
    {
        //
        // Update Class Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (szFullName)
        CoTaskMemFree(szFullName);
    return RemapErrorCode(hr, m_szContainerName);
}
//---------------------------------------------------------------
//  Function:   ChangePackageCategories
//
//  Synopsis:   Change (Not Add) the Categories that a package
//              belongs to.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cCategories
//              Number of Categories.
//      rpCategory
//              Array of categories.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Converts all the categories to strings
//  Packs it and sends it to the DS.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageCategories(
                                                 LPOLESTR       pszPackageName,
                                                 UINT           cCategories,
                                                 GUID          *rpCategory
                                                 )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    LPOLESTR   *pszGuid = NULL;
    UINT        count;
    ADS_ATTR_INFO pAttr[1];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((cCategories) && ((!rpCategory) ||
           (!IsValidReadPtrIn(rpCategory, sizeof(GUID) * cCategories))))
        return E_INVALIDARG;

    // Construct the Name of the Package Object.

    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
       
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                          &hADs);
    ERROR_ON_FAILURE(hr);
    
    // fill in the categories
    pszGuid = (LPOLESTR *)CoTaskMemAlloc(cCategories * sizeof(LPOLESTR));
    if (!pszGuid) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }
    
    // convert the GUIDs to Strings.
    for (count = 0; (count < cCategories); count++) 
    {
        pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
        
        if (!(pszGuid[count])) 
        {
            FREEARR(pszGuid, count);
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }
        
        StringFromGUID(rpCategory[count], pszGuid[count]);
    }
    
    // Pack it into Attribute Structure.
    PackStrArrToAttr(pAttr+cAttr, PKGCATEGORYLIST, pszGuid, cCategories);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);
    
    if (pszGuid)
        for (count = 0; (count < cCategories); count++)
            CoTaskMemFree(pszGuid[count]);
    
    CoTaskMemFree(pszGuid);

    if (szFullName)
        CoTaskMemFree(szFullName);

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//  Function:   SetPriorityByFileExt
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      pszFileExt
//              File Extension for which the priority has to be changed.
//      Priority
//              Priority for the Package.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Gets the file Extensions and changes
//  the priority corresponding to the File Extension.
//----------------------------------------------------------------
HRESULT CClassContainer::SetPriorityByFileExt(
                                              LPOLESTR pszPackageName,
                                              LPOLESTR pszFileExt,
                                              UINT     Priority
                                              )
{
    HRESULT       hr = S_OK;
    HANDLE        hADs = NULL;
    WCHAR        *szFullName=NULL;
    LPOLESTR     *prgFileExt = NULL;
    WCHAR         szUsn[20];
    ADS_ATTR_INFO pAttr[4], *pAttrGot = NULL;
    DWORD         cAttr = 0, cAttrGot = 0, cModified = 0, cShellFileExt = 0, i=0;
    LPOLESTR      pAttrNames[] = {PKGFILEEXTNLIST};
    
    // Construct the Package Name
    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
        
    // Bind to the Package Object.
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, 
                          &hADs);
    ERROR_ON_FAILURE(hr);
    
    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // get the file extensions.
    hr = ADSIGetObjectAttributes(hADs, pAttrNames, 1,  &pAttrGot,  &cAttrGot);    
    
    if  ((SUCCEEDED(hr)) && (cAttrGot))  
        UnpackStrArrFrom(pAttrGot[0], &prgFileExt, &cShellFileExt);
    
    // Look for the given file extension.
    for (i=0; i < cShellFileExt; ++i)
    {
        if (wcsncmp(prgFileExt[i], pszFileExt, wcslen(pszFileExt)) == 0)
        {
            // if the file extension is found, change the corresponding priority.
            if (wcslen(prgFileExt[i]) != (wcslen(pszFileExt)+3))
                continue;

            wsprintf(prgFileExt[i], L"%s:%2d", pszFileExt, Priority%100);
            break;
        }
    }
    
    if (i == cShellFileExt)
    {
        ERROR_ON_FAILURE(hr = CS_E_OBJECT_NOTFOUND);
    }
    
    if (cShellFileExt)
    {
        PackStrArrToAttr(pAttr+cAttr, PKGFILEEXTNLIST, prgFileExt, cShellFileExt);
        cAttr++;
    }
    
    hr = ADSISetObjectAttributes(hADs,  pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:    
    CoTaskMemFree(prgFileExt);
    
    if (szFullName)
        CoTaskMemFree(szFullName);

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   ChangePackageSourceList
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cSources
//              Number of sources
//      pszSourceList
//              List of sources
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Makes the new sourcelist with the order
// maintained.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageSourceList(
                                                LPOLESTR     pszPackageName,
                                                UINT         cSources,
                                                LPOLESTR    *pszSourceList
                                                )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    UINT        count;
    WCHAR       szUsn[20];
    LPOLESTR   *pszPrioritySourceList = NULL;
    ADS_ATTR_INFO pAttr[2];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((!pszSourceList) ||
           (!IsValidReadPtrIn(pszSourceList, sizeof(LPOLESTR) * cSources)))
        return E_INVALIDARG;
    
    for (count = 0; (count < cSources); count++) 
        if ((!pszSourceList[count]) || (IsBadStringPtr(pszSourceList[count], _MAX_PATH)))
            return E_INVALIDARG;

    // Construct the Name of the Package Object.
    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
       
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                          &hADs);
    ERROR_ON_FAILURE(hr);

    // Local variable for adding the order to the list.
    pszPrioritySourceList = (LPOLESTR *)CoTaskMemAlloc(cSources * sizeof(LPOLESTR));
    if (!pszPrioritySourceList) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }

    // add the order to the list
    for (count = 0; (count < cSources); count++) 
    {
        pszPrioritySourceList[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(pszSourceList[count])+
                                                    1+1+1+NumDigits10(cSources)));
        
        if (!(pszPrioritySourceList[count])) 
        {
            FREEARR(pszPrioritySourceList, count);
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }
        
        wsprintf(pszPrioritySourceList[count], L"%d:%s", count, pszSourceList[count]);
    }

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    // Pack it into Attribute Structure.
    PackStrArrToAttr(pAttr+cAttr, MSIFILELIST, pszPrioritySourceList, cSources);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
   
    if (szFullName)
        CoTaskMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   ChangePackageUpgradeList
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cSources
//              Number of sources
//      pszSourceList
//              List of sources
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Makes the new sourcelist with the order
// maintained.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageUpgradeList(
                                                LPOLESTR     pszPackageName,
                                                UINT         cUpgrades,
                                                UPGRADEINFO *prgUpgradeInfoList
                                                )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    UINT        count = 0, count1 = 0, count2 = 0;
    LPOLESTR   *pProp = NULL, pAttrNames[2] = {UPGRADESPACKAGES, OBJECTGUID}, *rpszUpgrades = NULL;
    ADS_ATTR_INFO pAttr[2], *pAttrGot = NULL;
    DWORD       cAttr = 0, cModified = 0, i=0, posn = 0, cUpgradeInfoStored = 0,
                cAddList = 0, cRemoveList = 0, cgot = 0;
    GUID        PkgGuid;
    WCHAR       szUsn[20];
    UPGRADEINFO *pUpgradeInfoStored = NULL, *pAddList = NULL, *pRemoveList = NULL;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((cUpgrades) && ((!prgUpgradeInfoList) ||
           (!IsValidReadPtrIn(prgUpgradeInfoList, sizeof(UPGRADEINFO) * cUpgrades))))
        return E_INVALIDARG;

    for (count = 0; (count < cUpgrades); count++)
    {
        if ((!(prgUpgradeInfoList[count].szClassStore)) || 
            IsBadStringPtr((prgUpgradeInfoList[count].szClassStore), _MAX_PATH))
            return E_INVALIDARG;

        if (IsNullGuid(prgUpgradeInfoList[count].PackageGuid))
            return E_INVALIDARG;

        if (((prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) == 0) &&
            ((prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall) == 0) &&
            ((prgUpgradeInfoList[count].Flag & UPGFLG_UpgradedBy) == 0))
            return E_INVALIDARG;      
    }    

    // Construct the Name of the Package Object.
    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);
    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                          &hADs);
    ERROR_ON_FAILURE(hr);
   
    // get the guid and upgrade info
    hr = ADSIGetObjectAttributes(hADs, pAttrNames, 2,  &pAttrGot,  &cgot);    
    
    // Package guid
    posn = GetPropertyFromAttr(pAttrGot, cgot, OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttrGot[posn], &PkgGuid);

    // Upgrade package
    posn = GetPropertyFromAttr(pAttrGot, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
        UnpackStrArrFrom(pAttrGot[posn], &pProp, &cUpgradeInfoStored);

    // allocating the lists
    pUpgradeInfoStored = (UPGRADEINFO *)CoTaskMemAlloc(sizeof(UPGRADEINFO)*(cUpgradeInfoStored));
    pAddList = (UPGRADEINFO *)CoTaskMemAlloc(sizeof(UPGRADEINFO)*(cUpgrades+cUpgradeInfoStored));
    pRemoveList = (UPGRADEINFO *)CoTaskMemAlloc(sizeof(UPGRADEINFO)*(cUpgrades+cUpgradeInfoStored));

    if ((!pUpgradeInfoStored) || (!pAddList) || (!pRemoveList))
        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);

    // convert the strings to upgradinfo structures.
    for (count = 0; count < (cUpgradeInfoStored); count++)
    {
        WCHAR *pStr = NULL;
        LPOLESTR ptr = pProp[count];
        UINT len = wcslen (ptr);
            
        pUpgradeInfoStored[count].szClassStore = pProp[count];

        if (len <= 41)
            continue;

        *(ptr + len - 3) = NULL;
        pUpgradeInfoStored[count].Flag = wcstoul(ptr+(len-2), &pStr, 16);

        *(ptr + len - 3 - 36 - 2) = L'\0';
        /*      -GUID-'::'*/
        GUIDFromString(ptr+len-3-36, &(pUpgradeInfoStored[count].PackageGuid));        
    }

    cUpgradeInfoStored = count; // we might have skipped some.

    // AddList formed.
    for (count = 0; count < cUpgrades; count++)
    {
        for (count1 = 0; count1 < cUpgradeInfoStored; count1++)
        {
            // ignore flag changes
            if ((wcscmp(pUpgradeInfoStored[count1].szClassStore, prgUpgradeInfoList[count].szClassStore) == 0) && 
                (memcmp(&pUpgradeInfoStored[count1].PackageGuid, &prgUpgradeInfoList[count].PackageGuid, sizeof(GUID)) == 0))
                break;
        }

        if (count1 == cUpgradeInfoStored)
            pAddList[cAddList++] = prgUpgradeInfoList[count];
    }

    // remove list formed.
    for (count1 = 0; count1 < cUpgradeInfoStored; count1++)
    {
        for (count = 0; count < cUpgrades; count++)
        {
            // ignore flag changes
            if ((wcscmp(pUpgradeInfoStored[count1].szClassStore, prgUpgradeInfoList[count].szClassStore) == 0) && 
                (memcmp(&pUpgradeInfoStored[count1].PackageGuid, &prgUpgradeInfoList[count].PackageGuid, sizeof(GUID)) == 0))
                break;
        }

        if (count == cUpgrades)
            pRemoveList[cRemoveList++] = pUpgradeInfoStored[count];
    }

    for (count = 0; count < cAddList; count++)
    {
        // in case of UpgradedBy do no try to fix up the links.
        if (!(pAddList[count].Flag & UPGFLG_UpgradedBy))
        {            
            DWORD   Flags = 0;
            if (pAddList[count].Flag & UPGFLG_Enforced)
                Flags = UPGFLG_Enforced;
        }
    }

    for (count = 0; count < cRemoveList; count++)
    {
        // in case of UpgradedBy do no try to fix up the links.
        if (!(pRemoveList[count].Flag  & UPGFLG_UpgradedBy))
        {            
            DWORD   Flags = 0;
            if (pRemoveList[count].Flag & UPGFLG_Enforced)
                Flags = UPGFLG_Enforced;
        }
    }

    rpszUpgrades = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*cUpgrades);
    if (!rpszUpgrades)
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    for (count = 0; (count < cUpgrades); count++) 
    {
        WCHAR szPackageGuid[_MAX_PATH];
        UINT len = wcslen(prgUpgradeInfoList[count].szClassStore);

        rpszUpgrades[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) *(36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2));
                                                           // Guid size+::+length++:+flagDigit+2 
        if (!rpszUpgrades[count])
        {
            FREEARR(rpszUpgrades, count);  
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }

        StringFromGUID(prgUpgradeInfoList[count].PackageGuid, szPackageGuid);
        wsprintf(rpszUpgrades[count], L"%s%s%s%s%02x", prgUpgradeInfoList[count].szClassStore, PKG_UPG_DELIMITER1, szPackageGuid,
                        PKG_UPG_DELIMITER2, prgUpgradeInfoList[count].Flag%16);
    }

    PackStrArrToAttr(pAttr+cAttr, UPGRADESPACKAGES, rpszUpgrades, cUpgrades); 
    cAttr++;

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);

    if (szFullName)
        CoTaskMemFree(szFullName);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);

    if (pAttrGot)
        FreeADsMem(pAttrGot);

    if (pProp)
        CoTaskMemFree(pProp);

    if (pUpgradeInfoStored)
        CoTaskMemFree(pUpgradeInfoStored);
    
    if (pAddList) 
        CoTaskMemFree(pAddList);
    
    if (pRemoveList)
        CoTaskMemFree(pRemoveList);

    return RemapErrorCode(hr, m_szContainerName);
}


extern LPOLESTR szAppCategoryColumns;

//---------------------------------------------------------------
//  Function:   GetAppCategories
//
//  Synopsis:   gets the list of Package Categories in the Domain.
//
//  Arguments:
//  [in]    
//      Locale
//              Locale for the categories. Used to get the description.
//  [out]
//      pAppCategoryList
//              the list of Application Categories in the domain
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Gets the FullName of the Domain, binds to the AppCategory container
//  below that. and gets all the categories with approp. types.
//----------------------------------------------------------------

HRESULT CClassContainer::GetAppCategories (
                                           LCID                  Locale,
                                           APPCATEGORYINFOLIST  *pAppCategoryList
                                           )
{
    HRESULT             hr = S_OK;
    WCHAR               szfilter[_MAX_PATH];
    WCHAR               szRootPath[_MAX_PATH], szAppCategoryContainer[_MAX_PATH];
    HANDLE              hADs = NULL;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    
    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    // we do not expect too many categories
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = 20;
    
    if (!IsValidPtrOut(pAppCategoryList, sizeof(APPCATEGORYINFOLIST)))
        return E_INVALIDARG;
    
    // get the name of the domain.
    hr = GetRootPath(szRootPath);
    ERROR_ON_FAILURE(hr);
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
                                                        szRootPath+LDAPPREFIXLENGTH);
    
    wsprintf(szfilter, L"(objectClass=%s)", CLASS_CS_CATEGORY);
    
    //binds to the category container
    hr = ADSIOpenDSObject(szAppCategoryContainer, NULL, NULL, 
                                                ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hADs);
    ERROR_ON_FAILURE(hr);
    
    hr = ADSISetSearchPreference(hADs, SearchPrefs, 2);
    ERROR_ON_FAILURE(hr);
    
    // gets a search handle
    hr = ADSIExecuteSearch(hADs, szfilter, pszCategoryAttrNames, cCategoryAttr, &hADsSearchHandle);
    ERROR_ON_FAILURE(hr);
    
    // tries to find out the number of categories.
    pAppCategoryList->cCategory = 0;
    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
                       ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS));
	               hr = ADSIGetNextRow(hADs, hADsSearchHandle))        
        pAppCategoryList->cCategory++;
    
    // get the number of elements.    
    pAppCategoryList->pCategoryInfo = (APPCATEGORYINFO *)CoTaskMemAlloc(
                                                      sizeof(APPCATEGORYINFO)*
                                                      pAppCategoryList->cCategory);
    
    if (!(pAppCategoryList->pCategoryInfo))
    {
        pAppCategoryList->cCategory = 0;
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
    }
   
    // if it has come till here, it has to have a search handle
    ADSICloseSearchHandle(hADs, hADsSearchHandle);    
    hADsSearchHandle = NULL;

    memset(pAppCategoryList->pCategoryInfo, 0, sizeof(APPCATEGORYINFO)*pAppCategoryList->cCategory);

    // gets a search handle
    hr = ADSIExecuteSearch(hADs, szfilter, pszCategoryAttrNames, cCategoryAttr, &hADsSearchHandle);
    ERROR_ON_FAILURE(hr);

    // passes the search handle and gets the categorylist.
    hr = FetchCategory(hADs, hADsSearchHandle, pAppCategoryList, Locale);
    ERROR_ON_FAILURE(hr);
    
Error_Cleanup:
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(hADs, hADsSearchHandle);

    if (hADs)
        ADSICloseDSObject(hADs);
    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   RegisterAppCategory
//
//  Synopsis:   Adda category and assoc desc. for the whole Domain(This is per domain
//              and not per class store.)
//
//  Arguments:
//  [in]    
//      pAppCategory
//              Pointer to a APPCATEGORYINFO structure to be added.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Finds the root path of the domain. binds to the category container
//  underneath it. deletes this particular AppCategory.
//----------------------------------------------------------------
HRESULT CClassContainer::RegisterAppCategory (
                                              APPCATEGORYINFO    *pAppCategory
                                              )
{
    WCHAR           szRootPath[_MAX_PATH], localedescription[128+16],
                    szAppCategoryContainer[_MAX_PATH], szRDN[_MAX_PATH],
                  * szFullName = NULL, szAppCatid[_MAX_PATH];

    HRESULT         hr = S_OK;
    HANDLE          hADsContainer = NULL, hADs = NULL;
    ULONG           i, j, cdesc = 0, posn = 0;
    LPOLESTR      * pszDescExisting = NULL, pszDesc = NULL;
    LPOLESTR        AttrName = LOCALEDESCRIPTION;
    ADS_ATTR_INFO * pAttrGot = NULL, pAttr[6];
    DWORD           cgot = 0, cAttr = 0;
    BOOL            fExists = TRUE;
    
    if ((!pAppCategory) || (!IsValidReadPtrIn(pAppCategory, sizeof(APPCATEGORYINFO))))
        return E_INVALIDARG;
    
    if ((pAppCategory->pszDescription == NULL) || 
        (IsBadStringPtr(pAppCategory->pszDescription, _MAX_PATH)))
        return E_INVALIDARG;
    
    if (IsNullGuid(pAppCategory->AppCategoryId))
        return E_INVALIDARG;
    
    // get the name of the root of the domain
    hr = GetRootPath(szRootPath);
    ERROR_ON_FAILURE(hr);
    
    // Bind to a AppCategory container
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
        szRootPath+LDAPPREFIXLENGTH);
    
    // container is supposed to exist.
    hr = ADSIOpenDSObject(szAppCategoryContainer, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                          &hADsContainer);
    ERROR_ON_FAILURE(hr);


    RDNFromGUID(pAppCategory->AppCategoryId, szRDN);
    
    wsprintf(localedescription, L"%x %s %s", pAppCategory->Locale, CAT_DESC_DELIMITER,
        pAppCategory->pszDescription);
    
    BuildADsPathFromParent(szAppCategoryContainer, szRDN, &szFullName);
    
    // BUGBUG:: ADS_FAST_BIND and the create seems to be going twice. why?
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hADs);
    
    if (SUCCEEDED(hr))
        hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttrGot, &cgot);

    if (SUCCEEDED(hr))
    {
        fExists = TRUE;
    }
    else 
    {
        fExists = FALSE;
        PackStrToAttr(pAttr, OBJECTCLASS, CLASS_CS_CATEGORY); cAttr++;
        
        PackGUIDToAttr(pAttr+cAttr, CATEGORYCATID, &(pAppCategory->AppCategoryId)); cAttr++;
        
        hr = ADSICreateDSObject(hADsContainer, szRDN, pAttr, cAttr);
        
        for (j = 0; j < cAttr; j++)
            FreeAttr(pAttr[j]);
        cAttr = 0;
        
        if (hADs)
        {
            ADSICloseDSObject(hADs);
            hADs = NULL;
        }
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hADs);
    }
    
    if (szFullName)
        FreeADsMem(szFullName);
    
    ERROR_ON_FAILURE(hr);
    
    if (fExists) {
        if (cgot) 
        {
            UnpackStrArrFrom(pAttrGot[0], &pszDescExisting, &cdesc);
        }
        
        // Existing list of descriptions
        if (posn = FindDescription(pszDescExisting, cdesc, &(pAppCategory->Locale), NULL, 0))
        {   // Delete the old value
            PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, pszDescExisting+(posn-1), 1, FALSE); cAttr++;
        }
        CoTaskMemFree(pszDescExisting);
    }
    
    pszDesc = localedescription;
    
    PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, &pszDesc, 1, TRUE);
    cAttr++;
    
    DWORD cModified;
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);
    
Error_Cleanup:
    
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (hADs)
        ADSICloseDSObject(hADs);
    
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);
    
    return RemapErrorCode(hr, m_szContainerName);
}



//---------------------------------------------------------------
//  Function:   UnregisterAppCategory
//
//  Synopsis:   Removes a category from the whole Domain(This is per domain)
//              and not per class store.
//
//  Arguments:
//  [in]    
//      pAppCategoryId
//              Pointer to a GUID that has to be removed.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Finds the root path of the domain. binds to the category container
//  underneath it. deletes this particular AppCategory.
//----------------------------------------------------------------
HRESULT CClassContainer::UnregisterAppCategory (
                                                GUID         *pAppCategoryId
                                                )
{
    WCHAR           szRootPath[_MAX_PATH], szRDN[_MAX_PATH],
                    szAppCategoryContainer[_MAX_PATH];
    HRESULT         hr = S_OK;
    HANDLE          hADs = NULL;
    
    if (!IsValidReadPtrIn(pAppCategoryId, sizeof(GUID)))
        return E_INVALIDARG;
    
    hr = GetRootPath(szRootPath);
    // Bind to a AppCategory container
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
        szRootPath+LDAPPREFIXLENGTH);
    
    hr = ADSIOpenDSObject(szAppCategoryContainer, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                            &hADs);
    
    ERROR_ON_FAILURE(hr);
    
    RDNFromGUID(*pAppCategoryId, szRDN);
    
    hr = ADSIDeleteDSObject(hADs, szRDN);
    
    ADSICloseDSObject(hADs);
    
    // Delete this category
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//  Function:   DeletePackage
//
//  Synopsis:   Permanently remove a package and the associated Classes 
//              from class store
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Guid of the package that has to be removed.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Deletes the package and all the clsids associated with the 
//  package (using DeleteClass) Ignores the error from DeleteClass
//  Tries to delete all the upgrade relationships from this package.
//  Errors are ignored.
//----------------------------------------------------------------
HRESULT CClassContainer::DeletePackage (LPOLESTR    szFullName
                                        )
{
    HRESULT         hr = S_OK;
    DWORD           cStr = 0, count = 0, cgot = 0, posn = 0;
    LPOLESTR        szRDN = NULL, szJunk = NULL;
    LPOLESTR      * szStr = NULL;
    LPOLESTR        pAttrName[] = {PKGCLSIDLIST, UPGRADESPACKAGES, OBJECTGUID};
    ADS_ATTR_INFO * pAttr = NULL;
    HANDLE          hADs = NULL;
    WCHAR           szUsn[20];
    GUID            PackageGuid;

    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                            &hADs);
    
    if (!SUCCEEDED(hr))
        return hr;
    
    GetCurrentUsn(szUsn);
    
    hr = ADSIGetObjectAttributes(hADs, pAttrName, 3, &pAttr, &cgot);

    memset(&PackageGuid, 0, sizeof(GUID));
    posn = GetPropertyFromAttr(pAttr, cgot,  OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &PackageGuid);

    posn = GetPropertyFromAttr(pAttr, cgot,  PKGCLSIDLIST);
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szStr, &cStr);

    for (count = 0; count < cStr; count++)
    {
        if (wcslen(szStr[count]) > (STRINGGUIDLEN-1))
            szStr[count][STRINGGUIDLEN-1] = L'\0';
        hr = DeleteClass(szStr[count]);
    }

    if (szStr)
        CoTaskMemFree(szStr);
    szStr = NULL;
    cStr = 0;

    posn = GetPropertyFromAttr(pAttr, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn],  &szStr, &cStr);

    for (count = 0; count < cStr; count++)
    {
        GUID        UpgradeeGuid;
        WCHAR      *pStr = NULL;
        LPOLESTR    ptr = szStr[count];
        UINT        len = wcslen (ptr);
        DWORD       UpgradeFlag, Flags = 0;

        if (len <= 41)
            continue;

        *(ptr + (len - 3)) = NULL;
                    
        UpgradeFlag = wcstoul(ptr+(len-2), &pStr, 16);

        *(ptr + (len - 3 - 36 - 2)) = L'\0';
                 /*      -GUID-'::'*/
        GUIDFromString(ptr+len-3-36, &UpgradeeGuid);
    
        if (UpgradeFlag & UPGFLG_Enforced)
            Flags = UPGFLG_Enforced;

    }
    
    if (szStr)
        CoTaskMemFree(szStr);
    szStr = NULL;
    cStr = 0;

    // ignore errors
    if (pAttr)
        FreeADsMem(pAttr);
    
    ADSICloseDSObject(hADs);
    
    BuildADsParentPath(szFullName, &szJunk, &szRDN);
    
    if (szJunk)
        FreeADsMem(szJunk);

    hr = ADSIDeleteDSObject(m_ADsPackageContainer, szRDN);
    if (szRDN)
        FreeADsMem(szRDN);

    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    return hr;
}

//---------------------------------------------------------------
//  Function:   RemovePackage
//
//  Synopsis:   Mark a package as disabled or orphaned
//              Or permanently remove a package and the associated Classes 
//              from class store
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Guid of the package that has to be removed.
//  [in]
//      dwFlags
//              The new flags for the package. To delete the package explicitly
//              use flag zero or orphan.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Calls Delete package if the flags is zero or Orphan.
//  Otherwise it sets the new flags and stamps the new time stamp.
//----------------------------------------------------------------
HRESULT CClassContainer::RemovePackage (
                                        LPOLESTR       pszPackageName,
                                        DWORD          dwFlags
                                        )
{
    HRESULT         hr = S_OK;
    WCHAR          *szRDN = NULL, *szFullName = NULL;
    HANDLE          hADs = NULL;
    WCHAR           szUsn[20];
    ADS_ATTR_INFO   pAttr[7];
    DWORD           cAttr = 0, cModified = 0, i=0;

    if ((dwFlags != 0) && (dwFlags != ACTFLG_Orphan) && (dwFlags != ACTFLG_Uninstall))
        return E_INVALIDARG;
    
    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;

    if (dwFlags == 0)
        // delete the package from the class store
    {
        hr = DeletePackage(szFullName);
    }
    else
    {
        GUID    NewPackageId;
        WCHAR   szNewRDN[_MAX_PATH], *szRDN = NULL, *szJunk = NULL;
        //
        // PackageName is unchanged.
        //
        GetCurrentUsn(szUsn);

/*
        CoCreateGuid(&NewPackageId);
        RDNFromGUID(NewPackageId, szNewRDN);

        BuildADsParentPath(szFullName, &szJunk, &szRDN);
        if (szJunk)
            FreeADsMem(szJunk);

        hr = ADSIModifyRdn(m_ADsPackageContainer, szRDN, szNewRDN);
        if (szRDN)
            FreeADsMem(szRDN);

        ERROR_ON_FAILURE(hr);
        
        // construct the Full Path for the Package.
        BuildADsPathFromParent(m_szPackageName, szNewRDN, &szFullName);
*/        
        // Bind to the Package Object.
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND, &hADs);
        ERROR_ON_FAILURE(hr);

        // setting the flag as orphan/uninstall
        PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS, dwFlags);
        cAttr++;

        // stamping the modification time for cleanup later.
        PackStrToAttr (pAttr+cAttr, PKGUSN, szUsn);
        cAttr++;

        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);

        if (hADs)
            ADSICloseDSObject(hADs);

        for (i = 0; i < cAttr; i++)
            FreeAttr(pAttr[i]);
    
        if (SUCCEEDED(hr))
        {
            //
            // Update Class Store Usn
            //
            UpdateStoreUsn(m_ADsContainer, szUsn);
        }
    }
        
Error_Cleanup:
    if (szFullName)
        CoTaskMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}

// Merges list1 and List2 into ResList removing duplicates.
HRESULT MergePropList(LPOLESTR    *List1,  DWORD   cList1,
                   LPOLESTR    *List2,  DWORD   cList2,
                   LPOLESTR   **ResList,DWORD  *cResList)
{
    DWORD i, j;
    
    *cResList = 0;
    *ResList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(cList1+cList2));
    if (!*ResList)
        return E_OUTOFMEMORY;

    for (i = 0; i < cList1; i++)
        (*ResList)[i] = List1[i];
    
    for (i = 0; i < cList2; i++) {
        for (j = 0; j < cList1; j++)
            if (wcscmp((*ResList)[j], List2[i]) == 0)
                break;
            
            if (j == cList1)
                (*ResList)[(*cResList)++] = List2[i];
    }

    return S_OK;
}

//---------------------------------------------------------------
//  Function:   NewClass
//
//  Synopsis:   Adds classes corresp. to a package under the DS.
//              Called by AddPackage.
//
//  Arguments:
//  [in]    
//      pClassDetail
//              Class Detail of the clsid that needs to be added.
//              Validation is specified in class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the classdetail structure. If the clsid already exists in
//  the DS, it adds these values under the same clsid and increases the refcount.
//----------------------------------------------------------------
HRESULT CClassContainer::NewClass (CLASSDETAIL *pClassDetail)
{
    HRESULT         hr = S_OK;
    STRINGGUID      szGUID1, szGUID2;
    WCHAR           szRDN [_MAX_PATH], * szFullName = NULL;
    ADS_ATTR_INFO   pAttr[6], *pAttrsGot = NULL;
    BOOL            fExists = FALSE;
    HANDLE          hADs = NULL;
    LPOLESTR        AttrNames[] = {PKGFILEEXTNLIST, PROGIDLIST, CLASSREFCOUNTER};
    DWORD           posn = 0, cProp = 0, cPropMerged = 0, refcount = 0,
                    cAttr = 0, cModified = 0, cgot = 0, i;
    LPOLESTR      * pszProp = NULL, *pszPropMerged = NULL;
    
    if (!m_fOpen)
        return E_FAIL;
    
    //
    // Cant be a NULL guid
    //
    
    if (IsNullGuid(pClassDetail->Clsid))
        return E_INVALIDARG;

    // Not using RDNFrom GUID b'cos szGUID1 is used below
    StringFromGUID(pClassDetail->Clsid, szGUID1);    
    wsprintf(szRDN, L"CN=%s", szGUID1);
    
    BuildADsPathFromParent(m_szClassName, szRDN, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADs);
    
    if (SUCCEEDED(hr)) {
        fExists = TRUE;
        hr = ADSIGetObjectAttributes(hADs, AttrNames, 3, &pAttrsGot, &cgot);
    }
    
    // BUGBUG :: bug in adsldpc doesn't return error in open.
    if (!SUCCEEDED(hr))
        fExists = FALSE;
    
    //
    // Create the RDN for the Class Object
    //
    
    if (!fExists) {
        PackStrToAttr(pAttr+cAttr, OBJECTCLASS, CLASS_CS_CLASS); cAttr++;
        PackStrToAttr(pAttr+cAttr, CLASSCLSID, szGUID1); cAttr++;
    }
    
    if (pClassDetail->cProgId)
    {
        if (fExists)
            posn = GetPropertyFromAttr(pAttrsGot, cgot, PROGIDLIST);
        
        if (posn < cgot)
            UnpackStrArrFrom(pAttrsGot[posn], &pszProp, &cProp);
        
        // we can not just append b'cos duplicate values are valid conditions.
        
        MergePropList(pszProp, cProp,
            pClassDetail->prgProgId, pClassDetail->cProgId,
            &pszPropMerged, &cPropMerged);
        
        PackStrArrToAttr(pAttr+cAttr, PROGIDLIST, pszPropMerged, cPropMerged);
        cAttr++;
        
        CoTaskMemFree(pszPropMerged);
        pszPropMerged = NULL; cPropMerged = 0;
        
        CoTaskMemFree(pszProp);
        pszProp = NULL; cProp = 0;
    }
    
    if (!IsNullGuid(pClassDetail->TreatAs))
    {
        StringFromGUID(pClassDetail->TreatAs, szGUID2);
        PackStrToAttr(pAttr+cAttr, TREATASCLSID, szGUID2);
        cAttr++;
    }
    
    // this is going to be modified if find that an entry already exists.
    
    if (fExists) {
        posn = GetPropertyFromAttr(pAttrsGot, cgot, CLASSREFCOUNTER);
        if (posn < cgot) {
            UnpackDWFrom(pAttrsGot[posn], &refcount);
        }
    }
    
    refcount++;
    PackDWToAttr(pAttr+cAttr, CLASSREFCOUNTER, refcount);
    cAttr++;
    
    if (fExists)
        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);
    else
        hr = ADSICreateDSObject(m_ADsClassContainer, szRDN, pAttr, cAttr);
    
    if (pAttrsGot)
        FreeADsMem(pAttrsGot);
    
    if (szFullName)
        FreeADsMem(szFullName);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    return RemapErrorCode(hr, m_szContainerName);
}

#define SCRIPT_IN_DIRECTORY    256

//---------------------------------------------------------------
//  Function:   AddPackage
//
//  Synopsis:   Adds a package object in the DS.
//
//  Arguments:
//  [out]    
//      pszPackageId
//              An Id that is returned corresponding to the package.
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and tries to create the object in the DS.
//  Calls NewClass to add all the clsids after that. 
//  If this returns error
//                     the whole package is removed.
//----------------------------------------------------------------
HRESULT CClassContainer::AddPackage (
                                     PACKAGEDETAIL *pPackageDetail,
                                     GUID          *pPkgGuid
                                     )
{
    HRESULT             hr = S_OK;
    WCHAR               szRDN [_MAX_PATH];
    LPOLESTR          * pszGuid1 = NULL, *pszGuid2 = NULL,
                      * pszGuid3 = NULL, *pszGuid4 = NULL,
                      * pszProgId = NULL, *pszFileExt = NULL,
                      * rpszUpgrades = NULL, *rpszSources = NULL,
                        szPackageId = NULL, szJunk = NULL;

    DWORD             * pdwArch=NULL, count = 0, cPackProgId = 0;
    ADS_ATTR_INFO       pAttr[29]; 
    DWORD               cAttr = 0;
    WCHAR               szUsn[20];
    BOOL                fPackageCreated = FALSE, GenerateGuid = FALSE;
    GUID                PackageGuidId;
        
    if ((!pPkgGuid) || !IsValidReadPtrIn(pPkgGuid, sizeof(GUID)))
        return E_INVALIDARG;

    if ((!(pPackageDetail->pszPackageName)) || 
                IsBadStringPtr((pPackageDetail->pszPackageName), _MAX_PATH))
        return E_INVALIDARG;


    if (!pPackageDetail)
        return E_INVALIDARG;
    
    if (!IsValidReadPtrIn(pPackageDetail, sizeof(PACKAGEDETAIL)))
        return E_INVALIDARG;
    
    // validating ActivationInfo.
    if (pPackageDetail->pActInfo)
    {    
        if (!IsValidReadPtrIn(pPackageDetail->pActInfo, sizeof(ACTIVATIONINFO)))
            return E_INVALIDARG;
        
        if (!IsValidReadPtrIn(pPackageDetail->pActInfo->pClasses,
            sizeof(CLASSDETAIL) * (pPackageDetail->pActInfo->cClasses)))
            return E_INVALIDARG;

        // validating classdetail
        for (count = 0; (count < (pPackageDetail->pActInfo->cClasses)); count++)
        {
            CLASSDETAIL *pClassDetail = (pPackageDetail->pActInfo->pClasses)+count;
            if (IsNullGuid(pClassDetail->Clsid))
               return E_INVALIDARG;

            for (DWORD count1 = 0; (count1 < (pClassDetail->cProgId)); count1++)
            {
                // if profid is NULL or an empty string.
                if ((!((pClassDetail->prgProgId)[count1])) || 
                    (!((pClassDetail->prgProgId)[count1][0])))
                    return E_INVALIDARG;
            }
        }
        
        if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgShellFileExt,
            sizeof(LPOLESTR) * (pPackageDetail->pActInfo->cShellFileExt)))
            return E_INVALIDARG;
        
        for (count = 0; count < (pPackageDetail->pActInfo->cShellFileExt); count++)
        {
            if (!pPackageDetail->pActInfo->prgShellFileExt[count])
                return E_INVALIDARG;
        }
        
        if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgPriority,
            sizeof(UINT) * (pPackageDetail->pActInfo->cShellFileExt)))
            return E_INVALIDARG;
        
        if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgInterfaceId,
            sizeof(IID) * (pPackageDetail->pActInfo->cInterfaces)))
            return E_INVALIDARG;
        
        if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgTlbId,
            sizeof(GUID) * (pPackageDetail->pActInfo->cTypeLib)))
            return E_INVALIDARG;
    }
    
    // Validating InstallInfo
    // BUGBUG:: Validate ProductCode, Mvipc
    if ((pPackageDetail->pInstallInfo == NULL) || 
        (!IsValidReadPtrIn(pPackageDetail->pInstallInfo, sizeof(INSTALLINFO)))
        )
        return E_INVALIDARG;
    
    if (!IsValidReadPtrIn(pPackageDetail->pInstallInfo->prgUpgradeInfoList, 
        sizeof(UPGRADEINFO)*(pPackageDetail->pInstallInfo->cUpgrades)))
        return E_INVALIDARG;
    
    for (count = 0; count < (pPackageDetail->pInstallInfo->cUpgrades); count++)
    {
        if ((!(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore)) || 
            IsBadStringPtr((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore), _MAX_PATH))
            return E_INVALIDARG;

        if (IsNullGuid(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].PackageGuid))
            return E_INVALIDARG;

        if (((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) == 0) &&
            ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall) == 0) &&
            ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_UpgradedBy) == 0))
            return E_INVALIDARG;      
    }    
    
    // validating PlatformInfo    
    
    if ((pPackageDetail->pPlatformInfo == NULL) || 
        (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo, sizeof(PLATFORMINFO)))
        )
        return E_INVALIDARG;
    
    if (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo->prgPlatform,
        sizeof(CSPLATFORM) * (pPackageDetail->pPlatformInfo->cPlatforms)))
        return E_INVALIDARG;
    
    if ((pPackageDetail->pPlatformInfo->cLocales == 0) ||
        (pPackageDetail->pPlatformInfo->cPlatforms == 0))
        return E_INVALIDARG;
    
    if (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo->prgLocale,
        sizeof(LCID) * (pPackageDetail->pPlatformInfo->cLocales)))
        return E_INVALIDARG;
    
    // validating InstallInfo
    
    // Validating other fields in PackageDetail structure
    
    if ((pPackageDetail->pszSourceList == NULL) ||
        (!IsValidReadPtrIn(pPackageDetail->pszSourceList,
        sizeof(LPOLESTR) * (pPackageDetail->cSources))))
        return E_INVALIDARG;
    
    for (count = 0; count < (pPackageDetail->cSources); count++)
    {
        if ((!pPackageDetail->pszSourceList[count]) || 
                        (IsBadStringPtr(pPackageDetail->pszSourceList[count], _MAX_PATH)))
            return E_INVALIDARG;
    }
    
    if (pPackageDetail->rpCategory)
    {
        if (!IsValidReadPtrIn(pPackageDetail->rpCategory,
            sizeof(GUID) * (pPackageDetail->cCategories)))
            return E_INVALIDARG;
    }

    // If the restrictions are too constrictive then we should go to
    // the DS, to see whether it is a valid name or not. till then..

//    GenerateGuid = InvalidDSName(pPackageDetail->pszPackageName);

    hr = GetDNFromPackageName(pPackageDetail->pszPackageName, &szJunk);
    if (szJunk)
        CoTaskMemFree(szJunk);

    if (FAILED(hr))
        return RemapErrorCode(hr, m_szContainerName);

    if (hr == S_OK)
    {
        return CS_E_OBJECT_ALREADY_EXISTS;
    }

/*    szPackageId = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(GenerateGuid?41:
                                        (wcslen(pPackageDetail->pszPackageName)+1)));
*/

    szPackageId = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*41);

    if (!(szPackageId))
        return E_OUTOFMEMORY;

    memset(&PackageGuidId, 0, sizeof(GUID));
/*
    if (GenerateGuid)
    {
        CoCreateGuid(&PackageGuidId);
        StringFromGUID(PackageGuidId, szPackageId);
    }
    else 
        wcscpy(szPackageId, pPackageDetail->pszPackageName);
*/
    // always generate guid

    CoCreateGuid(&PackageGuidId);
    StringFromGUID(PackageGuidId, szPackageId);

    //
    // Create the RDN for the Package Object
    //

    wsprintf(szRDN, L"CN=%s", szPackageId);

    
    PackStrToAttr(pAttr+cAttr, OBJECTCLASS, CLASS_CS_PACKAGE); cAttr++;
    
    // fill in the activation info
    
    // add the class to the packagecontainer list
    
    if (pPackageDetail->pActInfo)
    {
        if (pPackageDetail->pActInfo->cClasses) 
        {
            pszGuid1 = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cClasses)*sizeof(LPOLESTR));
            if (!pszGuid1) {
                ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            
            for (count = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
            {
                WCHAR   szCtx[9];

                pszGuid1[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(STRINGGUIDLEN+9));
                if (!pszGuid1[count]) {
                    FREEARR(pszGuid1, count);
                    ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);                                
                }

                StringFromGUID(pPackageDetail->pActInfo->pClasses[count].Clsid, pszGuid1[count]);
                wsprintf(szCtx, L":%8x", pPackageDetail->pActInfo->pClasses[count].dwComClassContext);
                wcscat(pszGuid1[count], szCtx);
                cPackProgId += pPackageDetail->pActInfo->pClasses[count].cProgId;
            }
            
            PackStrArrToAttr(pAttr+cAttr, PKGCLSIDLIST, pszGuid1,
                pPackageDetail->pActInfo->cClasses); cAttr++; 
        }
        
        // collecting all the progids from the various clsids.
        pszProgId = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*cPackProgId);
        if (!pszProgId) {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        
        for (count = 0, cPackProgId = 0; count < pPackageDetail->pActInfo->cClasses; count++) {
            // for each clsid
            DWORD cClassProgId, j = 0;
            for (cClassProgId = 0; cClassProgId < pPackageDetail->pActInfo->pClasses[count].cProgId;
                                                                               cClassProgId++) 
            {
                // for each progid within ClassDetail
                for (j = 0; j < cPackProgId; j++)
                {
                    if (_wcsicmp(pszProgId[j], 
                               pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId]) == 0)
                        break;
                }
                // needs to be added if there are no dups.
                if (j == cPackProgId)
                {
                    pszProgId[cPackProgId] =
                        pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId];
                    _wcslwr(pszProgId[cPackProgId]);
                    CSDBGPrint((L"AddPackage: Progid = %s\n", pszProgId[cPackProgId]));
                    cPackProgId++;
                }
            }
        }
        
        if (cPackProgId) {
            PackStrArrToAttr(pAttr+cAttr, PROGIDLIST, pszProgId, cPackProgId); cAttr++;
        }
        
        CoTaskMemFree(pszProgId);
        
        if (pPackageDetail->pActInfo->cShellFileExt) {
            //
            // Store a tuple in the format <file ext>:<priority>
            //
            pszFileExt = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cShellFileExt) * sizeof(LPOLESTR));
            if (!pszFileExt)
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            for (count = 0; count < pPackageDetail->pActInfo->cShellFileExt; count++)
            {
                pszFileExt[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) *
                    (wcslen(pPackageDetail->pActInfo->prgShellFileExt[count])+1+2+1));
                if (!pszFileExt[count]) 
                {
                    FREEARR(pszFileExt, count);
                    ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
                }
                // format is fileext+:+nn+NULL where nn = 2 digit priority
                wsprintf(pszFileExt[count], L"%s:%2d",
                    pPackageDetail->pActInfo->prgShellFileExt[count],
                    pPackageDetail->pActInfo->prgPriority[count]%100);

                _wcslwr(pszFileExt[count]);
            }
            PackStrArrToAttr(pAttr+cAttr, PKGFILEEXTNLIST, pszFileExt,
                pPackageDetail->pActInfo->cShellFileExt); cAttr++;
        }
        
        if (pPackageDetail->pActInfo->cInterfaces) {
            pszGuid2 = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cInterfaces)*sizeof(LPOLESTR));
            if (!pszGuid2) {
                ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++) {
                pszGuid2[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
                if (!pszGuid2[count]) {
                    FREEARR(pszGuid2, count);
                    ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                
                StringFromGUID((pPackageDetail->pActInfo->prgInterfaceId)[count], pszGuid2[count]);
            }
            
            PackStrArrToAttr(pAttr+cAttr, PKGIIDLIST, pszGuid2, pPackageDetail->pActInfo->cInterfaces);
            cAttr++;
        }
/*        
        
        if (pPackageDetail->pActInfo->cTypeLib) {
            pszGuid3 = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cTypeLib)*sizeof(LPOLESTR));
            if (!pszGuid3) {
                ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cTypeLib)); count++) {
                pszGuid3[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
                if (!pszGuid3[count]) {
                    FREEARR(pszGuid3, count);
                    ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
                
                StringFromGUID((pPackageDetail->pActInfo->prgTlbId)[count], pszGuid3[count]);
            }
            
            PackStrArrToAttr(pAttr+cAttr, PKGTLBIDLIST, pszGuid3, pPackageDetail->pActInfo->cTypeLib);
            cAttr++;
        }
*/
    }
   
    // fill in the platforminfo
    
    // BUGBUG::***os version
    if (pPackageDetail->pPlatformInfo->cPlatforms) {
        pdwArch = (DWORD *)CoTaskMemAlloc(sizeof(DWORD)*(pPackageDetail->pPlatformInfo->cPlatforms));
        if (!pdwArch)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; (count < (pPackageDetail->pPlatformInfo->cPlatforms)); count++)
            UnpackPlatform (pdwArch+count, (pPackageDetail->pPlatformInfo->prgPlatform)+count);
        
        PackDWArrToAttr(pAttr+cAttr, ARCHLIST, pdwArch, pPackageDetail->pPlatformInfo->cPlatforms);
        cAttr++;
    }
    
    if (pPackageDetail->pPlatformInfo->cLocales) {
        PackDWArrToAttr(pAttr+cAttr, LOCALEID, pPackageDetail->pPlatformInfo->prgLocale,
            pPackageDetail->pPlatformInfo->cLocales);
        cAttr++;
    }
    
    // fill in the installinfo
    
    PackStrToAttr(pAttr+cAttr, PACKAGENAME, pPackageDetail->pszPackageName);
    cAttr++;

    PackDWToAttr(pAttr+cAttr, PACKAGETYPE, (DWORD)(pPackageDetail->pInstallInfo->PathType));
    cAttr++;
    
    if (pPackageDetail->pInstallInfo->pszScriptPath) {
        PackStrToAttr(pAttr+cAttr, SCRIPTPATH, pPackageDetail->pInstallInfo->pszScriptPath);
        cAttr++;
    }
    
    if (pPackageDetail->pInstallInfo->pszSetupCommand) {
        PackStrToAttr(pAttr+cAttr, SETUPCOMMAND, pPackageDetail->pInstallInfo->pszSetupCommand);
        cAttr++;
    }
    
    if (pPackageDetail->pInstallInfo->pszUrl) {
        PackStrToAttr(pAttr+cAttr, HELPURL, pPackageDetail->pInstallInfo->pszUrl);
        cAttr++;
    }
    
    //
    // Store the current USN
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // package flags
    PackDWToAttr(pAttr+cAttr, PACKAGEFLAGS, pPackageDetail->pInstallInfo->dwActFlags);
    cAttr++;
    
    // product code, different from pkg guid
    PackGUIDToAttr(pAttr+cAttr, PRODUCTCODE, &(pPackageDetail->pInstallInfo->ProductCode));
    cAttr++;
    
    // Mvipc
    PackGUIDToAttr(pAttr+cAttr, MVIPC, &(pPackageDetail->pInstallInfo->Mvipc));
    cAttr++;

    // Hi Version of the package
    PackDWToAttr(pAttr+cAttr, VERSIONHI, pPackageDetail->pInstallInfo->dwVersionHi);
    cAttr++;

    
    // Low Version of the package
    PackDWToAttr(pAttr+cAttr, VERSIONLO, pPackageDetail->pInstallInfo->dwVersionLo);
    cAttr++;
    
    // Revision
    PackDWToAttr(pAttr+cAttr, REVISION, pPackageDetail->pInstallInfo->dwRevision);
    cAttr++;

    // scriptsize
    PackDWToAttr(pAttr+cAttr, SCRIPTSIZE, pPackageDetail->pInstallInfo->cScriptLen);
    cAttr++;
    
    // uilevel
    PackDWToAttr (pAttr+cAttr, UILEVEL, (DWORD)pPackageDetail->pInstallInfo->InstallUiLevel);
    cAttr++;
    
    // adding cUpgrade number of Classstore/PackageGuid combinations
    if (pPackageDetail->pInstallInfo->cUpgrades) 
    {
        WCHAR szPackageGuid[_MAX_PATH];

        rpszUpgrades = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*pPackageDetail->pInstallInfo->cUpgrades);
        if (!rpszUpgrades)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++) 
        {
            UINT len = wcslen(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore);
            rpszUpgrades[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) *(36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2));
                                                        // Guid size+::+length++:+flagDigit+2 
            if (!rpszUpgrades[count])
            {
                FREEARR(rpszUpgrades, count);  
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
            }

            StringFromGUID(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].PackageGuid, 
                            szPackageGuid);
            wsprintf(rpszUpgrades[count], L"%s%s%s%s%02x",
                        pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore,
                        PKG_UPG_DELIMITER1,
                        szPackageGuid,
                        PKG_UPG_DELIMITER2, 
                        pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag%16);
        }
          
        PackStrArrToAttr(pAttr+cAttr, UPGRADESPACKAGES, rpszUpgrades,
            pPackageDetail->pInstallInfo->cUpgrades); 
        cAttr++;
    }
    
    // Fill in the source list 
    // Maintain the serial number associated with the sources. Order matters!!
    if (pPackageDetail->cSources) 
    {
        rpszSources = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(pPackageDetail->cSources));
        if (!rpszSources)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; count < (pPackageDetail->cSources); count++) 
        {
            rpszSources[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(pPackageDetail->pszSourceList[count])+
                                                    1+1+NumDigits10(pPackageDetail->cSources)));
            if (!rpszSources[count])
            {
                FREEARR(rpszSources, count);
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
            }
            wsprintf(rpszSources[count], L"%d:%s", count, pPackageDetail->pszSourceList[count]);
        }
        
        PackStrArrToAttr(pAttr+cAttr, MSIFILELIST, rpszSources, pPackageDetail->cSources);
        cAttr++;
    }
    
    // fill in the categories
    // Add the package Categories
    if (pPackageDetail->cCategories)
    {
        pszGuid4 = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->cCategories) * sizeof(LPOLESTR));
        if (!pszGuid4)
        {
            ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        for (count = 0; (count < pPackageDetail->cCategories); count++)
        {
            pszGuid4[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
            if (!pszGuid4[count])
            {
                FREEARR(pszGuid4, count);
                ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            
            StringFromGUID((pPackageDetail->rpCategory)[count], pszGuid4[count]);
        }
        
        PackStrArrToAttr(pAttr+cAttr, PKGCATEGORYLIST, pszGuid4, pPackageDetail->cCategories);
        cAttr++;
    }
    
    // fill in the vendor
    
    // Publisher
    if (pPackageDetail->pszPublisher) 
    {
        PackStrToAttr(pAttr+cAttr, PUBLISHER, pPackageDetail->pszPublisher);
        cAttr++;
    }
    
    /*    
    //
    // Store the script in the directory
    //
    if ((pPackageDetail->pInstallInfo->dwActFlags & SCRIPT_IN_DIRECTORY) && 
    (pPackageDetail->pInstallInfo->cScriptLen))
    {
    
      if ((pPackageDetail->pInstallInfo->cScriptLen) &&
      (!IsValidReadPtrIn(pPackageDetail->pInstallInfo->pScript, pPackageDetail->pInstallInfo->cScriptLen)))
      return E_INVALIDARG;
      
        if (pPackageDetail->pInstallInfo->cScriptLen)
        {
        PackBinToAttr(pAttr+cAttr, PKGSCRIPT, pPackageDetail->pInstallInfo->pScript,
						  pPackageDetail->pInstallInfo->cScriptLen);
                          cAttr++;
                          }
                          }
    */
    
    hr = ADSICreateDSObject(m_ADsPackageContainer, szRDN, pAttr, cAttr);
    ERROR_ON_FAILURE(hr);

    memset(pPkgGuid, 0, sizeof(GUID));

//    memcpy(pPkgGuid, &PackageGuidId, sizeof(GUID));

    hr = GetPackageGuid(szRDN, pPkgGuid);
    ERROR_ON_FAILURE(hr);

    fPackageCreated = TRUE;

    if (pPackageDetail->pActInfo)
    {
        for (count = 0; count < pPackageDetail->pActInfo->cClasses; count++) {
            hr = NewClass((pPackageDetail->pActInfo->pClasses)+count);
            ERROR_ON_FAILURE(hr);
        }
    }
    
    if (!(pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_Uninstall) &&
        !(pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_Orphan))
    {
        if (pPackageDetail->pInstallInfo->cUpgrades)
        {
            //
            // Need to fixup the other packages that this package upgrades
            //
            for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++)
            {
                if ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) ||
                    (pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall))
                {
                    DWORD Flags = 0;

                    if (pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_Enforced)
                        Flags = UPGFLG_Enforced;

                }
            }
            for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++)
                CoTaskMemFree(rpszUpgrades[count]);
            CoTaskMemFree(rpszUpgrades);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    for (count = 0; count < cAttr; count++)
        FreeAttr(pAttr[count]);
    
    if (pszGuid1) {
        for (count = 0; (count < pPackageDetail->pActInfo->cClasses); count++)
            CoTaskMemFree(pszGuid1[count]);
        CoTaskMemFree(pszGuid1);
    }
    
    if (pszGuid2) {
        for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++)
            CoTaskMemFree(pszGuid2[count]);
        CoTaskMemFree(pszGuid2);
    }
    
    if (pszGuid3) {
        for (count = 0; (count < (pPackageDetail->pActInfo->cTypeLib)); count++)
            CoTaskMemFree(pszGuid3[count]);
        CoTaskMemFree(pszGuid3);
    }
    
    if (pszGuid4) {
        for (count = 0; (count < pPackageDetail->cCategories); count++)
            CoTaskMemFree(pszGuid4[count]);
        CoTaskMemFree(pszGuid4);
    }
    
    if (pszFileExt) {
        for (count = 0; (count < pPackageDetail->pActInfo->cShellFileExt); count++)
            CoTaskMemFree(pszFileExt[count]);
        CoTaskMemFree(pszFileExt);
    }
    
    if (pdwArch) {
        CoTaskMemFree(pdwArch);
    }
    
    if (rpszSources) 
    {
        for (count = 0; (count < pPackageDetail->cSources); count++)
            CoTaskMemFree(rpszSources[count]);
        CoTaskMemFree(rpszSources);
    }

    //
    // On failure, the package should be removed from the ds if we
    // created it there.
    //
    if (FAILED(hr) && (fPackageCreated))
    {
        HRESULT hrDeleted;
        LPWSTR  wszPackageFullPath;

        //
        // Need to get a full path to the package in order to delete it.
        //
        hrDeleted = BuildADsPathFromParent(m_szPackageName, szRDN, &wszPackageFullPath);

        ASSERT(SUCCEEDED(hrDeleted));

        CSDBGPrint((L"AddPackage failed, attempting to remove deleted package with path %s\n", wszPackageFullPath));

        hrDeleted = DeletePackage(wszPackageFullPath);

        CSDBGPrint((L"DeletePackage returned %x\n", hrDeleted));
        
        //
        // Free the full path
        //
        CoTaskMemFree(wszPackageFullPath);
    }

    return RemapErrorCode(hr, m_szContainerName);
}

//+
//
// Cleanup old packages from Class Store based on lastChangeTime
//

HRESULT CClassContainer::Cleanup (
                                  FILETIME        *pTimeBefore
                                  )
{
    //
    // Delete all packages marked as "Uninstall"
    // OR "Orphan" and are older than the time given
    //
    
    ULONG               cRowsFetched = 0;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    WCHAR               szFilter[_MAX_PATH], szRDN[_MAX_PATH];
    HRESULT             hr = S_OK;
    ADS_ATTR_INFO       pAttr;
    SYSTEMTIME          SystemTime;
    ADS_SEARCH_COLUMN   column;
    DWORD               dwPackageFlags;
    LPOLESTR            pszPackageId = NULL;
    
    if ((!pTimeBefore) ||
        !IsValidReadPtrIn(pTimeBefore, sizeof(FILETIME)))
        return E_INVALIDARG;
    
    FileTimeToSystemTime(
        (CONST FILETIME *) pTimeBefore, 
        &SystemTime);  
    
    wsprintf (szFilter, 
        L"(%s<=%04d%02d%02d%02d%02d%02d)", 
        PKGUSN,
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);
    
    // execute the search and keep the handle returned.
    hr = ADSIExecuteSearch(m_ADsPackageContainer, szFilter, pszDeleteAttrNames,
        cDeleteAttr, &hADsSearchHandle);
    
    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    
    while (TRUE)
    {
        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;
        
        dwPackageFlags = 0;
        
        // Get the Package State
        hr = ADSIGetColumn(m_ADsPackageContainer, hADsSearchHandle, PACKAGEFLAGS, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwPackageFlags);
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        
        //
        // Check flag values to see if this package is Orphaned or Uninstalled
        //
        
        if ((dwPackageFlags & ACTFLG_Orphan) || (dwPackageFlags & ACTFLG_Uninstall)) 
        {
            
            hr = ADSIGetColumn(m_ADsPackageContainer, hADsSearchHandle, OBJECTDN, &column);
            
            if (SUCCEEDED(hr))
            {
                WCHAR    * szDN = NULL;

                UnpackStrFrom(column, &szDN);
                hr = DeletePackage(szDN);

                ADSIFreeColumn(m_ADsPackageContainer, &column);
                ERROR_ON_FAILURE(hr);
            }
        }
        hr = ADSIGetNextRow(m_ADsPackageContainer, hADsSearchHandle);  
    }
    
Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    return RemapErrorCode(hr, m_szContainerName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    csmain.cxx
//
//  Contents:    All the exposed APIs.
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//  Globals

//
// Link list pointer for Class Containers Seen
//
// CLASSCONTAINER *gpContainerHead = NULL;

//
// Link list pointer for User Profiles Seen
//
// USERPROFILE *gpUserHead = NULL;


//
// Class Factory Objects
//

CClassContainerCF   *   g_pCF       = NULL;
CAppContainerCF     *   pCF         = NULL; // BUGBUG:: Name should change.
CClassAccessCF      *   pCSAccessCF = NULL;

// Debugging Output Global values.
DWORD                    gDebugLog = 0;
DWORD                    gDebugOut = 0;
DWORD                    gDebugEventLog = 0;
DWORD                    gDebug = 0;

//IClassAccess        *   gpClassAccess = NULL;

//
//   Number of objects alive in cstore.dll
//
HINSTANCE g_hInst = NULL;
long ObjectCount = 0;
// ULONG  g_ulObjCount = 0;    

//
// Critical Section for All Global Objects.
//
CRITICAL_SECTION ClassStoreBindList;

void Uninitialize();
BOOL InitializeClassStore(BOOL fInit);

//
//---------------------------------------------------------------------
// Following are used for Supporting Test Scenarios thru FlushSidCache.
WCHAR pwszDebugPath [_MAX_PATH];
BOOL  fDebugPath = FALSE;
//---------------------------------------------------------------------


//-------------------------------------------------------------------
//  Function        Uninitialize
//
//  Synopsis:       Class Store Server Uninitialization.
//                  Disconnects from all Class Containers in use.
//                  Flushes out all State information using ResetClassStoreState.
//                  Unregisters Server registrations etc..
//
//  Arguments:      None
//
//  Returns:        None
//
//-------------------------------------------------------------------
void Uninitialize()
{
    //
    // Cleanup all open containers
    //

    //ResetClassStoreState();
    //
    // release the Class Factory objects
    //
    if (pCF)
        pCF->Release();
    if (pCSAccessCF)
        pCSAccessCF->Release();

    if (g_pCF)
        g_pCF->Release();
    //
    // get rid of the critical section
    //

    DeleteCriticalSection(&ClassStoreBindList);

}



//---------------------------------------------------------------------------
// Function:        FlushSidCache
//
//  Synopsis:       Supported for Testing Only. Not exposed thru any header.
//                  Currently useless and not implemented.
//
//  Arguments:      pwszNewPath
//
//  Returns:        S_OK
//
//---------------------------------------------------------------------------

HRESULT FlushSidCache (LPOLESTR pwszNewPath)
{
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Function:   InitDebugValues
//
//  Synopsis:   Initializes the Debug Values for the class store.
//
//  Arguments:
//   
//  Returns:
//      S_OK
//
// Log will go into the Debugger if the first bit is 1.
// If second bit is set, log will go into a log file.
// If third bit is set, log will go into event log.
//----------------------------------------------------------------
void InitDebugValues()
{
    DWORD       Size;
    DWORD       Type;
    DWORD       Status;
    HKEY        hKey;
    DWORD       DebugLevel = 0;

    Status = ERROR_SUCCESS;

    Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DIAGNOSTICS_KEY,
                    0,
                    KEY_READ,
                    &hKey );

    Size = sizeof(DebugLevel);

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegQueryValueEx(
                        hKey,
                        DIAGNOSTICS_APPDEPLOYMENT_VALUE,
                        NULL,
                        &Type,
                        (LPBYTE) &DebugLevel,
                        &Size );

        if ( (ERROR_SUCCESS == Status) && (Type != REG_DWORD) )
            DebugLevel = 0;

        RegCloseKey(hKey);
    }

    gDebugEventLog = DebugLevel & 4;
    gDebugLog = DebugLevel & 2;
    gDebugOut = DebugLevel & 1;

    gDebug = (gDebugOut || gDebugLog || gDebugEventLog);
}
//---------------------------------------------------------------------------
//
//  Function:   InitializeClassStore
//
//  History:    7-25-96   DebiM   Created
//
//  This entry point is called at DLL attach
//----------------------------------------------------------------------------
BOOL InitializeClassStore(BOOL fInit)
{
    HRESULT     hr;
    BOOL        bStatus;
    
    ObjectCount = 1;

    InitDebugValues();

    InitializeLanguageSupport();

    pCF = new CAppContainerCF();
    pCSAccessCF = new CClassAccessCF();

    NTSTATUS status = RtlInitializeCriticalSection(&ClassStoreBindList);

    g_pCF = new CClassContainerCF;

    if (!pCF || !pCSAccessCF || !g_pCF || !NT_SUCCESS(status))
    {
        ASSERT(FALSE);
        goto fail;
    }

    return TRUE;

fail:
    if (pCF)
        delete pCF;
    if (pCSAccessCF)
        delete pCSAccessCF;
    if (g_pCF)
    	{
    	delete g_pCF;
    	g_pCF = NULL;
    	}
    return FALSE;

}



void
GetDefaultPlatform(CSPLATFORM *pPlatform)
{
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId;
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;
    pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;
}


/*
void Uninit()
//
// This routine is called at dll detach time
//
{
    //
    // release the Class Factory object
    //
    if (g_pCF)
        g_pCF->Release();
}

*/    


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//  Arguments:
//  [in]    
//      clsid   
//              Clsid of the object.
//      iid     
//              Iid of the Class factory
//  [out]
//      ppv     Interface pointer to the Class Factory
//   
//  Returns:
//      S_OK, E_NOINTERFACE, E_OUTOFMEMORY
//
//  Gets the corresponding Class Factory Object and QIs with the IID. 
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualCLSID(clsid, CLSID_DirectoryClassBase))
    {
        return g_pCF->QueryInterface(iid, ppv);
    }
    
    if (IsEqualCLSID(clsid, CLSID_ClassAccess))
    {
        return pCSAccessCF->QueryInterface(iid, ppv);
    }

    *ppv = NULL;

    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//  
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//  Used By:
//              Used by OLE to see whether Dll can be unloaded.
//
// Arguments:
//           
// Returns :
//      S_FALSE.
//
//              Unimplemented currently.
//--------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // BugBug 
    //
    /*
    if (ulObjectCount > 0)
        hr = S_FALSE;
    else
        hr = S_OK;
    */
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   LibMain
//  
//  Synopsis:   Standard DLL initialization entrypoint.
//
//  Used By:
//              During loading and unloading of the DLL.
//
//  Arguments:
//  [in]
//      hInst: 
//              module Handle.
//      ulReason:
//              Reason why the DllMain procedure was called.
//      pvReserved:
//              Unused parameter.              
//           
//  Returns :
//      TRUE.
//  initializes the global variables in attach and frees them in detach
//
//--------------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
//    HRESULT     hr;
//    DWORD cbSize = _MAX_PATH;
//    WCHAR wszUserName [_MAX_PATH];

    switch (ulReason)
    {
    // Loading the Dll from the process.
    case DLL_PROCESS_ATTACH:
        // prevents thread level attach/detach calls.
        DisableThreadLibraryCalls(hInst);

        g_hInst = hInst;
        //g_pCF = new CClassContainerCF;
        InitializeClassStore(FALSE);
        break;


    // unloading the Dll from the process.
    case DLL_PROCESS_DETACH:
        //Uninit();
        Uninitialize();
        break;

    // ignoring thread attach and detach.
    default:
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:   DllMain
//  
//  Synopsis:   entry point for NT
//
//  Used By:
//              During loading and unloading of the DLL.
//
//  *Comments*:
//              Calls LibMain
//
// Arguments:
//  [in]
//      hDll: 
//              module Handle
//      dwReason:
//              Reason why the DllMain procedure was called.
//      lpReserved:
//              Unused parameter.              
//           
// Returns :
//      S_OK, CS_E_XXX errors.
//--------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}

//+-------------------------------------------------------------------------
//
//  Function:   CsGetClassAccess
//
//  Synopsis:   Returns an instantiated interface to the Class Store
//              Co-ordinator object in Rpcss.
//
//  Arguments:  [ppIClassAccess] - where to put class access interface pointer
//
//  Returns:    S_OK - Got a Class Access Successfully
//              E_FAIL
//
//--------------------------------------------------------------------------

STDAPI CsGetClassAccess(
    IClassAccess     **     ppIClassAccess)
{
    HRESULT     hr;
    *ppIClassAccess = NULL;

    hr = pCSAccessCF->CreateInstance( NULL, 
        IID_IClassAccess, 
        (void **)ppIClassAccess);

    return hr;

}

//+-------------------------------------------------------------------
//
// CsEnumApps (DebiM 11/7/97)
//
// Returns an enumerator for packages in the Class Store (s).
// The enumerator works across all class stores in the calling users profile.
//
//
// This is used by:
//    - Add/Remove programs to select Corporate Apps
//    - winlogon to obtain the list of assigned apps
//
// Arguments:
//  [in]
//        pszPackageName    :   Optional Wildcard string for PackageName
//        pLastUsn          :   Optional Time Stamp for new packages
//        pCategory         :   Optional CategoryId
//        dwAppFlags        :   Per APPINFO_xxx in objbase.h
//  [out]
//        ppIEnumPackage    :   Returned Interface Pointer
//
// Returns :
//      S_OK or E_NO_CLASSSTORE
//
//--------------------------------------------------------------------
STDAPI
CsEnumApps(
        LPOLESTR        pszPackageName,    // Wildcard string for PackageName
        GUID            *pCategory,        // CategoryId
        ULONGLONG       *pLastUsn,         // Time Stamp for new packages
        DWORD           dwAppFlags,        // Per APPINFO_xxx in objbase.h
        IEnumPackage    **ppIEnumPackage   // Returned Interface Pointer
        )
{
    HRESULT         hr;
    IClassAccess  * pIClassAccess = NULL;

    *ppIEnumPackage = NULL;

    //
    // Get an IClassAccess 
    //
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    //
    // Get the enumerator
    //
    hr = pIClassAccess->EnumPackages (
        pszPackageName,
        pCategory,
        pLastUsn,
        dwAppFlags,
        ppIEnumPackage
        );

    pIClassAccess->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetAppInfo
//  
//  Synopsis:   Gets Package Information for a package that matches
//              the query.
//
//  Used By:
//              services. CoCreateInstance (OLE)
//
//  Arguments:
//  [in]
//      pClassSpec: 
//              The query consisting of the name or clsid or ... 
//      pQueryContext:
//              Execution context, architecture/Platform/locale req'd, 
//              Default value is the ThreadLocale and the default Platform.
//
//  [out]
//      pPackageInfo
//              Neccessary Package Information.
//           
//  Returns :
//      S_OK, CS_E_XXX errors.
// 
//  Looks up the given class specification in the DS.  If an application for
//  this class specification is found, then the application details are returned.
//  Gets the IClassAccess Pointer and calls GetAppInfo on it.
//
//  Caller needs to FREE the pPackageInfo using the Release APIs.
//--------------------------------------------------------------------

STDAPI
CsGetAppInfo(
         uCLSSPEC          *   pClassSpec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT      *   pQueryContext,
         PACKAGEDISPINFO   *   pPackageInfo
         )
{
    HRESULT         hr = S_OK;
    IClassAccess  * pIClassAccess = NULL;
    
    // Gets the IClassAccess pointer
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    // Calls the GetAppInfo method 
    hr = pIClassAccess->GetAppInfo(pClassSpec, pQueryContext, pPackageInfo );
    pIClassAccess->Release();
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CsCreateClassStore
//  
//  Synopsis:   Creates the class store.
//
//  Used By:
//              mmc snapin.
//
//  Arguments:
//  [in]
//      szCSPath: 
//              Path where a new class store has to be created.
//           
//  Returns :
//      S_OK, CS_E_XXX errors.
// 
//  Removes the moniker if present, gets the parent containers Name (GPO)
//  and the name of the class store. Creates a Class Store with this name
//  Below the parent object. 
//--------------------------------------------------------------------

STDAPI
CsCreateClassStore(LPOLESTR szCSPath) 
{
    LPOLESTR szPath = NULL;
    LPOLESTR szParentPath=NULL, szStoreName=NULL;
    HRESULT  hr = S_OK;
    LPOLESTR szPolicyName = NULL, szUserMachine = NULL;

    // removing moniker ADCS: if present.
    if (wcsncmp (szCSPath, L"ADCS:", 5) == 0)
        szPath = szCSPath + 5;
    else
        szPath = szCSPath;

    // Getting the path for the parent (Policy object) from the name.
    hr = BuildADsParentPath(szPath, &szParentPath, &szStoreName);

    ERROR_ON_FAILURE(hr);

    // Get the Policy Object
    hr = BuildADsParentPath(szParentPath, &szPolicyName, &szUserMachine);
    if (!SUCCEEDED(hr))
    {
        szPolicyName = NULL;
    }

    if (szUserMachine)
        FreeADsMem(szUserMachine);

    // creating class store. returns CS_E_XXX errors when it returns.
    hr = CreateRepository(szParentPath, szStoreName, szPolicyName);
    
Error_Cleanup:

    if (szPolicyName)
        FreeADsMem(szPolicyName);

    if (szParentPath)
        FreeADsMem(szParentPath);

    if (szStoreName)
        FreeADsMem(szStoreName);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetClassStore
//  
//  Synopsis:   Gets the IClassAdmin interface pointer for the input class store.
//
//  Used By:
//              mmc snapin.
//
// Arguments:
//  [in]
//      szPath: 
//              Unicode Path For the Class Store.
//         
//  [out]
//      ppIClassAdmin: 
//              IClassAdmin interface pointer.
//              
//
// Returns :
//      S_OK, or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsGetClassStore(LPOLESTR szPath, void **ppIClassAdmin)
{
    // removing moniker ADCS: if present.
    if (wcsncmp (szPath, L"ADCS:", 5) == 0)
        szPath += 5;

    return g_pCF->CreateConnectedInstance(
                  szPath, 
                  ppIClassAdmin);
}

//+---------------------------------------------------------------
//
//  Function:   CsDeleteClassStore
//
//  Synopsis:   Public entrypoint for deleting a class store container from DS.
//              Not implemented.
//
//----------------------------------------------------------------

STDAPI
CsDeleteClassStore(LPOLESTR szPath)
{
    return E_NOTIMPL;

}

//+-------------------------------------------------------------------
//
//  Function:   CsRegisterAppCategory
//  
//  Synopsis:   Registers a cetegory under the Domain.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  Arguments:
//  [in]
//      pAppCategory:   
//              Category and its details that have to be added.
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsRegisterAppCategory(APPCATEGORYINFO *pAppCategory)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->RegisterAppCategory(pAppCategory);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsUnregisterAppCategory 
//  
//  Synopsis:   Unregister an AppCategory from the Domain.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  Arguments:
//  [in]
//      pAppCategoryId:   
//              Guid (category) that has to be unregistered.
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsUnregisterAppCategory (GUID *pAppCategoryId)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->UnregisterAppCategory(pAppCategoryId);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetAppCategories 
//  
//  Synopsis:   get the definitive list of Application Categories and descriptions
//              based on default Locale.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  *Comments*:
//              The caller needs to free the memory allocated using CoTaskMemFree().
//
//  Arguments:
//  [out]
//      AppCategoryList:   
//              Returned list of GUIDs and Unicode descriptions
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
// 
//  Gets the list of Categories published in the Domain.
//  The CALLER needs to FREE the memory using Release API.
//--------------------------------------------------------------------
STDAPI
CsGetAppCategories (APPCATEGORYINFOLIST  *pAppCategoryList)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->GetAppCategories (
                                         GetUserDefaultLCID(), 
                                         pAppCategoryList);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetClassStorePath
//  
//  Synopsis:   Returns the class store path.
//
//  Used By:
//              Winlogon/mmc snapin.
//  Arguments:
//  [in]
//      DSProfilePath: 
//              Path For the DS Object given to winlogon.
//              This is validated here.
//         
//  [out]
//      pCSPath: 
//              Unicode Path to the class store.
//           
// Returns :
//      S_OK, or CS_E_XXX error codes.
// 
//  Looks at the profile object and gets the DEFAULTCLASSSTOREPATH Property.
//  The CALLER needs to FREE the memory allocated using CoTaskMemFree().
//--------------------------------------------------------------------

STDAPI
CsGetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR *pCSPath)
{
    HRESULT        hr;

    //
    // Initialize locals
    //
    hr = S_OK;

    //
    // Initialize out parameters
    //
    *pCSPath = NULL;

    if (gDebug)
    {
        WCHAR   Name[32];
        DWORD   NameSize = 32;

        if ( ! GetUserName( Name, &NameSize ) )
            CSDBGPrint((L"GetClassStorePath GetUserName failed 0x%x", GetLastError()));
        else
            CSDBGPrint((L"GetClassStorePath as %s", Name));
    }

    //
    // Validate the ds path string -- make sure it's NULL terminated
    //
    if ((!DSProfilePath) || (IsBadStringPtr(DSProfilePath, _MAX_PATH)))
        ERROR_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Make sure the ldap prefix is there
    //
    if (wcsncmp (DSProfilePath, LDAPPREFIX, LDAPPREFIXLENGTH) != 0)
        ERROR_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Now build the class store path.  It would be nice if we could use
    // BuildADsPathFromParent to do this, but it does not allocate memory
    // with CoTaskMemalloc, and the interface to this function requires that
    // the returned cs path is freed by the caller with CoTaskMemfree -- thus
    // we have to do all the memory allocation and copying ourselfves.
    
    //
    // First, get memory -- length is just the length of the current ds path
    // in addition to the length for a path separator and the name of the class
    // store container
    //
    *pCSPath = (LPOLESTR) CoTaskMemAlloc(
        wcslen(DSProfilePath) * sizeof (WCHAR) +
        sizeof (WCHAR) +
        sizeof (CLASSSTORECONTAINERNAME));

    if (!(*pCSPath))
        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);

    //
    // Get the ds path past the prefix so we can use it
    // in creating the new path
    //
    LPOLESTR DSPathWithoutPrefix;
    
    DSPathWithoutPrefix = DSProfilePath + LDAPPREFIXLENGTH;

    //
    // currently, prefixing LDAP: at the beginning.
    //
    wsprintf(*pCSPath,
             L"%s%s", 
             LDAPPREFIX CLASSSTORECONTAINERNAME LDAPPATHSEP,
             DSPathWithoutPrefix);


Error_Cleanup:

    return RemapErrorCode(hr, DSProfilePath);
}

//+-------------------------------------------------------------------
//
//  Function:   CsSetClassStorePath
//  
//  Synopsis:   Sets the class store path.
//
//  Used By:
//              mmc snapin.
//
//  Arguments:
//  [in]
//      DSProfilePath: 
//              Path For the DS Object given to winlogon.
//              This is validated here.
//         
//  [in]
//      pCSPath: 
//              Unicode Path to the class store.
//
//  Returns :
//      S_OK, or CS_E_XXX error codes.
//
//  Sets The Class Store Path on the Profile Object.
//  The CALLER needs to FREE the memory allocated using CoTaskMemFree().
//--------------------------------------------------------------------

STDAPI
CsSetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR szCSPath)
{
    HRESULT        hr = S_OK;
    HANDLE         hADs = NULL;
    LPWSTR         AttrName = {DEFAULTCLASSSTOREPATH};
    ADS_ATTR_INFO  Attr[1];
    DWORD          cModified = 0;

    if ((!DSProfilePath) || (IsBadStringPtr(DSProfilePath, _MAX_PATH)))
        return E_INVALIDARG;

    if ((!szCSPath) || (IsBadStringPtr(szCSPath, _MAX_PATH)))
        return E_INVALIDARG;
   

    // Packing Class store Path minus LDAP: at the beginning.
    if (_wcsnicmp(szCSPath, L"ADCS:", 5) == 0)
        szCSPath += 5;

    PackStrToAttr(Attr, AttrName, szCSPath+wcslen(LDAPPREFIX));

    // binding to the Policy Object.
    hr = ADSIOpenDSObject(DSProfilePath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                                   &hADs);
    ERROR_ON_FAILURE(hr);

    // setting class store path.
    hr = ADSISetObjectAttributes(hADs, Attr, 1, &cModified);

    // releasing the interface handle
    ADSICloseDSObject(hADs);

Error_Cleanup:
    return RemapErrorCode(hr, DSProfilePath);
}




//----------------The release APIs-------------------------
STDAPI
ReleasePackageInfo(PACKAGEDISPINFO *pPackageInfo)
{
    DWORD i;
    if (pPackageInfo) 
    {
        CoTaskMemFree(pPackageInfo->pszScriptPath);
        CoTaskMemFree(pPackageInfo->pszPackageName);
        CoTaskMemFree(pPackageInfo->pszPolicyName);
        for (i = 0; i < (pPackageInfo->cUpgrades); i++) 
            CoTaskMemFree(pPackageInfo->prgUpgradeInfoList[i].szClassStore);
        CoTaskMemFree(pPackageInfo->prgUpgradeInfoList);
        CoTaskMemFree(pPackageInfo->pszPublisher);
    }
    return S_OK;
}

STDAPI
ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryInfoList)
{
    DWORD i;
    if (pAppCategoryInfoList) 
    {
        for (i = 0; i < (pAppCategoryInfoList->cCategory); i++) 
            CoTaskMemFree((pAppCategoryInfoList->pCategoryInfo)[i].pszDescription);
        CoTaskMemFree(pAppCategoryInfoList->pCategoryInfo);
    }
    return S_OK;
}

STDAPI
ReleaseInstallInfo(INSTALLINFO *pInstallInfo)
{
    DWORD i;
    if (pInstallInfo)
    {
        CoTaskMemFree(pInstallInfo->pszSetupCommand);
        CoTaskMemFree(pInstallInfo->pszScriptPath);
        CoTaskMemFree(pInstallInfo->pszUrl);
        CoTaskMemFree(pInstallInfo->pClsid);
        for (i = 0; i < (pInstallInfo->cUpgrades); i++) 
            CoTaskMemFree(pInstallInfo->prgUpgradeInfoList[i].szClassStore);
        CoTaskMemFree(pInstallInfo->prgUpgradeInfoList);
    }
    return S_OK;
}

void
ReleaseClassDetail(CLASSDETAIL ClassDetail)
{
    DWORD i;
    for (i = 0; i < ClassDetail.cProgId; i++)
        CoTaskMemFree(ClassDetail.prgProgId[i]);
    CoTaskMemFree(ClassDetail.prgProgId);
}

STDAPI
ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail)
{
   DWORD i;
   if (pPackageDetail) 
   {
       if (pPackageDetail->pActInfo)
       {   
           for (i = 0; i < pPackageDetail->pActInfo->cClasses; i++)
               ReleaseClassDetail((pPackageDetail->pActInfo->pClasses)[i]);
           CoTaskMemFree(pPackageDetail->pActInfo->pClasses);
           
           for (i = 0; i < pPackageDetail->pActInfo->cShellFileExt; i++)
               CoTaskMemFree((pPackageDetail->pActInfo->prgShellFileExt)[i]);
           CoTaskMemFree(pPackageDetail->pActInfo->prgShellFileExt);

           CoTaskMemFree(pPackageDetail->pActInfo->prgPriority);
           CoTaskMemFree(pPackageDetail->pActInfo->prgInterfaceId);
           CoTaskMemFree(pPackageDetail->pActInfo->prgTlbId);
           CoTaskMemFree(pPackageDetail->pActInfo);
       }
       
       if (pPackageDetail->pPlatformInfo)
       {
           CoTaskMemFree(pPackageDetail->pPlatformInfo->prgPlatform);
           CoTaskMemFree(pPackageDetail->pPlatformInfo->prgLocale);
           CoTaskMemFree(pPackageDetail->pPlatformInfo);
       }
       
       if (pPackageDetail->pInstallInfo)
       {
           ReleaseInstallInfo(pPackageDetail->pInstallInfo);
           CoTaskMemFree(pPackageDetail->pInstallInfo);
       }
       
       for (i = 0; i < (pPackageDetail->cSources); i++)
           CoTaskMemFree(pPackageDetail->pszSourceList[i]);
       CoTaskMemFree(pPackageDetail->pszSourceList);

       CoTaskMemFree(pPackageDetail->pszPackageName);
       CoTaskMemFree(pPackageDetail->rpCategory);
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csinst.cxx ===
/*
* csinst.cxx

  Author: DebiM
  
    This is a tool to install an empty Class Repository for a NTDS DC.
    This needs to be run after a successful NTDS installation.
    It creates an empty repository in the domain.
    
*/

#include "ole2int.h"
#include <rpc.h>
#include "cstore.h"
//dsbase.hxx"



//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  History:    10-22-96   DebiM   Created
//
//----------------------------------------------------------------------------
void _cdecl main( int argc, char ** argv)
{
    HRESULT     hr;
    WCHAR       szPath [_MAX_PATH + 1];    
    
    hr = CoInitialize(NULL);
    if ( FAILED(hr) )
    {
        printf( "CoInitialize failed(%x)\n", hr );
        return;
    }
    
    
    if (argc == 2)
    {
        //
        // Use the path for the container passed as parameter
        //
        
        MultiByteToWideChar (CP_ACP, 0, argv [1], strlen (argv[1]) + 1, szPath, _MAX_PATH);
        hr = CsCreateClassStore(szPath);
    }
    else
    {
        printf( "Usage is >> csinst <Class Store Path>\n");
        CoUninitialize();
        return;
    }
    
    if (FAILED(hr))
    {
        printf( "Failed to create repository - %S. Error - 0x%x\n", 
            szPath, hr);
    }
    else
    {
        printf( "Created Repository at - %S.\n", 
            szPath);
    }
    
    CoUninitialize();
    return;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\cspath.cxx ===
#include "cstore.hxx"

HRESULT
GetAppmgmtIniFilePath(
    PSID        pSid,
    LPWSTR*     ppwszPath
    )
{
    UNICODE_STRING  SidString;
    PTOKEN_USER     pTokenUser;
    WCHAR           wszPath[MAX_PATH];
    WCHAR *         pwszSystemDir;
    DWORD           AllocLength;
    DWORD           Length;
    DWORD           Size;
    DWORD           Status;
    BOOL            bStatus;

    Status = ERROR_SUCCESS;
    *ppwszPath = 0;

    pwszSystemDir = wszPath;
    AllocLength = sizeof(wszPath) / sizeof(WCHAR);

    for (;;)
    {
        Length = GetSystemDirectory(
                    pwszSystemDir,
                    AllocLength );

        if ( 0 == Length )
            return HRESULT_FROM_WIN32(GetLastError());

        if ( Length >= AllocLength )
        {
            AllocLength = Length + 1;
        
            //
            // No check for failure of alloca since it throws an 
            // exception on failure
            //
            pwszSystemDir = (WCHAR *) alloca( AllocLength * sizeof(WCHAR) );

            continue;
        }

        break;
    }

    if ( pSid )
    {
        if ( ERROR_SUCCESS == Status )
        {
            Status = RtlConvertSidToUnicodeString(
                                &SidString,
                                pSid,
                                TRUE );
        }

        if ( Status != ERROR_SUCCESS )
            return HRESULT_FROM_WIN32(Status);
    }
    else
    {
        RtlInitUnicodeString( &SidString, L"MACHINE" );
    }

    // System dir + \appmgmt\ + Sid \ + inifilename \ + null 
    *ppwszPath = new WCHAR[Length + 11 + (SidString.Length / 2) +
                          (sizeof(APPMGMT_INI_FILENAME) / sizeof(WCHAR))];

    if ( *ppwszPath )
    {
        lstrcpy( *ppwszPath, pwszSystemDir );
        if ( pwszSystemDir[lstrlen(pwszSystemDir)-1] != L'\\' )
            lstrcat( *ppwszPath, L"\\" );
        lstrcat( *ppwszPath, L"appmgmt\\" );
        lstrcat( *ppwszPath, SidString.Buffer );
        lstrcat( *ppwszPath, APPMGMT_INI_FILENAME );
    }
    else
    {
        Status = ERROR_OUTOFMEMORY;
    }

    if ( pSid )
        RtlFreeUnicodeString( &SidString );

    return HRESULT_FROM_WIN32(Status);
}



HRESULT ReadClassStorePath(PSID pSid, LPWSTR* ppwszClassStorePath)
{
    HRESULT hr;
    LPWSTR  wszIniFilePath;

    hr = GetAppmgmtIniFilePath(
        pSid,
        &wszIniFilePath);

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD  nBufferSize;
    DWORD  nCharsReceived;
    LPWSTR wszResult;

    nBufferSize = DEFAULT_CSPATH_LENGTH;
    wszResult = NULL;

    //
    // The GetPrivateProfileString function is so horribly designed
    // that we have to write this disgusting code below to deal with it
    //
    for (DWORD dwRetry = 0; dwRetry < 7; dwRetry++)
    {
        WCHAR DefaultBuffer = L'\0';

        wszResult = new WCHAR [nBufferSize];

        if (!wszResult)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // It turns out that this api has other issues as well -- if the file
        // doesn't exist it doesn't even return an error that would 
        // make sense (like 0) -- instead, I've seen it return 8!
        // To get around this interesting behavior, I'll set the first
        // character of the string to L'\0' before calling the api -- this means that
        // subsequent code will treat the failure as if we read a
        // zero length class store path from the file, which is the
        // desired behavior.
        //
        *wszResult = L'\0';

        nCharsReceived = GetPrivateProfileString(
            APPMGMT_INI_CSTORE_SECTIONNAME,
            APPMGMT_INI_CSPATH_KEYNAME,
            &DefaultBuffer,
            wszResult,
            nBufferSize,
            wszIniFilePath);

        //
        // If nothing is written, then there's no point in going forward
        // since this api returns the number of characters we need to write
        //
        if (!nCharsReceived) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            break;
        }

        if (nCharsReceived != (nBufferSize - 1))
        {
            break;
        }

        //
        // Double the size of the allocation
        //
        nBufferSize *= 2;  

        //
        // Free the previous allocation
        //
        delete [] wszResult;  

        wszResult = NULL;
    }

    if (wszResult && nCharsReceived) 
    {
        LPWSTR wszAllocatedCSPathForCaller;

        *ppwszClassStorePath = new WCHAR[nCharsReceived + 1];

        if (*ppwszClassStorePath)
        {
            wcscpy(*ppwszClassStorePath, wszResult);
        } 
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }

    delete [] wszResult;

    delete [] wszIniFilePath;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\csuser.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//  File:   csuser.cxx
//
//      Maintains a list of class containers per User SID.
//      Looks up this list for every IClassAccess call from OLE32/SCM.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

//
// Link list pointer for Class Containers Seen
//
extern CLASSCONTAINER *gpContainerHead;

//
// Link list pointer for User Profiles Seen
//
extern USERPROFILE *gpUserHead;


// Initialzed in InitializeClassStore at startup

extern CRITICAL_SECTION    ClassStoreBindList;

//-------------------------------------------------------------------------
//
// OpenUserRegKey
//
//  Opens a key under a user's HKEY_CLASSES_ROOT registry key.  On NT5
//  HKCR is equivalent to HKEY_USERS\{sid string}\Software\Classes.
//
//  A SID string is used to create
//  the proper registry key name to open.
//
//-------------------------------------------------------------------------
DWORD
OpenUserRegKey(
               IN  PSID        pSid,
               IN  WCHAR *     pwszSubKey,
               OUT HKEY *      phKey
               )
{
    UNICODE_STRING  UnicodeString;
    WCHAR *         pwszKey;
    DWORD           AllocSize;
    NTSTATUS        Status;
    
    UnicodeString.Length = UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = 0;
    
    Status = RtlConvertSidToUnicodeString(
        &UnicodeString,
        pSid,
        (BOOLEAN)TRUE // Allocate
        );
    
    //
    // Don't return a raw NT status code.  This is the only possible error
    // condition presuming our sid is valid.
    //
    if ( Status != STATUS_SUCCESS )
        return ERROR_OUTOFMEMORY;
    
    //
    // Your friendly reminder, unicode string length is in bytes and doesn't include
    // null terminator, if any.
    // Add byte for '\\' and end null.
    //
    AllocSize = UnicodeString.Length + ((1 + lstrlen(pwszSubKey) + 1) * sizeof(WCHAR));
    pwszKey = (WCHAR *) alloca( AllocSize );
    
    if ( pwszKey )
    {
        memcpy( pwszKey, UnicodeString.Buffer, UnicodeString.Length );
        pwszKey[UnicodeString.Length / 2] = L'\\';
        lstrcpyW( &pwszKey[(UnicodeString.Length / 2) + 1], pwszSubKey );
    }
    
    RtlFreeUnicodeString( &UnicodeString );
    
    if ( ! pwszKey )
        return ERROR_OUTOFMEMORY;
    
    Status = RegOpenKeyEx(
        HKEY_USERS,
        pwszKey,
        0,
        KEY_READ,
        phKey );
        
    return Status;
}

//
// GetUserSid
// ----------
//
//  Synopsis:       return the user SID of the caller.
//
//  Arguments:      &PSID       -       Where to store the caller's PSID
//
//  Returns:        HRESULT     -       S_OK if successful
//                                      E_FAIL otherwise
//
SID     LocalSystemSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };


HRESULT GetUserSid(PSID *ppUserSid, UINT *pCallType)
{
    BYTE            achBuffer[100];
    PTOKEN_USER     pUser = (PTOKEN_USER) &achBuffer;
    PSID            pSid;
    DWORD           dwBytesRequired;
    BOOL            fAllocatedBuffer = FALSE;
    HRESULT         hr = S_OK;
    HANDLE          hUserToken = NULL;
    BOOL            fImpersonated = TRUE;
    
    
    *pCallType = CS_CALL_USERPROCESS;
    
    // Initialize
    *ppUserSid = NULL;
    
    // Get caller's token while impersonating
    
    if (!OpenThreadToken(GetCurrentThread(),
        TOKEN_DUPLICATE | TOKEN_QUERY,
        TRUE,
        &hUserToken))
    {
        fImpersonated = FALSE;
        if (ERROR_NO_TOKEN != GetLastError())
            return HRESULT_FROM_WIN32(GetLastError());
        
        if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_DUPLICATE | TOKEN_QUERY,
            &hUserToken))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (!GetTokenInformation(
            hUserToken,                // Handle
            TokenUser,                 // TokenInformationClass
            pUser,                     // TokenInformation
            sizeof(achBuffer),         // TokenInformationLength
            &dwBytesRequired           // ReturnLength
            ))
        {
            
            //
            // Need to handle the case of insufficient buffer size.
            //
            
            if (sizeof(achBuffer) >= dwBytesRequired)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            
            
            if (SUCCEEDED(hr))
            {
                //
                // Allocate space for the user info
                //
                
                pUser = (PTOKEN_USER) CoTaskMemAlloc(dwBytesRequired);
                if (pUser == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            
            if (SUCCEEDED(hr))
            {
                fAllocatedBuffer = TRUE;
                
                //
                // Read in the UserInfo
                //
                
                
                if (!GetTokenInformation(
                    hUserToken,                // Handle
                    TokenUser,                 // TokenInformationClass
                    pUser,                     // TokenInformation
                    dwBytesRequired,           // TokenInformationLength
                    &dwBytesRequired           // ReturnLength
                    ))
                    
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
        
    }
    
    if (hUserToken)
    {
        CloseHandle( hUserToken );
        hUserToken = NULL;
    }
    
    if (SUCCEEDED(hr))
    {
        
        //
        // Distinguish between
        //            a) LOCAL_SYSTEM,
        //            b) Impersonated Call from a LOCAL_SYSTEM
        // and        c) In_proc call from a user process
        //
        // For case (c) make the SID null.
        //
        
        if (EqualSid(pUser->User.Sid, &LocalSystemSid))
        {
            *pCallType = CS_CALL_LOCALSYSTEM;
        }
        else
        {
            if (fImpersonated)
            {
                *pCallType = CS_CALL_IMPERSONATED;
            }
            else
            {
                *pCallType = CS_CALL_USERPROCESS;
            }
        }
        
        // Alloc buffer for copy of SID
        
        dwBytesRequired = GetLengthSid(pUser->User.Sid);
        *ppUserSid = CoTaskMemAlloc(dwBytesRequired);
        if (*ppUserSid == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Copy SID
            
            if (!CopySid(dwBytesRequired, *ppUserSid, pUser->User.Sid))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CoTaskMemFree(*ppUserSid);
                *ppUserSid = NULL;
            }
        }
    }
    
    if (fAllocatedBuffer == TRUE)
    {
        CoTaskMemFree(pUser);
    }
    
    return hr;
}


#if 0
//
// GetDomainClassStore
// -------------------
//
//  This will go away.
//
//  Currently this is used to get the Class Store Path
//  for the domain.
//


#define     DEFAULTSTORENAME  L"CN=ClassStore"


HRESULT
GetDomainClassStore(
                    LPOLESTR * pszDefaultContainer,
                    LPOLESTR * pszDefaultStore)
                    
                    //
                    // Finds the Root Path for the DC for this machine
                    // Then gets the Default Known CLass Store for the DC
                    //
{
    HRESULT         hr;
    LPOLESTR        PathNames[2];
    VARIANT         * pVarFilter = NULL;
    IEnumVARIANT    * pEnum;
    IADs          * pADs;
    VARIANT         VariantArray[2];
    IDispatch       * pDispatch = NULL;
    ULONG           cFetched;
    IADsContainer * pContainer = NULL;
    
    //
    // Do a bind to the DC by a GetObject for the Path LDAP:
    //
    hr = ADsGetObject(
        L"LDAP:",
        IID_IADsContainer,
        (void **)&pContainer
        );
    
    RETURN_ON_FAILURE(hr);
    
    hr = ADsBuildEnumerator(
        pContainer,
        &pEnum
        );
    
    hr = ADsEnumerateNext(
        pEnum,
        1,
        VariantArray,
        &cFetched
        );
    
    pEnum->Release();
    
    if ((hr == S_FALSE) || (cFetched == 0))
    {
        return E_FAIL;
    }
    
    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*2);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) &pADs) ;
    pDispatch->Release();
    
    pADs->get_ADsPath(pszDefaultContainer);
    pADs->Release();
    pContainer->Release();
    
    *pszDefaultStore = DEFAULTSTORENAME;
    
    return S_OK;
}


#endif

PCLASSCONTAINER
GetClassStore (LPOLESTR pszPath)
{
    
    PCLASSCONTAINER pCS = NULL;
    
    pCS = (CLASSCONTAINER *) CoTaskMemAlloc (sizeof(CLASSCONTAINER));
    if (!pCS)
        return NULL;

    pCS->gpClassStore = NULL;
    pCS->cBindFailures = 0;
    pCS->cAccess = 0;
    pCS->cNotFound = 0;
    pCS->pszClassStorePath = (LPOLESTR)CoTaskMemAlloc
        (sizeof(WCHAR) * (wcslen(pszPath)+1));
    if (!(pCS->pszClassStorePath))
    {
        CoTaskMemFree(pCS);
        return NULL;
    }

    wcscpy (pCS->pszClassStorePath, pszPath);
    //++cStores;
    
    return pCS;
}


extern WCHAR pwszDebugPath [];
extern BOOL  fDebugPath;

//
// GetPerUserClassStore
// ---------------------
//
//  Synopsis:       Gets the ADT Class Store List from the
//                  per-user Registry.
//                  Returns error if none defined,
//
//  Arguments:
//                  [out] ppStoreList : where to store list of class container
//                                      serial numbers
//                  [out] pcStores    : where to store number of class containers
//
//  Returns:        S_OK,
//
//  History:        Changed by (DebiM)
//                  2/24/97
//                  return a NULL list of Class Stores when none defined.
//

HRESULT GetPerUserClassStore(
                             PSID      pSid,
                             UINT      CallType,
                             LPOLESTR  **ppStoreList,
                             DWORD     *pcStores)
                             
{
    LONG    lErrorCode;
    DWORD    dwDataLen = 0;
    DWORD    dwType;
    HKEY    hKey = NULL;
    HRESULT hr = S_OK;
    LPOLESTR pszPath, pszStart;
    LPOLESTR *ppszPath;
    LPWSTR pszPathList=NULL;
    
    *pcStores = 0;
    *ppStoreList = NULL;
    
    if (!fDebugPath)
    {
        switch (CallType)
        {
        case CS_CALL_LOCALSYSTEM :
            CSDBGPrint((L"Reading HKLM for class store path"));
            break;
            
        case CS_CALL_IMPERSONATED :
            CSDBGPrint((L"Reading as an impersonated user for class store path"));
            break;
            
        case CS_CALL_USERPROCESS :
            CSDBGPrint((L"Reading HKCU for class store path"));            
            break;

        default:
            return E_FAIL;
        }
        
        HRESULT hrCSPath;

        hrCSPath = ReadClassStorePath(
            CallType != CS_CALL_LOCALSYSTEM ? pSid : NULL,
            &pszPathList);

        if (FAILED(hrCSPath))
        {
            // treat as NULL list of Class Stores
            delete [] pszPathList;
            return S_OK;
        }
    }
    else  // Test Mode - Privately Set Path - Only for testing
    {
        wcscpy (&pszPathList[0], &pwszDebugPath[0]);
    }

    // counting the number of ';'s and the number of class stores.
    // assuming that it ends with a ;

    DWORD cTentativeStores = 0;

    for (pszPath = pszPathList, cTentativeStores = 0;
            (pszPath = wcschr(pszPath, L';'));)
    {
        ++(cTentativeStores); pszPath++;
    }
    
    ++(cTentativeStores);

    pszPath = pszPathList;
    
    ppszPath = *ppStoreList = (LPOLESTR *) CoTaskMemAlloc
        (sizeof(LPOLESTR) * (cTentativeStores));
    
    if (*ppStoreList == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    memset (*ppStoreList, 0, sizeof(LPOLESTR) * (cTentativeStores));

    //
    // Parse the list to separate different class containers
    //

    while (*pszPath)
    {
        while (*pszPath == L' ')
            ++pszPath;
        pszStart = pszPath;
        
        if (!*pszPath)
            break;
        if (*pszPath == L';')
        {
            ++pszPath;
            continue;
        }
        
        while (*pszPath && (*pszPath != L';'))
            ++pszPath;
        
        //
        // got one. save it.
        //
        *ppszPath = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (ULONG) (pszPath - pszStart + 1));

        if (!(*ppszPath))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        memcpy (*ppszPath, pszStart, sizeof (WCHAR) * (ULONG) (pszPath - pszStart));
        *((*ppszPath)+(pszPath - pszStart)) = NULL;

        (ppszPath)++;
        
        if (*pszPath == L';')
        {
            ++pszPath;
        }

        (*pcStores)++;

        if ((*pcStores) == cTentativeStores)
            break;
    }
    
    delete [] pszPathList;
    return S_OK;

Error_Cleanup:
    DWORD i;
    for (i = 0; i < (*pcStores); i++) 
    {
        if (ppszPath[i])
            CoTaskMemFree(ppszPath[i]);
    }
    CoTaskMemFree(ppszPath);
        
    ppStoreList = NULL;

    (*pcStores) = 0;
    if (pszPathList)
        CoTaskMemFree(pszPathList);

    return hr;
}


//
// GetUserClassStores
// ------------------
//
//  Synopsis:       This routine reads the Class Store list and parses it.
//                  If it has prior knowledge it reurns the parsed list.
//  Arguments:
//                  [out]  pcStores: Number of Class Stores
//                  [out]  ppStoreIdList: Class Store Id List,
//
//  Returns:        S_OK
//                  May return a NULL list of Class Stores.
//
//


HRESULT GetUserClassStores(
                           PCLASSCONTAINER     **ppStoreList,
                           DWORD                *pcStores,
                           BOOL                 *pfCache,
                           PSID                 *ppUserSid)
{
    HRESULT          hr = S_OK;
    UINT             CallType;
    PCLASSCONTAINER *pList = NULL;
    DWORD            i;

    //
    // Get the SID of the calling process
    //
    
    hr = GetUserSid(ppUserSid, &CallType);

    if (FAILED(hr))
    {
        *ppUserSid = NULL;
        hr = S_OK;
    }

    *pfCache = (CallType == CS_CALL_IMPERSONATED);

    if (gDebug)
    {
        if (*pfCache)
            CSDBGPrint((L"Cache the class store"));
    }
    
    EnterCriticalSection (&ClassStoreBindList);
    
    //
    // Get the Class Store List
    //
    LPOLESTR *ppStoreNameList = NULL;
    
    hr = GetPerUserClassStore(
        *ppUserSid, CallType, &ppStoreNameList, pcStores);
    
    //
    // Note that the above may return a NULL list of Class Stores
    //

    CSDBGPrint((L"Found %d ClassStores", (*pcStores)));
    
    if (SUCCEEDED(hr)) 
    {
        *ppStoreList = pList = (PCLASSCONTAINER *)
                        CoTaskMemAlloc (sizeof(PCLASSCONTAINER) * (*pcStores));

        if (!(*ppStoreList))
            hr = E_OUTOFMEMORY;
        else
            memset(pList, 0, sizeof(PCLASSCONTAINER) * (*pcStores));
    }

    if (SUCCEEDED(hr))
    {    
        for (i=0; i < (*pcStores); i++)
        {
            *pList = GetClassStore (ppStoreNameList[i]);
            if (!(*pList))
            {
                // free all the ones that have been allocated.
                DWORD j;
                for (j = 0; j < (*pcStores); j++)
                    if (*pList)
                    {
                        if ((*pList)->pszClassStorePath)
                            CoTaskMemFree((*pList)->pszClassStorePath);
                        CoTaskMemFree(*pList);    
                    }

                hr = E_OUTOFMEMORY;
                (*pcStores) = 0;
                break;
            }

            pList++;
        }
    }

    if (ppStoreNameList)
    {
        for (i=0; i < (*pcStores); ++i)
        {
            if (ppStoreNameList[i])
                CoTaskMemFree (ppStoreNameList[i]);
        }
    }
    
    if (ppStoreNameList)
        CoTaskMemFree (ppStoreNameList);
    
    LeaveCriticalSection (&ClassStoreBindList);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\dscon.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//
//      Class Store Schema creation and access using ADs
//
//      This source file contains implementations for IClassAccess,
//      interface for CClassAccess object.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

HRESULT CreateContainer (HANDLE pParent,
                         LPOLESTR szName,
                         LPOLESTR szDesc
                         )
{
    
    HRESULT         hr;
    int             l;
    ADS_ATTR_INFO   Attr[3];
    
    //
    // Use the Parent Container interface to Create the child.
    //
    
    PackStrToAttr(Attr, OBJECTCLASS, CLASS_CS_CONTAINER);
    
    PackStrToAttr(Attr+1, DESCRIPTION, szDesc);

	//
    // Set its schema version
    //
    //PackDWToAttr(Attr+2, STOREVERSION, SCHEMA_VERSION_NUMBER);
    
    hr = ADSICreateDSObject(pParent, szName, Attr, 2);
    
    return hr;
    
}



HRESULT CreateRepository(LPOLESTR szParentPath, LPOLESTR szStoreName, LPOLESTR szPolicyDn)
{
    
    HRESULT         hr = S_OK;
    HANDLE          hADsParent = NULL;
    HANDLE          hADsContainer = NULL;
    HANDLE          hADsPolicy = NULL;
    LPOLESTR        szContainerName = NULL;
    LPOLESTR        szPolicyName = NULL;
    int             l;
    WCHAR           szPath [_MAX_PATH];
    WCHAR         * szFullName = NULL;
    WCHAR           szUsn[30];
    ADS_ATTR_INFO   pAttr[4];   
    DWORD           cGot = 0, cModified = 0;
    BOOL            fCreatedContainer = FALSE,
                    fCreatedCategories = FALSE,
                    fCreatedClasses = FALSE;
    LPOLESTR        AttrName = GPNAME;
    ADS_ATTR_INFO   * pGetAttr = NULL;
        
    if (!szParentPath)
    {
        hr = GetRootPath(szPath);
        //
        // If failed go away
        //
        if (FAILED(hr))
        {
            return hr;
        }
        
        szParentPath = szPath;
    }
    
    //
    // First get the PolicyName
    //
    if (szPolicyDn)
    {        
        hr = ADSIOpenDSObject(szPolicyDn, NULL, NULL, ADS_SECURE_AUTHENTICATION,
            &hADsPolicy);
        RETURN_ON_FAILURE(hr);
        
        //
        // Get the PolicyName
        //
        
        hr = ADSIGetObjectAttributes(hADsPolicy, &AttrName, 1, &pGetAttr, &cGot);
        
        if (SUCCEEDED(hr) && (cGot))
            UnpackStrAllocFrom(pGetAttr[0], &szPolicyName);
    
        if (pGetAttr)
            FreeADsMem(pGetAttr);
        pGetAttr = NULL;

        ADSICloseDSObject(hADsPolicy);
    }

    hr = ADSIOpenDSObject(szParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADsParent);
    RETURN_ON_FAILURE(hr);
    
    hr = CreateContainer(hADsParent,
        szStoreName,
        L"Application Store");

    //
    // handle this error correctly
    // see if a broken class store is left behind
    // this could happen due to DS going down after incomplete creation etc.
    // from the class store container property you could tell
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) ||
	    (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))
    {
        //
        // There is a Class Store already
        // See if it is a good one.

        DWORD dwStoreVersion = 0;
        hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
        if (!SUCCEEDED(hr))
            return CS_E_OBJECT_ALREADY_EXISTS;
        
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
            &hADsContainer);
        
        FreeADsMem(szFullName);
        if (!SUCCEEDED(hr))
            return CS_E_OBJECT_ALREADY_EXISTS;

        AttrName = STOREVERSION;
        //
        // Get the Store Version
        //
        
        hr = ADSIGetObjectAttributes(hADsContainer, &AttrName, 1, &pGetAttr, &cGot);
        
        if (SUCCEEDED(hr) && (cGot))
            UnpackDWFrom(pGetAttr[0], &dwStoreVersion);
        
        if (pGetAttr)
            FreeADsMem(pGetAttr);

        ADSICloseDSObject(hADsContainer);

        if (dwStoreVersion == SCHEMA_VERSION_NUMBER)
            return CS_E_OBJECT_ALREADY_EXISTS;

        // if it is zero, then it was aborted in the middle.
        if (dwStoreVersion != 0)
            return CS_E_SCHEMA_MISMATCH;

        // If it is a bad one try to delete it
        DeleteRepository(szParentPath, szStoreName);

        //
        // Then again try to create it and proceed if successful
        //
        
        hr = CreateContainer(hADsParent,
            szStoreName,
            L"Application Store");
        
    }

    ERROR_ON_FAILURE(hr);
    fCreatedContainer = TRUE;

    hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADsContainer);
    
    ERROR_ON_FAILURE(hr);
    

    //
    // Create the class container
    //
    
    hr = CreateContainer (hADsContainer,
        CLASSCONTAINERNAME,
        L"Application Object Classes");

    ERROR_ON_FAILURE(hr);
    fCreatedClasses = TRUE;
    
    
    //
    // Create the category container
    //
    
    hr = CreateContainer (hADsContainer,
        CATEGORYCONTAINERNAME,
        L"Component Categories");

    ERROR_ON_FAILURE(hr);
    fCreatedCategories = TRUE;
    
    //
    // Create the package container
    //
    
    hr = CreateContainer (hADsContainer,
        PACKAGECONTAINERNAME,
        L"Application Packages");
    
    ERROR_ON_FAILURE(hr);
    
    //
    // Store the USN and PolicyID properties
    //

    GetCurrentUsn(szUsn);
    
    PackStrToAttr(&pAttr[0], STOREUSN, szUsn);
    PackStrToAttr(&pAttr[1], POLICYDN, szPolicyDn);
    PackStrToAttr(&pAttr[2], POLICYNAME, szPolicyName);
    PackDWToAttr(&pAttr[3], STOREVERSION, SCHEMA_VERSION_NUMBER);
    
    hr = ADSISetObjectAttributes(hADsContainer, pAttr, 4, &cModified);

    FreeAttr(pAttr[0]);
    FreeAttr(pAttr[1]);
    FreeAttr(pAttr[2]);
    FreeAttr(pAttr[3]);
    
    ADSICloseDSObject(hADsContainer);
    ADSICloseDSObject(hADsParent);
    
    FreeADsMem(szFullName);
    CoTaskMemFree(szPolicyName);

    return RemapErrorCode(hr, szParentPath);

Error_Cleanup:
    
    if (fCreatedCategories)
        ADSIDeleteDSObject(hADsContainer, CATEGORYCONTAINERNAME);
    if (fCreatedClasses)
        ADSIDeleteDSObject(hADsContainer, CLASSCONTAINERNAME);
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);

    if (fCreatedContainer)
        ADSIDeleteDSObject(hADsParent, szStoreName);
    if (hADsParent)
        ADSICloseDSObject(hADsParent);

    if (szFullName)
        FreeADsMem(szFullName);
    if (szPolicyName)
        CoTaskMemFree(szPolicyName);
    
    return RemapErrorCode(hr, szParentPath);
   
}

    
HRESULT DeleteRepository(LPOLESTR szParentPath, LPOLESTR szStoreName)
{
    HRESULT         hr = S_OK;
    HANDLE          hADsParent = NULL;
    HANDLE          hADsContainer = NULL;
    WCHAR         * szFullName = NULL;
        
    hr = ADSIOpenDSObject(szParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADsParent);
    RETURN_ON_FAILURE(hr);
    
    hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, ADS_SECURE_AUTHENTICATION,
        &hADsContainer);
    FreeADsMem(szFullName);
    ERROR_ON_FAILURE(hr);

    ADSIDeleteDSObject(hADsContainer, CATEGORYCONTAINERNAME);
    ADSIDeleteDSObject(hADsContainer, CLASSCONTAINERNAME);
    ADSIDeleteDSObject(hADsContainer, PACKAGECONTAINERNAME);
    ADSICloseDSObject(hADsContainer);
    
    ADSIDeleteDSObject(hADsParent, szStoreName);
    ADSICloseDSObject(hADsParent);
    
    return S_OK;

Error_Cleanup:
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);
    if (hADsParent)
        ADSICloseDSObject(hADsParent);
    return hr;
}

HRESULT GetRootPath(LPOLESTR szContainer)
{
    HRESULT         hr = S_OK;
    ULONG           cGot = 0;
    HANDLE          hADs = NULL;
    LPOLESTR        AttrName = {L"defaultNamingContext"}, pDN = NULL;
    ADS_ATTR_INFO * pAttr = NULL;
    
    szContainer[0] = L'\0';

    //
    // Do a bind to the machine by a GetObject for the Path
    //
    hr = ADSIOpenDSObject(L"LDAP://rootdse", NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                            &hADs);
    RETURN_ON_FAILURE(hr);
    
    hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttr, &cGot);
    
    if (SUCCEEDED(hr) && (cGot))
        UnpackStrFrom(pAttr[0], &pDN);
    else
        pDN = L"\0";

    wsprintf(szContainer, L"%s%s", LDAPPREFIX, pDN);
    
    ADSICloseDSObject(hADs);

    if (pAttr)
        FreeADsMem(pAttr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\common\dscon.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//
//      Class Store Schema creation and access using ADs
//      
//      This source file contains implementations for IClassAccess,
//      interface for CClassAccess object.   
//
//
//---------------------------------------------------------------------

#include "dsbase.hxx"

HRESULT CreateContainer (IADsContainer * pParent, 
                 LPOLESTR szParentName, 
                 LPOLESTR szName, 
                 LPOLESTR szDesc,
                 IADsContainer ** ppChild)
{

    HRESULT         hr;
    IADs          * pADs = NULL;
    IDispatch       * pUnknown = NULL;
    int             l;
    //
    // Use the Parent Container interface to Create the child.
    //
    hr = pParent->Create(
                CLASS_CS_CONTAINER,
                szName,
                &pUnknown
                );
    
    RETURN_ON_FAILURE(hr);

    //
    // Get IADs pointer on the new object
    //
    hr = pUnknown->QueryInterface(
                        IID_IADs,
                        (void **)&pADs
                        );

    pUnknown->Release();

    RETURN_ON_FAILURE(hr);

    //
    // Set its description
    //
    hr = SetProperty (pADs, DESCRIPTION, szDesc);
    RETURN_ON_FAILURE(hr);

    //
    // Set its schema version
    //
    hr = SetPropertyDW (pADs, STOREVERSION, SCHEMA_VERSION_NUMBER);
    RETURN_ON_FAILURE(hr);
    //
    // persist the object
    //

    hr = StoreIt (pADs);
    RETURN_ON_FAILURE(hr);

    if (ppChild)
    {
        //
        // Get IADsContainer pointer on the child object to return
        //
        hr = pADs->QueryInterface(
                        IID_IADsContainer,
                        (void **)ppChild
                        );
    }

    pADs->Release();

    return hr;
}



HRESULT CreateRepository(LPOLESTR szParentPath, LPOLESTR szStoreName)
{

    HRESULT  hr;
    IADsContainer * pADsParent = NULL;
    IADsContainer * pADsContainer = NULL;
    LPOLESTR        szContainerName = NULL;
    int             l;
    WCHAR           szPath [_MAX_PATH+1];
	
    if (!szParentPath)
    {
        hr = GetRootPath(szPath);
		//
		// If failed go away
		//
	    if (FAILED(hr))
		{
			return hr;
		}
    
        szParentPath = szPath;
    }

    hr = ADsGetObject(
                szParentPath,
                IID_IADsContainer,
                (void **)&pADsParent
                );
    
    RETURN_ON_FAILURE(hr);
    hr = CreateContainer (pADsParent, 
                          szParentPath, 
                          szStoreName, 
                          L"Application Store",
                          &pADsContainer);
        
    pADsParent->Release();
    RETURN_ON_FAILURE(hr);

    //
    // Create the class container
    //

    hr = CreateContainer (pADsContainer, 
                          szContainerName, 
                          CLASSCONTAINERNAME, 
                          L"Application Object Classes",
                          NULL);
    RETURN_ON_FAILURE(hr);


    //
    // Create the category container
    //

    hr = CreateContainer (pADsContainer, 
                          szContainerName, 
                          CATEGORYCONTAINERNAME, 
                          L"Component Categories",
                          NULL);
    RETURN_ON_FAILURE(hr);

    //
    // Create the Packages container
    //

    hr = CreateContainer (pADsContainer, 
                          szContainerName, 
                          PACKAGECONTAINERNAME, 
                          L"Application Packages",
                          NULL);
    //CoTaskMemFree (szContainerName);
    pADsContainer->Release();
    RETURN_ON_FAILURE(hr);
    return S_OK;

}


HRESULT GetRootPath(LPOLESTR szContainer)
{
    HRESULT hr;
    IEnumVARIANT    * pEnum;
    IADs *pADs;
    VARIANT VariantArray[2];
    IDispatch *pDispatch = NULL;
    ULONG      cFetched;
    IADsContainer *pContainer = NULL;
	LPOLESTR      pszContainer;

    // 
    // Do a bind to the machine by a GetObject for the Path
    //
    hr = ADsGetObject(
                L"LDAP:",
                IID_IADsContainer,
                (void **)&pContainer
                );
    
	RETURN_ON_FAILURE(hr);

    hr = ADsBuildEnumerator(
            pContainer,
            &pEnum
            );
    
    hr = ADsEnumerateNext(
                    pEnum,
                    1,
                    VariantArray,
                    &cFetched
                    );

    pEnum->Release();

    if ((hr == S_FALSE) || (cFetched == 0))
    {
        return E_FAIL;
    }

    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*2);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) &pADs) ;
    pDispatch->Release();
    
    pADs->get_ADsPath(&pszContainer);
    pADs->Release();
    pContainer->Release();

	wcscpy (szContainer, pszContainer);
	SysFreeString (pszContainer);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\dsiface.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       dsiface.cxx
//
//  Contents:   ADs calls for Class Store Property Read/Write
//
//
//  History:    Sep-Oct 96.   DebiM
//
//----------------------------------------------------------------------------


#include "cstore.hxx"

#pragma warning ( disable : 4018 )
#pragma warning ( disable : 4244 )

//
// From CSPLATFORM to DS datatype
//
void
UnpackPlatform (DWORD *pdwArch,
                CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)pdwArch;
    
    *(pc) = (unsigned char)pPlatform->dwPlatformId;
    *(++pc) = (unsigned char)pPlatform->dwVersionHi;
    *(++pc) = (unsigned char)pPlatform->dwVersionLo;
    *(++pc) = (unsigned char)pPlatform->dwProcessorArch;
}

//
// From DS datatype to CSPLATFORM
//
void
PackPlatform (DWORD dwArch,
              CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)&dwArch;
    
    pPlatform->dwPlatformId = *(pc);
    pPlatform->dwVersionHi = *(++pc);
    pPlatform->dwVersionLo = *(++pc);
    pPlatform->dwProcessorArch = *(++pc);
}


//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID
//
//--------------------------------------------------------------------------
int  StringFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    swprintf(lptsz, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        rguid.Data1, rguid.Data2, rguid.Data3,
        rguid.Data4[0], rguid.Data4[1],
        rguid.Data4[2], rguid.Data4[3],
        rguid.Data4[4], rguid.Data4[5],
        rguid.Data4[6], rguid.Data4[7]);
    
    return 36;
}

//+-------------------------------------------------------------------------
//
//  Function:   RdnFromGUID
//
//--------------------------------------------------------------------------
int  RDNFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    wcscpy (lptsz, L"CN=");
    StringFromGUID(rguid, lptsz+3);
    return 3+36;
}

//BUGBUG. This belongs in a common library
void GUIDFromString(
                    LPOLESTR psz,
                    GUID *pclsguid)
                    //
                    // Converts a Stringified GUID to GUID structure
                    //
{
    WCHAR szC [40];
    LPOLESTR szClsId;
    LPOLESTR endptr;
    
    memset ((void *)pclsguid, NULL, sizeof (GUID));
    if ((!psz) ||
        (*psz == NULL))
        return;

    if (wcslen(psz) < 36)
        return;

    wcsncpy (&szC [0], psz, 36);
    szC[36] = L'\0';

    szClsId = &szC[0];
  
    *(szClsId+36) = NULL;
    pclsguid->Data4[7] = wcstoul (szClsId+34, &endptr, 16);

    *(szClsId+34) = NULL;
    pclsguid->Data4[6] = wcstoul (szClsId+32, &endptr, 16);

    *(szClsId+32) = NULL;
    pclsguid->Data4[5] = wcstoul (szClsId+30, &endptr, 16);

    *(szClsId+30) = NULL;
    pclsguid->Data4[4] = wcstoul (szClsId+28, &endptr, 16);

    *(szClsId+28) = NULL;
    pclsguid->Data4[3] = wcstoul (szClsId+26, &endptr, 16);

    *(szClsId+26) = NULL;
    pclsguid->Data4[2] = wcstoul (szClsId+24, &endptr, 16);
    
    *(szClsId+23) = NULL;
    pclsguid->Data4[1] = wcstoul (szClsId+21, &endptr, 16);

    *(szClsId+21) = NULL;
    pclsguid->Data4[0] = wcstoul (szClsId+19, &endptr, 16);
    
    *(szClsId+18) = NULL;
    pclsguid->Data3 = wcstoul (szClsId+14, &endptr, 16);

    *(szClsId+13) = NULL;
    pclsguid->Data2 = wcstoul (szClsId+9, &endptr, 16);

    *(szClsId+8) = NULL;
    pclsguid->Data1 = wcstoul (szClsId, &endptr, 16);
}

BOOL  IsNullGuid(REFGUID rguid)
{
    UINT i;
    
    if (rguid.Data1)
        return FALSE;
    if (rguid.Data2)
        return FALSE;
    if (rguid.Data3)
        return FALSE;
    for (i=0; i < 8; ++i)
    {
        if (rguid.Data4[i])
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\common\dsprop.cxx ===
#include "dsbase.hxx"

HRESULT PackGuid2Variant(
    GUID      guidData,
    VARIANT * pvData
    )
{

    SAFEARRAYBOUND size; // Get rid of 16
    SAFEARRAY FAR *psa;
    CHAR HUGEP *pArray=NULL;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    HRESULT  hr;

    size.cElements = sizeof(GUID);
    size.lLbound = 0;

    if (!pvData) {
        return(E_FAIL);
    }

    psa = SafeArrayCreate(VT_UI1, 1, &size);
    if (!psa) {
        return(E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData( psa, (void HUGEP * FAR *) &pArray );
    RETURN_ON_FAILURE(hr);
    memcpy( pArray, &guidData, size.cElements );
    SafeArrayUnaccessData( psa );

    V_VT(pvData) = VT_ARRAY | VT_UI1;
    V_ARRAY(pvData) = psa;
    return(S_OK);
}

HRESULT PackGuidArray2Variant(
    GUID      *guidData,
    ULONG     cguids,
    VARIANT * pvData
    )
{

    SAFEARRAYBOUND size, sizeguid;
    SAFEARRAY FAR *psa, *psaOctetString;
    CHAR HUGEP *pArray=NULL;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    HRESULT  hr;
    VARIANT  *var;
    ULONG    i;

    if (!pvData) {
           return(E_FAIL);
    }

    var = new VARIANT[cguids];
    if (!var)
            return E_OUTOFMEMORY;

    sizeguid.cElements = cguids;
    sizeguid.lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, &sizeguid);
    if (!psa)
            return E_OUTOFMEMORY;

    size.cElements = sizeof(GUID);
    size.lLbound = 0;

    for (i = 0; i < cguids; i++) {

            psaOctetString = SafeArrayCreate(VT_UI1, 1, &size);
            if (!psaOctetString) {
                return(E_OUTOFMEMORY);
            }

            hr = SafeArrayAccessData( psaOctetString, (void HUGEP * FAR *) &pArray );
            RETURN_ON_FAILURE(hr);

            memcpy( pArray, &(guidData[i]), size.cElements );
            SafeArrayUnaccessData( psaOctetString );

            V_VT(var+i) = VT_ARRAY | VT_UI1;
            V_ARRAY(var+i) = psaOctetString;

            SafeArrayPutElement(psa, (LONG *)&i, var+i);
            RETURN_ON_FAILURE(hr);
    }
    V_VT(pvData) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvData) = psa;
    return(S_OK);
}

HRESULT PackDWORDArray2Variant(
    DWORD    * pdwData,
    ULONG      cdword,
    VARIANT  * pvData
    )
{

    SAFEARRAYBOUND size, sizedword;
    SAFEARRAY FAR *psa;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT  *var = NULL;
    ULONG    i;

    if (!pvData) {
           return(E_FAIL);
    }

    var = new VARIANT[cdword];
    if (!var)
            return E_OUTOFMEMORY;

    sizedword.cElements = cdword;
    sizedword.lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, &sizedword);
    if (!psa)
            return E_OUTOFMEMORY;

    size.cElements = 1;
    size.lLbound = 0;

    for (i = 0; i < cdword; i++) {
            V_VT(var+i) = VT_I4;
            var[i].lVal = pdwData[i];
            SafeArrayPutElement(psa, (LONG *)&i, var+i);
    }

    V_VT(pvData) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pvData) = psa;
    return(S_OK);
}

HRESULT GetPropertyListAlloc(IADs *pADs,
                LPOLESTR pszPropName,
                DWORD *pCount,
                LPOLESTR **ppList)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    VARIANT var;

    *pCount = 0;
    *ppList = NULL;

    VariantInit(&var);

    hr = pADs->Get(pszPropName, &var);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        return S_OK;
    }

    RETURN_ON_FAILURE(hr);

    if(!((V_VT(&var) &  VT_VARIANT)))
    {
        return(E_FAIL);
    }

    //
    // The following is a work around
    //
    if (!V_ISARRAY(&var))
    {
        (*ppList) = (LPOLESTR *) CoTaskMemAlloc(sizeof(LPOLESTR));
        *pCount = 1;
        *(*ppList) = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(var.bstrVal)+1));
        wcscpy (*(*ppList), var.bstrVal);
        VariantClear(&var);
        return S_OK;
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1)
    {
        return E_FAIL;
    }
    //
    // Check that there is atleast one element in this array
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        *ppList = NULL;
        return S_OK; // was E_FAIL;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    RETURN_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    RETURN_ON_FAILURE(hr);

    (*ppList) = (LPOLESTR *) CoTaskMemAlloc(sizeof(LPOLESTR)*(dwSUBound-dwSLBound+1));

    for (i = dwSLBound; i <= dwSUBound; i++)
    {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );

        if (FAILED(hr))
        {
            continue;
        }

        if (i <= dwSUBound)
        {
            (*ppList)[*pCount] = (LPOLESTR) CoTaskMemAlloc
                 (sizeof (WCHAR) * (wcslen(v.bstrVal) + 1));
            wcscpy ((*ppList)[*pCount], v.bstrVal);
            VariantClear(&v);
            (*pCount)++;
        }
    }

    VariantClear(&var);
    return(S_OK);
}


HRESULT SetPropertyGuid (IADs *pADs, LPOLESTR pszPropName, GUID guidPropVal)
{
    VARIANT var;
    HRESULT hr;

    VariantInit(&var);
    hr = PackGuid2Variant(guidPropVal, &var);
    hr = pADs->Put(pszPropName, var);
    VariantClear(&var);
    return hr;
}


// replacing ADsBuildVarArrStr b'cos of mem leaks.

HRESULT
BuildVarArrayStr(
    LPWSTR *lppPathNames,
    DWORD  dwPathNames,
    VARIANT * pVar
    )
{

    VARIANT v;
    SAFEARRAYBOUND sabNewArray;
    DWORD i;
    SAFEARRAY *psa = NULL;
    HRESULT hr = E_FAIL;


    if (!pVar) {
        hr = E_ADS_BAD_PARAMETER;
        goto Fail;
    }
    VariantInit(pVar);

    sabNewArray.cElements = dwPathNames;
    sabNewArray.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabNewArray);

    if (!psa) {
        goto Fail;
    }

    for (i = 0; i < dwPathNames; i++) {

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;
        V_BSTR(&v) = SysAllocString(*(lppPathNames + i));
        hr = SafeArrayPutElement(psa,
                                 (long FAR *)&i,
                                 &v
                                 );

    SysFreeString(v.bstrVal);
    VariantClear(&v);

    if (FAILED(hr)) {
            goto Fail;
        }
    
    }

    V_VT(pVar) = VT_ARRAY | VT_VARIANT;

    V_ARRAY(pVar) = psa;

    return(ResultFromScode(S_OK));


Fail:

    if (psa) {
        SafeArrayDestroy(psa);
    }

    return(E_FAIL);

}


HRESULT SetPropertyList(IADs *pADs, LPWSTR pszPropName, DWORD   Count,
                                LPWSTR *pList)
{
    VARIANT       Var;
    HRESULT       hr;

    VariantInit(&Var);

    hr = BuildVarArrayStr(pList, Count, &Var);

    hr = pADs->Put(pszPropName, Var);
    VariantClear(&Var);
    return hr;
}


HRESULT SetPropertyListMerge(IADs *pADs, LPWSTR pszPropName, DWORD Count,
                  LPWSTR *pList)
{
   HRESULT   hr = S_OK;
   LPOLESTR *pszProps = NULL, *pszMergedProps = NULL;
   DWORD     cProps = 0, cMergedProps = 0;
   DWORD     i, j;

   hr = GetPropertyListAlloc(pADs, pszPropName, &cProps, &pszProps);
   RETURN_ON_FAILURE(hr);
   // get the property already stored.

   pszMergedProps = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(cProps+Count));
   for (i = 0; i < cProps; i++)
       pszMergedProps[i] = pszProps[i];

   // copy all the prop got.

   cMergedProps = cProps;
   for (j = 0; j < Count; j++) {
      for (i = 0; i < cProps; i++) {
      if (wcscmp(pList[j], pszMergedProps[i]) == 0) {
          break;
      }
      }
      // if this element was not found already add it.
      if (i == cProps)
      pszMergedProps[cMergedProps++] = pList[j];
   }

   hr = SetPropertyList(pADs, pszPropName, cMergedProps, pszMergedProps);

   for (i = 0; i < cProps; i++)
      CoTaskMemFree(pszProps[i]);

   CoTaskMemFree(pszProps);
   CoTaskMemFree(pszMergedProps);

   return hr;
}

HRESULT GetPropertyGuid(IADs *pADs, LPOLESTR pszPropName, GUID *pguidPropVal)
{
    VARIANT varGet;
    HRESULT hr;

    VariantInit(&varGet);
    hr = pADs->Get(pszPropName, &varGet);
    RETURN_ON_FAILURE(hr);

    hr = UnpackGuidFromVariant(varGet, pguidPropVal);

    VariantClear(&varGet);
    return hr;
}

HRESULT UnpackGuidFromVariant(VARIANT varGet, GUID *pguidPropVal)
{
    HRESULT hr=S_OK;
    SAFEARRAY FAR *psa;
    CHAR HUGEP *pArray=NULL;

    if (V_VT(&varGet) != (VT_ARRAY | VT_UI1))
        return E_FAIL;
    if ((V_ARRAY(&varGet))->rgsabound[0].cElements != sizeof(GUID))
        return E_FAIL;

    psa = V_ARRAY(&varGet);

    hr = SafeArrayAccessData( psa, (void HUGEP * FAR *) &pArray );
    RETURN_ON_FAILURE(hr);
    memcpy( pguidPropVal, pArray, sizeof(GUID)); // check for size
    SafeArrayUnaccessData( psa );

    // BUGBUG:: any more freeing to do ??
    return hr;
}


// assumption that this is going to be a variant structure with

HRESULT GetPropertyListAllocGuid(IADs *pADs,
                LPOLESTR pszPropName,
                DWORD *pCount,
                GUID **ppList)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    VARIANT var;

    *pCount = 0;
    VariantInit(&var);

    hr = pADs->Get(pszPropName, &var);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        return S_OK;
    }

    RETURN_ON_FAILURE(hr);

    //
    // The following is a work around
    //
    if (V_VT(&var) == (VT_ARRAY | VT_UI1))
    {
        (*ppList) = (GUID *) CoTaskMemAlloc(sizeof(GUID));
        *pCount = 1;
        UnpackGuidFromVariant(var, *ppList);
        VariantClear(&var);
        return S_OK;
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1)
    {
        return E_FAIL;
    }
    //
    // Check that there is atleast one element in this array
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        *ppList = NULL;
        return S_OK; // was E_FAIL;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    RETURN_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    RETURN_ON_FAILURE(hr);

    (*ppList) = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(dwSUBound-dwSLBound+1));

    for (i = dwSLBound; i <= dwSUBound; i++)
    {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );

        if (FAILED(hr))
        {
            continue;
        }

        if (i <= dwSUBound)
        {
            UnpackGuidFromVariant(v, (*ppList)+(*pCount));
            VariantClear(&v);
            (*pCount)++;
        }
    }

    VariantClear(&var);
    return(S_OK);
}


HRESULT SetPropertyListGuid(IADs *pADs, LPOLESTR pszPropName,
                            DWORD cCount, GUID *ppList)
{

    VARIANT Var;
    HRESULT hr=S_OK;

    VariantInit(&Var);
    hr = PackGuidArray2Variant(ppList, cCount, &Var);
    RETURN_ON_FAILURE(hr);

    hr = pADs->Put(pszPropName, Var);
    RETURN_ON_FAILURE(hr);

    VariantClear(&Var);
    return hr;
}

HRESULT
PackString2Variant(
    LPWSTR lpszData,
    VARIANT * pvData
    )
{
    BSTR bstrData = NULL;

    if (!lpszData || !*lpszData) {
        return(E_FAIL);
    }

    if (!pvData) {
        return(E_FAIL);
    }

    bstrData = SysAllocString(lpszData);

    if (!bstrData) {
        return(E_FAIL);
    }

    pvData->vt = VT_BSTR;
    pvData->bstrVal = bstrData;

    return(S_OK);
}


HRESULT
PackDWORD2Variant(
    DWORD dwData,
    VARIANT * pvData
    )
{
    if (!pvData) {
        return(E_FAIL);
    }


    pvData->vt = VT_I4;
    pvData->lVal = dwData;

    return(S_OK);
}


HRESULT
PackBOOL2Variant(
    BOOL fData,
    VARIANT * pvData
    )
{
    pvData->vt = VT_BOOL;
    pvData->boolVal = fData;

    return(S_OK);
}



HRESULT GetPropertyList(IADs *pADs,
                LPOLESTR pszPropName,
                DWORD *pCount,
                LPOLESTR *pList)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    VARIANT var;

    *pCount = 0;
    VariantInit(&var);

    hr = pADs->Get(pszPropName, &var);

    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        return S_OK;
    }

    RETURN_ON_FAILURE(hr);

    if(!((V_VT(&var) &  VT_VARIANT)))
    {
        return(E_FAIL);
    }

    //
    // The following is a work around for the package detail field
    //
    if (!V_ISARRAY(&var))
    {
        *pCount = 1;
        *pList = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(var.bstrVal)+1));
        wcscpy (*pList, var.bstrVal);
        VariantClear(&var);
        return S_OK;
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1)
    {
        return E_FAIL;
    }
    //
    // Check that there is atleast one element in this array
    //
    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
    {
        return E_FAIL;
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    RETURN_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    RETURN_ON_FAILURE(hr);

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        if (i <= dwSUBound)
        {
            *pList = (LPOLESTR) CoTaskMemAlloc
                 (sizeof (WCHAR) * (wcslen(v.bstrVal) + 1));
            wcscpy (*pList, v.bstrVal);
            VariantClear(&v);
            (*pCount)++;
            ++pList;
        }
    }

    VariantClear(&var);
    return(S_OK);
}



HRESULT GetPropertyAlloc (IADs *pADs, LPOLESTR pszPropName, LPOLESTR *ppszPropVal)
{
    VARIANT varGet;
    HRESULT hr;

    if (!ppszPropVal)
            return S_OK;

    VariantInit(&varGet);
    hr = pADs->Get(pszPropName, &varGet);
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        *ppszPropVal = NULL;
        return S_OK;
    }
    RETURN_ON_FAILURE(hr);
    *ppszPropVal = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(varGet.bstrVal)+1));
    wcscpy (*ppszPropVal, varGet.bstrVal);
    VariantClear(&varGet);
    return hr;
}


HRESULT GetProperty (IADs *pADs, LPOLESTR pszPropName, LPOLESTR pszPropVal)
{
    VARIANT varGet;
    HRESULT hr;

    VariantInit(&varGet);
    hr = pADs->Get(pszPropName, &varGet);
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        pszPropVal[0] = NULL;
        return S_OK;
    }
    RETURN_ON_FAILURE(hr);
    wcscpy (pszPropVal, varGet.bstrVal);
    VariantClear(&varGet);
    return hr;
}


HRESULT GetPropertyDW (IADs *pADs, LPOLESTR pszPropName, DWORD *pdwPropVal)
{
    VARIANT varGet;
    HRESULT hr;

    VariantInit(&varGet);
    hr = pADs->Get(pszPropName, &varGet);
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        *pdwPropVal = 0;
        return S_OK;
    }

    RETURN_ON_FAILURE(hr);
    *pdwPropVal = varGet.lVal;
    VariantClear(&varGet);
    return hr;
}

HRESULT GetPropertyListAllocDW (IADs *pADs, LPOLESTR pszPropName, DWORD *pCount, DWORD **pdwPropVal)
{
   LONG dwSLBound = 0;
   LONG dwSUBound = 0;
   VARIANT v;
   LONG i;
   HRESULT hr = S_OK;
   VARIANT var;

   *pCount = 0;
   *pdwPropVal = NULL;

   VariantInit(&var);

   hr = pADs->Get(pszPropName, &var);

   if (hr == E_ADS_PROPERTY_NOT_FOUND)
   {
       return S_OK;
   }

   RETURN_ON_FAILURE(hr);

   if (!V_ISARRAY(&var))
   {
       *pCount = 1;
       *pdwPropVal = (DWORD *) CoTaskMemAlloc (sizeof(DWORD));
       (*pdwPropVal)[0] = var.lVal;
       VariantClear(&var);
       return S_OK;
   }

   //
   // Check that there is only one dimension in this array
   //

   if ((V_ARRAY(&var))->cDims != 1)
   {
       return E_FAIL;
   }
   //
   // Check that there is atleast one element in this array
   //
   if ((V_ARRAY(&var))->rgsabound[0].cElements == 0)
   {
       return E_FAIL;
   }

   //
   // We know that this is a valid single dimension array
   //

   hr = SafeArrayGetLBound(V_ARRAY(&var),
               1,
               (long FAR *)&dwSLBound
               );
   RETURN_ON_FAILURE(hr);

   hr = SafeArrayGetUBound(V_ARRAY(&var),
               1,
               (long FAR *)&dwSUBound
               );
   RETURN_ON_FAILURE(hr);

   *pdwPropVal = (DWORD *)CoTaskMemAlloc(sizeof(DWORD)*
                 (dwSUBound - dwSLBound + 1));

   if (!(*pdwPropVal))
       return E_OUTOFMEMORY;

   for (i = dwSLBound; i <= dwSUBound; i++) {
       VariantInit(&v);
       hr = SafeArrayGetElement(V_ARRAY(&var),
                   (long FAR *)&i,
                   &v
                   );
       if (FAILED(hr)) {
            continue;
       }

       (*pdwPropVal)[*pCount] = v.lVal;
       VariantClear(&v);
       (*pCount)++;
   }

   VariantClear(&var);
   return(S_OK);
}

HRESULT SetPropertyListDW (IADs *pADs, LPOLESTR pszPropName, DWORD dwCount, DWORD *pdwPropVal)
{
   VARIANT       Var;
   HRESULT       hr = S_OK;

   VariantInit(&Var);

//  BUGBUG:: THis doesn't seem to work.
//  hr = ADsBuildVarArrayInt(pdwPropVal, dwCount, &Var);

   hr = PackDWORDArray2Variant(pdwPropVal, dwCount, &Var);

   if (SUCCEEDED(hr))
      hr = pADs->Put(pszPropName, Var);

   VariantClear(&Var);
   return hr;
}

HRESULT SetProperty (IADs *pADs, LPOLESTR pszPropName, LPOLESTR pszPropVal)
{
    VARIANT var;
    HRESULT hr;

    if ((pszPropVal == NULL) || (*pszPropVal == NULL))
        return S_OK;
    VariantInit(&var);
    PackString2Variant(pszPropVal, &var);
    hr = pADs->Put(pszPropName, var);
    SysFreeString(var.bstrVal);
    VariantClear(&var);
    return hr;
}

HRESULT SetPropertyDW (IADs *pADs, LPOLESTR pszPropName, DWORD dwPropVal)
{
    VARIANT var;
    HRESULT hr;

    VariantInit(&var);
    PackDWORD2Variant(dwPropVal, &var);
    hr = pADs->Put(pszPropName, var);
    VariantClear(&var);
    return hr;
}

HRESULT StoreIt (IADs *pADs)
{
    HRESULT hr;
    hr = pADs->SetInfo();
    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        DWORD proverr;
        hr = ADsGetLastError (&proverr, NULL, 0, NULL, 0);
        if (SUCCEEDED(hr)
          //  && (proverr == LDAP_NO_SUCH_ATTRIBUTE)
            )
        {
            printf ("Ldap Error = %d.\n", proverr);
            return E_FAIL;
        }
        else
            return hr; //E_INVALIDARG;
    }
    return hr;
}


HRESULT GetFromVariant(VARIANT *pVar,
                DWORD *pCount,          // In, Out
                LPOLESTR  *rpgList)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    LONG j;
    HRESULT hr = S_OK;
    ULONG cFetch = *pCount;
    void HUGEP *pArray;

    pArray = NULL;

    if( !(pVar->vt & VT_ARRAY))
        return E_FAIL;

    hr = SafeArrayGetLBound(V_ARRAY(pVar),
        1,
        (long FAR *) &dwSLBound );

    hr = SafeArrayGetUBound(V_ARRAY(pVar),
        1,
        (long FAR *) &dwSUBound );

    hr = SafeArrayAccessData( V_ARRAY(pVar), &pArray );

    *pCount = 0;
    for (j=dwSLBound; (j<=dwSUBound)  && (*pCount < cFetch); j++)
    {
        switch(pVar->vt & ~VT_ARRAY)
        {

        case VT_BSTR:
            *rpgList = (LPOLESTR) CoTaskMemAlloc
                 (sizeof (WCHAR) * (wcslen(((BSTR *)pArray)[j]) + 1));
            wcscpy (*rpgList, ((BSTR *)pArray)[j]);
            (*pCount)++;
            ++rpgList;
            break;
       
        case VT_I4:
            *rpgList = (LPOLESTR)(((DWORD *) pArray)[j]);
            (*pCount)++;
            ++rpgList;
            break;

        case VT_VARIANT:
            VARIANT *pV;
            pV = (VARIANT *)pArray + j;
    
            if (pV->vt == (VT_ARRAY | VT_UI1))
            {    /* binary data, only GUID */
                 UnpackGuidFromVariant(*pV, (GUID *)rpgList);
            }
            else if (pV->vt == VT_I4)
            {
                *rpgList = (LPOLESTR) pV->lVal;
                (*pCount)++;
                ++rpgList;
            }
            else
            {
                *rpgList = (LPOLESTR) CoTaskMemAlloc
                 (sizeof (WCHAR) * (wcslen(pV->bstrVal)+1));
                wcscpy (*rpgList, pV->bstrVal);
                (*pCount)++;
                ++rpgList;
            }
            break;
            /*
        case VT_I8:
            wprintf(L"%I64d #  ",((__int64 *) pArray)[j]);
            break;
        */
        default:
            return E_FAIL;
        }

    }

    SafeArrayUnaccessData( V_ARRAY(pVar) );
    return S_OK;
}

HRESULT GetCategoryLocaleDesc(LPOLESTR *pdesc, ULONG cdesc, LCID *plcid,
                                LPOLESTR szDescription)
{
    LCID     plgid;
    LPOLESTR ptr;
    if (!cdesc)
        return E_FAIL; // CAT_E_NODESCRIPTION;

    // Try locale passed in
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
            return S_OK;

    // Get default sublang local
    plgid = PRIMARYLANGID((WORD)*plcid);
    *plcid = MAKELCID(MAKELANGID(plgid, SUBLANG_DEFAULT), SORT_DEFAULT);
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
            return S_OK;

    // Get matching lang id
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 1))
            return S_OK;

    // Get User Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
            return S_OK;

    // Get System Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
            return S_OK;

    // Get the first one
    *plcid = wcstoul(pdesc[0], &ptr, 16);
    if (szDescription)
            wcscpy(szDescription, (ptr+wcslen(CATSEPERATOR)+2));

    return S_OK;
}

//-------------------------------------------
// Returns the description corresp. to a LCID
//  desc:         list of descs+lcid
//  cdesc:        number of elements.
//      plcid:        the lcid in/out
//  szDescription:description returned.
//  GetPrimary:   Match only the primary.
//---------------------------------------

ULONG FindDescription(LPOLESTR *desc, ULONG cdesc, LCID *plcid, LPOLESTR szDescription, BOOL GetPrimary)
{
        ULONG i;
        LCID  newlcid;
        LPOLESTR ptr;
        for (i = 0; i < cdesc; i++)
        {
            newlcid = wcstoul(desc[i], &ptr, 16); // to be changed
            // error to be checked.
            if ((newlcid == *plcid) || ((GetPrimary) &&
                (PRIMARYLANGID((WORD)*plcid) == PRIMARYLANGID(LANGIDFROMLCID(newlcid)))))
            {
                if (szDescription)
                    wcscpy(szDescription, (ptr+wcslen(CATSEPERATOR)+2));
                if (GetPrimary)
                    *plcid = newlcid;
                return i+1;
            }
        }
        return 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\common\csenum.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       csenum.cxx
//
//  Contents:   Per Class Container Package Enumeration
//
//
//  History:    09-09-96  DebiM   created
//              11-01-97  DebiM   modified, moved to cstore
//
//----------------------------------------------------------------------------

#include "dsbase.hxx"
#include "csenum.hxx"




//IEnumPackage implementation.

HRESULT CEnumPackage::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumPackage)
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CEnumPackage::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CEnumPackage::Release()
{
    ULONG dwRefCount=m_dwRefCount-1;
    if (InterlockedDecrement((long*) &m_dwRefCount)==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumPackage methods
//extern DBBINDING InstallBinding [];

//
// CEnumPackage::Next
// ------------------
//
//
//
//  Synopsis:       This method returns the next celt number of packages
//                  within the scope of the enumeration.
//                  Packages are returned in the alphabetical name order.
//
//  Arguments:      [in]  celt - Number of package details to fetch
//                  INSTALLINFO *rgelt - Package detail structure
//                  ULONG *pceltFetched - Number of packages returned
//
//  Returns:        S_OK or S_FALSE if short of packages
//
//
//

HRESULT CEnumPackage::Next(ULONG 	   celt,
                           PACKAGEDISPINFO *rgelt,
                           ULONG       *pceltFetched)

{
    ULONG          cgot = 0;
    HRESULT        hr = S_OK;
    Data          *pData;
    LPOLESTR       name;

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if (!IsValidPtrOut(rgelt, sizeof(PACKAGEDISPINFO)*celt))
        return E_INVALIDARG;

    hr = FetchPackageInfo(m_pIRow,
        m_HAcc,
        m_dwAppFlags,
        m_pdwLocale,
        m_pPlatform,
        celt,
        &cgot,
        rgelt);


    //
    // BUGBUG. Check for errors.
    //
    if (cgot != celt)
            hr = S_FALSE;
    else
            hr = S_OK;

    m_dwPosition += cgot;

    if (pceltFetched)
       *pceltFetched = cgot;

    return hr;
}


HRESULT CEnumPackage::Skip(ULONG celt)
{
    ULONG        celtFetched = NULL, i;
    HRESULT      hr = S_OK;
    PACKAGEDISPINFO *pIf = NULL;

    pIf = new PACKAGEDISPINFO[celt];
    hr = Next(celt, pIf, &celtFetched);
    for (i = 0; i < celtFetched; i++)
       ReleasePackageInfo(pIf+i);
    delete pIf;

    return hr;
}

HRESULT CEnumPackage::Reset()
{
    m_dwPosition = 0;
    return m_pIRow->RestartPosition(NULL);
}

// BUGBUG:: Positioning

HRESULT CEnumPackage::Clone(IEnumPackage **ppenum)
{
   CEnumPackage *pClone = new CEnumPackage;
   HRESULT hr = S_OK, hr1 = S_OK;

   hr = pClone->Initialize(m_CommandText, m_dwAppFlags, m_pdwLocale, m_pPlatform);
   if (FAILED(hr)) {
       delete pClone;
       return hr;
   }

   hr = pClone->QueryInterface(IID_IEnumPackage, (void **)ppenum);

   if (m_dwPosition)
      hr1 = pClone->Skip(m_dwPosition);
   // we do not want to return the error code frm skip.
   return hr;
}

CEnumPackage::CEnumPackage()
{
    m_dwRefCount = 0;
    m_HAcc = NULL;
    m_pIRow = NULL;
    m_pIAccessor = NULL;
    m_CommandText = NULL;
    m_dwPosition = 0;
    m_pIDBCreateCommand = NULL;
    m_pdwLocale = NULL;
    m_pPlatform = NULL;
    StartQuery(&(m_pIDBCreateCommand));
}



HRESULT CEnumPackage::Initialize(LPOLESTR   szCommandText,
                                 DWORD      dwAppFlags,
                                 DWORD      *pdwLocale,
                                 CSPLATFORM *pPlatform)
{
    HRESULT hr;
    m_CommandText = (LPOLESTR)CoTaskMemAlloc (sizeof(WCHAR) * (wcslen(szCommandText)+1));
    if (!m_CommandText)
        return E_OUTOFMEMORY;
    wcscpy(m_CommandText, szCommandText);
    m_dwAppFlags = dwAppFlags;
    
    if (pdwLocale)
    {
        m_pdwLocale = (DWORD *) CoTaskMemAlloc(sizeof(DWORD));
        *m_pdwLocale = *pdwLocale;
    }

    if (pPlatform)
    {
        m_pPlatform = (CSPLATFORM *) CoTaskMemAlloc(sizeof(CSPLATFORM));
        memcpy (m_pPlatform, pPlatform, sizeof(CSPLATFORM));
    }
    
    hr = ExecuteQuery (m_pIDBCreateCommand,
                       szCommandText,
                       PACKAGEENUM_COLUMN_COUNT,
                       NULL, 
                       &m_HAcc,
                       &m_pIAccessor,
                       &m_pIRow
                       );
    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}

CEnumPackage::~CEnumPackage()
{
    if (m_CommandText)
        CoTaskMemFree (m_CommandText);
    if (m_pdwLocale)
        CoTaskMemFree (m_pdwLocale);

    CloseQuery(m_pIAccessor,
               m_HAcc,
               m_pIRow);

    EndQuery(m_pIDBCreateCommand);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\common\dsiface.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       dsiface.cxx
//
//  Contents:   ADs calls for Class Store Property Read/Write
//
//
//  History:    Sep-Oct 96.   DebiM
//
//----------------------------------------------------------------------------


#include "dsbase.hxx"

#pragma warning ( disable : 4018 )
#pragma warning ( disable : 4244 )

//
// From CSPLATFORM to DS datatype
//
void
UnpackPlatform (DWORD *pdwArch, 
                CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)pdwArch;

    *(pc) = (unsigned char)pPlatform->dwPlatformId;
    *(++pc) = (unsigned char)pPlatform->dwVersionHi;
    *(++pc) = (unsigned char)pPlatform->dwVersionLo;
    *(++pc) = (unsigned char)pPlatform->dwProcessorArch;
}

//
// From DS datatype to CSPLATFORM 
//
void
PackPlatform (DWORD dwArch, 
              CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)&dwArch;

    pPlatform->dwPlatformId = *(pc);
    pPlatform->dwVersionHi = *(++pc);
    pPlatform->dwVersionLo = *(++pc);
    pPlatform->dwProcessorArch = *(++pc);
}




//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID
//
//--------------------------------------------------------------------------
int  StringFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    swprintf(lptsz, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);

    return 36;
}

//+-------------------------------------------------------------------------
//
//  Function:   RdnFromGUID
//
//--------------------------------------------------------------------------
int  RdnFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    wcscpy (lptsz, L"CN=");
    StringFromGUID(rguid, lptsz+3);
    return 3+36;
}

//BUGBUG. This belongs in a common library
void GUIDFromString(
   LPOLESTR psz,
   GUID *pclsguid)
//
// Converts a Stringified GUID to GUID structure
//
{
   WCHAR szC [40];
   LPOLESTR szClsId;
   LPOLESTR endptr;

      memset ((void *)pclsguid, NULL, sizeof (GUID));
      if ((!psz) ||
          (*psz == NULL))
            return;
      if (wcslen(psz) < 36)
          return;
      wcscpy (&szC [0], psz);
      szClsId = &szC[0];
      *(szClsId+36) = NULL;
      pclsguid->Data4[7] = wcstoul (szClsId+34, &endptr, 16);
      *(szClsId+34) = NULL;
      pclsguid->Data4[6] = wcstoul (szClsId+32, &endptr, 16);
      *(szClsId+32) = NULL;
      pclsguid->Data4[5] = wcstoul (szClsId+30, &endptr, 16);
      *(szClsId+30) = NULL;
      pclsguid->Data4[4] = wcstoul (szClsId+28, &endptr, 16);
      *(szClsId+28) = NULL;
      pclsguid->Data4[3] = wcstoul (szClsId+26, &endptr, 16);
      *(szClsId+26) = NULL;
      pclsguid->Data4[2] = wcstoul (szClsId+24, &endptr, 16);

      *(szClsId+23) = NULL;
      pclsguid->Data4[1] = wcstoul (szClsId+21, &endptr, 16);
      *(szClsId+21) = NULL;
      pclsguid->Data4[0] = wcstoul (szClsId+19, &endptr, 16);

      *(szClsId+18) = NULL;
      pclsguid->Data3 = wcstoul (szClsId+14, &endptr, 16);
      *(szClsId+13) = NULL;
      pclsguid->Data2 = wcstoul (szClsId+9, &endptr, 16);
      *(szClsId+8) = NULL;
      pclsguid->Data1 = wcstoul (szClsId, &endptr, 16);
}

BOOL  IsNullGuid(REFGUID rguid)
{
    UINT i;

    if (rguid.Data1)
        return FALSE;
    if (rguid.Data2)
        return FALSE;
    if (rguid.Data3)
        return FALSE;
    for (i=0; i < 8; ++i)
    {
        if (rguid.Data4[i])
            return FALSE;
    }
    return TRUE;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\dsprop.cxx ===
#include "cstore.hxx"


// set property routines do not do any allocations.
// get properties have 2 different sets of routines
//             1. in which there is no allocation taking place
//                and the buffers are freed when the ds data structures
//                are freed.
//             2. Allocation takes place and these should be used for
//                data that needs to be returned back to the clients.


void FreeAttr(ADS_ATTR_INFO attr)
{
    CoTaskMemFree(attr.pADsValues);
}

// Note: None of these APIs copies anything into their own buffers.
// It allocates a buffer for adsvalues though.

// packing a property's value into a attribute structure
// for sending in with a create/modify.

void PackStrArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty,
                      WCHAR **pszAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    
    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE)*num);
    
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackDWArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD *pAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackGUIDArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    
    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_OCTET_STRING;
        attr->pADsValues[i].OctetString.dwLength = sizeof(GUID);
        attr->pADsValues[i].OctetString.lpValue = (unsigned char *)(pAttr+i);
    }
}

void PackBinToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, BYTE *pAttr, DWORD sz)
{
    attr->pszAttrName = szProperty;
    attr->dwNumValues = 1;
    
    attr->dwControlCode = ADS_ATTR_UPDATE;
    
    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE));
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.
    
    attr->pADsValues[0].dwType = ADSTYPE_OCTET_STRING;
    attr->pADsValues[0].OctetString.dwLength = sz;
    attr->pADsValues[0].OctetString.lpValue = pAttr;
}

void PackStrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR *szAttr)
{
    if (szAttr)
        PackStrArrToAttr(attr, szProperty, &szAttr, 1);
    else
        PackStrArrToAttr(attr, szProperty, &szAttr, 0);
}

void PackDWToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD Attr)
{
    PackDWArrToAttr(attr, szProperty, &Attr, 1);
}

// passing in a pointer to GUID which is passed down into the LDAP structure.

void PackGUIDToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr)
{
    PackGUIDArrToAttr(attr, szProperty, pAttr, 1);
}

// returns the attribute corresp. to a given property.
DWORD GetPropertyFromAttr(ADS_ATTR_INFO *pattr, DWORD cNum, WCHAR *szProperty)
{
    DWORD   i;
    for (i = 0; i < cNum; i++)
        if (_wcsicmp(pattr[i].pszAttrName, szProperty) == 0)
            break;
        return i;
}



HRESULT GetCategoryLocaleDesc(LPOLESTR *pdesc, ULONG cdesc, LCID *plcid,
                              LPOLESTR szDescription)
{
    LCID     plgid;
    LPOLESTR ptr;

    szDescription[0] = L'\0';
    if (!cdesc)
        return E_FAIL; // CAT_E_NODESCRIPTION;
    
    // Try locale passed in
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get default sublang local
    plgid = PRIMARYLANGID((WORD)*plcid);
    *plcid = MAKELCID(MAKELANGID(plgid, SUBLANG_DEFAULT), SORT_DEFAULT);
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get matching lang id
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 1))
        return S_OK;
    
    // Get User Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get System Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get the first one
    *plcid = wcstoul(pdesc[0], &ptr, 16);
    if (szDescription)
    {
        if ((ptr) && (wcslen(ptr) >= (CAT_DESC_DELIM_LEN+2)))
            wcscpy(szDescription, (ptr+CAT_DESC_DELIM_LEN+2));
        else
            szDescription = L'\0';
    }
    return S_OK;
}

//-------------------------------------------
// Returns the description corresp. to a LCID
//  desc:         list of descs+lcid
//  cdesc:        number of elements.
//      plcid:        the lcid in/out
//  szDescription:description returned.
//  GetPrimary:   Match only the primary.
//---------------------------------------

ULONG FindDescription(LPOLESTR *desc, ULONG cdesc, LCID *plcid, LPOLESTR szDescription, BOOL GetPrimary)
{
    ULONG i;
    LCID  newlcid;
    LPOLESTR ptr;
    for (i = 0; i < cdesc; i++)
    {
        newlcid = wcstoul(desc[i], &ptr, 16); // to be changed
        // error to be checked.
        if ((newlcid == *plcid) || ((GetPrimary) &&
            (PRIMARYLANGID((WORD)*plcid) == PRIMARYLANGID(LANGIDFROMLCID(newlcid)))))
        {
            if (szDescription)
            {
                if ((ptr) && (wcslen(ptr) >= (CAT_DESC_DELIM_LEN+2)))
                    wcscpy(szDescription, (ptr+CAT_DESC_DELIM_LEN+2));
                else
                    szDescription = L'\0';
            }
            if (GetPrimary)
                *plcid = newlcid;
            return i+1;
        }
    }
    return 0;
}

DWORD NumDigits10(DWORD Value)
{
    DWORD ret = 0;

    for (ret = 0; Value != 0; ret++) 
        Value = Value/10;

    return ret;
}


void ReportEventCS(HRESULT ErrorCode, HRESULT ExtendedErrorCode, LPOLESTR szContainerName)
{

    WCHAR       szErrCode[16];
    LPCTSTR     Msg[2];
    HANDLE      hEventLogHandle;

    Msg[0] = szContainerName;
    Msg[1] = szErrCode;

    wsprintf(szErrCode, L"0x%x", ExtendedErrorCode);


    hEventLogHandle = RegisterEventSource(NULL, CLASSSTORE_EVENT_SOURCE);
    
    if (!hEventLogHandle) 
    {
#if DBG
        // Don't want to call call CSDBGPrint
        WCHAR Msg[_MAX_PATH];
        wsprintf(Msg, L"CSTORE: ReportEventCS: Couldn't open event log. Error returned 0x%x\n", GetLastError());
        OutputDebugString(Msg);
#endif // DBG
        return;
    }

    switch (ErrorCode) {
    case CS_E_INVALID_VERSION:
        ReportEvent(hEventLogHandle,
            EVENTLOG_ERROR_TYPE,
            0,
            EVENT_CS_INVALID_VERSION,
            NULL,
            2,
            0,
            Msg,
            NULL
            );
        break;

    case CS_E_NETWORK_ERROR:
        ReportEvent(hEventLogHandle,
            EVENTLOG_ERROR_TYPE,
            0,
            EVENT_CS_NETWORK_ERROR,
            NULL,
            2,
            0,
            Msg,
            NULL
            );
        break;
        
    case CS_E_INVALID_PATH:
        ReportEvent(hEventLogHandle,
            EVENTLOG_ERROR_TYPE,
            0,
            EVENT_CS_INVALID_PATH,
            NULL,
            2,
            0,
            Msg,
            NULL
            );
        break;
    case CS_E_SCHEMA_MISMATCH:
        ReportEvent(hEventLogHandle,
            EVENTLOG_ERROR_TYPE,
            0,
            EVENT_CS_SCHEMA_MISMATCH,
            NULL,
            2,
            0,
            Msg,
            NULL
            );
        break;
    case CS_E_INTERNAL_ERROR:
        ReportEvent(hEventLogHandle,
            EVENTLOG_ERROR_TYPE,
            0,
            EVENT_CS_INTERNAL_ERROR,
            NULL,
            2,
            0,
            Msg,
            NULL
            );
        break;
    }

    BOOL bDeregistered;

    bDeregistered = DeregisterEventSource(hEventLogHandle);

    if (!bDeregistered)
    {
#if DBG
        // Don't want to call call CSDBGPrint
        WCHAR Msg[_MAX_PATH];
        wsprintf(Msg, L"CSTORE: ReportEventCS: Couldn't Deregister event log. Error returned 0x%x\n", GetLastError());
        OutputDebugString(Msg);
#endif // DBG        
    }
}

// remapping Error Codes returned by LDAP to reasonable class store errors.
//
HRESULT RemapErrorCode(HRESULT ErrorCode, LPOLESTR m_szContainerName)
{
    HRESULT RetCode;

    if (SUCCEEDED(ErrorCode))
        return S_OK;

    switch (ErrorCode) 
    {
        //            
        //  All kinds of failures due to ObjectNotFound
        //  due to non-existence of object OR 
        //         non-existent container OR
        //         invalid path specification
        //  Other than Access Denails
        //
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):    // understand what causes this
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND):   //  -do-
            
            RetCode = CS_E_OBJECT_NOTFOUND;                       // which object - specific error
            break;

        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):
        case E_ADS_OBJECT_EXISTS:
            RetCode = CS_E_OBJECT_ALREADY_EXISTS;
            break;

        //            
        //  The following errors should not be expected normally.
        //  Class Store schema mismatched should be handled correctly.
        //  Errors below may ONLY occur for corrupted data OR out-of-band changes
        //  to a Class Store content.

        case E_ADS_CANT_CONVERT_DATATYPE:
        case E_ADS_SCHEMA_VIOLATION:
        case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
        case HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
            RetCode = CS_E_SCHEMA_MISMATCH;
            break;

        //            
        //  Any kinds of Access or Auth Denial
        //      return ACCESS_DENIED
        //

        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
        case HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):

            RetCode = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            break;

        case E_ADS_BAD_PATHNAME:
        case HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):  // this is wrong
            RetCode = CS_E_INVALID_PATH;
            break;
        
        //            
        //  Out of Memory
        //

        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            
            RetCode = E_OUTOFMEMORY;
            break;

        //            
        //  Any DNS, DS or Network failures
        //

        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY):
        case HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
        case HRESULT_FROM_WIN32(ERROR_DS_BUSY):
        case HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
        case HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
        case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
        case HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
        case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
            RetCode = CS_E_NETWORK_ERROR;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
             RetCode = CS_E_ADMIN_LIMIT_EXCEEDED;
             break;

        case CS_E_OBJECT_NOTFOUND:
        case CS_E_OBJECT_ALREADY_EXISTS:
        case CS_E_INVALID_VERSION:
        case CS_E_PACKAGE_NOTFOUND:
            RetCode = ErrorCode;
            break;

        case E_INVALIDARG:
        case ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS:
            RetCode = E_INVALIDARG;
            break;

        default:
            RetCode = CS_E_INTERNAL_ERROR;
    }

    CSDBGPrint((L"Error Code 0x%x remapped to 0x%x\n", ErrorCode, RetCode));

    if ((RetCode == CS_E_INVALID_PATH)    || 
        (RetCode == CS_E_NETWORK_ERROR)   ||
        (RetCode == CS_E_INVALID_VERSION) ||
        (RetCode == CS_E_SCHEMA_MISMATCH) ||
        (RetCode == CS_E_INTERNAL_ERROR))
        ReportEventCS(RetCode, ErrorCode, m_szContainerName);

    return RetCode;
}

// These functions are used to delete a single value from a
// multivalued property or append to a multivalued property

void PackStrArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR **pszAttr, DWORD num,
                        BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackDWArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD *pAttr, DWORD num,
                       BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackGUIDArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr, DWORD num,
                         BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CoTaskMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             // BUGBUG:: return the hresult.
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_OCTET_STRING;
        attr->pADsValues[i].OctetString.dwLength = sizeof(GUID);
        attr->pADsValues[i].OctetString.lpValue = (unsigned char *)(pAttr+i);
    }
}

void LogMessage(WCHAR *wszDebugBuffer)
{
      HANDLE hFile = NULL;

      hFile = CreateFile(LOGFILE,
                         GENERIC_WRITE,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

      if ( hFile != INVALID_HANDLE_VALUE )
      {
          if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
          {
              char *  pszString;
              DWORD   Size;
              int     Status;

              Size = lstrlen(wszDebugBuffer) + 1;
              pszString = (char *) CoTaskMemAlloc( Size );

               if ( pszString )
               {
                   Status = WideCharToMultiByte(
                           CP_ACP,
                           0,
                           wszDebugBuffer,
                           -1,
                           pszString,
                           Size,
                           NULL,
                           NULL );

                   if ( Status )
                   {
                       WriteFile(
                               hFile,
                               (LPCVOID) pszString,
                               lstrlenA(pszString) * sizeof(char),
                               &Size,
                               NULL );

                   }
               }
               CoTaskMemFree(pszString);
           }

           CloseHandle (hFile);
      }
}

void CSDbgPrint(WCHAR *Format, ...)
{
    WCHAR   wszDebugTitle[50], wszMsg[500];                      
    SYSTEMTIME systime;                                             
    WCHAR   wszDebugBuffer[500];
    DWORD   dwErrCode = 0;
    va_list VAList;
    LPCTSTR Msg[1];

    if ((gDebugLog) || (gDebugOut))                                    
    {                                                                   
        dwErrCode = GetLastError();

        va_start(VAList, Format);
        GetLocalTime( &systime );                                       
        wsprintf( wszDebugTitle, L"CSTORE (%x) %02d:%02d:%02d:%03d ",   
                    GetCurrentProcessId(),                              
                    systime.wHour, systime.wMinute, systime.wSecond,    
                    systime.wMilliseconds);                           
        
        wvsprintf(wszMsg, Format, VAList);
        wsprintf(wszDebugBuffer, L"%s:: %s\n", wszDebugTitle, wszMsg);    
        if (gDebugOut)                                                  
            OutputDebugString(wszDebugBuffer);                          
                                                                       
        if (gDebugLog)                                                  
            LogMessage(wszDebugBuffer);                               
  
        if (gDebugEventLog)
        {            
            HANDLE hEventLogHandle;

            // we don't need time etc. for event log. 
            // it should be added 

            hEventLogHandle = RegisterEventSource(NULL, CLASSSTORE_EVENT_SOURCE);
            
            if (!hEventLogHandle) 
            {
#if DBG
                // Don't want to call call CSDBGPrint
                WCHAR Msg[_MAX_PATH];
                wsprintf(Msg, L"CSTORE: CSDbgPrint: Couldn't open event log. Error returned 0x%x\n", GetLastError());
                OutputDebugString(Msg);
#endif // DBG
            }

            if (hEventLogHandle) 
            {
                Msg[0] = wszMsg;
                ReportEvent(hEventLogHandle,
                            EVENTLOG_INFORMATION_TYPE,
                            0,  
                            EVENT_CS_CLASSSTORE_DEBUGMSG,
                            NULL,
                            1,
                            0,
                            Msg,
                            NULL
                    );

                BOOL bDeregistered;

                bDeregistered = DeregisterEventSource(hEventLogHandle);

                if (!bDeregistered)
                {
#if DBG
                    // Don't want to call call CSDBGPrint
                    WCHAR Msg[_MAX_PATH];
                    wsprintf(Msg, L"CSTORE: CSDbgPrint: Couldn't Deregister event log. Error returned 0x%x\n", GetLastError());
                    OutputDebugString(Msg);
#endif // DBG        
                }
            }

        }

        SetLastError(dwErrCode);
    }                                                                   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\backend\qry.cxx ===
//
//  Author: DebiM/UShaji
//  Date:   Jan 97 - Apr 98
//
//      Class Store Query and Fetch Implementation
//
//
//---------------------------------------------------------------------
//
#include "cstore.hxx"

//
// List of Attributes for On-Demand Package Lookup Query
//
LPOLESTR pszInstallInfoAttrNames[] =
{
    PKGFILEEXTNLIST,    LOCALEID,   ARCHLIST,   PACKAGEFLAGS,   SCRIPTPATH,         PKGCLSIDLIST,
    PACKAGETYPE,        PKGUSN,     VERSIONHI,  VERSIONLO,      UPGRADESPACKAGES,   UILEVEL, 
    PACKAGENAME,        HELPURL,    PUBLISHER,  REVISION,       PRODUCTCODE,        OBJECTDN, 
    OBJECTGUID 
};
DWORD cInstallInfoAttr = 19;

//
// List of Attributes for Enumeration of Packages (with Filters)
//

LPOLESTR pszPackageInfoAttrNames[] =
{
    PACKAGEFLAGS,       PACKAGETYPE,    SCRIPTPATH, SCRIPTSIZE,         PKGUSN,     LOCALEID,   ARCHLIST,
    PACKAGENAME,        VERSIONHI,      VERSIONLO,  UPGRADESPACKAGES,   UILEVEL,    PUBLISHER,  HELPURL, 
    REVISION,           PRODUCTCODE,    OBJECTGUID, OBJECTDN 
};
DWORD cPackageInfoAttr = 18;

//
// List of Attributes for GetPackageDetail() method
//

LPOLESTR pszPackageDetailAttrNames[] =
{
    PACKAGEFLAGS,   PACKAGETYPE,    SCRIPTPATH,         SCRIPTSIZE,         SETUPCOMMAND,   HELPURL,        PKGUSN, 
    VERSIONHI,      VERSIONLO,      UILEVEL,            UPGRADESPACKAGES,   ARCHLIST,       LOCALEID,       PKGCLSIDLIST,   
    PKGIIDLIST,     PKGTLBIDLIST,   PKGFILEEXTNLIST,    PACKAGENAME,        MSIFILELIST,    PKGCATEGORYLIST,MVIPC, 
    PRODUCTCODE,    REVISION,       OBJECTGUID
};
DWORD cPackageDetailAttr = 24;


LPOLESTR pszDeleteAttrNames[] =
{
    PACKAGEFLAGS, OBJECTDN 
};
DWORD cDeleteAttr = 2;

//
// List of Attributes for App Categories
//

LPOLESTR pszCategoryAttrNames[] =
{
    LOCALEDESCRIPTION, CATEGORYCATID
};
DWORD cCategoryAttr = 2;

BOOL MatchPlatform(
    CSPLATFORM *pReqPlatform,
    CSPLATFORM *pPkgPlatform,
    BOOL        fX86OnAlpha)
{
    //
    // Make sure this is the correct platform
    //
    if (pReqPlatform->dwPlatformId != pPkgPlatform->dwPlatformId) 
    {
        return FALSE;
    }

    //
    // ProcessorArch must match
    //
    if (pReqPlatform->dwProcessorArch != pPkgPlatform->dwProcessorArch)
    {
        //
        // If the caller didn't request x86 on alpha, inequality between 
        // architectures is automatic disqualification
        //
        if (!fX86OnAlpha) 
        {
            return FALSE;
        }

        //
        // Caller specified that we should allow x86 packages on alpha --
        // see if we are in that situation, and only disqualify the package if not
        //
        if ( ! ((PROCESSOR_ARCHITECTURE_ALPHA == pReqPlatform->dwProcessorArch) &&
                (PROCESSOR_ARCHITECTURE_INTEL == pPkgPlatform->dwProcessorArch)))
        {
            return FALSE;
        }
    }

    //
    // Check the OS version, hi part first -- this requested platform must be at least as
    // high as the package platform -- if not, it is disqualified
    //
    if (pReqPlatform->dwVersionHi < pPkgPlatform->dwVersionHi)
    {
        return FALSE;
    }

    //
    // If the hi version is the same, check the low part of the os version
    //
    if (pReqPlatform->dwVersionHi == pPkgPlatform->dwVersionHi)
    {
        
        //
        // If the requested platform is less than the package, it cannot
        // support that package, so the package is disqualified.
        //
        if (pReqPlatform->dwVersionLo < pPkgPlatform->dwVersionLo)
        {
            return FALSE;
        }
    }

    //
    // We passed all the tests -- the package matches the requested platform
    //
    return TRUE;
}


// this has to change if the Msi can give us a preferred list etc.
DWORD PlatformWt(
    CSPLATFORM *pReqPlatform,
    CSPLATFORM *pPkgPlatform,
    BOOL        fX86OnAlpha)
{
    
    if (MatchPlatform(pReqPlatform,
                      pPkgPlatform,
                      fX86OnAlpha))
    {
        return PRI_ARCH_PREF1;
    }

    return 0;
}


DWORD ClassContextWt(DWORD ClsCtx)
{
    if (ClsCtx & CLSCTX_INPROC_SERVER)
        return PRI_CLSID_INPSVR;

    if (ClsCtx & CLSCTX_LOCAL_SERVER)
        return PRI_CLSID_LCLSVR;

    if (ClsCtx & CLSCTX_REMOTE_SERVER)
        return PRI_CLSID_REMSVR;

    return 0;
}

//
//
void GetCurrentUsn(LPOLESTR pStoreUsn)
{
    //
    // Get the current time as USN for the Class Store container
    //
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    wsprintf (pStoreUsn, L"%04d%02d%02d%02d%02d%02d", 
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);

}

void TimeToUsn (LPOLESTR szTimeStamp, CSUSN *pUsn)
{
    SYSTEMTIME SystemTime;

    if (szTimeStamp)
    {
        CSDBGPrint((L"szTimeStamp = %s", szTimeStamp));
        
        UINT l = wcslen(szTimeStamp) - 1;
        LPOLESTR pStr = szTimeStamp;
        
        for (UINT i=0; i < l; ++i)
        {
            if (*pStr == L' ')
                *pStr = L'0';
            ++pStr;
        }

        swscanf (szTimeStamp, L"%4d%2d%2d%2d%2d%2d", 
            &SystemTime.wYear,
            &SystemTime.wMonth,
            &SystemTime.wDay,
            &SystemTime.wHour,
            &SystemTime.wMinute,
            &SystemTime.wSecond);

        SystemTimeToFileTime(&SystemTime, (LPFILETIME) pUsn);
    }
    else
        pUsn->dwHighDateTime = pUsn->dwLowDateTime = 0;
}    


HRESULT UsnGet(ADS_ATTR_INFO Attr, CSUSN *pUsn)
{
    //
    // Read the USN for the Class Store container or Package
    //
    WCHAR *szTimeStamp=NULL;
    
    UnpackStrFrom(Attr, &szTimeStamp);

    TimeToUsn (szTimeStamp, pUsn);
    
    return S_OK;
}



// FetchInstallData
//-----------------
//
//
//  Gets the result set of the ondemand lookup query to locate an install package.
//  Returns the properties of the most likely Package in PackageInfo structure.
//
//  In case more than one package meets the criteria, their priorities are returned.
//  BUGBUG:: In case of E_OUTOFMEMORY in Unpack, we return the packages 
//  that we have already got.


HRESULT FetchInstallData(HANDLE             hADs,
                         ADS_SEARCH_HANDLE  hADsSearchHandle,   
                         QUERYCONTEXT      *pQryContext,
                         uCLSSPEC          *pclsspec, 
                         LPOLESTR           pszFileExt,
                         ULONG              cRows,
                         ULONG             *pcRowsFetched,
                         PACKAGEDISPINFO   *pPackageInfo,
                         UINT              *pdwPriority,
                         BOOL               OnDemandInstallOnly
                         )
{
    HRESULT             hr = S_OK;
    UINT                i, j;
    LPOLESTR            szUsn = NULL;
    ULONG               cCount = 0;
    LPOLESTR          * pszList = NULL;
    DWORD             * pdwList = NULL;
    ADS_SEARCH_COLUMN   column;
    CSPLATFORM          PkgPlatform;
    
    //
    //  Get the rows
    //
    

    //
    // Clear the caller supplied buffer in case the call to
    // get the first row fails
    //
    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    *pcRowsFetched = 0;
    
    if (*pcRowsFetched == cRows)
        return S_OK;
    
    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
	            ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS));
	            hr = ADSIGetNextRow(hADs, hADsSearchHandle))
    {
        //
        // Get the data from each row
        //

        //
        // Clear the caller supplied buffer in case previous
        // trips through this loop have written data
        //
        memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

        
        
        if(FAILED(hr))
        {
            //
            // BUGBUG. Missing cleanup.
            //
            return hr;
        }
        
        //
        // If querying by file ext check match and priority
        // .
        *pdwPriority = 0;

        if (pszFileExt)
        {
            //Column = fileExtension
            
            hr = ADSIGetColumn(hADs, hADsSearchHandle, PKGFILEEXTNLIST, &column);
            
            cCount = 0;
            
            if (SUCCEEDED(hr)) 
                UnpackStrArrFrom(column, &pszList, &cCount);
            
            UINT cLen = wcslen(pszFileExt);
            
            for (j=0; j < cCount; ++j)
            {
                LPOLESTR pStr = NULL;
                
                if (wcslen(pszList[j]) != (cLen+3))
                    continue;
                if (wcsncmp(pszList[j], pszFileExt, wcslen(pszFileExt)) != 0)
                    continue;
                *pdwPriority = (wcstoul(pszList[j]+(cLen+1), &pStr, 10))*PRI_EXTN_FACTOR;
                break;
            }
            
            if (SUCCEEDED(hr))
                ADSIFreeColumn(hADs, &column);
            
            CoTaskMemFree(pszList); pszList = NULL;

            //
            // If none matched skip this package
            //
            if (j == cCount)
                continue;
        }

        //Column = packageFlags
        //
        // Need to get this so we can properly interpret the machine
        // architecture settings since there is at least one flag,
        // ACTFLG_X86OnAlpha, that affects our processing of the
        // machine architecture.  Also need one of the flags to
        // do language matches.
        //
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PACKAGEFLAGS, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwActFlags));
            
            ADSIFreeColumn(hADs, &column);
        }
        else
            continue;

        
        //
        // Now check Locale and Platform -- only do this
        // if a locale was specified
        // 
        if (0 != pQryContext->Locale)
        {
            DWORD Wt = 0, MaxWt = 0;
            LANGID DesiredLang;

            DesiredLang = LANGIDFROMLCID(pQryContext->Locale);

            //Column = localeID
            hr = ADSIGetColumn(hADs, hADsSearchHandle, LOCALEID, &column);
            
            cCount = 0;

            if (SUCCEEDED(hr))
            {
                // Minor BUGBUG:: int converted to long.
                cCount = 0;
                UnpackDWArrFrom(column, &pdwList, &cCount);
                
                ADSIFreeColumn(hADs, &column);
            }
            
            for (j=0; j < cCount; ++j)
            {
                //
                // If the caller specifies LANG_SYSTEM_DEFAULT, we interpret this
                // to mean that the caller wants us to choose apps according
                // to the language precedence in GetLanguagePriority.  If some
                // other langid was given, we then only accept exact matches and
                // give those matches the highest priority, PRI_LANG_ALWAYSMATCH
                //
                if (LANG_SYSTEM_DEFAULT == DesiredLang)
                {
                    Wt = GetLanguagePriority (
                        LANGIDFROMLCID(pdwList[j]),
                        pPackageInfo->dwActFlags);
                } 
                else
                {
                    Wt = (DesiredLang == LANGIDFROMLCID(pdwList[j])) ?
                        PRI_LANG_ALWAYSMATCH :
                        0;
                }

                if (Wt > MaxWt)
                    MaxWt = Wt;
            }
            //
            // If none matched skip this package
            //
            
            if (pdwList)
                CoTaskMemFree(pdwList); 
            pdwList = NULL;
            
            // if nothing matched, quit
            if (MaxWt == 0)
                continue;

            *pdwPriority += MaxWt;
        }

        hr = ADSIGetColumn(hADs, hADsSearchHandle, ARCHLIST, &column);
        // machineArchitecture
        
        if (SUCCEEDED(hr))
        {
            // Minor BUGBUG:: int converted to long.
            cCount = 0;
            DWORD Wt = 0, MaxWt = 0;
            
            UnpackDWArrFrom(column, &pdwList, &cCount);
            
            ADSIFreeColumn(hADs, &column);

            for (j=0; j < cCount; ++j)
            {
                PackPlatform (pdwList[j], &PkgPlatform);
                
                Wt = PlatformWt (&(pQryContext->Platform),
                                 &PkgPlatform,
                                 pPackageInfo->dwActFlags & ACTFLG_X86OnAlpha);

                if (Wt > MaxWt)
                    MaxWt = Wt;
            }
            
            if (pdwList)
                CoTaskMemFree(pdwList); 
            pdwList = NULL;
            
            //
            // If none matched skip this package
            //
            if (MaxWt == 0)
                continue;
            
            *pdwPriority += MaxWt;
        }
        else
            continue;
        
        
        // passed all the filters.
        
        //
        // Does it support AutoInstall?
        //
        if ((OnDemandInstallOnly) && (!(pPackageInfo->dwActFlags & ACTFLG_OnDemandInstall)))
            continue;
        
        // If it is neither Published nor Assigned then skip it.

        if ((!(pPackageInfo->dwActFlags & ACTFLG_Published)) &&
            (!(pPackageInfo->dwActFlags & ACTFLG_Assigned)))
        {
            continue;
        }

        // If it is an Orphaned App OR Uninstalled App do not return.

        if ((pPackageInfo->dwActFlags & ACTFLG_Orphan) ||
            (pPackageInfo->dwActFlags & ACTFLG_Uninstall))
        {
            continue;
        }
 
        //Column = OBJECTGUID
        hr = ADSIGetColumn(hADs, hADsSearchHandle, OBJECTGUID, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR pStr = NULL;

            UnpackGUIDFrom(column, &(pPackageInfo->PackageGuid));
            
            ADSIFreeColumn(hADs, &column);
        }

        //Column = ScriptPath
        hr = ADSIGetColumn(hADs, hADsSearchHandle, SCRIPTPATH, &column);
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszScriptPath));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = comClassID
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PKGCLSIDLIST, &column);
        cCount = 0;
        if (SUCCEEDED(hr))
        {
            UnpackStrArrFrom(column, &pszList, &cCount);
            
            if (cCount)
            {
                if (pclsspec->tyspec == TYSPEC_CLSID)
                {
                    DWORD   i=0, Ctx = 0;
                    WCHAR   szClsid[STRINGGUIDLEN], *szPtr = NULL;

                    StringFromGUID(pclsspec->tagged_union.clsid, szClsid);
                    for (i = 0; i < cCount; i++)
                        if (wcsncmp(pszList[i], szClsid, STRINGGUIDLEN-1) == 0)
                            break;
                    
                    //
                    // The below assert is only hit if there is bad data -- if we find the
                    // clsid, i will not be cCount, and cCount will never be 0.  Basically,
                    // we're asserting that the search should always succeed if the ds data
                    // is good.
                    //
                    ASSERT(i != cCount);

                    if (i == cCount)    
                        continue;

                    if (wcslen(pszList[i]) > (STRINGGUIDLEN-1))
                        Ctx = wcstoul(pszList[i]+STRINGGUIDLEN, &szPtr, 16);

                    if ((Ctx & (pQryContext->dwContext)) == 0)
                    {   
                        CoTaskMemFree(pszList);
                        ADSIFreeColumn(hADs, &column);
                        // none of the class context matched.
                        continue;
                    }
                    else
                        *pdwPriority += ClassContextWt((Ctx & pQryContext->dwContext));
                }

                pPackageInfo->pClsid = (GUID *)CoTaskMemAlloc(sizeof(GUID));
                if (wcslen(pszList[0]) > (STRINGGUIDLEN-1))
                    pszList[0][STRINGGUIDLEN-1] = L'\0';
                
                // Only access the first entry
                if (pPackageInfo->pClsid)
                    GUIDFromString(pszList[0], pPackageInfo->pClsid);
 
                // o/w return NULL.

                CoTaskMemFree(pszList);
            }
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = packageType
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PACKAGETYPE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, (DWORD *)&(pPackageInfo->PathType));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = lastUpdateSequence
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PKGUSN, &column);
        if (SUCCEEDED(hr))
        {
            UnpackStrFrom(column, &szUsn);
            TimeToUsn (szUsn, (CSUSN *)(&(pPackageInfo->Usn)));
            ADSIFreeColumn(hADs, &column);
        }
        else {
            ReleasePackageInfo(pPackageInfo);
            continue;
        }
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PRODUCTCODE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->ProductCode));
            ADSIFreeColumn(hADs, &column);
        }

        //Column = versionNumberHi
        hr = ADSIGetColumn(hADs, hADsSearchHandle, VERSIONHI, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionHi));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = versionNumberLo
        hr = ADSIGetColumn(hADs, hADsSearchHandle, VERSIONLO, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionLo));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = revision
        hr = ADSIGetColumn(hADs, hADsSearchHandle, REVISION, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwRevision));
            
            ADSIFreeColumn(hADs, &column);
        }
		
        hr = ADSIGetColumn(hADs, hADsSearchHandle, UPGRADESPACKAGES, &column);       
        if (SUCCEEDED(hr))
        {
            LPOLESTR *pProp = NULL;
            hr = UnpackStrArrAllocFrom(column, &pProp, (DWORD *)&(pPackageInfo->cUpgrades));

            if (pPackageInfo->cUpgrades)
                pPackageInfo->prgUpgradeInfoList = (UPGRADEINFO *)CoTaskMemAlloc(sizeof(UPGRADEINFO)*
                                                        (pPackageInfo->cUpgrades));
		
            if (pPackageInfo->prgUpgradeInfoList)
            {
                memset(pPackageInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pPackageInfo->cUpgrades));

                for (j=0; j < ( pPackageInfo->cUpgrades); ++j)
                {
                    WCHAR *pStr = NULL;
                    LPOLESTR ptr = (pPackageInfo->prgUpgradeInfoList[j].szClassStore) = pProp[j];
                    UINT len = wcslen (ptr);
                    if (len <= 41)
                        continue;

                    *(ptr + len - 3) = NULL;
                    (pPackageInfo->prgUpgradeInfoList[j].Flag) = wcstoul(ptr+(len-2), &pStr, 16);

                    *(ptr + len - 3 - 36 - 2) = L'\0';
                            /*      -GUID-'::'*/
                    GUIDFromString(ptr+len-3-36, &(pPackageInfo->prgUpgradeInfoList[j].PackageGuid));
                }
                
                pPackageInfo->cUpgrades = j; // we might have skipped some.
            }

            ADSIFreeColumn(hADs, &column);
    	}
	
        hr = ADSIGetColumn(hADs, hADsSearchHandle, UILEVEL, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, (DWORD *)&(pPackageInfo->InstallUiLevel));

            ADSIFreeColumn(hADs, &column);
        }
		

        hr = ADSIGetColumn(hADs, hADsSearchHandle, PACKAGENAME, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszPackageName));

            ADSIFreeColumn(hADs, &column);

            CSDBGPrint((L"FetchInstallData:: Returning Package %s", pPackageInfo->pszPackageName));
        }
        else {
            ReleasePackageInfo(pPackageInfo);
            continue;
        }

        hr = ADSIGetColumn(hADs, hADsSearchHandle, HELPURL, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

            ADSIFreeColumn(hADs, &column);
        }
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PUBLISHER, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszPublisher));

            ADSIFreeColumn(hADs, &column);
        }

        // source list

        hr = ADSIGetColumn(hADs, hADsSearchHandle, MSIFILELIST, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR *rpszSourceList = NULL, psz = NULL, pStr = NULL;
            DWORD     Loc = 0, cSources = 0;
            
            UnpackStrArrFrom(column, &(rpszSourceList), &cSources);
            
            // reorder and allocate spaces.
            if (cSources > 1) 
            {
                pPackageInfo->fHasTransforms = 1;
/*
                pPackageInfo->pszSourceList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*
                    (pPackageInfo->cSources));

                // if we could not, plod on, the caller will get back as much as possible.
                if (!(pPackageInfo->pszSourceList)) {
                    pPackageInfo->cSources = 0;
                }

                memset(pPackageInfo->pszSourceList, 0, sizeof(LPOLESTR)*(pPackageInfo->cSources));

                for (count = 0; count < (pPackageInfo->cSources); count++) 
                {
                    pPackageInfo->pszSourceList[count] = (LPOLESTR)CoTaskMemAlloc(
                                            sizeof(WCHAR)*(wcslen(rpszSourceList[count])+1));

                    if (!(pPackageInfo->pszSourceList[count]))
                        break;
                }

                // if mem couldn't be allocated
                if (count != pPackageInfo->cSources) {
                    for (count = 0; count < (pPackageInfo->cSources); count++) 
                        if ((pPackageInfo->pszSourceList[count]))
                            CoTaskMemFree(pPackageInfo->pszSourceList[count]);

                    CoTaskMemFree(pPackageInfo->pszSourceList);
                    pPackageInfo->cSources = 0;
                }

                for (count = 0; count < (pPackageInfo->cSources); count++) 
                {
                    psz = wcschr(rpszSourceList[count], L':');
                    *psz = L'\0';
                    Loc = wcstoul(rpszSourceList[count], &pStr, 10);                    
                    wsprintf(pPackageDetail->pszSourceList[Loc], L"%s", psz+1);
                }
*/
            }
            else
                pPackageInfo->fHasTransforms = 0;
            
            ADSIFreeColumn(hADs, &column);

            CoTaskMemFree(rpszSourceList);
        }

        ++pPackageInfo;
        ++pdwPriority;
        (*pcRowsFetched)++;
        
        if (*pcRowsFetched == cRows)
            break;
     }
     
     
     //
     // Check if we found as many as asked for
     //
     if (*pcRowsFetched != cRows)
         return S_FALSE;
     return S_OK;
     
}

// FetchPackageInfo
//-----------------
//
//  Gets the result set of the query : List of Package objects.
//  Returns the properties in PackageInfo structure.
//
HRESULT FetchPackageInfo(HANDLE             hADs,
                         ADS_SEARCH_HANDLE  hADsSearchHandle,
                         DWORD              dwFlags,
                         CSPLATFORM        *pPlatform,
                         ULONG              cRows,
                         ULONG             *pcRowsFetched,
                         PACKAGEDISPINFO   *pPackageInfo,
                         BOOL              *fFirst
                         )
                         
{
    HRESULT             hr = S_OK;
    UINT                i, j;
    ULONG               cPlatforms = 0;
    DWORD             * dwPlatformList=NULL;
    LCID              * dwLocaleList=NULL;
    DWORD               dwPackageFlags;
    ULONG               cFetched = 0;
    ULONG               cRowsLeft = 0;
    CSPLATFORM          PkgPlatform;
    ADS_SEARCH_COLUMN   column;
    LPOLESTR            szUsn = NULL;
    BOOL                fX86OnAlpha;

    *pcRowsFetched = 0;
    cRowsLeft = cRows;

    if (!cRowsLeft)
        return S_OK;
    
    // The LDAP filter performs a part of the selection
    // The flag filters are interpreted on the client after obtaining the result set
    
    for (;(cRowsLeft);)
    {
        if ((*fFirst) && (!(*pcRowsFetched))) {
            *fFirst = FALSE;
            hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
        }
        else
            hr = ADSIGetNextRow(hADs, hADsSearchHandle);
        
        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;
        
        dwPackageFlags = 0;
        
        // Get the Flag Value: Column = packageFlags
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PACKAGEFLAGS, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwPackageFlags);
            
            ADSIFreeColumn(hADs, &column);
        }
        else 
            continue;
        
        //
        // Check flag values to see if this package meets the filter
        //
 
        //
        // If it is an Orphaned App, we only return it for APPINFO_ALL.
        //
        if ((dwPackageFlags & ACTFLG_Orphan) && (!(dwFlags & APPINFO_ALL)))
        {
            continue;
        }

        // If it is an Uninstalled App return it if asked for by APPINFO_ALL

        if ((dwPackageFlags & ACTFLG_Uninstall) && (!(dwFlags & APPINFO_ALL)))
        {
            continue;
        }
        
        if ((dwFlags & APPINFO_PUBLISHED) && (!(dwPackageFlags & ACTFLG_Published)))
        {
            continue;
        }

        if ((dwFlags & APPINFO_ASSIGNED) && (!(dwPackageFlags & ACTFLG_Assigned)))
        {
            continue;
        }
        
        if ((dwFlags & APPINFO_VISIBLE) && (!(dwPackageFlags & ACTFLG_UserInstall)))
        {
            continue;
        }
        
        if ((dwFlags & APPINFO_AUTOINSTALL) && (!(dwPackageFlags & ACTFLG_OnDemandInstall)))
        {
            continue;
        }

        //
        // Move the data into PackageInfo structure
        //
        memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));
        
        //Column = packageType
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PACKAGETYPE, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, (DWORD *)&(pPackageInfo->PathType));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        if (( dwFlags & APPINFO_MSI ) && (pPackageInfo->PathType != DrwFilePath))
            continue;
        
        pPackageInfo->LangId = LANG_NEUTRAL;

        //
        // If the package flags specify that we should ignore locale, or the
        // caller specified that all locale's are acceptable, skip the language
        // checks
        //
        if ( ! (dwPackageFlags & ACTFLG_IgnoreLanguage) &&
             ! (dwFlags & APPINFO_ALLLOCALE) )
        {
            LANGID PackageLangId;
            DWORD  cLanguages;

            hr = ADSIGetColumn(hADs, hADsSearchHandle, LOCALEID, &column);
            
            dwLocaleList = NULL;

            if (SUCCEEDED(hr))
            {
                // type change. shouldn't affect anything.
                UnpackDWArrFrom(column, &dwLocaleList, &cLanguages);
                
                ADSIFreeColumn(hADs, &column);
            }
            else
                continue;

            //
            // We only care about the first language returned -- originally
            // the packages in the ds could support multiple locales, but
            // we now only support one language
            //
            if (cLanguages)
            {
                PackageLangId = LANGIDFROMLCID(dwLocaleList[0]);
            }

            CoTaskMemFree(dwLocaleList);

            if (!cLanguages || !MatchLanguage(PackageLangId, dwPackageFlags))
                continue;

            pPackageInfo->LangId = PackageLangId;
        }
        
        if (pPlatform != NULL)
        {
            
            //Column = machineArchitecture
            hr = ADSIGetColumn(hADs, hADsSearchHandle, ARCHLIST, &column);
            cPlatforms = 0;
            dwPlatformList = NULL;
            
            if (SUCCEEDED(hr))
            {
                UnpackDWArrFrom(column, &dwPlatformList, &cPlatforms);
                
                ADSIFreeColumn(hADs, &column);
            }
            else
                continue;

           for (j=0; j < cPlatforms; ++j)
            {
                PackPlatform (dwPlatformList[j], &PkgPlatform);
                if (MatchPlatform (pPlatform,
                                   &PkgPlatform,
                                   dwPackageFlags & ACTFLG_X86OnAlpha))
                    break;
            }
            
            if (dwPlatformList)
                CoTaskMemFree(dwPlatformList);
            //
            // If none matched skip this package
            //
            if (j == cPlatforms)
                continue;
            
        }
        
        pPackageInfo->dwActFlags = dwPackageFlags;
        
        //Column = packageName. freeing this????
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PACKAGENAME, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszPackageName));
            
            CSDBGPrint((L"FetchPackageInfo:: Returning Package %s", pPackageInfo->pszPackageName));
            ADSIFreeColumn(hADs, &column);
        }
        else {
            ReleasePackageInfo(pPackageInfo);
            continue;
        }

        //Column = OBJECTGUID
        hr = ADSIGetColumn(hADs, hADsSearchHandle, OBJECTGUID, &column);

        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->PackageGuid));
            
            ADSIFreeColumn(hADs, &column);
        }

        //Column = ScriptPath
        hr = ADSIGetColumn(hADs, hADsSearchHandle, SCRIPTPATH, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszScriptPath));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = ScriptSize
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, SCRIPTSIZE, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->cScriptLen));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = lastUpdateSequence,
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PKGUSN, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackStrFrom(column, &szUsn);
            TimeToUsn (szUsn, (CSUSN *)(&(pPackageInfo->Usn)));
            ADSIFreeColumn(hADs, &column);
        }
        else {
            ReleasePackageInfo(pPackageInfo);
            continue;
        }
        
        // ProductCode
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PRODUCTCODE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->ProductCode));
            ADSIFreeColumn(hADs, &column);
        }

        //Column = versionNumberHi
        hr = ADSIGetColumn(hADs, hADsSearchHandle, VERSIONHI, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionHi));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = versionNumberLo
        hr = ADSIGetColumn(hADs, hADsSearchHandle, VERSIONLO, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionLo));
            
            ADSIFreeColumn(hADs, &column);
        }
        
        //Column = revision
        hr = ADSIGetColumn(hADs, hADsSearchHandle, REVISION, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwRevision));
            
            ADSIFreeColumn(hADs, &column);
        }

        hr = ADSIGetColumn(hADs, hADsSearchHandle, UPGRADESPACKAGES, &column);       
        if (SUCCEEDED(hr))
        {
            LPOLESTR *pProp = NULL;
            hr = UnpackStrArrAllocFrom(column, &pProp, (DWORD *)&(pPackageInfo->cUpgrades));

            if (pPackageInfo->cUpgrades)
                pPackageInfo->prgUpgradeInfoList = (UPGRADEINFO *)CoTaskMemAlloc(sizeof(UPGRADEINFO)*
                                                        (pPackageInfo->cUpgrades));
		
            if (pPackageInfo->prgUpgradeInfoList)
            {
                memset(pPackageInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pPackageInfo->cUpgrades));

                for (j=0; j < ( pPackageInfo->cUpgrades); ++j)
                {
                    WCHAR *pStr = NULL;
                    LPOLESTR ptr = (pPackageInfo->prgUpgradeInfoList[j].szClassStore) = pProp[j];
                    UINT len = wcslen (ptr);
                    if (len <= 41)
                        continue;

                    *(ptr + len - 3) = NULL;
                    (pPackageInfo->prgUpgradeInfoList[j].Flag) = wcstoul(ptr+(len-2), &pStr, 16);

                    *(ptr + len - 3 - 36 - 2) = L'\0';
                            /*      -GUID-'::'*/
                    GUIDFromString(ptr+len-3-36, &(pPackageInfo->prgUpgradeInfoList[j].PackageGuid));
                }
                pPackageInfo->cUpgrades = j; // we might have skipped some.
            }


    	}
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, UILEVEL, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, (DWORD *)&(pPackageInfo->InstallUiLevel));

            ADSIFreeColumn(hADs, &column);
        }

        hr = ADSIGetColumn(hADs, hADsSearchHandle, HELPURL, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

            ADSIFreeColumn(hADs, &column);
        }
        
        hr = ADSIGetColumn(hADs, hADsSearchHandle, PUBLISHER, &column);
		
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszPublisher));

            ADSIFreeColumn(hADs, &column);
        }

        hr = ADSIGetColumn(hADs, hADsSearchHandle, MSIFILELIST, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR *rpszSourceList = NULL, psz = NULL, pStr = NULL;
            DWORD     Loc = 0, cSources=0;
            
            UnpackStrArrFrom(column, &(rpszSourceList), &cSources);
            
            // reorder and allocate spaces.
            if (cSources > 1)
            {
                pPackageInfo->fHasTransforms = 1;

/*                
                (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*
                    (pPackageInfo->cSources));

                // if we could not, plod on, the caller will get back as much as possible.
                if (!(pPackageInfo->pszSourceList)) {
                    pPackageInfo->cSources = 0;
                }

                memset(pPackageInfo->pszSourceList, 0, sizeof(LPOLESTR)*(pPackageInfo->cSources));

                for (count = 0; count < (pPackageInfo->cSources); count++) 
                {
                    pPackageInfo->pszSourceList[count] = (LPOLESTR)CoTaskMemAlloc(
                                            sizeof(WCHAR)*(wcslen(rpszSourceList[count])+1));

                    if (!(pPackageInfo->pszSourceList[count]))
                        break;
                }

                // if mem couldn't be allocated
                if (count != pPackageInfo->cSources) {
                    for (count = 0; count < (pPackageInfo->cSources); count++) 
                        if ((pPackageInfo->pszSourceList[count]))
                            CoTaskMemFree(pPackageInfo->pszSourceList[count]);

                    CoTaskMemFree(pPackageInfo->pszSourceList);
                    pPackageInfo->cSources = 0;
                }

                for (count = 0; count < (pPackageInfo->cSources); count++) 
                {
                    psz = wcschr(rpszSourceList[count], L':');
                    *psz = L'\0';
                    Loc = wcstoul(rpszSourceList[count], &pStr, 10);                    
                    wsprintf(pPackageDetail->pszSourceList[Loc], L"%s", psz+1);
                }
*/
            }
            else
                pPackageInfo->fHasTransforms = 0;
            
            CoTaskMemFree(rpszSourceList);

            ADSIFreeColumn(hADs, &column);
        }

        ++pPackageInfo;
        
        cRowsLeft--;
        
        (*pcRowsFetched)++;
        
    }
    
    if (!cRowsLeft)
        return S_OK;
    return S_FALSE;    
}

// FetchCategory
//--------------
//
// List of columns this routine fetches.
//

HRESULT FetchCategory(HANDLE               hADs,
                      ADS_SEARCH_HANDLE    hADsSearchHandle,
                      APPCATEGORYINFOLIST *pCategoryInfoList,
                      LCID                 Locale
                      )
{
    HRESULT                 hr = S_OK;
    ADS_SEARCH_COLUMN       column;
    LPOLESTR              * pszDesc = NULL;
    DWORD                   cdesc = 0, i = 0;
    LPOLESTR                szCatid = NULL;
    

    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle), i = 0;
                   ((SUCCEEDED(hr)) && ((hr) != S_ADS_NOMORE_ROWS));
                   hr = ADSIGetNextRow(hADs, hADsSearchHandle), i++)
    {
        // Get the data from each row ignoring the error returned.        
        
        // allocated number of buffers.
        if (i >= (pCategoryInfoList->cCategory))
            break;

        //Column = description
        hr = ADSIGetColumn(hADs, hADsSearchHandle, LOCALEDESCRIPTION, &column);
        cdesc = 0; pszDesc = NULL;
        
        if (SUCCEEDED(hr))
            UnpackStrArrFrom(column, &pszDesc, &cdesc);
                
        (pCategoryInfoList->pCategoryInfo)[i].Locale = Locale;
        (pCategoryInfoList->pCategoryInfo)[i].pszDescription =
	    		    (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*128);
        // BUGBUG:: Restricting the desc to 128.

        if ((pCategoryInfoList->pCategoryInfo)[i].pszDescription)
            GetCategoryLocaleDesc(pszDesc, cdesc, &((pCategoryInfoList->pCategoryInfo)[i].Locale),
	      		                (pCategoryInfoList->pCategoryInfo)[i].pszDescription);

        if (SUCCEEDED(hr))
            ADSIFreeColumn(hADs, &column);

        if (pszDesc)
            CoTaskMemFree(pszDesc);
        
        // catid
        hr = ADSIGetColumn(hADs, hADsSearchHandle, CATEGORYCATID, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &((pCategoryInfoList->pCategoryInfo)[i].AppCategoryId));
            
            ADSIFreeColumn(hADs, &column);
        }
    }
    
    pCategoryInfoList->cCategory = i;
    return S_OK;
}


HRESULT GetClassDetail(WCHAR *szClassPath, CLASSDETAIL *pClassDetail)
{
    HRESULT         hr = S_OK;
    WCHAR          *szGUID = NULL;
    ADS_ATTR_INFO  *pAttrsGot = NULL;
    HANDLE          hADs = NULL;
    LPOLESTR        AttrNames[] = {PROGIDLIST, TREATASCLSID, CLASSCLSID};
    DWORD           posn = 0, cProp = 0, cgot = 0;

    
    hr = ADSIOpenDSObject(szClassPath, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                          &hADs);
    RETURN_ON_FAILURE(hr);

    hr = ADSIGetObjectAttributes(hADs, AttrNames, 3, &pAttrsGot, &cgot);
    ERROR_ON_FAILURE(hr);
        
    posn = GetPropertyFromAttr(pAttrsGot, cgot, CLASSCLSID);

    if (posn < cgot) {
        UnpackStrFrom(pAttrsGot[posn], &szGUID);
        GUIDFromString(szGUID, &(pClassDetail->Clsid));
    }
    else
    {
        hr = CS_E_OBJECT_NOTFOUND;
        ERROR_ON_FAILURE(hr);
    }

    posn = GetPropertyFromAttr(pAttrsGot, cgot, PROGIDLIST);        
    if (posn < cgot)
        UnpackStrArrAllocFrom(pAttrsGot[posn], &(pClassDetail->prgProgId), 
                              &(pClassDetail->cProgId));


    posn = GetPropertyFromAttr(pAttrsGot, cgot, TREATASCLSID);                    
    if (posn < cgot)
    {
        UnpackStrFrom(pAttrsGot[posn], &szGUID);
        GUIDFromString(szGUID, &(pClassDetail->TreatAs));
    }
    
Error_Cleanup:
    if (pAttrsGot)
        FreeADsMem(pAttrsGot);

    if (hADs)
        ADSICloseDSObject(hADs);
        
    return hr;
}

HRESULT GetPackageDetail (HANDLE           hPackageADs, WCHAR *szClassContainerPath, 
                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT             hr = S_OK;
    GUID                PkgGuid;
    DWORD              *pdwArch = NULL, count = 0;
    PLATFORMINFO       *pPlatformInfo = NULL;
    INSTALLINFO        *pInstallInfo = NULL;
    ACTIVATIONINFO     *pActInfo = NULL;
    ADS_ATTR_INFO      *pAttr = NULL;
    DWORD               posn, cgot = 0;
    DWORD               cClasses = 0;
    LPOLESTR           *szClasses = NULL;
	DWORD				dwUiLevel = 0;
    DWORD               cProgId = 0;
    LPOLESTR           *pszProgId = NULL;   
	
    memset (pPackageDetail, 0, sizeof (PACKAGEDETAIL));
    
    hr = ADSIGetObjectAttributes(hPackageADs, pszPackageDetailAttrNames, cPackageDetailAttr,
		&pAttr, &cgot);
    RETURN_ON_FAILURE(hr);
    
    pInstallInfo = pPackageDetail->pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc(sizeof (INSTALLINFO));
    
    if (!pInstallInfo)
        ERROR_ON_FAILURE((hr=E_OUTOFMEMORY));

    memset(pInstallInfo, NULL, sizeof(INSTALLINFO));
    
    posn = GetPropertyFromAttr(pAttr, cgot,  PACKAGEFLAGS);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], (DWORD *)&(pInstallInfo->dwActFlags));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));

    posn = GetPropertyFromAttr(pAttr, cgot, PACKAGETYPE);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], (DWORD *)&(pInstallInfo->PathType));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));

    
    posn = GetPropertyFromAttr(pAttr, cgot, SCRIPTPATH);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszScriptPath));    
    
    posn = GetPropertyFromAttr(pAttr, cgot, SCRIPTSIZE);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], &(pInstallInfo->cScriptLen));
    
    posn = GetPropertyFromAttr(pAttr, cgot, SETUPCOMMAND);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszSetupCommand));
    
    posn = GetPropertyFromAttr(pAttr, cgot, HELPURL);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszUrl));
    
    posn = GetPropertyFromAttr(pAttr, cgot, PKGUSN);
    if (posn < cgot)
        UsnGet(pAttr[posn], (CSUSN *)&(pInstallInfo->Usn));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));
    
    posn = GetPropertyFromAttr(pAttr, cgot, PRODUCTCODE);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->ProductCode));
    
    posn = GetPropertyFromAttr(pAttr, cgot, MVIPC);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->Mvipc));
    // doesn't matter if the property itself is multivalued.
    
    posn = GetPropertyFromAttr(pAttr, cgot, OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->PackageGuid));

    posn = GetPropertyFromAttr(pAttr, cgot, VERSIONHI);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwVersionHi));
    
    posn = GetPropertyFromAttr(pAttr, cgot, VERSIONLO);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwVersionLo));
    
    posn = GetPropertyFromAttr(pAttr, cgot, REVISION);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwRevision));
    
    posn = GetPropertyFromAttr(pAttr, cgot, UILEVEL);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], &dwUiLevel);
    
    pInstallInfo->InstallUiLevel = dwUiLevel;
    
    posn = GetPropertyFromAttr(pAttr, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
    {
        LPOLESTR *pProp = NULL;
        UnpackStrArrAllocFrom(pAttr[posn], &pProp, (DWORD *)&(pInstallInfo->cUpgrades));
        
        if (pInstallInfo->cUpgrades)
            pInstallInfo->prgUpgradeInfoList = (UPGRADEINFO *)CoTaskMemAlloc(sizeof(UPGRADEINFO)*
                                                                             pInstallInfo->cUpgrades);

        if (!(pInstallInfo->prgUpgradeInfoList))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        memset(pInstallInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pInstallInfo->cUpgrades));

        for (count = 0; (count < (pInstallInfo->cUpgrades)); count++)
        {
            WCHAR *pStr = NULL;
            LPOLESTR ptr = (pInstallInfo->prgUpgradeInfoList[count].szClassStore) = pProp[count];
            UINT len = wcslen (ptr);
            
            if (len <= 41)
                continue;

            *(ptr + len - 3) = NULL;
            pInstallInfo->prgUpgradeInfoList[count].Flag = wcstoul(ptr+(len-2), &pStr, 16);

            *(ptr + len - 3 - 36 - 2) = L'\0';
                    /*      -GUID-'::'*/
            GUIDFromString(ptr+len-3-36, &(pInstallInfo->prgUpgradeInfoList[count].PackageGuid));
        }
        pInstallInfo->cUpgrades = count; // we might have skipped some.
    }
    
    
    pPlatformInfo = pPackageDetail->pPlatformInfo =
        (PLATFORMINFO *) CoTaskMemAlloc(sizeof (PLATFORMINFO));
    if (!pPlatformInfo) 
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    memset(pPlatformInfo, NULL, sizeof(PLATFORMINFO));
        
    posn = GetPropertyFromAttr(pAttr, cgot, ARCHLIST);
    
    if (posn < cgot)
        // Minor BUGBUG:: int converted to long.
        UnpackDWArrFrom(pAttr[posn], &pdwArch, (unsigned long *)&(pPlatformInfo->cPlatforms));
    
    pPlatformInfo->prgPlatform = (CSPLATFORM *)CoTaskMemAlloc(sizeof(CSPLATFORM)*
        (pPlatformInfo->cPlatforms));
    
    if (!(pPlatformInfo->prgPlatform))
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    for (count = 0; (count < (pPlatformInfo->cPlatforms)); count++)
        PackPlatform (pdwArch[count], (pPlatformInfo->prgPlatform)+count);
    
    CoTaskMemFree(pdwArch);
    
    posn = GetPropertyFromAttr(pAttr, cgot, LOCALEID);
    if (posn < cgot)
        // Minor BUGBUG:: int converted to long.
        UnpackDWArrFrom(pAttr[posn], &(pPlatformInfo->prgLocale),
        (unsigned long *)&(pPlatformInfo->cLocales));
	
    //
    // fill in ActivationInfo.
    //

    pActInfo = pPackageDetail->pActInfo = 
        (ACTIVATIONINFO *) CoTaskMemAlloc(sizeof (ACTIVATIONINFO));
	
    if (!pActInfo) {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }

    memset(pActInfo, NULL, sizeof(ACTIVATIONINFO));
        
    // get the progids so that we can eliminate progids from Clsids that do not match.
    
    posn = GetPropertyFromAttr(pAttr, cgot, PKGCLSIDLIST);
    cClasses = 0; szClasses = NULL;
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szClasses, &cClasses);
    pActInfo->cClasses = cClasses;
    if (cClasses)
    {
        pActInfo->pClasses = (CLASSDETAIL *) CoTaskMemAlloc (cClasses * sizeof(CLASSDETAIL));
        if (!(pActInfo->pClasses))
            return E_OUTOFMEMORY;

        memset (pActInfo->pClasses, NULL, cClasses * sizeof(CLASSDETAIL));
        
        for (count = 0; count < cClasses; count++)
        {
            WCHAR *szADsFullClassPath=NULL;
            WCHAR  szClassName[_MAX_PATH];

            if (wcslen(szClasses[count]) > (STRINGGUIDLEN-1))
            {
                WCHAR *szPtr = NULL;
                szClasses[count][STRINGGUIDLEN-1] = L'\0';
                pActInfo->pClasses[count].dwComClassContext = 
                                    wcstoul(szClasses[count]+STRINGGUIDLEN, &szPtr, 16);
            }

            wsprintf(szClassName, L"CN=%s", szClasses[count]);
            BuildADsPathFromParent(szClassContainerPath, szClassName, &szADsFullClassPath);
            hr = GetClassDetail(szADsFullClassPath, &(pActInfo->pClasses[count]));
            ERROR_ON_FAILURE(hr);
            
            // remove all the progids that do not belong to this package.
            FreeADsMem(szADsFullClassPath);
        }
        
        CoTaskMemFree(szClasses);
    }
    
    posn = GetPropertyFromAttr(pAttr, cgot, PKGIIDLIST);
    cClasses = 0; szClasses = NULL;
    
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szClasses, &cClasses);
    pActInfo->cInterfaces = cClasses;
    if (cClasses)
    {
        pActInfo->prgInterfaceId = (IID *) CoTaskMemAlloc (cClasses * sizeof(GUID));
        if (!(pActInfo->prgInterfaceId))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
    
        for (count = 0; count < cClasses; count++)
        {
            GUIDFromString(szClasses[count], (pActInfo->prgInterfaceId + count));
        }
        CoTaskMemFree(szClasses);
    }
    
    posn = GetPropertyFromAttr(pAttr, cgot, PKGTLBIDLIST);
    cClasses = 0; szClasses = NULL;
    
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szClasses, &cClasses);
    pActInfo->cTypeLib = cClasses;
    
    if (cClasses)
    {
        pActInfo->prgTlbId = (IID *) CoTaskMemAlloc (cClasses * sizeof(GUID));
        if (!(pActInfo->prgTlbId))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; count < cClasses; count++)
        {
            GUIDFromString(szClasses[count], (pActInfo->prgTlbId + count));
        }
        CoTaskMemFree(szClasses);
    }
    
    posn = GetPropertyFromAttr(pAttr, cgot, PKGFILEEXTNLIST);
    cClasses = 0;
    
    if (posn < cgot)
        UnpackStrArrAllocFrom(pAttr[posn], &(pActInfo->prgShellFileExt), &cClasses);
    pActInfo->cShellFileExt = cClasses;
    
    if (cClasses)
    {
        pActInfo->prgPriority = (UINT *)CoTaskMemAlloc(cClasses * sizeof(UINT));
        if (!(pActInfo->prgPriority))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
   
        for (count = 0; count < cClasses; count++)
        {
            LPOLESTR pStr=NULL;
            UINT cLen = wcslen((pActInfo->prgShellFileExt)[count]);
            *((pActInfo->prgShellFileExt)[count] + (cLen - 3)) = NULL;
            (pActInfo->prgPriority)[count] = 
                wcstoul((pActInfo->prgShellFileExt)[count]+(cLen-2), &pStr, 10);
        }
    }
	
    //
    // fill in package misc info
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PACKAGENAME);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn],   &(pPackageDetail->pszPackageName));
    else
        ERROR_ON_FAILURE(hr=CS_E_OBJECT_NOTFOUND);

    posn = GetPropertyFromAttr(pAttr, cgot, MSIFILELIST);
    if (posn < cgot) {
        LPOLESTR *rpszSourceList = NULL, psz = NULL, pStr = NULL;
        DWORD     Loc = 0;

        UnpackStrArrFrom(pAttr[posn], &(rpszSourceList),
							 (DWORD *)&(pPackageDetail->cSources));

        // reorder and allocate spaces.
        if (pPackageDetail->cSources) 
        {
            pPackageDetail->pszSourceList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*
                                                                        (pPackageDetail->cSources));
            if (!(pPackageDetail->pszSourceList))
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

            for (count = 0; count < (pPackageDetail->cSources); count++) 
            {
                psz = wcschr(rpszSourceList[count], L':');
                *psz = L'\0';
                Loc = wcstoul(rpszSourceList[count], &pStr, 10);
                pPackageDetail->pszSourceList[Loc] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(psz+1)+1));
                if (!(pPackageDetail->pszSourceList[Loc]))
                    ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

                wsprintf(pPackageDetail->pszSourceList[Loc], L"%s", psz+1);
            }
        }

        CoTaskMemFree(rpszSourceList);
    }
	
    posn = GetPropertyFromAttr(pAttr, cgot, PKGCATEGORYLIST);
    cClasses = 0; szClasses = NULL;

    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szClasses, &cClasses);
	
    if (cClasses)
    {
        pPackageDetail->rpCategory = (GUID *)CoTaskMemAlloc (sizeof(GUID) * cClasses);
        if (!(pPackageDetail->rpCategory))
            ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
        pPackageDetail->cCategories = cClasses;
        for (count = 0; count < cClasses; count++)
        {
            GUIDFromString(szClasses[count], (pPackageDetail->rpCategory + count));
        }
        CoTaskMemFree(szClasses);
    }
    
    return S_OK;

Error_Cleanup:
    ReleasePackageDetail(pPackageDetail);
    memset(pPackageDetail, 0, sizeof(PACKAGEDETAIL));

    if (pAttr)
        FreeADsMem(pAttr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\appmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Mar 12 06:53:36 1997
 */
/* Compiler settings for appmgr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __appmgr_h__
#define __appmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __APPMGRLib_LIBRARY_DEFINED__
#define __APPMGRLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: APPMGRLib
 * at Wed Mar 12 06:53:36 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_APPMGRLib;
#endif /* __APPMGRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\common\qry.cxx ===
#include "dsbase.hxx"

//
// List of columns this routine fetches.
//
LPOLESTR szInstallInfoColumns =
L"msiScriptPath,packageFlags,comClassID,packageType,lastUpdateSequence,versionNumberHi,versionNumberLo,localeID,machineArchitecture,oSVersion,fileExtPriority,canUpgradeScript,installUiLevel,executionContext,url,setupCommand";

//
// List of columns this routine fetches.
//
LPOLESTR szPackageInfoColumns =
L"packageName,packageFlags,packageType,msiScriptPath,msiScriptSize,lastUpdateSequence,versionNumberHi,versionNumberLo,localeID,machineArchitecture,oSVersion,canUpgradeScript";

//
// MatchLocale : Compares the packages locale to the client locale.
//               Prescribed order is :
//


BOOL MatchLocale(DWORD dwReqLocale, DWORD dwPkgLocale)
{            
    return ((dwReqLocale == dwPkgLocale) ||      // locale is matching
        (dwPkgLocale == GetUserDefaultLCID()) ||  // pkg locale is user default
        (dwPkgLocale == GetSystemDefaultLCID()) ||    // pkg locale is system default
        (dwPkgLocale == LOCALE_NEUTRAL)            // pkg is locale neutral
        );
            
}

BOOL MatchPlatform(CSPLATFORM *pReqPlatform, CSPLATFORM *pPkgPlatform)
{            
    //
    // ProcessorArch must match
    // AND OS must match
    // AND the OS version reqd by the package MUST be less or equal
    //     to the client's OS version
    //
        
    return (
        (pReqPlatform->dwPlatformId == pPkgPlatform->dwPlatformId)  &&
        (pReqPlatform->dwProcessorArch == pPkgPlatform->dwProcessorArch) &&
        ((pReqPlatform->dwVersionHi < pPkgPlatform->dwVersionHi)  ||
         ((pReqPlatform->dwVersionHi == pPkgPlatform->dwVersionHi)  &&
          (pReqPlatform->dwVersionLo <= pPkgPlatform->dwVersionLo))
        )
          );
}

//---------------------------------------------------------------
//  Query
//----------------------------------------------------------------
HRESULT
StartQuery(IDBCreateCommand    ** ppIDBCreateCommand)
{
    
    HRESULT         hr;
    IDBCreateSession    * pIDBCS = NULL;
    IDBInitialize       * pIDBInit = NULL;
    
    //
    // Instantiate a data source object for LDAP provider
    //
    hr = CoCreateInstance(
        CLSID_ADsDSOObject,
        0,
        CLSCTX_INPROC_SERVER,
        IID_IDBInitialize,
        (void **)&pIDBInit
        );
    if(FAILED(hr))
    {
        printf("CoCreateInstance failed \n");
        goto error;
    }
    
    hr = pIDBInit->Initialize();
    if(FAILED(hr))
    {
        printf("IDBIntialize::Initialize failed \n");
        goto error;
    }
    
    //
    // Request the IDBCreateSession interface
    //
    pIDBInit->QueryInterface(
        IID_IDBCreateSession,
        (void**) &pIDBCS);
    if(FAILED(hr))
    {
        printf("QueryInterface for IDBCreateSession failed \n");
        goto error;
    }
    
    pIDBInit->Release();
    pIDBInit = NULL;
    
    //
    // Create a session returning a pointer to its CreateCommand interface
    //
    hr = pIDBCS->CreateSession(
        NULL,
        IID_IDBCreateCommand,
        (LPUNKNOWN*) ppIDBCreateCommand
        );
    if(FAILED(hr))
    {
        printf("IDBCreateSession::CreateSession failed \n");
        goto error;
    }
    
    pIDBCS->Release();
    pIDBCS = NULL;
    
    return S_OK;
    
error:
    
    if(pIDBInit)
        pIDBInit->Release();
    if(pIDBCS)
        pIDBCS->Release();
    return -1;
    
}

HRESULT
EndQuery(IDBCreateCommand    * pIDBCreateCommand)
{
    pIDBCreateCommand->Release();
    return S_OK;
}

HRESULT
CreateBindingHelper(
                    IRowset *pIRowset,
                    ULONG   cColumns,
                    DBBINDING **pprgBindings
                    );


//  ExecuteQuery
// --------------
//
//  This is a generic routine.
//  It hides a lot of nuisances with regards to setting up a OLEDB
//  query session, specifying a query command and executing it,
//  associating a provided binding with it and getting an
//  Accessor and Rowset out of all these.
//
//  The inputs are
//      A IDBCreateCommand object to provide for reuse
//      The Query Command Text
//      Number of Columns in the query
//      Binding Association for Data Access
//  The Returned Set is:
//      Rowset Object
//      Accessor Object
//      Accessor Handle


HRESULT ExecuteQuery (IDBCreateCommand  *    pIDBCreateCommand,
                      LPWSTR         pszCommandText,
                      UINT           nColumns,
                      DBBINDING      *   pBinding,
                      HACCESSOR      *   phAccessor,
                      IAccessor      **  ppIAccessor,
                      IRowset        **  ppIRowset
                      )
{
    HRESULT        hr;
    ICommand     * pICommand = NULL;
    ICommandText     * pICommandText = NULL;
    IAccessor    * pAccessor = NULL;
    DBBINDING        * prgBindings = NULL;
    
    //
    // Create a command from the session object
    //
    
    hr = pIDBCreateCommand->CreateCommand(
        NULL,
        IID_ICommandText,
        (LPUNKNOWN*) &pICommandText);
    
    if(FAILED(hr))
    {
        printf(" IDBCreateCommand::CreateCommand failed, hr = 0x%x\n", hr);
        return hr;
    }
    
    hr = pICommandText->SetCommandText(
        DBGUID_LDAPDialect,
        pszCommandText
        );
    
    CSDbgPrint(("CS: Query: %S\n", pszCommandText));
    
    if(FAILED(hr))
    {
        printf("ICommandText::CommandText failed \n");
        return hr;
    }
    
    hr = pICommandText->QueryInterface(
        IID_ICommand,
        (void**) &pICommand);
    
    if(FAILED(hr))
    {
        printf("QueryInterface for ICommand failed \n");
        return hr;
    }
    
    hr = pICommandText->Release();
    
    //
    // Do the search and get back a rowset
    //
    hr = pICommand->Execute(
        NULL,
        IID_IRowset,
        NULL,
        NULL,
        (LPUNKNOWN *)ppIRowset);
    
    if (FAILED(hr))
    {
        printf("ICommand::Execute failed \n");
        return hr;
    }
    
    pICommand->Release();
    
    
    hr= (*ppIRowset)->QueryInterface(
        IID_IAccessor,
        (void**) ppIAccessor);
    
    if(FAILED(hr))
    {
        printf("QueryInterface for IAccessor failed \n");
        return hr;
    }
    
    //
    // With the bindings create the accessor
    //
    if (!pBinding)
    {
        //
        // Create a binding from data type
        //
        hr = CreateBindingHelper(
            *ppIRowset,
            nColumns,
            &prgBindings);
        
    }
    
    hr = (*ppIAccessor)->CreateAccessor(
        DBACCESSOR_ROWDATA,
        nColumns,
        (pBinding?pBinding:prgBindings),
        0,
        phAccessor,
        NULL);
    
    //
    // If a binding was created automatically, free it
    //
    if (prgBindings)
    {
        CoTaskMemFree(prgBindings);
    }
    
    return hr;
}


// FetchInstallData
//-----------------
//
//  This routine performs actual data access after a query execution.
//
//  It is not generic. It is query specific.
//  
//  This routine fetches data for the most common package query.



HRESULT FetchInstallData(
                 IRowset    *pIRowset,
                 HACCESSOR  hAccessor,
                 QUERYCONTEXT   *pQryContext,
                 LPOLESTR   pszFileExt,
                 ULONG      cRows,
                 ULONG      *pcRowsFetched,
                 INSTALLINFO *pInstallInfo,
                 UINT        *pdwPriority
                 )
                         
{
    HROW         * phRows = NULL;
    HRESULT      hr;
    UINT         i, j;
    Data         pData[20];
    VARIANT      *pVariant;
    ULONG        cRowsGot;
    ULONG        cPlatforms = 0;
    DWORD        dwPlatformList[20];
    ULONG        cLocale = 0;
    LCID         dwLocaleList[20];
    CSPLATFORM   PkgPlatform;
    
            
    *pcRowsFetched = 0;
            
    //
    //  Get the rows
    //
    phRows = (HROW *) CoTaskMemAlloc (sizeof (HROW) * cRows);
    if(!phRows)
    {
        return E_OUTOFMEMORY;
    }
    
    hr = pIRowset->GetNextRows(NULL, 0, cRows, &cRowsGot, &phRows);
    
    if(FAILED(hr))
    {
        printf("IRowset::GetNextRows failed hr = 0x%x\n", hr);
        return hr;
    }
    
    
    for (i = 0; i < cRowsGot; i++)
    {
        //
        // Get the data from each row
        //
        
        memset(pData, 0, sizeof(Data) * 20);
        
        hr = pIRowset->GetData(phRows[i],
            hAccessor,
            (void*)&pData[0]
            );

        
        if (FAILED(hr))
        {
            //
            // BUGBUG. Missing cleanup.
            //
            printf("IRowset::GetData failed \n");
            return hr;
        }
        
        //
        // If querying by file ext check match and priority
        // .

        if (pszFileExt)
        {
            //Column = fileExtension
        
	        ULONG    cFileExt = 20;
	        LPOLESTR szFileExt[20], pStr;
                 
            if (pData[10].status != DBSTATUS_S_ISNULL)
            {
                cFileExt = 20;  
                pVariant = (VARIANT*) pData[10].obValue;
                hr = GetFromVariant(pVariant, &cFileExt, (LPOLESTR *)&szFileExt[0]);
            }

            UINT cLen = wcslen(pszFileExt);
            for (j=0; j < cFileExt; ++j)
            {
                if (wcslen(szFileExt[j]) != (cLen+3))
                    continue;
                if (wcsncmp(szFileExt[j], pszFileExt, wcslen(pszFileExt)) != 0) 
                    continue;
                *pdwPriority = wcstoul(szFileExt[j]+(cLen+1), &pStr, 10);
                break;
            }
            //
            // If none matched skip this package
            //
            if (j == cFileExt)
                continue;

        }
        //
        // Now check Locale and Platform
        // .

        if (pQryContext->Locale != LOCALE_NEUTRAL)
        {
            //Column = localeID
        
            if (pData[7].status != DBSTATUS_S_ISNULL)
            {
                cLocale = 20;  
                pVariant = (VARIANT*) pData[7].obValue;
                hr = GetFromVariant(pVariant, &cLocale, (LPOLESTR *)&dwLocaleList[0]);
            }

            for (j=0; j < cLocale; ++j)
            {
                if (MatchLocale (dwLocaleList[j], pQryContext->Locale))
                    break;
            }
            //
            // If none matched skip this package
            //
            if (j == cLocale)
                continue;

        }

        //Column = machineArchitecture
           
        if (pData[8].status != DBSTATUS_S_ISNULL)
        {
            cPlatforms = 20;    
            pVariant = (VARIANT*) pData[8].obValue;
            hr = GetFromVariant(pVariant, &cPlatforms, (LPOLESTR *)&dwPlatformList[0]);
        }
            
        for (j=0; j < cPlatforms; ++j)
        {
             PackPlatform (dwPlatformList[j], &PkgPlatform);
             if (MatchPlatform (&(pQryContext->Platform), &PkgPlatform))
                 break;
        }
                
        //
        // If none matched skip this package
        //
        if (j == cPlatforms)
            continue;

        //
        // Move the data into InstallInfo structure
        //
        
        memset(pInstallInfo, 0, sizeof(INSTALLINFO));

        //Column = packageFlags
        if (pData[1].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->dwActFlags = (ULONG) (pData[1].obValue);
        }

        //
        // Does it support AutoInstall?
        //
        if (!(pInstallInfo->dwActFlags & ACTFLG_OnDemandInstall))
            continue;

        //Column = codePackage
        if (pData[0].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->pszScriptPath = (LPWSTR) CoTaskMemAlloc
                (sizeof(WCHAR) * (wcslen ((WCHAR *)pData[0].obValue)+1));
            wcscpy (pInstallInfo->pszScriptPath, (WCHAR *) pData[0].obValue);
        }
               
        
        //Column = comClassID
        if (pData[2].status != DBSTATUS_S_ISNULL)
        {
            ULONG cCount = 1;
            LPOLESTR pList = NULL;
            
            pVariant = (VARIANT*) pData[2].obValue;
            // Only access the first entry
            hr = GetFromVariant(pVariant, &cCount, &pList);
            pInstallInfo->pClsid = (GUID *) CoTaskMemAlloc (sizeof (GUID));
            GUIDFromString(pList, pInstallInfo->pClsid);
            CoTaskMemFree (pList);
        }
        
        //Column = packageType
        if (pData[3].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->PathType = (CLASSPATHTYPE) (ULONG) (pData[3].obValue);
        }
        
        //Column = lastUpdateSequence,
        if (pData[4].status != DBSTATUS_S_ISNULL)
        {
            swscanf ((LPOLESTR)(pData[4].obValue),
                L"%d %d",
                &(((CSUSN *)&(pInstallInfo->Usn))->dwHighDateTime),
                &(((CSUSN *)&(pInstallInfo->Usn))->dwLowDateTime)); 

        }
             
         //Column = versionNumberHi
        if (pData[5].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->dwVersionHi = (ULONG) (pData[5].obValue);
        }
        
        //Column = versionNumberLo
        if (pData[6].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->dwVersionLo = (ULONG) (pData[6].obValue);
        }
        
        if (pData[11].status != DBSTATUS_S_ISNULL)
        {
            ULONG cUp = 20;  

            pVariant = (VARIANT*) pData[11].obValue;
            pInstallInfo->prgUpgradeScript = 
                (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR) * cUp);
            hr = GetFromVariant(pVariant, &cUp, pInstallInfo->prgUpgradeScript);
            pInstallInfo->cUpgrades = cUp;

            pInstallInfo->prgUpgradeFlag = 
                (DWORD *) CoTaskMemAlloc(sizeof(DWORD) * cUp); 
            
            for (j=0; j < cUp; ++j)
            {
                LPOLESTR pStr;
                LPOLESTR ptr = (pInstallInfo->prgUpgradeScript)[j];
                UINT l = wcslen (ptr);
                *(ptr+l-2) = NULL;
                (pInstallInfo->prgUpgradeFlag)[j] = wcstoul(ptr+(l-1), &pStr, 10);
            }
        }
        
        //Column = installUiLevel
        if (pData[12].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->InstallUiLevel = (UINT) (pData[12].obValue);
        }

        //Column = ComClassContext
        if (pData[13].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->dwComClassContext = (UINT) (pData[13].obValue);
        }

        //Column = HelpUrl
        if (pData[14].status != DBSTATUS_S_ISNULL)
        {
            ULONG cCount = 1;
            
            pVariant = (VARIANT*) pData[14].obValue;
            // access only the first entry, allocated.
            hr = GetFromVariant(pVariant, &cCount, &(pInstallInfo->pszUrl));
        }
 
        //Column = setupCommand
        if (pData[15].status != DBSTATUS_S_ISNULL)
        {
            pInstallInfo->pszSetupCommand = (LPWSTR) CoTaskMemAlloc
                (sizeof(WCHAR) * (wcslen ((WCHAR *)pData[15].obValue)+1));
            wcscpy (pInstallInfo->pszSetupCommand, (WCHAR *) pData[15].obValue);
        }
               
        //
        // Check what memory needs to be freed
        //
        ++pInstallInfo;
        ++pdwPriority;
        ++(*pcRowsFetched);
        
     }
     
     if (cRowsGot)
     {
         //
         // Free the Row Handles
         //
         hr = pIRowset->ReleaseRows(cRowsGot, phRows, NULL, NULL, NULL);
     }
     
     if (phRows)
     {
         //
         // Free the Row Handle Pointer
         //
         CoTaskMemFree (phRows);
     }
     
     return S_OK;
     
}

// FetchPackageInfo
//-----------------
//
//  This routine performs actual data access after a query execution.
//
//  It is not generic. It is query specific.
//  
//  This routine fetches data for the most common package query.


HRESULT FetchPackageInfo(IRowset    *pIRowset,
                         HACCESSOR   hAccessor,
                         DWORD       dwFlags,
                         DWORD       *pdwLocale,
                         CSPLATFORM  *pPlatform,
                         ULONG       cRows,
                         ULONG      *pcRowsFetched,
                         PACKAGEDISPINFO *pPackageInfo
                         )
                         
{
    HROW         * phRows = NULL;
    HRESULT      hr;
    UINT         i, j;
    Data         pData[20];
    VARIANT      *pVariant;
    ULONG       cPlatforms = 0;
    DWORD       dwPlatformList[20];
    ULONG       cOs = 0;
    DWORD       dwOsList[20];
    ULONG       cLocale = 0;
    LCID        dwLocaleList[20];
    DWORD       dwPackageFlags;
    ULONG       cFetched;
    ULONG       cRowsLeft;
    CSPLATFORM  PkgPlatform;

    
    //
    //  Get the rows
    //
    phRows = (HROW *) CoTaskMemAlloc (sizeof (HROW) * cRows);
    if(!phRows)
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // The LDAP filter performs a part of the selection 
    // The flag filters are interpreted on the client after obtaining the result set
    // That requires us to repeat the fetch a number of times so as to 
    // make sure that all requested items are obtained.
    //

    *pcRowsFetched = 0;
    cRowsLeft = cRows;

    while (TRUE)
    {
        hr = pIRowset->GetNextRows(NULL, 0, cRowsLeft, &cFetched, &phRows);
    
        if(FAILED(hr))
        {
            printf("IRowset::GetNextRows failed hr = 0x%x\n", hr);
            return hr;
        }
    
    
        for (i = 0; i < cFetched; i++)
        {
            //
            // Get the data from each row
            //
        
            memset(pData, 0, sizeof(Data) * 20);
        
            hr = pIRowset->GetData(phRows[i],
                hAccessor,
                (void*)&pData[0]
                );
        
            
            if(FAILED(hr))
            {
                //
                // BUGBUG. Missing cleanup.
                //
                printf("IRowset::GetData failed \n");
                return hr;
            }
            

            //
            // Check flag values to see if this package meets the filter
            //
            
            //Get the Flag Value: Column = packageFlags
            
            dwPackageFlags = 0;
            if (pData[1].status != DBSTATUS_S_ISNULL)
            {
                dwPackageFlags = (ULONG) (pData[1].obValue);
            }
            
            if ((dwFlags & APPINFO_PUBLISHED) && (!(dwPackageFlags & ACTFLG_Published)))
            {
                continue;
            }

            if ((dwFlags & APPINFO_ASSIGNED) && (!(dwPackageFlags & ACTFLG_Assigned)))
            {
                continue;
            }

            if ((dwFlags & APPINFO_VISIBLE) && (!(dwPackageFlags & ACTFLG_UserInstall)))
            {
                continue;
            }

            if ((dwFlags & APPINFO_AUTOINSTALL) && (!(dwPackageFlags & ACTFLG_OnDemandInstall)))
            {
                continue;
            }

            //
            // Move the data into PackageInfo structure
            //
            memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));
            
            //Column = packageType
            if (pData[2].status != DBSTATUS_S_ISNULL)
            {
                pPackageInfo->PathType = (CLASSPATHTYPE) (ULONG) (pData[2].obValue);
            }
        
            //
            // Now check PathType
            //

            if ((dwFlags & APPINFO_MSI) && (pPackageInfo->PathType != DrwFilePath))
            {
                continue;
            }

            //
            // Now check Locale and Platform
            // BUGBUG. Missing.


            if (pdwLocale)
            {
                //Column = localeID
            
                if (pData[8].status != DBSTATUS_S_ISNULL)
                {
                    cLocale = 20;  
                    pVariant = (VARIANT*) pData[8].obValue;
                    hr = GetFromVariant(pVariant, &cLocale, (LPOLESTR *)&dwLocaleList[0]);
                }

                for (j=0; j < cLocale; ++j)
                {
                    if (MatchLocale (dwLocaleList[j], *pdwLocale))
                        break;
                }
                //
                // If none matched skip this package
                //
                if (j == cLocale)
                    continue;

            }

            if (pPlatform != NULL)
            {
            
                //Column = machineArchitecture
           
                if (pData[9].status != DBSTATUS_S_ISNULL)
                {
                    cPlatforms = 20;    
                    pVariant = (VARIANT*) pData[9].obValue;
                    hr = GetFromVariant(pVariant, &cPlatforms, (LPOLESTR *)&dwPlatformList[0]);
                }
            
                //Column = oSVersion. BUGBUG - unused now
           
                if (pData[10].status != DBSTATUS_S_ISNULL)
                {
                    cOs = 20;    
                    pVariant = (VARIANT*) pData[10].obValue;
                    hr = GetFromVariant(pVariant, &cOs, (LPOLESTR *)&dwOsList[0]);
                }
        
                for (j=0; j < cPlatforms; ++j)
                {
                    PackPlatform (dwPlatformList[j], &PkgPlatform);
                    if (MatchPlatform (pPlatform, &PkgPlatform))
                        break;
                }
                
                //
                // If none matched skip this package. 
                //
                if (j == cPlatforms)
                    continue;

            }

            pPackageInfo->dwActFlags = dwPackageFlags;
               
            //Column = packageName
            if (pData[0].status != DBSTATUS_S_ISNULL)
            {
                pPackageInfo->pszPackageName = (LPWSTR) CoTaskMemAlloc
                    (sizeof(WCHAR) * (wcslen ((WCHAR *)pData[0].obValue)+1));
                wcscpy (pPackageInfo->pszPackageName, (WCHAR *) pData[0].obValue);
            }
                
            //Column = codePackage
            if (pData[3].status != DBSTATUS_S_ISNULL)
            {
                pPackageInfo->pszScriptPath = (LPWSTR) CoTaskMemAlloc
                    (sizeof(WCHAR) * (wcslen ((WCHAR *)pData[3].obValue)+1));
                wcscpy (pPackageInfo->pszScriptPath, (WCHAR *) pData[3].obValue);
            }
               
            //Column = cScriptLen
            // BUGBUG. Wait for pScript.
            if (pData[4].status != DBSTATUS_S_ISNULL)
            {
                pPackageInfo->cScriptLen = 0; //(ULONG) (pData[4].obValue);
            }
        
            //Column = lastUpdateSequence,
            if (pData[5].status != DBSTATUS_S_ISNULL)
            {
                swscanf ((LPOLESTR)(pData[5].obValue),
                    L"%d %d",
                    &(((CSUSN *)&(pPackageInfo->Usn))->dwHighDateTime),
                    &(((CSUSN *)&(pPackageInfo->Usn))->dwLowDateTime));

            }
        
            //Column = versionNumberHi
            if (pData[6].status != DBSTATUS_S_ISNULL)
            {
                pPackageInfo->dwVersionHi = (ULONG) (pData[6].obValue);
            }
        
            //Column = versionNumberLo
            if (pData[7].status != DBSTATUS_S_ISNULL)
            {
                pPackageInfo->dwVersionLo = (ULONG) (pData[7].obValue);
            }

            if (pData[11].status != DBSTATUS_S_ISNULL)
            {
                ULONG cUp = 20;  

                pVariant = (VARIANT*) pData[11].obValue;
                pPackageInfo->prgUpgradeScript = 
                    (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR) * cUp);
                hr = GetFromVariant(pVariant, &cUp, pPackageInfo->prgUpgradeScript);
                pPackageInfo->cUpgrades = cUp;

                pPackageInfo->prgUpgradeFlag = 
                    (DWORD *) CoTaskMemAlloc(sizeof(DWORD) * cUp); 
            
                for (j=0; j < cUp; ++j)
                {
                    LPOLESTR pStr;
                    LPOLESTR ptr = (pPackageInfo->prgUpgradeScript)[j];
                    UINT l = wcslen (ptr);
                    *(ptr+l-2) = NULL;
                    (pPackageInfo->prgUpgradeFlag)[j] = 
                        wcstoul(ptr+(l-1), &pStr, 10);
                }
            }        
        
            //
            // Now process inline filters to decide if this package
            // meets the filter requirements
            // BUGBUG. Not implemented.
            if (0)
            {
                PackPlatform (dwPlatformList[0], NULL);
            }
            ++pPackageInfo;

            (*pcRowsFetched)++;

            //
            // Release memory 
            //
        
        }
     
        if (cFetched)
        {
            //
            // Free the Row Handles
            //
            hr = pIRowset->ReleaseRows(cFetched, phRows, NULL, NULL, NULL);
        }
        

        if (cRowsLeft > cFetched)
        {
            hr = S_FALSE;
            break;
        }

        cRowsLeft = cRows - *pcRowsFetched;
        
        if (cRowsLeft == 0)
        {
            hr = S_OK;
            break;
        }
     }
     
     if (phRows)
     {
         //
         // Free the Row Handle Pointer
         //
         CoTaskMemFree (phRows);
     }
     
     //
     // Check if we found as many as asked for
     //
     //if (*pcRowsFetched != cRows)
     //    return S_FALSE;
     return hr;
     
}

// FetchCategory
//--------------
//
// List of columns this routine fetches.
//

LPOLESTR szAppCategoryColumns =
	       L"extensionName, categoryId";

HRESULT FetchCategory(IRowset      	* pIRowset,
                      HACCESSOR     	  hAccessor,
                      ULONG    	    	  cRows,
                      ULONG   	   	* pcRowsFetched,
		      APPCATEGORYINFO  ** ppCategory,
		      LCID		  Locale
                 )
{
     HROW             		* phRows = NULL;
     HRESULT          		  hr = S_OK;
     UINT             		  i;
     Data			  pData[20];
     VARIANT		  	* pVariant = NULL;

     //
     //  Get the rows
     //

//     phRows = (HROW *) CoTaskMemAlloc (sizeof (HROW) * cRows);
//     if(!phRows)
//     {
//         return E_OUTOFMEMORY;
//     }
//
//     hr = pIRowset->GetNextRows(NULL, 0, cRows, pcRowsFetched, &phRows);

     phRows = NULL;

     hr = pIRowset->GetNextRows(NULL, 0, cRows, pcRowsFetched, &phRows);

     if(FAILED(hr))
     {
         printf("IRowset::GetNextRows failed hr = 0x%x\n", hr);
         return hr;
     }

     if (*pcRowsFetched)
	 *ppCategory = (APPCATEGORYINFO *)CoTaskMemAlloc(sizeof(APPCATEGORYINFO)*
						       (*pcRowsFetched));
     for (i = 0; i < *pcRowsFetched; i++)
     {
         //
         // Get the data from each row
         //

         memset(pData, 0, sizeof(Data));

         hr = pIRowset->GetData(phRows[i],
				hAccessor,
				(void*)&pData[0]
				);

         if(FAILED(hr))
         {
             //
             // BUGBUG. Missing cleanup.
             //
             printf("IRowset::GetData failed \n");
             return hr;
         }

             //Column = description
		
         if (pData[0].status != DBSTATUS_S_ISNULL)
         {
             ULONG cCount = 20;
             LPOLESTR pszDesc[20];
             
             pVariant = (VARIANT*) pData[0].obValue;
             
             hr = GetFromVariant(pVariant, &cCount, (LPOLESTR *)&pszDesc[0]);
             
             (*ppCategory)[i].Locale = Locale;
             (*ppCategory)[i].pszDescription = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*128);
             // BUGBUG:: same as comcat size. an arbitrary restriction.
             
             hr = GetCategoryLocaleDesc(pszDesc, cCount, &((*ppCategory)[i].Locale),
                 (*ppCategory)[i].pszDescription);
             
             
         }

         // column catid
         if (pData[1].status != DBSTATUS_S_ISNULL)
         {
             GUIDFromString((LPOLESTR)pData[1].obValue, &((*ppCategory)[i].AppCategoryId));
             
         }
     }

     if (*pcRowsFetched)
     {
         //
         // Free the Row Handles
         //
         hr = pIRowset->ReleaseRows(*pcRowsFetched, phRows, NULL, NULL, NULL);
     }

     if (*pcRowsFetched)
     {
         //
         // Free the Row Handle Pointer
         //
         CoTaskMemFree (phRows);
     }

     //
     // Check if we found as many as asked for
     //
     if (*pcRowsFetched != cRows)
         return S_FALSE;
     return S_OK;
}

HRESULT CloseQuery(IAccessor *pAccessor,
                   HACCESSOR hAccessor,
                   IRowset *pIRowset)
{
    ULONG cRef;
    
    if (pAccessor)
    {
        pAccessor->ReleaseAccessor(hAccessor, &cRef);    
        pAccessor->Release();
    }
    
    if (pIRowset)
    {
        pIRowset->Release();
    }
    
    return S_OK;
}


//---------------------------------------------------------------
//  End of Query
//----------------------------------------------------------------

//
// Form the bindings array to specify the way the provider has to put the
// data in buffer.
//

UINT i;
HRESULT
CreateBindingHelper(
                    IRowset *pIRowset,
                    ULONG   cColumns,
                    DBBINDING **pprgBind
                    )
{
    
    HRESULT hr;
    ULONG   cCols;
    DBCOLUMNINFO *prgColInfo = NULL;
    IColumnsInfo *pIColsInfo = NULL;
    LPOLESTR      szColNames = NULL;
    DBBINDING *prgBindings = NULL;
    
    if(!pIRowset)
        return(E_INVALIDARG);
    
    hr = pIRowset->QueryInterface(
        IID_IColumnsInfo,
        (void**) &pIColsInfo
        );
    if(FAILED(hr))
    {
        printf("QueryInterface for IColumnsInfo failed \n");
        return hr;
    }
    
    hr = pIColsInfo->GetColumnInfo(
        &cCols,
        &prgColInfo,
        &szColNames
        );
    if(FAILED(hr))
    {
        printf("IColumnsInfo::GetColumnInfo failed \n");
        return hr;
    }
    
    
    //
    // Verify that the number of columns match
    //
    if (cColumns != (cCols - 1))
    {
        return E_FAIL;
    }
    
    prgBindings = (DBBINDING *) CoTaskMemAlloc(sizeof(DBBINDING) * cColumns);
    
    //
    // Set up rest of the attributes
    //
    for (i=0; i < cColumns; i++)
    {
        memset (prgBindings+i, 0, sizeof(DBBINDING));
        prgBindings[i].iOrdinal = i+1;
        prgBindings[i].wType= prgColInfo[i+1].wType;
        if ((prgBindings[i].wType == DBTYPE_DATE) || (prgBindings[i].wType == DBTYPE_I8))
            prgBindings[i].obValue = sizeof(Data)*i + offsetof(Data, obValue2);
        else
            prgBindings[i].obValue = sizeof(Data)*i + offsetof(Data, obValue);
        prgBindings[i].obLength= sizeof(Data)*i + offsetof(Data, obLength);
        prgBindings[i].obStatus= sizeof(Data)*i + offsetof(Data, status);
        prgBindings[i].dwPart= DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS;
        
        if(prgBindings[i].wType & DBTYPE_BYREF)
            prgBindings[i].dwMemOwner= DBMEMOWNER_PROVIDEROWNED;
        else
            prgBindings[i].dwMemOwner= DBMEMOWNER_CLIENTOWNED;
        
        prgBindings[i].dwFlags= 0;
    }
    
    *pprgBind = prgBindings;
    
    pIColsInfo->Release();
    
    CoTaskMemFree(szColNames);
    CoTaskMemFree(prgColInfo);
    
    return(hr);
    
}

//
//
void GetCurrentUsn(LPOLESTR pStoreUsn)
{
    //
    // Get the current time as USN for the Class Store container
    //
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    wsprintf (pStoreUsn, L"%4d%2d%2d%2d%2d%2d", 
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);

}
//

HRESULT UsnUpd (IADs *pADs, LPWSTR szProp, LPOLESTR pUsn)
{
    //
    // Store the current USN
    //
    
    HRESULT hr = SetProperty (pADs,
        szProp,
        pUsn);
    
    return S_OK;
}

HRESULT UsnGet(IADs *pADs, LPWSTR szProp, CSUSN *pUsn)
{
    //
    // Read the USN for the Class Store container or Package
    //
    WCHAR szTimeStamp [20];
    SYSTEMTIME SystemTime;
    
    GetProperty (pADs,
        szProp,
        szTimeStamp);
    
    swscanf (szTimeStamp, L"%4d%2d%2d%2d%2d%2d", 
        &SystemTime.wYear,
        &SystemTime.wMonth,
        &SystemTime.wDay,
        &SystemTime.wHour,
        &SystemTime.wMinute,
        &SystemTime.wSecond);

    SystemTimeToFileTime(&SystemTime,
        (LPFILETIME) pUsn);

    return S_OK;
}

HRESULT GetPackageDetail (IADs            *pPackageADs,
                  PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT         hr = S_OK;
    GUID            PkgGuid;
    LPOLESTR        *pszString = NULL;
    DWORD           *pdwArch = NULL, count;
    PLATFORMINFO    *pPlatformInfo;
    INSTALLINFO     *pInstallInfo;
    ACTIVATIONINFO  *pActInfo;
    DWORD           cClasses;
    LPOLESTR        *szClasses;
    DWORD           dwUiLevel;


    memset (pPackageDetail, 0, sizeof (PACKAGEDETAIL));

    pInstallInfo = pPackageDetail->pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc(sizeof (INSTALLINFO));
    
    if (pInstallInfo)
    {
        memset(pInstallInfo, NULL, sizeof(INSTALLINFO));
        
        hr = GetPropertyDW (pPackageADs, PACKAGEFLAGS,
            &(pInstallInfo->dwActFlags));
        ERROR_ON_FAILURE(hr);
        
        hr = GetPropertyDW (pPackageADs, PACKAGETYPE,
            (DWORD *)&(pInstallInfo->PathType));
        ERROR_ON_FAILURE(hr);
        
        hr = GetPropertyAlloc(pPackageADs, SCRIPTPATH,
            &(pInstallInfo->pszScriptPath));
        ERROR_ON_FAILURE(hr);
        
        // BUGBUG. Wait for pScript
        //hr = GetPropertyDW (pPackageADs, SCRIPTSIZE,
        //    &(pInstallInfo->cScriptLen));
        //ERROR_ON_FAILURE(hr);

        hr = GetPropertyAlloc(pPackageADs, SETUPCOMMAND,
            &(pInstallInfo->pszSetupCommand));
        ERROR_ON_FAILURE(hr);
        
        hr = GetPropertyAlloc(pPackageADs, HELPURL,
            &(pInstallInfo->pszUrl));
        ERROR_ON_FAILURE(hr);
        
        hr = UsnGet(pPackageADs, 
            PKGUSN, 
            (CSUSN *)&(pInstallInfo->Usn));
        ERROR_ON_FAILURE(hr);
                
        hr = GetPropertyDW (pPackageADs, CLASSCTX,
            &(pInstallInfo->dwComClassContext));
        ERROR_ON_FAILURE(hr);
        
        // BUGBUG::***ProductCode

        hr = GetPropertyDW (pPackageADs, VERSIONHI,
            &(pInstallInfo->dwVersionHi));
        ERROR_ON_FAILURE(hr);

        hr = GetPropertyDW (pPackageADs, VERSIONLO,
            &(pInstallInfo->dwVersionLo));
        ERROR_ON_FAILURE(hr);

        hr = GetPropertyDW (pPackageADs, UILEVEL,
            &dwUiLevel);
        pInstallInfo->InstallUiLevel = dwUiLevel;
        ERROR_ON_FAILURE(hr);

        hr = GetPropertyListAlloc(pPackageADs, 
            UPGRADESCRIPTNAMES, 
            &count,
            &(pInstallInfo->prgUpgradeScript));
        pInstallInfo->prgUpgradeFlag = (DWORD *)CoTaskMemAlloc(count*sizeof(DWORD));
        pInstallInfo->cUpgrades = count; 
        for (count = 0; (count < (pInstallInfo->cUpgrades)); count++)
        {
            LPOLESTR pStr = NULL;
            LPOLESTR ptr = (pInstallInfo->prgUpgradeScript)[count];
            UINT l = wcslen (ptr);
            *(ptr + l - 2) = NULL;
           (pInstallInfo->prgUpgradeFlag)[count] = wcstoul(ptr+(l-1), &pStr, 10);
        }
    }
    
    pPlatformInfo = pPackageDetail->pPlatformInfo = 
        (PLATFORMINFO *) CoTaskMemAlloc(sizeof (PLATFORMINFO));

    if (pPlatformInfo)
    {
        memset(pPlatformInfo, NULL, sizeof(PLATFORMINFO));
        
        hr = GetPropertyListAllocDW(pPackageADs, ARCHLIST,
            (DWORD *)&(pPlatformInfo->cPlatforms), &pdwArch);
        ERROR_ON_FAILURE(hr);
        
        pPlatformInfo->prgPlatform = (CSPLATFORM *)CoTaskMemAlloc(sizeof(CSPLATFORM)*
            (pPlatformInfo->cPlatforms));
        
        for (count = 0; (count < (pPlatformInfo->cPlatforms)); count++)
            PackPlatform (pdwArch[count], (pPlatformInfo->prgPlatform)+count);
        
        CoTaskMemFree(pdwArch);
        
        hr = GetPropertyListAllocDW (pPackageADs, LOCALEID,
            (DWORD *)&(pPlatformInfo->cLocales),
            &(pPlatformInfo->prgLocale));
        ERROR_ON_FAILURE(hr);
    }

    //
    // fill in ActivationInfo.
    //
    pActInfo = pPackageDetail->pActInfo = 
        (ACTIVATIONINFO *) CoTaskMemAlloc(sizeof (ACTIVATIONINFO));

    if (pActInfo)
    {
        memset(pActInfo, NULL, sizeof(ACTIVATIONINFO));
    
        hr = GetPropertyListAlloc(pPackageADs, PKGCLSIDLIST, &cClasses, &szClasses);
        pActInfo->cClasses = cClasses;
        if (cClasses)
        {
            pActInfo->pClasses = (CLASSDETAIL *) CoTaskMemAlloc (cClasses * sizeof(CLASSDETAIL));
            memset (pActInfo->pClasses, NULL, cClasses * sizeof(CLASSDETAIL));
    
            for (count = 0; count < cClasses; count++)
            {
                GUIDFromString(szClasses[count], &((pActInfo->pClasses[count]).Clsid));
            }
        }

        for (count = 0; count < cClasses; count++)
            CoTaskMemFree(szClasses[count]);
        CoTaskMemFree(szClasses);

        hr = GetPropertyListAlloc(pPackageADs, PKGIIDLIST, &cClasses, &szClasses);
        pActInfo->cInterfaces = cClasses;
        if (cClasses)
        {
            pActInfo->prgInterfaceId = (IID *) CoTaskMemAlloc (cClasses * sizeof(GUID));
    
            for (count = 0; count < cClasses; count++)
            {
                GUIDFromString(szClasses[count], (pActInfo->prgInterfaceId + count));
            }
        }

        for (count = 0; count < cClasses; count++)
            CoTaskMemFree(szClasses[count]);
        CoTaskMemFree(szClasses);

        hr = GetPropertyListAlloc(pPackageADs, PKGTLBIDLIST, &cClasses, &szClasses);
        pActInfo->cTypeLib = cClasses;
        if (cClasses)
        {
            pActInfo->prgTlbId = (GUID *) CoTaskMemAlloc (cClasses * sizeof(GUID));
    
            for (count = 0; count < cClasses; count++)
            {
                GUIDFromString(szClasses[count], (pActInfo->prgTlbId + count));
            }
        }

        for (count = 0; count < cClasses; count++)
            CoTaskMemFree(szClasses[count]);
        CoTaskMemFree(szClasses);
            
        hr = GetPropertyListAlloc(pPackageADs, PKGFILEEXTNLIST, &cClasses, 
            &(pActInfo->prgShellFileExt));
        pActInfo->cShellFileExt = cClasses;
        if (cClasses)
        {
            pActInfo->prgPriority = (UINT *)CoTaskMemAlloc(cClasses * sizeof(UINT));
            for (count = 0; count < cClasses; count++)
            {
                LPOLESTR pStr;
                UINT cLen = wcslen((pActInfo->prgShellFileExt)[count]);
                *((pActInfo->prgShellFileExt)[count] + (cLen - 3)) = NULL;
                (pActInfo->prgPriority)[count] = 
                    wcstoul((pActInfo->prgShellFileExt)[count]+(cLen-2), &pStr, 10);
            }
        }
    }

    //
    // fill in package misc info
    //
    hr = GetPropertyAlloc(pPackageADs, PACKAGENAME,
            &(pPackageDetail->pszPackageName));
    ERROR_ON_FAILURE(hr);
    
    hr = GetPropertyListAlloc(pPackageADs, MSIFILELIST, &cClasses, 
            &(pPackageDetail->pszSourceList));
    pPackageDetail->cSources = cClasses;
    ERROR_ON_FAILURE(hr);

    hr = GetPropertyListAlloc(pPackageADs, PKGCATEGORYLIST, 
        &cClasses, &szClasses);
    ERROR_ON_FAILURE(hr);

    if (cClasses)
    {
        pPackageDetail->rpCategory = (GUID *)CoTaskMemAlloc (sizeof(GUID) * cClasses);
        pPackageDetail->cCategories = cClasses;
        for (count = 0; count < cClasses; count++)
        {
            GUIDFromString(szClasses[count], (pPackageDetail->rpCategory + count));
            CoTaskMemFree(szClasses[count]);
        }
        CoTaskMemFree(szClasses);
    }

    
Error_Cleanup:
    
    // BUGBUG:: free each of the strings.
    if (pszString)
        CoTaskMemFree(pszString);
    
    pPackageADs->Release();
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadm\catinfo.cxx ===
//
//  Author: ushaji
//  Date:   December 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for ICatInformation interfaces.                             
//
//      Refer Doc "Design for Support of File Types and Component Categories
//      in Class Store" ? (or may be Class Store Schema)
//


#include "csadm.hxx"

//---------------------------------------------------------------
// EnumCategories:
//      returns the enumerator to enumerate categories.
//        lcid:                    locale id.
//        ppenumcategoryinfo:        Enumerator that is returned.
//
// ppEnumCategoryInfo value is undefined if an error occurs
// I am assuming that except in rare conditions all the application in a
// particular environment will have the same lcid.
//---------------------------------------------------------------

HRESULT __stdcall CClassContainer::EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo)
{
    VARIANT                *pVarFilter = NULL;
    HRESULT                 hr;
    CSCEnumCategories      *pEnum;

    if (!m_fOpen)
        return E_FAIL;

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (!IsValidPtrOut(ppenumCategoryInfo, sizeof(IEnumCATEGORYINFO *)))
        return E_INVALIDARG;

    *ppenumCategoryInfo=NULL;

    pEnum=new CSCEnumCategories;
    if(NULL == pEnum)
        return E_OUTOFMEMORY;

    hr = pEnum->Initialize(m_ADsCategoryContainer, lcid);
    if (FAILED(hr))
    {
        delete pEnum;
        return hr;
    }

    hr = pEnum->QueryInterface(IID_IEnumCATEGORYINFO,(void**) ppenumCategoryInfo);

    if (FAILED(hr))
    {
        delete pEnum;
        return hr;
    }

    return S_OK;
} /* EnumCategories */

//---------------------------------------------------------------
// GetCategoryDesc:
//        returns the description of a given category.
//        rcatid:         category id.
//        lcid:           locale id.
//        ppszDesc        pointer to the description string to be returned.
//                        Allocated by the function. to be freed by client.
//--------------------------------------------------------------------------
HRESULT __stdcall CClassContainer::GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc)
{
    STRINGGUID    guidstr;
    ULONG         cdesc, i;
    LPOLESTR     *localedesc;
    IADs         *pADs;
    HRESULT       hr;

    if (!IsValidPtrOut(ppszDesc, sizeof(LPOLESTR)))
        return E_INVALIDARG;

    if (IsNullGuid(rcatid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    RdnFromGUID(rcatid, guidstr);
    hr = m_ADsCategoryContainer->GetObject(NULL, guidstr, (IDispatch **)&pADs);
    if (FAILED(hr))
        return CAT_E_CATIDNOEXIST;

    hr = GetPropertyListAlloc(pADs, LOCALEDESCRIPTION, &cdesc, &localedesc);
    if (hr == E_OUTOFMEMORY)
        return hr;

    if (FAILED(hr))
        return CAT_E_NODESCRIPTION;

    *ppszDesc = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR)*128);
    if (!(*ppszDesc))
        return E_OUTOFMEMORY;

    GetCategoryLocaleDesc(localedesc, cdesc, &lcid, *ppszDesc);

    for (i = 0; i < cdesc; i++)
        CoTaskMemFree(localedesc[i]);
    CoTaskMemFree(localedesc);
    pADs->Release();
    return S_OK;

} /* GetCategoryDesc */


//---------------------------------------------------------------
// EnumClassesOfCategories:
//        returns the enumerator for classes that implements given catids and
//                requires some given catids.
//
//        cImplemented    number of implemented categories.
//                        (0 is error and -1 is ignore implemented.
//        rgcatidImpl        list of implemented categories.
//                        should be NULL in the two cases mentioned above.
//
//        cRequired:        number of required categories.
//                        (0 is requiring nothing and -1 is ignore required.
//        rgcatidReq        list of required categories.
//                        should be NULL in the two cases mentioned above.
//
//        ppenumClsid        the enumerator of class ids.
//--------------------------------------------------------------------------

HRESULT __stdcall CClassContainer::EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[],
                                          ULONG cRequired, CATID rgcatidReq[],
                                          IEnumGUID **ppenumClsid)
{
    ULONG                          i;
    CSCEnumClassesOfCategories    *penumclasses;
    HRESULT                        hr;
    Data                          *pData;

    if (!IsValidPtrOut(ppenumClsid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;

    if ((rgcatidImpl == NULL) && (cImplemented != 0) && (cImplemented != -1))
        return E_INVALIDARG;

    if ((rgcatidReq == NULL) && (cRequired != 0) && (cRequired != -1))
        return E_INVALIDARG;

    if ((cImplemented == -1) && (rgcatidImpl != NULL))
        return E_POINTER;

    if ((cRequired == -1) && (rgcatidReq != NULL))
        return E_POINTER;

    if (cImplemented == 0)
        return E_INVALIDARG;

    if ((rgcatidImpl) && (!IsValidReadPtrIn(rgcatidImpl, sizeof(CATID)*cImplemented)))
    {
        return E_INVALIDARG;
    }

    if ((rgcatidReq) && (!IsValidReadPtrIn(rgcatidReq, sizeof(CATID)*cRequired)))
    {
        return E_INVALIDARG;
    }

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    penumclasses = new CSCEnumClassesOfCategories;
    if (!penumclasses)
    {
        return E_OUTOFMEMORY;
    }

    hr = penumclasses->Initialize(cRequired, rgcatidReq, cImplemented, rgcatidImpl,
                                 m_ADsClassContainer, (ICatInformation *)this);
    if (FAILED(hr))
    {
        delete penumclasses;
        return hr;
    }

    hr = penumclasses->QueryInterface(IID_IEnumCLSID, (void **)ppenumClsid);

    if (FAILED(hr))
    {
        delete penumclasses;
        return hr;
    }

    return hr;
} /* EnumClassesOfCategories */

//---------------------------------------------------------------
// EnumReqCategoriesOfClass:
//        see below EnumCategoriesofClass
//
//---------------------------------------------------------------

HRESULT CClassContainer::EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)

{
    if (!IsValidReadPtrIn(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(ppenumCatid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;

    return EnumCategoriesOfClass(rclsid, REQ_CATEGORIES, ppenumCatid);

} /* EnumReqClassesOfCategories */

//---------------------------------------------------------------
// EnumImplCategoriesOfClass:
//        see below EnumCategoriesofClass
//
//---------------------------------------------------------------
HRESULT CClassContainer::EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
    if (!IsValidReadPtrIn(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(ppenumCatid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;

    return EnumCategoriesOfClass(rclsid, IMPL_CATEGORIES, ppenumCatid);

} /* EnumimplClassesOfCategories */

//---------------------------------------------------------------
// EnumCategoriesOfClass:
//        returns the enumerator for the implemented or required
//    rclsid:            the class id.
//    impl_or_req        the type of category to enumerated.
//    ppenumcatid        the enumerator that is returned.
// Prefetches all the catids and then enumerates them.
//---------------------------------------------------------------

HRESULT CClassContainer::EnumCategoriesOfClass(REFCLSID rclsid, BSTR impl_or_req,
                                               IEnumGUID **ppenumCatid)
{
    STRINGGUID                  szName;
    IADs                        *pADs = NULL;
    ULONG                        i;
    ULONG                        cCatid;
    CATID                       *Catid = NULL;
    CSCEnumCategoriesOfClass    *pEnumCatid;
    HRESULT                      hr = S_OK;

    if (!m_fOpen)
        return E_FAIL;

    // Get the ADs interface corresponding to the clsid that is mentioned.
    RdnFromGUID(rclsid, szName);

    hr = m_ADsClassContainer->GetObject(NULL,
                szName,
                (IDispatch **)&pADs
                );
    RETURN_ON_FAILURE(hr);

    hr = GetPropertyListAllocGuid(pADs, impl_or_req, &cCatid,  &Catid);
    pADs->Release();
    RETURN_ON_FAILURE(hr);

    pEnumCatid = new CSCEnumCategoriesOfClass;
    if (!pEnumCatid)
    {
        if (Catid)
            CoTaskMemFree(Catid);
        return E_OUTOFMEMORY;
    }

    hr = pEnumCatid->Initialize(Catid, cCatid);
    if (Catid)
        CoTaskMemFree(Catid);

    if (FAILED(hr)) {
        delete pEnumCatid;
        return hr;
    }

    return pEnumCatid->QueryInterface(IID_IEnumCATID, (void **)ppenumCatid);
}
//---------------------------------------------------------------
// IsClassOfCategories:
//    similar to EnumClassesOfCategories but returns S_OK/S_FALSE for the
//    clsid rclsid. Finds the first class that implements these categories
//    and is of this clsid and checks its required.
//---------------------------------------------------------------

HRESULT __stdcall CClassContainer::IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented,
                                      CATID __RPC_FAR rgcatidImpl[  ],
                                      ULONG cRequired, CATID __RPC_FAR rgcatidReq[ ])
{
    ULONG        cRead, i;
    Data         *pData;
    HRESULT       hr, hr1;

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (cImplemented == 0)
        return E_INVALIDARG;

    if ((rgcatidImpl == NULL) && (cImplemented != 0) && (cImplemented != -1))
        return E_INVALIDARG;

    if ((rgcatidReq == NULL) && (cRequired != 0) && (cRequired != -1))
        return E_INVALIDARG;

    if ((cImplemented == -1) && (rgcatidImpl != NULL))
        return E_POINTER;

    if ((cRequired == -1) && (rgcatidReq != NULL))
        return E_POINTER;

    if ((rgcatidImpl) && (!IsValidReadPtrIn(rgcatidImpl, sizeof(CATID)*cImplemented)))
    {
        return E_INVALIDARG;
    }

    if ((rgcatidReq) && (!IsValidReadPtrIn(rgcatidReq, sizeof(CATID)*cRequired)))
    {
        return E_INVALIDARG;
    }

    hr = ImplSatisfied(rclsid, cImplemented, rgcatidImpl, this);
    RETURN_ON_FAILURE(hr);

    if (hr == S_OK)
    {
        hr = ReqSatisfied(rclsid, cRequired, rgcatidReq, this);
        RETURN_ON_FAILURE(hr);
    }

    if (hr != S_OK)
        return S_FALSE;
    return S_OK;
					
} /* IsClassOfCategories */


//--------------------------------------------------------------------------------
//    ReqSatisfied:
//        Returns S_OK/S_FALSE depending on whether the clsid satisfies the required
//        condition for the clsid.
//    clsid:                Class ID of the class.
//    cAvailReq:            Number of Available required classes.
//    AvailReq:            Avail required classes.
//    calls the enumerator and sees whether there is any required class not present in
//    the available list. returns S_OK if cAvailReq = -1.
//--------------------------------------------------------------------------------

HRESULT ReqSatisfied(CLSID clsid, ULONG cAvailReq, CATID *AvailReq,
               ICatInformation *pICatInfo)
{
    IEnumGUID *pIEnumCatid;
    ULONG      got, i;
    CATID      catid;
    HRESULT    hr;

    if (cAvailReq == -1)
        return S_OK;

    hr = pICatInfo->EnumReqCategoriesOfClass(clsid, &pIEnumCatid);
    if (FAILED(hr)) {
        return hr;
    }
    for (;;) {
        hr = pIEnumCatid->Next(1, &catid, &got);
        if (FAILED(hr)) {
            hr = S_FALSE;
            break;
        }

        if (!got) {
            hr = S_OK;
            break;
        }
	/// check if the required categories are available
        for (i = 0; i < cAvailReq; i++)
            if (IsEqualGUID(catid, AvailReq[i]))
                break;
        if (i == cAvailReq) {
            hr = S_FALSE;
            break;
        }
    }
    pIEnumCatid->Release();
    return hr;
}

//--------------------------------------------------------------------------------
//    Implements:
//        Returns S_OK/S_FALSE depending on whether the clsid satisfies the required
//        condition for the clsid.
//    clsid:                Class ID of the class.
//    cImplemented:         Number of Implemented categories.
//    ImplementedList:      Implemented Categories.
//    calls the enumerator and sees whether there is any required class not present in
//    the available list. returns S_OK if cImplemented = -1.
//--------------------------------------------------------------------------------
// BUGBUG:: This should return error when the enumerator return errors.

HRESULT ImplSatisfied(CLSID clsid, ULONG cImplemented, CATID *ImplementedList,
               ICatInformation *pICatInfo)
{
    IEnumGUID *pIEnumCatid;
    ULONG      got, i;
    CATID      catid;
    HRESULT    hr;

    if (cImplemented == -1)
        return S_OK;

    hr = pICatInfo->EnumImplCategoriesOfClass(clsid, &pIEnumCatid);
    if (FAILED(hr)) {
        return hr;
    }
    for (;;) {
        hr = pIEnumCatid->Next(1, &catid, &got);
        if (FAILED(hr)) {
            hr = S_FALSE;
            break;
        }

        if (!got) {
            hr = S_FALSE;
            break;
        }

	// check if it implements any of the categories requested.
        for (i = 0; i < cImplemented; i++)
            if (IsEqualGUID(catid, ImplementedList[i]))
                break;
        if (i < cImplemented) {
            hr = S_OK;
            break;
        }
    }
    pIEnumCatid->Release();
    return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadm\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   DllMain for csadm.dll
//
//  Functions:  DllMain, DllGetClassObject
//
//  History:    05-May-97  DebiM   Created.
//
//----------------------------------------------------------------------------
#include "csadm.hxx"

#pragma hdrstop

//  Globals
HINSTANCE g_hInst = NULL;
ULONG  g_ulObjCount = 0;    // Number of objects alive in csadm.dll

CClassContainerCF  *g_pCF = NULL;

void Uninit()
//
// This routine is called at dll detach time
//
{
    //
    // release the Class Factory object
    //
    if (g_pCF)
        g_pCF->Release();
}

    


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    if (IsEqualCLSID(clsid, CLSID_DirectoryClassBase))
    {
        return g_pCF->QueryInterface(iid, ppv);
    }

    *ppv = NULL;

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // BugBug 
    //
    /*
    if (ulObjectCount > 0)
        hr = S_FALSE;
    else
        hr = S_OK;
    */
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    DWORD cbSize = _MAX_PATH;
    WCHAR wszUserName [_MAX_PATH];

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_hInst = hInst;
        g_pCF = new CClassContainerCF;
        break;


    case DLL_PROCESS_DETACH:
        Uninit();
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}

//+---------------------------------------------------------------
//
//  Function:   CsCreateClassStore
//
//  Synopsis:   Public entrypoint for creating an empty class store. factories
//
//----------------------------------------------------------------

STDAPI
CsCreateClassStore(LPOLESTR szParentPath, LPOLESTR szStoreName)
{
    LPOLESTR szPath;
    if (wcsncmp (szParentPath, L"ADCS:", 5) == 0)
        szPath = szParentPath + 5;
    else
        szPath = szParentPath;
    return CreateRepository(szPath, szStoreName);
}

//+---------------------------------------------------------------
//
//  Function:   CsGetClassStore
//
//  Synopsis:   Public entrypoint for binding to a class store and
//              get back IClassAdmin
//
//----------------------------------------------------------------

STDAPI
CsGetClassStore(LPOLESTR szPath, void **ppIClassAdmin)
{
    return g_pCF->CreateConnectedInstance(
                  szPath, 
                  ppIClassAdmin);
}

//+---------------------------------------------------------------
//
//  Function:   CsDeleteClassStore
//
//  Synopsis:   Public entrypoint for deleting a class store container from DS.
//
//----------------------------------------------------------------

STDAPI
CsDeleteClassStore(LPOLESTR szPath)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
// CsGetAppCategories 
//
// Returns the complete list of Category GUIDs and Category Descriptions 
// per the input Locale.
//
//
// This is used by Add/Remove programs to get the definitive list of 
// Application Categories.
//
// The caller needs to free the memory allocated using CoTaskMemFree().
//
// Arguments:
//  [in]
//        LCID : Locale
//  [out]
//        APPCATEGORYINFOLIST *pAppCategoryList:   
//               Returned list of GUIDs and Unicode descriptions
//
// Returns :
//      S_OK 
//
//--------------------------------------------------------------------
STDAPI
CsGetAppCategories (APPCATEGORYINFOLIST  *pAppCategoryList)
{
    HRESULT         hr;
    IClassAdmin   * pIClassAdmin = NULL;

    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    hr = pIClassAdmin->GetAppCategories (
		GetUserDefaultLCID(), 
		pAppCategoryList);

    pIClassAdmin->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadm\catreg.cxx ===
//
//  Author: ushaji
//  Date:   December/Jan 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for ICatRegister interfaces.                             
//
//      Refer Doc "Design for Support of File Types and Component Categories
//    in Class Store" ? (or may be Class Store Schema)
//
//----------------------------------------------------------------------------

#include "csadm.hxx"

//-------------------------------------------------------------
// RegisterCategories:
//        registering categories in the class store.
//        cCategories:        Number of Categories
//        rgCategoryInfo:        Size cCategories
//
// Returns as soon as one of them fails.
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CClassContainer::RegisterCategories(
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ])
{
    /* Registering a list of Category ID in the Class Store */

    HRESULT           hr;
    IADs             *pADs = NULL;
    IDispatch        *pUnknown = NULL;
    STRINGGUIDRDN     szCatid;
    ULONG             i, j, cdesc, posn;
    LPOLESTR         *pszDescExisting, *pszDesc;
    WCHAR            *localedescription = NULL;
                      // sizeof description + seperator length + locale in hex

    /* BUGBUG::Should check whether write permissions exist? */
    if (!IsValidReadPtrIn(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }

    if (!IsValidReadPtrIn(rgCategoryInfo, sizeof(rgCategoryInfo[0])*cCategories))
    {
        return E_INVALIDARG; // gd
    }

    if (!m_fOpen)
        return E_FAIL;

    for (i = 0; i < cCategories; i++)
    {
        localedescription = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR)*(128+16));
        if (!localedescription)
            return E_OUTOFMEMORY;

        RdnFromGUID(rgCategoryInfo[i].catid, szCatid);

        wsprintf(localedescription, L"%x %s %s", rgCategoryInfo[i].lcid, CATSEPERATOR,
                                                rgCategoryInfo[i].szDescription);

        hr = m_ADsCategoryContainer->GetObject(NULL, szCatid, (IDispatch **)&pADs);

        if (SUCCEEDED(hr))
        {
                hr = GetPropertyListAlloc (pADs, LOCALEDESCRIPTION, &cdesc, &pszDescExisting);
                RETURN_ON_FAILURE(hr);
                            // Existing list of descriptions

                pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(cdesc+1));
                if (!pszDesc)
                        return E_OUTOFMEMORY;
                for (j = 0; j < cdesc; j++)
                        pszDesc[j] = pszDescExisting[j];

                if (!(posn = FindDescription(pszDescExisting, cdesc, &(rgCategoryInfo[i].lcid), NULL, 0)))
                {
                            // if no description exists for the lcid.
                    pszDesc[cdesc] = localedescription;
                    cdesc++;
                }
                else
                {   // overwrite the old value
                    CoTaskMemFree(pszDesc[posn-1]);
                    pszDesc[posn-1] = localedescription;
                }
        }
        else
        {
                hr = m_ADsCategoryContainer->Create(
                        CLASS_CS_CATEGORY,
                        szCatid,
                        &pUnknown
                        );

                RETURN_ON_FAILURE(hr);
                pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
                if (!pszDesc)
                        return E_OUTOFMEMORY;
                cdesc = 1;
                pszDesc[0] = localedescription;

                hr = pUnknown->QueryInterface(IID_IADs, (void **)&pADs);
                RETURN_ON_FAILURE(hr);

                pUnknown->Release();
        }

//        StringFromGUID(rgCategoryInfo[i].catid, szCatid);
//        SetProperty(pADs, CATEGORYCATID, szCatid);
        hr = SetPropertyGuid(pADs, CATEGORYCATID, rgCategoryInfo[i].catid);
        RETURN_ON_FAILURE(hr);

        SetPropertyList(pADs, LOCALEDESCRIPTION, cdesc, pszDesc);
        for (j = 0; j < cdesc; j++)
                CoTaskMemFree(pszDesc[j]);
        CoTaskMemFree(pszDesc);
        RETURN_ON_FAILURE(hr);

        hr = StoreIt (pADs);
        RETURN_ON_FAILURE(hr);

        pADs->Release();
    }
    return hr;
} /* RegisterCategories */


//--------------------------------------------------------
// Unregistering categories from the class store
//        cCategories:        Number of Categories
//        rgcatid:            catids of the categories.
//
// Stops after any one of them returns a error.
// Doesn't remove the category ids from each of the class ids.

HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterCategories(
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    STRINGGUIDRDN   szCatid;
    ULONG           i;
    HRESULT         hr;


    if (!IsValidPtrOut(this, sizeof(*this))){
        return E_ACCESSDENIED;
    }
    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG;
    }
    // Checking whether the caller has permissions

    if (!m_fOpen)
        return E_FAIL;

    for (i = 0; i < cCategories; i++)
    {
        RdnFromGUID(rgcatid[i], szCatid);

        hr = m_ADsCategoryContainer->Delete(CLASS_CS_CATEGORY,
                                        szCatid);
    }
    return S_OK;
} /* UnRegisterCategories */

//------------------------------------------------------------------
// RegisterClassXXXCategories:
//        rclsid:            This category will be registered with this clsid.
//        cCategories:    The number of categories to be added.
//        rgcatid            The categories to be added (cCategories)
//        impl_or_req        The property to which this category will be added.
//                            "Implemented Categories" or "Required Categories"
//
//
// add all the categories given to the class store for this class.
// The previous entries will be lost and on error it would not be
// restored or made empty. A PRIVATE METHOD called by the 2 public methods.
//------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CClassContainer::RegisterClassXXXCategories(
           /* [in] */ REFCLSID rclsid,
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ],BSTR impl_or_req)
{
    HRESULT       hr;
    STRINGGUIDRDN szName;
    IADs         *pADs = NULL;
    ULONG         i, j, tobeadded;
    VARIANT       Var;
    GUID         *pCatids, *pOldCatids=NULL;
    IDispatch    *pUnknown = NULL;
    STRINGGUID    szGUID;

    if (!m_fOpen)
        return E_FAIL;

    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }

    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG; // gd
    }

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    // Get the ADs interface corresponding to the clsid that is mentioned.
    StringFromGUID(rclsid, szGUID);
    wsprintf(szName, L"CN=%s", szGUID);

    hr = m_ADsClassContainer->GetObject(NULL,
                szName,
                (IDispatch **)&pADs
                );

    // if it didn't exist create it.
    if (FAILED(hr)) {
        hr = m_ADsClassContainer->Create(
                            CLASS_CS_CLASS,
                            szName,
                            &pUnknown
                            );
    
        RETURN_ON_FAILURE(hr);
    
        hr = pUnknown->QueryInterface(
                                IID_IADs,
                                (void **)&pADs
                                );
    
        pUnknown->Release();
    }
    
    hr = SetProperty (pADs, CLASSCLSID, szGUID);
    RETURN_ON_FAILURE(hr);

    hr = GetPropertyListAllocGuid(pADs, impl_or_req, &tobeadded, &pOldCatids);
    RETURN_ON_FAILURE(hr);

    pCatids = (GUID *)CoTaskMemAlloc(sizeof(GUID)*(tobeadded+cCategories));
    if (!pCatids)
        return E_OUTOFMEMORY;

    for (i = 0; i < tobeadded; i++)
        pCatids[i] = pOldCatids[i];

    for (i=0; i < cCategories; ++i) {
        for (j = 0; j < tobeadded; j++)
        {
            if (memcmp(&rgcatid[i], &pCatids[j], sizeof(GUID)) == 0)
                break;
        }
        if (j < tobeadded)
            continue;
        // The ith element is already there in the array.
        // Make sure of this when the property name changes.

        pCatids[tobeadded] = rgcatid[i];
        tobeadded++;
    }

    VariantInit(&Var);
    hr = PackGuidArray2Variant(pCatids, tobeadded, &Var);
    RETURN_ON_FAILURE(hr);

    hr = pADs->Put(impl_or_req, Var);
    RETURN_ON_FAILURE(hr);

    VariantClear(&Var);

    // save the data modified
    hr = StoreIt(pADs);
    pADs->Release();

    CoTaskMemFree(pCatids);
    if (pOldCatids)
        CoTaskMemFree(pOldCatids);
    return hr;
} /* RegisterClassXXXCategories */


//---------------------------------------------------------------------
// UnRegisterClassXXXCategories
//        rclsid:            classid from which the categories have to be removed.
//        cCategories:    Number of Categories
//        rgcatid:        Categories
//        impl_or_req:    The property to which this has to be added.
//
// Presently gets all the categories from the class. parses through it
// removes the ones that match in rgcatid and reregister the category.
//---------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterClassXXXCategories(
           /* [in] */ REFCLSID rclsid,
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ],BSTR impl_or_req)
{
    HRESULT       hr;
    STRINGGUIDRDN szName;
    IADs         *pADs = NULL;
    ULONG         i, j;
    ULONG         cNewCatids, cOldCatids;
    VARIANT       Var;
    GUID         *pOldCatids=NULL, *pNewCatids;

   // BUGBUG:: Have to decide some way of removing clsids once all categories
   //          are unregistered.

   if (!m_fOpen)
        return E_FAIL;

   if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (cCategories == 0)
        return S_OK;

    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }

    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG; // gd
    }

    if (cCategories == 0)
        return S_OK;

    // Get all the catids corresp to this clsid.
    // Get the ADs interface corresponding to the clsid that is mentioned.
    RdnFromGUID(rclsid, szName);
    hr = m_ADsClassContainer->GetObject(NULL,
                szName,
                (IDispatch **)&pADs
                );

    RETURN_ON_FAILURE(hr);

    hr = GetPropertyListAllocGuid(pADs,
              impl_or_req,
              &cOldCatids,
              &pOldCatids);

    RETURN_ON_FAILURE(hr);

    // parse through this list and delete all the catids that is part of
    // the user supplied list.

    pNewCatids = (GUID *)CoTaskMemAlloc(sizeof(GUID)*cOldCatids);
    if (!pNewCatids)
        return E_OUTOFMEMORY;

    for (i = 0, cNewCatids = 0; i < cOldCatids; i++)
    {
        for (j = 0; j < cCategories; j++)
            if (memcmp(&pOldCatids[i], &rgcatid[j], sizeof(GUID)) == 0)
                break;
        if (j == cCategories)
            pNewCatids[cNewCatids++] = pOldCatids[i];
    }

    // reregister this.

    VariantInit(&Var);
    hr = PackGuidArray2Variant(pNewCatids, cNewCatids, &Var);
    RETURN_ON_FAILURE(hr);

    hr = pADs->Put(impl_or_req, Var);
    RETURN_ON_FAILURE(hr);

    VariantClear(&Var);

    // save the data modified
    hr = StoreIt(pADs);
    pADs->Release();

    CoTaskMemFree(pNewCatids);
    if (pOldCatids)
        CoTaskMemFree(pOldCatids);

    return hr;
} /* UnRegisterClassXXXCategories */



HRESULT STDMETHODCALLTYPE CClassContainer::RegisterClassImplCategories(
           /* [in] */ REFCLSID rclsid,
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                        IMPL_CATEGORIES);
} /* RegisterClassImplCategories */


HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterClassImplCategories(
          /* [in] */ REFCLSID rclsid,
          /* [in] */ ULONG cCategories,
          /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{

    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                        IMPL_CATEGORIES);

} /* UnRegisterClassImplCategories */




HRESULT STDMETHODCALLTYPE CClassContainer::RegisterClassReqCategories(
          /* [in] */ REFCLSID rclsid,
          /* [in] */ ULONG cCategories,
          /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                    REQ_CATEGORIES);

} /* RegisterClassReqCategories */




HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterClassReqCategories(
          /* [in] */ REFCLSID rclsid,
          /* [in] */ ULONG cCategories,
          /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                        REQ_CATEGORIES);

} /* UnRegisterClassReqCategories */



//--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadm\cclstor.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclstor.cxx
//
//  Contents:Class Factory and IUnknown methods for CClassContainer
//
//  Author:  DebiM
//
//-------------------------------------------------------------------------

#include "csadm.hxx"

//
// Constructor for Class Container Class factory
//
unsigned long gulcInstances = 0;


CClassContainerCF::CClassContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcInstances );
}

//
// Destructor
//
CClassContainerCF::~CClassContainerCF()
{
    InterlockedDecrement((long *) &gulcInstances );
}

HRESULT  __stdcall  CClassContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
        {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateInstance
//
//  Synopsis:
//              This is the default create instance on the class factory.
//
//  Arguments:  pUnkOuter - Should be NULL
//              riid      - IID of interface wanted
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
//
HRESULT  __stdcall  CClassContainerCF::CreateInstance(
                    IUnknown    *   pUnkOuter,
                    REFIID          riid,
                    void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
             pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateConnectedInstance
//
//  Synopsis:
//              This method is called by the ParseDisplayName implementation
//              on the ClassFactory object.
//              When a display name is used to bind to a Class Store
//              an IClassAdmin is returned after binding to the container.
//              This method fails if the bind fails.
//
//  Arguments:  pszPath  - DisplayName of Class Store Container
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

HRESULT  __stdcall  CClassContainerCF::CreateConnectedInstance(
                    LPOLESTR        pszPath,
                    void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE sc = S_OK;
    HRESULT  hr;

    if ((pIUnk = new CClassContainer(pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAdmin, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        else
            printf ("Connect to Store Failed. hr = 0x%x.\n", sc);

        pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::ParseDisplayName
//
//  Synopsis:   Parse a display name and create a pointer moniker.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

STDMETHODIMP CClassContainerCF::ParseDisplayName(
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr = S_OK;
    LPOLESTR pch = pszDisplayName;
    IClassAdmin * pOleClassStore = NULL;
    DWORD ClassStoreId;

    //Validate parameters.
    *pchEaten = 0;
    *ppmkOut = NULL;

    //Eat the prefix.
    while (*pch != '\0' && *pch != ':')
    {
        pch++;
    }

    if(':' == *pch)
    {
        pch++;
    }
    else
    {
        return MK_E_SYNTAX;
    }

    hr = CreateConnectedInstance(pch, (void **) &pOleClassStore);

    if(SUCCEEDED(hr))
    {
        hr = CreatePointerMoniker(pOleClassStore, ppmkOut);
        if(SUCCEEDED(hr))
        {
            *pchEaten = lstrlenW(pszDisplayName);
        }

        pOleClassStore->Release();
    }

    return hr;
}


HRESULT  __stdcall  CClassContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcInstances ); }
    else
    { InterlockedDecrement((long *) &gulcInstances ); }
    return(S_OK);
}

//
// IUnknown methods for CClassContainer
//
//

HRESULT  __stdcall  CClassContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_IClassAdmin, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_ICatRegister, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatRegister *)this;
    }
    else if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    else {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadm\csdsadm.cxx ===
//RETURN
//  Author: DebiM
//  Date:   January 97
//
//
//      Class Store Administration Implementation
//
//      This source file contains implementations for
//      IClassAdmin interface.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------

#include "csadm.hxx"
void GetCurrentUsn(CSUSN *pStoreUsn);

//----------------------------------------------------------
// Implementation for CClassContainer
//----------------------------------------------------------
//
CClassContainer::CClassContainer()

{
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_pADsClassStore = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_ADsCategoryContainer = NULL;
    
    m_uRefs = 1;
    StartQuery(&m_pIDBCreateCommand);
}


//
// CClassContainer implementation
//
CClassContainer::CClassContainer(LPOLESTR szStoreName,
                                 HRESULT  *phr)
                                 
{
    IADs        *pADs = NULL;
    LPOLESTR    pszName = NULL;
    DWORD       dwStoreVersion = 0;
    
    *phr = S_OK;
    
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_pADsClassStore = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_ADsCategoryContainer = NULL;
    
    //
    // For every interface pointer, we create a separate Query session
    //
    StartQuery(&m_pIDBCreateCommand);
    
    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);
    
    *phr = ADsGetObject(
        szStoreName,
        IID_IADsContainer,
        (void **)&m_ADsContainer
        );
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Check the Schema Version of this container
    //
    
    *phr = m_ADsContainer->QueryInterface (IID_IADs, (void **)&m_pADsClassStore);
    if (!SUCCEEDED(*phr))
        return;
    
    *phr = GetPropertyDW (m_pADsClassStore, STOREVERSION, &dwStoreVersion);
    
    if ((!SUCCEEDED(*phr)) ||
        (dwStoreVersion != SCHEMA_VERSION_NUMBER))
    {
        *phr = CS_E_INVALID_VERSION;
        return;
    }
    
    //
    // Bind to the class container Object
    // Cache the interface pointer
    //
    
    m_ADsClassContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        CLASSCONTAINERNAME,
        (IDispatch **)&pADs
        );
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsClassContainer
        );
    
    *phr = pADs->get_ADsPath(&pszName);
    wcscpy (m_szClassName, pszName);
    SysFreeString(pszName);
    
    pADs->Release();
    pADs = NULL;
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    m_ADsPackageContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        PACKAGECONTAINERNAME,
        (IDispatch **)&pADs);
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsPackageContainer
        );
    
    *phr = pADs->get_ADsPath(&pszName);
    wcscpy (m_szPackageName, pszName);
    SysFreeString(pszName);
    pADs->Release();
    pADs = NULL;
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Bind to the category container Object
    // Cache the interface pointer
    //
    m_ADsCategoryContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        CATEGORYCONTAINERNAME,
        (IDispatch **)&pADs);
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsCategoryContainer
        );
    
    pADs->Release();
    pADs = NULL;
    
    m_fOpen = TRUE;
    m_uRefs = 1;
    return;
}


CClassContainer::~CClassContainer(void)
{
    UINT i;
    
    EndQuery(m_pIDBCreateCommand);
    m_pIDBCreateCommand = NULL;
    
    
    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }
    
    if (m_ADsClassContainer)
    {
        m_ADsClassContainer->Release();
        m_ADsClassContainer = NULL;
    }
    
    if (m_ADsPackageContainer)
    {
        m_ADsPackageContainer->Release();
        m_ADsPackageContainer = NULL;
    }
    
    if (m_ADsCategoryContainer)
    {
        m_ADsCategoryContainer->Release();
        m_ADsCategoryContainer = NULL;
    }
    
    if (m_ADsContainer)
    {
        m_ADsContainer->Release();
        m_ADsContainer = NULL;
    }
    
    if (m_pADsClassStore)
    {
        m_pADsClassStore->Release();
        m_pADsClassStore = NULL;
    }
    
}


//
// Removing a class from the database
//

HRESULT CClassContainer::DeleteClass (LPOLESTR szClsid)
{
    
    WCHAR       szName[_MAX_PATH];
    HRESULT         hr = S_OK;
    IADs       *pADs = NULL;
    DWORD       refcount = 0;
    
    if (!m_fOpen)
        return E_FAIL;
    
    wsprintf(szName, L"CN=%s", szClsid);
    hr = m_ADsClassContainer->GetObject(NULL, szName, (IDispatch **)&pADs);
    
    if (SUCCEEDED(hr))
        hr = GetPropertyDW(pADs, CLASSREFCOUNTER, &refcount);
    
    if (refcount <= 1)
        hr = m_ADsClassContainer->Delete(CLASS_CS_CLASS, szName);
    else {
        refcount--;
        hr = SetPropertyDW(pADs, CLASSREFCOUNTER, refcount);
        
        if (SUCCEEDED(hr))
            hr = StoreIt(pADs);
    }
    
    if (pADs)
        pADs->Release();
    return hr;
}


extern LPOLESTR szPackageInfoColumns;

HRESULT CClassContainer::EnumPackages(
                                      LPOLESTR         pszFileExt,
                                      GUID             *pCategory,
                                      DWORD            dwAppFlags,
                                      DWORD            *pdwLocale,
                                      CSPLATFORM       *pPlatform,
                                      IEnumPackage     **ppIEnumPackage
                                      )
{
    HRESULT                 hr = S_OK;
    CEnumPackage           *pEnum = NULL;
    WCHAR           szCommand[1000], szQry[1000];
    
    if (pszFileExt && IsBadStringPtr(pszFileExt, _MAX_PATH))
        return E_INVALIDARG;
    
    if (pCategory && !IsValidReadPtrIn(pCategory, sizeof(GUID)))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(ppIEnumPackage, sizeof(IEnumPackage *)))
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    pEnum = new CEnumPackage;
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a CommandText
    //
    
    wsprintf(szCommand, L"<%s>;(& (objectClass=packageRegistration) ", m_szPackageName);
    
    if (pszFileExt)
    {
        wsprintf(szQry, L"(%s=%s*) ", PKGFILEEXTNLIST, pszFileExt);
        wcscat(szCommand, szQry);
    }
    
    if (pCategory) 
    {
        STRINGGUID szCat;
        StringFromGUID (*pCategory, szCat);
        wsprintf(szQry, L"(%s=%s) ", PKGCATEGORYLIST, szCat);
        wcscat(szCommand, szQry);
    }
    
    wcscat(szCommand, L");");
    
    wsprintf(szQry, L" %s", szPackageInfoColumns);
    wcscat(szCommand, szQry);
    
    hr = pEnum->Initialize(szCommand, dwAppFlags, pdwLocale, pPlatform);
    
    if (FAILED(hr)) {
        delete pEnum;
        return hr;
    }
    
    hr = pEnum->QueryInterface(IID_IEnumPackage, (void**)ppIEnumPackage);
    
    return hr;
}

// GetPackageDetails
//  pszPackageName  :   name of the package to be got.
//  pInstallInfo    :   InstallInfo to be filled in. ignored if NULL.
//  pPlatformInfo   :   PlatformInfo to be filled in. ignored if NULL.
// both can be sent in as NULL to check whether package exists or not.


HRESULT CClassContainer::GetPackageDetails (
                          LPOLESTR        pszPackageName,
                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
    
    hr = GetPackageDetail (pPackageADs, pPackageDetail);
    return hr;
}


HRESULT CClassContainer::ChangePackageProperties(
                LPOLESTR       pszPackageName,
                LPOLESTR       pszNewName,
                DWORD         *pdwFlags,
                LPOLESTR       pszUrl,
                LPOLESTR       pszScriptPath,
				DWORD         *pInstallUiLevel
                )
{
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    WCHAR       szNewRdn [_MAX_PATH];
    LPOLESTR    pszPackageDN;
    CSUSN       Usn;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);

    if (pszNewName)
    {
        //
        // rename package
        //
    
        if (IsBadStringPtr(pszNewName, _MAX_PATH))
            return E_INVALIDARG;
    
        //
        // Check to see if any other change is requested.
        //

        if (pszScriptPath   ||
            pszUrl          ||
            pdwFlags)
            return E_INVALIDARG;

        BuildADsPathFromParent (m_szPackageName, szRdn, &pszPackageDN);
        wcscpy (szNewRdn, L"CN=");
        wcscat (szNewRdn, pszNewName);
        hr = m_ADsPackageContainer->MoveHere(pszPackageDN, szNewRdn, (IDispatch **)&pPackageADs);
        FreeADsMem(pszPackageDN);
        
        if (SUCCEEDED(hr))
            pPackageADs->Release();
        else
            CSDbgPrint(("Error in MoveHere. hr=0x%x\n", hr));
        return hr;
    }
    
    //
    // No rename.
    // Just change some properties.
    //
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
    //
    // Update the TimeStamp
    //
    GetCurrentUsn(&Usn);
    hr = UsnUpd(pPackageADs, PKGUSN, &Usn);
    ERROR_ON_FAILURE(hr);
    
    //
    // Change Package Flags
    //
    if (pdwFlags)
    {
        hr = SetPropertyDW (pPackageADs, PACKAGEFLAGS, *pdwFlags);
        ERROR_ON_FAILURE(hr);
    }

    //
    // Change Package Script
    //
    if (pszScriptPath) 
    {
        hr = SetProperty(pPackageADs, SCRIPTPATH, pszScriptPath);
        ERROR_ON_FAILURE(hr);
    }
        
    //
    // Change Package Help URL
    //
    if (pszUrl) 
    {
        hr = SetProperty(pPackageADs, HELPURL, pszUrl);
        ERROR_ON_FAILURE(hr);
    }

    //
    // Change UI Level
    //
    if (pInstallUiLevel) 
    {
        hr = SetPropertyDW (pPackageADs, UILEVEL, *pInstallUiLevel);
        ERROR_ON_FAILURE(hr);
    }

    hr = StoreIt(pPackageADs);    
    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
        
}


HRESULT CClassContainer::ChangePackageCategories(
                LPOLESTR       pszPackageName,
                UINT           cCategories,
                GUID          *rpCategory
                )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    LPOLESTR    *pszGuid = NULL;
    CSUSN       Usn;
    UINT        count;
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    if ((!cCategories) ||
        (!rpCategory) ||
        (!IsValidReadPtrIn(rpCategory, sizeof(GUID) * cCategories)))    
              return E_INVALIDARG;

    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
    
    // fill in the categories
    pszGuid = (LPOLESTR *)CoTaskMemAlloc(cCategories * sizeof(LPOLESTR));
    if (!pszGuid) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }
        
    
    for (count = 0; (count < cCategories); count++) 
    {
        pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
        {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        StringFromGUID(rpCategory[count], pszGuid[count]);
    }
        
    hr = SetPropertyList(pPackageADs, PKGCATEGORYLIST, cCategories,
            pszGuid);
    ERROR_ON_FAILURE(hr);
        
    for (count = 0; (count < cCategories); count++)
        CoTaskMemFree(pszGuid[count]);
        
    CoTaskMemFree(pszGuid);
    hr = StoreIt(pPackageADs);    
    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
}



HRESULT CClassContainer::SetPriorityByFileExt(
                                              LPOLESTR pszPackageName,
                                              LPOLESTR pszFileExt,
                                              UINT     Priority
                                              )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    LPOLESTR    *prgFileExt = NULL;
    ULONG       cShellFileExt;
    UINT        i;
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
        
    hr = GetPropertyListAlloc (pPackageADs, PKGFILEEXTNLIST,
            &cShellFileExt,
            &prgFileExt);

    for (i=0; i < cShellFileExt; ++i)
    {
        if (wcsncmp(prgFileExt[i], pszFileExt, wcslen(pszFileExt)) == 0)
        {
            wsprintf(prgFileExt[i], L"%s:%2d", 
                pszFileExt, 
                Priority);
        }
    }
    
    if (i == cShellFileExt)
    {
        ERROR_ON_FAILURE(CS_E_PACKAGE_NOTFOUND);
    }

    hr = SetPropertyList(pPackageADs, PKGFILEEXTNLIST, cShellFileExt, prgFileExt);

    hr = StoreIt(pPackageADs);    
    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
}



extern LPOLESTR szAppCategoryColumns;

HRESULT CClassContainer::GetAppCategories (
                                           LCID              Locale,
                                           APPCATEGORYINFOLIST  *pAppCategoryList
                                           )
{
    HRESULT      hr = S_OK;
    WCHAR        szCommand[1000], szQry[1000];
    WCHAR        szRootPath[_MAX_PATH],
        szAppCategoryContainer[_MAX_PATH];
    IRowset            * pIRow = NULL;
    HACCESSOR            HAcc;
    IAccessor          * pIAccessor = NULL;
    IDBCreateCommand   * pIDBCreateCommand = NULL;
    LPOLESTR      ** ppszDesc = NULL;
    DWORD        cgot = 0;
    
    if (!IsValidPtrOut(pAppCategoryList, sizeof(APPCATEGORYINFOLIST)))
        return E_INVALIDARG;
    
    hr = GetRootPath(szRootPath);
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX,
        APPCATEGORYCONTAINERNAME, szRootPath+wcslen(LDAPPREFIX));
    
    wsprintf(szCommand, L"<%s>; (objectClass=categoryRegistration); %s", szAppCategoryContainer,
        szAppCategoryColumns);
    
    hr = StartQuery(&(pIDBCreateCommand));
    RETURN_ON_FAILURE(hr);
    
    hr = ExecuteQuery (pIDBCreateCommand,
        szCommand,
        APPCATEGORY_COLUMN_COUNT,
        NULL,
        &HAcc,
        &pIAccessor,
        &pIRow
        );
    
    RETURN_ON_FAILURE(hr);
    
    pAppCategoryList->cCategory = 500;
    // upper limit presently.
    
    hr = FetchCategory(pIRow,
        HAcc,
        (pAppCategoryList->cCategory),
        &cgot,
        &(pAppCategoryList->pCategoryInfo),
        Locale);
    
    pAppCategoryList->cCategory = cgot;
    
    CloseQuery(pIAccessor,
        HAcc,
        pIRow);
    
    EndQuery(pIDBCreateCommand);
    
    return hr;
}



HRESULT CClassContainer::RegisterAppCategory (
                 APPCATEGORYINFO    *pAppCategory           
                 )
{
    WCHAR       szRootPath[_MAX_PATH], *localedescription = NULL,
                szAppCategoryContainer[_MAX_PATH], szRDN[_MAX_PATH];
    HRESULT     hr = S_OK;
    IADsContainer      *pADsContainer = NULL;
    IADs               *pADs = NULL;
    IDispatch          *pUnknown = NULL;
    ULONG               i, j, cdesc, posn;
    LPOLESTR           *pszDescExisting = NULL, *pszDesc = NULL;


    if (!IsValidReadPtrIn(pAppCategory, sizeof(APPCATEGORYINFO)))
    return E_INVALIDARG;

    if (IsBadStringPtr(pAppCategory->pszDescription, _MAX_PATH))
    return E_INVALIDARG;

    if (IsNullGuid(pAppCategory->AppCategoryId))
        return E_INVALIDARG;

    hr = GetRootPath(szRootPath);

    // Bind to a AppCategory container
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX,
             APPCATEGORYCONTAINERNAME, szRootPath+wcslen(LDAPPREFIX));

    hr = ADsGetObject(
                szAppCategoryContainer,
                IID_IADsContainer,
                (void **)&pADsContainer
                );
    RETURN_ON_FAILURE(hr);

    RdnFromGUID(pAppCategory->AppCategoryId, szRDN);

    localedescription = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(128+16));

    wsprintf(localedescription, L"%x %s %s", pAppCategory->Locale, CATSEPERATOR,
                        pAppCategory->pszDescription);

    hr = pADsContainer->GetObject(NULL, szRDN, (IDispatch **)&pADs);

    if (SUCCEEDED(hr))
    {
       hr = GetPropertyListAlloc (pADs, LOCALEDESCRIPTION, &cdesc, &pszDescExisting);
       ERROR_ON_FAILURE(hr);
       // Existing list of descriptions

       pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(cdesc+1));
       if ((cdesc) && (!pszDesc)) {
      hr = E_OUTOFMEMORY;
      ERROR_ON_FAILURE(hr);
       }

       for (j = 0; j < cdesc; j++)
      pszDesc[j] = pszDescExisting[j];

       if (!(posn = FindDescription(pszDescExisting, cdesc, &(pAppCategory->Locale), NULL, 0)))
       {
      // if no description exists for the lcid.
      pszDesc[cdesc] = localedescription;
      cdesc++;
       }
       else
       {   // overwrite the old value
      CoTaskMemFree(pszDesc[posn-1]);
      pszDesc[posn-1] = localedescription;
       }
    }
    else
    {
       hr = pADsContainer->Create(
            CLASS_CS_CATEGORY,
            szRDN,
            &pUnknown
            );
       ERROR_ON_FAILURE(hr);

       pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
       if (!pszDesc) {
      hr = E_OUTOFMEMORY;
      ERROR_ON_FAILURE(hr);
       }

       cdesc = 1;
       pszDesc[0] = localedescription;

       hr = pUnknown->QueryInterface(IID_IADs, (void **)&pADs);
       RETURN_ON_FAILURE(hr);

       pUnknown->Release();
    }

    hr = SetPropertyGuid(pADs, CATEGORYCATID, pAppCategory->AppCategoryId);
    ERROR_ON_FAILURE(hr);

    hr = SetPropertyList(pADs, LOCALEDESCRIPTION, cdesc, pszDesc);
    for (j = 0; j < cdesc; j++)
        CoTaskMemFree(pszDesc[j]);
    CoTaskMemFree(pszDesc);
    ERROR_ON_FAILURE(hr);

    hr = StoreIt(pADs);
    ERROR_ON_FAILURE(hr);

Error_Cleanup:

    if (pADs)
       pADs->Release();

    if (pADsContainer)
       pADsContainer->Release();

    // Add this category.
    return hr;
}


HRESULT CClassContainer::UnregisterAppCategory (
                 GUID         *pAppCategoryId
                 )
{
   WCHAR        szRootPath[_MAX_PATH], szRDN[_MAX_PATH],
            szAppCategoryContainer[_MAX_PATH];
   HRESULT      hr = S_OK;
   IADsContainer       *pADsContainer = NULL;

   if (!IsValidReadPtrIn(pAppCategoryId, sizeof(GUID)))
       return E_INVALIDARG;

   hr = GetRootPath(szRootPath);
   // Bind to a AppCategory container
   wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX,
            APPCATEGORYCONTAINERNAME, szRootPath+wcslen(LDAPPREFIX));

   hr = ADsGetObject(
           szAppCategoryContainer,
           IID_IADsContainer,
           (void **)&pADsContainer
           );

   RETURN_ON_FAILURE(hr);

   RdnFromGUID(*pAppCategoryId, szRDN);

   hr = pADsContainer->Delete(CLASS_CS_CATEGORY, szRDN);
   pADsContainer->Release();

   // Delete this category

   return hr;
}


//+

HRESULT CClassContainer::RemovePackage (LPOLESTR    pszPackageName)
//
// Remove a Package and the associated Classes from class store
//
{
    HRESULT     hr = S_OK;
    IADs       *pADs = NULL;
    DWORD       cClasses = 0, count = 0;
    WCHAR       szRdn [_MAX_PATH];
    LPOLESTR   *szClasses;
    
    if (IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;
    
    if ((pszPackageName == NULL) ||
        (*(pszPackageName) == NULL))
        return E_INVALIDARG;
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    if (!m_fOpen)
        return E_FAIL;
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pADs);
    RETURN_ON_FAILURE(hr);
    
    hr = GetPropertyListAlloc(pADs, PKGCLSIDLIST, &cClasses, &szClasses);
    
    for (count = 0; count < cClasses; count++)
        hr = DeleteClass(szClasses[count]);
    // ignore errors
    
    for (count = 0; count < cClasses; count++)
        CoTaskMemFree(szClasses[count]);
    CoTaskMemFree(szClasses);
    
    pADs->Release();
    
    hr = m_ADsPackageContainer->Delete(CLASS_CS_PACKAGE, szRdn);
    return hr;
}

//+

HRESULT CClassContainer::NewClass (CLASSDETAIL *pClassDetail)

//
// Add a new class to the database
//
{
    HRESULT         hr = S_OK;
    IADs          * pADs = NULL;
    IDispatch     * pUnknown = NULL;
    STRINGGUID      szGUID;
    WCHAR           szRDN [_MAX_PATH];
    
    if (!m_fOpen)
        return E_FAIL;
    
    //
    // Cant be a NULL guid
    //
    if (IsNullGuid(pClassDetail->Clsid))
        return E_INVALIDARG;
    
    StringFromGUID(pClassDetail->Clsid, szGUID);
    
    //
    // Create the RDN for the Class Object
    //
    
    // BUGBUG:: attaching package name creates problems.
    wsprintf(szRDN, L"CN=%s", szGUID);
    
    hr = m_ADsClassContainer->Create(
        CLASS_CS_CLASS,
        szRDN,
        &pUnknown
        );
    
    RETURN_ON_FAILURE(hr);
    
    hr = pUnknown->QueryInterface(
        IID_IADs,
        (void **)&pADs
        );
    
    pUnknown->Release();
    
    hr = SetProperty (pADs, CLASSCLSID, szGUID);
    ERROR_ON_FAILURE(hr);
    
    if (pClassDetail->cProgId)
    {
        hr = SetPropertyList(pADs, PROGIDLIST, pClassDetail->cProgId,
            pClassDetail->prgProgId);
        
        ERROR_ON_FAILURE(hr);
    }
    
    if (!IsNullGuid(pClassDetail->TreatAs))
    {
        StringFromGUID(pClassDetail->TreatAs, szGUID);
        hr = SetProperty (pADs, TREATASCLSID, szGUID);
        ERROR_ON_FAILURE(hr);
    }
    
    hr = SetPropertyDW(pADs, CLASSREFCOUNTER, 1);
    ERROR_ON_FAILURE(hr);
    
    hr = StoreIt (pADs);
    
    // this does not return an error for an alreay existing entry.
    
    if (hr == E_ADS_LDAP_ALREADY_EXISTS)
    {
        
        DWORD refcount = 0;
        
        pADs->Release(); // release the interface pointer already got.
        
        hr = m_ADsClassContainer->GetObject(NULL, // CLASS_CS_CLASS
            szRDN,
            (IDispatch **)&pADs);
        RETURN_ON_FAILURE(hr);
        
       if (pClassDetail->cProgId)
        {
            hr = SetPropertyListMerge(pADs, PROGIDLIST, pClassDetail->cProgId,
                pClassDetail->prgProgId);
            ERROR_ON_FAILURE(hr);
        }
        
        // increment reference counter.
        hr = GetPropertyDW(pADs, CLASSREFCOUNTER, &refcount);
        ERROR_ON_FAILURE(hr);
        
        refcount++;
        
        hr = SetPropertyDW(pADs, CLASSREFCOUNTER, refcount);
        ERROR_ON_FAILURE(hr);
        
        // No merging of the treatas.
        
        hr = StoreIt(pADs);
    }
    
Error_Cleanup:
    
    pADs->Release();
    return hr;
    
}

#define SCRIPT_IN_DIRECTORY    256


HRESULT CClassContainer::AddPackage(LPOLESTR       pszPackageName,
                                    PACKAGEDETAIL *pPackageDetail)
{
    HRESULT     hr;
    IADs       *pPackageADs = NULL;
    IDispatch  *pUnknown = NULL;
    WCHAR       szRDN [_MAX_PATH];
    LPOLESTR   *pszGuid, *pszProgId;
    DWORD      *pdwArch=NULL, count = 0, cPackProgId = 0;
    CSUSN      Usn;
    
    if (!pszPackageName)
        return E_INVALIDARG;
    
    if (!pPackageDetail)
        return E_INVALIDARG;
    
   if (!IsValidReadPtrIn(pPackageDetail, sizeof(PACKAGEDETAIL)))
       return E_INVALIDARG;

   LPWSTR pName = pszPackageName;
   while (*pName)
   {
        if ((*pName == L':') ||
            (*pName == L',') ||
            (*pName == L';') ||
            (*pName == L'/') ||
            (*pName == L'<') ||
            (*pName == L'>') ||
            (*pName == L'\\'))
            return E_INVALIDARG;
        ++pName;
   }

   // Validating ActivationInfo

   if (pPackageDetail->pActInfo)
   {
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo, sizeof(ACTIVATIONINFO)))
           return E_INVALIDARG;

       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->pClasses,
           sizeof(CLASSDETAIL) * (pPackageDetail->pActInfo->cClasses)))
           return E_INVALIDARG;
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgShellFileExt,
           sizeof(LPOLESTR) * (pPackageDetail->pActInfo->cShellFileExt)))
           return E_INVALIDARG;
       
       for (count = 0; count < (pPackageDetail->pActInfo->cShellFileExt); count++)
       {
           if (!pPackageDetail->pActInfo->prgShellFileExt[count])
               return E_INVALIDARG;
       }  
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgPriority,
           sizeof(UINT) * (pPackageDetail->pActInfo->cShellFileExt)))
           return E_INVALIDARG;
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgInterfaceId,
           sizeof(IID) * (pPackageDetail->pActInfo->cInterfaces)))
           return E_INVALIDARG;
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgTlbId,
           sizeof(GUID) * (pPackageDetail->pActInfo->cTypeLib)))
           return E_INVALIDARG;
   }

   // Validating InstallInfo

   if ((pPackageDetail->pInstallInfo == NULL) || 
       (!IsValidReadPtrIn(pPackageDetail->pInstallInfo, sizeof(INSTALLINFO)))
      )
       return E_INVALIDARG;

   // Validating PlatformInfo

   if ((pPackageDetail->pPlatformInfo == NULL) || 
       (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo, sizeof(PLATFORMINFO)))
      )
       return E_INVALIDARG;

   if (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo->prgPlatform,
            sizeof(CSPLATFORM) * (pPackageDetail->pPlatformInfo->cPlatforms)))
       return E_INVALIDARG;

   if ((pPackageDetail->pPlatformInfo->cLocales == 0) ||
       (pPackageDetail->pPlatformInfo->prgPlatform == 0))
       return E_INVALIDARG;

   if (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo->prgLocale,
            sizeof(LCID) * (pPackageDetail->pPlatformInfo->cLocales)))
       return E_INVALIDARG;

   // Validating other fields in PackageDetail structure
   
   if ((pPackageDetail->pszSourceList == NULL) ||
       (!IsValidReadPtrIn(pPackageDetail->pszSourceList,
             sizeof(LPOLESTR) * (pPackageDetail->cSources)))
      )
      return E_INVALIDARG;

   for (count = 0; count < (pPackageDetail->cSources); count++)
       if (!pPackageDetail->pszSourceList[count])
       return E_INVALIDARG;


   if (pPackageDetail->rpCategory)
   {
       if (!IsValidReadPtrIn(pPackageDetail->rpCategory,
              sizeof(GUID) * (pPackageDetail->cCategories)))     
              return E_INVALIDARG;
   }

    //
    // Now we create the package
    //    
    
    wcscpy (szRDN, L"CN=");
    wcscat (szRDN, pszPackageName);
    
    pUnknown = NULL;
    hr = m_ADsPackageContainer->Create(
        CLASS_CS_PACKAGE,
        szRDN,
        &pUnknown
        );
    
    RETURN_ON_FAILURE(hr);
    
    hr = pUnknown->QueryInterface(
        IID_IADs,
        (void **)&pPackageADs
        );
    
    pUnknown->Release();
    
    // fill in the activation info
    
    if (pPackageDetail->pActInfo)
    {
        
        if ((pPackageDetail->pActInfo)->cClasses) 
        {
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cClasses)*sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*STRINGGUIDLEN);
                StringFromGUID(pPackageDetail->pActInfo->pClasses[count].Clsid, pszGuid[count]);
                cPackProgId += pPackageDetail->pActInfo->pClasses[count].cProgId;
            }
            
            hr = SetPropertyList(pPackageADs, PKGCLSIDLIST, (pPackageDetail->pActInfo)->cClasses, pszGuid);
            ERROR_ON_FAILURE(hr);
            
            for (count = 0; (count < pPackageDetail->pActInfo->cClasses); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
        }
        
        // collecting all the progids from the various clsids.
        if (cPackProgId)
        {
            pszProgId = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*cPackProgId);
            if (!pszProgId) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0, cPackProgId = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
            {
                DWORD cClassProgId = 0;
                for (cClassProgId = 0; cClassProgId < pPackageDetail->pActInfo->pClasses[count].cProgId;
                cClassProgId++) 
                {
                    pszProgId[cPackProgId++] =
                        pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId];
                }
            }
            
            hr = SetPropertyList(pPackageADs, PROGIDLIST, cPackProgId, pszProgId);
            
            CoTaskMemFree(pszProgId);
        }
        
        ERROR_ON_FAILURE(hr);
        
        if (pPackageDetail->pActInfo->cShellFileExt) 
        {
            //
            // Store a tuple in the format <file ext>:<priority>
            //
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cShellFileExt) * sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            for (count = 0; count < pPackageDetail->pActInfo->cShellFileExt; count++)
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) * 
                    (wcslen(pPackageDetail->pActInfo->prgShellFileExt[count])+1+2+1));
                // format is fileext+:+nn+NULL where nn = 2 digit priority
                wsprintf(pszGuid[count], L"%s:%2d", 
                    pPackageDetail->pActInfo->prgShellFileExt[count], 
                    pPackageDetail->pActInfo->prgPriority[count]);
            }
            hr = SetPropertyList(pPackageADs, PKGFILEEXTNLIST, pPackageDetail->pActInfo->cShellFileExt, pszGuid);
            for (count = 0; (count < pPackageDetail->pActInfo->cShellFileExt); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
            
            //
            // Now IDS Workaround
            // BUGBUG. Remove this when the DS bug is fixed. 130491 in NTDEV
            //
            hr = SetPropertyList(pPackageADs, 
                QRYFILEEXT, 
                pPackageDetail->pActInfo->cShellFileExt, 
                pPackageDetail->pActInfo->prgShellFileExt);
            
        }
        
        ERROR_ON_FAILURE(hr);
        
        if (pPackageDetail->pActInfo->cInterfaces) 
        {
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cInterfaces)*sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++) 
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
                if (!pszGuid[count]) 
                {
                    hr = E_OUTOFMEMORY;
                    ERROR_ON_FAILURE(hr);
                }
                
                StringFromGUID((pPackageDetail->pActInfo->prgInterfaceId)[count], pszGuid[count]);
            }
            
            hr = SetPropertyList(pPackageADs, PKGIIDLIST, pPackageDetail->pActInfo->cInterfaces,
                pszGuid);
            ERROR_ON_FAILURE(hr);
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
        }
        
        
        if (pPackageDetail->pActInfo->cTypeLib) 
        {
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cTypeLib)*sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0; (count < (pPackageDetail->pActInfo)->cTypeLib); count++) 
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
                if (!pszGuid[count]) 
                {
                    hr = E_OUTOFMEMORY;
                    ERROR_ON_FAILURE(hr);
                }
                
                StringFromGUID((pPackageDetail->pActInfo->prgTlbId)[count], pszGuid[count]);
            }
            
            hr = SetPropertyList(pPackageADs, PKGTLBIDLIST, pPackageDetail->pActInfo->cTypeLib,
                pszGuid);
            ERROR_ON_FAILURE(hr);
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cTypeLib)); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
        }
    }
    // fill in the platforminfo
    
    // BUGBUG::***os version
    if ((pPackageDetail->pPlatformInfo)->cPlatforms) 
    {
        pdwArch = (DWORD *)CoTaskMemAlloc(sizeof(DWORD)*
            ((pPackageDetail->pPlatformInfo)->cPlatforms));
        
        for (count = 0; (count < (pPackageDetail->pPlatformInfo)->cPlatforms); count++)
            UnpackPlatform (pdwArch+count, ((pPackageDetail->pPlatformInfo)->prgPlatform)+count);
        
        hr = SetPropertyListDW (pPackageADs, ARCHLIST, (pPackageDetail->pPlatformInfo)->cPlatforms, pdwArch);
        ERROR_ON_FAILURE(hr);
        
        CoTaskMemFree(pdwArch);
    }
    
    if ((pPackageDetail->pPlatformInfo)->cLocales) 
    {
        hr = SetPropertyListDW (pPackageADs, 
            LOCALEID, (pPackageDetail->pPlatformInfo)->cLocales, 
            (pPackageDetail->pPlatformInfo)->prgLocale);
        ERROR_ON_FAILURE(hr);
    }
    
    // fill in the installinfo
    
    hr = SetProperty(pPackageADs, PACKAGENAME, pszPackageName);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, PACKAGETYPE, (DWORD)pPackageDetail->pInstallInfo->PathType);
    ERROR_ON_FAILURE(hr);
    
    if (pPackageDetail->pInstallInfo->pszScriptPath) 
    {
        hr = SetProperty(pPackageADs, SCRIPTPATH, pPackageDetail->pInstallInfo->pszScriptPath);
        ERROR_ON_FAILURE(hr);
    }
    
    if (pPackageDetail->pInstallInfo->pszSetupCommand) 
    {
        hr = SetProperty(pPackageADs, SETUPCOMMAND, pPackageDetail->pInstallInfo->pszSetupCommand);
        ERROR_ON_FAILURE(hr);
    }
    
    if (pPackageDetail->pInstallInfo->pszUrl) 
    {
        hr = SetProperty(pPackageADs, HELPURL, pPackageDetail->pInstallInfo->pszUrl);
        ERROR_ON_FAILURE(hr);
    }
    
    GetCurrentUsn(&Usn);
    hr = UsnUpd(pPackageADs, PKGUSN, &Usn);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, PACKAGEFLAGS, pPackageDetail->pInstallInfo->dwActFlags);
    ERROR_ON_FAILURE(hr);
        
    hr = SetPropertyDW (pPackageADs, CLASSCTX, pPackageDetail->pInstallInfo->dwComClassContext);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, VERSIONHI, pPackageDetail->pInstallInfo->dwVersionHi);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, VERSIONLO, pPackageDetail->pInstallInfo->dwVersionLo);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, SCRIPTSIZE, pPackageDetail->pInstallInfo->cScriptLen);
    ERROR_ON_FAILURE(hr);

    hr = SetPropertyDW (pPackageADs, UILEVEL, (DWORD)pPackageDetail->pInstallInfo->InstallUiLevel);
    ERROR_ON_FAILURE(hr);

   
    if (pPackageDetail->pInstallInfo->cUpgrades) 
    {
        LPOLESTR *rpszUpgrades;
        rpszUpgrades = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*pPackageDetail->pInstallInfo->cUpgrades);
        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++) 
        {
            UINT l = wcslen(pPackageDetail->pInstallInfo->prgUpgradeScript[count]);
            rpszUpgrades[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) *(4+l));
            wsprintf(rpszUpgrades[count], L"%S:%1d",
                pPackageDetail->pInstallInfo->prgUpgradeScript[count],
                pPackageDetail->pInstallInfo->prgUpgradeFlag[count]);
        }

        hr = SetPropertyList(pPackageADs, UPGRADESCRIPTNAMES, pPackageDetail->pInstallInfo->cUpgrades,
            rpszUpgrades);

        ERROR_ON_FAILURE(hr);
        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++)
            CoTaskMemFree(rpszUpgrades[count]);
        CoTaskMemFree(rpszUpgrades);
    }
    
    
    // fill in the sources
    if (pPackageDetail->cSources) 
    {
        hr = SetPropertyList(pPackageADs, MSIFILELIST, pPackageDetail->cSources,
            pPackageDetail->pszSourceList);
        ERROR_ON_FAILURE(hr);
    }

    // fill in the categories
    if (pPackageDetail->cCategories) 
    {
        pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->cCategories) * sizeof(LPOLESTR));
        if (!pszGuid) 
        {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        
        for (count = 0; (count < pPackageDetail->cCategories); count++) 
        {
            pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
            if (!pszGuid[count]) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            StringFromGUID((pPackageDetail->rpCategory)[count], pszGuid[count]);
        }
        
        hr = SetPropertyList(pPackageADs, PKGCATEGORYLIST, pPackageDetail->cCategories,
            pszGuid);
        ERROR_ON_FAILURE(hr);
        
        for (count = 0; (count < pPackageDetail->cCategories); count++)
            CoTaskMemFree(pszGuid[count]);
        CoTaskMemFree(pszGuid);
    }
    
    //
    // Store the script in the directory
    //
    if ((pPackageDetail->pInstallInfo->dwActFlags & SCRIPT_IN_DIRECTORY) && 
        (pPackageDetail->pInstallInfo->cScriptLen))
    {
   
        if ((pPackageDetail->pInstallInfo->cScriptLen) &&
            (!IsValidReadPtrIn(pPackageDetail->pInstallInfo->pScript, pPackageDetail->pInstallInfo->cScriptLen)))
            return E_INVALIDARG;

        SAFEARRAYBOUND size; // Get rid of 16
        SAFEARRAY FAR *psa;
        CHAR HUGEP *pArray=NULL;
        LONG dwSLBound = 0;
        LONG dwSUBound = 0;
        VARIANT vData;

        VariantInit(&vData);
        size.cElements = pPackageDetail->pInstallInfo->cScriptLen;
        size.lLbound = 0;

        psa = SafeArrayCreate(VT_UI1, 1, &size);
        if (!psa) {
            return(E_OUTOFMEMORY);
        }

        hr = SafeArrayAccessData( psa, (void HUGEP * FAR *) &pArray );
        RETURN_ON_FAILURE(hr);
        memcpy( pArray, pPackageDetail->pInstallInfo->pScript, size.cElements );
        SafeArrayUnaccessData( psa );

        V_VT(&vData) = VT_ARRAY | VT_UI1;
        V_ARRAY(&vData) = psa;
        hr = pPackageADs->Put(PKGSCRIPT, vData);
        VariantClear(&vData);
        ERROR_ON_FAILURE(hr);
    }
    
    hr = StoreIt(pPackageADs);
    ERROR_ON_FAILURE(hr);
    
    for (count = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
    {
        hr = NewClass((pPackageDetail->pActInfo->pClasses)+count);
        ERROR_ON_FAILURE(hr);
    }

    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadm\cscaten.cxx ===
//
//  Author: ushaji
//  Date:   December 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for Enumerator Interfaces.
//
//      Refer Doc "Design for Support of File Types and Component Categories
//    in Class Store" ? (or may be Class Store Schema). Most of these uses
//  OLE DB interfaces within the interfaces.
//
//----------------------------------------------------------------------------

#include "csadm.hxx"


//
// Private defines
//

#define MAX_ADS_FILTERS   10
#define MAX_ADS_ENUM      100

// BUGBUG:: Should this go to common

HRESULT
EnumCsObject(
    IADsContainer * pADsContainer,
    LPWSTR * lppPathNames,
    DWORD dwPathNames,
    IEnumVARIANT ** ppEnumVariant
    )
{
    ULONG cElementFetched = 0L;
    VARIANT  VarFilter;
    HRESULT hr;
    DWORD dwObjects = 0, dwEnumCount = 0, i = 0;
    BOOL  fContinue = TRUE;


    if (dwPathNames)
    {
        VariantInit(&VarFilter);

        hr = BuildVarArrayStr(
                lppPathNames,
                dwPathNames,
                &VarFilter
                );

        RETURN_ON_FAILURE(hr);

        hr = pADsContainer->put_Filter(VarFilter);

        RETURN_ON_FAILURE(hr);

        VariantClear(&VarFilter);
    }

    hr = ADsBuildEnumerator(
            pADsContainer,
            ppEnumVariant
            );

    return hr;
}


HRESULT
GetNextEnum(
    IEnumVARIANT * pEnum,
    IADs       **ppADs
    )
{

    HRESULT hr;
    VARIANT VariantArray[MAX_ADS_ENUM];
    IDispatch *pDispatch = NULL;


    hr = ADsEnumerateNext(
                    pEnum,
                    1,
                    VariantArray,
                    NULL
                    );

    if (hr == S_FALSE)
        return hr;

    RETURN_ON_FAILURE(hr);

    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) ppADs) ;
    pDispatch->Release();
    return(S_OK);
}

HRESULT GetCategoryProperty (IADs *pADs,
                           CATEGORYINFO *pcategoryinfo, LCID lcid)
{
     HRESULT    hr = S_OK;
     WCHAR      szName[_MAX_PATH];
     LPOLESTR  *pdesc = NULL;
     ULONG      i, cdesc;

     hr = GetPropertyGuid(pADs, CATEGORYCATID, &(pcategoryinfo->catid));
     RETURN_ON_FAILURE(hr);

     hr = GetPropertyListAlloc(pADs, LOCALEDESCRIPTION, &cdesc, &pdesc);
     RETURN_ON_FAILURE(hr);

     pcategoryinfo->lcid = lcid;

     hr = GetCategoryLocaleDesc(pdesc, cdesc, &(pcategoryinfo->lcid),
                                (pcategoryinfo->szDescription));
     for (i = 0; i < cdesc; i++)
         CoTaskMemFree(pdesc[i]);
     CoTaskMemFree(pdesc);

     if (FAILED(hr))
         *(pcategoryinfo->szDescription) = L'\0';

     return S_OK;
}
//----------------------------------------------


//    IEnumCATEGORYINFO:
//    IUnknown methods
HRESULT CSCEnumCategories::QueryInterface(REFIID riid, void** ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumCATEGORYINFO))
    {
        *ppObject=(IUnknown *)(IEnumCATEGORYINFO*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumCategories::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumCategories::Release()
{
    ULONG dwRefCount;

    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATEGORYINFO methods
//--------------------------------------------------------------------
// Next:
//        celt:            Number of elements to be fetched.
//        rgelt:           Buffer to return the elements.
//        pceltFetched:    ptr to Number of elements actually fetched.
//                         Takes care of that being NULL.
// Uses OLE DS interfaces to get the next enumerators.
//--------------------------------------------------------------------

HRESULT CSCEnumCategories::Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched)
{
    HRESULT             hr = S_OK;
    IADs               *pCatADs = NULL;
    ULONG               dwCount;

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if (m_pEnumVariant == NULL)
        return E_UNEXPECTED;

    if (celt < 0)
        return E_INVALIDARG;

    if (!IsValidPtrOut(rgelt, sizeof(CATEGORYINFO)*celt)) {
        return E_INVALIDARG;
    }

    for ((dwCount) = 0; (dwCount) < celt;) {
        hr = GetNextEnum(m_pEnumVariant, &pCatADs);
        if ((FAILED(hr)) || (hr == S_FALSE))
            break;

        hr = GetCategoryProperty(pCatADs, &(rgelt[dwCount]), m_lcid);
        pCatADs->Release();

        if (FAILED(hr))
            continue;

        (dwCount)++;
    }

    m_dwPosition += dwCount;

    if (pceltFetched)
        (*pceltFetched) = dwCount;
    return hr;
}

//---------------------------------------------------
// skip:
//            skips elements.
//    celt    Number of elements to skip.
//---------------------------------------------------

HRESULT CSCEnumCategories::Skip(ULONG celt)
{
    CATEGORYINFO *dummy;
    ULONG         got;
    HRESULT       hr;

    dummy = new CATEGORYINFO[celt];
    if (!dummy)
        return E_OUTOFMEMORY;

    if (m_pEnumVariant == NULL)
    {
        delete dummy;
        return E_UNEXPECTED;
    }
    hr = Next(celt, dummy, &got);
    delete dummy;
    return hr;
}

//---------------------------------------------------
// Reset:
//     Resets the pointer.
//---------------------------------------------------
HRESULT CSCEnumCategories::Reset(void)
{
    LPOLESTR    pszPathNames [2];
    HRESULT     hr;

    pszPathNames [0] = CLASS_CS_CATEGORY;

    if (m_pEnumVariant == NULL)
        return E_UNEXPECTED;
    m_pEnumVariant->Release();

    hr = EnumCsObject(m_ADsCategoryContainer, &pszPathNames[0],
                      0, &m_pEnumVariant);

    m_dwPosition = 0;
    return hr;
}
//--------------------------------------------------------------
//    Clone:
//            returns another interface which points to the same data.
//        ppenum:        enumerator
//------------------------------------------------------------
////////////////////////////////////////////////////////////////////
HRESULT CSCEnumCategories::Clone(IEnumCATEGORYINFO **ppenum)
{
    CSCEnumCategories* pClone=NULL;

    if (!IsValidPtrOut(ppenum, sizeof(IEnumCATEGORYINFO *))) {
        return E_INVALIDARG;
    }

    pClone=new CSCEnumCategories();

    if (!pClone)
    {
        return E_OUTOFMEMORY;
    }
    if (FAILED(pClone->Initialize(m_ADsCategoryContainer, m_lcid)))
    {
        delete pClone;
        return E_UNEXPECTED;
    }

    pClone->Skip(m_dwPosition);

    if (SUCCEEDED(pClone->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenum)))
    {
        return S_OK;
    }

    delete pClone;
    return E_UNEXPECTED;
}

CSCEnumCategories::CSCEnumCategories()
{
    m_dwRefCount=0;
    m_pEnumVariant = NULL;
    m_ADsCategoryContainer = NULL;
    m_lcid=0;
    m_dwPosition = 0;
}

HRESULT CSCEnumCategories::Initialize(IADsContainer *ADsCategoryContainer, LCID lcid)
{
    LPOLESTR pszPathNames [2];
    HRESULT hr;

    pszPathNames [0] = CLASS_CS_CATEGORY;
    m_ADsCategoryContainer = ADsCategoryContainer;
    m_ADsCategoryContainer->AddRef();

    hr = EnumCsObject(m_ADsCategoryContainer, &pszPathNames[0], 0, &m_pEnumVariant);
    RETURN_ON_FAILURE(hr);

    m_lcid = lcid;
    return S_OK;
} /* EnumCategories */


CSCEnumCategories::~CSCEnumCategories()
{
    if (m_ADsCategoryContainer)
        m_ADsCategoryContainer->Release();
    if (m_pEnumVariant)
        m_pEnumVariant->Release();
}

// CSCEnumCategoriesOfClass:
// IUnknown methods
HRESULT CSCEnumCategoriesOfClass::QueryInterface(REFIID riid, void** ppObject)
{
    if ((riid==IID_IUnknown) || (riid==IID_IEnumCATID))
    {
        *ppObject=(IEnumCATID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumCategoriesOfClass::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumCategoriesOfClass::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATID methods
HRESULT CSCEnumCategoriesOfClass::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    ULONG dwCount;

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if (celt < 0)
        return E_INVALIDARG;

    if (!IsValidPtrOut(rgelt, sizeof(GUID)*celt))
        return E_INVALIDARG;

    for ( (dwCount) = 0; (((dwCount) < celt) && (m_dwPosition < m_cCatid));
                                            (dwCount)++, m_dwPosition++)
        rgelt[(dwCount)] = m_catid[m_dwPosition];

    if (pceltFetched)
        (*pceltFetched) = dwCount;
    if (dwCount == celt)
        return S_OK;
    return S_FALSE;
}

HRESULT CSCEnumCategoriesOfClass::Skip(ULONG celt)
{
    if (m_cCatid >= (celt + m_dwPosition)) {
        m_dwPosition += celt;
        return S_OK;
    }
    m_dwPosition = m_cCatid;
    return S_FALSE;
}


HRESULT CSCEnumCategoriesOfClass::Reset(void)
{
    m_dwPosition = 0;
    return S_OK;
}

HRESULT CSCEnumCategoriesOfClass::Clone(IEnumGUID **ppenum)
{
    HRESULT                         hr = S_OK;
    CSCEnumCategoriesOfClass       *pEnumClone = NULL;

    if (!IsValidPtrOut(ppenum, sizeof(IEnumGUID *)))
        return E_POINTER;

    pEnumClone = new CSCEnumCategoriesOfClass;
    if (pEnumClone == NULL)
        return E_OUTOFMEMORY;

    pEnumClone->Initialize(m_catid, m_cCatid);
    pEnumClone->m_dwPosition = m_dwPosition;
    if (SUCCEEDED(hr = pEnumClone->QueryInterface(IID_IEnumCATID, (void**) ppenum)))
        return S_OK;

    delete pEnumClone;
    return hr;
}


CSCEnumCategoriesOfClass::CSCEnumCategoriesOfClass()
{
    m_dwRefCount=0;
    m_dwPosition = 0;
    m_catid = NULL;
}

HRESULT CSCEnumCategoriesOfClass::Initialize(CATID catid[], ULONG cCatid)
{
    ULONG   i;

    m_catid = new CATID[cCatid];
    if (!m_catid)
        return E_OUTOFMEMORY;
    m_cCatid = cCatid;
    for (i = 0; i < cCatid; i++)
        m_catid[i] = catid[i];
    m_dwPosition = 0;
    return S_OK;
}

CSCEnumCategoriesOfClass::~CSCEnumCategoriesOfClass()
{
    if (m_catid)
        delete m_catid;
}

// CEnumClassesOfCategories:
// IUnknown methods
HRESULT CSCEnumClassesOfCategories::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCLSID)
    {
        *ppObject=(IEnumCLSID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumClassesOfCategories::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumClassesOfCategories::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumGUID methods
HRESULT CSCEnumClassesOfCategories::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    ULONG        cRead;
    ULONG        i, dwCount, cgot;
    HRESULT      hr;
    CLSID        clsid;
    IADs        *pclsid;
    WCHAR        szClsid[_MAX_PATH];

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if ((celt < 0) || (!IsValidPtrOut(rgelt, sizeof(GUID)*celt)))
        return E_INVALIDARG;

    for ((dwCount) = 0; (dwCount) < celt;) {

        hr = GetNextEnum(m_pEnumVariant, &pclsid);
        if ((FAILED(hr)) || (hr == S_FALSE))
        {
            if (pceltFetched)
                *pceltFetched = dwCount;
            return S_FALSE;
        }

        hr = GetProperty (pclsid, CLASSCLSID, szClsid);
        pclsid->Release();

        if (FAILED(hr)) {
            if (pceltFetched)
                *pceltFetched = dwCount;
            return S_FALSE;
        }

        GUIDFromString(szClsid, &clsid);

        if ((ImplSatisfied(clsid, m_cImplemented, m_rgcatidImpl, m_pICatInfo) == S_OK) &&
                (ReqSatisfied(clsid, m_cRequired, m_rgcatidReq, m_pICatInfo) == S_OK))
        {
            rgelt[dwCount] = clsid;
            (dwCount)++;
        }
    }

    m_dwPosition += dwCount;

    if (pceltFetched)
        *pceltFetched = dwCount;

    return S_OK;
}

HRESULT CSCEnumClassesOfCategories::Skip(ULONG celt)
{
    CLSID       *dummyclasses;
    ULONG        celtFetched;
    HRESULT      hr;

    dummyclasses = new CLSID[celt];
    hr = Next(celt, dummyclasses, &celtFetched);
    delete dummyclasses;
    return hr;
}

HRESULT CSCEnumClassesOfCategories::Reset()
{
    LPOLESTR    pszPathNames [2];
    HRESULT     hr;

    pszPathNames [0] = CLASS_CS_CLASS;

    if (m_pEnumVariant == NULL)
        return E_UNEXPECTED;
    m_pEnumVariant->Release();

    hr = EnumCsObject(m_ADsClassContainer, &pszPathNames[0],
                      0, &m_pEnumVariant);
    m_dwPosition = 0;
    return hr;
}

HRESULT CSCEnumClassesOfCategories::Clone(IEnumGUID **ppenum)
{
    HRESULT                         hr;
    CSCEnumClassesOfCategories    *pEnumClone;

    if (!ppenum)
        return E_INVALIDARG;

    pEnumClone = new CSCEnumClassesOfCategories;
    if (!pEnumClone)
        return E_OUTOFMEMORY;
    hr = pEnumClone->Initialize(m_cRequired, m_rgcatidReq,
                                m_cImplemented, m_rgcatidImpl,
                                m_ADsClassContainer,
                                m_pICatInfo);
    if (FAILED(hr))
    {
        delete pEnumClone;
        return hr;
    }
    pEnumClone->Skip(m_dwPosition);

    hr = pEnumClone->QueryInterface(IID_IEnumCLSID, (void **)ppenum);
    if (FAILED(hr))
    {
        delete pEnumClone;
    }

    return hr;
}

CSCEnumClassesOfCategories::CSCEnumClassesOfCategories()
{
    m_dwRefCount = 0;
    m_rgcatidReq = NULL;
    m_rgcatidImpl = NULL;
    m_pICatInfo = NULL;
    m_ADsClassContainer = NULL;
    m_pEnumVariant = NULL;
    m_dwPosition = 0;
}

HRESULT CSCEnumClassesOfCategories::Initialize(ULONG cRequired, CATID rgcatidReq[],
                                               ULONG cImplemented, CATID rgcatidImpl[],
                                               IADsContainer *ADsClassContainer,
                                               ICatInformation *pICatInfo)
{
    ULONG       i;
    HRESULT     hr;
    LPOLESTR    pszPathNames [2];

    pszPathNames [0] = CLASS_CS_CLASS;
    m_ADsClassContainer = ADsClassContainer;
    m_ADsClassContainer->AddRef();

    hr = EnumCsObject(m_ADsClassContainer, &pszPathNames[0], 0, &m_pEnumVariant);
    RETURN_ON_FAILURE(hr);

    m_pICatInfo = pICatInfo;
    RETURN_ON_FAILURE(m_pICatInfo->AddRef());

    m_cRequired = cRequired;
    if (cRequired != -1)
    {
        m_rgcatidReq = new CATID[cRequired];
        if (!m_rgcatidReq)
            return E_OUTOFMEMORY;
        for (i = 0; i < m_cRequired; i++)
            m_rgcatidReq[i] = rgcatidReq[i];
    }

    m_cImplemented = cImplemented;
    if (cImplemented != -1)
    {
        m_rgcatidImpl = new CATID[cImplemented];
        if (!m_rgcatidImpl)
            return E_OUTOFMEMORY;
        for (i = 0; i < m_cImplemented; i++)
            m_rgcatidImpl[i] = rgcatidImpl[i];
    }
    return S_OK;
}

CSCEnumClassesOfCategories::~CSCEnumClassesOfCategories()
{
    if (m_rgcatidReq)
        delete m_rgcatidReq;
    if (m_rgcatidImpl)
        delete m_rgcatidImpl;
    if (m_pICatInfo)
        m_pICatInfo->Release();
    if (m_ADsClassContainer)
        m_ADsClassContainer->Release();
    if (m_pEnumVariant)
        m_pEnumVariant->Release();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\cshelp.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       cshelp.cpp
//
//  Contents:   Helper functions for working with the class store
//
//  Classes:
//
//  Functions:  DeletePackageAndDependants
//
//  History:    6-26-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

void DeleteApp(IClassAdmin * pca, APPDETAIL &ad)
{
    // I would here try to delete any IIDs associated with this app but
    // there is no way to determine which IIDs ARE associated with this app.

    // Delete any CLSIDs associated with this app
    DWORD nIndex = ad.cClasses;
    while (nIndex--)
    {
        // Deliberately ignoring the return code
        pca->DeleteClass(ad.prgClsIdList[nIndex]);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   DeletePackageAndDependants
//
//  Synopsis:   deletes a package from the class store along with all of the
//              other objects that are associated with it (CLSIDs, etc)
//
//  Arguments:  [pca]    - IClassAdmin pointer
//              [szName] - name of the package to be removed
//              [ppd]    - pointer to the PACKAGEDETAIL structure
//
//  Returns:    S_OK on success
//
//  History:    6-26-1997   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT DeletePackageAndDependants(IClassAdmin * pca, LPOLESTR szName, PACKAGEDETAIL * ppd)
{
    // First delete the package.  Any CLSIDs or IIDs that were
    // implemented solely by this package can now be deleted from the
    // class store.  If they are also implemented by other packages that
    // are still in the class store, then deleting them will return an
    // error which we can safely ignore.
    HRESULT hr = pca->DeletePackage(szName);

    DWORD nApp = ppd->cApps;
    while (nApp--)
    {
        DeleteApp(pca, ppd->pAppDetail[nApp]);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "appmgr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__CA9BAE5D_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_DLLDATAX_H__CA9BAE5D_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__CA9BAE5D_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\cshelp.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       cshelp.h
//
//  Contents:   Helper functions for working with the class store
//
//  Classes:
//
//  Functions:  DeletePakcageAndDependants
//
//  History:    6-26-1997   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT DeletePackageAndDependants(IClassAdmin * pca, LPOLESTR szName, PACKAGEDETAIL * ppd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "precomp.hxx"
#include "process.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

long CSnapin::lDataObjectRefCount = 0;

#if 1   // BUGBUG - until this gets put in the regular build environment
extern const IID IID_IClassAdmin; /* = {0x00000191,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}}; */
#endif

extern const CLSID CLSID_Snapin = {0xbdc67e00,0x8ea5,0x11d0,{0x8d,0x3c,0x00,0xa0,0xc9,0x0d,0xca,0xe7}};
extern const wchar_t * szCLSID_Snapin = L"{bdc67e00-8ea5-11d0-8d3c-00a0c90dcae7}";
//const CLSID CLSID_Snapin = {0x18731372,0x1D79,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

// Main NodeType GUID on numeric format
extern const GUID cNodeType = {0xf8b3a900,0x8ea5,0x11d0,{0x8d,0x3c,0x00,0xa0,0xc9,0x0d,0xca,0xe7}};
//const GUID cNodeType = {0x44092d22,0x1d7e,0x11D0,{0xA2,0x9B,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};

// Main NodeType GUID on string format
extern const wchar_t*  cszNodeType = L"{f8b3a900-8ea5-11d0-8d3c-00a0c90dcae7}";
//const wchar_t*  cszNodeType = L"{44092d22-1d7e-11d0-a29b-00c04fd909dd}";

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"APPMGR_INTERNAL";

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

static MMCBUTTON SnapinButtons[] =
{
 { 0, 1, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Folder"), _T("New Folder") },
 { 1, 2, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Inbox"),  _T("Mail Inbox")},
 { 2, 3, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Outbox"), _T("Mail Outbox") },
 { 3, 4, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Send"),   _T("Send Message") },
 { 0, 0, TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),      _T("") },
 { 4, 5, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Trash"),  _T("Trash") },
 { 5, 6, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Open"),   _T("Open Folder")},
 { 6, 7, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("News"),   _T("Today's News") },
 { 7, 8, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("INews"),  _T("Internet News") },

};

static MMCBUTTON SnapinButtons2[] =
{
 { 0, 10, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Compose"),   _T("Compose Message") },
 { 1, 20, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Print"),     _T("Print Message") },
 { 2, 30, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Find"),      _T("Find Message") },
 { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),         _T("") },
 { 3, 40, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Inbox"),     _T("Inbox") },
 { 4, 50, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Smile"),     _T("Smile :-)") },
 { 5, 60, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Reply"),     _T("Reply") },
 { 0, 0,  TBSTATE_ENABLED, TBSTYLE_SEP   , _T(" "),         _T("") },
 { 6, 70, TBSTATE_ENABLED, TBSTYLE_BUTTON, _T("Reply All"), _T("Reply All") },

};

// Utility function to delete an registry key and all of it's children
LONG RegDeleteTree(HKEY hKey, LPCTSTR lpSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKey(hKey, lpSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    TCHAR szName[256];
    while (ERROR_SUCCESS == RegEnumKey(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKey(hKey, lpSubKey);
}


INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    INTERNAL* internal = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    if (!lpDataObject)
        return NULL;


    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        internal = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);

                if (internal == NULL)
                        break;

        } while (FALSE);

    return internal;
}

/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CSnapin::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
        FORMATETC formatetc = { CDataObject::m_cfNodeType, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(GUID));

    // Attempt to get data from the object
    do
        {
                if (stgmedium.hGlobal == NULL)
                        break;

                if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
                        break;

        GUID* nodeType = reinterpret_cast<GUID*>(stgmedium.hGlobal);

                if (nodeType == NULL)
                        break;

        // Is this my main node (static folder node type)
        if (*nodeType == cNodeType)
            bResult = TRUE;

        } while (FALSE);


    // Free resources
        if (stgmedium.hGlobal != NULL)
                GlobalFree(stgmedium.hGlobal);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation

STDMETHODIMP CSnapin::GetResultViewType(long cookie,  BSTR* ppViewType, LONG * pViewOptions)
{
    // Use default view
    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    hr = m_pConsole->QueryInterface(IID_IPropertySheetProvider,
                        (void **)&m_pIPropertySheetProvider);

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    return S_OK;
}

STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr = S_OK;
    long cookie;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            cookie = 0;
        }
        else
        {
            cookie = pInternal->m_cookie;
        }


        switch(event)
        {
        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_CLICK:
            hr = OnResultItemClkOrDblClk(cookie, FALSE);
            break;

        case MMCN_DBLCLICK:
            if (pInternal->m_type == CCT_RESULT)
                hr = OnResultItemClkOrDblClk(cookie, TRUE);
            else
                hr = S_FALSE;
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow(cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_SELECT:
            hr = OnSelect(pInternal->m_type, cookie, arg, param);
            break;

        // Note - Future expansion of notify types possible
        default:
            ASSERT(FALSE);  // Handle new messages
            hr = E_UNEXPECTED;
            break;
        }

        FREE_INTERNAL(pInternal);
    }

    return hr;
}

STDMETHODIMP CSnapin::Destroy(long cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);
        SAFE_RELEASE(m_pConsoleVerb);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        if (m_pComponentData)
        {
            ((IComponentData*)m_pComponentData)->Release(); // QI'ed in IComponentDataImpl::CreateComponent
        }
        SAFE_RELEASE(m_pIAppManagerActions); // ditto


    }

    return S_OK;
}

STDMETHODIMP CSnapin::QueryDataObject(long cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    CSnapin::lDataObjectRefCount = 0;
    m_lViewMode = LVS_REPORT;
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

//    SAFE_RELEASE(m_pToolbar1);
//    SAFE_RELEASE(m_pToolbar2);

//    SAFE_RELEASE(m_pControlbar);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
//    ASSERT(m_pToolbar1 == NULL);
//    ASSERT(m_pToolbar2 == NULL);


//    delete m_pbmpToolbar1;
//    delete m_pbmpToolbar2;

    Construct();

    ASSERT(CSnapin::lDataObjectRefCount == 0);

}

void CSnapin::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;
    m_pIAppManagerActions = NULL;
//    m_pToolbar1 = NULL;
//    m_pToolbar2 = NULL;
//    m_pControlbar = NULL;

//    m_pbmpToolbar1 = NULL;
//    m_pbmpToolbar2 = NULL;
}

// Array of menu item commands to be inserted into the context menu.
// Note - the first item is the menu text,
// the second item is the status string

CONTEXTMENUITEM menuItems[] =
{
        {
                L"", L"",
                0, CCM_INSERTIONPOINTID_PRIMARY_TOP, MFT_SEPARATOR, CCM_SPECIAL_SEPARATOR
        },
        {
                L"", L"",
                IDM_ADD_APP, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        },
        {
                L"", L"",
                IDM_UPDATE_APP, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        },
        {
                L"", L"",
                IDM_DEL_APP, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        },
        {
                L"", L"",
                IDM_ADD_FROM_IE, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        },
        {
                L"", L"",
                IDM_REFRESH, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, 0
        }
};


CString szExtension;
CString szFilter;

void CSnapin::LoadResources()
{
    // Load strings from resources

    m_column1.LoadString(IDS_NAME);
    m_column2.LoadString(IDS_TYPE);
    m_column3.LoadString(IDS_SIZE);
    m_column4.LoadString(IDS_LOC);
    m_column5.LoadString(IDS_MACH);
    m_column6.LoadString(IDS_DESC);
    m_column7.LoadString(IDS_PATH);
    m_szAddApp.LoadString(IDM_ADD_APP);
    m_szAddAppDesc.LoadString(IDS_ADD_APP_DESC);
    m_szDelApp.LoadString(IDM_DEL_APP);
    m_szDelAppDesc.LoadString(IDS_DEL_APP_DESC);
    m_szUpdateApp.LoadString(IDM_UPDATE_APP);
    m_szUpdateAppDesc.LoadString(IDS_UPDATE_APP_DESC);
    m_szRefresh.LoadString(IDM_REFRESH);
    m_szRefreshDesc.LoadString(IDS_REFRESH_DESC);
    m_szAddFromIe.LoadString(IDM_ADD_FROM_IE);
    m_szAddFromIeDesc.LoadString(IDS_ADD_FROM_IE_DESC);
    menuItems[1].strName = (LPWSTR)((LPCOLESTR)m_szAddApp);
    menuItems[1].strStatusBarText = (LPWSTR)((LPCOLESTR)m_szAddAppDesc);
    menuItems[2].strName = (LPWSTR)((LPCOLESTR)m_szUpdateApp);
    menuItems[2].strStatusBarText = (LPWSTR)((LPCOLESTR)m_szUpdateAppDesc);
    menuItems[3].strName = (LPWSTR)((LPCOLESTR)m_szDelApp);
    menuItems[3].strStatusBarText = (LPWSTR)((LPCOLESTR)m_szDelAppDesc);
    menuItems[4].strName = (LPWSTR)((LPCOLESTR)m_szAddFromIe);
    menuItems[4].strStatusBarText = (LPWSTR)((LPCOLESTR)m_szAddFromIeDesc);
    menuItems[5].strName = (LPWSTR)((LPCOLESTR)m_szRefresh);
    menuItems[5].strStatusBarText = (LPWSTR)((LPCOLESTR)m_szRefreshDesc);
    szExtension.LoadString(IDS_DEF_EXTENSION);
    szFilter.LoadString(IDS_EXTENSION_FILTER);
    m_szFolderTitle.LoadString(IDS_FOLDER_TITLE);
}

HRESULT CSnapin::InitializeHeaders(long cookie)
{
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);

    // Put the correct headers depending on the cookie
    // Note - cookie ignored for this sample
    m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, 100);    // Name
    m_pHeader->InsertColumn(1, m_column2, LVCFMT_LEFT, 75);     // Type
//    m_pHeader->InsertColumn(2, m_column3, LVCFMT_RIGHT, 50);    // Size
    m_pHeader->InsertColumn(2, m_column4, LVCFMT_RIGHT, 100);    // localle
    m_pHeader->InsertColumn(3, m_column5, LVCFMT_LEFT, 75);     // machine
    m_pHeader->InsertColumn(4, m_column6, LVCFMT_LEFT, 75);    // description
    m_pHeader->InsertColumn(5, m_column7, LVCFMT_LEFT, 150);    // path

    return hr;
}

HRESULT CSnapin::InitializeBitmaps(long cookie)
{
    ASSERT(m_pImageResult != NULL);

    CBitmap bmp16x16;
    CBitmap bmp32x32;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    m_pImageResult->ImageListSetStrip(reinterpret_cast<long*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<long*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}

STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    ASSERT(pResult != NULL);
    if (pResult)
    {
        if (pResult->lParam == -1)
        {
            switch (pResult->nCol)
            {
            case 0:
                pResult->str = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
                break;
            default:
                pResult->str = (BSTR)_T("");
                break;
            }
        }
        else
        {
            std::map<long, APP_DATA>::iterator i = m_pComponentData->m_AppData.find(pResult->lParam);
            if (i != m_pComponentData->m_AppData.end())
            {
                APP_DATA & data = i->second;
                switch (pResult->nCol)
                {
                case 0:
                    pResult->str = (unsigned short *)((LPCOLESTR)data.szName);
                    break;
                case 1:
                    pResult->str = (unsigned short *)((LPCOLESTR)data.szType);
                    break;
                case 2:
                    pResult->str = (unsigned short *)((LPCOLESTR)data.szLoc);
                    break;
                case 3:
                    pResult->str = (unsigned short *)((LPCOLESTR)data.szMach);
                    break;
                case 4:
                    pResult->str = (unsigned short *)((LPCOLESTR)data.szDesc);
                    break;
                case 5:
                    pResult->str = (unsigned short *)((LPCOLESTR)data.szIconPath);
                    break;
                }
                if (pResult->str == NULL)
                    pResult->str = (BSTR)_T("");
            }
        }
    }

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    return m_pComponentData->
        AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}

STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    return m_pComponentData->
        Command(nCommandID, pDataObject);
}

///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
: m_bIsDirty(TRUE)
{
    HKEY hKey;
    DWORD dwDisp;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    m_pScope = NULL;
    m_pConsole = NULL;
    m_pIClassAdmin = NULL;
    m_fLoaded = FALSE;
    m_fExtension = FALSE;
    m_pIGPTInformation = NULL;
    m_lLastAllocated = 0;

    //
    // This creates the magic "GPTSupport" key in HKCR so that Darwin
    // generates full link files.
    //

    if (RegCreateKeyEx (HKEY_CLASSES_ROOT, TEXT("GPTSupport"), 0, NULL,
                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey,
                  &dwDisp) == ERROR_SUCCESS)
    {
        RegCloseKey (hKey);
    }
}

CComponentDataImpl::~CComponentDataImpl()
{

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);
    ASSERT(CSnapin::lDataObjectRefCount == 0);
}
#include <msi.h>

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pScope));
    ASSERT(hr == S_OK);

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    return S_OK;
}

HRESULT CSnapin::OnAddImages(long cookie, long arg, long param)
{
    if (arg == 0)
    {
        return E_INVALIDARG;
    }

    // add the images for the scope tree
    CBitmap bmp16x16;
    CBitmap bmp32x32;
    LPIMAGELIST lpScopeImage = (LPIMAGELIST)arg;

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);
    bmp32x32.LoadBitmap(IDB_32x32);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<long*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<long*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(255,0,255));

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    m_pSnapin = pObject;


    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    ASSERT(m_pScope != NULL);
    HRESULT hr;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnProperties(param);
    }
    else
    {
        INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
        long cookie = 0;
        if (pInternal != NULL)
        {
            cookie = pInternal->m_cookie;
            FREE_INTERNAL(pInternal);
        }
        else
        {
            // only way we could not be able to extract our own format is if we're operating as an extension
            m_fExtension = TRUE;
        }

        if (m_pIGPTInformation == NULL)
        {
            hr = lpDataObject->QueryInterface(IID_IGPTInformation,
                            reinterpret_cast<void**>(&m_pIGPTInformation));
            if (SUCCEEDED(hr))
            {
                WCHAR szBuffer[MAX_PATH];
                do
                {
                    hr = m_pIGPTInformation->GetCSPath(szBuffer, MAX_PATH);
                    if (FAILED(hr)) break;
                    m_szLDAP_Path = "ADCS:";
                    m_szLDAP_Path += szBuffer;

                    hr = m_pIGPTInformation->GetGPTPath(GPT_SECTION_USER, szBuffer, MAX_PATH);
                    if (FAILED(hr)) break;
                    m_szGPT_Path = szBuffer;
                    m_szGPT_Path += L"\\Applications";

                    if (SUCCEEDED(CreateApplicationDirectories()))
                    {
                        m_fLoaded = TRUE;
                    }
                } while (0);
            }
        }


        switch(event)
        {
//      case MMCN_ADD:
//          hr = OnAdd(cookie, arg, param);
//          break;

        case MMCN_DELETE:
            hr = OnDelete(cookie, arg, param);
            break;

        case MMCN_RENAME:
            hr = OnRename(cookie, arg, param);
            break;

        case MMCN_EXPAND:
            {
                hr = OnExpand(cookie, arg, param);
            }
            break;

        case MMCN_SELECT:
            hr = OnSelect(cookie, arg, param);
            break;

        case MMCN_CONTEXTMENU:
            hr = OnContextMenu(cookie, arg, param);
            break;

        default:
            break;
        }

    }

    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    // Delete enumerated scope items
    DeleteList();

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);
    SAFE_RELEASE(m_pIClassAdmin);
    SAFE_RELEASE(m_pIGPTInformation);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStreamInit interface members

STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_Snapin;

    return E_NOTIMPL;
}

STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    ASSERT(pStm);

    // Read the string
    TCHAR psz[MAX_PATH];        // BUGBUG - really should be WCHAR to avoid problems in case
                                //          it's ever compiled for MBCS
    ULONG nBytesRead;
    ULONG cb;
    HRESULT hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
    if (SUCCEEDED(hr))
    {
        hr = pStm->Read(psz, cb, &nBytesRead);
        if (SUCCEEDED(hr))
        {
            if (cb > MAX_PATH * sizeof(TCHAR))
            {
                return E_FAIL;
            }
            m_szLDAP_Path = psz;

            hr = pStm->Read(&cb, sizeof(ULONG), &nBytesRead);
            if (SUCCEEDED(hr))
            {
                if (cb > MAX_PATH * sizeof(TCHAR))
                {
                    return E_FAIL;
                }
                hr = pStm->Read(psz, cb, &nBytesRead);

                if (SUCCEEDED(hr))
                {
                    m_szGPT_Path = psz;
                    m_fLoaded = TRUE;
                    ClearDirty();
                }
            }
        }
    }
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    ULONG cb = (m_szLDAP_Path.GetLength() + 1) * sizeof(TCHAR);
    HRESULT hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szLDAP_Path, cb, &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    cb = (m_szGPT_Path.GetLength() + 1) * sizeof(TCHAR);
    hr = pStm->Write(&cb, sizeof(ULONG), &nBytesWritten);
    if (FAILED(hr))
        return STG_E_CANTSAVE;
    hr = pStm->Write(m_szGPT_Path, cb, &nBytesWritten);

    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    ULONG cb = (m_szLDAP_Path.GetLength() + m_szGPT_Path.GetLength() + 2) * sizeof(TCHAR) + 2 * sizeof(ULONG);
    // Set the size of the string to be saved
    ULISet32(*pcbSize, cb);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::InitNew(void)
{
    return S_OK;
}

// IAppManagerActions methods

STDMETHODIMP CComponentDataImpl::CanPackageBeAssigned(ULONG cookie)
{
    HRESULT hr = E_FAIL;
    std::map<long, APP_DATA>::iterator i = m_AppData.find(cookie);
    if (i != m_AppData.end())
    {
        APP_DATA & data = i->second;
        // If it is already assigned or if the path points to the GPT then it can
        // be assigned.
        if (data.pDetails->dwActFlags & ACTFLG_Assigned)
        {
            hr = S_OK;
        }
        else
        {
            CString szTemp = data.szPath;
            szTemp.MakeLower();
            int i = szTemp.Find(_T("\\published\\"));
            if (i < 0)
            {
                i = szTemp.Find(_T("\\assigned\\")); // cover all the bases
            }
            if (i >= 0)
            {
                // finally make sure it's got an .aas extension
                if (szTemp.Right(4) == _T(".aas"))
                {
                    DWORD dwAttributes =  GetFileAttributes(data.szPath);
                    if ((dwAttributes != 0xffffffff) && ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CComponentDataImpl::NotifyClients(BOOL f)
{
    // Notify clients of change
    if (m_pIGPTInformation)
    {
        m_pIGPTInformation->NotifyClients(f);
    }
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::MovePackageToAssigned(ULONG cookie)
{
    HRESULT hr = E_FAIL;
    // first validate that we've got a script file that can be moved
    if (SUCCEEDED(CanPackageBeAssigned(cookie)))
    {
        APP_DATA & data = m_AppData[cookie];
        // don't need to validate the cookie because CanPackageBeAssigned does it.

        // need to build the destination path
        CString szTemp = data.szPath;
        szTemp.MakeLower();
        int iSplitpoint = szTemp.Find(_T("published"));
        if (iSplitpoint >= 0)
        {
            CString szDestination = data.szPath.Left(iSplitpoint);
            szDestination += _T("assigned");
            szDestination += data.szPath.Mid(iSplitpoint + strlen("published"));

            // move the script file
            if (!MoveFileEx(data.szPath, szDestination, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH))
                return (hr);

            // update the path in the data packet
            data.szPath = szDestination;
            data.pDetails->pszPath = (LPOLESTR)(LPCOLESTR) data.szPath;

        }
        else
        {
            if (szTemp.Find(_T("assigned")) >= 0)
            {
                hr = S_OK;   // already in the assigned directory
            }
        }
    }
    return hr;
}

STDMETHODIMP CComponentDataImpl::MovePackageToPublished(ULONG cookie)
{
    HRESULT hr = E_FAIL;
    // first validate that we've got a script file that can be moved
    if (SUCCEEDED(CanPackageBeAssigned(cookie)))
    {
        APP_DATA & data = m_AppData[cookie];
        // don't need to validate pData because CanPackageBeAssigned does it.

        // need to build the destination path
        CString szTemp = data.szPath;
        szTemp.MakeLower();
        int iSplitpoint = szTemp.Find(_T("assigned"));
        if (iSplitpoint >= 0)
        {
            CString szDestination = data.szPath.Left(iSplitpoint);
            szDestination += _T("published");
            szDestination += data.szPath.Mid(iSplitpoint + strlen("assigned"));

            // move the script file
            if (!MoveFileEx(data.szPath, szDestination, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH))
                return(hr);

            // update the path in the data packet
            data.szPath = szDestination;
            data.pDetails->pszPath = (LPOLESTR)(LPCOLESTR) data.szPath;

            // Notify clients of change
            if (m_pIGPTInformation)
            {
                m_pIGPTInformation->NotifyClients(FALSE);
            }
            hr = S_OK;
        }
        else
        {
            if (szTemp.Find(_T("published")) >= 0)
            {
                hr = S_OK;   // already in the published directory
            }
        }
    }
    return hr;
}

STDMETHODIMP CComponentDataImpl::ReloadPackageData(ULONG cookie)
{
    // put up an hourglass (this could take a while)
    CHourglass hourglass;
    return E_NOTIMPL;
}

HRESULT CComponentDataImpl::CreateApplicationDirectories(VOID)
{
    TCHAR szDir[MAX_PATH];
    LPTSTR lpEnd;
    HRESULT hr = S_OK;


    lstrcpy (szDir, m_szGPT_Path);
    lpEnd = szDir + lstrlen(szDir);

    do
    {
#if 0
        lstrcpy (lpEnd, TEXT("\\Assigned\\x86\\WinNT"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        lstrcpy (lpEnd, TEXT("\\Assigned\\x86\\Win95"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
#else
        lstrcpy (lpEnd, TEXT("\\Assigned\\x86"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
#endif

        lstrcpy (lpEnd, TEXT("\\Assigned\\Alpha"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
#if 0
        lstrcpy (lpEnd, TEXT("\\Published\\x86\\WinNT"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        lstrcpy (lpEnd, TEXT("\\Published\\x86\\Win95"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
#else
        lstrcpy (lpEnd, TEXT("\\Published\\x86"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
#endif
        lstrcpy (lpEnd, TEXT("\\Published\\Alpha"));
        if (!CreateNestedDirectory (szDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

    } while (FALSE);

    return hr;
}


UINT CComponentDataImpl::CreateNestedDirectory (LPTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        SetLastError(ERROR_INVALID_DATA);
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnAdd(long cookie, long arg, long param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnDelete(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRename(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(long cookie, long arg, long param)
{
    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        EnumerateScopePane(cookie,
            param);
    }

    return S_OK;
}

HRESULT CComponentDataImpl::OnSelect(long cookie, long arg, long param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnContextMenu(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnProperties(long param)
{
    if (param == NULL)
    {
        return S_OK;
    }

    ASSERT(param != NULL);

    return S_OK;
}


void CComponentDataImpl::EnumerateScopePane(long cookie, HSCOPEITEM pParent)
{
    // We only have one folder so this is really easy.
    if (cookie != NULL)
        return ;

    if (m_fExtension)
    {
        // if we're an extension then add a root folder to hang everything off of
        SCOPEDATAITEM * m_pScopeItem = new SCOPEDATAITEM;
        memset(m_pScopeItem, 0, sizeof(SCOPEDATAITEM));
        m_pScopeItem->mask = SDI_STR | SDI_PARAM;
        m_pScopeItem->relativeID = pParent;
        m_pScopeItem->displayname = (unsigned short *)-1;
        m_pScopeItem->lParam = -1; // made up cookie for my main folder
        m_pScope->InsertItem(m_pScopeItem);
    }
}

void CComponentDataImpl::DeleteList()
{
    return;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    if (pScopeDataItem->lParam == -1)
    {
        TCHAR szBuffer[256];
        ::LoadString(ghInstance, IDS_FOLDER_TITLE, szBuffer, 256);
        m_szFolderTitle = szBuffer;
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_szFolderTitle);
    }
    else
    {
        ASSERT(pScopeDataItem->mask == TVIF_TEXT);
        pScopeDataItem->displayname = (unsigned short *)((LPCOLESTR)m_AppData[pScopeDataItem->lParam].szName);
    }

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    long handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (m_pIClassAdmin && (pInternal->m_type == CCT_RESULT))
    {
        HRESULT hr;

        APP_DATA & data = m_pComponentData->m_AppData[pInternal->m_cookie];

        // Create the property page
        CGeneralPage* pPage = new CGeneralPage();
        CPackageDetails * pDetails = new CPackageDetails();
        pPage->m_hConsoleHandle = handle;
        pPage->m_pData = &data;
        pPage->m_cookie = pInternal->m_cookie;
        FREE_INTERNAL(pInternal);

        pPage->m_szName = data.szName;

        pDetails->m_hConsoleHandle = handle;
        pDetails->m_pData = &data;

        // marshal the IClassAdmin interface to the details page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(pDetails->m_pIStream));

        // marshal the IClassAdmin interface to the general page
        hr = CoMarshalInterThreadInterfaceInStream(IID_IClassAdmin, m_pIClassAdmin, &(pPage->m_pIStream));

        // marshal the IAppManagerActions interface to the general page

        hr = CoMarshalInterThreadInterfaceInStream(IID_IAppManagerActions, m_pIAppManagerActions, & (pPage->m_pIStreamAM));

        // Object gets deleted when the page is destroyed
        ASSERT(lpProvider != NULL);

        hr = MMCPropPageCallback(&pPage->m_psp);
        if (SUCCEEDED(hr))
        {
            hr = MMCPropPageCallback(&pDetails->m_psp);
            if (SUCCEEDED(hr))
            {
                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pPage->m_psp);
                HPROPSHEETPAGE hDetails = CreatePropertySheetPage(&pDetails->m_psp);

                if (hPage == NULL || hDetails == NULL)
                    return E_UNEXPECTED;

                lpProvider->AddPage(hPage);
#if DBG==1
                lpProvider->AddPage(hDetails);
#endif
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // Look at the data object and see if it an item that we want to have a property sheet
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (CCT_RESULT == pInternal->m_type)
    {
        FREE_INTERNAL(pInternal);
        return S_OK;
    }

    FREE_INTERNAL(pInternal);
    return S_FALSE;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

    if (pInternal->m_type == CCT_SCOPE)
        bResult = TRUE;

    FREE_INTERNAL(pInternal);

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG * pInsertionAllowed)
{
    HRESULT hr = S_OK;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);


    do {

        //
        // Add Application menu item
        //

        hr = pContextMenuCallback->AddItem(&menuItems[1]);

        if (FAILED(hr))
                break;


        //
        // Update & Remove application if this is a result pane item
        //

        if (pInternal->m_type == CCT_RESULT)
        {

            hr = pContextMenuCallback->AddItem(&menuItems[2]);

            if (FAILED(hr))
                    break;

            hr = pContextMenuCallback->AddItem(&menuItems[3]);

            if (FAILED(hr))
                    break;

        }


        //
        // Separator
        //

        hr = pContextMenuCallback->AddItem(&menuItems[0]);

        if (FAILED(hr))
                break;


        //
        // Import Application menu item
        //

        hr = pContextMenuCallback->AddItem(&menuItems[4]);

        if (FAILED(hr))
                break;


        //
        // Separator
        //

        hr = pContextMenuCallback->AddItem(&menuItems[0]);

        if (FAILED(hr))
                break;


        //
        // Refresh menu item
        //

        hr = pContextMenuCallback->AddItem(&menuItems[5]);

        if (FAILED(hr))
                break;


    } while (FALSE);


    FREE_INTERNAL(pInternal);
    return hr;
}

HRESULT CComponentDataImpl::InitializeClassAdmin()
{
    HRESULT hr = S_OK;
    BOOL fCancel = FALSE;
#if 0
    if (!m_fLoaded)
    {
        // initialize dialog with a default path
        // MH Remember last URL
        GetProfileString(L"Appmgr", L"DefCS", L"ADCS:LDAP:", m_szLDAP_Path.GetBuffer(_MAX_PATH), _MAX_PATH);
        m_szLDAP_Path.ReleaseBuffer();

        m_szGPT_Path = "C:\\GPT\\User\\Applications";
    }
#endif
    do
    {
#if 0
        if (!m_fLoaded)
        {
            // If I have to ask for a path then I must not have recieved one
            // from the GPT so the GPT snapin is probably in an invalid
            // state.  Therefore I should forget about the GPT snapin.
            // If I don't do this then the GPT snapin is very likely to
            // throw exceptions when I try to send it notifications.
            if (m_pIGPTInformation)
            {
                SAFE_RELEASE(m_pIGPTInformation);
                m_pIGPTInformation = NULL;
            }

            // ask for a path

            CInitDlg dlgInit;
            dlgInit.m_szLDAP_Path = m_szLDAP_Path;
            dlgInit.m_szGPT_Path = m_szGPT_Path;
            int iReturn = dlgInit.DoModal();
            if (iReturn = IDOK)
            {
                m_szLDAP_Path= dlgInit.m_szLDAP_Path;
                WriteProfileString(L"Appmgr", L"DefCS", m_szLDAP_Path); // MH Remember last URL
                m_szGPT_Path = dlgInit.m_szGPT_Path;
            }
            m_fLoaded = TRUE;
        }
#endif
        if (!m_pIClassAdmin)
        {
            // get the IClassAdmin
            LPBC pbc = NULL;
            hr = CreateBindCtx(0, &pbc);
            if (SUCCEEDED(hr))
            {
                ULONG chEaten = 0;
                IMoniker * pmk = NULL;

                hr = MkParseDisplayName(pbc, (LPCOLESTR) m_szLDAP_Path, &chEaten, &pmk);
                if (SUCCEEDED(hr))
                {
                    hr = pmk->BindToObject(pbc, NULL, IID_IClassAdmin, (void **) & m_pIClassAdmin);
                    // make sure directories are created:
                    if (SUCCEEDED(hr))
                    {
                        hr = CreateApplicationDirectories();
                    }
                    SAFE_RELEASE(pmk);
                }

                SAFE_RELEASE(pbc);
            }
            if (FAILED(hr))
            {
                m_fLoaded = FALSE;
                TCHAR szBuffer[256];
                if (!m_pIClassAdmin)
                {
                    ::LoadString(ghInstance, IDS_CSADMINFAILED, szBuffer, 256);
                }
                else
                {
                    m_pIClassAdmin->Release();
                    m_pIClassAdmin = NULL;
                    ::LoadString(ghInstance, IDS_GPTFAILED, szBuffer, 256);
                }
                int iReturn = ::MessageBox(NULL, m_szLDAP_Path,
                                   szBuffer,
                                   MB_RETRYCANCEL);
                if (iReturn == IDCANCEL)
                {
                    fCancel = TRUE;
                }
            }
        }
    } while ((!fCancel) && (!m_pIClassAdmin));
    return hr;
}

#include <list>

typedef struct tagCABLIST
{
    FILETIME ft;
    CString szPath;
    bool operator<(const struct tagCABLIST& st)
        {
            return CompareFileTime(&ft, &st.ft) < 0;
        }
} CABLIST;


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.

        // Handle each of the commands.
        switch (nCommandID)
        {
        case IDM_ADD_APP:
        case IDM_UPDATE_APP:
            {
            // put up an hourglass (this could take a while)
            CHourglass hourglass;
            CString szFileName;


            if (nCommandID == IDM_UPDATE_APP)
            {
                INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
                if (pInternal)
                {
                    APP_DATA & data = m_AppData[pInternal->m_cookie];

                    szFileName = data.szIconPath;

                    FREE_INTERNAL(pInternal);
                }
            }


            CFileDialog cfd(TRUE,
                            szExtension,
                            szFileName,
                            OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST,
                            szFilter);
            if (IDOK == cfd.DoModal())
            {

                if (nCommandID == IDM_ADD_APP)
                {
                    LONG index;
                    BOOL bFound = FALSE;

                    // make sure the user isn't adding something that
                    // already exists

                    std::map<long, APP_DATA>::iterator i = m_AppData.begin();
                    while (i != m_AppData.end())
                    {
                        APP_DATA &Data = i->second;

                        TCHAR Drive [_MAX_DRIVE];
                        TCHAR Dir [_MAX_DIR];
                        TCHAR Name [_MAX_FNAME];
                        TCHAR Ext [_MAX_EXT];
                        TCHAR szFile[_MAX_PATH];

                        _tsplitpath( Data.szIconPath, Drive, Dir, Name, Ext );
                        lstrcpy( szFile, Name );
                        lstrcat( szFile, Ext );

                        if (lstrcmpi (szFile, cfd.m_ofn.lpstrFileTitle) == 0)
                        {
                            bFound = TRUE;
                            break;
                        }
                        i++;
                    }

                    if (bFound)
                    {
                        TCHAR szBuffer[256];
                        TCHAR szTitle[100];

                        ::LoadString(ghInstance, IDS_ADDEXISTSALREADY, szBuffer, 256);
                        ::LoadString(ghInstance, IDS_SNAPIN_DESC, szTitle, 100);
                        m_pConsole->MessageBox(szBuffer,
                                           szTitle,
                                           MB_OK, NULL);
                        break;
                    }
                }


                // user selected an application
                UNIVERSAL_NAME_INFO * pUni = new UNIVERSAL_NAME_INFO;
                ULONG cbSize = sizeof(UNIVERSAL_NAME_INFO);
                BOOL bAssigned = FALSE;
                HRESULT hr = WNetGetUniversalName(cfd.m_ofn.lpstrFile,
                                                  UNIVERSAL_NAME_INFO_LEVEL,
                                                  pUni,
                                                  &cbSize);
                if (ERROR_MORE_DATA == hr)  // we expect this to be true
                {
                    delete [] pUni;
                    pUni = (UNIVERSAL_NAME_INFO *) new BYTE [cbSize];
                    hr = WNetGetUniversalName(cfd.m_ofn.lpstrFile,
                                              UNIVERSAL_NAME_INFO_LEVEL,
                                              pUni,
                                              &cbSize);
                }

                int i;
                char * szPackagePath = NULL;

                if (S_OK == hr)
                {
                    i = WTOALEN(pUni->lpUniversalName);
                    szPackagePath = new char [i+1];
                    WTOA(szPackagePath, pUni->lpUniversalName, i);
                }
                else
                {
                    i = WTOALEN(cfd.m_ofn.lpstrFile);
                    szPackagePath = new char [i+1];
                    WTOA(szPackagePath, cfd.m_ofn.lpstrFile, i);
                }
                delete[] pUni;

                i = WTOALEN((LPCOLESTR)m_szGPT_Path);
                char * szFilePath = new char [i+1];
                WTOA(szFilePath, m_szGPT_Path, i);


                if (nCommandID == IDM_UPDATE_APP)
                {
                    if (SUCCEEDED(RemovePackage(pDataObject, &bAssigned)))
                    {
                        hr = AddMSIPackage(pDataObject, szPackagePath, szFilePath, cfd.m_ofn.lpstrFileTitle, &bAssigned);
                    }
                }
                else
                {
                    hr = AddMSIPackage(pDataObject, szPackagePath, szFilePath, cfd.m_ofn.lpstrFileTitle, &bAssigned);
                }

                delete [] szPackagePath;
                delete [] szFilePath;


                // Notify clients of change
                if (SUCCEEDED(hr) && m_pIGPTInformation && bAssigned)
                {
                    m_pIGPTInformation->NotifyClients(FALSE);
                }
            }
            }
            break;


        case IDM_ADD_FROM_IE:
            if (m_pIClassAdmin)
            {
                // Locate IE4
                HKEY hkey;
                LONG r;
                TCHAR szPath[MAX_PATH];
                TCHAR szFullPath[MAX_PATH];
                r = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("SOFTWARE\\Microsoft\\IE4\\Setup"),
                                 0,
                                 KEY_READ,
                                 &hkey);
                if (ERROR_SUCCESS == r)
                {
                    DWORD cbData = MAX_PATH * sizeof(TCHAR);
                    r = RegQueryValueEx(hkey,
                                        TEXT("Path"),
                                        0,
                                        NULL,
                                        (LPBYTE)szPath,
                                        &cbData);
                    if (ERROR_SUCCESS == r)
                    {
                        ExpandEnvironmentStrings(szPath, szFullPath, MAX_PATH);
                        lstrcat(szFullPath, TEXT("\\iexplore.exe"));
                    }
                    RegCloseKey(hkey);
                }

                if (ERROR_SUCCESS == r)
                {
                    // Put up dialog informing user to close IE4 when he's ready
                    // to continue.
                    TCHAR szBuffer[1024];
                    TCHAR szCaption[256];
                    ::LoadString(ghInstance, IDS_SPAWNMSG, szBuffer, 1024);
                    ::LoadString(ghInstance, IDS_SPAWNCAPTION, szCaption, 256);

                    int iReturn = ::MessageBox(NULL,
                                               szBuffer,
                                               szCaption,
                                               MB_YESNO);
                    if (IDYES == iReturn)
                    {
                        // Take the starting time stamp
                        FILETIME ftStart;
                        GetSystemTimeAsFileTime(&ftStart);

                        // Start IE4 and wait for it to be closed
                        BOOL f;
                        STARTUPINFO startupinfo;
                        memset (&startupinfo, 0, sizeof(startupinfo));
                        PROCESS_INFORMATION processinfo;
                        f = CreateProcess(NULL,
                                          szFullPath,
                                          NULL, // process attributes
                                          NULL, // thread attributes
                                          FALSE, // bInheritHandles
                                          CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS,
                                          NULL, // lpEnvironment
                                          NULL, // lpCurrentDirectory
                                          &startupinfo,
                                          &processinfo);
                        if (f)
                        {
                            DWORD dw;
                            MSG msg;
                            do
                            {
                                dw = MsgWaitForMultipleObjects(1, &processinfo.hProcess, FALSE,  INFINITE, QS_ALLINPUT);
                                // if we don't process Windows messages
                                // here, we run the risk of causing a
                                // deadlock
                                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                                {
                                    DispatchMessage(&msg);
                                }
                            } while (dw != WAIT_OBJECT_0  );
                        }

                        // Take the ending time stamp
                        FILETIME ftEnd;
                        GetSystemTimeAsFileTime(&ftEnd);

                        r = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                         TEXT("SOFTWARE\\Microsoft\\Code Store Database\\Distribution Units"),
                                         0,
                                         KEY_READ,
                                         &hkey);
                        if (ERROR_SUCCESS == r)
                        {
                            DWORD cSubKeys,
                                cbMaxSubKeyLen;

                            r = RegQueryInfoKey(hkey,
                                                NULL, // lpClass
                                                NULL, // lpcbClass
                                                0,    // reserved
                                                &cSubKeys,
                                                &cbMaxSubKeyLen,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL);
                            // Build a list of cab files installed after the
                            // time stamp and order them by time.
                            std::list<CABLIST> cablist;
                            LPTSTR lpName = new TCHAR[cbMaxSubKeyLen + 1];
                            DWORD iSubKey;
                            DWORD cbName;
                            FILETIME ftSubKey;
                            for (iSubKey = 0; iSubKey < cSubKeys; iSubKey++)
                            {
                                HKEY hkSubKey;
                                cbName = cbMaxSubKeyLen + 1;
                                r = RegEnumKeyEx(hkey,
                                                 iSubKey,
                                                 lpName,
                                                 &cbName,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 &ftSubKey);
                                if ((ERROR_SUCCESS == r) &&
                                    (CompareFileTime(&ftStart, &ftSubKey) <= 0) &&
                                    (CompareFileTime(&ftSubKey, &ftEnd) <= 0))
                                {
                                    CString szSubKey = lpName;
                                    szSubKey += "\\DownloadInformation";
                                    HKEY hkeyInfo;
                                    r = RegOpenKeyEx(hkey,
                                                     szSubKey,
                                                     0,
                                                     KEY_READ,
                                                     &hkeyInfo);
                                    if (ERROR_SUCCESS == r)
                                    {
                                        TCHAR szPath[MAX_PATH];
                                        DWORD cbData = MAX_PATH * sizeof(TCHAR);
                                        r = RegQueryValueEx(hkeyInfo,
                                                            TEXT("CODEBASE"),
                                                            0,
                                                            NULL,
                                                            (LPBYTE)szPath,
                                                            &cbData);
                                        if (ERROR_SUCCESS == r)
                                        {
                                            // add this one to the list
                                            CABLIST cl;
                                            cl.szPath = szPath;
                                            cl.ft = ftSubKey;
                                            cablist.push_back(cl);
                                        }
                                        RegCloseKey(hkeyInfo);
                                    }
                                }
                            }
                            RegCloseKey(hkey);
                            delete [] lpName;

                            // sort the list by file time stamps
                            cablist.sort();

                            // for each cab file in the list
                            std::list<CABLIST>::iterator i;
                            for (i=cablist.begin(); i != cablist.end(); i++)
                            {
                                int x;
                                char * szPackagePath = NULL;
                                x = WTOALEN(i->szPath);
                                szPackagePath = new char [x+1];
                                WTOA(szPackagePath, i->szPath, x);

                                x = WTOALEN((LPCOLESTR)m_szGPT_Path);
                                char * szFilePath = new char [x+1];
                                WTOA(szFilePath, m_szGPT_Path, x);
                                HWND hwnd;
                                m_pConsole->GetMainWindow(&hwnd);

                                // install the cab file
                                HRESULT hr = UpdateClassStoreFromIE(m_pIClassAdmin, szPackagePath, szFilePath, 1, ftStart, i->ft, hwnd);

                                ftStart = i->ft;

                                delete [] szPackagePath;
                                delete [] szFilePath;

                                if (S_OK != hr)
                                {
                                    TCHAR szBuffer[256];
                                    ::LoadString(ghInstance, IDS_ADDFAILED, szBuffer, 256);
                                    m_pConsole->MessageBox(szBuffer,
                                                       i->szPath,
                                                       MB_OK, NULL);
                                }
                                else
                                {
                                    // add an entry to the result pane
                                    PACKAGEDETAIL * pd = new PACKAGEDETAIL;
                                    int n = i->szPath.ReverseFind('/');
                                    CString szName = i->szPath.Mid(n+1);
                                    hr = m_pIClassAdmin->GetPackageDetails((LPOLESTR)((LPCOLESTR) szName), pd);
                                    if (SUCCEEDED(hr))
                                    {
                                        APP_DATA data;
                                        data.szName = pd->pszPackageName;
                                        if (pd->dwActFlags & ACTFLG_Assigned)
                                        {
                                            data.type = DT_ASSIGNED;
                                        }
                                        else
                                        {
                                            data.type = DT_PUBLISHED;
                                        }
                                        data.szPath = pd->pszPath;
                                        data.szIconPath = pd->pszIconPath;
                                        data.szDesc = pd->pszProductName;
                                        data.pDetails = pd;

                                        RESULTDATAITEM resultItem;

                                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                                        resultItem.str = MMC_CALLBACK;
                                        resultItem.nImage = 1;
                                        data.fBlockDeletion = FALSE;
                                        SetStringData(&data);
                                        m_lLastAllocated++;
                                        m_AppData[m_lLastAllocated] = data;
                                        // BUGBUG - need to make sure that m_lLastAllocated
                                        // hasn't already been used!
                                        resultItem.lParam = m_lLastAllocated;
                                        hr = m_pSnapin->m_pResult->InsertItem(&resultItem);
                                        if (SUCCEEDED(hr))
                                        {
                                            m_AppData[m_lLastAllocated].itemID = resultItem.itemID;
                                            m_pSnapin->m_pResult->Sort(0, 0, -1);
                                        }

                                        // Notify clients of change
                                        if (m_pIGPTInformation && (data.type == DT_ASSIGNED))
                                        {
                                            m_pIGPTInformation->NotifyClients(FALSE);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    // put up dialog informing user that IE4 isn't installed
                    // on this machine
                    // UNDONE
                }

            }
            break;
        case IDM_REFRESH:
            if (m_pIClassAdmin)
            {

                std::map <long, APP_DATA>::iterator i;
                for (i=m_AppData.begin(); i != m_AppData.end(); i++)
                {
                    m_pSnapin->m_pResult->DeleteItem(i->second.itemID, 0);
                    m_AppData.erase(i);
                }
                m_lLastAllocated = 0;
                m_pSnapin->EnumerateResultPane(0);
            }
            break;
        case IDM_DEL_APP:
            {
            BOOL bAssigned = FALSE;

            if (SUCCEEDED(RemovePackage(pDataObject, &bAssigned)))
            {
               // Notify clients of change
               if (m_pIGPTInformation && bAssigned)
               {
                   m_pIGPTInformation->NotifyClients(FALSE);
               }
            }
            }
            break;

        default:
            break;
        }
    return S_OK;
}


HRESULT CComponentDataImpl::AddMSIPackage(LPDATAOBJECT pDataObject, LPSTR szPackagePath, LPSTR szFilePath, LPOLESTR lpFileTitle, BOOL *bAssigned)
{
    HRESULT hr = E_FAIL;

    if (m_pIClassAdmin)
    {
        ASSERT(m_pConsole);
        {
            char szPackageName[MAX_PATH];
            DWORD cchPackageName = MAX_PATH;
            HWND hwnd;
            m_pConsole->GetMainWindow(&hwnd);

            hr = UpdateClassStore(m_pIClassAdmin, szPackagePath, szFilePath, szPackageName, cchPackageName, !(*bAssigned), hwnd);

            if (S_OK != hr)
            {
                TCHAR szBuffer[256];
                // check to see if the reason is because there
                // were no COM Serverss
                if (hr == MAKE_HRESULT( SEVERITY_SUCCESS, 0, 1 ))
                {
                    ::LoadString(ghInstance, IDS_NOCOMSVR, szBuffer, 256);
                }
                else
                {
                    ::LoadString(ghInstance, IDS_ADDFAILED, szBuffer, 256);
//#if DBG == 1
#if 0
                    TCHAR szDebugBuffer[256];
                    DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                             NULL,
                                             hr,
                                             0,
                                             szDebugBuffer,
                                             sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                             NULL);
                    if (0 == dw)
                    {
                        wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
                    }
                    wcscat(szBuffer, szDebugBuffer);
#endif
                }
                m_pConsole->MessageBox(szBuffer,
                                   lpFileTitle,
                                   MB_OK, NULL);
            }
            else
            {
                PACKAGEDETAIL * pd = new PACKAGEDETAIL;
                WCHAR wszPackageName[MAX_PATH];
                ATOW(wszPackageName, szPackageName, MAX_PATH);
                hr = m_pIClassAdmin->GetPackageDetails(wszPackageName, pd);
                //hr = m_pIClassAdmin->GetPackageDetails(lpFileTitle, pd);
                if (SUCCEEDED(hr))
                {
                    APP_DATA data;
                    data.szName = pd->pszPackageName;
                    if (pd->dwActFlags & ACTFLG_Assigned)
                    {
                        data.type = DT_ASSIGNED;
                    }
                    else
                    {
                        data.type = DT_PUBLISHED;
                    }
                    data.szPath = pd->pszPath;
                    data.szIconPath = pd->pszIconPath;
                    data.szDesc = pd->pszProductName;
                    data.pDetails = pd;
                    data.fBlockDeletion = FALSE;
                    SetStringData(&data);
                    m_lLastAllocated++;
                    m_AppData[m_lLastAllocated] = data;

                    RESULTDATAITEM resultItem;

                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = 1;
                    // BUGBUG - need to make sure that m_lLastAllocated
                    // hasn't already been used!
                    resultItem.lParam = m_lLastAllocated;
                    hr = m_pSnapin->m_pResult->InsertItem(&resultItem);
                    if (SUCCEEDED(hr))
                    {
                        m_AppData[m_lLastAllocated].itemID = resultItem.itemID;
                        m_pSnapin->m_pResult->Sort(0, 0, -1);
                    }

                    // Notify clients of change
                    if (data.type == DT_ASSIGNED)
                    {
                        *bAssigned = TRUE;
                    }
                }
            }
        }
    }

    return hr;
}



HRESULT CComponentDataImpl::RemovePackage(LPDATAOBJECT pDataObject, BOOL *bAssigned)
{
    HRESULT hr = E_FAIL;

    if (m_pIClassAdmin)
    {
        ASSERT(m_pConsole);
        INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
        if (pInternal->m_type == CCT_RESULT)
        {
            // put up an hourglass (this could take a while)
            CHourglass hourglass;
            APP_DATA & data = m_AppData[pInternal->m_cookie];

            if (!data.fBlockDeletion) // make sure it's not being held open by a property page
            {
                // We need to make sure it gets removed from
                // the GPT before we delete it from the class store.

                if (data.pDetails->PathType==DrwFilePath) // MH: don't touch the GPT for anything but Darwin files!
                    DeleteFile(data.szPath);

                if (data.type == DT_ASSIGNED)
                    *bAssigned = TRUE;


                hr = DeletePackageAndDependants(m_pIClassAdmin, (LPOLESTR)((LPCOLESTR) data.szName), data.pDetails);

                if (SUCCEEDED(hr))
                {
                    hr = m_pSnapin->m_pResult->DeleteItem(data.itemID, 0);
                    if (SUCCEEDED(hr))
                    {
                        m_AppData.erase(pInternal->m_cookie);
                        m_pSnapin->m_pResult->Sort(0, 0, -1);
                    }
                }
            }
        }
        FREE_INTERNAL(pInternal);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//

#if 0

STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{

    TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar);
        // Please don't delete this. Required to make sure we pick up the bitmap
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        if (pControlbar != NULL)
        {
            // Hold on to the controlbar interface.
            if (m_pControlbar)
            {
                m_pControlbar->Release();
            }

            m_pControlbar = pControlbar;
            m_pControlbar->AddRef();

            HRESULT hr=S_FALSE;

                // Create the Toolbar 1
            if (!m_pToolbar1)
            {
                hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pToolbar1));
                ASSERT(SUCCEEDED(hr));


                // Add the bitmap
                m_pbmpToolbar1 = new CBitmap;
                m_pbmpToolbar1->LoadBitmap(IDB_TOOLBAR1);
                hr = m_pToolbar1->AddBitmap(11, *m_pbmpToolbar1, 16, 16, RGB(255, 0, 255));
                ASSERT(SUCCEEDED(hr));

                // Add the buttons to the toolbar
                hr = m_pToolbar1->AddButtons(ARRAYLEN(SnapinButtons), SnapinButtons);
                ASSERT(SUCCEEDED(hr));
            }


            // TOOLBAR 2
            // Create the Toolbar 2
            if (!m_pToolbar2)
            {
                hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pToolbar2));
                ASSERT(SUCCEEDED(hr));

                // Add the bitmap
                m_pbmpToolbar2 = new CBitmap;
                m_pbmpToolbar2->LoadBitmap(IDB_TOOLBAR2);
                hr = m_pToolbar2->AddBitmap(36, *m_pbmpToolbar2, 16, 16, RGB(192,192,192));
                ASSERT(SUCCEEDED(hr));

                // Add the buttons to the toolbar
                hr = m_pToolbar2->AddButtons(ARRAYLEN(SnapinButtons2), SnapinButtons2);
                ASSERT(SUCCEEDED(hr));
            }
        }
        else
    {
        SAFE_RELEASE(m_pControlbar);
        }


    return S_OK;
}

STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, long arg, long param)
{
    HRESULT hr=S_FALSE;
        // Temp temp
        static BOOL bSwap=FALSE;

    switch (event)
    {
#if 0
    case MMCN_ACTIVATE:
        TRACE(_T("CSnapin::ControlbarNotify - MMCN_ACTIVATE\n"));
        // Need to handle this.
        // Verify that we can enable and disable buttons based on selection

        if (arg == TRUE)
        {
            m_pToolbar1->SetButtonState(3, BUTTONPRESSED, TRUE);
        }
        else
        {
            BOOL bState=FALSE;
            hr = m_pToolbar1->GetButtonState(3, BUTTONPRESSED, &bState);
            ASSERT(SUCCEEDED(hr));

            if (bState)
                m_pToolbar1->SetButtonState(3, BUTTONPRESSED, FALSE);
        }

        break;
#endif // 0

        case MMCN_BTN_CLICK:
        TRACE(_T("CSnapin::ControlbarNotify - MMCN_BTN_CLICK\n"));
                // Temp code
                TCHAR szMessage[MAX_PATH];
                wsprintf(szMessage,_T("CommandID %ld was not handled by the snapin!!!"),param);
                AfxMessageBox(szMessage);

                break;
        case MMCN_SELECT:
        TRACE(_T("CSnapin::ControlbarNotify - MMCN_SEL_CHANGE\n"));
                {
                        LPDATAOBJECT* ppDataObject = reinterpret_cast<LPDATAOBJECT*>(param);

                        // Attach the toolbars to the window
                        hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
                        ASSERT(SUCCEEDED(hr));

                        hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
                        ASSERT(SUCCEEDED(hr));

                }

        bSwap = !bSwap ;

        if (bSwap == TRUE)
        {
            m_pToolbar1->SetButtonState(1, ENABLED,       FALSE);  // 1 = CMD ID
            m_pToolbar1->SetButtonState(2, CHECKED,       TRUE);  // 2 = CMD ID
            m_pToolbar1->SetButtonState(3, HIDDEN,        TRUE);  // 3 = CMD ID
            m_pToolbar1->SetButtonState(4, INDETERMINATE, TRUE);  // 4 = CMD ID
            m_pToolbar1->SetButtonState(5, BUTTONPRESSED, TRUE);  // 5 = CMD ID

            // Just for fun let's add another style
            m_pToolbar1->SetButtonState(2, BUTTONPRESSED, TRUE);  // 4 = CMD ID
        }
        else
        {
            BOOL bState=FALSE;
            hr = m_pToolbar1->GetButtonState(1, ENABLED, &bState);
            ASSERT(SUCCEEDED(hr));

            if (bState == FALSE)
                m_pToolbar1->SetButtonState(1, ENABLED, TRUE);


            // Above is the correct way
            m_pToolbar1->SetButtonState(2, CHECKED,       FALSE);
            m_pToolbar1->SetButtonState(3, HIDDEN,        FALSE);
            m_pToolbar1->SetButtonState(4, INDETERMINATE, FALSE);
            m_pToolbar1->SetButtonState(5, BUTTONPRESSED, FALSE);

            // Better remove the additional style
            m_pToolbar1->SetButtonState(2, BUTTONPRESSED, FALSE);  // 4 = CMD ID

        }


        break;


    default:
        ASSERT(FALSE); // Unhandle event
    }

    return S_OK;
}
#endif

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectB);

    if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

    FREE_INTERNAL(pA);
    FREE_INTERNAL(pB);

    return hr;
}

STDMETHODIMP CSnapin::Compare(long lUserParam, long cookieA, long cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;

    *pnResult = 0;

    APP_DATA & dataA = m_pComponentData->m_AppData[cookieA];
    APP_DATA & dataB = m_pComponentData->m_AppData[cookieB];
    // compare the two based on column and the cookies

    switch (nCol)
    {
    case 0:
        *pnResult = dataA.szName.CompareNoCase(dataB.szName);
        break;
    case 1:
        *pnResult = dataA.szType.CompareNoCase(dataB.szType);
        break;
    case 2:
        *pnResult = dataA.pDetails->Locale - dataB.pDetails->Locale;
        break;
    case 3:
        *pnResult = dataA.szMach.CompareNoCase(dataB.szMach);
        break;
    case 4:
        *pnResult = dataA.szDesc.CompareNoCase(dataB.szDesc);
        break;
    case 5:
        *pnResult = dataA.szIconPath.CompareNoCase(dataB.szIconPath);
        break;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin


#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#include "objidl.h"
#include "data.h"
#include "amsp.h"
#include "gptedit.h"

// Note - This is the offset in my image list that represents the folder
const FOLDER_IMAGE_IDX = 0;
const OPEN_FOLDER_IMAGE_IDX = 5;
extern HINSTANCE ghInstance;

extern const CLSID CLSID_Snapin;
extern const wchar_t * szCLSID_Snapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;

/////////////////////////////////////////////////////////////////////////////
// Snapin

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);

class CComponentDataImpl:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public CComObjectRoot,
    public IAppManagerActions,
    public CComCoClass<CComponentDataImpl, &CLSID_Snapin>
{
BEGIN_COM_MAP(CComponentDataImpl)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY(IAppManagerActions)
END_COM_MAP()

DECLARE_REGISTRY(CSnapin, _T("AppManager.1"), _T("AppManager"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

    friend class CSnapin;
    friend class CDataObject;

        CComponentDataImpl();
        ~CComponentDataImpl();

protected:
    LPGPTINFORMATION    m_pIGPTInformation;  // Interface pointer to the GPT

public:
// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStreamInit interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);
    STDMETHOD(InitNew)(VOID);

public:
// IAppManagerActions,
    STDMETHOD(CanPackageBeAssigned)(ULONG cookie);
    STDMETHOD(MovePackageToAssigned)(ULONG cookie);
    STDMETHOD(MovePackageToPublished)(ULONG cookie);
    STDMETHOD(ReloadPackageData)(ULONG cookie);
    STDMETHOD(NotifyClients)(BOOL f);
// Notify handler declarations
private:
    HRESULT OnAdd(long cookie, long arg, long param);
    HRESULT OnDelete(long cookie, long arg, long param);
    HRESULT OnRename(long cookie, long arg, long param);
    HRESULT OnExpand(long cookie, long arg, long param);
    HRESULT OnSelect(long cookie, long arg, long param);
    HRESULT OnContextMenu(long cookie, long arg, long param);
    HRESULT OnProperties(long param);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    void DeleteList();
    void EnumerateScopePane(long cookie, HSCOPEITEM pParent);
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);
    HRESULT InitializeClassAdmin();
    HRESULT AddMSIPackage(LPDATAOBJECT pDataObject, LPSTR szPackagePath, LPSTR szFilePath,
                          LPOLESTR lpFileTitle, BOOL *bAssigned);
    HRESULT RemovePackage(LPDATAOBJECT pDataObject, BOOL *bAssigned);


private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE               m_pConsole;
    BOOL                    m_bIsDirty;
    IClassAdmin *           m_pIClassAdmin;
    BOOL m_fExtension;
    BOOL m_fLoaded;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(long cookie);
    HRESULT CreateApplicationDirectories(VOID);
    UINT CreateNestedDirectory (LPTSTR lpPath, LPSECURITY_ATTRIBUTES lpSecurityAttributes);

    CSnapin * m_pSnapin;

public:
    CString m_szGPT_Path;
    CString m_szLDAP_Path;
    CString m_szFolderTitle;
    std::map <long, APP_DATA> m_AppData;
    long m_lLastAllocated;
};

class CSnapin :
    public IComponent,
    public IExtendContextMenu,       // Step 3
//    public IExtendControlbar,
    public IExtendPropertySheet,
    public IResultDataCompare,
        public CComObjectRoot
{
public:
        CSnapin();
        ~CSnapin();

BEGIN_COM_MAP(CSnapin)
        COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)       // Step 3
//    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompare)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

// DECLARE_REGISTRY(CSnapin, _T("Snapin.Snapin.1"), _T("Snapin.Snapin"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

    friend class CDataObject;
    static long lDataObjectRefCount;


// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
    STDMETHOD(Destroy)(long cookie);
    STDMETHOD(GetResultViewType)(long cookie,  BSTR* ppViewType, LONG * pViewOptions);
    STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(long lUserParam, long cookieA, long cookieB, int* pnResult);

// IExtendControlbar
//    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
//    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, long arg, long param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
                        long handle,
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(long cookie, long arg, long param);
    HRESULT OnShow(long cookie, long arg, long param);
    HRESULT OnActivate(long cookie, long arg, long param);
    HRESULT OnMinimize(long cookie, long arg, long param);
    HRESULT OnSelect(DATA_OBJECT_TYPES type, long cookie, long arg, long param);
    HRESULT OnPropertyChange(long param); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(long cookie, BOOL fDblClick);
    HRESULT OnAddImages(long cookie, long arg, long param);

// IExtendContextMenu
public:
        STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, LONG * pInsertionAllowed);
        STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// End step 3

// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(long cookie);

    void Enumerate(long cookie, HSCOPEITEM pParent);
    HRESULT InitializeBitmaps(long cookie);

public:
    void EnumerateResultPane(long cookie);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    CComponentDataImpl * m_pComponentData;
    IPropertySheetProvider * m_pIPropertySheetProvider;
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb
    LONG                m_lViewMode;    // View mode
public:
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list


protected:
//    LPTOOLBAR           m_pToolbar1;    // Toolbar for view
//    LPTOOLBAR           m_pToolbar2;    // Toolbar for view
//    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars

//    CBitmap*    m_pbmpToolbar1;     // Imagelist for the first toolbar
//    CBitmap*    m_pbmpToolbar2;     // Imagelist for the first toolbar
    IClassAdmin * m_pIClassAdmin;
    IAppManagerActions * m_pIAppManagerActions;


// Header titles for each nodetype(s)
protected:
    CString m_column1;
    CString m_column2;
    CString m_column3;
    CString m_column4;
    CString m_column5;
    CString m_column6;
    CString m_column7;

    CString m_szAddApp;
    CString m_szDelApp;
    CString m_szUpdateApp;
    CString m_szAddFromIe;
    CString m_szShowData;
    CString m_szAddAppDesc;
    CString m_szDelAppDesc;
    CString m_szUpdateAppDesc;
    CString m_szAddFromIeDesc;
    CString m_szShowDataDesc;
    CString m_szFolderTitle;
    CString m_szRefresh;
    CString m_szRefreshDesc;
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    LPCOMPONENTDATA lpcd;
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&lpcd));
    ASSERT(hr == S_OK);
    m_pComponentData = dynamic_cast<CComponentDataImpl*>(lpcd);
    hr = pUnk->QueryInterface(IID_IAppManagerActions, reinterpret_cast<void**>(&m_pIAppManagerActions));
    ASSERT(hr == S_OK);
}


#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

class CHourglass
{
    private:
    HCURSOR m_hcurSaved;

    public:
    CHourglass()
    {
        m_hcurSaved = ::SetCursor(::LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    ~CHourglass()
    {
        ::SetCursor(m_hcurSaved);
    };
};

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\data.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       data.cpp
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:    CAppData
//
//  Functions:
//
//  History:    05-27-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//+--------------------------------------------------------------------------
//
//  Function:   SetStringData
//
//  Synopsis:   helper function to initialize strings that are based on
//              binary data
//
//  Arguments:  [pData] - pointer to structer to be modified
//
//  Returns:    0
//
//  Modifies:   szType, szMach, and szLoc
//
//  History:    05-27-1997   stevebl   Created
//
//  Notes:      This function is here to ensure that any routine that needs
//              to display this data in a user-friendly manner, will always
//              display it in a consistent fashion.
//
//              In other words, if the code needs to display this data in
//              more than one place, both places will display it in the same
//              way.
//
//---------------------------------------------------------------------------

long SetStringData(APP_DATA * pData)
{
    // Modifies szType, szLoc, and szMach.
    TCHAR szBuffer[256];
    ::LoadString(ghInstance, IDS_DATATYPES + (int)pData->type, szBuffer, 256);
    pData->szType = szBuffer;
    ::LoadString(ghInstance, IDS_OS + pData->pDetails->Platform.dwPlatformId + 1, szBuffer, 256);
    pData->szMach = szBuffer;
    wsprintf(szBuffer, _T(" %u.%u/"), pData->pDetails->Platform.dwVersionHi, pData->pDetails->Platform.dwVersionLo);
    pData->szMach += szBuffer;
    ::LoadString(ghInstance, IDS_HW + pData->pDetails->Platform.dwProcessorArch, szBuffer, 256);
    pData->szMach += szBuffer;
//    pData->szLoc.Format((LPCTSTR)_T("0x%lX"), pData->loc);
    GetLocaleInfo(pData->pDetails->Locale, LOCALE_SLANGUAGE, szBuffer, 256);
    pData->szLoc = szBuffer;
    GetLocaleInfo(pData->pDetails->Locale, LOCALE_SCOUNTRY, szBuffer, 256);
    pData->szLoc += _T(" - ");
    pData->szLoc += szBuffer;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\data.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       data.h
//
//  Contents:   Defines storage class that maintains data for snap-in nodes.
//
//  Classes:
//
//  Functions:  SetStringData
//
//  History:    5-27-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#ifndef _DATA_H_
#define _DATA_H_

#define _NEW_
#include <map>

typedef enum DEPLOYMENT_TYPES
{
    DT_ASSIGNED = 0,
    DT_PUBLISHED
} DEPLOYMENT_TYPE;

typedef struct tagAPP_DATA
{
    CString             szName;
    DEPLOYMENT_TYPE     type;
    CString             szType;
    CString             szPath;
    CString             szIconPath;
    CString             szLoc;
    CString             szMach;
    CString             szDesc;
    PACKAGEDETAIL       *pDetails;
    long                itemID;
    BOOL                fBlockDeletion;
} APP_DATA;

long SetStringData(APP_DATA * pData);

#endif // _DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject : public IDataObject, public CComObjectRoot 
{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() {};
    ~CDataObject() {};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;  
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfInternal; // Step 3

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        ++CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(long cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;    // Step 3
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

// Step 3
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }

        return hr;
}

// Note - Sample does not implement these
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
        return E_NOTIMPL;
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
        return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
                    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszNodeType, ((wcslen(cszNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_Snapin, sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\initdlg.cpp ===
// InitDlg.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInitDlg dialog


CInitDlg::CInitDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CInitDlg::IDD, pParent)
{
        //{{AFX_DATA_INIT(CInitDlg)
        m_szLDAP_Path = _T("");
        m_szGPT_Path = _T("");
        //}}AFX_DATA_INIT
}


void CInitDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CInitDlg)
        DDX_Text(pDX, IDC_EDIT1, m_szLDAP_Path);
        DDV_MaxChars(pDX, m_szLDAP_Path, 260);
        DDX_Text(pDX, IDC_EDIT2, m_szGPT_Path);
        DDV_MaxChars(pDX, m_szGPT_Path, 260);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInitDlg, CDialog)
        //{{AFX_MSG_MAP(CInitDlg)
                // NOTE: the ClassWizard will add message map macros here
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInitDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\initdlg.h ===
#if !defined(AFX_INITDLG_H__CA9BAE60_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_INITDLG_H__CA9BAE60_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InitDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInitDlg dialog

class CInitDlg : public CDialog
{
// Construction
public:
	CInitDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CInitDlg)
	enum { IDD = IDD_INITIALIZATION };
	CString	m_szLDAP_Path;
	CString	m_szGPT_Path;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CInitDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INITDLG_H__CA9BAE60_9A39_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\dmppkg.h ===
void
DumpOneClass(FILE * stream,  CLASSDETAIL * pClassDetail );

void
DumpOnePackage(
        FILE * stream,
        PACKAGEDETAIL * p,
        CLASSDETAIL * rgClassDetails);

void
DumpOneAppDetail(
        FILE * stream,
        APPDETAIL * pA,
        CLASSDETAIL * rgClassDetails);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT CSnapin::OnFolder(long cookie, long arg, long param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CSnapin::OnShow(long cookie, long arg, long param)
{
    HRESULT hr = S_OK;
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        ASSERT(m_pComponentData != NULL);
        hr = m_pComponentData->InitializeClassAdmin();
        if (SUCCEEDED(hr))
        {
            m_pResult->SetViewMode(m_lViewMode);
            InitializeHeaders(cookie);
            InitializeBitmaps(cookie);
            Enumerate(cookie, param);
        }

        // BUBBUG - Demonstration to should how you can attach
        // and a toolbar when a particular nodes gets focus.
        // warning this needs to be here as the toolbars are
        // currently hidden when the previous node looses focus.
        // This should be update to show the user how to hide
        // and show toolbars. (Detach and Attach).

        //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar1);
        //m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pToolbar2);
    }
    else
    {
        m_pResult->GetViewMode(&m_lViewMode);

        // BUGBUG - Demonstration this to show how to hide toolbars that
        // could be particular to a single node.
        // currently this is used to hide the toolbars the console
        // does not do any toolbar clean up.

        //m_pControlbar->Detach(m_pToolbar1);
        //m_pControlbar->Detach(m_pToolbar2);
        // Free data associated with the result pane items, because
        // your node is no longer being displayed.
        // Note: The console will remove the items from the result pane
    }

    return hr;
}

HRESULT CSnapin::OnActivate(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CSnapin::OnResultItemClkOrDblClk(long cookie, BOOL fDblClick)
{
    return S_OK;
}

HRESULT CSnapin::OnMinimize(long cookie, long arg, long param)
{
    return S_OK;
}

HRESULT CSnapin::OnSelect(DATA_OBJECT_TYPES type, long cookie, long arg, long param)
{
    if (m_pConsoleVerb)
    {
        // Set the default verb to open
        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


        // If this is one of our items, enable the properties verb.
        if (type == CCT_RESULT)
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
    }

    return S_OK;
}

HRESULT CSnapin::OnPropertyChange(long param)   // param is the cookie of the item that changed
{
    HRESULT hr = S_OK;
    m_pResult->Sort(0, 0, -1);
//    EnumerateResultPane(0);
    return hr;
}

HRESULT CSnapin::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CSnapin::Enumerate(long cookie, HSCOPEITEM pParent)
{
    EnumerateResultPane(cookie);
}

#define NUM_APPS 6

char * rgName[] = {
    "Application 1",
    "Application 2",
    "Word",
    "XL",
    "Access",
    "Notepad"
    };

char * rgPath[] = {
    "c:\\foo\\bar",
    "c:\\bar\\foo",
    "c:\\program files\\word",
    "c:\\program files\\excel",
    "c:\\program files\\access",
    "c:\\winnt\\notepad"
    };

long rgSize[] = {
    1000,
    2000,
    23000,
    34000,
    12034,
    100
    };

char * rgDescription[] = {
    "Description of app 1",
    "Description of app 2",
    "Word stuff",
    "Excel stuff",
    "Database stuff",
    "yeah, right"
    };

LCID rgLcid[] = {
    0,
    0,
    100,
    32,
    45,
    123,
    45
    };

DEPLOYMENT_TYPE rgDT[] = {
    DT_PUBLISHED,
    DT_PUBLISHED,
    DT_ASSIGNED,
    DT_ASSIGNED,
    DT_PUBLISHED,
    DT_ASSIGNED
    };

void CSnapin::EnumerateResultPane(long cookie)
{
    // put up an hourglass (this could take a while)
    CHourglass hourglass;

    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);
    ASSERT(m_pComponentData->m_pIClassAdmin != NULL);
    RESULTDATAITEM resultItem;
    memset(&resultItem, 0, sizeof(RESULTDATAITEM));

    // Right now we only have one folder and it only
    // contains a list of application packages so this is really simple.

    if (m_pComponentData->m_AppData.begin() == m_pComponentData->m_AppData.end())  // test to see if the data has been initialized
    {
        IClassAdmin * pICA = m_pComponentData->m_pIClassAdmin;
        m_pIClassAdmin = pICA;
        CSPLATFORM csPlatform;
        memset(&csPlatform, 0, sizeof(CSPLATFORM));

        IEnumPackage * pIPE = NULL;

        HRESULT hr = pICA->GetPackagesEnum(
                            GUID_NULL,
                            NULL,
                            csPlatform,
                            0,
                            0,
                            &pIPE);
        if (SUCCEEDED(hr))
        {
            hr = pIPE->Reset();
            while (SUCCEEDED(hr))
            {
                ULONG nceltFetched;
                PACKAGEDETAIL * pd = new PACKAGEDETAIL;

                hr = pIPE->Next(1, pd, &nceltFetched);
                if (nceltFetched)
                {
                    APP_DATA data;
                    data.szName = pd->pszPackageName;
                    if (pd->dwActFlags & ACTFLG_Assigned)
                    {
                        data.type = DT_ASSIGNED;
                    }
                    else
                    {
                        data.type = DT_PUBLISHED;
                    }

                    data.szPath = pd->pszPath;
                    data.szIconPath = pd->pszIconPath;
                    data.szDesc = pd->pszProductName;
                    data.pDetails = pd;
                    data.fBlockDeletion = FALSE;
                    SetStringData(&data);
                    m_pComponentData->m_AppData[++m_pComponentData->m_lLastAllocated] = data;
                }
                else
                {
                    break;
                }
            }
            SAFE_RELEASE(pIPE);
        }
    }
    std::map<long, APP_DATA>::iterator i = m_pComponentData->m_AppData.begin();
    while (i != m_pComponentData->m_AppData.end())
    {
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.str = MMC_CALLBACK;
        resultItem.nImage = 1;
        resultItem.lParam = i->first;
        m_pResult->InsertItem(&resultItem);
        i->second.itemID = resultItem.itemID;
        i++;
    }

    m_pResult->Sort(0, 0, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\dmppkg.cxx ===
#include "precomp.hxx"

char *
StringToULong(
    char * pString,
    unsigned long * pNumber )
    {
    unsigned long Number;
    int           Count;

    // There will be 8 characters int a string that converts into a long.

    for( Count = 0; Count < 8; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }

char *
StringToUShort(
    char          * pString,
    unsigned short * pNumber )
    {
    unsigned short Number;
    int           Count;

    // There will be 4 characters int a string that converts into a short.

    for( Count = 0; Count < 4; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }
char *
StringToUChar(
    char          * pString,
    unsigned char * pNumber )
    {
    unsigned char Number;
    int           Count;

    // There will be 2 characters int a string that converts into a char.

    for( Count = 0; Count < 2; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }

char *
StringToCLSID(
    char    *   pString,
    CLSID   *   pClsid )
    {

    pString = StringToULong( pString, &pClsid->Data1 );
    pString++; // skip -

    pString = StringToUShort( pString, &pClsid->Data2 );
    pString++; // skip -

    pString = StringToUShort( pString, &pClsid->Data3 );
    pString++; // skip -

    pString = StringToUChar( pString, &pClsid->Data4[0] );
    pString = StringToUChar( pString, &pClsid->Data4[1] );
    pString++; // skip -

    pString = StringToUChar( pString, &pClsid->Data4[2] );
    pString = StringToUChar( pString, &pClsid->Data4[3] );
    pString = StringToUChar( pString, &pClsid->Data4[4] );
    pString = StringToUChar( pString, &pClsid->Data4[5] );
    pString = StringToUChar( pString, &pClsid->Data4[6] );
    pString = StringToUChar( pString, &pClsid->Data4[7] );

    return pString;
    }

void
CLSIDToString(
    CLSID * pClsid,
    char  * pString )
    {
    sprintf( pString,
             "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             pClsid->Data1,
             pClsid->Data2,
             pClsid->Data3,
             pClsid->Data4[0],
             pClsid->Data4[1],
             pClsid->Data4[2],
             pClsid->Data4[3],
             pClsid->Data4[4],
             pClsid->Data4[5],
             pClsid->Data4[6],
             pClsid->Data4[7] );
    }

void
DumpOneClass(FILE * stream, CLASSDETAIL * pClassDetail )
        {
        char  Buffer[ _MAX_PATH ];
        DWORD count;

        CLSIDToString( &pClassDetail->Clsid, &Buffer[0] );
        fprintf(stream, "\n\t\t\tCLSID = %s", &Buffer[0] );


        fwprintf(stream, L"\n\t\t\tDescription = %s", pClassDetail->pszDesc );
        fwprintf(stream, L"\n\t\t\tIconPath = %s", pClassDetail->pszIconPath );

//        CLSIDToString( &pClassDetail->TypelibID, &Buffer[0] );
//        fprintf(stream, "\n\t\t\tTypelibID = %s", &Buffer[0] );

        CLSIDToString( &pClassDetail->TreatAsClsid, &Buffer[0] );
        fprintf(stream, "\n\t\t\tTreatAsClsid = %s", &Buffer[0] );

        CLSIDToString( &pClassDetail->AutoConvertClsid, &Buffer[0] );
        fprintf(stream, "\n\t\t\tAutoConvertClsid = %s", &Buffer[0] );

        if( pClassDetail->cFileExt )
                {
                for(count = 0;
                        count < pClassDetail->cFileExt;
                        count++
                        )
                        {
                        fwprintf(stream, L"\n\t\t\tFileExt = %s", pClassDetail->prgFileExt[ count ] );
                        }
                }
        else
                {
                fprintf(stream, "\n\t\t\tOtherFileExt = None" );
                }

        fwprintf(stream, L"\n\t\t\tMimeType = %s", pClassDetail->pMimeType );
        fwprintf(stream, L"\n\t\t\tDefaultProgid = %s", pClassDetail->pDefaultProgId );

        if( pClassDetail->cOtherProgId )
                {
                for(count = 0;
                        count < pClassDetail->cOtherProgId;
                        count++
                        )
                        {
                        fwprintf(stream, L"\n\t\t\tOtherProgId = %s", pClassDetail->prgOtherProgId[ count ] );
                        }
                }
        else
                {
                fprintf(stream, "\n\t\t\tOtherProgId = None" );
                }
        fprintf(stream, "\n");

        }

void
DumpOnePackage(
        FILE * stream,
        PACKAGEDETAIL * p,
        CLASSDETAIL * rgClassDetails)
        {
        DWORD count;

//        fprintf(stream, "\n++++++++++++++++++++++++++++++++++++++++++++++++++");

        fprintf(stream, "ClassPathType = %d", p->PathType );
        fwprintf(stream, L"\nPackagePath = %s", p->pszPath );
        fwprintf(stream, L"\nIconPath = %s", p->pszIconPath );
        fwprintf(stream, L"\nSetup Command = %s", p->pszSetupCommand );
        fprintf(stream, "\nActFlags = %d", p->dwActFlags );
        fwprintf(stream, L"\nVendor = %s", p->pszVendor );
        fwprintf(stream, L"\nPackageName = %s", p->pszPackageName );
        fwprintf(stream, L"\nProductName = %s", p->pszProductName );
        fwprintf(stream, L"\ndwContext = %d", p->dwContext );
        fwprintf(stream, L"\nPlatform.dwProcessorArch = 0x%x", p->Platform.dwProcessorArch );
        fwprintf(stream, L"\ndwLocale = 0x%x", p->Locale );
        fwprintf(stream, L"\ndwVersionHi = %d", p->dwVersionHi );
        fwprintf(stream, L"\ndwVersionLo = %d", p->dwVersionLo );
        fwprintf(stream, L"\nCountOfApps = %d", p->cApps );

        for( count = 0;
                 count < p->cApps;
                 ++count )
                {
                DumpOneAppDetail(stream, &p->pAppDetail[count], rgClassDetails);
                // advance to the set of class detail structures for the next app
                rgClassDetails += p->pAppDetail[count].cClasses;
                }
//        fprintf(stream, "\n--------------------------------------------------");
        }


void
DumpOneAppDetail(
        FILE * stream,
        APPDETAIL * pA,
        CLASSDETAIL * rgClassDetails)
        {
        char Buffer[ 100 ];
        DWORD count;


        CLSIDToString( &pA->AppID, &Buffer[0] );
        fprintf(stream, "\n\t\tAPPID = %s", &Buffer[0] );

        if( pA->cClasses )
                {
                for( count = 0;
                         count < pA->cClasses;
                         ++count )
                        {
                        DumpOneClass(stream, &rgClassDetails[count]);
                        }
                }
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\snapin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Oct 03 17:06:29 1996
 */
/* Compiler settings for Snapin.idl:
    Os, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Snapin_h__
#define __Snapin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponent
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IComponent : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IComponent_INTERFACE_DEFINED__ */



#ifndef __SNAPINLib_LIBRARY_DEFINED__
#define __SNAPINLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SNAPINLib
 * at Thu Oct 03 17:06:29 1996
 * using MIDL 3.00.15
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SNAPINLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Snapin;

class Snapin;
#endif
#endif /* __SNAPINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\genpage.cpp ===
// genpage.cpp : implementation file
//

#include "precomp.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage property page

IMPLEMENT_DYNCREATE(CGeneralPage, CPropertyPage)

CGeneralPage::CGeneralPage() : CPropertyPage(CGeneralPage::IDD)
{
    //{{AFX_DATA_INIT(CGeneralPage)
    m_szName = _T("");
    m_szDeploy = _T("");
    m_szDescription = _T("");
    m_szLocale = _T("");
    m_szPath = _T("");
    m_szVer = _T("");
    m_fShow = TRUE;
    //}}AFX_DATA_INIT

    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
}

CGeneralPage::~CGeneralPage()
{
}

void CGeneralPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGeneralPage)
    DDX_Control(pDX, IDC_DEPLOY, m_cbDeploy);
    DDX_CBString(pDX, IDC_DEPLOY, m_szDeploy);
    DDX_Text(pDX, IDC_NAME, m_szName);
    DDX_Text(pDX, IDC_DESCRIPTION, m_szDescription);
    DDX_Text(pDX, IDC_LOCALE, m_szLocale);
    DDX_Text(pDX, IDC_PATH, m_szPath);
    DDX_Text(pDX, IDC_VERSION, m_szVer);
    DDX_Control(pDX, IDC_CPU, m_cbCPU);
    DDX_Control(pDX, IDC_OS, m_cbOS);
    DDX_Check(pDX, IDC_CHECK1, m_fShow);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGeneralPage, CPropertyPage)
    //{{AFX_MSG_MAP(CGeneralPage)
    ON_WM_DESTROY()
    ON_EN_CHANGE(IDC_NAME, OnChangeName)
    ON_EN_CHANGE(IDC_PATH, OnChangePath)
    ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
    ON_BN_CLICKED(IDC_CHECK1, OnChangeShow)
    ON_CBN_SELCHANGE(IDC_DEPLOY, OnSelchangeDeploy)
    ON_CBN_SELCHANGE(IDC_OS, OnChangeOS)
    ON_CBN_SELCHANGE(IDC_CPU, OnChangeCPU)
    ON_EN_CHANGE(IDC_VERSION, OnChangeVersion)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage message handlers

void CGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    MMCFreeNotifyHandle(m_hConsoleHandle);

    CPropertyPage::OnDestroy();

    m_pData->fBlockDeletion = FALSE;

    // Delete the CGeneralPage object
    delete this;
}



BOOL CGeneralPage::OnApply()
{
    if (m_pIAppManagerActions == NULL || m_pIClassAdmin == NULL)
    {
        return FALSE;
    }
    // put up an hourglass (this could take a while)
    CHourglass hourglass;

    CString szNewScriptPath;
    CString szOldScriptPath;

    HRESULT hr;
    if (m_bUpdate == TRUE)
    {
        PACKAGEDETAIL NewDetails;
        memcpy(&NewDetails, m_pData->pDetails, sizeof(PACKAGEDETAIL));

        // UNDONE - validate the data

        NewDetails.pszPackageName = (LPOLESTR) ((LPCTSTR)m_szName);

        swscanf((LPOLESTR)((LPCTSTR)m_szVer), _T("%u.%u"),&(NewDetails.Platform.dwVersionHi),&(NewDetails.Platform.dwVersionLo));
        NewDetails.Platform.dwPlatformId = m_cbOS.GetCurSel();
        NewDetails.Platform.dwProcessorArch = m_cbCPU.GetCurSel() == 1 ? PROCESSOR_ARCHITECTURE_ALPHA : PROCESSOR_ARCHITECTURE_INTEL;

        NewDetails.dwActFlags = (m_pData->pDetails->dwActFlags & (! (ACTFLG_Published | ACTFLG_Assigned | ACTFLG_UserInstall)));
        BOOL fAssign = FALSE;
        if (m_szDeploy == m_szPublished)
        {
            NewDetails.dwActFlags |= ACTFLG_Published;
        }
        else
        {
            NewDetails.dwActFlags |= ACTFLG_Assigned;
            fAssign = TRUE;
        }

        NewDetails.dwActFlags |= ((!m_fShow) ? 0 : ACTFLG_UserInstall);
        BOOL fMoveScript = (NewDetails.dwActFlags & (ACTFLG_Assigned | ACTFLG_Published))
            != (m_pData->pDetails->dwActFlags & (ACTFLG_Assigned | ACTFLG_Published))
            || (NewDetails.Platform.dwProcessorArch != m_pData->pDetails->Platform.dwProcessorArch);
        if (fMoveScript)
        {
            // Find out if script file can in fact be moved
            BOOL fCanMoveScript = FALSE;

            szOldScriptPath = m_pData->szPath;
            CString szTemp = szOldScriptPath;
            szTemp.MakeLower();
            int i = szTemp.Find(_T("\\published\\"));
            if (i < 0)
            {
                i = szTemp.Find(_T("\\assigned\\")); // cover all the bases
            }
            if (i >= 0)
            {
                // finally make sure it's got an .aas extension
                if (szTemp.Right(4) == _T(".aas"))
                {
                    DWORD dwAttributes =  GetFileAttributes(m_pData->szPath);
                    if ((dwAttributes != 0xffffffff) && ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
                    {
                        fCanMoveScript = TRUE;
                    }
                }
            }
            if (fCanMoveScript)
            {
                // Build new path

                szNewScriptPath = szOldScriptPath;
                // Strip off everything up to "\\published" or "\\assigned"
                szNewScriptPath = szNewScriptPath.Left(i);
                szNewScriptPath +=
                    (NewDetails.dwActFlags & ACTFLG_Assigned) != 0
                    ? _T("\\Assigned") : _T("\\Published");
                szNewScriptPath +=
                    NewDetails.Platform.dwProcessorArch == PROCESSOR_ARCHITECTURE_ALPHA
                    ? _T("\\Alpha\\") : _T("\\x86\\");
                {
                    TCHAR Name [_MAX_FNAME];
                    TCHAR Ext [_MAX_EXT];
                    TCHAR ScriptNameAndPath[_MAX_PATH ];
                    _tsplitpath( szOldScriptPath, NULL, NULL, Name, Ext );

                    szNewScriptPath += Name;
                    szNewScriptPath += Ext;
                }

                // Try and move it

                if (!MoveFileEx(szOldScriptPath,
                                szNewScriptPath,
                                MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH))
                {
                    // wasn't moved
                    fMoveScript = FALSE;

                    // UNDONE - put up a message that the scrip file wasn't moved?
                }
                else
                {
                    m_pData->szPath = szNewScriptPath;
                    NewDetails.pszPath = (LPOLESTR)(LPCOLESTR)m_pData->szPath;
                }
            }
            else
            {
                // wasn't moved so make sure we don't try and move it back later
                fMoveScript = FALSE;
            }
        }

        NewDetails.pszProductName = (LPOLESTR) ((LPCTSTR)m_szDescription);

        BOOL fPathChanged = m_szPath != m_pData->szIconPath;
        BOOL fChangeBoth = 0 == wcscmp(m_pData->pDetails->pszPath, m_pData->pDetails->pszIconPath);
        if (fPathChanged)
        {
            // user changed the path
            NewDetails.pszIconPath = (LPOLESTR)((LPCTSTR)m_szPath);
            if (fChangeBoth)
            {
                NewDetails.pszPath = (LPOLESTR)((LPCTSTR)m_szPath);
            }
        }


        hr = m_pIClassAdmin->DeletePackage(m_pData->pDetails->pszPackageName);
        if (SUCCEEDED(hr))
        {
            hr = m_pIClassAdmin->NewPackage(&NewDetails);
        }
        if (FAILED(hr))
        {
            if (fMoveScript)
            {
                // changed location for deployment back to what it was
                // before we failed to change the info in the class store
                // (Note that we're assuming that if we could change it one way
                // we can change it back.)

                if (MoveFileEx(szNewScriptPath,
                               szOldScriptPath,
                               MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH))
                {
                    m_pData->szPath = szOldScriptPath;
                    m_pData->pDetails->pszPath = (LPOLESTR)(LPCOLESTR)m_pData->szPath;
                }

            }
            hr = m_pIClassAdmin->NewPackage(m_pData->pDetails);
            // need to move this message
            ::MessageBox(NULL,
                         L"Couldn't apply changes.  Verify that the class store's server is active.",
                         L"ERROR",
                         MB_OK);
            return FALSE;
        }
        else
        {
            if (fMoveScript)
            {
                // Notify clients of change
                if (m_pIAppManagerActions)
                {
                    m_pIAppManagerActions->NotifyClients(FALSE);
                }
            }
        }

        memcpy(m_pData->pDetails, &NewDetails, sizeof(PACKAGEDETAIL));
        if (m_pData->pDetails->dwActFlags & ACTFLG_Assigned)
        {
            m_pData->type = DT_ASSIGNED;
        }
        else
        {
            m_pData->type = DT_PUBLISHED;
        }
        m_pData->szType = m_szDeploy;
        // Up above, we set NewDetails.pszPackageName to m_szName.
        // We can't leave it set to that because m_szName is a member
        // variable of this property sheet class object and will be released
        // when the property sheet goes away.  We need to copy it to
        // m_pData->szName (which is a CString and therefore has it's own
        // memory store) and then set the details back to it so it doesn't
        // get freed from under us.
        m_pData->szName = m_szName;
        m_pData->pDetails->pszPackageName = (LPOLESTR)((LPCTSTR)m_pData->szName);
        // same problem with szDesc
        m_pData->szDesc = m_szDescription;
        m_pData->pDetails->pszProductName = (LPOLESTR)((LPCTSTR)m_pData->szDesc);
        if (fPathChanged)
        {
            m_pData->szIconPath = m_szPath;
            m_pData->pDetails->pszIconPath = (LPOLESTR)((LPCTSTR)m_pData->szIconPath);
            // user changed the path
            if (fChangeBoth)
            {
                m_pData->szPath = m_szPath;
                m_pData->pDetails->pszPath = (LPOLESTR)((LPCTSTR)m_pData->szIconPath);
            }
        }
        if (m_szPath != m_pData->szIconPath)
        {
            // user changed the path
            if (wcscmp(m_pData->pDetails->pszPath, m_pData->pDetails->pszIconPath))
            {
                // If the paths were the same to start with then change 'em both.
                m_pData->szPath = m_szPath;
                m_pData->pDetails->pszPath = (LPOLESTR)((LPCTSTR)m_pData->szPath);
            }
            m_pData->szIconPath = m_szPath;
            m_pData->pDetails->pszIconPath = (LPOLESTR)((LPCTSTR)m_pData->szIconPath);
        }

        SetStringData(m_pData);

        MMCPropertyChangeNotify(m_hConsoleHandle, (long) m_cookie);

        m_bUpdate = FALSE;
    }

    return CPropertyPage::OnApply();
}

BOOL CGeneralPage::OnInitDialog()
{
    TCHAR szBuffer[256];
    m_pData->fBlockDeletion = TRUE;
    m_szName = m_pData->szName;
    m_szDescription = m_pData->szDesc;
    m_szLocale = m_pData->szLoc;
    m_szPath = m_pData->szIconPath;
    m_szDeploy = m_pData->szType;
    wsprintf(szBuffer, _T("%u.%u"), m_pData->pDetails->Platform.dwVersionHi, m_pData->pDetails->Platform.dwVersionLo);
    m_szVer = szBuffer;
    m_fShow =  m_pData->pDetails->dwActFlags & ACTFLG_UserInstall ? 1 : 0;
    CPropertyPage::OnInitDialog();

    // unmarshal the IAppManagerActions interface
    HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStreamAM, IID_IAppManagerActions, (void **) &m_pIAppManagerActions);
    if (!SUCCEEDED(hr))
    {
#if DBG == 1
        ::MessageBox(NULL,
                     L"Couldn't marshal IAppManagerActions",
                     L"DEBUG ERROR",
                     MB_OK);
#endif
        m_pIAppManagerActions = NULL;
        return FALSE;
        // BUGBUG - what should I do here?  Disallow changes?
    }

    // unmarshal the IClassAdmin interface
    hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);
    if (!SUCCEEDED(hr))
    {
#if DBG == 1
        ::MessageBox(NULL,
                     L"Couldn't marshal IClassAdmin",
                     L"DEBUG ERROR",
                     MB_OK);
#endif
        m_pIClassAdmin = NULL;
        // BUGBUG - what should I do here?  Disallow changes?
    }

    ::LoadString(ghInstance, IDS_DATATYPES, szBuffer, 256);
    m_szAssigned = szBuffer;
    // Test to be sure it can be assigned.
    // If it's not a Darwin package then it can't be assigned and
    // the option won't even be presented to the user.

    if (m_pIAppManagerActions)
    {
        hr = m_pIAppManagerActions->CanPackageBeAssigned(m_cookie);
    }
    if (hr == ERROR_SUCCESS)
    {
        m_cbDeploy.AddString(szBuffer);
    }
    ::LoadString(ghInstance, IDS_DATATYPES+1, szBuffer, 256);
    m_szPublished = szBuffer;
    m_cbDeploy.AddString(szBuffer);
    m_cbDeploy.SelectString(0, m_szDeploy);

    int i;
    for (i = 0; i < (sizeof(m_rgszOS) / sizeof(m_rgszOS[0])); i++)
    {
        ::LoadString(ghInstance, IDS_OS + i + 1, szBuffer, 256);
        m_rgszOS[i] = szBuffer;
        m_cbOS.AddString(szBuffer);
    }
    m_cbOS.SetCurSel(m_pData->pDetails->Platform.dwPlatformId);

    for (i = 0; i < (sizeof(m_rgszCPU) / sizeof(m_rgszCPU[0])); i++)
    {
        ::LoadString(ghInstance, IDS_HW + (i == 0 ? PROCESSOR_ARCHITECTURE_INTEL : PROCESSOR_ARCHITECTURE_ALPHA), szBuffer, 256);
        m_rgszCPU[i] = szBuffer;
        m_cbCPU.AddString(szBuffer);
    }
    m_cbCPU.SetCurSel(m_pData->pDetails->Platform.dwProcessorArch == PROCESSOR_ARCHITECTURE_ALPHA ? 1 : 0);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CGeneralPage::OnChangeShow()
{
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CPropertyPage::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.

    // TODO: Add your control notification handler code here

    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangePath()
{
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeCPU()
{
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeOS()
{
    TCHAR * rgszVer[] =
    {
        _T("3.1"),
        _T("4.1"),
        _T("5.0")
    };
    int i = m_cbOS.GetCurSel();
    m_szVer = rgszVer[i];
    GetDlgItem(IDC_VERSION)->SetWindowText(m_szVer);
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeVersion()
{
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeName()
{
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CPropertyPage::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.

    // TODO: Add your control notification handler code here

    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnChangeDescription()
{
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CPropertyPage::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.

    // TODO: Add your control notification handler code here
    SetModified();
    m_bUpdate = TRUE;
}

void CGeneralPage::OnSelchangeDeploy()
{
    // TODO: Add your control notification handler code here
    SetModified();
    m_bUpdate = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\pkgdtl.cpp ===
// pkgdtl.cpp : implementation file
//

#include "precomp.hxx"

#include "fcntl.h"
#include "io.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails property page

IMPLEMENT_DYNCREATE(CPackageDetails, CPropertyPage)

CPackageDetails::CPackageDetails() : CPropertyPage(CPackageDetails::IDD)
{
        //{{AFX_DATA_INIT(CPackageDetails)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_hConsoleHandle = NULL;
}

CPackageDetails::~CPackageDetails()
{
}

void CPackageDetails::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CPackageDetails)
        DDX_Control(pDX, IDC_LIST1, m_cList);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPackageDetails, CPropertyPage)
        //{{AFX_MSG_MAP(CPackageDetails)
        ON_WM_DESTROY()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails message handlers

void CPackageDetails::OnDestroy()
{
        MMCFreeNotifyHandle(m_hConsoleHandle);

        CPropertyPage::OnDestroy();

        // Delete the CPackageDetails object
        delete this;
}

// removes tabs and \n characters
void Convert(WCHAR * wsz, CString &sz)
{
    sz="";

    int iIn=0;
    int iOut=0;
    WCHAR ch;
    while (ch = wsz[iIn++])
    {
        switch (ch)
        {
        case L'\t':
            iOut++;
            sz += ' ';
            while (iOut % 4)
            {
                iOut++;
                sz += ' ';
            }
            break;
        case L'\n':
            break;
        default:
            iOut++;
            sz += ch;
            break;
        }
    }
}

BOOL CPackageDetails::OnInitDialog()
{
        CPropertyPage::OnInitDialog();

        m_cList.ResetContent();

        HRESULT hr = CoGetInterfaceAndReleaseStream(m_pIStream, IID_IClassAdmin, (void **) &m_pIClassAdmin);

        if (SUCCEEDED(hr))
        {
            // compute the number of CLASSDETAIL elements that
            // need to be fetched

            ULONG cCD = 0;
            ULONG nApp;
            for (nApp = 0; nApp < m_pData->pDetails->cApps; nApp++)
            {
                cCD += m_pData->pDetails->pAppDetail[nApp].cClasses;
            }

            // allocate them and fetch the list
            CLASSDETAIL * rgCD = new CLASSDETAIL[cCD];
            CLASSDETAIL * rgClassDetail = rgCD;

            // BUGBUG - put error checking in here!

            for (nApp = 0; nApp < m_pData->pDetails->cApps; nApp++)
            {
                ULONG nClass;
                for (nClass = 0; nClass < m_pData->pDetails->pAppDetail[nApp].cClasses; nClass++)
                {
                    hr = m_pIClassAdmin->GetClassDetails(m_pData->pDetails->pAppDetail[nApp].prgClsIdList[nClass], rgCD);
                    // advance to next CLASSDETAIL structure
                    rgCD++;
                }
            }

            FILE * stream = tmpfile();
            _setmode(_fileno(stream), _O_TEXT);
            if (m_pData->pDetails)
            {
                DumpOnePackage(stream,
                    m_pData->pDetails,
                    rgClassDetail);
            }
            rewind(stream);
            WCHAR wsz[256];
            CString szTemp;
            int cWidth = 0;
            m_cList.ResetContent();
            while (fgetws(wsz, 256, stream))
            {
                Convert(wsz, szTemp);
                CSize csExtent = m_cList.GetDC()->GetTextExtent(szTemp);
                m_cList.GetDC()->LPtoDP(&csExtent);
                if (cWidth < csExtent.cx)
                {
                    cWidth = csExtent.cx;
                }
                m_cList.AddString(szTemp);
            }
            m_cList.SetHorizontalExtent(cWidth);
            fclose(stream);
        }

        return TRUE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_PATH                        5
#define IDS_LOC                         6
#define IDS_MACH                        7
#define IDS_DESC                        8
#define IDS_NODENAME                    9
#define IDS_ADD_APP_DESC                10
#define IDS_ADD_FROM_IE_DESC            11
#define IDS_DEL_APP_DESC                12
#define IDS_UPDATE_APP_DESC             13
#define IDS_FOLDER_TITLE                14
#define IDS_REFRESH_DESC                15
#define IDS_DATATYPES                   20
#define IDS_ARCHITECTURES               30
#define IDD_GENERAL                     107
#define IDC_NAME                        201
#define IDB_16x16                       202
#define IDC_EDIT1                       202
#define IDB_32x32                       203
#define IDC_LIST1                       203
#define IDC_EDIT2                       203
#define IDC_DEPLOY                      204
#define IDI_FOLDER                      205
#define IDC_CPU                         205
#define IDC_DESCRIPTION                 206
#define IDB_TOOLBAR1                    207
#define IDC_PATH                        207
#define IDB_TOOLBAR2                    208
#define IDC_LOCALE                      208
#define IDD_INITIALIZATION              209
#define IDC_BROWSE                      209
#define IDD_PACKAGE_DETAILS             210
#define IDC_CHECK1                      210
#define IDC_OS                          211
#define IDC_VERSION                     212
#define IDM_ADD_APP                     300
#define IDM_ADD_FROM_IE                 301
#define IDM_REFRESH                     302
#define IDM_UPDATE_APP                  303
#define IDM_DEL_APP                     304
#define IDS_DEF_EXTENSION               305
#define IDS_EXTENSION_FILTER            306
#define IDS_CSADMINFAILED               307
#define IDS_GPTFAILED                   308
#define IDS_ADDFAILED                   309
#define IDS_CABCAPTION                  310
#define IDS_CABWARNING                  311
#define IDS_URLMONERROR                 312
#define IDS_CLASSSTOREERROR             313
#define IDS_SPAWNMSG                    314
#define IDS_SPAWNCAPTION                315
#define IDS_NOCOMSVR                    316
#define IDS_ADDEXISTSALREADY            317
#define IDS_CLSIDCONFLICT1              318
#define IDS_CLSIDCONFLICT2              319
#define IDS_BOGUS_EXTENSION             320
#define IDS_OS                          400
#define IDS_HW                          410

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        211
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         211
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\pkgdtl.h ===
#if !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
#define AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// pkgdtl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPackageDetails dialog

class CPackageDetails : public CPropertyPage
{
        DECLARE_DYNCREATE(CPackageDetails)

// Construction
public:
        CPackageDetails();
        ~CPackageDetails();

// Dialog Data
        //{{AFX_DATA(CPackageDetails)
        enum { IDD = IDD_PACKAGE_DETAILS };
        CListBox        m_cList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CPackageDetails)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CPackageDetails)
        afx_msg void OnDestroy();
        virtual BOOL OnInitDialog();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        public:
            long    m_hConsoleHandle; // Handle given to the snap-in by the console
            IStream * m_pIStream;     // copy of the pointer to the marshalling stream for unmarshalling IClassAdmin
            IClassAdmin * m_pIClassAdmin;
            APP_DATA * m_pData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PKGDTL_H__BB970E11_9CA4_11D0_8D3F_00A0C90DCAE7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\genpage.h ===
// genpage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage dialog

class CGeneralPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CGeneralPage)

// Construction
public:
        CGeneralPage();
        ~CGeneralPage();

// Dialog Data
        //{{AFX_DATA(CGeneralPage)
        enum { IDD = IDD_GENERAL };
        CComboBox       m_cbDeploy;
        CComboBox       m_cbOS;
        CComboBox       m_cbCPU;
        CString m_szName;
        CString m_szDeploy;
        CString m_szDescription;
        CString m_szLocale;
        CString m_szPath;

        // to remember the strings placed in the combo box for later comparison:
        CString m_szPublished;
        CString m_szAssigned;

        // to remember the strings in the CPU combo box
        CString m_rgszCPU[2];
        CString m_rgszOS[3];

        APP_DATA * m_pData;
        DWORD   m_cookie;
        CString m_szVer;
        IStream * m_pIStream;     // copy of the pointer to the marshalling stream for unmarshalling IClassAdmin
        IClassAdmin * m_pIClassAdmin;
        IStream * m_pIStreamAM;
        IAppManagerActions * m_pIAppManagerActions;
        int    m_fShow;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CGeneralPage)
        public:
        virtual BOOL OnApply();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CGeneralPage)
        afx_msg void OnDestroy();
        virtual BOOL OnInitDialog();
        afx_msg void OnChangeName();
        afx_msg void OnChangeVersion();
        afx_msg void OnChangeOS();
        afx_msg void OnChangeCPU();
        afx_msg void OnChangePath();
        afx_msg void OnChangeDescription();
        afx_msg void OnSelchangeDeploy();
        afx_msg void OnChangeShow();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

public:
    long    m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#include "safereg.hxx"


//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;
    ULONG   ulType;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszPathBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    *pwszBuf = L'\0'; // init for failure case

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
    }
    else if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\snapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL,
//              run nmake -f Snapinps.mak in the project directory.

#include "precomp.hxx"

#include "safereg.hxx"
#include "amsp.h"

#define BREAK_ON_FAIL_HRESULT(hr) if (FAILED(hr)) break

#define PSBUFFER_STR    L"AppManagementBuffer"
#define THREADING_STR   L"Apartment"

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Snapin, CComponentDataImpl)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CSnapinApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSnapinApp theApp;

HINSTANCE ghInstance;

BOOL CSnapinApp::InitInstance()
{
        ghInstance = m_hInstance;
        _Module.Init(ObjectMap, m_hInstance);
        return CWinApp::InitInstance();
}

int CSnapinApp::ExitInstance()
{
        _Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
    DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI amspDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    if (IsEqualCLSID(rclsid, CLSID_Snapin))
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }
    return amspDllGetClassObject(rclsid, riid, ppv);
}

const wchar_t * szGPT_Snapin = L"{2C8C9b20-96AD-11d0-8C54-121767000000}";

const wchar_t * szGPT_Namespace = L"{A6B4EEBC-B681-11d0-9484-080036B11A03}";
const wchar_t * szAppName = L"Application Manager";
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    CSafeReg    shk;
    CSafeReg    shkCLSID;
    CSafeReg    shkServer;
    CSafeReg    shkTemp;
    HRESULT hr = S_OK;
    do
    {
        hr =  _Module.RegisterServer(FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        // register extension
/*
extern const CLSID CLSID_Snapin;
extern const wchar_t * szCLSID_Snapin;
extern const GUID cNodeType;
extern const wchar_t*  cszNodeType;
*/
        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\SnapIns", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szGPT_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"RequiredExtensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(szCLSID_Snapin, &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        shkTemp.Close();
        shkServer.Close();
        shk.Close();


        hr = shkCLSID.Create(szCLSID_Snapin, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(L"NameString",
                          REG_SZ,
                          (CONST BYTE *) szAppName,
                          sizeof(WCHAR) * (lstrlen(szAppName)+ 1));

        hr = shk.Create(L"NodeTypes", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.Create(szGPT_Namespace, &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        shkTemp.Close();
        shkServer.Close();
        shk.Close();

        shkCLSID.Close();

        hr = shkCLSID.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\MMC\\NodeTypes", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCLSID.Create(szGPT_Namespace, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"Extensions", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.Create(L"NameSpace", &shkTemp);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkTemp.SetValue(szCLSID_Snapin,
                          REG_SZ,
                          (CONST BYTE *) szAppName,
                          sizeof(WCHAR) * (lstrlen(szAppName)+ 1));
        shkTemp.Close();
        shkServer.Close();
        shk.Close();
        shkCLSID.Close();


        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Create the CLSID entry for the private interface proxy/stub
        // dll (which just points back to this dll).
        //

        WCHAR wszModuleFilename[MAX_PATH];
        LONG lr = GetModuleFileName(ghInstance, wszModuleFilename, MAX_PATH);

        if (!lr)
        {
            break;
        }

        hr = shkCLSID.Create(GUID_IAPPMANAGERACTIONS_STR, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(NULL,
                          REG_SZ,
                          (CONST BYTE *) PSBUFFER_STR,
                          sizeof(PSBUFFER_STR));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.Create(L"InprocServer32", &shkServer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *) wszModuleFilename,
                                sizeof(WCHAR) * (lstrlen(wszModuleFilename) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkServer.SetValue(L"ThreadingModel",
                                REG_SZ,
                                (CONST BYTE *) THREADING_STR,
                                sizeof(THREADING_STR));
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        hr = shk.Open(HKEY_CLASSES_ROOT, L"Interface", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = RegisterInterface(&shk,
                               GUID_IAPPMANAGERACTIONS_STR,
                               IAPPMANAGERACTIONS_STR,
                               NUM_IAPPMANAGERACTIONS_METHODS,
                               GUID_IAPPMANAGERACTIONS_STR);
    } while (0);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//              5-09-1997   SteveBl    Modified for use with AppMgr
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\types\uuid\gptuuid.cpp ===
#define INITGUID
#include <windows.h>
#include <basetyps.h>
#include "gptedit.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "precomp.hxx"
#include <atlimpl.cpp>

const CLSID CLSID_Snapin = {0xbdc67e00,0x8ea5,0x11d0,{0x8d,0x3c,0x00,0xa0,0xc9,0x0d,0xca,0xe7}};

// Main NodeType GUID on numeric format
const GUID cNodeType = {0xf8b3a900,0x8ea5,0x11d0,{0x8d,0x3c,0x00,0xa0,0xc9,0x0d,0xca,0xe7}};

// Main NodeType GUID on string format
const wchar_t*  cszNodeType = L"{f8b3a900-8ea5-11d0-8d3c-00a0c90dcae7}";

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"APPMGR_INTERNAL";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detect\basep.cxx ===
#include "precomp.hxx"

HRESULT
BASE_PTYPE::InstallIntoRegistry(
    HKEY  *  hRegistryKey )
    {
    return S_OK;
    }

void
BASE_PTYPE::Init()
    {
    pPackageName = 0;
    PackageType = PT_NONE;
    }

CLASSPATHTYPE
BASE_PTYPE::GetClassPathType(
    PACKAGE_TYPE p )
    {
static CLASSPATHTYPE Mapping[] = {
    ExeNamePath, // PT_NONE (Not Known)
	DllNamePath, // PT_SR_DLL (Self registering dll)
	TlbNamePath, // PT_TYPE_LIB (typelib)
    ExeNamePath, // PT_SR_EXE (Self registering exe)
	CabFilePath, // PT_CAB_FILE (cab file)
	InfFilePath, // PT_INF_FILE (inf file)
	DrwFilePath, // PT_DARWIN_PACKAGE (darwin package)
};
    return Mapping[ p ];
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\appmgr\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) 1995-1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

const long UNINITIALIZED = -1;

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

extern const CLSID CLSID_Snapin;    // In-Proc server GUID
extern const GUID cNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszNodeType; // Main NodeType GUID on string format

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    long                m_cookie;   // What object the cookie represents
    CString             m_string;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\cabinst\cabinst.cxx ===
#include "urlmon.h"
#include <stdio.h>

void
SystemMessage (
    LPTSTR szPrefix,
    HRESULT hr
    )
{
    LPTSTR   szMessage;

    if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS)
        hr = HRESULT_CODE(hr);

    FormatMessage (
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        hr,
        MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &szMessage,
        0,
        NULL);

    printf ("%s: %s(%lx)\n", szPrefix, szMessage, hr);

    LocalFree(szMessage);
}


class CBindStatusCallback : public IBindStatusCallback
{
public:
    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IBindStatusCallback methods
    STDMETHODIMP         OnStartBinding(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHODIMP         GetPriority(LONG* pnPriority);
    STDMETHODIMP         OnLowResource(DWORD dwReserved);
    STDMETHODIMP         OnProgress(ULONG ulProgress,
                                    ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText);

    STDMETHODIMP         OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP         GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP         OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                                         STGMEDIUM* pstgmed);
    STDMETHODIMP         OnObjectAvailable(REFIID riid, IUnknown* punk);


    // constructors/destructors
    CBindStatusCallback();

private:
    long    _cRef;
    HRESULT _hr;
};

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    if (argc!=2)
        {
                printf("Usage: CABINST <URL>\n");
        exit (E_INVALIDARG);
        }

    CoInitialize(NULL);
    HRESULT hr=S_OK;

    IBindCtx *pBC=NULL;

    //Synchronous call with bind context.
    CBindStatusCallback *pCallback = new CBindStatusCallback();

    if (!pCallback)
    {
        exit (-1);
    }
    hr = CreateAsyncBindCtx(0, pCallback, NULL, &pBC);


    WCHAR wszArg[_MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, argv[1], -1, wszArg, sizeof(wszArg)/sizeof(wszArg[0]));

#if 1

    IUnknown* punk=NULL;
    hr=CoGetClassObjectFromURL (
        IID_IUnknown,
        wszArg,
        (DWORD) -1,(DWORD) -1, L"", pBC, CLSCTX_SERVER, NULL, IID_IUnknown, (void**) &punk);
    if (punk)
    {
        punk->Release();
    }

#else

        typedef HRESULT (STDAPICALLTYPE *PFNASYNCGETCLASSBITS)(
                REFCLSID rclsid,                    // CLSID
                DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
                DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
                LPCWSTR szURL,                      // CODE= in INSERT tag
                IBindCtx *pbc,                      // bind ctx
                DWORD dwClsContext,                 // CLSCTX flags
                LPVOID pvReserved,                  // Must be NULL
                REFIID riid,                        // Usually IID_IClassFactory
                DWORD flags);

        PFNASYNCGETCLASSBITS pfnAsyncGetClassBits=NULL;

    HINSTANCE hDll;

    hDll = LoadLibraryEx("URLMON.DLL", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if(hDll != 0)
        {
        pfnAsyncGetClassBits = (PFNASYNCGETCLASSBITS)
            GetProcAddress(hDll, "AsyncGetClassBits");

        if(pfnAsyncGetClassBits == 0)
                {
            hr = HRESULT_FROM_WIN32(GetLastError());

                        IUnknown* punk=NULL;
                        hr=CoGetClassObjectFromURL (
                                IID_IUnknown,
                                wszArg,
                                (DWORD) -1,(DWORD) -1, L"", pBC, CLSCTX_SERVER, NULL, IID_IUnknown, (void**) &punk);
                        if (punk)
                        {
                                punk->Release();
                        }

                }
        else
            {
                hr = (*pfnAsyncGetClassBits)(
                                        IID_IUnknown,                   // bogus CLSID
                                                (DWORD) -1,(DWORD) -1,  // don't care about version #
                                                wszArg,                                 // URL/Path
                                                pBC,                                    // Bind context with IBSC
                                                CLSCTX_SERVER,
                                                NULL,
                                                IID_IClassFactory,
                                                0);   // 1 == CD_FLAGS_FORCE_DOWNLOAD

            }
        FreeLibrary(hDll);
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        }
#endif

        if (hr==MK_S_ASYNCHRONOUS)
        {
                MSG msg;
                while (GetMessage(&msg, NULL, 0,0))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
            }
                hr=msg.wParam;
        }

        if (hr==REGDB_E_CLASSNOTREG)
        {
                hr=S_OK; // Ignore instantiation error since we are asking for IID_IUnknown...
        }

        if (FAILED(hr))
        {
                SystemMessage("Unable to install CAB file", hr);
        }
    pCallback->Release();
        pBC->Release();
    CoUninitialize();
    return hr;
}

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::CBindStatusCallback
//
//  Synopsis:   Creates a bind status callback object.
//
//----------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback()
: _cRef(1), _hr(MK_S_ASYNCHRONOUS)
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::QueryInterface
//
//  Synopsis:   Gets an interface pointer to the bind status callback object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IBindStatusCallback))
    {
        AddRef();
        *ppv = (IBindStatusCallback *) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::AddRef
//
//  Synopsis:   Increments the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return _cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Release
//
//  Synopsis:   Decrements the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::Release()
{
    LONG count = _cRef - 1;

    if(0 == InterlockedDecrement((long *) &_cRef))
    {
        delete this;
        count = 0;
    }

    return count;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    _hr = hrStatus;
    PostQuitMessage(hrStatus);
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    return (NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// This function is called whenever data starts arriving. When the file download is
// complete then the BSCF_LASTDATANOTIFICATION comes and you can get the local cached
// File Name.
// ---------------------------------------------------------------------------
 STDMETHODIMP
 CBindStatusCallback::OnDataAvailable
 (
 DWORD grfBSCF,
 DWORD dwSize,
 FORMATETC* pfmtetc,
 STGMEDIUM* pstgmed
 )
 {
    return(NOERROR);
 }


// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detect\cabfile.cxx ===
#include "precomp.hxx"

#include "process.h"
#include "shellapi.h"
#include "urlmon.h"

class CBindStatusCallback : public IBindStatusCallback, public ICodeInstall
{
public:
    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IBindStatusCallback methods
    STDMETHODIMP         OnStartBinding(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHODIMP         GetPriority(LONG* pnPriority);
    STDMETHODIMP         OnLowResource(DWORD dwReserved);
    STDMETHODIMP         OnProgress(ULONG ulProgress,
                                    ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText);

    STDMETHODIMP         OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP         GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP         OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                                         STGMEDIUM* pstgmed);
    STDMETHODIMP         OnObjectAvailable(REFIID riid, IUnknown* punk);

    // ICodeInstall methods
    STDMETHODIMP         GetWindow(REFGUID guidReason, HWND * phwnd);
    STDMETHODIMP         OnCodeInstallProblem(ULONG ulStatusCode,
                                              LPCWSTR szDestination,
                                              LPCWSTR szSource,
                                              DWORD dwReserved);

    // constructors/destructors
    CBindStatusCallback();
    ~CBindStatusCallback();

private:
    IBindStatusCallback * m_pIBSC;
    long    _cRef;
    HRESULT _hr;
};

extern HINSTANCE ghInstance;

#include "..\appmgr\resource.h"

HRESULT
CAB_FILE::InstallIntoRegistry( HKEY  * RegistryKey)
{
    // UNDONE - put in dialog box informing the user that we will
    // install the cab file here.
#if 0
    TCHAR szCaption[256];
    TCHAR szBuffer[256];
    ::LoadString(ghInstance, IDS_CABCAPTION, szCaption, 256);
    ::LoadString(ghInstance, IDS_CABWARNING, szBuffer, 256);
    int iReturn = ::MessageBox(NULL, szBuffer,
                               szCaption,
                               MB_YESNO);
    if (iReturn == IDNO)
    {
        return E_FAIL;
    }
#endif
    // Go ahead and install the cab file
    IBindCtx *pBC=NULL;

    //Synchronous call with bind context.
    CBindStatusCallback *pCallback = new CBindStatusCallback();
    if (!pCallback)
    {
        exit (-1);
    }
    HRESULT hr;

    hr = CreateAsyncBindCtx(0, pCallback, NULL, &pBC);


    char * szName = GetPackageName();
    WCHAR wszName[_MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, szName, -1, wszName, sizeof(wszName)/sizeof(wszName[0]));

    IUnknown* punk=NULL;
#if 1
    typedef HRESULT (STDAPICALLTYPE *PFNASYNCGETCLASSBITS)(
                                                          REFCLSID rclsid,                    // CLSID
                                                          LPCWSTR, LPCWSTR,
                                                          DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
                                                          DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
                                                          LPCWSTR szURL,                      // CODE= in INSERT tag
                                                          IBindCtx *pbc,                      // bind ctx
                                                          DWORD dwClsContext,                 // CLSCTX flags
                                                          LPVOID pvReserved,                  // Must be NULL
                                                          REFIID riid,                        // Usually IID_IClassFactory
                                                          DWORD flags);

    PFNASYNCGETCLASSBITS pfnAsyncGetClassBits=NULL;

    HINSTANCE hDll;

    hDll = LoadLibraryEx("URLMON.DLL", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (hDll != 0)
    {
        pfnAsyncGetClassBits = (PFNASYNCGETCLASSBITS)
                               GetProcAddress(hDll, "AsyncGetClassBits");

        if (pfnAsyncGetClassBits == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            IUnknown* punk=NULL;
            hr=CoGetClassObjectFromURL (
                                       IID_IUnknown,
                                       wszName,
                                       (DWORD) -1,(DWORD) -1, L"", pBC, CLSCTX_SERVER, NULL, IID_IUnknown, (void**) &punk);
            if (punk)
            {
                punk->Release();
            }

        }
        else
        {
            hr = (*pfnAsyncGetClassBits)(
                                        IID_IUnknown,           // bogus CLSID
                                        NULL, NULL,
                                        (DWORD) -1,(DWORD) -1,  // don't care about version #
                                        wszName,                // URL/Path
                                        pBC,                    // Bind context with IBSC
                                        CLSCTX_SERVER,
                                        NULL,
                                        IID_IClassFactory,
                                        1);                     // 1 == CD_FLAGS_FORCE_DOWNLOAD
        }
        FreeLibrary(hDll);
    }
#else
    hr=CoGetClassObjectFromURL (
                               IID_IUnknown,
                               wszName,
                               (DWORD) -1,(DWORD) -1, L"", pBC, CLSCTX_SERVER, NULL, IID_IUnknown, (void**) &punk);
    if (punk)
    {
        punk->Release();
    }
#endif
    if (hr==MK_S_ASYNCHRONOUS)
    {
        MSG msg;
        while (GetMessage(&msg, NULL, 0,0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        hr=msg.wParam;
    }

    if (hr==REGDB_E_CLASSNOTREG)
    {
        hr=S_OK; // Ignore instantiation error since we are asking for IID_IUnknown...
    }

    pCallback->Release();
    pBC->Release();

    //    i = _spawnlp( P_WAIT,
    //                  "cabinst.exe",     // argument
    //                  GetPackageName(),  // argument
    //                  0 );               // argument

    return hr;
}

HRESULT
CAB_FILE::InitRegistryKeyToInstallInto(
    HKEY   * phKey )
{
    return CreateMappedRegistryKey( phKey );
}

HRESULT
CAB_FILE::RestoreRegistryKey( HKEY * phKey)
{
    return RestoreMappedRegistryKey( phKey);
}

HRESULT
CAB_FILE::DeleteTempKey(HKEY hKey, FILETIME ftLow, FILETIME ftHigh)
{
    CleanMappedRegistryKey(hKey, ftLow, ftHigh);
    return S_OK;
}

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::CBindStatusCallback
//
//  Synopsis:   Creates a bind status callback object.
//
//----------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback()
: _cRef(1), _hr(MK_S_ASYNCHRONOUS)
{
    CreateStdProgressIndicator(GetDesktopWindow(), NULL, NULL, &m_pIBSC);
}

CBindStatusCallback::~CBindStatusCallback()
{
    m_pIBSC->Release();
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::QueryInterface
//
//  Synopsis:   Gets an interface pointer to the bind status callback object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IBindStatusCallback))
    {
        AddRef();
        *ppv = (IBindStatusCallback *) this;
    }
    else
        if (IsEqualIID(riid, IID_ICodeInstall))
    {
        AddRef();
        *ppv = (ICodeInstall *) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::AddRef
//
//  Synopsis:   Increments the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return _cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Release
//
//  Synopsis:   Decrements the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::Release()
{
    LONG count = _cRef - 1;

    if (0 == InterlockedDecrement((long *) &_cRef))
    {
        delete this;
        count = 0;
    }

    return count;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    return m_pIBSC->OnStartBinding(grfBSCOption, pbinding);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
    return m_pIBSC->GetPriority(pnPriority);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return m_pIBSC->OnLowResource(dwReserved);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    _hr = hrStatus;
    PostQuitMessage(hrStatus);
    return m_pIBSC->OnStopBinding(hrStatus, pszError);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    return m_pIBSC->GetBindInfo(pgrfBINDF, pbindInfo);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// This function is called whenever data starts arriving. When the file download is
// complete then the BSCF_LASTDATANOTIFICATION comes and you can get the local cached
// File Name.
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnDataAvailable
(
DWORD grfBSCF,
DWORD dwSize,
FORMATETC* pfmtetc,
STGMEDIUM* pstgmed
)
{
    return m_pIBSC->OnDataAvailable(grfBSCF, dwSize, pfmtetc, pstgmed);
}


// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return m_pIBSC->OnObjectAvailable(riid, punk);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnProgress
(
ULONG ulProgress,
ULONG ulProgressMax,
ULONG ulStatusCode,
LPCWSTR pwszStatusText
)
{
    return m_pIBSC->OnProgress(ulProgress, ulProgressMax, ulStatusCode, pwszStatusText);
}

STDMETHODIMP
CBindStatusCallback::GetWindow(REFGUID guidReason, HWND * phwnd)
{
    *phwnd = GetDesktopWindow();
    return S_OK;
}

STDMETHODIMP
CBindStatusCallback::OnCodeInstallProblem(ULONG ulStatusCode,
                                          LPCWSTR szDestination,
                                          LPCWSTR szSource,
                                          DWORD dwReserved)
{
    HRESULT hr = E_ABORT;
    switch (ulStatusCode)
    {
    case CIP_OLDER_VERSION_EXISTS:
    case CIP_NEWER_VERSION_EXISTS:
    case CIP_NAME_CONFLICT:
    case CIP_TRUST_VERIFICATION_COMPONENT_MISSING:
        hr = S_OK;
        break;
        //case CIP_DRIVE_FULL:
    case CIP_ACCESS_DENIED:
        default:
        break;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detect\darwin.cxx ===
#include "precomp.hxx"

#include <msi.h>
#include "process.h"

HRESULT
DARWIN_PACKAGE::InstallIntoRegistry( HKEY * RegistryKey)
{
    HRESULT hr;
    int     MsiStatus;


    // We will need to code scipt generation here.

    // process the advertise script.

    MsiStatus = MsiProcessAdvertiseScript(
                        GetScriptFileName(),    // script file path
                        0,                      // optional icon folder,
                        *RegistryKey,           // optional reg key
                        FALSE, // output shortcuts to special folder
                        FALSE // remove stuff from prev invocation
                        );
    return HRESULT_FROM_WIN32( (long)MsiStatus );
}

HRESULT
DARWIN_PACKAGE::InitRegistryKeyToInstallInto(
    HKEY   * phKey )
{

    DWORD   Disposition;
    LONG    Error;

        Error = RegCreateKeyEx(
                        HKEY_CLASSES_ROOT,
                        TEMP_KEY,
                        0,
                        "REG_SZ",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        0,
                        phKey,
                        &Disposition );

    return HRESULT_FROM_WIN32( Error );
}

HRESULT
DARWIN_PACKAGE::RestoreRegistryKey( HKEY *hKey)
{
    return S_OK;
}

HRESULT
DARWIN_PACKAGE::DeleteTempKey(HKEY hKey, FILETIME ftLow, FILETIME ftHigh)
{
    return HRESULT_FROM_WIN32( RegDeleteTree( HKEY_CLASSES_ROOT, TEMP_KEY ));
}

char *
DARWIN_PACKAGE::GenerateScriptFileName(
    char * pPackageName )
{
    char    Drive [_MAX_DRIVE];
    char    Dir [_MAX_DIR];
    char    Name [_MAX_FNAME];
    char    Ext [_MAX_EXT];
    char  *  ScriptNameAndPath = new char [_MAX_PATH ];

    _splitpath( pPackageName, Drive, Dir, Name, Ext );
    strcpy( ScriptNameAndPath, Drive );
    strcat( ScriptNameAndPath, Dir );
    strcat( ScriptNameAndPath, Name );
    strcat( ScriptNameAndPath, ".aas" );
    return ScriptNameAndPath;
}

HRESULT
DARWIN_PACKAGE::InstallIntoGPT(
    MESSAGE     *   pMessage,
    BOOL            fAssignOrPublish,
    char        *   pScriptBasePath )
{
    int MsiStatus;

    MsiStatus = MsiAdvertiseProduct(
                     GetPackageName(), GetScriptFileName(), 0,
                     LANGIDFROMLCID(GetUserDefaultLCID()));

    return HRESULT_FROM_WIN32( (long)MsiStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detect\ptypes.cxx ===
#include "precomp.hxx"

#include "oaidl.h"
#include <msi.h>
#include "..\appmgr\resource.h"
extern HINSTANCE ghInstance;

/*****************************************************************************
    forwards
 *****************************************************************************/
HRESULT
DetectSelfRegisteringDll(
                        char * pszDll,
                        HINSTANCE * phInstance);

BASE_PTYPE *
DetectPackageType(
                 MESSAGE * pMessage,
                 char    * pPackageName );

HRESULT
DetectDarwinPackage(
                   MESSAGE * pMessage,
                   char * pPackageName );

CLASSPATHTYPE
GetClassPathType(
                PACKAGE_TYPE p );

/*****************************************************************************
    Code
 *****************************************************************************/
HRESULT
DetectPackageAndRegisterIntoClassStore(
                                      MESSAGE     *   pMessage,
                                      char        * pPackageName,
                                      BOOL            fAssignOrPublish,
                                      IClassAdmin * pClassAdmin )
{
    HRESULT hr = S_OK;
    BASE_PTYPE * pT;
    HKEY        hKey;
    TCHAR szCaption[256];
    TCHAR szBuffer[256];
    TCHAR szDebugBuffer[256];


    //
    // detect the package type.
    //

    pMessage->fAssignOrPublish = fAssignOrPublish;
    pMessage->ActFlags = (fAssignOrPublish==1) ? ACTFLG_Published : ACTFLG_Assigned;

    if ( pT = DetectPackageType( pMessage, pPackageName ) )
    {

        //
        // Create registry key to install into.
        //

        if ( pT->InitRegistryKeyToInstallInto( &hKey ) == S_OK )
        {
            //
            // Register the package into the registry.
            //

            hr = pT->InstallIntoRegistry( &hKey );

            pT->RestoreRegistryKey( &hKey );

            if ( SUCCEEDED( hr ) )
            {
                GetSystemTimeAsFileTime(&pMessage->ftHigh);

                //
                // register the package into the class store.
                //
                pMessage->hRoot = hKey;
                pMessage->fPathTypeKnown = 1;
                pMessage->PathType =pT->GetClassPathType(pT->GetPackageType());
                hr=UpdateClassStoreFromMessage( pMessage, pClassAdmin );
                if (S_OK == hr)
                {
                    pT->InstallIntoGPT( pMessage,
                                        fAssignOrPublish,
                                        pMessage->pAuxPath );
                }
                else
                {
                    if (FAILED(hr))
                    {
                        // Unable to update the class store
                        DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                                 NULL,
                                                 hr,
                                                 0,
                                                 szDebugBuffer,
                                                 sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                                 NULL);
                        if (0 == dw)
                        {
                            wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
                        }
                        ::LoadString(ghInstance, IDS_CLASSSTOREERROR, szBuffer, 256);
                        strcat(szBuffer, szDebugBuffer);
                        strncpy(szCaption, pMessage->pPackagePath, 256);
                        int iReturn = ::MessageBox(pMessage->hwnd, szBuffer,
                                                   szCaption,
                                                   MB_OK);
                    }
                }
            }
            else
            {
                // Unable to install package
                DWORD dw = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                         NULL,
                                         hr,
                                         0,
                                         szDebugBuffer,
                                         sizeof(szDebugBuffer) / sizeof(szDebugBuffer[0]),
                                         NULL);
                if (0 == dw)
                {
                    wsprintf(szDebugBuffer, TEXT("(HRESULT: 0x%lX)"), hr);
                }
                ::LoadString(ghInstance, IDS_URLMONERROR, szBuffer, 256);
                strcat(szBuffer, szDebugBuffer);
                strncpy(szCaption, pMessage->pPackagePath, 256);
                int iReturn = ::MessageBox(pMessage->hwnd, szBuffer,
                                           szCaption,
                                           MB_OK);
            }
            pT->DeleteTempKey(hKey, pMessage->ftLow, pMessage->ftHigh);
        }
    }
    else
        hr = HRESULT_FROM_WIN32( ERROR_MOD_NOT_FOUND );
    return hr;
}

BASE_PTYPE *
DetectPackageType(
                 MESSAGE * pMessage,
                 char    * pPackageName)
{
    HRESULT hr;
    HINSTANCE hDll;

    char    Dir [_MAX_DIR];
    char    Name [_MAX_FNAME];
    char    Ext [_MAX_EXT];
    ITypeLib  *  Tlib;
    OLECHAR   wPackageName[ _MAX_PATH ];

    _splitpath( pPackageName, NULL, Dir, Name, Ext );

    //
    // Check if this is a valid darwin package
    //

    if (_stricmp( Ext, ".msi" ) == 0)
    {
        hr = DetectDarwinPackage( pMessage, pPackageName );
        if ( SUCCEEDED(hr) )
        {
            return  new DARWIN_PACKAGE( pPackageName, pMessage->pAuxPath );
        }
        else return NULL; // it stops here
    }


    //
    // Check if this is a cab file.
    //


    if ( _stricmp( Ext, ".cab" ) == 0 )
    {

        // It is a cab file, try cab file download

        return new CAB_FILE( pPackageName, TRUE );
    }


    //
    // Check if this is a type library.
    //

    mbstowcs( wPackageName, pPackageName, strlen( pPackageName ) + 1 );
    if ( (hr = LoadTypeLibEx( wPackageName,
                              REGKIND_NONE,
                              &Tlib ) ) == S_OK )
    {
        return new TYPE_LIB( pPackageName );
    }

    //
    // Check if this is a self registring Dll.
    //

    hr =  DetectSelfRegisteringDll( pPackageName, &hDll );

    if ( SUCCEEDED( hr ))
    {
        return new SR_DLL( pPackageName );
    }

    //
    // Aw Shucks! This is none of the above.
    //
    // Treat as CAB file for now ("hand path to IE code-download to install")
    return new CAB_FILE( pPackageName, FALSE );
//    return 0;
}

//  Utility funciton to copy the contents of one registry tree into another.
//  NOTE: Contents are not removed from the destination key, just either
//        overwritten or added to by the data in the source key.
//        Only items whose date stamp falls within the indicated range will
//        be copied. If ftLow and ftHigh are 0 then the range is ignored
//        and all items are copied.
//  Returns:    ERROR_SUCCESS if items were successfully copied.
//              ERROR_NO_MORE_ITEMS if no items were found to copy.
//              other if it failed.
//
LONG RegCopyTree(HKEY     hKeyDest,
                 HKEY     hKeySrc,
                 FILETIME ftLow,
                 FILETIME ftHigh )
{
    HKEY hKeyNewSrc;
    HKEY hKeyNewDest;
    LONG lResult = ERROR_SUCCESS;
    DWORD cSubKeys;
    DWORD cbMaxSubKeyLen;
    DWORD cbMaxClassLen;
    DWORD cValues;
    DWORD cbMaxValueNameLen;
    DWORD cbMaxValueLen;
    FILETIME ft;
    BOOL fItemsCopied = FALSE;

    lResult = RegQueryInfoKey(hKeySrc,
                              NULL, NULL, // class
                              NULL, // reserved
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              NULL, // lpcbSecurityDescriptor
                              &ft);

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    BOOL fInRange = TRUE;
    // If the high and low times are not equal then check the file time.
    if (CompareFileTime(&ftLow, &ftHigh) != 0)
    {
        if (!((CompareFileTime(&ftLow, &ft) <= 0) &&
            (CompareFileTime(&ft, &ftHigh) <= 0)))
        {
            // time didn't match
            fInRange = FALSE;
        }
    }

    DWORD dwIndex;
    if (fInRange)
    {
        // This key exists and something about it is new so we don't want
        // it deleted even if there were no sub-keys or values in it.
        fItemsCopied = TRUE;

        // copy all the values for this key pair
        TCHAR * lpValueName = new TCHAR[cbMaxValueNameLen + 1];
        DWORD cbValueName;
        DWORD dwType;
        BYTE * lpData = new BYTE[cbMaxValueLen + 1];
        DWORD cbData;

        for (dwIndex = 0; dwIndex < cValues; dwIndex++)
        {
            cbValueName = cbMaxValueNameLen + 1;
            cbData = cbMaxValueLen + 1;
            lResult = RegEnumValue(hKeySrc,
                                   dwIndex,
                                   lpValueName,
                                   &cbValueName,
                                   NULL,
                                   &dwType,
                                   lpData,
                                   &cbData);
            if (ERROR_SUCCESS == lResult)
            {
                lResult = RegSetValueEx(hKeyDest,
                                        lpValueName,
                                        0,
                                        dwType,
                                        lpData,
                                        cbData);
            }
            if (ERROR_SUCCESS != lResult)
                break;
        }
        delete [] lpValueName;
        delete [] lpData;
    }

    if (ERROR_SUCCESS == lResult)
    {
        HKEY hSubKeyDest, hSubKeySrc;
        TCHAR * lpName = new TCHAR[cbMaxSubKeyLen + 1];
        DWORD cbName;
        TCHAR * lpClass = new TCHAR[cbMaxClassLen + 1];
        DWORD cbClass;
        FILETIME ftLastWriteTime;

        for (dwIndex = 0; dwIndex < cSubKeys; dwIndex++)
        {
            cbName = cbMaxSubKeyLen + 1;
            cbClass = cbMaxClassLen + 1;
            lResult = RegEnumKeyEx(hKeySrc,
                                   dwIndex,
                                   lpName,
                                   &cbName,
                                   NULL,
                                   lpClass,
                                   &cbClass,
                                   &ftLastWriteTime);
            if (ERROR_SUCCESS == lResult)
            {
                DWORD dwDisposition;
                BOOL fInRange = TRUE;
                // If the high and low times are not equal then check the
                // file time.
                if (CompareFileTime(&ftLow, &ftHigh) != 0)
                {
                    if (!((CompareFileTime(&ftLow, &ftLastWriteTime) <= 0) &&
                        (CompareFileTime(&ftLastWriteTime, &ftHigh) <= 0)))
                    {
                        // time didn't match
                        fInRange = FALSE;
                    }
                }
                if (fInRange)
                {
                    lResult = RegOpenKeyEx(hKeySrc,
                                           lpName,
                                           0,
                                           KEY_ALL_ACCESS,
                                           &hSubKeySrc);
                    if (ERROR_SUCCESS == lResult)
                    {
                        lResult = RegCreateKeyEx(hKeyDest,
                                                 lpName,
                                                 0,
                                                 lpClass,
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_ALL_ACCESS,
                                                 NULL,
                                                 &hSubKeyDest,
                                                 &dwDisposition);
                        if (ERROR_SUCCESS == lResult)
                        {
                            lResult = RegCopyTree(hSubKeyDest, hSubKeySrc, ftLow, ftHigh);
                            if (ERROR_NO_MORE_ITEMS == lResult)
                            {
                                // Nothing was new under this sub tree so
                                // delete it.
                                if (REG_CREATED_NEW_KEY == dwDisposition)
                                {
                                    RegCloseKey(hSubKeyDest);
                                    RegDeleteKey(hKeyDest, lpName);
                                }
                                lResult = ERROR_SUCCESS;
                            }
                            else
                            {
                                if (REG_CREATED_NEW_KEY == dwDisposition)
#if 0
                                {
                                    // We created this key so we better make
                                    // sure that security info gets copied
                                    // over too.
                                    DWORD cbSD = 256;
                                    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) new BYTE [cbSD];
                                    if (pSD)
                                    {
                                        lResult = RegGetKeySecurity(hSubKeySrc,
                                                                    OWNER_SECURITY_INFORMATION |
                                                                    GROUP_SECURITY_INFORMATION |
                                                                    DACL_SECURITY_INFORMATION,
                                                                    &pSD,
                                                                    &cbSD);
                                        if (ERROR_INSUFFICIENT_BUFFER == lResult)
                                        {
                                            delete [] pSD;
                                            pSD = (PSECURITY_DESCRIPTOR) new BYTE [cbSD];
                                            if (pSD)
                                            {
                                                lResult = RegGetKeySecurity(hSubKeySrc,
                                                                            OWNER_SECURITY_INFORMATION |
                                                                            GROUP_SECURITY_INFORMATION |
                                                                            DACL_SECURITY_INFORMATION,
                                                                            &pSD,
                                                                            &cbSD);
                                            }
                                            else lResult = ERROR_NOT_ENOUGH_MEMORY;
                                        }
                                        if (ERROR_SUCCESS == lResult)
                                        {
                                            lResult = RegSetKeySecurity(hSubKeyDest,
                                                                        OWNER_SECURITY_INFORMATION |
                                                                        GROUP_SECURITY_INFORMATION |
                                                                        DACL_SECURITY_INFORMATION,
                                                                        &pSD);
                                        }
                                        if (pSD)
                                            delete[] pSD;
                                    }
                                    else lResult = ERROR_NOT_ENOUGH_MEMORY;
                                }
#endif
                                RegCloseKey(hSubKeyDest);
                                fItemsCopied = TRUE;
                            }
                        }
                        RegCloseKey(hSubKeySrc);
                    }
                    if (ERROR_SUCCESS != lResult)
                    {
                        break;
                    }
                }
            }
        }
        delete [] lpName;
        delete [] lpClass;
    }

    if (ERROR_SUCCESS == lResult)
    {
        if (!fItemsCopied)
        {
            lResult = ERROR_NO_MORE_ITEMS;
        }
    }
    return lResult;
}

HRESULT
CreateMappedRegistryKey(HKEY    *   phKey )
{

    LONG    Error;
    DWORD   Disposition;

    *phKey = 0;
    Error = RegCreateKeyEx(
                          HKEY_LOCAL_MACHINE,
                          TEMP_KEY,
                          0,                  // mbz
                          "REG_SZ",
                          REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS,
                          0,
                          phKey,
                          &Disposition );

    Error = RegOverridePredefKey( HKEY_CLASSES_ROOT, *phKey );

    return HRESULT_FROM_WIN32(Error);
}


HRESULT
RestoreMappedRegistryKey(HKEY * phKey)
{
    DWORD   Disposition;

    // set HKEY_CLASSES_ROOT back to what it should be
    LONG Error = RegOverridePredefKey(HKEY_CLASSES_ROOT, NULL);

    Error = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           TEMP_KEY,
                           0,
                           "REG_SZ",
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           0,
                           phKey,
                           &Disposition);

    return HRESULT_FROM_WIN32(Error);
}

HRESULT
CleanMappedRegistryKey(
    HKEY hKey, FILETIME ftLow, FILETIME ftHigh)
{
    // copy everything under our temporary key to HKEY_CLASSES_ROOT
    LONG Error = RegCopyTree(HKEY_CLASSES_ROOT, hKey, ftLow, ftHigh);

    RegCloseKey(hKey);

    RegDeleteTree(HKEY_LOCAL_MACHINE, TEMP_KEY);

    return HRESULT_FROM_WIN32(Error);
}

HRESULT
DetectSelfRegisteringDll(
                        char * pszDll,
                        HINSTANCE * phInstance )
{

    HRESULT hr;
    HINSTANCE hDll;
    HRESULT (STDAPICALLTYPE *pfnDllRegisterServer)();

    hDll = LoadLibraryEx(pszDll, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (hDll != 0)
    {
        pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
                               GetProcAddress(hDll, "DllRegisterServer");

        if (pfnDllRegisterServer == 0)
            hr = HRESULT_FROM_WIN32(GetLastError());
        else
        {
            hr = S_OK;
        }
        FreeLibrary(hDll);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    return hr;
}

HRESULT
DetectDarwinPackage(
                   MESSAGE * pMessage,
                   char * pPackageName )
{
    int     MsiStatus = 0;

    char    Name [_MAX_FNAME];
    char    ScriptNameAndPath[_MAX_PATH ];

    SYSTEM_INFO si;
    GetSystemInfo(&si);

    // this will be replaced by darwin detection api. ////////////////////

    _splitpath( pPackageName, NULL, NULL, Name, NULL );

    sprintf(ScriptNameAndPath,
            "%s\\%s\\%s\\%s.aas",
            pMessage->pAuxPath,
            (pMessage->fAssignOrPublish == 0) ? "Assigned" : "Published",
            (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA)? "Alpha" : "x86",
            Name);

    MsiStatus = MsiAdvertiseProduct(
                                   pPackageName,   // darwin package name
                                   ScriptNameAndPath, 0,
                                   LANGIDFROMLCID(GetUserDefaultLCID()));

    // ////////////////////////////////////////////////

    if ( MsiStatus == 0 ) // change this check when they swicth to win32 codes.
    {
        /**
        _splitpath( pPackageName, NULL, NULL, Name, NULL );

        sprintf(ScriptNameAndPath,
                "%s\\%s\\%s\\%s.aas",
                pMessage->pAuxPath,
                (pMessage->fAssignOrPublish == 0) ? "Assigned" : "Published",
                "x86",
                Name );

        MsiStatus = MsiAdvertiseProduct(
                         pPackageName, ScriptNameAndPath, 0,
                         LANGIDFROMLCID(GetUserDefaultLCID()));
         **/

        pMessage->pAuxPath = new char[ strlen(ScriptNameAndPath)+1 ];
        strcpy(pMessage->pAuxPath, ScriptNameAndPath );

        // set the UserInstall flag by default for Darwin packges
        pMessage->ActFlags += ACTFLG_UserInstall;

        // Set pMessage->pPackageName to the name reported by the Darwin
        // package.

        char szProductBuf39[39];
        LANGID lgid;
        DWORD dwVersion;
        char szNameBuf[_MAX_PATH];
        DWORD cchNameBuf = _MAX_PATH;
        char szPackageBuf[_MAX_PATH];
        DWORD cchPackageBuf = _MAX_PATH;

        MsiStatus = MsiGetProductInfoFromScriptA(ScriptNameAndPath,
                                                 szProductBuf39,
                                                 &lgid,
                                                 &dwVersion,
                                                 szNameBuf,
                                                 &cchNameBuf,
                                                 szPackageBuf,
                                                 &cchPackageBuf);
        if (0 == MsiStatus)
        {
            pMessage->pPackageName = new char [ cchNameBuf + 1];
            strcpy(pMessage->pPackageName, szNameBuf);
        }
    }
    return HRESULT_FROM_WIN32( (long)MsiStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detect\srdll.cxx ===
#include "precomp.hxx"

HRESULT
SR_DLL::InstallIntoRegistry( HKEY * RegistryKey)
{
    HRESULT hr;
    HINSTANCE hDll;
    HRESULT (STDAPICALLTYPE *pfnDllRegisterServer)();
    HKEY    hKey;

    hDll = LoadLibraryEx(GetPackageName(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if(hDll != 0)
        {
        pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
            GetProcAddress(hDll, "DllRegisterServer");

        if(pfnDllRegisterServer == 0)
            hr = HRESULT_FROM_WIN32(GetLastError());
        else
            {
                hr = (*pfnDllRegisterServer)();
            }
        FreeLibrary(hDll);
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        }


    return hr;
}

HRESULT
SR_DLL::InitRegistryKeyToInstallInto(
    HKEY   * phKey )
    {
    return CreateMappedRegistryKey( phKey );
    }

HRESULT
SR_DLL::RestoreRegistryKey( HKEY *phKey )
    {
    return RestoreMappedRegistryKey( phKey);
    }

HRESULT
SR_DLL::DeleteTempKey(HKEY hKey, FILETIME ftLow, FILETIME ftHigh)
    {
        CleanMappedRegistryKey(hKey, ftLow, ftHigh);
        return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detect\typelib.cxx ===
#include "precomp.hxx"

HRESULT
TYPE_LIB::InstallIntoRegistry( HKEY * RegistryKey)
{
    HRESULT hr = S_OK;
    OLECHAR   wPackageName[ _MAX_PATH ];
    ITypeLib * Tlib;
    char * pP = GetPackageName();

    mbstowcs( wPackageName, pP, strlen(pP ) + 1 );
    hr = LoadTypeLibEx( wPackageName, REGKIND_REGISTER, &Tlib );
    return hr;
}

HRESULT
TYPE_LIB::InitRegistryKeyToInstallInto(
    HKEY   * phKey )
{
    return CreateMappedRegistryKey( phKey );
}

HRESULT
TYPE_LIB::RestoreRegistryKey( HKEY *phKey )
{
    return RestoreMappedRegistryKey( phKey);
}

HRESULT
TYPE_LIB::DeleteTempKey(HKEY hKey, FILETIME ftLow, FILETIME ftHigh)
{
    CleanMappedRegistryKey(hKey, ftLow, ftHigh);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\inc\protos.h ===
#include "common.h"
#include "message.hxx"

HRESULT
DetectPackageAndRegisterIntoClassStore(
    MESSAGE     *   pMessage,
    char        * pPackageName,
    BOOL            fPublishOrAssign,
    IClassAdmin * pClassAdmin );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\inc\common.h ===
/*
** File: common.hxx
**

**      (C) 1989 Microsoft Corp.
*/

/*****************************************************************************/
/**                                             Microsoft LAN Manager                                                           **/
/**                             Copyright(c) Microsoft Corp., 1987-1990                                         **/
/*****************************************************************************/
/*****************************************************************************
File                            : rpctypes.hxx
Title               : rpc type node defintions
Description         : Common header file for MIDL compiler
History                         :
    ??-Aug-1990 ???     Created
    20-Sep-1990 NateO   Safeguards against double inclusion

*****************************************************************************/

#ifndef __COMMON_HXX__
#define __COMMON_HXX__

#define INC_OLE2
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <assert.h>
#include "list.hxx"

typedef CLSID * PCLSID;

/*****************************************************************************
        definitions from \nt\private\cs\inc\cscons.h
 *****************************************************************************/
#include <cscons.h>

/*****************************************************************************
        definitions from objidl.h
 *****************************************************************************/

#include <wtypes.h>
#include <objidl.h>

/*****************************************************************************
        definitions for common.h
 *****************************************************************************/

#define SIZEOF_STRINGIZED_CLSID 39
#define MAX_ARRAY_OF_POINTER_ELEMENTS 30
#define MAX_ARRAY 30

/*
   This is the structure of the entry made into the class dictionary. The entry
   key is the Clsid field. The main data is the CLASSASSOCIATION structure,
   which will be used in the IClassAdmin interface methods.
*/

typedef char  CLSIDString;
typedef CLASSDETAIL CLASSASSOCIATION;

typedef class tagCLASS_ENTRY
    {

public:
    CLSIDString                 ClsidString[ SIZEOF_STRINGIZED_CLSID ]; // stringized form of class id.
    CLASSASSOCIATION    ClassAssociation;
        Name_List                       OtherProgIDs;
        Name_List                       FileExtList;
public:
                                tagCLASS_ENTRY()
                                        {
                                        memset( ClsidString, '\0', SIZEOF_STRINGIZED_CLSID );
                                        memset( &ClassAssociation, '\0', sizeof( CLASSASSOCIATION ) );
                                        }
                                ~tagCLASS_ENTRY()
                                        {
                                        }
        void            SetClsidString( char * StringizedClsid )
                                        {
                                        strcpy( &ClsidString[0], StringizedClsid );
                                        }

        CLSIDString     *GetClsidString()
                                        {
                                        return &ClsidString[0];
                                        }

        void            SetClassAssociation( CLASSASSOCIATION *pCA )
                                        {
                                        memcpy( &ClassAssociation, pCA, sizeof( CLASSASSOCIATION ));
                                        }

        void            GetClassAssociation( CLASSASSOCIATION * pCA )
                                        {
                                        memcpy( pCA, &ClassAssociation, sizeof( CLASSASSOCIATION ) );
                                        }
    }CLASS_ENTRY;

/*
   This is the structure of the entry made into the iid dictionary. The entry
   key is the IID field. The main data is the TypeLib and Clsid fields,
   which will be used in the IClassAdmin interface methods. Note that the Clsid
   field is the ProxyStubClsid32 field in the interface key in the registry.
*/

typedef class tagITF_ENTRY
    {
public:
    char                IID[ SIZEOF_STRINGIZED_CLSID ];
    char                Clsid[ SIZEOF_STRINGIZED_CLSID ];
        char            TypelibID[ SIZEOF_STRINGIZED_CLSID ];
public:
                                tagITF_ENTRY()
                                        {
                                        memset( IID, '\0', SIZEOF_STRINGIZED_CLSID );
                                        memset( Clsid, '\0', SIZEOF_STRINGIZED_CLSID );
                                        memset( TypelibID, '\0', SIZEOF_STRINGIZED_CLSID );
                                        }

        void            SetIIDString(char * StringizedIID )
                                        {
                                        strcpy( &IID[0], StringizedIID );
                                        }

        CLSIDString     *GetIIDString()
                                        {
                                        return &IID[0];
                                        }
        void            SetClsid( char * StringizedClsid )
                                        {
                                        strcpy( &Clsid[0], StringizedClsid );
                                        }
        void            SetTypelibID( char * StringizedClsid )
                                        {
                                        strcpy( &TypelibID[0], StringizedClsid );
                                        }

    } ITF_ENTRY;

/*
    This is the structure of the entry made into the package dictionary. The
    key is the PID field (Package ID).
*/

typedef class tagAPP_ENTRY
        {
public:
        char                    AppIDString[ SIZEOF_STRINGIZED_CLSID ];
        APPDETAIL               AppDetails;
        CLSID_List              ClsidList;
        CLSID_List      TypelibList;
        Name_List               RemoteServerNameList;
public:
                                        tagAPP_ENTRY()
                                                {
                                                memset(AppIDString, '\0', SIZEOF_STRINGIZED_CLSID );
                                                memset(&AppDetails, '\0', sizeof(APPDETAIL) );
                                                }
                                        ~tagAPP_ENTRY()
                                                {
                                                }
        void            SetAppIDString( char * StringizedClsid )
                                        {
                                        strcpy( &AppIDString[0], StringizedClsid );
                                        }

        CLSIDString     *GetAppIDString()
                                        {
                                        return &AppIDString[0];
                                        }

        void            GetAppDetail( APPDETAIL * pDest )
                                        {
                                        memcpy( pDest, &AppDetails, sizeof( APPDETAIL ));
                                        }

        void            AddClsid( char * Clsid )
                                        {
                                        ClsidList.Add( (unsigned char *)Clsid );
                                        AppDetails.cClasses++;
                                        }

        void            AddRemoteServerName( char * RemoteServerName )
                                        {
                                        RemoteServerNameList.Add( (unsigned char *)RemoteServerName );
                                        AppDetails.cServers++;
                                        }

        void            AddTypelib( char * Clsid )
                                        {
                                        TypelibList.Add( (unsigned char *)Clsid );
                                        AppDetails.cTypeLibIds++;
                                        }

        int                     GetClsidCount()
                                        {
                                        return ClsidList.GetCount();
                                        }

        int                     GetRemoteServerCount()
                                        {
                                        return RemoteServerNameList.GetCount();
                                        }

        int                     GetTypelibCount()
                                        {
                                        return TypelibList.GetCount();
                                        }
        }APP_ENTRY;

class APPDICT;
class NAMEDICT;

typedef class tagPACKAGE_ENTRY // package entry
    {
public:
    char            PIDString[ SIZEOF_STRINGIZED_CLSID ];
        char                    OriginalName[ _MAX_PATH ];                              // remove when not debugging
        char                    PackageName[ _MAX_PATH ];
        PACKAGEDETAIL   PackageDetails;
        APP_ENTRY_List  AppEntryList;
        NAMEDICT        *       ClsidsInNullAppid;
        NAMEDICT    *   TypelibsInNullAppid;
        NAMEDICT        *       RemoteServerNamesInNullAppid;
        APPDICT         *       pAppDict;
        int                             Count;
        int                             CountOfClsidsInNullAppid;
        int             CountOfTypelibsInNullAppid;
        int                             CountOfRemoteServerNamesInNullAppid;

public:
                                        tagPACKAGE_ENTRY();

                                        ~tagPACKAGE_ENTRY();


        void            SetOriginalName( char * p )
                                        {
                                        strcpy( &OriginalName[0], p );
                                        }

        char    *       GetOriginalName()
                                        {
                                        return ( &OriginalName[0] );
                                        }

        void            SetPIDString( char * StringizedClsid )
                                        {
                                        strcpy( &PIDString[0], StringizedClsid );
                                        }

        CLSIDString     *GetPIDString()
                                        {
                                        return &PIDString[0];
                                        }
        void             SetPackageName( char * pName )
                                        {
                                        strcpy( &PackageName[0], (const char *)pName );
                                        }

        void            GetPackageDetail( PACKAGEDETAIL * pDest )
                                        {
                                        memcpy( pDest, &PackageDetails, sizeof( PACKAGEDETAIL ));
                                        }
        void            SetPackageDetail( PACKAGEDETAIL * pSrc )
                                        {
                                        memcpy( &PackageDetails, pSrc, sizeof( PACKAGEDETAIL ));
                                        }

        void            AddAppEntry( APP_ENTRY * pAppEntry);

        APP_ENTRY * SearchAppEntry( char * pAppidString );


        void            AddClsidToNullAppid( char * pClsidString );

        void            AddTypelibToNullAppid( char * pTypelibClsidString );

        int             GetCountOfClsidsInNullAppid()
                                        {
                                        return CountOfClsidsInNullAppid;
                                        }
        char    *       GetFirstClsidInNullAppidList();

        int         GetCountOfTypelibsInNullAppid()
                        {
                        return CountOfTypelibsInNullAppid;
                        }

        char    *   GetFirstTypelibInNullAppidList();

    }PACKAGE_ENTRY;


typedef CLSID * POINTER_TO_CLSID;
typedef APPDETAIL * PAPPDETAIL;

char *  StringToCLSID( char    *   pString, CLSID   *   pClsid );
void    CLSIDToString( CLSID * pClsid, char  * pString );
char *  StringToULong( char * , unsigned long * );

#endif // __COMMON_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\detest\main.cxx ===
#include "precomp.hxx"
#pragma hdrstop


HRESULT RegisterDll(char * pszDll);
extern "C"
{
WINADVAPI LONG APIENTRY RegOverridePredefKey( HKEY, HKEY );
}

void DumpOnePackage(
        MESSAGE * pMessage,
        PACKAGEDETAIL * p );

void DumpOneAppDetail(
        MESSAGE * pMessage,
	    APPDETAIL * pA );

void DumpOneClass(
        MESSAGE * pMessage,
        CLASSDETAIL * pClassDetail );

void DumpIIDEntries(
         IIDICT * pIIDict );

void DumpOneIIDEntry(
        ITF_ENTRY * pITFEntry );

HRESULT VerifyArguments(
        MESSAGE * pMessage );
void
DumpOneTypelib(
    MESSAGE * pMessage,
    CLSID   * pClsid );

char *
ClassPathTypeToString(
    CLASSPATHTYPE i );

char *
ProcessorArchitectureToString(
    int i );

char *
PlatformIdToString(
    int i );

int
__cdecl main( int argc, char * argv[] )
{
    MESSAGE Message;
    BOOL    flag = FALSE;

    if( argc < 4 )
        {
        printf( "Usage: detest <package file name > <darwin script file path> <publish (1) or Assign (0)" );
        exit(1);
        }

    Message.fDumpOnly = 1;
    Message.pDumpOnePackage = DumpOnePackage;
    Message.pPackagePath = argv[1];
    Message.pAuxPath = argv[2];
    if( toupper(*(argv[3])) == 'P')
        flag = TRUE;
    DetectPackageAndRegisterIntoClassStore(&Message, Message.pPackagePath, flag, 0);
    return 0;
}

void
DumpOnePackage(
	MESSAGE * pMessage,
	PACKAGEDETAIL * p )
	{
	DWORD count;
	
	printf("\n++++++++++++++++++++++++++++++++++++++++++++++++++");
	
	printf( "\nClassPathType = %s", ClassPathTypeToString(p->PathType) );
	wprintf(L"\nPackagePath = %s", p->pszPath );
	wprintf(L"\nIconPath = %s", p->pszIconPath );
	wprintf(L"\nSetup Command = %s", p->pszSetupCommand );
	printf("\nActFlags = %d", p->dwActFlags );
	wprintf(L"\nVendor = %s", p->pszVendor );
	wprintf(L"\nPackageName = %s", p->pszPackageName );
	wprintf(L"\nProductName = %s", p->pszProductName );
	wprintf(L"\ndwContext = %d", p->dwContext );
	printf("\nCsPlatform = (PlatformID= %s, VersionHi = 0x%x, VersionLo = 0x%x, ProcessorArchitecture = %s",
             PlatformIdToString( p->Platform.dwPlatformId ),
             p->Platform.dwVersionHi,
             p->Platform.dwVersionLo,
             ProcessorArchitectureToString( p->Platform.dwProcessorArch ) );

	wprintf(L"\ndwLocale = 0x%x", p->Locale );

	wprintf(L"\ndwVersionHi = %d", p->dwVersionHi );
	wprintf(L"\ndwVersionLo = %d", p->dwVersionLo );
	wprintf(L"\nCountOfApps = %d", p->cApps );

	for( count = 0;
		 count < p->cApps;
		 ++count )
		{
		DumpOneAppDetail( pMessage, &p->pAppDetail[count] );
		}
	printf("\n--------------------------------------------------");
	}

void
DumpOneAppDetail(
	MESSAGE * pMessage,
	APPDETAIL * pA )
	{
	char Buffer[ 100 ];
	DWORD count;
	CLASS_ENTRY * pC;


	CLSIDToString( &pA->AppID, &Buffer[0] );
	printf( "\n\t\tAPPID = %s", &Buffer[0] );

	if( pA->cClasses )
		{
		for( count = 0;
			 count < pA->cClasses;
			 ++count )
			{

			char Buffer[50];
			CLSIDToString( &pA->prgClsIdList[count],&Buffer[0] );
			pC = pMessage->pClsDict->Search( &Buffer[0] );
			if( pC )
				DumpOneClass( pMessage, &pC->ClassAssociation );
			}
		}
	if( pA->cTypeLibIds )
	    {
		for( count = 0;
			 count < pA->cTypeLibIds;
			 ++count )
			{
			DumpOneTypelib( pMessage, pA->prgTypeLibIdList );
			}
	    }
	else
	    printf( "\n\t\t No Typelibs present" );
	}

	
void
DumpOneClass( MESSAGE * pMessage, CLASSDETAIL * pClassDetail )
	{
	char  Buffer[ _MAX_PATH ];
	DWORD count;

	CLSIDToString( &pClassDetail->Clsid, &Buffer[0] );
	printf( "\n\t\t\tCLSID = %s", &Buffer[0] );


	wprintf( L"\n\t\t\tDescription = %s", pClassDetail->pszDesc );
	wprintf( L"\n\t\t\tIconPath = %s", pClassDetail->pszIconPath );

	CLSIDToString( &pClassDetail->TreatAsClsid, &Buffer[0] );
	printf( "\n\t\t\tTreatAsClsid = %s", &Buffer[0] );

	CLSIDToString( &pClassDetail->AutoConvertClsid, &Buffer[0] );
	printf( "\n\t\t\tAutoConvertClsid = %s", &Buffer[0] );

	printf("\n\t\t\tCountOfFileExtensions = %d", pClassDetail->cFileExt );

	if( pClassDetail->cFileExt )
		{
		for(count = 0;
			count < pClassDetail->cFileExt;
			count++
			)
			{
			wprintf( L"\n\t\t\tFileExt = %s", pClassDetail->prgFileExt[ count ] );
			}
		}
	else
		{
		printf("\n\t\t\tOtherFileExt = None" );
		}

	wprintf(L"\n\t\t\tMimeType = %s", pClassDetail->pMimeType );
	wprintf(L"\n\t\t\tDefaultProgid = %s", pClassDetail->pDefaultProgId );

	printf("\n\t\t\tCountOfOtherProgIds = %d", pClassDetail->cOtherProgId );
	if( pClassDetail->cOtherProgId )
		{
		for(count = 0;
			count < pClassDetail->cOtherProgId;
			count++
			)
			{
			wprintf( L"\n\t\t\tOtherProgId = %s", pClassDetail->prgOtherProgId[ count ] );
			}
		}
	else
		{
		printf("\n\t\t\tOtherProgId = None" );
		}
	printf("\n");

	}

void
DumpOneTypelib(
    MESSAGE * pMessage,
    CLSID   * pClsid )
    {
	char  Buffer[ _MAX_PATH ];
	CLSIDToString( pClsid, &Buffer[0] );
	printf( "\n\t\t\tTypelibID = %s", &Buffer[0] );
	printf("\n");
    }

char *
ClassPathTypeToString(
    CLASSPATHTYPE i )
    {
static char * Map[] =  { "Exe", "Dll", "Tlb", "Cab", "Inf", "Darwin" };

    if( i > sizeof( Map ) / sizeof(char *) )
        return "Exe";
    return Map[ i ];
    }

char *
ProcessorArchitectureToString(
    int i )
    {
static char * Map[] = {
     "PROCESSOR_ARCHITECTURE_INTEL",
     "PROCESSOR_ARCHITECTURE_MIPS",
     "PROCESSOR_ARCHITECTURE_ALPHA",
     "PROCESSOR_ARCHITECTURE_PPC",
     "PROCESSOR_ARCHITECTURE_SH",
     "PROCESSOR_ARCHITECTURE_ARM"
     };

    if( i > sizeof( Map ) / sizeof( char * ) )
        return "PROCESSOR_ARCHITECTURE_UNKNOWN";

    return Map[ i ];
    }

char *
PlatformIdToString(
    int i )
    {
static  char * Map[] =  {
    "VER_PLATFORM_WIN32s",
    "VER_PLATFORM_WIN32_WINDOWS",
    "VER_PLATFORM_WIN32_NT"
    };

    if( i > sizeof( Map ) / sizeof( char * ) )
        return "VER_PLATFORM_UNKNOWN";
    return Map[ i ];
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\classid.cxx ===
/******************************************************************************
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassStore;
extern const IID IID_IClassAdmin;

LONG
UpdateClassEntryFromAutoConvert(
                               MESSAGE         *   pMessage,
                               BasicRegistry   *   pCLSID,
                               CLASS_ENTRY     *   pClassEntry );
LONG
UpdateClassEntryFromTreatAs(
                           MESSAGE         *   pMessage,
                           BasicRegistry   *   pCLSID,
                           CLASS_ENTRY     *   pClassEntry );
LONG
UpdateClassEntryFromServerType(
                              MESSAGE *   pMessage,
                              BasicRegistry * pCLSID,
                              CLASS_ENTRY *   pClassEntry );
LONG
UpdateClassEntryFromTypelib(
                           MESSAGE         *   pMessage,
                           BasicRegistry   *   pCLSID,
                           CLASS_ENTRY     *   pClassEntry );

LONG
UpdateClassEntryFromAppID(
                         MESSAGE     *   pMessage,
                         BasicRegistry * pCLSID,
                         CLASS_ENTRY *   pClassEntry,
                         char            *       pAppidBuffer );

ULONG
GeneratePackageDetails(
                      MESSAGE         *       pMessage,
                      BasicRegistry * pCLSID,
                      PACKAGEDETAIL * pPackageDetails );

ULONG
UpdateClassEntryFromServerType(
                              MESSAGE * pMessage,
                              APP_ENTRY * pAppEntry,
                              BasicRegistry * pCLSID );

ULONG
PackageFromServerType(
                     MESSAGE * pMessage,
                     DWORD   Context,
                     APP_ENTRY * pAppEntry,
                     BasicRegistry * pServerTypeKey,
                     BasicRegistry * pCLSID );

ULONG
UpdateClassEntryFromServerType(
                              MESSAGE * pMessage,
                              BasicRegistry * pCLSID,
                              APP_ENTRY * pAppEntry );

LONG
UpdatePackageFromClsid(
                      MESSAGE * pMessage,
                      BasicRegistry * pCLSID,
                      char * pClsidString,
                      char * pAppid );

LONG
UpdatePackage(
             MESSAGE * pMessage,
             BOOL      fUsageFlag,
             DWORD           Context,
             char    *       pClsidString,
             char        * pAppid,
             char    *       ServerName,
             DWORD   *   pMajorVersion,
             DWORD   *   pMinorVersion,
             DWORD   *   pLocale );


CLASSPATHTYPE
GetPathType(
           char * pExtension );

LPOLESTR
GetPath(
       char * pPath );

LPOLESTR
GetSetupCommand(
               char * pName );

LPOLESTR
MakePackageName(
               char * pName );

void

SetCSPlatform( CSPLATFORM * pCSPlatform );

/******************************************************************************
    Globals
 ******************************************************************************/
extern char * MapDriveToServerName[ 26 ];


LONG
UpdateDatabaseFromCLSID(
                       MESSAGE * pMessage )
/*****************************************************************************
    Purpose:
        Update the internal database from clsid entries under the root key
        specified by the message.
    In Arguments:
        Message - A message block that contains the root of the key that has
                  class id etc related information.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        A Win32 error code specifying success or the kind of failure.
    Remarks:
        The routine only returns an error code of ERROR_NO_MORE_ITEMS.
 *****************************************************************************/
{
    BasicRegistry * pHKCR = new BasicRegistry( pMessage->hRoot ); // HKCR
    BasicRegistry * pCLSIDUnderHKCR;
    CLSDICT       * pClsDict = pMessage->pClsDict;
    BOOL            fNewEntry = 0;
    int             Index;
    LONG            CLSIDError = ERROR_SUCCESS;
    CLASS_ENTRY   * pClassEntry;

    //
    // Get the first clsid key under HKCR
    //

    if ( pHKCR->Find( "CLSID", &pCLSIDUnderHKCR ) != ERROR_SUCCESS )
        return ERROR_NO_MORE_ITEMS;


    //
    // Go thru all the subkeys under CLSID and get the details under the keys.
    //

    for ( Index = 0, fNewEntry = 0;
        CLSIDError != ERROR_NO_MORE_ITEMS;
        ++Index )
    {
        char    CLSIDBuffer[256];
        DWORD   SizeOfCLSIDBuffer = sizeof(CLSIDBuffer)/sizeof(char);
        char    AppidBuffer[ 256 ];
        BasicRegistry * pCLSID;


        //
        // Get the name of the key - the next one under HKCRCLSID that
        // matches our time stamp criteria.
        //

        CLSIDError = pCLSIDUnderHKCR->NextKey(
                                             CLSIDBuffer,
                                             &SizeOfCLSIDBuffer,
                                             &pCLSID,
                                             pMessage->ftLow,
                                             pMessage->ftHigh);

        if ( (CLSIDError == ERROR_SUCCESS ) &&
             (CLSIDBuffer[0] == '{') )
        {

            //
            // We got a valid classid entry. See if it is in the database
            // already, if not make a new entry and update that with the
            // classid related details.
            //

            char * pT = new char [SizeOfCLSIDBuffer+1];
            strcpy( pT, CLSIDBuffer );

            if ( (pClassEntry = pClsDict->Search( CLSIDBuffer ) ) == 0 )
            {
                pClassEntry = new CLASS_ENTRY;
                fNewEntry = 1;
            }

            memcpy( pClassEntry->ClsidString,
                    &CLSIDBuffer,
                    SIZEOF_STRINGIZED_CLSID );

            //
            // Update class entry from subkeys.
            //

            // update frm "autoconvert" value. ignore error, since optional.

            UpdateClassEntryFromAutoConvert( pMessage, pCLSID, pClassEntry );

            // update frm "treatas" value. ignore error, since optional.

            UpdateClassEntryFromTreatAs( pMessage, pCLSID, pClassEntry );

            //
            // Update from clsid. Although this is optional, the appid setting
            // is important in that it determines if a classid falls under an
            // appid that is supported by a package or if it is a clsid that
            // does not have an appid. A package can have both - clsids
            // which have appids or those that dont.
            //

            BOOL fAdded = FALSE;

            // Check if this class id has an app id.

            if ( UpdateClassEntryFromAppID( pMessage,
                                            pCLSID,
                                            pClassEntry,
                                            &AppidBuffer[0] ) )
            {

                // yes this classid has an appid, so enter into the app detail
                // structure corresponding to the appid.

                fAdded = UpdatePackageFromClsid( pMessage, pCLSID, pT, &AppidBuffer[0] );
            }
            else
            {

                // no, this classid does not have an appid associated, so
                // enter this into the null appid group.

                fAdded = UpdatePackageFromClsid( pMessage, pCLSID, pT, 0 );
            }

            if ( fNewEntry && fAdded)
                pClsDict->Insert( pClassEntry );
        }
        else if ( CLSIDError == ERROR_SUCCESS )
        {
            delete pCLSID;
        }

    }

    //
    // delete the CLSID key under HKCR
    //

    delete pCLSIDUnderHKCR;

    if ( CLSIDError == ERROR_NO_MORE_ITEMS )
        return ERROR_SUCCESS;


    return ERROR_SUCCESS;
}

LONG
UpdatePackageFromClsid(
                      MESSAGE * pMessage,
                      BasicRegistry * pCLSID,
                      char * pClsidString,
                      char * pAppid )
/*****************************************************************************
    Purpose:
        To update package details from package id.
    In Arguments:
        pMessage    - Message block passing info between modules.
        pCLSID      - An open Key to the registry for the specified clsid.
        pClsidString- A stringized clsid used for entring into appid database.
        pAppid      - Stringized appid to enter into the package database.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        Status. 1 - need to add CLSID, 0 - don't need to add CLSID
    Remarks:
        A package is a collection of individual executables. Under the CLSID key
        in a registry can be a number of packages: inproc handlers, inproc
        servers and local and remote servers. Each of these qualify as
        individual packages unless packaged in say a cab file. That overall
        packaging  is specified by the package path field in the message.
        Therefore this routine goes thru all individual packages as specified
        under the CLSID key and attempts to generate packages for them. The
        Update package routine then decides what the package type is based on
        whether the message field has a package path specified. It is very
        possible (and happens for .Cab files) for CLSID entries of local server
        inproc handler etc to end up in one package

 *****************************************************************************/
{
    // class context mapping array.

    static DWORD ClassContextArray[] =
    {
        CLSCTX_INPROC_HANDLER,
        CLSCTX_INPROC_SERVER,
        CLSCTX_LOCAL_SERVER,
        CLSCTX_REMOTE_SERVER
// BUGBUG - what about the 16-bit cases?
//        ,
//        CLSCTX_INPROC_SERVER16,
//        CLSCTX_LOCAL_SERVER,
//        CLSCTX_INPROC_HANDLER16
    };

    // Keys that map to a class context.
    // Must have same number of elements as ClassContextArray.

    static char * pKeyNamesArray[] =
    {
        "InprocHandler32",
        "InprocServer32",
        "LocalServer32",
        "RemoteServer32"
//        ,
//        "InprocServer",
//        "LocalServer",
//        "InprocHandler"
    };

    LONG lReturn = 0;

    int Index;

    for ( Index = 0;
        Index < sizeof(pKeyNamesArray) / sizeof(pKeyNamesArray[0]) ;
        Index++ )
    {
        // Search for all the server types under the CLSID. If available, create
        // packages for those server types.

        BasicRegistry * pServerTypeKey;
        LONG E;

        // check if a potential package of the type specified exists in the
        // registry. In other words, check if one of the above specified keys
        // exists under the clsid key.
        //

        E = pCLSID->Find( pKeyNamesArray[ Index ], &pServerTypeKey );

        if ( E == ERROR_SUCCESS )
        {

            //
            // Yes, a key for the specified server type exists.
            // Get its named value. Based on this we will attempt to enter
            // a new package in our database.
            //

            char ServerName[_MAX_PATH];
            DWORD   ServerNameLength;

            ServerNameLength = sizeof( ServerName) / sizeof( char );

            E = pServerTypeKey->QueryValueEx( 0,
                                              &ServerName[0],
                                              &ServerNameLength );

            //
            // A server name may have a switch specified for execution. That
            // is not significant for our class store update, but is significant
            // in that it should not be part of the server name to enter into
            // the class store. Make sure we ignore it.
            //

            if ( E == ERROR_SUCCESS )
            {
                // remove any '/' switch characters, so we dont get confused.

                char * p = strchr( &ServerName[0], '/' );

                if ( p )
                {
                    while ( *(--p) == ' ' );
                    *(p+1) = '\0';
                }

                //
                // call common routine to update package from clsid and appid
                // details.
                //

                UpdatePackage( pMessage,
                               0, // clsid update - not a typelib id update
                               ClassContextArray[ Index ],
                               pClsidString,
                               pAppid,
                               &ServerName[0],
                               0,
                               0,
                               0 );

            }
            else
            {
                // It is possible that the tag may not have a name, in
                // which case we need to create a package entry using the
                // original package path.
                UpdatePackage( pMessage,
                               0, // clsid update
                               ClassContextArray[ Index ],
                               pClsidString,
                               pAppid,
                               pMessage->pPackagePath,
                               0,
                               0,
                               0 );
            }
            delete pServerTypeKey;
            // We've found one entry and that's enough to get everything we
            // need to know to be able to populate the class store so we're
            // going to break out of the for loop here.
            // BUGBUG - For beta 2 we need to simplify this code so that we
            // don't even bother looking for this.  Most of this code
            // is here to support features that the class store was going to
            // have once upon a time.  Since then, the class store has been
            // redesigned and we really don't need all of this junk.
            lReturn = 1;
            break;
        }

    }
    return lReturn;
}

LONG
UpdatePackage(
             MESSAGE * pMessage,
             BOOL        fUsage,
             DWORD           Context,
             char    *       pClsidString,
             char        * pAppid,
             char    *   ServerName,
             DWORD   *   pMajor,
             DWORD   *   pMinor,
             LCID   *   pLocale )
/*****************************************************************************
    Purpose:
        Update package details in database based on clsid and appid.
    In Arguments:
        pMessage    - Message block passing arguments between modules.
        fUsageFlag  - 0 if clsid is being updated in appid list or 1 if a
                      typelib is being updated in appid list.
        pClsidString- A stringized clsid/typelibid used for entring into
                      appid database.
        pAppid      - Stringized appid to enter into the package database.
        ServerName  -   String used to identify the original server name.
        pMajor      - Major version number
        pMinor      - Minor version number
        pLocale     - locale.
    Out Arguments:
    InOut Arguments:
    Return Arguments:
    Remarks:
        Version#s and locale info are pointers. This routine is used by typelib
        update routine also. They usually have version and locale info, but
        general packages do not. Therefore the routine has pointers to indicate
        if info is available and if so, update it.

        If the message has a package path, it indicates that the server
        supporting the classid is part of that package. So the package path
        determines the package type etc and overrides any server names specified
        in the CLSID key

        We are also making an assumption that there is no appid associated with
        a typelib, so we can asssume that all typelib entries go to the null
        appid list only. If this changes, then use the AddTypelib method in
        APP_ENTRY to update the app entry.


        THIS ROUTINE NEEDS CLEANUP - IT IS A HACK AFTER HACK AFTER HACK
 *****************************************************************************/
{
    PDICT   * pPackageDict = pMessage->pPackageDict;
    PACKAGE_ENTRY * pPackageEntry;
    char    Name[ _MAX_FNAME ];
    char    Ext[ _MAX_EXT ];
    char    PackageName[ _MAX_PATH ];
    PACKAGEDETAIL   PackageDetails;
    LONG Error = 0;
    APP_ENTRY * pAppEntry;
    char * p;
    CSPLATFORM CSPlatform;
    SetCSPlatform( &CSPlatform);


    // clear the package details structure.

    memset(&PackageDetails, '\0', sizeof( PackageDetails ));


    //
    // If package path exists, then the extension etc determine the package
    // type. If not, the server name (localserver/handler name etc) determines
    // the package type.
    //


    if ( p = pMessage->pPackagePath )
    {
        _splitpath( pMessage->pPackagePath, NULL, NULL, Name, Ext );
    }
    else
    {
        p = ServerName;
        _splitpath( ServerName, NULL, NULL, Name, Ext );
    }

    if (pMessage->pPackageName)
    {
        strcpy(PackageName, pMessage->pPackageName);
    }
    else
    {
        strcpy( PackageName, Name );
        strcat( PackageName, Ext );
        pMessage->pPackageName = new char[strlen(PackageName)+1];
        strcpy(pMessage->pPackageName, PackageName);
    }


    // Check if we already have the package name in the dictionary.

    pPackageEntry = pPackageDict->Search( &PackageName[0], Context );

    // if we do not, make a new package entry.

    if (!pPackageEntry)
    {
        pPackageEntry = new PACKAGE_ENTRY;
        strcpy( &pPackageEntry->PackageName[0], &PackageName[0] );

        PackageDetails.dwContext =( pMessage->pPackagePath )
                                  ? CLSCTX_INPROC_SERVER + CLSCTX_LOCAL_SERVER :
                                  Context; // Context temp workaround
        if ( pMessage->fPathTypeKnown )
            PackageDetails.PathType = pMessage->PathType;
        else
            PackageDetails.PathType = GetPathType( &Ext[0] );

        if ( (pMessage->pAuxPath) && (PackageDetails.PathType == DrwFilePath))
            PackageDetails.pszPath = GetPath( pMessage->pAuxPath );
        else
            PackageDetails.pszPath = GetPath( p );

        PackageDetails.pszIconPath = GetPath( p );
        if ( pMessage->pSetupCommand )
            PackageDetails.pszSetupCommand = GetPath( pMessage->pSetupCommand );
        PackageDetails.dwActFlags = pMessage->ActFlags;
        PackageDetails.pszPackageName = MakePackageName( &PackageName[0] );
        PackageDetails.pszProductName = MakePackageName( &Name[0] );

        PackageDetails.Platform = CSPlatform;

        if (pLocale )
            PackageDetails.Locale = *pLocale;
        else
            PackageDetails.Locale =
            MAKELCID(
                    MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),
                    SORT_DEFAULT );

        if ( pMajor )
            PackageDetails.dwVersionHi = *pMajor;
        else
            PackageDetails.dwVersionHi = 0;
        if ( pMinor )
            PackageDetails.dwVersionLo = *pMinor;
        else
            PackageDetails.dwVersionLo = 0;

        PackageDetails.cApps = 0;
        PackageDetails.pAppDetail = 0;



        // set the package details.

        pPackageEntry->SetPackageDetail( &PackageDetails );


        // store the original name so that we can dump it.

        pPackageEntry->SetOriginalName( ServerName );


        // Add this into the package dictionary.

        pMessage->pPackageDict->Insert( pPackageEntry );

    }


    // search for the app entry. The class entry needs to be entered
    // there. If there is no app id specified (appentry is null )
    // get the app entry whose ID is 0. All classes that do not have
    // an app id specified, will go into this bucket. Finally we will
    // assign an appid to it and enter into the class store.

    if ( !pAppid )
    {
        // There is no appid. Enter the clsid entry in the null appid.

        if ( fUsage == 0 )
            pPackageEntry->AddClsidToNullAppid( pClsidString );
        else
            pPackageEntry->AddTypelibToNullAppid( pClsidString );
    }
    else
    {
        pAppEntry = pPackageEntry->SearchAppEntry( pAppid );
        if ( !pAppEntry )
        {
            pAppEntry = new APP_ENTRY;
            pAppEntry->SetAppIDString( pAppid );
            pPackageEntry->AddAppEntry( pAppEntry );
        }
        pAppEntry->AddClsid( pClsidString );


    }

    return 0;


}

CLASSPATHTYPE
GetPathType(
           char * pExt )
/*****************************************************************************
    Purpose:
        Map the file extension to CLASSPATHTYPE
    In:
        pExt    - File Extension to map
    Out:
        None.
    InOut:
        None.
    Return:
        CLASSPATHTYPE of the file extension.
    Remarks:
        olb is apparently an extension that implies "old type library"-whatever
        that is.
        If no standard mapping is found, a CLASSPATHTYPE of ExeNamePath is
        returned.
 *****************************************************************************/
{
    // extensions to map.

    static char * ExtArray[] =
    { ".dll",
        ".exe",
        ".cab",
        ".tlb",
        ".inf",
        ".olb"
    };

    // CLASSPATHTYPEs to map the extensions to.

    static CLASSPATHTYPE PathType[] =
    {
        DllNamePath,
        ExeNamePath,
        CabFilePath,
        TlbNamePath,
        InfFilePath,
        TlbNamePath
    };

    int index;
    int     fFound = -1;


    for ( index = 0;
        index < sizeof( ExtArray ) / sizeof( char * );
        ++index )
    {
        if ( _stricmp( pExt, ExtArray[index] ) == 0 )
        {
            fFound = index;
            break;
        }
    }

    if ( fFound != -1 )
    {
        return PathType[ index ];
    }
    else
        return ExeNamePath;

}

LPOLESTR
GetPath(
       char * pPath )
/*****************************************************************************
    Purpose:
        Map a char * path to a wide character path
    In Arguments:
        pPath   - Path to the file to translate to wide char.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        The translated file path.
    Remarks:
 *****************************************************************************/
{
    if ( pPath )
    {
        LPOLESTR        p = new OLECHAR[ (MAX_PATH+1) * 2 ];
        mbstowcs( p, pPath, strlen(pPath)+1 );
        return p;
    }
    return 0;
}

LPOLESTR
GetSetupCommand(
               char * pSetupCommandLine )
/*****************************************************************************
    Purpose:
        Translate setup command line to wide char.
    In Arguments:
        Setup command line.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        The translated setup command line.
    Remarks:
        For now the setup command line is setup.exe
 *****************************************************************************/
{
    LPOLESTR        p = new OLECHAR[ (MAX_PATH+1) * 2 ];
    mbstowcs( p, "setup.exe", strlen("setup.exe")+1 );
    return p;
}


LPOLESTR
MakePackageName(
               char * pName )
/*****************************************************************************
    Purpose:
        Translate package name to wide char.
    In Arguments:
        package name to translate.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        translated command line
    Remarks:
 *****************************************************************************/
{
    LPOLESTR        p = new OLECHAR[ (MAX_PATH+1) * 2 ];
    mbstowcs( p, pName, strlen(pName)+1 );
    return p;

}

LONG
UpdateClassEntryFromAutoConvert(
                               MESSAGE         *   pMessage,
                               BasicRegistry   *   pCLSID,
                               CLASS_ENTRY     *   pClassEntry )
/*****************************************************************************
    Purpose:
        Update the classid entry in the data base with the autoconvert field.
    In Arguments:
        pMessage    - Message block passing arguments between modules.
        pCLSID      - pointer to class representing the registry key.
        pClassEntry - The class entry data structure to update.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        Status.
    Remarks:
 *****************************************************************************/
{
    LONG            error;
    char            Data[SIZEOF_STRINGIZED_CLSID];
    DWORD           SizeOfData = sizeof(Data)/sizeof(char);

    error = pCLSID->QueryValue( "AutoConvertTo", &Data[0], &SizeOfData );

    if ( error == ERROR_SUCCESS )
    {
        StringToCLSID(
                     &Data[1],
                     &pClassEntry->ClassAssociation.AutoConvertClsid );
    }
    return error;
}

LONG
UpdateClassEntryFromTreatAs(
                           MESSAGE         *   pMessage,
                           BasicRegistry   *   pCLSID,
                           CLASS_ENTRY     *   pClassEntry )
/*****************************************************************************
    Purpose:
        Update the class entry in the database with the Treatas key.
    In Arguments:
        pMessage    - Message block passing arguments between modules.
        pCLSID      - pointer to class representing the registry key.
        pClassEntry - The class entry data structure to update.
    Out Arguments:
        None.
    InOut Arguments:
        None.
    Return Arguments:
        Status.
    Remarks:
 *****************************************************************************/
{
    LONG            error;
    char            Data[SIZEOF_STRINGIZED_CLSID];
    DWORD           SizeOfData = sizeof(Data)/sizeof(char);

    error = pCLSID->QueryValue( "TreatAs", &Data[0], &SizeOfData );
    if ( error == ERROR_SUCCESS )
    {
        StringToCLSID(
                     &Data[1],
                     &pClassEntry->ClassAssociation.TreatAsClsid );
    }
    return error;
}

LONG
UpdateClassEntryFromAppID(
                         MESSAGE     *   pMessage,
                         BasicRegistry * pCLSID,
                         CLASS_ENTRY *   pClassEntry,
                         char            *       pAppidBuffer )
/*****************************************************************************
    Purpose:
        Update the class entry in the database with the Appid key.
    In Arguments:
        pMessage    - Message block passing arguments between modules.
        pCLSID      - pointer to class representing the registry key.
        pClassEntry - The class entry data structure to update.
    Out Arguments:
        pAppIdBuffer- Buffer which receives the stringized appid value.
    InOut Arguments:
        None.
    Return Arguments:
        Status.
    Remarks:
        This routine looks for the presence of an appid on a clsid. The appid
        key will determine the appdetails structure that the clsid will go into.

 *****************************************************************************/
{

    LONG    error;
    APP_ENTRY * pAppEntry = 0;
    DWORD   SizeOfAppIDValue = SIZEOF_STRINGIZED_CLSID;
    char    AppIDValue[ SIZEOF_STRINGIZED_CLSID ];
    BOOL    fNewEntry = 0;



    error = pCLSID->QueryValueEx( "AppID", &AppIDValue[0], &SizeOfAppIDValue );

    if ( error == ERROR_SUCCESS )
    {
        memcpy( pAppidBuffer, &AppIDValue[0], SIZEOF_STRINGIZED_CLSID );
        return 1;
    }
    else
        return 0;
}

void
SetCSPlatform(
             CSPLATFORM * pCSPlatform )
{
//    OSVERSIONINFO VersionInformation;

//    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
//    GetVersionEx(&VersionInformation);

//    pCSPlatform->dwPlatformId = VersionInformation.dwPlatformId;
//    pCSPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
//    pCSPlatform->dwVersionLo = VersionInformation.dwMinorVersion;

#if 0
    // this is not supported for Beta 1
    pCSPlatform->dwPlatformId = -1; // any OS platform
    pCSPlatform->dwVersionHi = 0;
    pCSPlatform->dwVersionLo = 0;
#else
    pCSPlatform->dwPlatformId = VER_PLATFORM_WIN32_NT;
    pCSPlatform->dwVersionHi = 5;
    pCSPlatform->dwVersionLo = 0;
#endif

    // pCSPlatform->dwProcessorArch = PROCESSOR_ARCHITECTURE_INTEL;

    SYSTEM_INFO si;
    GetSystemInfo(&si);

    pCSPlatform->dwProcessorArch = si.wProcessorArchitecture;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\appdict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:
	
	appdict.cxx

 Abstract:

	This file stores the indexes of all class assocation entries based on IID.

 Notes:


 History:

 	VibhasC		Sep-29-1996		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "precomp.hxx"


void
APPDICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all ITF_ENTRY indexes allocated.

 	NOTE: tHIS FUNCTION DOES NOT DELETE THE ITF_ENTRY, BUT ONLY THE INDEX
 	OF THE CLASS ENTRY

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		        Status;
	APP_ENTRY	*	        pClassEntry;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pClassEntry = (APP_ENTRY *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pClassEntry );
		}

}

APP_ENTRY *
APPDICT::GetFirst()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the first item in the dictionary

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;
	APP_ENTRY	    *	        pClassEntry;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	if( SUCCESS == Status )
		return pClassEntry = (APP_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

APP_ENTRY *
APPDICT::GetNext( APP_ENTRY * pLastClassEntry)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the next item in the dictionary

 Arguments:

 	pLastClassEntry.
	
 Return Value:
	
	None.

 Notes:
    pLastClassEntry is the entry returned by the previous call to GetFirst
    or GetNext. This is the seed for this search.

    This function returns a zero if there are no more entries in the
    dictionary.

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary. But if we supply the last searched
	// item, we get the next in the dictionary.
	//

	if( (Status = Dict_Next( pLastClassEntry) ) == SUCCESS )
		return pLastClassEntry = (APP_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

APP_ENTRY *
APPDICT::Insert(
	APP_ENTRY	*	        pClassEntry )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a class entry in the index.

 Arguments:
	
 Return Value:
	
 	A pointer to the APP_ENTRY entry which was created and inserted.

 Notes:

	Search for the class association entry and if it exists, return that,
	do not create a new one.
----------------------------------------------------------------------------*/
{

	Dict_Status		Status	= Dict_Find( pClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			Dict_Insert( (pUserType) pClassEntry );
			return pClassEntry;
		default:
			return (APP_ENTRY *)Dict_Curr_Item();
		}
}

APP_ENTRY *
APPDICT::Search(
	char    * Iid, DWORD Context )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a class entry in the dictionary.

 Arguments:
	
	pClassEntry	- Name of the APP_ENTRY being searched for.

 Return Value:
	
	A		pointer to the APP_ENTRY expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
	//
	// In order to search, we must create a dummy APP_ENTRY to compare
	// against. We initialize this with the class id passed and search for it.
	//

	APP_ENTRY	DummyClassEntry;
	Dict_Status		Status;

    memset(&DummyClassEntry, '\0', sizeof( APP_ENTRY ) );
    memcpy( (char *)&DummyClassEntry.AppIDString[0], Iid , SIZEOF_STRINGIZED_CLSID );
    
	//
	// Search.
	//

	Status	= Dict_Find( &DummyClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (APP_ENTRY *)0;
		default:
			return (APP_ENTRY *)Dict_Curr_Item();
		}
}

int
APPDICT::Compare(
	 void * p1,
	 void * p2 )
	{
	APP_ENTRY 	*	pRes1	= (APP_ENTRY *)p1;
	APP_ENTRY	    *	pRes2 	= (APP_ENTRY *)p2;
	int             Result;

	Result =  _memicmp( p1, p2, SIZEOF_STRINGIZED_CLSID );

	Result = (Result < 0) ? -1 : (Result > 0) ? 1 : 0;
	return Result;
	}

void
PrintAPP_ENTRYKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\clsdict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:
	
	clsdict.cxx

 Abstract:

	This file stores the indexes of all class assocation entries based on clsid.

 Notes:


 History:

 	VibhasC		Sep-29-1996		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "precomp.hxx"

void
CLSDICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all CLASS_ENTRY indexes allocated.

 	NOTE: tHIS FUNCTION DOES NOT DELETE THE CLASS_ENTRY, BUT ONLY THE INDEX
 	OF THE CLASS ENTRY

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		        Status;
	CLASS_ENTRY	*	        pClassEntry;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pClassEntry = (CLASS_ENTRY *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pClassEntry );
		}

}

CLASS_ENTRY *
CLSDICT::GetFirst()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the first item in the dictionary

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;
	CLASS_ENTRY	*	        pClassEntry;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	if( SUCCESS == Status )
		return pClassEntry = (CLASS_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

CLASS_ENTRY *
CLSDICT::GetNext( CLASS_ENTRY * pLastClassEntry)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the next item in the dictionary

 Arguments:

 	pLastClassEntry.
	
 Return Value:
	
	None.

 Notes:
    pLastClassEntry is the entry returned by the previous call to GetFirst
    or GetNext. This is the seed for this search.

    This function returns a zero if there are no more entries in the
    dictionary.

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary. But if we supply the last searched
	// item, we get the next in the dictionary.
	//

	if( (Status = Dict_Next( pLastClassEntry) ) == SUCCESS )
		return pLastClassEntry = (CLASS_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

CLASS_ENTRY *
CLSDICT::Insert(
	CLASS_ENTRY	*	        pClassEntry )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a class entry in the index.

 Arguments:
	
 Return Value:
	
 	A pointer to the CLASS_ENTRY entry which was created and inserted.

 Notes:

	Search for the class association entry and if it exists, return that,
	do not create a new one.
----------------------------------------------------------------------------*/
{

	Dict_Status		Status	= Dict_Find( pClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			Dict_Insert( (pUserType) pClassEntry );
			return pClassEntry;
		default:
			return (CLASS_ENTRY *)Dict_Curr_Item();
		}
}

CLASS_ENTRY *
CLSDICT::Search(
	char    * Clsid )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a class entry in the dictionary.

 Arguments:
	
	pClassEntry	- Name of the CLASS_ENTRY being searched for.

 Return Value:
	
	A		pointer to the CLASS_ENTRY expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
	//
	// In order to search, we must create a dummy CLASS_ENTRY to compare
	// against. We initialize this with the class id passed and search for it.
	//

	CLASS_ENTRY	DummyClassEntry;
	Dict_Status		Status;

    memcpy( &DummyClassEntry, Clsid, SIZEOF_STRINGIZED_CLSID );

	//
	// Search.
	//

	Status	= Dict_Find( &DummyClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (CLASS_ENTRY *)0;
		default:
			return (CLASS_ENTRY *)Dict_Curr_Item();
		}
}

int
CLSDICT::Compare(
	 void * p1,
	 void * p2 )
	{
	CLASS_ENTRY 	*	pRes1	= (CLASS_ENTRY *)p1;
	CLASS_ENTRY	    *	pRes2 	= (CLASS_ENTRY *)p2;

	return _memicmp( p1, p2, SIZEOF_STRINGIZED_CLSID );
	}

void
PrintCLASS_ENTRYKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\list.cxx ===
#include "precomp.hxx"
#pragma hdrstop

void
List::Add( void * pElement )
    {
    ListEntry * pNew = new ListEntry;
    
    pNew->pNext = 0;
    pNew->pElement = pElement;

    if( pCurrent )
        pCurrent->pNext = pNew;
    else
        pFirst = pNew;
    pCurrent = pNew;
	Count++;
    }
/**************
int
List::Search( unsigned char * pElement )
    {
    ListEntry * pEntry = pFirst;

    for( pEntry = pFirst;
         pEntry != 0;
         pEntry = pEntry->pNext )
        {
        if( _stricmp( (const char *) pEntry->pElement, (const char *) pElement ) == 0 )
            return 0;
        }
    return -1;
    }
**************/
void
List::Clear()
    {
    ListEntry * pEntry = pFirst;

    for( pEntry = pFirst;
         pEntry != 0;
         pEntry = pEntry->pNext )
        {
        if( pEntry )
            delete pEntry;
        }
	Count = 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\iid.cxx ===
/******************************************************************************
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassStore;
extern const IID IID_IClassAdmin;

LONG
UpdateDatabaseFromIID(
    MESSAGE * pMessage )
    {
        BasicRegistry * pHKCR = new BasicRegistry( pMessage->hRoot ); // HKCR
    BasicRegistry * pInterfaceRoot;
    IIDICT        * pIIDict = pMessage->pIIDict;
    BOOL            fFinish = 0;
    int             Index;
    LONG            Error;


        //
    // Get the first IID key under HKCR
    //

    Error = pHKCR->Find( "Interface", &pInterfaceRoot );

        if( Error == ERROR_NO_MORE_ITEMS )
                return ERROR_SUCCESS;

    //
    // Go thru all the subkeys under Interface and get the details under the keys.
    //

        pInterfaceRoot->InitForEnumeration( 0 );

    for( Index = 0;
         fFinish != 1;
         ++Index )
                {
                BasicRegistry * pKey;
                char                    InterfaceKeyBuffer[ 256 ];
                DWORD                   SizeOfInterfaceKeyBuffer = 256;


                Error = pInterfaceRoot->NextKey(
                            &InterfaceKeyBuffer[0],
                            &SizeOfInterfaceKeyBuffer,
                            &pKey,
                            pMessage->ftLow,
                            pMessage->ftHigh );

                if( Error != ERROR_NO_MORE_ITEMS )
                        {
                        BasicRegistry * pProxyClsidKey;

                        // get the proxystubclsid key under this.

                        Error = pKey->Find("ProxyStubclsid32", &pProxyClsidKey );

                        if( Error != ERROR_NO_MORE_ITEMS )
                                {
                                char    PSBuffer[ 256 ];
                                DWORD   SizeofPSBuffer = 256;

                                // Get the unnamed value. That is the clsid value.i
                // Enter that into the iidict.

                                Error = pProxyClsidKey->QueryValue(
                                                "",
                                                &PSBuffer[0],
                                                &SizeofPSBuffer );

                                if( Error != ERROR_NO_MORE_ITEMS )
                                        {
                                        ITF_ENTRY * pITFEntry = pMessage->pIIDict->Search(
                                                       &InterfaceKeyBuffer[0] );

                                        if( !pITFEntry )
                                                {
                                                pITFEntry = new ITF_ENTRY;
                                                pITFEntry->SetIIDString( &InterfaceKeyBuffer[0] );
                                                pMessage->pIIDict->Insert( pITFEntry );
                                                }
                                        pITFEntry->SetClsid( &PSBuffer[0] );
                                        }
                                delete pProxyClsidKey;
                                }
                        delete pKey;
                        }
                else
                        fFinish = 1;

                }

        return ERROR_SUCCESS;

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\dict.cxx ===
/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

                  RPC - Written by Dov Harel


        This file contains the implementation for splay tree self
        adjusting binary trees
-------------------------------------------------------------------- */

#if 0

#include "objidl.h"
#include "common.h"

#endif // 0

#include "precomp.hxx"

// handly macros used to define common tree operations

#define ROTATELEFT  tmp=t->right; t->right=tmp->left;  tmp->left =t; t=tmp
#define ROTATERIGHT tmp=t->left;  t->left =tmp->right; tmp->right=t; t=tmp

#define LINKLEFT  tmp=t; t = t->right; l = l->right = tmp
#define LINKRIGHT tmp=t; t = t->left;  r = r->left = tmp

#define ASSEMBLE r->left = t->right;     l->right = t->left; \
                 t->left = Dummy->right; t->right = Dummy->left

       TreeNode Dumbo(Nil);
static TreeNode *Dummy = &Dumbo;        // a global dummy node

TreeNode *
GetGlobalTreeNode()
{
    return( &Dumbo );
}


// initialize the memory allocator for TreeNode

//*************************************************************************
//*****              Core functions (internal)                        *****
//*************************************************************************

long                                    // return last comparision
Dictionary::SplayUserType(              // general top down splay

    pUserType keyItem   // pointer to a "key item" searched for

) //-----------------------------------------------------------------------//
{
    TreeNode* t;        // current search point
    TreeNode* l;        // root of "left subtree" < keyItem
    TreeNode* r;        // root of "right subtree" > keyItem
    long kcmp;          // cash comparison results
    TreeNode* tmp;

    if ((fCompare = Compare(keyItem, root->item)) == 0)
        return (fCompare);

    Dummy = l = r = &Dumbo;
    Dumbo.left = Dumbo.right = Nil;

    t = root;

    do {
        if ( fCompare < 0 ) {
            if ( t->left == Nil ) break;

            if ( (kcmp = Compare(keyItem, t->left->item)) == 0 ) {
                LINKRIGHT;
            }
            else if ( kcmp < 0 ) {
                ROTATERIGHT;
                if ( t->left != Nil ) {
                    LINKRIGHT;
                }
            }
            else { // keyItem > t->left->item
                LINKRIGHT;
                if ( t->right != Nil ) {
                    LINKLEFT;
                }
            }
        }
        else { // keyItem > t->item
            if ( t->right == Nil ) break;

            if ( (kcmp = Compare(keyItem, t->right->item)) == 0 ) {
                LINKLEFT;
            }
            else if ( kcmp > 0 ) {
                ROTATELEFT;
                if ( t->right != Nil ) {
                    LINKLEFT;
                }
            }
            else { // keyItem < t->right->item
                LINKLEFT;
                if ( t->left != Nil ) {
                    LINKRIGHT;
                }
            }
        }
    } while ( (fCompare = Compare(keyItem, t->item)) != 0 );

    ASSEMBLE;

//  if (fCompare != Compare(keyItem, t->item))
//      printf("Dictionary error!");

    root = t;
    return(fCompare);
}

TreeNode*
SplayLeft(

    TreeNode* t         // root of tree & current "search" point

) //-----------------------------------------------------------------------//
{
    TreeNode* l=Dummy;  // root of "left subtree" < keyItem
    TreeNode* r=Dummy;  // root of "right subtree" > keyItem
    TreeNode* tmp;

    if (t == Nil || t->left == Nil)
        return(t);

    if (t->left->left == Nil) {
        ROTATERIGHT;
        return(t);
    }

    Dummy->left = Dummy->right = Nil;

    while ( t->left != Nil ) {
        ROTATERIGHT;

        if ( t->left != Nil ) {
            LINKRIGHT;
        }
    }
    ASSEMBLE;
    return(t);
}

#ifndef DICT_NOPREV

TreeNode*
SplayRight(

    TreeNode* t         // root of tree & current "search" point

) //-----------------------------------------------------------------------//
{
    TreeNode* l=Dummy;  // root of "left subtree" < keyItem
    TreeNode* r=Dummy;  // root of "right subtree" > keyItem
    TreeNode* tmp;

    if (t == Nil || t->right == Nil)
        return(t);

    Dummy->left = Dummy->right = Nil;

    while ( t->right != Nil ) {
        ROTATELEFT;

        if ( t->right != Nil ) {
            LINKLEFT;
        }
    }
    ASSEMBLE;
    return(t);
}

#endif



// Class methods for Splay Tree

Dict_Status
Dictionary::Dict_Find(          // return a item that matches

    pUserType itemI             // this value

  // Returns:
  //   itemCur - Nil if at not in Dict, else found item
) //-----------------------------------------------------------------------//
{
    itemCur = Nil;

    if (root == Nil)
        return (EMPTY_DICTIONARY);

    if (itemI == Nil)
        return (NULL_ITEM);

    if (SplayUserType (itemI) == 0){

        itemCur = root->item;
        return(SUCCESS);
    }
//  printf("After NotFound %ld: (", this); PrintItem(itemI); printf(")\n"); Dict_Print();
    return(ITEM_NOT_FOUND);
}

#ifndef DICT_NONEXT

Dict_Status
Dictionary::Dict_Next(          // return the next item

    pUserType itemI             // of a key greater then this

  // Returns:
  //   itemCur - Nil if at end of Dict, else current item
) //-----------------------------------------------------------------------//
{
    TreeNode* t;

    itemCur = Nil;

    if (root == Nil)
        return (EMPTY_DICTIONARY);

    if (itemI == Nil) {                 // no arg, return first record
        root = SplayLeft (root);

        itemCur = root->item;
        return (SUCCESS);
    }

    if (itemI != root->item)

        if (SplayUserType (itemI) > 0) {
            itemCur = root->item;
            return (SUCCESS);
        }

    if (root->right == Nil)
        return (LAST_ITEM);

    t = root;

    root = SplayLeft (root->right);
    root->left = t;
    t->right = Nil;

    itemCur = root->item;
    return (SUCCESS);
}
#endif // DICT_NONEXT

#ifndef DICT_NOPREV

Dict_Status
Dictionary::Dict_Prev(          // return the previous item

    pUserType itemI             // of a key less then this

  // Returns:
  //   itemCur - Nil if at begining of Dict, else current item
) //-----------------------------------------------------------------------//
{
    TreeNode* t;

    itemCur = Nil;

    if (root == Nil)
        return (EMPTY_DICTIONARY);

    if (itemI == Nil) {                 // no arg, return last record
        root = SplayRight (root);

        itemCur = root->item;
        return (SUCCESS);
    }

    if (itemI != root->item)

        if (SplayUserType (itemI) < 0) {
            itemCur = root->item;
            return (SUCCESS);
        }

    if (root->left == Nil)
        return (LAST_ITEM);

    t = root;
    root = SplayRight (root->left);
    root->right = t;
    t->left = Nil;

    itemCur = root->item;
    return (SUCCESS);
}

#endif // DICT_NOPREV

Dict_Status
Dictionary::Dict_Insert(                // insert the given item into the tree

    pUserType itemI             // the item to be inserted

  // Returns:
  //  itemCur - point to new item
) //-----------------------------------------------------------------------//
{
    TreeNode *newNode, *t;

    if ((itemCur = itemI) == Nil)
        return (NULL_ITEM);

    if (root == Nil) {
        root = new TreeNode(itemI);
        size++;
        return (SUCCESS);
    }

    if (SplayUserType (itemI) == 0)
        return (ITEM_ALREADY_PRESENT);

    newNode = new TreeNode(itemI);
    size++;

    t = root;

    if (fCompare > 0) {
        newNode->right = t->right;      //  item >= t->item
        newNode->left = t;
        t->right = Nil;
    }
    else {
        newNode->left = t->left;
        newNode->right = t;
        t->left = Nil;
    }
    root = newNode;

//  printf("After Insert %ld: (", this); PrintItem(itemI); printf(")\n"); Dict_Print();
    return (SUCCESS);
}


Dict_Status
Dictionary::Dict_Delete(        // delete the given item from the tree

    pUserType *itemI            // points to the (key) item to be deleted

  // Returns:
  //   itemCur is Nil - undefined
) //-----------------------------------------------------------------------//
{
    TreeNode *t, *r;

    itemCur = Nil;

    if (root == Nil)
        return (EMPTY_DICTIONARY);

    if (itemI == Nil)
        return (NULL_ITEM);

    if (itemI != root->item) {

        if (SplayUserType (*itemI) != 0)
            return(ITEM_NOT_FOUND);
    }

    *itemI = root->item;
    t = root;

    if (t->left == Nil)
        root = t->right;

    else if ( (r = t->right) == Nil)
        root = t->left;

    else {
        r = SplayLeft (r);
        r->left = t->left;      // at this point r->left == Nil
        root = r;
    }

    delete t;
    size--;

    return (SUCCESS);
}


pUserType
Dictionary::Dict_Delete_One()
{
        TreeNode        *       pCurrent        = root;
        TreeNode        *       pPrev           = NULL;         // NULL indicates prev is root
        pUserType               pResult;
        int                             fLeft;

        while ( pCurrent )
                {
                if ( pCurrent->left )
                        {
                        pPrev           = pCurrent;
                        pCurrent        = pCurrent->left;
                        fLeft           = 1;
                        continue;
                        }

                if ( pCurrent->right )
                        {
                        pPrev           = pCurrent;
                        pCurrent        = pCurrent->right;
                        fLeft           = 0;
                        continue;
                        }

                // found a leaf
                break;
                }

        // we are now at a leaf (or tree empty)
        if ( !pCurrent )
                return NULL;

        // unhook from parent
        if ( pPrev )
                {
                if ( fLeft )
                        pPrev->left             = NULL;
                else
                        pPrev->right    = NULL;
                }
        else
                root    = NULL;

        // return the item, and delete the treenode
        pResult = pCurrent->item;
        delete pCurrent;
        size--;
        return pResult;
}

// Utility functions to print of a tree

#ifndef DICT_NOPRINT

static indentCur;
static PrintFN printCur;

static char spaces[] =
"                                                                           ";

void
Dictionary::PrinTree(           // recursively print out a tree
    int lmargin,        // current depth & margen
    TreeNode *np        // subtree to print

) //-----------------------------------------------------------------------//
{
#if 0
    if (np == Nil)
       return;

    PrinTree(lmargin+indentCur, np->right);

    if (lmargin > sizeof(spaces))
        lmargin = sizeof(spaces);;

    spaces[lmargin] = 0;
    printf(spaces);
    spaces[lmargin] = ' ';

    Print(np->item);
    printf("\n");

    PrinTree(lmargin+indentCur, np->left);
#endif // 0


}

void
Dictionary::Dict_Print(
long indent

  // prints the binary tree (indented right subtree,
  // followed by the root, followed by the indented right dubtree)
) //-----------------------------------------------------------------------//
{
    indentCur = indent;

    PrinTree(0, root);
}

#endif // DICT_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\fileext.cxx ===
/******************************************************************************
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"
#include "..\appmgr\resource.h"
extern HINSTANCE ghInstance;

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassStore;
extern const IID IID_IClassAdmin;

LONG
UpdatePackage(
             MESSAGE * pMessage,
             BOOL      fUsageFlag,
             DWORD           Context,
             char    *       pClsidString,
             char        * pAppid,
             char    *       ServerName,
             DWORD   *   pMajorVersion,
             DWORD   *   pMinorVersion,
             DWORD   *   pLocale );


LONG
FindCLSIDFromFileExtension(
        MESSAGE         *       pMessage,
        BasicRegistry * pFileExtKey,
        char    *       ClsidBuffer,
        DWORD   *   SizeofClsidBuffer,
        char * szExt );

LONG
UpdateDatabaseFromFileExt(
    MESSAGE * pMessage )
    {
        BasicRegistry * pHKCR = new BasicRegistry( pMessage->hRoot );
        BasicRegistry * pFileKey;
        LONG                    Error;
        int                             Index;

        //
        // Get the file extension entries one by one. A file extension entry
        // is one whose name starts with a ".". So we enumerate the keys
        // looking for file extensions and add to the class dictionary.
        // Note that this step is carried out AFTER the class dictionary is
        // already populated, so we can assume that the class dictionary is
        // present.
        //

        pHKCR->InitForEnumeration(0);

        for ( Index = 0;Error != ERROR_NO_MORE_ITEMS;++Index )
                {
                char    FileExtBuffer[ 256 ];
                DWORD   SizeOfFileExtBuffer = 256;
                Error = pHKCR->NextKey( FileExtBuffer,
                                                                &SizeOfFileExtBuffer,
                                                                &pFileKey,
                                        pMessage->ftLow, pMessage->ftHigh );

                if( (Error == ERROR_SUCCESS ) && (FileExtBuffer[0] == '.') )
                        {
                        LONG                    Error2;
                        char                    ClsidBuffer[256];
                        DWORD                   SizeofClsidBuffer = 256;

                        // this is a file extension key.

                        // Given a file extension key, figure out the CLSID.

/*****
                        if(_stricmp(FileExtBuffer, ".doc" ) == 0 )
                                printf("Hello1");
******/

                        Error2 = FindCLSIDFromFileExtension(
                                                pMessage,
                                                pFileKey,
                                                ClsidBuffer,
                                                &SizeofClsidBuffer,
                                                FileExtBuffer  );
                        if( Error2 != ERROR_NO_MORE_ITEMS )
                                {
                                CLASS_ENTRY * pClsEntry;

                                // Enter into the Clsid dictionary.

                                if( (pClsEntry = pMessage->pClsDict->Search( &ClsidBuffer[0] ) ) != 0 )
                                        {
                                        int len = strlen( FileExtBuffer );
                                        char * p = new char[ len + 1];
                                        strcpy( p, FileExtBuffer );
                                        pClsEntry->FileExtList.Add( p );
                                        }
                                }


                        }

                // close the key if we opened it.

                if( Error == ERROR_SUCCESS )
                        delete pFileKey;
                }
        return ERROR_SUCCESS;
    }
LONG
FindCLSIDFromFileExtension(
        MESSAGE *               pMessage,
        BasicRegistry * pFileExtKey,
        char    *       ClsidBuffer,
        DWORD   *   pSizeofClsidBuffer,
        char * szExt )
        {
        char                    Buffer[256];
        DWORD                   SizeofBuffer;
        BasicRegistry * pClsidKey;
        HKEY                pTempKey;
        BasicRegistry * pProgIDKey;
        LONG                    Error = ERROR_NO_MORE_ITEMS;
        int                             fFound = 0;

        // Find the unnamed value. This is the progid value. Under this, a CLSID key should be present.

        SizeofBuffer = 256;
        Error = pFileExtKey->QueryValue("", &Buffer[0], &SizeofBuffer );

        // Get the key named in the Buffer.

        Error = RegOpenKeyEx( pMessage->hRoot,
                                                  &Buffer[0],
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &pTempKey );

        pProgIDKey = new BasicRegistry( pTempKey );

        if( Error == ERROR_SUCCESS )
                {
                // Now get the CLSID subkey under this prog id key.

                Error = pProgIDKey->Find( "CLSID", &pClsidKey );

                if( Error == ERROR_SUCCESS )
                        {
                        // Find the unnamed value in this

                        Error = pClsidKey->QueryValue( "", &ClsidBuffer[0], pSizeofClsidBuffer );

                        delete pClsidKey;
                        }
                else
                    {
                    CLSID TempClsid;

                    // uuid create on TempClsid here
                    UuidCreate(&TempClsid);

                    // Convert that to a string.

                    CLSIDToString( &TempClsid, &ClsidBuffer[0] );

                    CLASS_ENTRY * pClassEntry = new CLASS_ENTRY;

                    memcpy( pClassEntry->ClsidString,
                            &ClsidBuffer[0],
                            SIZEOF_STRINGIZED_CLSID );

                    pMessage->pClsDict->Insert( pClassEntry );

                    char * pT = new char [SIZEOF_STRINGIZED_CLSID];

                    memcpy( pT,
                            &ClsidBuffer[0],
                            SIZEOF_STRINGIZED_CLSID );

                    UpdatePackage( pMessage,
                                   0, // clsid update
                                   CTX_LOCAL_SERVER,
                                   pT,
                                   0,
                                   pMessage->pPackagePath,
                                   0,
                                   0,
                                   0 );

                    Error = ERROR_SUCCESS;
                    }
                delete pProgIDKey;
                }
        else
        {
            // Message that the file extension couldn't be mapped to a prog ID
            char szCaption [256];
            char szBuffer[256];

            ::LoadString(ghInstance, IDS_BOGUS_EXTENSION, szBuffer, 256);
            strcat(szBuffer, szExt);
            strncpy(szCaption, pMessage->pPackagePath, 256);
            int iReturn = ::MessageBox(pMessage->hwnd, szBuffer,
                                       szCaption,
                                       MB_OK);
        }

        return Error == ERROR_SUCCESS ? Error: ERROR_NO_MORE_ITEMS;
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\iidict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:
	
	iidict.cxx

 Abstract:

	This file stores the indexes of all class assocation entries based on IID.

 Notes:


 History:

 	VibhasC		Sep-29-1996		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "precomp.hxx"

void
IIDICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all ITF_ENTRY indexes allocated.

 	NOTE: tHIS FUNCTION DOES NOT DELETE THE ITF_ENTRY, BUT ONLY THE INDEX
 	OF THE CLASS ENTRY

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		        Status;
	ITF_ENTRY	*	        pClassEntry;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pClassEntry = (ITF_ENTRY *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pClassEntry );
		}

}

ITF_ENTRY *
IIDICT::GetFirst()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the first item in the dictionary

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;
	ITF_ENTRY	*	        pClassEntry;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	if( SUCCESS == Status )
		return pClassEntry = (ITF_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

ITF_ENTRY *
IIDICT::GetNext( ITF_ENTRY * pLastClassEntry)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the next item in the dictionary

 Arguments:

 	pLastClassEntry.
	
 Return Value:
	
	None.

 Notes:
    pLastClassEntry is the entry returned by the previous call to GetFirst
    or GetNext. This is the seed for this search.

    This function returns a zero if there are no more entries in the
    dictionary.

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary. But if we supply the last searched
	// item, we get the next in the dictionary.
	//

	if( (Status = Dict_Next( pLastClassEntry) ) == SUCCESS )
		return pLastClassEntry = (ITF_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

ITF_ENTRY *
IIDICT::Insert(
	ITF_ENTRY	*	        pClassEntry )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a class entry in the index.

 Arguments:
	
 Return Value:
	
 	A pointer to the ITF_ENTRY entry which was created and inserted.

 Notes:

	Search for the class association entry and if it exists, return that,
	do not create a new one.
----------------------------------------------------------------------------*/
{

	Dict_Status		Status	= Dict_Find( pClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			Dict_Insert( (pUserType) pClassEntry );
			return pClassEntry;
		default:
			return (ITF_ENTRY *)Dict_Curr_Item();
		}
}

ITF_ENTRY *
IIDICT::Search(
	char    * Iid )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a class entry in the dictionary.

 Arguments:
	
	pClassEntry	- Name of the ITF_ENTRY being searched for.

 Return Value:
	
	A		pointer to the ITF_ENTRY expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
	//
	// In order to search, we must create a dummy ITF_ENTRY to compare
	// against. We initialize this with the class id passed and search for it.
	//

	ITF_ENTRY	DummyClassEntry;
	Dict_Status		Status;

    memcpy( &DummyClassEntry, Iid, SIZEOF_STRINGIZED_CLSID );

	//
	// Search.
	//

	Status	= Dict_Find( &DummyClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (ITF_ENTRY *)0;
		default:
			return (ITF_ENTRY *)Dict_Curr_Item();
		}
}

int
IIDICT::Compare(
	 void * p1,
	 void * p2 )
	{
	ITF_ENTRY 	*	pRes1	= (ITF_ENTRY *)p1;
	ITF_ENTRY	    *	pRes2 	= (ITF_ENTRY *)p2;

	return _memicmp( p1, p2, SIZEOF_STRINGIZED_CLSID );
	}

void
PrintITF_ENTRYKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\message.cxx ===
#include "precomp.hxx"

extern void DumpOnePackage( MESSAGE *, PACKAGEDETAIL * );

void
_MESSAGE::Init()
        {
        fDumpOnly = 0;
        fPathTypeKnown = 0;
        pClsDict = new CLSDICT;
        pAppDict = new APPDICT;
        pPackageDict = new PDICT;
        pIIDict = new IIDICT;
        pPackagePath = 0;
        pPackageName = 0;
    hRoot = HKEY_CLASSES_ROOT;
        RunningAppIDValue = 1;
        pSetupCommand = 0;
        pClassStoreName = 0;
        pClassStoreDomainName = 0;
        pIconPath = 0;
        pDumpOnePackage = 0;
        GetSystemTimeAsFileTime(&ftLow);
        ftHigh = ftLow;
        Locale = MAKELANGID( LANG_ENGLISH,SUBLANG_ENGLISH_US);
//    Architecture= MAKEARCHITECTURE( HW_X86, OS_WINNT );
    ActFlags = 0;
        }

_MESSAGE::_MESSAGE()
    {
    Init();
    }

_MESSAGE::_MESSAGE( HKEY hKey )
        {
        Init();
        hRoot = hKey;
        }
_MESSAGE::_MESSAGE(char * pRootKeyName )
    {
    Init();
    SetRootKey( pRootKeyName );
    }

_MESSAGE::~_MESSAGE()
    {

    if( pClsDict )
        delete pClsDict;
        if( pAppDict )
                delete pAppDict;
        if( pPackageDict )
                delete pPackageDict;
        if( pIIDict )
                delete pIIDict;
    }

LONG
_MESSAGE::SetRootKey(
        char * pRootKeyName )
        {
        LONG error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                  pRootKeyName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRoot );

        return error;

        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\ndict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:
	
	NAMEDICT.cxx

 Abstract:

	This file stores the indexes of all class assocation entries based on IID.

 Notes:


 History:

 	VibhasC		Sep-29-1996		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "precomp.hxx"

void
NAMEDICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all ITF_ENTRY indexes allocated.

 	NOTE: tHIS FUNCTION DOES NOT DELETE THE ITF_ENTRY, BUT ONLY THE INDEX
 	OF THE CLASS ENTRY

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		        Status;
	char	*	        pClassEntry;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pClassEntry = (char *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pClassEntry );
		}

}

char *
NAMEDICT::GetFirst()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the first item in the dictionary

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;
	char	    *	        pClassEntry;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	if( SUCCESS == Status )
		return pClassEntry = (char *)Dict_Curr_Item();
    else
        return 0;

}

char *
NAMEDICT::GetNext( char * pLastClassEntry)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the next item in the dictionary

 Arguments:

 	pLastClassEntry.
	
 Return Value:
	
	None.

 Notes:
    pLastClassEntry is the entry returned by the previous call to GetFirst
    or GetNext. This is the seed for this search.

    This function returns a zero if there are no more entries in the
    dictionary.

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary. But if we supply the last searched
	// item, we get the next in the dictionary.
	//

	if( (Status = Dict_Next( pLastClassEntry) ) == SUCCESS )
		return pLastClassEntry = (char *)Dict_Curr_Item();
    else
        return 0;

}

char *
NAMEDICT::Insert(
	char	*	        pClassEntry )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a class entry in the index.

 Arguments:
	
 Return Value:
	
 	A pointer to the char entry which was created and inserted.

 Notes:

	Search for the class association entry and if it exists, return that,
	do not create a new one.
----------------------------------------------------------------------------*/
{

	Dict_Status		Status	= Dict_Find( pClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			Dict_Insert( (pUserType) pClassEntry );
			return pClassEntry;
		default:
			return (char *)Dict_Curr_Item();
		}
}

char *
NAMEDICT::Search(
	char    * Name, DWORD Context )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a class entry in the dictionary.

 Arguments:
	
	pClassEntry	- Name of the char being searched for.

 Return Value:
	
	A		pointer to the char expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
    Dict_Status Status = Dict_Find( Name );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (char *)0;
		default:
			return (char *)Dict_Curr_Item();
		}
}

int
NAMEDICT::Compare(
	 void * p1,
	 void * p2 )
	{
	char 	*	pRes1	= (char *)p1;
	char	*	pRes2 	= (char *)p2;
	int             Result;

	Result =  _stricmp( pRes1, pRes2 );
	Result = (Result < 0) ? -1 : (Result > 0) ? 1 : 0;


	return Result;
	}

void
PrintcharKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\pcs.cxx ===
/******************************************************************************
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

#include "..\appmgr\resource.h"
extern HINSTANCE ghInstance;
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)

#define HOME 1

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassAdmin;

CLSID CLSID_ClassStore = { /* 62392950-1AF8-11d0-B267-00A0C90F56FC */
    0x62392950,
    0x1af8,
    0x11d0,
    {0xb2, 0x67, 0x00, 0xa0, 0xc9, 0x0f, 0x56, 0xfc}
};

const IID IID_IClassStore = {
    0x00000190,
    0x0000,
    0x0000,
    {0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}
};

const IID IID_IClassAdmin = {
    0x00000191,
    0x0000,
    0x0000,
    {0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}
};
int
CompareClassDetails(
    CLASSDETAIL * p1,
    CLASSDETAIL * p2 );

HRESULT
UpdateDatabaseFromRegistry(
                          MESSAGE * pMessage );

HRESULT
UpdateClassStoreFromDatabase(
                            MESSAGE * pMessage,
                            IClassAdmin * pClassAdmin );

HRESULT
UpdateClassStoreFromMessage(
                           MESSAGE * pMessage,
                           IClassAdmin * pClassAdmin );

HRESULT
UpdateClassAssociations(
                       MESSAGE * pMessage,
                       IClassAdmin * pClassAdmin );

void
RemoveClassAssociations(
                        MESSAGE * pMessage,
                        IClassAdmin * pClassAdmin );

HRESULT
UpdatePackageDetails(
                    MESSAGE * pMessage,
                    IClassAdmin * pClassAdmin );

void
RemoveOneClassAssociation(
                         MESSAGE * pMessage,
                         CLASS_ENTRY * pClsEntry,
                         IClassAdmin * pClassAdmin );

HRESULT
UpdateOneClassAssociation(
                         MESSAGE * pMessage,
                         CLASS_ENTRY * pClsEntry,
                         IClassAdmin * pClassAdmin );

HRESULT
UpdateOnePackageDetail(
                      MESSAGE * pMessage,
                      PACKAGE_ENTRY * pClsEntry,
                      IClassAdmin * pClassAdmin );

LONG
UpdateDatabaseFromTypelib(
                         MESSAGE * pMessage );

void
DumpTypelibEntries(
                  MESSAGE * pMessage );


LONG
UpdateDatabaseFromFileExt(
                         MESSAGE * pMessage );
LONG
UpdateDatabaseFromProgID(
                        MESSAGE * pMessage );

LONG
UpdateDatabaseFromIID(
                     MESSAGE * pMessage );


HRESULT
AddToClassStore(
               MESSAGE *pMessage,
               IClassAdmin * pClassAdmin );

void
AppEntryToAppDetail(
                   APP_ENTRY * pAppEntry,
                   APPDETAIL * pAppDetail );

HRESULT
UpdatePackageDetails(
                    MESSAGE * pMessage,
                    IClassAdmin * pClassAdmin );

void
AppEntryToAppDetail(
                   APP_ENTRY * pAppEntry,
                   APPDETAIL * pAppDetail );

HRESULT
UpdateInterfaceEntries(
                      MESSAGE * pMessage,
                      IClassAdmin * pClassAdmin );

HRESULT
UpdateOneInterfaceEntry(
                       MESSAGE * pMessage,
                       ITF_ENTRY * pITFEntry,
                       IClassAdmin * pClassAdmin );

/******************************************************************************
    Da Code
 ******************************************************************************/

HRESULT
VerifyArguments( MESSAGE * pMessage )
{
    //    if( !pMessage->pRegistryKeyName )
    //        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER );

    return S_OK;
}

HRESULT
UpdateDatabaseFromRegistry(
                          MESSAGE * pMessage )
{
    HRESULT hr = S_OK;
    hr =  HRESULT_FROM_WIN32( UpdateDatabaseFromCLSID( pMessage ));

    if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr )
        return UpdateDatabaseFromFileExt(pMessage);

    if ( !SUCCEEDED(hr ) )
        return hr;

    hr = HRESULT_FROM_WIN32( UpdateDatabaseFromFileExt( pMessage ));

    if ( !SUCCEEDED(hr ) )
        return hr;

    hr = HRESULT_FROM_WIN32( UpdateDatabaseFromProgID( pMessage ));

    if ( !SUCCEEDED(hr ) )
        return hr;

    hr = HRESULT_FROM_WIN32( UpdateDatabaseFromIID( pMessage ));

    if ( !SUCCEEDED(hr ) )
        return hr;

    hr = HRESULT_FROM_WIN32( UpdateDatabaseFromTypelib( pMessage ));

    if ( !SUCCEEDED(hr ) )
        return hr;

    return hr;
}

HRESULT
UpdateClassStoreFromDatabase( MESSAGE * pMessage, IClassAdmin * pClassAdmin )
{
    HRESULT hr;


    hr = UpdateClassAssociations( pMessage, pClassAdmin );

    if ( SUCCEEDED(hr))
    {
        hr = UpdateInterfaceEntries( pMessage, pClassAdmin );

        if ( SUCCEEDED(hr) )
        {
            hr = UpdatePackageDetails( pMessage, pClassAdmin );
        }
    }

    if (FAILED(hr))
    {
        // We blew it somewhere so we need to remove all the CLSIDs that we
        // might have added.
        RemoveClassAssociations( pMessage, pClassAdmin);
    }

    return hr;
}

HRESULT
UpdateClassStoreFromMessage( MESSAGE * pMessage, IClassAdmin * pClassAdmin )
{
    HRESULT hr;

    if ( (hr = VerifyArguments( pMessage )) == S_OK )
    {
        hr = UpdateDatabaseFromRegistry( pMessage );
        if (SUCCEEDED(hr) || MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,ERROR_NO_MORE_ITEMS) == hr)
        {
            if (pMessage->hRoot != HKEY_CLASSES_ROOT)
            {
                // We mapped it into a temporary key so we need to do a pass
                // on HKEY_CLASSES_ROOT as well in order to catch anything
                // that might have been copied there instead of into our
                // remapped key.
                // This is a problem because we can't remap HKCR across
                // process boundaries, our remapping function only works in
                // this process.
                pMessage->hRoot = HKEY_CLASSES_ROOT;
                hr = UpdateDatabaseFromRegistry( pMessage );
            }
            if (SUCCEEDED(hr) || MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,ERROR_NO_MORE_ITEMS) == hr)
            {
                hr = UpdateClassStoreFromDatabase( pMessage, pClassAdmin );
            }
        }
    }
    return hr;

}

HRESULT
UpdateInterfaceEntries(
                      MESSAGE * pMessage,
                      IClassAdmin * pClassAdmin )
{
    ITF_ENTRY * pITFEntry = (ITF_ENTRY *)pMessage->pIIDict->GetFirst();
    HRESULT hr;

    if ( pITFEntry )
    {
        do
        {
            hr = UpdateOneInterfaceEntry(pMessage,pITFEntry,pClassAdmin);
            if ( !SUCCEEDED(hr) )
                return hr;
            pITFEntry = pMessage->pIIDict->GetNext( pITFEntry );
        } while ( pITFEntry != 0 );
    }
    else
        hr  = MAKE_HRESULT( SEVERITY_SUCCESS, 0, 1 ); // no interfaces.
    return hr;
}

HRESULT
UpdateOneInterfaceEntry(
                       MESSAGE * pMessage,
                       ITF_ENTRY * pITFEntry,
                       IClassAdmin * pClassAdmin )
{
    CLSID           IID;
    CLSID           PSClsid;
    CLSID           TypelibID;

    StringToCLSID( &pITFEntry->IID[1], &IID );
    StringToCLSID( &pITFEntry->Clsid[1], &PSClsid );
    StringToCLSID( &pITFEntry->TypelibID[1], &PSClsid );

    HRESULT hr = S_OK;

    if ( !pMessage->fDumpOnly )
        hr = pClassAdmin->NewInterface( IID, L"", PSClsid, TypelibID );

    if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        hr = S_OK;
    return hr;
}

HRESULT
UpdatePackageDetails(
                    MESSAGE * pMessage,
                    IClassAdmin * pClassAdmin )
{
    PACKAGE_ENTRY * pPackageEntry =
    (PACKAGE_ENTRY *)pMessage->pPackageDict->GetFirst();
    HRESULT hr = S_OK;
    hr = E_FAIL;

    if ( pPackageEntry )
    {
        do
        {
            hr = UpdateOnePackageDetail(pMessage,pPackageEntry,pClassAdmin);
            if (!SUCCEEDED(hr))
                return hr;
            pPackageEntry = pMessage->pPackageDict->GetNext(pPackageEntry);
        } while ( pPackageEntry != 0 );
    }
    else
        hr  = MAKE_HRESULT( SEVERITY_SUCCESS, 0, 1 ); // no packages.
    return hr;

}

HRESULT
UpdateOnePackageDetail(
                      MESSAGE * pMessage,
                      PACKAGE_ENTRY * pPackageEntry,
                      IClassAdmin * pClassAdmin )
{
    PACKAGEDETAIL   PackageDetail;
    APP_ENTRY       *pAppEntry;
    int             len;
    int             count;
    HRESULT         hr = S_OK;
    int             Index = 0;
    int             max;

    // copy the bare package details

    memcpy( &PackageDetail,
            &pPackageEntry->PackageDetails,
            sizeof( PACKAGEDETAIL ) );

    count = PackageDetail.cApps = pPackageEntry->Count;

    // if the null appid  contains at least one clsid entry or typelib entry
    // assume one more app id in the package. There can be either a clsid entry or
    // a typelib entry in the null appid.

    if ( (pPackageEntry->GetCountOfClsidsInNullAppid() > 0 ) ||
         (pPackageEntry->GetCountOfTypelibsInNullAppid() > 0 )
       )
    {
        PackageDetail.cApps += 1;
        count++;
    }


    // Allocate an APPDETAIL structure if there is at least one appid in the
    // package.

    if ( count )
    {
        PackageDetail.pAppDetail = new APPDETAIL[ count ];
        memset( PackageDetail.pAppDetail, '\0', count * sizeof(APPDETAIL) );
    }

    // update the rest of entries that have an appid.

    for ( Index = 0, pAppEntry = pPackageEntry->pAppDict->GetFirst();
        pAppEntry && (Index < pPackageEntry->Count);
        ++Index, pAppEntry = pPackageEntry->pAppDict->GetNext( pAppEntry) )
    {
        AppEntryToAppDetail(pAppEntry, &PackageDetail.pAppDetail[ Index ] );
    }

    //
    // If there is at least one clsid in the null appid, then assign the appid
    // the same guid as the first clsid in the list. Else, if there is at least
    // one typelib in the list, assign the appid the same guid as the typelib id
    //


    if ( (max = pPackageEntry->GetCountOfClsidsInNullAppid()) > 0 )
    {
        APP_ENTRY A;
        char * p = pPackageEntry->GetFirstClsidInNullAppidList();

        A.SetAppIDString( p );


        // Add the Class ids from the NUll app entry list to the app entry..

        for ( count = 0, p = pPackageEntry->ClsidsInNullAppid->GetFirst();
            p && (count < max);
            ++count, p = pPackageEntry->ClsidsInNullAppid->GetNext( p )
            )
        {
            A.AddClsid( p );
        }


        // update the entries with the null clsid.

        AppEntryToAppDetail( &A, &PackageDetail.pAppDetail [ Index ] );

        // Add remote server names to app entry ( not implemented yet ).

    }
    else if ( (max = pPackageEntry->GetCountOfTypelibsInNullAppid()) > 0 )
    {
        APP_ENTRY A;
        char * p = pPackageEntry->GetFirstTypelibInNullAppidList();

        A.SetAppIDString( p );


        // Add the Class ids from the NUll app entry list to the app entry..

        for ( count = 0, p = pPackageEntry->TypelibsInNullAppid->GetFirst();
            p && (count < max);
            ++count, p = pPackageEntry->TypelibsInNullAppid->GetNext( p )
            )
        {
            A.AddTypelib( p );
        }


        // update the entries with the null clsid.

        AppEntryToAppDetail( &A, &PackageDetail.pAppDetail [ Index ] );

    }

    // update package name.

    len = strlen( &pPackageEntry->PackageName[0] );
    PackageDetail.pszPackageName = new OLECHAR[ (len +1 )*2 ];
    mbstowcs(PackageDetail.pszPackageName,&pPackageEntry->PackageName[0],len+1);

    // write the class store.


    if ( pMessage->fDumpOnly)
    {
        (*pMessage->pDumpOnePackage)( pMessage, &PackageDetail );
        hr = S_OK;
    }
    else
        hr = pClassAdmin->NewPackage( &PackageDetail );

    return hr;
}

void
RemoveClassAssociations(
                       MESSAGE * pMessage,
                       IClassAdmin * pClassAdmin )
{
    CLASS_ENTRY * pClsEntry = pMessage->pClsDict->GetFirst();

    if ( pClsEntry )
    {
        do
        {
            RemoveOneClassAssociation( pMessage, pClsEntry, pClassAdmin );
            pClsEntry = pMessage->pClsDict->GetNext( pClsEntry );
        } while ( pClsEntry != 0 );
    }
}

void
RemoveOneClassAssociation(
                         MESSAGE * pMessage,
                         CLASS_ENTRY * pClsEntry,
                         IClassAdmin * pClassAdmin )
{
    CLSID clsid;
    StringToCLSID(&(pClsEntry->GetClsidString())[1], &clsid );
    pClassAdmin->DeleteClass( clsid );
}

HRESULT
UpdateClassAssociations(
                       MESSAGE * pMessage,
                       IClassAdmin * pClassAdmin )
{
    CLASS_ENTRY * pClsEntry = pMessage->pClsDict->GetFirst();
    HRESULT hr = S_OK;

    if ( pClsEntry )
    {
        do
        {
            hr = UpdateOneClassAssociation( pMessage, pClsEntry, pClassAdmin );
            if (hr != S_OK )
                return hr;
            pClsEntry = pMessage->pClsDict->GetNext( pClsEntry );
        } while ( pClsEntry != 0 );
    }
    return hr;
}

HRESULT
UpdateOneClassAssociation(
                         MESSAGE * pMessage,
                         CLASS_ENTRY * pClsEntry,
                         IClassAdmin * pClassAdmin )
{
    CLASSASSOCIATION        CA;
    LPOLESTR        *           prgFileExt;
    LPOLESTR        *           prgProgID;
    char * p;
    int len;
    ListEntry * pListEntry;
    HRESULT                 hr = S_OK;

    memcpy( &CA, &pClsEntry->ClassAssociation, sizeof( CLASSASSOCIATION ) );

    CA.cFileExt = pClsEntry->FileExtList.GetCount();
    CA.cOtherProgId = pClsEntry->OtherProgIDs.GetCount();


    // convert the classid into a guid

    StringToCLSID(&(pClsEntry->GetClsidString())[1], &CA.Clsid );

    // create the file extension array.

    if ( CA.cFileExt )
    {
        int count;

        // allocate array for the file extensions.

        CA.prgFileExt = prgFileExt = new LPOLESTR[ CA.cFileExt ];

        // copy the file extensions one by one.

        for ( count = 0, pListEntry = pClsEntry->FileExtList.GetFirst();
            pListEntry;
            ++count, pListEntry = pClsEntry->FileExtList.GetNext( pListEntry )
            )
        {
            char * p = (char *) pListEntry->pElement;

            int len = strlen(p);
            prgFileExt[ count ] = new OLECHAR[ (len+1)*2 ];
            mbstowcs( prgFileExt[ count ], p, len+1 );
        }
    }

    // create the progid array
    if ( CA.cOtherProgId )
    {
        int count;
        ListEntry * pListEntry;

        // allocate array for the file extensions.

        CA.prgOtherProgId = prgProgID = new LPOLESTR[ CA.cOtherProgId ];

        // copy the file extensions one by one.

        for ( count = 0, pListEntry = pClsEntry->OtherProgIDs.GetFirst();
            pListEntry;
            ++count, pListEntry = pClsEntry->OtherProgIDs.GetNext( pListEntry )
            )
        {
            p = (char *) pListEntry->pElement;
            len = strlen(p);

            prgProgID[ count ] = new OLECHAR[ (len +1) *2 ];
            mbstowcs( prgProgID[ count ], p, len+1 );
        }
    }

    // create the default progid - the first in the progidlist.

    if ( pClsEntry->OtherProgIDs.GetCount() )
    {
        pListEntry = pClsEntry->OtherProgIDs.GetFirst();
        p = (char *)pListEntry->pElement;
        len = strlen(p);
        CA.pDefaultProgId = new OLECHAR[ (len+1) * 2 ];
        mbstowcs( CA.pDefaultProgId, p, len+1 );
    }
    else
        CA.pDefaultProgId = 0;

    if (CA.pszDesc == NULL)
    {
        CA.pszDesc = L"";
    }

    if ( !pMessage->fDumpOnly )
    {
        // First try and delete the class entry to make sure this class ID
        // isn't orphaned from some earlier partial installation.  If the
        // classid is in the class store but isn't listed as being
        // implemented by an application then this will cause it to be
        // deleted.  If it _IS_ implemented by another application then this
        // wil be a NOP.
        pClassAdmin->DeleteClass(CA.Clsid);

        hr = pClassAdmin->NewClass( &CA );
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ) // duplicate
    {
        // Get details of the pre-existing class.
        CLASSDETAIL cdOld;
        hr = pClassAdmin->GetClassDetails(CA.Clsid, &cdOld);

        if (SUCCEEDED(hr))
        {
            // Check to see if they are equivalent (CompareClassDetails).
            int i = CompareClassDetails(&CA, &cdOld);

            if (0 != i)
            {
                // Inform the user of a conflict and abort
                TCHAR szCaption[256];
                TCHAR szBuffer[1024];
                ::LoadString(ghInstance, IDS_CLSIDCONFLICT1, szBuffer, 1024);
                // UNDONE - we need to get the other application's name here.
                strcpy(szCaption, "some other application");
                IEnumPackage * pIEP;
                CSPLATFORM cp;
                memset(&cp, 0, sizeof(cp));
                hr = pClassAdmin->GetPackagesEnum(CA.Clsid,
                                                  NULL,
                                                  cp,
                                                  0,
                                                  0,
                                                  &pIEP);
                if (SUCCEEDED(hr))
                {
                    ULONG ul;
                    PACKAGEDETAIL pd;
                    hr = pIEP->Next(1, &pd, &ul);
                    if (SUCCEEDED(hr) && 1 == ul)
                    {
                        WTOA(szCaption, pd.pszPackageName, 256);
                    }
                    pIEP->Release();
                }
                strcat(szBuffer, szCaption);
                ::LoadString(ghInstance, IDS_CLSIDCONFLICT2, szCaption, 256);
                strcat (szBuffer, szCaption);
                strncpy(szCaption, pMessage->pPackagePath, 256);
                int iReturn = ::MessageBox(pMessage->hwnd, szBuffer,
                                           szCaption,
                                           MB_OK);
                hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            }
            else
            {
                // they aren't different so it's OK to continue
                hr = S_OK;
            }
        }
    }


    //
    // before return, update the class association data structure back to the class
    // entry structure, so that the dumper can use it.

    memcpy( &pClsEntry->ClassAssociation, &CA, sizeof( CLASSASSOCIATION ) );
    return hr;
}

// compares two class details
//

//
// Input: p1: Pointer to a CLASSDETAIL structure
//        p2: Pointer to the other CLASSDETAIL structure
// Returns:
//      0 if all is well, -1 otherwise.
// Notes: DOES NOT CHECK FOR NULL INPUT POINTERS.
//


int
CompareClassDetails(
    CLASSDETAIL * p1,
    CLASSDETAIL * p2 )
    {

    // compare the class id.

    if( _memicmp( (const void * )&p1->Clsid,
                  (const void *)&p2->Clsid,
                  sizeof( CLSID ) ) )
        return -1;

    // We do not compare pszdesc, since it is just an info field.

    // We DO compare the icon paths, since if icon paths are different, they are
    // likely to be different packages supporting the same classid. (I am not
    // sure, this is a good argument)

    if( p1->pszIconPath && p2->pszIconPath )
        {
        if( _wcsicmp( (const wchar_t *)p1->pszIconPath,
                      (const wchar_t *)p2->pszIconPath ) != 0 )
            return -1;
        }

    // test the Treatas and AutoConvert CLSIDs

    if( _memicmp( (const unsigned char *)&p1->TreatAsClsid,
                  (const unsigned char *)&p2->TreatAsClsid,
                  sizeof( CLSID ) ) )
        return -1;

    if( _memicmp( (const unsigned char *)&p1->AutoConvertClsid,
                  (const unsigned char *)&p2->AutoConvertClsid,
                  sizeof( CLSID ) ) )
        return -1;

    // If the count of file extensions do not match, they are likely different
    // packages.

    if( p1->cFileExt != p2->cFileExt )
        return -1;
    else
        {
        int i, cFileExt;


        // All the file extensions should match for the guaranteeing that the
        // package is the same.

        for( i = 0, cFileExt = p1->cFileExt;
             i < cFileExt;
            ++i
           )
            {
            if(_wcsicmp( (const wchar_t *)p1->prgFileExt[ i ],
                         (const wchar_t *)p2->prgFileExt[ i ] ) != 0 )
                 return -1;
            }

        if( i < cFileExt )
            return -1;

        }

    // compare mime type.

    if( p1->pMimeType && p2->pMimeType )
        {
        if( _wcsicmp( (const wchar_t *)p1->pMimeType,
                      (const wchar_t *)p2->pMimeType ) != 0 )
            return -1;
        }

    // compare default progid.

    if( p1->pDefaultProgId && p2->pDefaultProgId )
        {
        if( _wcsicmp( (const wchar_t *)p1->pDefaultProgId,
                      (const wchar_t *)p2->pDefaultProgId ) != 0 )
            return -1;
        }

    // if the count of Other prog ids do not match , they are likely different
    // packages

    if( p1->cOtherProgId != p2->cOtherProgId )
        return -1;
    else
        {
        int i, cOtherProgId;


        // All the OtherProgIds should match for the guaranteeing that the
        // package is the same.

        for( i = 0, cOtherProgId = p1->cOtherProgId;
             i < cOtherProgId;
            ++i
           )
            {
            if(_wcsicmp((const wchar_t *)p1->prgOtherProgId[ i ],
                        (const wchar_t *)p2->prgOtherProgId[ i ]) != 0 )
                 return -1;
            }

        if( i < cOtherProgId )
            return -1;

        }

    return 0;
    }

void
AppEntryToAppDetail(
                   APP_ENTRY * pAppEntry,
                   APPDETAIL * pAppDetail )
{
    int             count;
    ListEntry *     pListEntry;
    char    * p;

    StringToCLSID( &pAppEntry->AppIDString[1], &pAppDetail->AppID );

    // pick up the clsid list.

    if ( count = pAppEntry->ClsidList.GetCount() )
    {

        // Allocate space for requisite # of CLSIDs

        pAppDetail->cClasses = count;
        pAppDetail->prgClsIdList = new CLSID[ count ];

        for ( count = 0, pListEntry = pAppEntry->ClsidList.GetFirst();
            pListEntry;
            pListEntry = pAppEntry->ClsidList.GetNext( pListEntry ), ++count
            )
        {
            p = (char*)pListEntry->pElement;
            StringToCLSID( p+1, &pAppDetail->prgClsIdList[count] );
        }
    }

    // pick up typelib list.

    if ( count = pAppEntry->TypelibList.GetCount() )
    {

        // Allocate space for requisite # of Typelibs

        pAppDetail->cTypeLibIds = count;
        pAppDetail->prgTypeLibIdList = new CLSID[ count ];

        for ( count = 0, pListEntry = pAppEntry->TypelibList.GetFirst();
            pListEntry;
            pListEntry = pAppEntry->TypelibList.GetNext( pListEntry ), ++count
            )
        {
            p = (char*)pListEntry->pElement;
            StringToCLSID( p+1, &pAppDetail->prgTypeLibIdList[count] );
        }
    }

    // pick up remote server name list.

    if ( count = pAppEntry->RemoteServerNameList.GetCount() )
    {
        pAppDetail->prgServerNames =  new LPOLESTR[ count ];
        pAppDetail->cServers = count;

        for ( count = 0, pListEntry = pAppEntry->RemoteServerNameList.GetFirst();
            pListEntry;
            pListEntry = pAppEntry->RemoteServerNameList.GetNext( pListEntry ), ++count
            )
        {
            p = (char *) pListEntry->pElement;
            int    len = strlen(p);

            pAppDetail->prgServerNames[ count ] = new OLECHAR[ (len +1) * 2 ];
            mbstowcs( pAppDetail->prgServerNames[count], p, len+1 );
        }

    }


}


HRESULT
AddToClassStore( MESSAGE *pMessage, IClassAdmin * pClassAdmin )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\typelib.cxx ===
/******************************************************************************
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassStore;
extern const IID IID_IClassAdmin;

#if 0
ULONG
PackageFromTypelib(
        MESSAGE * pMessage,
        BasicRegistry * pKeyToTypeLibName );
#endif // 0

LONG
UpdatePackage(
        MESSAGE * pMessage,
        BOOL        fUsage,
        DWORD           Context,
        char    *       pClsidString,
        char        * pAppid,
        char    *       ServerName,
    DWORD   *   pMajorVersion,
    DWORD   *   pMinorVersion,
    LCID   *   pLocale );

CLASSPATHTYPE
GetPathType( char * pExtension );

LPOLESTR
GetPath( char * pPath );

LPOLESTR
GetSetupCommand( char * pName );

LPOLESTR
MakePackageName( char * pName );

ULONG
GetNextTypelib(
    MESSAGE         *   pMessage,
    DWORD           *   pMajorVersion,
    DWORD           *   pMinorVersion,
    LCID           *   pLocale,
    BasicRegistry   *   pTypelib,
    BasicRegistry   **   ppTypelibNameKey,
    char            *   pTypelibNameBuffer,
    DWORD           *   pTypelibNameLength );

void
GetMajorAndMinorVersion(
    char    *   pBuffer,
    DWORD   *   pMajor,
    DWORD   *   pMinor );

LONG
UpdateDatabaseFromTypelib(
    MESSAGE * pMessage )
    {
    BasicRegistry * pHKCR = new BasicRegistry( pMessage->hRoot ); // HKCR
    BasicRegistry * pTypelibKey;
    BOOL            fNewEntry = 0;
    int             Index;
    LONG            Error = ERROR_SUCCESS;

    //
    // Get the first typelib key under HKCR
    //

    Error = pHKCR->Find( "Typelib", &pTypelibKey );

        if(Error == ERROR_NO_MORE_ITEMS )
                return ERROR_SUCCESS;

        pTypelibKey->InitForEnumeration(0);

    //
    // Go thru all the subkeys under Typelib and get the details
        // under the keys.
    //

    for( Index = 0, fNewEntry = 0;
         Error != ERROR_NO_MORE_ITEMS;
         ++Index )
        {
        char CLSIDBuffer[ _MAX_PATH ];
        DWORD   SizeOfCLSIDBuffer;
        BasicRegistry * pCLSIDKey;

                //
        // Get the name of the next clsid key
        //

        SizeOfCLSIDBuffer = sizeof(CLSIDBuffer)/sizeof(char);
        Error = pTypelibKey->NextKey(
                            CLSIDBuffer,
                            &SizeOfCLSIDBuffer,
                            &pCLSIDKey,
                            pMessage->ftLow, pMessage->ftHigh);

                if( Error == ERROR_SUCCESS )
            {
            BasicRegistry * pT;
            char TypelibName[ _MAX_PATH ];
            DWORD   TypelibNameLength;
            DWORD   MajorVersion = 0;
            DWORD   MinorVersion = 0;
            LCID   Locale       = 0;

            TypelibNameLength = sizeof(TypelibName)/sizeof(char);
            Error = GetNextTypelib(
                         pMessage,
                         &MajorVersion,
                         &MinorVersion,
                         &Locale,
                         pCLSIDKey,
                         &pT,
                         &TypelibName[0],
                         &TypelibNameLength );

                        if( Error == ERROR_SUCCESS )
                                {

                            char * pTemp = new char [SizeOfCLSIDBuffer+1];
                            strcpy( pTemp, &CLSIDBuffer[0] );

                                UpdatePackage( pMessage,
                                               1, // typelib update - not a clsid update.
                               0,
                               pTemp,
                               0,
                               TypelibName,
                               &MajorVersion,
                               &MinorVersion,
                               &Locale
                               );
                        delete pT;
                                }
                    delete pCLSIDKey;
                    Error = ERROR_SUCCESS;
                    }

                }

        delete pTypelibKey;
    return Error = ERROR_SUCCESS;
    }

ULONG
GetNextTypelib(
    MESSAGE         *   pMessage,
    DWORD           *   pMajorVersion,
    DWORD           *   pMinorVersion,
    LCID            *   pLocale,
    BasicRegistry   *   pTypelib,
    BasicRegistry   **   ppTypelibNameKey,
    char            *   pTypelibNameBuffer,
    DWORD           *   pTypelibNameLength )
    {
    LONG Error = ERROR_SUCCESS;
    BasicRegistry * pVersionKey;
    char Buffer[ _MAX_PATH ];
    DWORD SizeOfBuffer = sizeof( Buffer ) / sizeof( char );

    // get the key to the real type lib name

    // First get to the type libversion.

    Error = pTypelib->NextNumericKey( &Buffer[0],
                                      &SizeOfBuffer,
                                      &pVersionKey,
                                      pMessage->ftLow, pMessage->ftHigh );

    if( Error == ERROR_SUCCESS )
        {
        BasicRegistry * pLocaleKey;

        SizeOfBuffer = sizeof( Buffer ) / sizeof( char );


        /// TODO TODO: Get the version# here.

        GetMajorAndMinorVersion( &Buffer[0], pMajorVersion, pMinorVersion );

        Error = pVersionKey->NextNumericKey(
                                &Buffer[0],
                                &SizeOfBuffer,
                                &pLocaleKey,
                                pMessage->ftLow, pMessage->ftHigh );

        if( Error == ERROR_SUCCESS )
            {
            BasicRegistry * pRealTypelibKey;

            // Get the locale hex value

            StringToULong( &Buffer[0], pLocale );

            // we have the Locale Key, now get the real file name key.

            Error = pLocaleKey->Find( "Win32", &pRealTypelibKey );

            if( Error == ERROR_SUCCESS )
                {
                // get the unnamed value - the name is the name of the typelib

                Error = pRealTypelibKey->QueryValueEx( 0,
                                                       pTypelibNameBuffer,
                                                       pTypelibNameLength );
                // The buffer has the real value of the typelibkey.

                if( Error == ERROR_SUCCESS )
                    *ppTypelibNameKey = pRealTypelibKey;

                // The real typelib key, if necessary will be deleted by the
                // caller.

                }

            delete pLocaleKey;
            }
        delete pVersionKey;
        }

    return Error;
    }

void
GetMajorAndMinorVersion(
    char    *   pBuffer,
    DWORD   *   pMajor,
    DWORD   *   pMinor )
    {

    if( pMajor )
        *pMajor = atol( pBuffer );

    pBuffer = strchr( pBuffer, '.' );
    if( pBuffer && pMinor )
        *pMinor = atol( pBuffer+1 );

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\pentry.cxx ===
#include "precomp.hxx"

tagPACKAGE_ENTRY::tagPACKAGE_ENTRY()
{
	memset( PIDString, '\0', SIZEOF_STRINGIZED_CLSID );
	memset( &PackageDetails, '\0', sizeof(PackageDetails) );
	pAppDict = new APPDICT;
	CountOfClsidsInNullAppid = 0;
	CountOfTypelibsInNullAppid = 0;
	CountOfRemoteServerNamesInNullAppid =0;
	ClsidsInNullAppid = new NAMEDICT;
	TypelibsInNullAppid = new NAMEDICT;
	RemoteServerNamesInNullAppid = new NAMEDICT;

	Count = 0;

}
tagPACKAGE_ENTRY::~tagPACKAGE_ENTRY()
	{
	delete ClsidsInNullAppid;
	delete RemoteServerNamesInNullAppid;
	}

void
tagPACKAGE_ENTRY::AddAppEntry(
	APP_ENTRY * pAppEntry )
	{
	pAppDict->Insert( pAppEntry );
	Count++;
	}
APP_ENTRY *
tagPACKAGE_ENTRY::SearchAppEntry(
	char * pAppidString )
{
	return pAppDict->Search( pAppidString, 0 );
}

char *
tagPACKAGE_ENTRY::GetFirstClsidInNullAppidList()
{
	return ClsidsInNullAppid->GetFirst();
}
char *
tagPACKAGE_ENTRY::GetFirstTypelibInNullAppidList()
    {
    return TypelibsInNullAppid->GetFirst();
    }

void
tagPACKAGE_ENTRY::AddClsidToNullAppid( char * pClsidString )
	{
	if( ClsidsInNullAppid->Insert( pClsidString ) == pClsidString )
		CountOfClsidsInNullAppid++;
	}

void
tagPACKAGE_ENTRY::AddTypelibToNullAppid( char * pTypelibClsid )
	{
	if( TypelibsInNullAppid->Insert( pTypelibClsid ) == pTypelibClsid )
		CountOfTypelibsInNullAppid++;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\progid.cxx ===
/******************************************************************************
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassStore;
extern const IID IID_IClassAdmin;

LONG
UpdateDatabaseFromProgID(
                        MESSAGE * pMessage )
{
    BasicRegistry * pHKCR = new BasicRegistry( pMessage->hRoot );
    BasicRegistry * pProgIDKey;
    LONG                    Error = ERROR_SUCCESS;
    int                             Index;

    //
    // Get the progid entries one by one. A progID is one who has a CLSID subkey
    // underneath it. Assume that the class dictionary has been populated.
    //

    pHKCR->InitForEnumeration(0);

    for ( Index = 0;Error != ERROR_NO_MORE_ITEMS;++Index )
    {
        char    ProgIDBuffer[ 256 ];
        DWORD   SizeOfProgIDBuffer = 256;
        Error = pHKCR->NextKey( ProgIDBuffer,
                                &SizeOfProgIDBuffer,
                                &pProgIDKey,
                                pMessage->ftLow, pMessage->ftHigh );

        if ( Error == ERROR_SUCCESS )
        {
            //
            // The CLSID key under HKCR also has a CLSID under it. If so, skip it.
            //

            if (_stricmp( ProgIDBuffer, "CLSID" ) == 0 )
            {
                delete pProgIDKey;
                continue;
            }

            // if the key has a clsid key underneath, then this is a progid key
            // else it is not.
            BasicRegistry * pClsidKey;
            LONG            Error2;
            char                    Buffer[256];
            DWORD                   SizeofBuffer = 256;

            Error2 = pProgIDKey->Find( "CLSID", &pClsidKey ) ;

            if ( Error2 != ERROR_NO_MORE_ITEMS )
            {
                CLASS_ENTRY * pClsEntry;
                CLSDICT *               pClsDict;

                // we found a real progid key. Enter this into the clsid
                // dictionary.

                pClsidKey->QueryValue( "", &Buffer[0], &SizeofBuffer );

                pClsDict = pMessage->pClsDict;

                if ( pClsEntry = pClsDict->Search( &Buffer[0] ) )
                {
                    char * p = new char [strlen( ProgIDBuffer ) + 1];

                    strcpy( p, ProgIDBuffer );

                    // enter into class dictionary.

                    pClsEntry->OtherProgIDs.Add( p );

                }
                delete pClsidKey;
            }
            delete pProgIDKey;
        }

    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\updcs.cxx ===
#include "precomp.hxx"
#include "message.hxx"
#include "shellapi.h"

// Utility function to delete an registry key and all of it's children
LONG RegDeleteTree(HKEY hKey, char * lpSubKey)
{
    HKEY hKeyNew;
    LONG lResult = RegOpenKeyA(hKey, lpSubKey, &hKeyNew);
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }
    char szName[256];
    while (ERROR_SUCCESS == RegEnumKeyA(hKeyNew, 0, szName, 256))
    {
        RegDeleteTree(hKeyNew, szName);
    }
    RegCloseKey(hKeyNew);
    return RegDeleteKeyA(hKey, lpSubKey);
}

HRESULT
UpdateClassStore(
    IClassAdmin     *   pClassAdmin,
    char            *   szFilePath,
    char            *   szAuxPath, // used to specify auxillary path
    char            *   szPackageName,
    DWORD               cchPackageName,
    DWORD               flags,
    HWND                hwnd )
    {
    HRESULT hr;
    MESSAGE Message;
    BOOL    fAssignOrPublish = flags & 0x1;
    Message.fAssignOrPublish = fAssignOrPublish;
    Message.ActFlags = ACTFLG_RunLocally | (fAssignOrPublish==1) ? ACTFLG_Published : ACTFLG_Assigned;
    Message.pPackagePath = szFilePath;
    Message.pAuxPath    = szAuxPath;
    Message.hwnd = hwnd;

    hr = DetectPackageAndRegisterIntoClassStore( &Message,
                                                 szFilePath,
                                                 fAssignOrPublish,
                                                 pClassAdmin );
    szPackageName[0]=0;
    if (SUCCEEDED(hr))
    {
        if (Message.pPackageName)
        {
            strncpy(szPackageName, Message.pPackageName, cchPackageName);
        }
    }
    return hr;
    }

HRESULT
UpdateClassStoreFromIE(
    IClassAdmin     *   pClassAdmin,
    char            *   szFilePath,
    char            *   szAuxPath, // used to specify auxillary path
    DWORD               flags,
    FILETIME            ftStart,
    FILETIME            ftEnd,
    HWND                hwnd )
    {
    HRESULT hr;
    MESSAGE Message;
    BOOL    fAssignOrPublish = flags & 0x1;
    Message.hwnd = hwnd;
    Message.pPackagePath = szFilePath;
    Message.fAssignOrPublish = fAssignOrPublish;
    Message.ActFlags = ACTFLG_RunLocally | (fAssignOrPublish==1) ? ACTFLG_Published : ACTFLG_Assigned;
    Message.pAuxPath    = szAuxPath;
    Message.ftLow = ftStart;
    Message.ftHigh = ftEnd;
    BASE_PTYPE * pT = new CAB_FILE(szFilePath, TRUE);
    Message.hRoot = HKEY_CLASSES_ROOT;
    Message.fPathTypeKnown = 1;
    Message.PathType = pT->GetClassPathType(pT->GetPackageType());
    hr = UpdateClassStoreFromMessage( &Message, pClassAdmin );
    if (S_OK == hr)
    {
        pT->InstallIntoGPT( &Message,
                            fAssignOrPublish,
                            Message.pAuxPath );
    }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\regutil.cxx ===
#include "precomp.hxx"


/*
        This function opens the key identified by the KeyName, and is logically
        under the ParentKey in the registry.
        If you need to open HKCR, specify HKCR as ParentKey and KeyName to be NULL. If
        you need to open a Key under HKCR, specify the KeyName to be the name of the key
        under HKCR to be opened.
*/
BasicRegistry::BasicRegistry(
    HKEY        ParentKey,
    char    *   KeyName )
    {
        LONG error;
    // assume that this wont return an error.

    error = RegOpenKeyEx( ParentKey,
                  KeyName,
                  0,
                  KEY_ALL_ACCESS,
                  &Key );

        if( error != ERROR_SUCCESS )
                {
                Key = 0;
                }
        else
                {
                strcpy(StoredKeyName, KeyName);
                }


        KeyIndex = 0;
    }

/*
        This function enumerates the sub-key under this key. If you have to enumerate a key
        under HKCR, the class should be an HKCR class and the key will be be key to
        enumerate under HKCR
 */

LONG
BasicRegistry::NextKey(
    char            * pNameOfKeyToEnumUnderThis,
    DWORD           * pSizeOfKeyNameBuffer,
    BasicRegistry   **ppNewChildKey,
    FILETIME        ftLow,
    FILETIME        ftHigh )
    {
    HKEY    hKeyTemp;
    FILETIME ft;
    DWORD dwSaveMaxSize = *pSizeOfKeyNameBuffer;

    LONG error;
    do
    {
        error = RegEnumKeyEx(
                        Key,
                        KeyIndex,
                        pNameOfKeyToEnumUnderThis,
                        pSizeOfKeyNameBuffer,
                        0,                      // reserved - mbz
                        0,                      // class of key
                        0,                      // sizeof class buffer
                        &ft );

        if( error )
            return ERROR_NO_MORE_ITEMS;
        if (CompareFileTime(&ftLow, &ftHigh) != 0)    // if the high and low
                                                      // times are not equal
                                                      // then check the file
                                                      // time.
        {
            if ((CompareFileTime(&ftLow, &ft) <= 0) &&
                (CompareFileTime(&ft, &ftHigh) <= 0))
            {
                break;
            }
            else
            {
                // time didn't match
                // get next key
                KeyIndex++;
                *pSizeOfKeyNameBuffer = dwSaveMaxSize;
            }
        }
        else
        {
            break;
        }
    } while ( TRUE );

    error = RegOpenKeyEx(
                Key,
                pNameOfKeyToEnumUnderThis,
                0,
                KEY_ALL_ACCESS,
                &hKeyTemp );

    if( error == ERROR_SUCCESS )
        {
        *ppNewChildKey = new BasicRegistry( hKeyTemp );
        }
    else
        error = ERROR_NO_MORE_ITEMS;

    KeyIndex++;
    return error;
    }

// Gets a key whose name starts with a number. useful for typelib version and
// language id checking.

LONG
BasicRegistry::NextNumericKey(
    char            * pBufferForKeyName,
    DWORD           * pSizeOfKeyNameBuffer,
    BasicRegistry   ** ppNewChildKey,
    FILETIME        ftLow,
    FILETIME        ftHigh)
{
    HKEY    hKeyTemp;
    FILETIME ft;
    DWORD dwSaveMaxSize = *pSizeOfKeyNameBuffer;

    LONG error;
    do
    {
        error = RegEnumKeyEx(
                        Key,
                        KeyIndex,
                        pBufferForKeyName,
                        pSizeOfKeyNameBuffer,
                        0,                      // reserved - mbz
                        0,                      // class of key
                        0,                      // sizeof class buffer
                        &ft );

        if( error )
            return ERROR_NO_MORE_ITEMS;
        if( isdigit( pBufferForKeyName[0] ) )
        {
            if (CompareFileTime(&ftLow, &ftHigh) != 0)    // if the high and low
                                                          // times are not equal
                                                          // then check the file
                                                          // time.
            {
                if ((CompareFileTime(&ftLow, &ft) <= 0) &&
                    (CompareFileTime(&ft, &ftHigh) <= 0))
                {
                    break;
                }
                else
                {
                    // time didn't match
                    // get next key
                    KeyIndex++;
                    *pSizeOfKeyNameBuffer = dwSaveMaxSize;
                }
            }
            else
            {
                break;
            }
        }
    } while ( TRUE );

    error = RegOpenKeyEx(
                Key,
                pBufferForKeyName,
                0,
                KEY_ALL_ACCESS,
                &hKeyTemp );

    if( error == ERROR_SUCCESS )
        {
        *ppNewChildKey = new BasicRegistry( hKeyTemp );
        }
    else
        error = ERROR_NO_MORE_ITEMS;

    KeyIndex++;
    return error;
}

/*
        Find a subkey within the key with the given subkey name. If the subkey is not found,
        no key is created (and none needs to be deleted)
 */
LONG
BasicRegistry::Find( char * SubKeyName,
      BasicRegistry ** ppSubKey )
    {
    LONG error;

    BasicRegistry * SubKey = new BasicRegistry( Key, SubKeyName );

    if( SubKey->GetKey() != 0 )
        {
        error = ERROR_SUCCESS;
        }
    else
        {
                delete SubKey;
        error = ERROR_NO_MORE_ITEMS;
                SubKey = 0;
        }
    if( ppSubKey)
        *ppSubKey = SubKey;
    return error;
    }

/*
        Get the value on the key.
 */
LONG
BasicRegistry::QueryValue(
    char    *   ValueName,
    char    *   ValueResult,
    DWORD   *   SizeOfValueResult )
    {
    LONG    error = RegQueryValue( Key,
                                   ValueName,
                                   ValueResult,
                                   (long *)SizeOfValueResult );

    return error == ERROR_SUCCESS ? error : ERROR_NO_MORE_ITEMS;
    }
LONG
BasicRegistry::QueryValueEx(
    char    *   ValueName,
    char    *   ValueResult,
    DWORD   *   SizeOfValueResult )
    {
    LONG    error = RegQueryValueEx(Key,
                                    ValueName,
                                                                        0,
                                                                        0,
                                    (unsigned char *)ValueResult,
                                    (unsigned long *)SizeOfValueResult );

    return error == ERROR_SUCCESS ? error : ERROR_NO_MORE_ITEMS;
    }



// figure out if this key is any of the classifications we are interested in.

KEY_CLASS
BasicRegistry::ClassifyKey(
    char    *   KeyName )
    {
    LONG    error;
    char    ValueResult[ MAX_KEY_NAME_LENGTH ];
    DWORD   SizeOfValueResult = sizeof( ValueResult )/sizeof( char );

    error = QueryValue( KeyName, ValueResult, &SizeOfValueResult );

    if( error != ERROR_SUCCESS )
        return KEY_UNKNOWN;

    // See if it is a file extenstion.
    if( ValueResult[0] == '.' )
        return KEY_FILEEXT;

    // See if it is a progid. It is a progid, if it has a clsid key underneath
    // it.

    error = Find( "CLSID", 0 );

    if (error == ERROR_SUCCESS )
        return KEY_PROGID;

    return KEY_UNKNOWN;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\util.cxx ===
/****************************************************************************** 
 * Utility file for guid and other support.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

/******************************************************************************
    Da Code
 ******************************************************************************/
char *
StringToULong(
    char * pString,
    unsigned long * pNumber )
    {
    unsigned long Number = 0;
    int           Count;

    // There will be 8 characters int a string that converts into a long.

    for( Count = 0; (Count < 8) && pString && *pString ; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }

char *
StringToUShort(
    char          * pString,
    unsigned short * pNumber )
    {
    unsigned short Number = 0;
    int           Count;

    // There will be 4 characters int a string that converts into a short.

    for( Count = 0; (Count < 4) && pString ; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }
char *
StringToUChar(
    char          * pString,
    unsigned char * pNumber )
    {
    unsigned char Number = 0;
    int           Count;

    // There will be 2 characters int a string that converts into a char.

    for( Count = 0; (Count < 2) && pString ; ++Count, ++pString )
        {
        if( (*pString >= '0') && (*pString <= '9' ) )
            {
            Number = (Number << 4) + (*pString -'0');
            }
        else if( (*pString >='A') && (*pString <= 'F'))
            {
            Number = (Number << 4) + (*pString - 'A') + 10;
            }
        else if( (*pString >='a') && (*pString <= 'f'))
            {
            Number = (Number << 4) + (*pString - 'a') + 10;
            }
        }

    *pNumber = Number;
    return pString;
    }

char *
StringToCLSID(
    char    *   pString,
    CLSID   *   pClsid )
    {

    pString = StringToULong( pString, &pClsid->Data1 );
    pString++; // skip -

    pString = StringToUShort( pString, &pClsid->Data2 );
    pString++; // skip -

    pString = StringToUShort( pString, &pClsid->Data3 );
    pString++; // skip -

    pString = StringToUChar( pString, &pClsid->Data4[0] );
    pString = StringToUChar( pString, &pClsid->Data4[1] );
    pString++; // skip -

    pString = StringToUChar( pString, &pClsid->Data4[2] );
    pString = StringToUChar( pString, &pClsid->Data4[3] );
    pString = StringToUChar( pString, &pClsid->Data4[4] );
    pString = StringToUChar( pString, &pClsid->Data4[5] );
    pString = StringToUChar( pString, &pClsid->Data4[6] );
    pString = StringToUChar( pString, &pClsid->Data4[7] );

    return pString;
    }

void
CLSIDToString(
    CLSID * pClsid,
    char  * pString )
    {
    sprintf( pString,
             "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             pClsid->Data1,
             pClsid->Data2,
             pClsid->Data3,
             pClsid->Data4[0],
             pClsid->Data4[1],
             pClsid->Data4[2],
             pClsid->Data4[3],
             pClsid->Data4[4],
             pClsid->Data4[5],
             pClsid->Data4[6],
             pClsid->Data4[7] );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcs\pdict.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:
	
	pdict.cxx

 Abstract:

	This file stores the indexes of all class assocation entries based on IID.

 Notes:


 History:

 	VibhasC		Sep-29-1996		Created.

 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/
#include "precomp.hxx"

void
PDICT::Clear()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Clear the dictionary of all ITF_ENTRY indexes allocated.

 	NOTE: tHIS FUNCTION DOES NOT DELETE THE ITF_ENTRY, BUT ONLY THE INDEX
 	OF THE CLASS ENTRY

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{

	Dict_Status		        Status;
	PACKAGE_ENTRY	*	        pClassEntry;

	//
	// The way to delete all elements is to get to the top and then
	// do a get next, delete each one.
	//

	//
	// Note: Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	while( SUCCESS == Status )
		{
		pClassEntry = (PACKAGE_ENTRY *)Dict_Curr_Item();
		Status = Dict_Delete( (pUserType *) &pClassEntry );
		}

}

PACKAGE_ENTRY *
PDICT::GetFirst()
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the first item in the dictionary

 Arguments:

 	None.
	
 Return Value:
	
	None.

 Notes:

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;
	PACKAGE_ENTRY	    *	        pClassEntry;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary.
	//

	Status = Dict_Next();

	if( SUCCESS == Status )
		return pClassEntry = (PACKAGE_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

PACKAGE_ENTRY *
PDICT::GetNext( PACKAGE_ENTRY * pLastClassEntry)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Get the next item in the dictionary

 Arguments:

 	pLastClassEntry.
	
 Return Value:
	
	None.

 Notes:
    pLastClassEntry is the entry returned by the previous call to GetFirst
    or GetNext. This is the seed for this search.

    This function returns a zero if there are no more entries in the
    dictionary.

----------------------------------------------------------------------------*/
{
	Dict_Status		        Status;

	//
	// Dict_Next() has a default parameter of null. This returns the
	// first record in the dictionary. But if we supply the last searched
	// item, we get the next in the dictionary.
	//

	if( (Status = Dict_Next( pLastClassEntry) ) == SUCCESS )
		return pLastClassEntry = (PACKAGE_ENTRY *)Dict_Curr_Item();
    else
        return 0;

}

PACKAGE_ENTRY *
PDICT::Insert(
	PACKAGE_ENTRY	*	        pClassEntry )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Insert a class entry in the index.

 Arguments:
	
 Return Value:
	
 	A pointer to the PACKAGE_ENTRY entry which was created and inserted.

 Notes:

	Search for the class association entry and if it exists, return that,
	do not create a new one.
----------------------------------------------------------------------------*/
{

	Dict_Status		Status	= Dict_Find( pClassEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:

			Dict_Insert( (pUserType) pClassEntry );
			return pClassEntry;
		default:
			return (PACKAGE_ENTRY *)Dict_Curr_Item();
		}
}

PACKAGE_ENTRY *
PDICT::Search(
	char    * Name, DWORD Context )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

 	Search for a class entry in the dictionary.

 Arguments:
	
	pClassEntry	- Name of the PACKAGE_ENTRY being searched for.

 Return Value:
	
	A		pointer to the PACKAGE_ENTRY expression if found.
	NULL	otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
	//
	// In order to search, we must create a dummy PACKAGE_ENTRY to compare
	// against. We initialize this with the class id passed and search for it.
	//

	PACKAGE_ENTRY	DummyPackageEntry;
	Dict_Status		Status;

    memset(&DummyPackageEntry, '\0', sizeof( PACKAGE_ENTRY ) );
    strcpy( (char *)&DummyPackageEntry.PackageName, Name );
	DummyPackageEntry.PackageDetails.dwContext = Context;
    
	//
	// Search.
	//

	Status	= Dict_Find( &DummyPackageEntry );

	switch( Status )
		{
		case EMPTY_DICTIONARY:
		case ITEM_NOT_FOUND:
			return (PACKAGE_ENTRY *)0;
		default:
			return (PACKAGE_ENTRY *)Dict_Curr_Item();
		}
}

int
PDICT::Compare(
	 void * p1,
	 void * p2 )
	{
	PACKAGE_ENTRY 	*	pRes1	= (PACKAGE_ENTRY *)p1;
	PACKAGE_ENTRY	    *	pRes2 	= (PACKAGE_ENTRY *)p2;
	char	*			pName1 = &pRes1->PackageName[0];
	char	*			pName2 = &pRes2->PackageName[0];
		int             Result;

	Result =  _stricmp( pName1, pName2 );
	Result = (Result < 0) ? -1 : (Result > 0) ? 1 : 0;

#if 0

    if( Result == 0 )
	{
	Result = (long)( pRes1->PackageDetails.dwContext ) - (long)(pRes2->PackageDetails.dwContext);
	Result = (Result < 0) ? -1 : (Result > 0) ? 1 : 0;
	}
#endif // 0

	return Result;
	}

void
PrintPACKAGE_ENTRYKey( void * p )
	{
	((void)(p));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csadmin\pcstest\main.cxx ===
/****************************************************************************** 
 * Temp conversion utility to take registry entries and populate the class store with those entries.
 *****************************************************************************/

/******************************************************************************
    includes
******************************************************************************/
#include "precomp.hxx"

#define HOME 1

/******************************************************************************
    defines and prototypes
 ******************************************************************************/

extern CLSID CLSID_ClassStore;
extern const IID IID_IClassAdmin;

const IID IID_IClassStore = {
        0x00000190,
        0x0000,
        0x0000,
        { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }
};



void GatherArguments(
        int argc,
        char * argv[],
        MESSAGE * pMessage );


HRESULT UpdateDatabaseFromRegistry(
        MESSAGE * pMessage );

HRESULT UpdateClassStoreFromDatabase(
        MESSAGE * pMessage,
        IClassAdmin * pClassAdmin );

IClassAdmin * InitializeClassStoreInterfaces(
        MESSAGE * pMessage );

void ReleaseClassStoreInterfaces(
        MESSAGE * pMessage,
        IClassAdmin * pClassAdmin);

HRESULT AddToClassStore(
        MESSAGE *pMessage,
        IClassAdmin * pClassAdmin );

void DumpOnePackage(
        MESSAGE * pMessage,
        PACKAGEDETAIL * p );

void DumpOneAppDetail(
        MESSAGE * pMessage,
	    APPDETAIL * pA );

void DumpOneClass(
        MESSAGE * pMessage,
        CLASSDETAIL * pClassDetail );

void DumpIIDEntries(
         IIDICT * pIIDict );

void DumpOneIIDEntry(
        ITF_ENTRY * pITFEntry );

void
DumpOneTypelib(
    MESSAGE * pMessage,
    CLSID   * pClsid );

HRESULT VerifyArguments(
        MESSAGE * pMessage );

/******************************************************************************
    Globals
 ******************************************************************************/

char    *   SwitchSpecified[26];
char    *    AdditionalSwitchParam[26];
BOOL         DumpAll = 1;


/******************************************************************************
    Da Code
 ******************************************************************************/

void Usage()
{
    printf("\nUsage:");

    //////////////////////////////////////////////////////////////////////////

    printf("\n\t -a <Architecture> - valid values are:" );
    printf("\n\t\t [ Intel, Alpha]");

    //////////////////////////////////////////////////////////////////////////

    printf("\n\t -o <OS> - valid values are:");
    printf("\n\t\t [Winnt, Win95, Win31]" );

    printf("\n\t -p <Full Package Path (including name eg \\foo\bar\baz.cab>");

    //////////////////////////////////////////////////////////////////////////

    printf("\n\t -r <RunFlags> - NotImplemeted yet");

    //////////////////////////////////////////////////////////////////////////

	printf("\n\t -n <Package name >" );

    //////////////////////////////////////////////////////////////////////////

    printf("\n\t -k <Registry key: eg \\Software\\Classes (always assumed under HKLM");
	printf("\n\t\t eg \\Software\\Classes for HKLM\\Software\\Classes or HKCR" );
	printf("\n\t -s <Setup Command including switches>");
	printf("\n\t -z <Dump, but dont update class store>");
	printf("\n\t -c <Class store path >");
	//////////////////////////////////////////////////////////////////////////

	printf("\n\t -i <icon path>");
	//////////////////////////////////////////////////////////////////////////

}

int __cdecl main( int argc, char * argv[] )
{
    MESSAGE *   pMessage = new MESSAGE;
	IClassAdmin * pClassAdmin;
	HRESULT     hr;

	// gather arguments

	GatherArguments( argc, argv, pMessage );

	if( pMessage->SetRootKey( SwitchSpecified[ 'K' - 'A' ] ) != ERROR_SUCCESS )
	    {
		printf("\nCannot open Key: %s\n", AdditionalSwitchParam[ 'K' - 'A' ] );
		exit( MAKE_HRESULT( SEVERITY_ERROR,
                            FACILITY_WIN32,
                            ERROR_INVALID_PARAMETER) );
	    }

	if( (hr = VerifyArguments( pMessage)) != S_OK )
	    {
		printf("\nInvalid arguments, hr = 0x%x\n", hr );
        exit( hr );
	    }

    UpdateDatabaseFromRegistry( pMessage );

	pClassAdmin = InitializeClassStoreInterfaces( pMessage );
	UpdateClassStoreFromDatabase( pMessage, pClassAdmin );
	ReleaseClassStoreInterfaces( pMessage, pClassAdmin );

    return 0;
}

void
GatherArguments(
    int argc,
    char * argv[],
	MESSAGE * pMessage )
    {
    int     Index = 1;
    char *  argp;

	memset(&SwitchSpecified[0], '\0', sizeof(SwitchSpecified)/sizeof(char *) );


    // For switches that do not take arguments, do not advance the index pointer
    // in the switch handler.
 
    while( Index < argc )
        {
        argp = argv[Index];
        if( (*argp == '-') || (*argp == '/') )++argp;

        switch( toupper(*argp) )
            {
            case 'A':
                ++Index;
                SwitchSpecified[ 'A' - 'A'] = argp = argv[ Index ];
                break;
            case 'O':
                ++Index;
                SwitchSpecified[ 'O' - 'A'] = argp = argv[ Index ];
                break;
            case 'P':
                ++Index;
                SwitchSpecified[ 'P' - 'A'] = argp = argv[ Index ];
        		pMessage->pPackagePath = argp;
                break;
			case 'N':
				++Index;
				SwitchSpecified['N' - 'A'] = argp = argv[Index];
				pMessage->pPackageName = argp;
				break;
			case 'K':
				++Index;
				SwitchSpecified['K' - 'A'] = argp = argv[Index];
				pMessage->pRegistryKeyName = argp;
				break;
			case 'S':
				++Index;
				SwitchSpecified['S' - 'A'] = argp = argv[Index];
				pMessage->pSetupCommand = argp;
				break;
			case 'Z':
				SwitchSpecified['Z' - 'A'] = argp = argv[Index];
				pMessage->fDumpOnly = 1;
				pMessage->pDumpOnePackage = DumpOnePackage;
				break;
			case 'C':
				++Index;
				SwitchSpecified['C' - 'A'] = argp = argv[Index];
				pMessage->pClassStoreName = argp;
				break;
            case 'I':
				++Index;
				SwitchSpecified['I' - 'A'] = argp = argv[Index];
				pMessage->pIconPath = argp;
				break;
            case 'D':
				++Index;
				SwitchSpecified['D' - 'A'] = argp = argv[Index];
				pMessage->pClassStoreDomainName = argp;
				break;
            case 'R':
				pMessage->ActFlags = ACTFLG_RunLocally;
                break;
            default:
                printf( "\nUnknown switch %c", *argp );
                Usage();
                exit(1);
            }
        ++Index;
        }

	// update base registry key.

	if( SwitchSpecified[ 'K' - 'A' ] == 0 )
		pMessage->pRegistryKeyName = "\\Software\\Classes";

    // updatre class store name.

	if( SwitchSpecified[ 'C' - 'A' ] == 0 )
		pMessage->pClassStoreName = "classstore3";

    // update class store domain name

    if(SwitchSpecified[ 'D' - 'A' ] == 0 )
        pMessage->pClassStoreDomainName = "olecs";
    
    // update architecture.

    if( SwitchSpecified[ 'A'-'A'] && SwitchSpecified['O' - 'A'] )
        {
        DWORD O,A;
        int i;

        static char * pArcStrings[] = { "Unknown",
                                        "Intel",
                                        "Mips",
                                        "Alpha",
                                        "PPC"
                                      };
        static DWORD  Arc[] =
                        {
                        PROCESSOR_ARCHITECTURE_UNKNOWN,
                        PROCESSOR_ARCHITECTURE_INTEL,            
                        PROCESSOR_ARCHITECTURE_MIPS,            
                        PROCESSOR_ARCHITECTURE_ALPHA,
                        PROCESSOR_ARCHITECTURE_PPC
                        };

        static char * pOsStrings[] =
                         {
                         "Winnt",
                         "Win95",
                         "Win31"
                         };

        static DWORD Os[] =
                         {
                         OS_WINNT,
                         OS_WIN95,
                         OS_WIN31
                         };

        for (i = 0; i < sizeof( pArcStrings)/sizeof(char *);++i )
            {
            if( _stricmp( pArcStrings[ i ], SwitchSpecified[ 'A'-'A' ]) == 0 )
                A = Arc[ i ];
            }
        for (i = 0; i < sizeof( pOsStrings)/sizeof(char *);++i )
            {
            if( _stricmp( pOsStrings[ i ], SwitchSpecified[ 'O'-'A' ]) == 0 )
                O = Os[ i ];
            }
    
        pMessage->Architecture = MAKEARCHITECTURE(A,O);
       }
    }


IClassAdmin *
InitializeClassStoreInterfaces( MESSAGE * pMessage )
{
	IClassAdmin *pClassAdmin = NULL;
	IMoniker *pmk = NULL;
	LPBC pbc = NULL;
	ULONG chEaten;
	char 	Buffer[_MAX_PATH ];
	OLECHAR	MonikerBuffer[(_MAX_PATH+1)*2 ];
	

	if( pMessage->fDumpOnly )
		return 0;

	HRESULT hr = CoInitialize(NULL);

	if( FAILED(hr) )
	{
	printf( "Client CoInitialize failed Ox%x!\n", hr );
	return 0;
	}

	hr = CreateBindCtx (0, &pbc);
	if (!SUCCEEDED(hr))
	{
	printf( "CreateBindCtx failed Ox%x!\n", hr );
	return 0;
	}


	strcpy(Buffer, "ADCS:");
	strcat(Buffer, pMessage->pClassStoreName );

	mbstowcs( MonikerBuffer, Buffer, strlen(Buffer)+1 );

	chEaten = 0;
	hr = MkParseDisplayName (pbc, MonikerBuffer, &chEaten,&pmk);

	if (!SUCCEEDED(hr))
	{
	printf( "MkParseDisplayName failed Ox%x!\n", hr );
	return 0;
	}

	hr = pmk->BindToObject ( 
					pbc,
					NULL,
					IID_IClassAdmin,
					(void **) &pClassAdmin);

	if (!SUCCEEDED(hr))
	{
	printf( "BindToObject failed Ox%x!\n", hr );
	return 0;
	}
	pmk->Release();
	pbc->Release();

	return pClassAdmin;
    
}
void
ReleaseClassStoreInterfaces( MESSAGE * pMessage, IClassAdmin * pClassAdmin)
{
	if( pMessage->fDumpOnly || (pClassAdmin == 0) )
		return;
    pClassAdmin->Release();
}

void
DumpIIDEntries( IIDICT * pIIDict )
	{
	ITF_ENTRY * pITFEntry = pIIDict->GetFirst();

	if( pITFEntry )
		do
			{
			printf("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
			printf("\nIID = %s", pITFEntry->IID );
			DumpOneIIDEntry( pITFEntry );
			printf("\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
			pITFEntry = pIIDict->GetNext( pITFEntry );
			} while (pITFEntry != 0 );
	}

void
DumpOneIIDEntry(ITF_ENTRY * pITFEntry )
	{
	printf("\nProxyStubClsid = %s", pITFEntry->Clsid );
	printf("\nTypelibID = %s", pITFEntry->TypelibID );
	}

void
DumpOnePackage(
	MESSAGE * pMessage,
	PACKAGEDETAIL * p )
	{
	DWORD count;
	
	printf("\n++++++++++++++++++++++++++++++++++++++++++++++++++");
	
	printf( "\nClassPathType = %d", p->PathType );
	wprintf(L"\nPackagePath = %s", p->pszPath );
	wprintf(L"\nIconPath = %s", p->pszIconPath );
	wprintf(L"\nSetup Command = %s", p->pszSetupCommand );
	printf("\nActFlags = %d", p->dwActFlags );
	wprintf(L"\nVendor = %s", p->pszVendor );
	wprintf(L"\nPackageName = %s", p->pszPackageName );
	wprintf(L"\nProductName = %s", p->pszProductName );
	wprintf(L"\ndwContext = %d", p->dwContext );
	wprintf(L"\nCsPlatform = (PlatformID= 0x%x, VersionHi = 0x%x, VersionLo = 0x%x, ProcessorArchitecture = 0x%x",
             p->Platform.dwPlatformId,
             p->Platform.dwVersionHi,
             p->Platform.dwVersionLo,
             p->Platform.dwProcessorArch );
	wprintf(L"\ndwLocale = 0x%x", p->Locale );
	wprintf(L"\ndwVersionHi = %d", p->dwVersionHi );
	wprintf(L"\ndwVersionLo = %d", p->dwVersionLo );
	wprintf(L"\nCountOfApps = %d", p->cApps );

	for( count = 0;
		 count < p->cApps;
		 ++count )
		{
		DumpOneAppDetail( pMessage, &p->pAppDetail[count] );
		}
	printf("\n--------------------------------------------------");
	}

	
void
DumpOneAppDetail(
	MESSAGE * pMessage,
	APPDETAIL * pA )
	{
	char Buffer[ 100 ];
	DWORD count;
	CLASS_ENTRY * pC;


	CLSIDToString( &pA->AppID, &Buffer[0] );
	printf( "\n\t\tAPPID = %s", &Buffer[0] );

	if( pA->cClasses )
		{
		for( count = 0;
			 count < pA->cClasses;
			 ++count )
			{

			char Buffer[50];
			CLSIDToString( &pA->prgClsIdList[count],&Buffer[0] );
			pC = pMessage->pClsDict->Search( &Buffer[0] );
			if( pC )
				DumpOneClass( pMessage, &pC->ClassAssociation );
			}
		}
	if( pA->cTypeLibIds )
	    {
		for( count = 0;
			 count < pA->cTypeLibIds;
			 ++count )
			{
			DumpOneTypelib( pMessage, pA->prgTypeLibIdList );
			}
	    }
	else
	    printf( "\n\t\t No Typelibs present" );
	}


void
DumpOneClass( MESSAGE * pMessage, CLASSDETAIL * pClassDetail )
	{
	char  Buffer[ _MAX_PATH ];
	DWORD count;

	CLSIDToString( &pClassDetail->Clsid, &Buffer[0] );
	printf( "\n\t\t\tCLSID = %s", &Buffer[0] );


	wprintf( L"\n\t\t\tDescription = %s", pClassDetail->pszDesc );
	wprintf( L"\n\t\t\tIconPath = %s", pClassDetail->pszIconPath );

	CLSIDToString( &pClassDetail->TreatAsClsid, &Buffer[0] );
	printf( "\n\t\t\tTreatAsClsid = %s", &Buffer[0] );

	CLSIDToString( &pClassDetail->AutoConvertClsid, &Buffer[0] );
	printf( "\n\t\t\tAutoConvertClsid = %s", &Buffer[0] );

	printf("\n\t\t\tCountOfFileExtensions = %d", pClassDetail->cFileExt );

	if( pClassDetail->cFileExt )
		{
		for(count = 0;
			count < pClassDetail->cFileExt;
			count++
			)
			{
			wprintf( L"\n\t\t\tFileExt = %s", pClassDetail->prgFileExt[ count ] );
			}
		}
	else
		{
		printf("\n\t\t\tOtherFileExt = None" );
		}

	wprintf(L"\n\t\t\tMimeType = %s", pClassDetail->pMimeType );
	wprintf(L"\n\t\t\tDefaultProgid = %s", pClassDetail->pDefaultProgId );

	printf("\n\t\t\tCountOfOtherProgIds = %d", pClassDetail->cOtherProgId );
	if( pClassDetail->cOtherProgId )
		{
		for(count = 0;
			count < pClassDetail->cOtherProgId;
			count++
			)
			{
			wprintf( L"\n\t\t\tOtherProgId = %s", pClassDetail->prgOtherProgId[ count ] );
			}
		}
	else
		{
		printf("\n\t\t\tOtherProgId = None" );
		}
	printf("\n");

	}

void
DumpOneTypelib(
    MESSAGE * pMessage,
    CLSID   * pClsid )
    {
	char  Buffer[ _MAX_PATH ];
	CLSIDToString( pClsid, &Buffer[0] );
	printf( "\n\t\t\tTypelibID = %s", &Buffer[0] );
	printf("\n");
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csinst\csinst.cxx ===
/*
* csinst.cxx

  Author: DebiM
  
    This is a tool to install an empty Class Repository for a NTDS DC.
    This needs to be run after a successful NTDS installation.
    It creates an empty repository in the domain.
    
*/

#include "ole2int.h"
#include <rpc.h>
#include "cstore.h"
//dsbase.hxx"



//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  History:    10-22-96   DebiM   Created
//
//----------------------------------------------------------------------------
void _cdecl main( int argc, char ** argv)
{
    HRESULT     hr;
    WCHAR       szPath [_MAX_PATH + 1];    
    
    hr = CoInitialize(NULL);
    if ( FAILED(hr) )
    {
        printf( "CoInitialize failed(%x)\n", hr );
        return;
    }
    
    
    if (argc == 2)
    {
        //
        // Use the path for the container passed as parameter
        //
        
        MultiByteToWideChar (CP_ACP, 0, argv [1], strlen (argv[1]) + 1, szPath, _MAX_PATH);
        hr = CsCreateClassStore(szPath);
    }
    else
    {
        printf( "Usage is >> csinst <Class Store Path>\n");
        CoUninitialize();
        return;
    }
    
    if (FAILED(hr))
    {
        printf( "Failed to create repository - %S. Error - 0x%x\n", 
            szPath, hr);
    }
    else
    {
        printf( "Created Repository at - %S.\n", 
            szPath);
    }
    
    CoUninitialize();
    return;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csdrt\csdrtgc.cxx ===
//
//  Author: DebiM
//  Date:   March 97.  Revised for Beta2 in Nov 97.
//  File:   csdrtgc.cxx
//
//      Class Store DRTs
//
//      This source file contains DRTs for Class Store App Access
//          CClassAccess::IClassAccess
//
//
//      It tests the following Class Store functionality
//
//         GetAppInfo()
//         CsEnumApps()
//
//
//
//---------------------------------------------------------------------

#include "csdrt.hxx"
extern BOOL fVerbose;
extern BOOL fMultiStore;
extern IClassAccess *pIClassAccess;

extern GUID TestClsid1, TestClsid2, TestClsid3, TestClsid4, TestClsid5;
extern Sname TestPackName4, TestFileExt1, TestFileExt4, TestMimeType2;
extern Sname TestOtherProgID2, TestProgId1, TestProgId3;
extern WCHAR  szLookupPackageName [];

extern BOOL fClassInfoVerify;


//
// Routines to verify that the App Package returned is as expected.
//
HRESULT AssertPackage(INSTALLINFO *pInstallInfo)
{
    // Code Path should be present
    VerifyPackage (pInstallInfo->pszScriptPath != NULL, L"Script Path Missing");
    // Script should be present
#if 0
    VerifyPackage (pInstallInfo->cScriptLen != 0, L"Script Missing");
    for (UINT i=0; i < pInstallInfo->cScriptLen; i++)
    {
       VerifyPackage (pInstallInfo->pScript[i] == i%128, L"Script Content Wrong");
    }
#endif

//    ReleaseInstallInfo(pInstallInfo);

    return S_OK;
}

void ReleaseObj(PACKAGEDISPINFO obj)
{
    ReleasePackageInfo(&obj);
}

void VerbosePrintObj(PACKAGEDISPINFO obj)
{
}


//
// Routine to call GetAppInfo() with different class spec.
//
HRESULT CallClassSpecInfo (uCLSSPEC         *pclsspec,
                           INSTALLINFO      *pInstallInfo)
{
    QUERYCONTEXT    QryContext;
    HRESULT         hr;

    QryContext.dwContext = CLSCTX_INPROC_SERVER + CLSCTX_LOCAL_SERVER;
    QryContext.Locale = GetThreadLocale();
    GetDefaultPlatform(&QryContext.Platform);
    QryContext.dwVersionHi = 0;
    QryContext.dwVersionLo = 0;

    hr = pIClassAccess->GetAppInfo(
         pclsspec,
         &QryContext,
         pInstallInfo);

    if (!SUCCEEDED(hr))
        return hr;

    PrintInstallInfo(pInstallInfo);

    return hr;
}


//
// This routine calls GetAppInfo() for a FileExtension
//

HRESULT LookupByFileext (LPOLESTR pExt,
                         INSTALLINFO  *pInstallInfo)
{
    HRESULT        hr;
    uCLSSPEC       clsspec;

    clsspec.tyspec = TYSPEC_FILEEXT;
    clsspec.tagged_union.pFileExt = pExt;

    hr = CallClassSpecInfo(&clsspec, pInstallInfo);
    if (!SUCCEEDED(hr))
    {
        VerbosePrint("....... GetClassSpecInfo (EXT=%S) returned 0x%x\n", pExt, hr);
        return hr;
    }
    return S_OK;
}

//
// This routine calls GetAppInfo() for a Clsid
//

HRESULT LookupByClsid (GUID Clsid,
                       INSTALLINFO  *pInstallInfo)
{
    HRESULT        hr;
    uCLSSPEC       clsspec;

    clsspec.tyspec = TYSPEC_CLSID;
    memcpy(&clsspec.tagged_union.clsid, &Clsid, sizeof(GUID));

    hr = CallClassSpecInfo(&clsspec, pInstallInfo);

    if (!SUCCEEDED(hr))
    {
        VerbosePrint("....... GetClassSpecInfo (CLSID=) returned 0x%x\n", hr);
        return hr;
    }
    return S_OK;
}

//
// This routine calls GetAppInfo() for a MimeType
//
HRESULT LookupByMimeType (LPOLESTR pMimeType,
                          INSTALLINFO  *pInstallInfo)
{
    HRESULT        hr;
    uCLSSPEC       clsspec;

    clsspec.tyspec = TYSPEC_MIMETYPE;
    clsspec.tagged_union.pMimeType = pMimeType;

    hr = CallClassSpecInfo(&clsspec, pInstallInfo);

    if (!SUCCEEDED(hr))
    {
        VerbosePrint("....... GetClassSpecInfo (MimeType=%S) returned 0x%x\n", pMimeType, hr);
        return hr;
    }
    return S_OK;
}

//
// This routine calls GetAppInfo() for a Progid
//
HRESULT LookupByProgid (LPOLESTR pProgId,
                       INSTALLINFO  *pInstallInfo)
{
    HRESULT        hr;
    uCLSSPEC       clsspec;

    clsspec.tyspec = TYSPEC_PROGID;
    clsspec.tagged_union.pProgId = pProgId;

    hr = CallClassSpecInfo (&clsspec, pInstallInfo);

    if (!SUCCEEDED(hr))
    {
        VerbosePrint("....... GetClassSpecInfo (ProgId=%S) returned 0x%x\n", pProgId, hr);
        return hr;
    }
    return S_OK;
}

//
// This routine calls GetAppInfo() by Name of Package
//
HRESULT LookupByName (LPOLESTR pName,
                       INSTALLINFO  *pInstallInfo)
{
    HRESULT        hr;
    uCLSSPEC       clsspec;

    clsspec.tyspec = TYSPEC_PACKAGENAME;
    clsspec.tagged_union.pPackageName = pName;

    hr = CallClassSpecInfo (&clsspec, pInstallInfo);
    if (!SUCCEEDED(hr))
    {
        VerbosePrint("....... GetClassSpecInfo (PackageName=%S) returned 0x%x\n", pName, hr);
        return hr;
    }
    return S_OK;
}

//
// This routine calls GetClassInfo() for a TypeLib
//
HRESULT LookupByTlbid (GUID TlbId,
                       INSTALLINFO  *pInstallInfo)
{
    HRESULT        hr;
    uCLSSPEC       clsspec;

    clsspec.tyspec = TYSPEC_TYPELIB;
    memcpy(&clsspec.tagged_union.typelibID, &TlbId, sizeof(GUID));

    hr = CallClassSpecInfo (&clsspec, pInstallInfo);
    if (!SUCCEEDED(hr))
    {
        VerbosePrint("....... GetClassSpecInfo (Tlb) returned 0x%x\n", hr);
        return hr;
    }
    return S_OK;
}

void HandleEnumResult(UINT cElt, UINT cFound, HRESULT hr, PACKAGEDISPINFO PackageInfo[])
{
    if (fVerbose)
    {
        if ((hr != S_OK) && (hr != S_FALSE))
        {
            printf ("..........Next(%d) returned error = 0x%x.\n", cElt, hr);
        }
        else
        {
            printf ("..........Next(%d) returned %d packages. hr = 0x%x.\n", cElt, cFound, hr);
            for (UINT i = 0; i < cFound; i++)
            {
                printf ("..........PackageInfo[%d].pszPackageName = %S, Flags=%d\n", 
                    i, 
                    PackageInfo[i].pszPackageName,
                    PackageInfo[i].dwActFlags);
                ReleasePackageInfo(&PackageInfo[i]);
            }
        }
    }
}

PACKAGEDISPINFO PackageDisp[3];

// DoCoEnumApps Test
HRESULT DoCoEnumAppsTest()
{
PACKAGEDISPINFO PackageInfo[30];
ULONG cFound;
HRESULT hr;
IEnumPackage     *pIEnumPackage = NULL;

  VerbosePrint("...... CsEnumApps(All Platform & Locale).\n");
  hr = CsEnumApps(
        NULL,
        NULL,
        NULL,
        APPINFO_ALLLOCALE | APPINFO_ALLPLATFORM,
        &pIEnumPackage
        );

  if (hr != S_OK)
  {
      printf ("CsEnumApps returned error = 0x%x.\n", hr);
      return hr;
  }

  memset (&PackageInfo[0], 0, sizeof(PACKAGEDISPINFO) * 30);

  VerbosePrint("......... Next(6)\n");
  hr = pIEnumPackage->Next(6, &PackageInfo[0], &cFound );
  HandleEnumResult(6, cFound, hr, &PackageInfo[0]);

  VerbosePrint("......... Next(4)\n");
  hr = pIEnumPackage->Next(4, &PackageInfo[0], &cFound );
  HandleEnumResult(4, cFound, hr, &PackageInfo[0]);

  pIEnumPackage->Release();

  pIEnumPackage = NULL;

  VerbosePrint("...... CsEnumApps(All Platform & Locale, Wildcard=*2*2*)\n");
  hr = CsEnumApps(
        L"*2*2*",
        NULL,
        NULL,
        APPINFO_ALLLOCALE | APPINFO_ALLPLATFORM,
        &pIEnumPackage
        );

  if (hr != S_OK)
  {
      printf ("CsEnumApps returned error = 0x%x.\n", hr);
      return hr;
  }

  if (fClassInfoVerify) {
      DWORD cgot;
      EnumTests(pIEnumPackage, 3, &cgot, PackageDisp, 3, TRUE);
  }
  else {
      memset (&PackageInfo[0], 0, sizeof(PACKAGEDISPINFO) * 30);
      
      VerbosePrint("......... Next(6)\n");
      hr = pIEnumPackage->Next(6, &PackageInfo[0], &cFound );
      HandleEnumResult(6, cFound, hr, &PackageInfo[0]);
  }
  pIEnumPackage->Release();

  pIEnumPackage = NULL;

  VerbosePrint("...... CsEnumApps(ASSIGNED & MSI ONLY)\n");
  hr = CsEnumApps(
        NULL,
        NULL,
        NULL,
        APPINFO_ASSIGNED | APPINFO_MSI,
        &pIEnumPackage
        );

  if (hr != S_OK)
  {
      printf ("CsEnumApps returned error = 0x%x.\n", hr);
      return hr;
  }

  if (fClassInfoVerify) {
      DWORD cgot;
      EnumTests(pIEnumPackage, 3, &cgot, PackageDisp, 3, TRUE);
  }
  else {
      memset (&PackageInfo[0], 0, sizeof(PACKAGEDISPINFO) * 30);
      
      VerbosePrint("......... Next(6)\n");
      hr = pIEnumPackage->Next(6, &PackageInfo[0], &cFound );
      HandleEnumResult(6, cFound, hr, &PackageInfo[0]);
  }

  pIEnumPackage->Release();
  pIEnumPackage = NULL;

  VerbosePrint("...... CsEnumApps(PUBLISHED & VISIBLE ONLY)\n");
  hr = CsEnumApps(
        NULL,
        NULL,
        NULL,
        APPINFO_PUBLISHED | APPINFO_VISIBLE,
        &pIEnumPackage
        );

  if (hr != S_OK)
  {
      printf ("CsEnumApps returned error = 0x%x.\n", hr);
      return hr;
  }

  if (fClassInfoVerify) {
      DWORD cgot;
      EnumTests(pIEnumPackage, 3, &cgot, PackageDisp, 3, TRUE);
  }
  else {
      memset (&PackageInfo[0], 0, sizeof(PACKAGEDISPINFO) * 30);
      
      VerbosePrint("......... Next(6)\n");
      hr = pIEnumPackage->Next(6, &PackageInfo[0], &cFound );
      HandleEnumResult(6, cFound, hr, &PackageInfo[0]);
  }
  pIEnumPackage->Release();
  return hr;
}

extern PACKAGEDETAIL   PackageDetail1, PackageDetail2,
                PackageDetail3, PackageDetail4;

HRESULT DoClassInfoTest()
{

    INSTALLINFO InstallInfo;
    HRESULT hr = S_OK, hr2;

//By Package Name
    VerbosePrint("...... Lookup by Package Name.\n");
    hr = LookupByName (TestPackName4,
                        &InstallInfo);
    if (fClassInfoVerify)
        if (!Compare(InstallInfo, *(PackageDetail3.pInstallInfo)))
            printf("!!!Members of InstallInfo not matching\n\n");

    ReleaseInstallInfo(&InstallInfo);

//FileExt1
    VerbosePrint("...... Lookup by FileExt1.\n");
    hr2 = LookupByFileext (TestFileExt1, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if (!Compare(InstallInfo, *(PackageDetail1.pInstallInfo)))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

//Clsid1
    VerbosePrint("...... Lookup by Clsid1.\n");
    hr2 = LookupByClsid (TestClsid1, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if ((!Compare(InstallInfo, *(PackageDetail1.pInstallInfo))) && 
                (!Compare(InstallInfo, *(PackageDetail2.pInstallInfo))))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

//ProgId1
    VerbosePrint("...... Lookup by ProgId1.\n");
    hr2 = LookupByProgid (TestProgId1, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if ((!Compare(InstallInfo, *(PackageDetail1.pInstallInfo))) && 
                (!Compare(InstallInfo, *(PackageDetail2.pInstallInfo))))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

//Clsid2

    VerbosePrint("...... Lookup by Clsid2.\n");
    hr2 = LookupByClsid (TestClsid2, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if (!Compare(InstallInfo, *(PackageDetail1.pInstallInfo)))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

//ProgId3

    VerbosePrint("...... Lookup by ProgId3.\n");
    hr2 = LookupByProgid (TestProgId3, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if (!Compare(InstallInfo, *(PackageDetail2.pInstallInfo)))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

//TestOtherProgID2
    VerbosePrint("...... Lookup by OtherProgId2.\n");
    hr2 = LookupByProgid (TestOtherProgID2, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if ((!Compare(InstallInfo, *(PackageDetail1.pInstallInfo))) && 
                (!Compare(InstallInfo, *(PackageDetail2.pInstallInfo))))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

    if (!fMultiStore)
        return hr;

    VerbosePrint(".... Looking in Second Store.\n");


//FileExt4
    VerbosePrint("...... Lookup by FileExt4.\n");
    hr = LookupByFileext (TestFileExt4, &InstallInfo);
    if (SUCCEEDED(hr))
    {
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
        if (fClassInfoVerify)
            if ((!Compare(InstallInfo, *(PackageDetail1.pInstallInfo))) && 
                (!Compare(InstallInfo, *(PackageDetail3.pInstallInfo))))
                printf("!!!Members of InstallInfo not matching\n\n");
    }
    ReleaseInstallInfo(&InstallInfo);

// Clsid4
// Should get two packages now !!

    VerbosePrint("...... Lookup by Clsid4.\n");
    hr2 = LookupByClsid (TestClsid4, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

// Tlbid1

    VerbosePrint("...... Lookup by Tlbid1.\n");
    hr2 = LookupByTlbid (TestClsid1, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

// Tlbid2

    VerbosePrint("...... Lookup by Tlbid2.\n");
    hr2 = LookupByTlbid (TestClsid2, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        //AssertPackage(&InstallInfo);
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);

// Clsid5

    VerbosePrint("...... Lookup by Clsid5.\n");
    hr2 = LookupByClsid (TestClsid5, &InstallInfo);
    if (SUCCEEDED(hr2))
    {
        //
        // Check expected values
        //
        hr2 = AssertPackage(&InstallInfo);
    }
    if (!SUCCEEDED(hr2))
        hr = hr2;

    ReleaseInstallInfo(&InstallInfo);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csdrt\csdrtcmp.cxx ===
#include "csdrt.hxx"
extern BOOL fVerbose;

BOOL Compare(WCHAR *sz1, WCHAR *sz2)
{
    return (wcscmp(sz1, sz2) == 0);
}

BOOL Compare(CSPLATFORM cp1, CSPLATFORM cp2)
{
    return (memcmp((void *)&cp1, (void *)&cp2, sizeof(CSPLATFORM)) == 0);
}

BOOL Compare(GUID guid1, GUID guid2)
{
    return (guid1 == guid2);
}

BOOL Compare(DWORD dw1, DWORD dw2)
{
    return (dw1 == dw2);
}

BOOL Compare(CLASSDETAIL Cd1, CLASSDETAIL Cd2)
{
    int i;
    if (Cd1.Clsid != Cd2.Clsid)
        return FALSE;

/*    if (Cd1.TreatAs != Cd2.TreatAs)
        return FALSE;

    if (Cd1.cProgId != Cd2.cProgId)
        return FALSE;

    for (i = 0; i < (int)(Cd1.cProgId); i++)
        if (!ArrayCompare((Cd1.prgProgId), (Cd2.prgProgId)[i], (Cd1.cProgId)))
            return FALSE;
*/
    return TRUE;
}

BOOL Compare(ACTIVATIONINFO Av1, ACTIVATIONINFO Av2)
{
    int i;

    if ((Av1.cClasses) != (Av2.cClasses))
        return FALSE;

    for (i = 0; i < (int)(Av1.cClasses); i++) 
        if (!ArrayCompare(Av1.pClasses, Av2.pClasses[i], (Av1.cClasses)))
            return FALSE;

    if ((Av1.cShellFileExt) != (Av2.cShellFileExt))
        return FALSE;

    for (i = 0; i < (int)(Av1.cShellFileExt); i++) {
        DWORD posn1=0, posn2=0;

        posn1 = ArrayCompare<LPOLESTR>((Av1.prgShellFileExt), (Av2.prgShellFileExt)[i], (Av1.cShellFileExt));
        posn2 = ArrayCompare((Av1.prgPriority), (Av2.prgPriority)[i], (Av1.cShellFileExt));
        
        if ((posn1 == 0) || (posn1 != posn2))
            return FALSE;
    }

    if ((Av1.cInterfaces) != (Av2.cInterfaces))
        return FALSE;

    for (i = 0; i < (int)(Av1.cInterfaces); i++) {
        if (!ArrayCompare<GUID>(Av1.prgInterfaceId, Av2.prgInterfaceId[i], Av1.cInterfaces))
            return FALSE;
    }

    if ((Av1.cTypeLib) != (Av2.cTypeLib))
        return FALSE;

    for (i = 0; i < (int)(Av1.cTypeLib); i++) {
        if (!ArrayCompare(Av1.prgTlbId, (Av2.prgTlbId)[i], (Av1.cTypeLib)))
            return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID
//
//--------------------------------------------------------------------------
int  StringFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    swprintf(lptsz, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);

    return 36;
}

BOOL Compare(INSTALLINFO If1, INSTALLINFO If2)
{
    if (If1.dwActFlags != If2.dwActFlags) {
       printf("ActFlags not matching 0x%x & 0x%x\n", If1.dwActFlags, If2.dwActFlags);
       return FALSE;
    }

    if (If1.PathType != If2.PathType) {
       printf("PathType not matching 0x%x & 0x%x\n", If1.PathType, If2.PathType);
       return FALSE;
    }

    if ((If1.pszScriptPath != If2.pszScriptPath) && 
        (wcscmp(If1.pszScriptPath, If2.pszScriptPath) != 0)) {
       printf("pszScriptPath not matching %S & %S\n", If1.pszScriptPath, If2.pszScriptPath);
       return FALSE;
    }

    if ((If1.pszSetupCommand != If2.pszSetupCommand) && 
        (wcscmp(If1.pszSetupCommand, If2.pszSetupCommand) != 0)) {
       printf("pszSetupCommand not matching %S & %S\n", If1.pszSetupCommand, If2.pszSetupCommand);
       return FALSE;
    }

    if ((If1.pszUrl != If2.pszUrl) && 
        (wcscmp(If1.pszUrl, If2.pszUrl) != 0)) {
       printf("pszUrl not matching %S & %S\n", If1.pszUrl, If2.pszUrl);
       return FALSE;
    }


    if (If1.dwComClassContext != If2.dwComClassContext) {
       printf("dwComClassContext not matching 0x%x & 0x%x\n", If1.dwComClassContext, If2.dwComClassContext);
       return FALSE;
    }

    if (If1.InstallUiLevel != If2.InstallUiLevel) {
       printf("InstallUiLevel not matching 0x%x & 0x%x\n", If1.InstallUiLevel, If2.InstallUiLevel);
       return FALSE;
    }

// pClsid
/*  Not matching corrently

    if ((If1.ProductCode) != (If2.ProductCode)) {
       WCHAR  szGuid1[100], szGuid2[100];
       
       StringFromGUID(If1.ProductCode, szGuid1);
       StringFromGUID(If2.ProductCode, szGuid2);
       printf("ProductCode not matching\n\t%S\n\t%S\n", szGuid1, szGuid2);
       return FALSE;
    }

    if ((If1.Mvipc) != (If2.Mvipc)) {
       WCHAR  szGuid1[100], szGuid2[100];
       
       StringFromGUID(If1.Mvipc, szGuid1);
       StringFromGUID(If2.Mvipc, szGuid2);
       printf("Mvipc not matching\n\t%S\n\t%S\n", szGuid1, szGuid2);
       return FALSE;
    }
*/

    if (If1.dwVersionHi != If2.dwVersionHi) {
       printf("dwVersionHi not matching 0x%x & 0x%x\n", If1.dwVersionHi, If2.dwVersionHi);
       return FALSE;
    }

    if (If1.dwVersionLo != If2.dwVersionLo) {
       printf("dwVersionLo not matching 0x%x & 0x%x\n", If1.dwVersionLo, If2.dwVersionLo);
       return FALSE;
    }

    if (If1.cUpgrades != If2.cUpgrades) {
       printf("cUpgrades not matching 0x%x & 0x%x\n", If1.cUpgrades, If2.cUpgrades);
       return FALSE;
    }

    
    int i;
    for (i = 0; i < (int)(If1.cUpgrades); i++) {
        DWORD posn1=0, posn2=0;

        posn1 = ArrayCompare((If1.prgUpgradeScript), (If2.prgUpgradeScript)[i], (If1.cUpgrades));
        posn2 = ArrayCompare((If1.prgUpgradeFlag), (If2.prgUpgradeFlag)[i], (If1.cUpgrades));
        
        if ((posn1 == 0) || (posn1 != posn2))
            return FALSE;
    }

    if (If1.cScriptLen != If2.cScriptLen) {
       printf("cScriptLen not matching 0x%x & 0x%x\n", If1.cScriptLen, If2.cScriptLen);
       return FALSE;
    }

    return TRUE;
}

BOOL Compare(PLATFORMINFO Pf1, PLATFORMINFO Pf2)
{
    UINT i = 0;

    if (Pf1.cPlatforms != Pf2.cPlatforms)
       return FALSE;

    for (i = 0; i < (int)(Pf1.cPlatforms); i++)
        if (!ArrayCompare(Pf1.prgPlatform, Pf2.prgPlatform[i], Pf1.cPlatforms))
            return FALSE;

    if (Pf1.cLocales != Pf2.cLocales)
        return FALSE;

    for (i = 0; i < (int)(Pf1.cLocales); i++)
        if (!ArrayCompare(Pf1.prgLocale, Pf2.prgLocale[i], (Pf1.cLocales)))
            return FALSE;

    return TRUE;
}

BOOL Compare(PACKAGEDETAIL Pd1, PACKAGEDETAIL Pd2)
{
    UINT i = 0;
    VerbosePrint("Verify!! Package Name <<%S>> \n", Pd1.pszPackageName);

    if (Pd1.cSources != Pd2.cSources)
        return FALSE;

    for (i = 0; i < (int)(Pd1.cSources); i++)
        if (!ArrayCompare(Pd1.pszSourceList, Pd2.pszSourceList[i], (Pd1.cSources)))
            return FALSE;

    if (Pd1.cCategories != Pd2.cCategories)
        return FALSE;

    for (i = 0; i < (int)(Pd1.cCategories); i++)
        if (!ArrayCompare(Pd1.rpCategory, Pd2.rpCategory[i], (Pd1.cCategories)))
            return FALSE;

    if ((Pd1.pActInfo != Pd2.pActInfo) && (!Compare(*Pd1.pActInfo, *Pd2.pActInfo)))
        return FALSE;

    if (!Compare(*Pd1.pPlatformInfo, *Pd2.pPlatformInfo))
        return FALSE;

    if (!Compare(*Pd1.pInstallInfo, *Pd2.pInstallInfo))
        return FALSE;

    return TRUE;

}

BOOL Compare(PACKAGEDISPINFO Pi1, PACKAGEDISPINFO Pi2)
{
    if (wcscmp(Pi1.pszPackageName, Pi2.pszPackageName) != 0)
        return FALSE;

    if (Pi1.dwActFlags != Pi2.dwActFlags)
        return FALSE;

    if (Pi1.PathType != Pi2.PathType)
        return FALSE;

    if (wcscmp(Pi1.pszScriptPath, Pi2.pszScriptPath) != 0)
        return FALSE;

    if (Pi1.cScriptLen != Pi2.cScriptLen)
        return FALSE;

/*    WCHAR pStoreUsn[20];
    SYSTEMTIME SystemTime;

    FileTimeToSystemTme((FILETIME *)&(Pi1.Usn), &SystemTime); 
    wsprintf (pStoreUsn, L"%4d%2d%2d%2d%2d%2d",
           SystemTime.wYear,
           SystemTime.wMonth,
           SystemTime.wDay,
           SystemTime.wHour,
           SystemTime.wMinute,
           SystemTime.wSecond);
   
    VerbosePrint(L"VERIFY!!! Last modification time for Package Time %s\n", pStoreUsn);
*/

    if (Pi1.dwVersionHi != Pi2.dwVersionHi)
        return FALSE;

    if (Pi1.dwVersionLo != Pi2.dwVersionLo)
        return FALSE;

    if (Pi1.cUpgrades != Pi2.cUpgrades)
        return FALSE;
    
    int i;
    for (i = 0; i < (int)(Pi1.cUpgrades); i++) {
        DWORD posn1=0, posn2=0;

        posn1 = ArrayCompare((Pi1.prgUpgradeScript), (Pi2.prgUpgradeScript)[i], (Pi1.cUpgrades));
        posn2 = ArrayCompare((Pi1.prgUpgradeFlag), (Pi2.prgUpgradeFlag)[i], (Pi1.cUpgrades));
        
        if ((posn1 == 0) || (posn1 != posn2))
            return FALSE;
    }

    return TRUE;
}

BOOL Compare(CATEGORYINFO ci1, CATEGORYINFO ci2)
{
    return ((ci1.catid == ci2.catid) && (ci1.lcid == ci2.lcid) && 
        (wcscmp(ci1.szDescription, ci2.szDescription) == 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csdrt\csdrtprf.cxx ===
// csdrtprf.cxx
#include "csdrt.hxx"
extern BOOL fVerbose;
extern BOOL fMultiStore;
extern IClassAccess    *pIClassAccess;
extern IClassAdmin     *pIClassAdmin;
extern IClassAdmin     *pIClassAdmin2;

extern WCHAR           szClassStorePath [_MAX_PATH+1];

extern WCHAR           szContainer [_MAX_PATH+1];
extern WCHAR           szContainer2 [_MAX_PATH+1];
extern WCHAR           szNewContainer [_MAX_PATH+1];
        
extern UINT            cLoops;
extern UINT            cCase;
extern GUID TestClsid1, TestClsid2, TestClsid3, TestClsid4, TestClsid5;
extern Sname TestFileExt1, TestFileExt4, TestMimeType2;
extern Sname TestOtherProgID2, TestProgId1, TestProgId3;

HRESULT AddRandomPackage(PACKAGEDETAIL &packagedetail, int i);
void InitTempNames();
/*
RunATest()
{

    PACKAGEINFO PackageInfo;
    HRESULT hr, hr2;

    switch(cCase)
    {
//FileExt1
    case 1:
        hr = LookupByFileext (TestFileExt1, &PackageInfo);
        if (SUCCEEDED(hr))
        {
        // Check expected values
        //
            AssertPackage1By1(&PackageInfo);
        }
        break;

//Clsid1
    case 2:
        hr2 = LookupByClsid (TestClsid1, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            // Check expected values
            //
            AssertPackage1By1(&PackageInfo);
        }
        else
            hr = hr2;
        break;

//ProgId1
    case 3:
        hr2 = LookupByProgid (TestProgId1, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage1By1(&PackageInfo);
        }
        else
            hr = hr2;
        break;

// MimeType2
    case 4:
        hr2 = LookupByMimeType (TestMimeType2, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage1By2(&PackageInfo);
        }
        else
            hr = hr2;
        break;


//Clsid2
    case 5:
        hr2 = LookupByClsid (TestClsid2, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage1By2(&PackageInfo);
        }
        else
            hr = hr2;
        break;

//ProgId3
    case 6:
        hr2 = LookupByProgid (TestProgId3, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage2(&PackageInfo);
        }
        else
            hr = hr2;
        break;

//TestOtherProgID2
    case 7:
        hr2 = LookupByProgid (TestOtherProgID2, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage1By1(&PackageInfo);
        }
        else
            hr = hr2;
        break;

//FileExt4
    case 8:
        hr = LookupByFileext (TestFileExt4, &PackageInfo);
        if (SUCCEEDED(hr))
        {
            // Check expected values
            //  
            AssertPackage4(&PackageInfo);
        }
        break;

// Clsid4
// Should get two packages now !!
    case 9:
        hr2 = LookupByClsid (TestClsid4, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage4(&PackageInfo);
        }
        else
            hr = hr2;
        break;
    
// Tlbid1
    case 10:

        hr2 = LookupByTlbid (TestClsid1, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage4(&PackageInfo);
        }
        else
            hr = hr2;
        break;

// Tlbid2
    case 11:

        hr2 = LookupByTlbid (TestClsid2, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            //AssertPackage5(&PackageInfo);
        }
        else
            hr = hr2;
        break;

// Clsid5
    case 12:
        hr2 = LookupByClsid (TestClsid5, &PackageInfo);
        if (SUCCEEDED(hr2))
        {
            //
            // Check expected values
            //
            AssertPackage6(&PackageInfo);
        }
        else
            hr = hr2;
        break;
    default:
        printf("Not yet implemented\n");
        break;
    }
    return hr;
}



void RunPerfTests()
{
    DWORD   time1, time2, time3, time4;

    hr = GetClassAdmin (szContainer, &pIClassAdmin);
    if (FAILED(hr))
        return;

    hr = DoAdminTest(&cCount, &cPkgCount);
    if (FAILED(hr))
        return;

    // Populating class store.

    if (!cLoop)
        return;

    VerbosePrint("Started timing\n");

    // take the time time1.
    time1 = GetTickCount();

    hr = GetClassAccess ();
    if (FAILED(hr))
        return;

    // Get the interface pointers, depending on the test.

    RunATest();

    // take the time time2.
    time2 = GetTickCount();

    for (i = 0; i < (cLoops-1); i++)
    {
        RunATest();
    }

    // take the time time3
    time3 = GetTickCount();

    // Release the interface pointers.

    // take the time time4
    time4 = GetTickCount();

    printf("Time1\tTime2\tTime3\tTime4\n");
    printf("-----\t-----\t-----\t-----\n\n");
    printf("%d\t%d\t%d\t%d\n", time1, time2, time3 time4);
    // print the times.

    // Parameter based cleanup.
}

*/



HRESULT AddRandomUnassignedPackages(int i)
{
    PACKAGEDETAIL PackageDetail;
    memset(&PackageDetail, 0, sizeof(PACKAGEDETAIL));

    PackageDetail.pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
    memset (PackageDetail.pInstallInfo, 0, sizeof(INSTALLINFO));

    PackageDetail.pPlatformInfo = (PLATFORMINFO *) CoTaskMemAlloc (sizeof(PLATFORMINFO));
    memset (PackageDetail.pPlatformInfo, 0, sizeof(PLATFORMINFO));

    PackageDetail.pActInfo = (ACTIVATIONINFO *) CoTaskMemAlloc (sizeof(ACTIVATIONINFO));
    memset (PackageDetail.pActInfo, 0, sizeof(ACTIVATIONINFO));

    PackageDetail.pInstallInfo->dwActFlags = 
       ACTFLG_Published +               // Published
       ACTFLG_UserInstall +             // Visible
       ACTFLG_OnDemandInstall;          // AutoInstall
   return AddRandomPackage(PackageDetail, i);
}


HRESULT AddRandomAssignedPackages(int i)
{
   PACKAGEDETAIL PackageDetail;
   memset(&PackageDetail, 0, sizeof(PACKAGEDETAIL));

   PackageDetail.pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
   memset (PackageDetail.pInstallInfo, 0, sizeof(INSTALLINFO));

   PackageDetail.pPlatformInfo = (PLATFORMINFO *) CoTaskMemAlloc (sizeof(PLATFORMINFO));
   memset (PackageDetail.pPlatformInfo, 0, sizeof(PLATFORMINFO));

   PackageDetail.pActInfo = (ACTIVATIONINFO *) CoTaskMemAlloc (sizeof(ACTIVATIONINFO));
   memset (PackageDetail.pActInfo, 0, sizeof(ACTIVATIONINFO));

   PackageDetail.pInstallInfo->dwActFlags = 
       ACTFLG_Assigned +                // Assigned
       ACTFLG_UserInstall +             // Visible
       ACTFLG_OnDemandInstall;          // AutoInstall

   return AddRandomPackage(PackageDetail, i);
}




HRESULT DoLogonPerfTest(BOOL fInitialize)
{
    UINT            i = 0, j = 0;
    PACKAGEDISPINFO PackageInfo[30];
    IEnumPackage   *pIEnumPackage = NULL;
    HRESULT         hr = S_OK;
    DWORD           cgot = 0;
    DWORD           tc1, tc2, tc3, tc4, tc5, tc6, tc;
    
    if (fInitialize) 
    {
        InitTempNames();

        // add 500 random packages
        for (i = 0; i < 500; i++) 
        {
            hr = AddRandomUnassignedPackages(i);
            if (FAILED(hr))
                return hr;
        }
        
        VerbosePrint("Added 500 unassigned apps\n");
        // add 5 known packages that are assigned.
        for (i = 0; i < 5; i++)
        {
            hr = AddRandomAssignedPackages(i+500);
            if (FAILED(hr))
                return hr;
        }

        VerbosePrint("Added 5 Assigned Apps\n");
        
        pIClassAdmin->Release();

    }

    // Lookup for assigned packages using
    // CoEnumAppInfo

    tc = GetTickCount();

    cLoops = 1;
    for (i = 0; i < (int)cLoops; i++)
    {
        tc1 = GetTickCount();

        hr = CsEnumApps(
                    NULL,
                    NULL,
                    NULL,
                    APPINFO_ASSIGNED | APPINFO_MSI,
                    &pIEnumPackage
                    );

        tc2 = GetTickCount();
        printf("CsEnumApps: Time=%d MilliSec\n", tc2 - tc1);

        if (FAILED(hr)) {
            printf("CsEnumApps returned hr = 0x%x\n", hr);
            return hr;
        }

/*
        for (j = 0; j < 5; j++)
        {
            tc3 = GetTickCount();

            hr = pIEnumPackage->Next(1, PackageInfo, &cgot); 
            if (hr != S_OK) {
                printf("Next %d returned hr = 0x%x\n", j+1, hr);
                return hr;
            }

            tc4 = GetTickCount();
            printf("Next %d\n", tc4 - tc3);
        }
*/
        hr = pIEnumPackage->Next(20, PackageInfo, &cgot); 
        tc5 = GetTickCount();
//        printf("Last Next %d\n", tc5 - tc4);
        printf("Browsing: Time = %d MilliSec, # of assigned apps = %d\n", 
            tc5 - tc2, cgot);

        if (fVerbose)
        for (j = 0; j < cgot; j++)
        {
            PrintPackageInfo(&PackageInfo[j]);
        }

        printf("Next(%d) returned hr = 0x%x\n", 20, hr);



//        if (i%10 == 0)
//            VerbosePrint(".");

//        if (i % 100 == 0)
//            VerbosePrint("\n");

        pIEnumPackage->Release();
        tc6 = GetTickCount();
        printf("Release %d\n", tc6 - tc5);

    }

    printf ("End of Class Store Stress for %d passes (%d MilliSec Per Loop).\n",
        cLoops,
        (GetTickCount() - tc)/cLoops);

    return S_OK;
    // measure the time taken.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csdrt\csdrtcat.cxx ===
// csdrtcat.cxx

// This runs the following tests.
// Adds two classes catclsid1, catclsid2

// adds 3 categories
//      1 with 1 desc and locale id.
//      2 with 2 desc and locale id.
//      3 without 1 desc and locale id 2.
//
// register 2 categories in the req. list for catclsid1. (cat1, cat2)
// register 1 impl category in the impl list for catclsid1 (cat3)
//
// register 2 in the the impl for the catclsid2.(cat2, cat3)
//
// unregister 1 cat frm the req list for catclsid1 (cat2)
// register that one for impl list of catclsid1 (cat2)
//
//
// Info tests confirmations as well as tests.
//
// Enumcat result should be two. Match descriptions.
// EnumImplCategories of clsid1 should be 2. (cat2, cat3)
// EnumReqCategories of clsid2 should be zero.
//
// Enumclasses of categories with (req: cat1, cat3) (impl: cat2) should be two.
//
// GetCategoryDesc with the other locale id than the one used in EnumCat. cat2
//                 with any locale id cat3.
//
// IsClassOfCategories clsid1 impl cat2, req: cat1 answer should be S_OK
//
//

#include "csdrt.hxx"
extern BOOL fVerbose;

GUID catClsid1;
GUID catClsid2;
GUID testCatid1;
GUID testCatid2;
GUID testCatid3;

Sname testCatDesc1, testCatDesc2, testCatDesc21, testCatDesc3, TestCatClassDesc1, TestCatClassDesc2;
Sname testCatPackName1, testCatPackName2;
LCID TestCatLocale1, TestCatLocale2;

LPOLESTR testConstCatDesc1 = L"CS DRT Test Category Desc, 1 (Locale same as Thread)";
LPOLESTR testConstCatDesc2 = L"CS DRT Test Category Desc, 2 (Locale same as Thread)";
LPOLESTR testConstCatDesc21 = L"CS DRT Test Category Desc, 2 (Locale = Thread Locale + 1)";
LPOLESTR testConstCatDesc3 = L"CS DRT Test Category Desc, 3 (Locale = Thread Locale + 1)";

LPOLESTR testConstCatClassDesc1 = L"CS DRT Class id 1 for comcat test";
LPOLESTR testConstCatClassDesc2 = L"CS DRT Class id 2 for comcat test";

LPOLESTR testConstCatPackName1 = L"CS DRT Test Comcat Pack 1";
LPOLESTR testConstCatPackName2 = L"CS DRT Test Comcat Pack 2";


void InitCatTempNames()
{
   CreateGuid(&catClsid1);
   CreateGuid(&catClsid2);

   CreateGuid(&testCatid1);
   CreateGuid(&testCatid2);
   CreateGuid(&testCatid3);

   CreateUnique(testCatDesc1, testConstCatDesc1);
   CreateUnique(testCatDesc2, testConstCatDesc2);
   CreateUnique(testCatDesc21, testConstCatDesc21);
   CreateUnique(testCatDesc3, testConstCatDesc3);

   CreateUnique(TestCatClassDesc1, testConstCatClassDesc1);
   CreateUnique(TestCatClassDesc2, testConstCatClassDesc2);

   TestCatLocale1 = GetThreadLocale();
   TestCatLocale2 = 2*TestCatLocale1 + 1;

   CreateUnique(testCatPackName1, testConstCatPackName1);
   CreateUnique(testCatPackName2, testConstCatPackName2);
}

void ReleaseObj(GUID obj)
{
}

void ReleaseObj(CATEGORYINFO obj)
{
}


HRESULT CreateCatClasses(IClassAdmin *pIClassAdmin1, IClassAdmin *pIClassAdmin2)
{
//    CLASSDETAIL         ClassDetail;
//    PACKAGEDETAIL       PackageDetail;
    HRESULT             hr = S_OK;

    // adding classes--------------------------------

    InitCatTempNames();

//    memset (&ClassDetail, NULL, sizeof (CLASSDETAIL));
//    memcpy (&ClassDetail.Clsid, &catClsid1, sizeof (GUID));
//
//    memset(&PackageDetail, 0, sizeof(PACKAGEDETAIL));
//    PackageDetail.pActInfo->cClasses = 1;
//    PackageDetail.pActInfo->pClasses = (CLASSDETAIL *)CoTaskMemAlloc(sizeof(CLASSDETAIL));
//    PackageDetail.pActInfo->pClasses[0] = ClassDetail;
//
//    hr = pIClassAdmin1->AddPackage(testCatPackName1, &PackageDetail);
//    if (!SUCCEEDED(hr))
//    {
//        printf ("ERROR! 1. NewPackage() in CatTest returned 0x%x.\n", hr);
//        return hr;
//    }
//
//    PackageDetail.pActInfo->pClasses[0].Clsid = catClsid2;
//
//    if (pIClassAdmin2)
//       hr = pIClassAdmin2->AddPackage(testCatPackName2, &PackageDetail);
//    else
//       hr = pIClassAdmin1->AddPackage(testCatPackName2, &PackageDetail);
//
//    if (!SUCCEEDED(hr))
//    {
//        printf ("ERROR! 2. NewPackage() in CatTest returned 0x%x.\n", hr);
//        return hr;
//    }
    return hr;
}


HRESULT RegCategories(ICatRegister *pICatRegister1, ICatRegister *pICatRegister2)
{
    HRESULT             hr;
    CATEGORYINFO        CategoryInfo;

    // adding categories---------------------------

    memset (&CategoryInfo, NULL, sizeof (CATEGORYINFO));
    memcpy(&CategoryInfo.catid, &testCatid1, sizeof(GUID));
    CategoryInfo.lcid = TestCatLocale1;
    wcscpy(CategoryInfo.szDescription, testCatDesc1);

    hr = pICatRegister1->RegisterCategories(1, &CategoryInfo);
    if (FAILED(hr))
    {
        printf("Error! 1. RegisterCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }

    memset (&CategoryInfo, NULL, sizeof (CATEGORYINFO));
    memcpy(&CategoryInfo.catid, &testCatid2, sizeof(GUID));
    CategoryInfo.lcid = TestCatLocale1;
    wcscpy(CategoryInfo.szDescription, testCatDesc2);

    hr = pICatRegister1->RegisterCategories(1, &CategoryInfo);
    if (FAILED(hr))
    {
        printf("Error! 2. RegisterCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }

    memset (&CategoryInfo, NULL, sizeof (CATEGORYINFO));
    memcpy(&CategoryInfo.catid, &testCatid2, sizeof(GUID));
    CategoryInfo.lcid = TestCatLocale2;
    wcscpy(CategoryInfo.szDescription, testCatDesc21);

    hr = pICatRegister1->RegisterCategories(1, &CategoryInfo);
    if (FAILED(hr))
    {
        printf("Error! 3. RegisterCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }


    memset (&CategoryInfo, NULL, sizeof (CATEGORYINFO));
    memcpy(&CategoryInfo.catid, &testCatid3, sizeof(GUID));
    CategoryInfo.lcid = TestCatLocale2;
    wcscpy(CategoryInfo.szDescription, testCatDesc3);

    if (pICatRegister2)
       hr = pICatRegister2->RegisterCategories(1, &CategoryInfo);
    else
       hr = pICatRegister1->RegisterCategories(1, &CategoryInfo);

    if (FAILED(hr))
    {
        printf("Error! 4. RegisterCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }
    return hr;
}

HRESULT RegCategoriesWithClasses(ICatRegister *pICatRegister1,
                 ICatRegister *pICatRegister2)
{
    GUID                guids[4];
    HRESULT             hr=S_OK;
    // registering implemented and required categories.--------------

    guids[0] = testCatid1;
    guids[1] = testCatid2;
    hr = pICatRegister1->RegisterClassReqCategories(catClsid1, 2, guids);
    if (FAILED(hr))
    {
        printf("Error! 1. RegisterClassReqCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }

    hr = pICatRegister1->RegisterClassImplCategories(catClsid1, 1, &testCatid3);
    if (FAILED(hr))
    {
        printf("Error! 1. RegisterClassImplCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }


    guids[0] = testCatid2;
    guids[1] = testCatid3;
    if (pICatRegister2)
       hr = pICatRegister2->RegisterClassImplCategories(catClsid2, 2, guids);
    else
       hr = pICatRegister1->RegisterClassImplCategories(catClsid2, 2, guids);

    if (FAILED(hr))
    {
        printf("Error! 2. RegisterClassImplCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }

    hr = pICatRegister1->UnRegisterClassReqCategories(catClsid1, 1, &testCatid2);
    if (FAILED(hr))
    {
        printf("Error! 1. UnRegisterClassReqCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }

    hr = pICatRegister1->RegisterClassImplCategories(catClsid1, 1, &testCatid2);
    if (FAILED(hr))
    {
        printf("Error! 1. RegisterClassImplCategories in CatTest returned 0x%x.\n", hr);
        return hr;
    }
    return hr;
}
void VerbosePrintObj(CATEGORYINFO catinfo)
{
   VerbosePrint("Description %S\n", catinfo.szDescription);
}

void VerbosePrintObj(GUID guid)
{

}

HRESULT DoEnumCatsOfClassesTest(ICatInformation *pICatInformation)
{
        HRESULT             hr=S_OK;
    IEnumGUID           *pIEnumGUID = NULL;
    GUID                guids[4];
    LPOLESTR            szDesc;
    ULONG               got;

    // Enumerating Implemented Categories-------------------------

    hr = pICatInformation->EnumImplCategoriesOfClass(catClsid1, &pIEnumGUID);
    if (FAILED(hr))
    {
        printf("Error! EnumImplCategoriesOfClass in CatTest returned 0x%x\n", hr);
        return hr;
    }

    hr = EnumTests<IEnumGUID, GUID>(pIEnumGUID, 2, NULL, 0, 0, FALSE);

    // Enumerating Required Categories-------------------------

    hr = pICatInformation->EnumReqCategoriesOfClass(catClsid1, &pIEnumGUID);
    if (FAILED(hr))
    {
        printf("Error! EnumImplCategoriesOfClass in CatTest returned 0x%x\n", hr);
        return hr;
    }

    if (FAILED(hr))
    {
        printf("Error! EnumReqCategoriesOfClass in CatTest returned 0x%x\n", hr);
        return hr;
    }

    hr = EnumTests<IEnumGUID, GUID>(pIEnumGUID, 1, NULL, 0, 0, FALSE);
    return hr;
}


HRESULT DoEnumClassesOfCats(ICatInformation *pICatInformation)
{
    HRESULT             hr=S_OK;
    IEnumGUID           *pIEnumGUID = NULL;
    GUID                guids[4];
    ULONG               got;

    // Enumerating classes of categories--------------------------------
    guids[0] = testCatid1;
    guids[1] = testCatid3;
    hr = pICatInformation->EnumClassesOfCategories(1, &testCatid2, 2, guids, &pIEnumGUID);
    if (FAILED(hr))
    {
        printf("Error! EnumClassesOfCategories in CatTest returned 0x%x\n", hr);
        return hr;
    }

        EnumTests<IEnumGUID, GUID>(pIEnumGUID, 2, NULL, 0, 0, FALSE);
    return hr;
}

HRESULT CatCleanup(ICatRegister *pICatRegister1, ICatRegister *pICatRegister2)
{
    HRESULT hr;
    // Removing the categories at the end of the test.-----------------

    hr = pICatRegister1->UnRegisterCategories(1, &testCatid1);
    if (FAILED(hr))
        printf ("ERROR! 1. UnRegisterCategories() in CatTest returned 0x%x.\n", hr);

    hr = pICatRegister1->UnRegisterCategories(1, &testCatid2);
    if (FAILED(hr))
        printf ("ERROR! 2. UnRegisterCategories() in CatTest returned 0x%x.\n", hr);

    if (pICatRegister2)
       hr = pICatRegister2->UnRegisterCategories(1, &testCatid3);
    else
       hr = pICatRegister1->UnRegisterCategories(1, &testCatid3);

    if (FAILED(hr))
        printf ("ERROR! 3. UnRegisterCategories() in CatTest returned 0x%x.\n", hr);
    return hr;
}

HRESULT CatClassCleanup(IClassAdmin *pIClassAdmin1, IClassAdmin *pIClassAdmin2)
{
    HRESULT hr;

    // Removing the classes and at the end of the test.--------------
//    hr = pIClassAdmin1->RemovePackage(testCatPackName1, 0);
//    if (FAILED(hr))
//        printf ("ERROR! 1. RemovePackage() in CatTest returned 0x%x.\n", hr);

    if (pIClassAdmin2)
       hr = pIClassAdmin2->RemovePackage(testCatPackName2, 0);
    else
       hr = pIClassAdmin1->RemovePackage(testCatPackName2, 0);

    if (FAILED(hr))
        printf ("ERROR! 2. RemovePackage() in CatTest returned 0x%x.\n", hr);

    return hr;
}

HRESULT DoCatTests(IClassAdmin *pIClassAdmin1, IClassAdmin *pIClassAdmin2)
{
    HRESULT             hr=S_OK, hr1=S_OK;
    CATEGORYINFO            CategoryInfo;
    ICatRegister               *pICatRegister1=NULL, *pICatRegister2=NULL;
    ICatInformation            *pICatInformation = NULL;
    IEnumGUID              *pIEnumGUID = NULL;
    GUID                guids[4];
    LPOLESTR            szDesc;
    ULONG               expected, got=0;
    IEnumCATEGORYINFO          *pIEnumCATEGORYINFO = NULL;

    VerbosePrint("Creating classes for category test\n\n");
    hr = CreateCatClasses(pIClassAdmin1, pIClassAdmin2);
    if (FAILED(hr))
        goto ReleaseAll;

    //getting Icatregister interface--------------

    hr = pIClassAdmin1->QueryInterface(IID_ICatRegister, (void **)&pICatRegister1);
    if (FAILED(hr))
    {
         printf("Error! QueryInterface failed for ICatRegister in CatTest returned 0x%x.\n", hr);
         goto ReleaseAll;
    }


    if (pIClassAdmin2)
         hr = pIClassAdmin2->QueryInterface(IID_ICatRegister, (void **)&pICatRegister2);
    if (FAILED(hr))
    {
         printf("Error! QueryInterface failed for ICatRegister in CatTest returned 0x%x.\n", hr);
         goto ReleaseAll;
    }

    // getting the ICatInformation pointer

        hr = CoCreateInstance(CLSID_GblComponentCategoriesMgr, NULL, CLSCTX_INPROC,
                         IID_ICatInformation, (void **)&pICatInformation);
    if (FAILED(hr))
    {
       printf("**Error! QueryInterface failed for ICatInformation in comcat returned 0x%x.\n", hr);
       goto ReleaseAll;
    }

    VerbosePrint("\nEnumerating Categories for category test before registering\n\n");
    hr = pICatInformation->EnumCategories(TestCatLocale1, &pIEnumCATEGORYINFO);
    if (FAILED(hr)) {
       printf("**Error! EnumCategories failed for ICatInformation in comcat returned 0x%x.\n", hr);
       goto ReleaseAll;
    }

    hr = EnumTests<IEnumCATEGORYINFO, CATEGORYINFO>(pIEnumCATEGORYINFO, 0, &got, 0, 0, FALSE);

    if (FAILED(hr))
        goto ReleaseAll;

    VerbosePrint("\nRegistering Categories for category test\n\n");
    hr = RegCategories(pICatRegister1, pICatRegister2);
    if (FAILED(hr))
        goto ReleaseAll;

    VerbosePrint("\nRegistering Categories with classes for category test\n\n");
    hr = RegCategoriesWithClasses(pICatRegister1, pICatRegister2);
    if (FAILED(hr))
        goto ReleaseAll;


    VerbosePrint("\nEnumerating Categories for category test after registering\n\n");
    hr = pICatInformation->EnumCategories(TestCatLocale1, &pIEnumCATEGORYINFO);
    if (FAILED(hr)) {
       printf("**Error! EnumCategories failed for ICatInformation in comcat returned 0x%x.\n", hr);
       goto ReleaseAll;

    }

    hr = EnumTests<IEnumCATEGORYINFO, CATEGORYINFO>(pIEnumCATEGORYINFO, got+3, NULL, 0, 0, FALSE);
    if (FAILED(hr))
        goto ReleaseAll;

    VerbosePrint("\nEnumerating Categories of the classes for category test\n\n");
    hr = DoEnumCatsOfClassesTest(pICatInformation);
    if (FAILED(hr))
        goto ReleaseAll;

    VerbosePrint("\nEnumerating Classes of the categories for category test\n\n");

    hr = DoEnumClassesOfCats(pICatInformation);
    if (FAILED(hr))
        goto ReleaseAll;


    VerbosePrint("\nTesting IsClassOfCategories for category test\n\n");

    hr = pICatInformation->IsClassOfCategories(catClsid1, 1, &testCatid2, -1, NULL); // 1, &testCatid1);
    if (hr != S_OK)
    {
        printf("Error! IsClassOfCategories in CatTest returned 0x%x\n", hr);
        goto ReleaseAll;
    }

    // GetCategoryDesc------------------

    VerbosePrint("\nCalling GetCategoryDesc for category test\n\n");

    hr = pICatInformation->GetCategoryDesc(testCatid2, TestCatLocale2, &szDesc);
    if (FAILED(hr))
    {
        printf("Error!1.  GetCategoryDesc in CatTest returned 0x%x\n", hr);
        goto ReleaseAll;
    }

    if (wcscmp(szDesc, testCatDesc21) != 0)
    {
        printf("Description not matching, Expected: \"%s\", got \"%s\"\n");
        goto ReleaseAll;
    }

    CoTaskMemFree(szDesc);

    hr = pICatInformation->GetCategoryDesc(testCatid3, TestCatLocale2, &szDesc);
    if (FAILED(hr))
    {
        printf("Error!2.  GetCategoryDesc in CatTest returned 0x%x\n", hr);
        goto ReleaseAll;
    }

    if (wcscmp(szDesc, testCatDesc3) != 0)
    {
        printf("Error!3. Description not matching, Expected: \"%s\", got \"%s\"\n");
        goto ReleaseAll;
    }

    CoTaskMemFree(szDesc);

    VerbosePrint("\nCleaning up the classes and the categories for category test\n\n");

ReleaseAll:
    CatCleanup(pICatRegister1, pICatRegister2);
    CatClassCleanup(pIClassAdmin1, pIClassAdmin2);

    if (pICatRegister1)
        pICatRegister1->Release();

    if (pICatRegister2)
            pICatRegister2->Release();

    if (pICatInformation)
        pICatInformation->Release();
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csdrt\csdrt.cxx ===
//
//  Author: DebiM
//  Date:   March 97
//  File:   csdrt.cxx
//
//      Class Store DRTs
//
//      This is the main source file
//      The related files are csdrtad.cxx and csdrtgc.cxx
//
//      Current DRTs test:
//          CClassContainer::IClassAdmin
//          CClassAccess::IClassAccess
//
//
//      It tests the following Class Store functionality
//
//         Admin Interfaces
//         Browse Interfaces
//         GetAppInfo()
//         Tests with multiple class stores
//
//
//      To be extended to do:
//         2. ACL tests
//         3. Tests for error scenarios
//         4. More comprehensive
//              - large no. of CLSIDs per Package
//
//---------------------------------------------------------------------

#include "csdrt.hxx"

BOOL    fBrowseTest;
BOOL    fVerbose;
BOOL    fAdminTest;
BOOL    fClassInfoTest;
BOOL    fClassInfoVerify;
BOOL    fComprehensive;
BOOL    fEmptyTest;
BOOL    fRemoveTest;
BOOL    fDllTest;
BOOL    fStress;
BOOL    fRefreshTest;
BOOL    fMultiStore;
BOOL	fCatTest;

BOOL    fLogonPerf = FALSE;
BOOL    fLogonPerfInitialize = FALSE;
BOOL    fOverwritePath = FALSE;
BOOL    fLogon = FALSE;

IClassAccess    *pIClassAccess = NULL;
IClassAdmin     *pIClassAdmin = NULL;
IClassAdmin     *pIClassAdmin2 = NULL;

WCHAR           szClassStorePath [2000+1];

WCHAR           szContainer [2000+1];
WCHAR           szContainer2 [2000+1];
WCHAR           szNewContainer [2000+1];
WCHAR           szLookupPackageName [_MAX_PATH];
WCHAR           szUserName[_MAX_PATH];
WCHAR           szPassword[_MAX_PATH];

LPOLESTR        pszDomain, pszUser;

UINT            cLoops = 100;
STDAPI_(void) UpdateClassStoreSettings(WCHAR *pwszNewPath);

GUID NULLGUID =
{ 0x00000000, 0x0000, 0x0000,
{ 0x00, 0x00, 0x0, 0x00, 0x0, 0x00, 0x00, 0x00 }
};

void Usage()
{
    printf ("Usage is\n");
    printf ("     csdrt [-p<containerpath>] [-v] [-a] [-b] [-g] [-o]\n");
    printf ("  OR csdrt [-p<containerpath>] [-v] -e\n");
    printf ("  OR csdrt [-p<containerpath>] [-v] -c\n");
    printf ("  OR csdrt [-p<containerpath>] [-v] -s [-b] [-l<loop count>] \n");
    printf ("  OR csdrt [-p<containerpath>] [-m[<containerpath>]] [-v] -s [-b] [-l<loop count>] \n");
    printf ("     where:\n");
    printf ("       <containerpath> is a DNS pathname for a Class container.\n");
    printf ("                       if absent defaults to env var DRT_CLASSSTORE.\n");
    printf ("       -v : Verbose.\n");
    printf ("       -a : Test IClassAdmin functionality.\n");
    printf ("       -b : Test Browse functionality - IEnumPackage.\n");
    printf ("       -q : Test Comcat functionality \n");
    printf ("       -g : Test GetPackageInfo(). -gV for verification. Class store has to be clean before this\n");
    printf ("       -r : Test IClassRefresh.\n");
    printf ("       -d : Test entry points in csadm.dll.\n");
    printf ("       -f : perf tests for IClassAccess. \n");
    printf ("       -t : Perf for logon procedure. Add I if it has to be initialized. have to be run alone\n");
    printf ("       -e : Empty the Class Store\n");
    printf ("       -c : A complete test of functionality.\n");
    printf ("       -m : Run Multi Class Store Tests. Needs env var DRT_CLASSSTORE2. \n");
    printf ("       -s : Stress Test. Tests GetClassInfo and Optionally Browse. \n");
    printf ("       -l : Loop count for Stress Test. Default = 100. Number of packages\n");
    printf ("       -o : overwrite path \n");
    printf ("       -u : domain\\user. \n");
    printf ("       -w : password. \n");
}


HRESULT RunComprehensive()
{
    HRESULT hr;

    VerbosePrint ("Running Comprehensive Suite of Class Store DRTs.\n");
    fBrowseTest = fAdminTest = fRemoveTest = fClassInfoTest = fCatTest =
        fRefreshTest = TRUE;
    hr = RunTests();
    CleanUp();
    VerbosePrint ("End of Comprehensive Suite of Class Store DRTs.\n");
    return hr;
}


HRESULT RunStress()
{
    HRESULT hr;
    ULONG cCount, cPkgCount, cErrCount = 0, cPrevCount = 0;
    DWORD tc = GetTickCount();

    pIClassAccess = NULL;
    pIClassAdmin = NULL;
    pIClassAdmin2 = NULL;

    printf ("Started Class Store Stress for %d passes.\n", cLoops);

    for (UINT i=0; i < cLoops; ++i)
    {
        if (i%100 == 0)   // Before every hundredth time
        {
            //
            // Get an IClassAdmin interface pointer
            //
            hr = GetClassAdmin (szContainer, &pIClassAdmin);
            if (!SUCCEEDED(hr))
                return hr;
            //
            // Get an IClassAccess interface pointer
            //
            hr = GetClassAccess ();
            if (!SUCCEEDED(hr))
                return hr;

            hr = DoRemoveTest (&cPkgCount);

            hr = DoAdminTest(&cPkgCount);
            if (!SUCCEEDED(hr))
                ++cErrCount;
        }


        if (fBrowseTest)
        {
            hr = DoBrowseTest(pIClassAdmin);
            if (!SUCCEEDED(hr))
                ++cErrCount;
        }

        if (fClassInfoTest)
        {
            hr = DoClassInfoTest();
            if (!SUCCEEDED(hr))
                ++cErrCount;
        }


        if ((i+1)%10 == 0)   // After every Tenth time
        {
            //
            // Progress Indicator. If errors display a :( else display a :)
            //
            if (cErrCount > cPrevCount)
            {
                printf (":( ");
                cPrevCount = cErrCount;
            }
            else
                printf (":) ");
        }

        if ((i+1)%100 == 0)   // After every Hundredth time
        {
            //
            // Get rid of the interface pointers
            //
            CleanUp();
            //
            // Detail Progress indicator
            //
            printf ("\n ... %d Stress Passes Completed (with %d Errors).\n",
                i+1, cErrCount);
        }
    }

    printf ("End of Class Store Stress for %d passes (%d MilliSec Per Loop) (%d Errors).\n",
        cLoops,
        (GetTickCount() - tc)/cLoops,
        cErrCount);

    return S_OK;
}


HRESULT RunTests()
{
    HRESULT hr = S_OK;

    pIClassAccess = NULL;
    pIClassAdmin = NULL;
    pIClassAdmin2 = NULL;

    //
    // Depending on run parameters
    // invoke different tests
    //

    if (fBrowseTest || fAdminTest || fEmptyTest || fCatTest || fLogonPerfInitialize)
    {
        //
        // Get an IClassAdmin interface pointer
        //
        hr = GetClassAdmin (szContainer, &pIClassAdmin);
        if (!SUCCEEDED(hr))
            return hr;

        if (fMultiStore)
        {
            hr = GetClassAdmin (szContainer2, &pIClassAdmin2);
            if (!SUCCEEDED(hr))
                return hr;
        }
    }

    if (fEmptyTest)
    {

        VerbosePrint("... Empty Container Test Started.\n");
        hr = EmptyClassStore (pIClassAdmin);
        VerbosePrint("... Empty Container Test Ended.\n");

        if (pIClassAdmin2 != NULL)
        {
            VerbosePrint("... Empty Container Test on Second Class Store Started.\n");
            hr = EmptyClassStore(pIClassAdmin2);
            VerbosePrint("... Empty Container Test on Second Class Store Ended.\n");
        }
        if (SUCCEEDED(hr))
            printf ("PASSED ---- Empty Container Test Suite.\n");
        else
            printf ("FAILED ---- Empty Container Test Suite. hr = 0x%x.\n", hr);
    }

    if (fAdminTest)
    {
        ULONG cCount, cPkgCount;

        VerbosePrint("... Admin Test Started.\n");
        hr = DoAdminTest(&cPkgCount);
        VerbosePrint("... Admin Test Ended. (Added %d Packages).\n",
            cPkgCount);

        if (SUCCEEDED(hr))
            printf ("PASSED ---- Admin Test Suite.\n");
        else
            printf ("FAILED ---- Admin Test Suite. hr = 0x%x.\n", hr);
    }

    if (fCatTest)
    {
        ULONG cCount, cPkgCount;

        VerbosePrint("... Comcat Test Started.\n");
        hr = DoCatTests(pIClassAdmin, pIClassAdmin2);
        VerbosePrint("... Admin Test Ended. \n");

        if (SUCCEEDED(hr))
            printf ("PASSED ---- Comcat Test Suite.\n");
        else
            printf ("FAILED ---- Comcat Test Suite. hr = 0x%x.\n", hr);
    }

    if (fBrowseTest)
    {
        VerbosePrint("... Browse Test Started.\n");
        hr = DoBrowseTest(pIClassAdmin);
        VerbosePrint("... Browse Test Ended.\n");

        if (pIClassAdmin2 != NULL)
        {
            VerbosePrint("... Browse Test on Second Class Store Started.\n");
            hr = DoBrowseTest(pIClassAdmin2);
            VerbosePrint("... Browse Test on Second Class Store Ended.\n");
        }

        if (SUCCEEDED(hr))
            printf ("PASSED ---- Browse Test Suite.\n");
        else
            printf ("FAILED ---- Browse Test Suite. hr = 0x%x.\n", hr);
    }


    if (fClassInfoTest || fRefreshTest)
    {
        //
        // Get an IClassAccess interface pointer
        //
        hr = GetClassAccess ();
        if (!SUCCEEDED(hr))
            return hr;
    }

    if (fLogonPerf)
    {
        //
        // Measure the performance during a std. logon
        //

        hr = DoLogonPerfTest(fLogonPerfInitialize);

    }

    if (fRefreshTest)
    {
        VerbosePrint("... Refresh Test Started.\n");
        hr = RefreshTest ();
        VerbosePrint("... Refresh Test Ended.\n");
        if (SUCCEEDED(hr))
            printf ("PASSED ---- Refresh Test Suite.\n");
        else
            printf ("FAILED ---- Refresh Test Suite. hr = 0x%x.\n", hr);
    }

    if (fClassInfoTest)
    {
        VerbosePrint("... CoEnumApps Test Started.\n");
        hr = DoCoEnumAppsTest();
        VerbosePrint("... CoEnumApps Test Ended.\n");

        VerbosePrint("... Class Store Lookup Test Started.\n");
        hr = DoClassInfoTest();
        VerbosePrint("... Class Store Lookup Test Ended.\n");

        if (SUCCEEDED(hr))
            printf ("PASSED ---- Class Store Lookup Test Suite.\n");
        else
            printf ("FAILED ---- Class Store Lookup Test Suite. hr = 0x%x.\n", hr);
    }

    if (fRemoveTest)
    {
        ULONG cPkgCount;
        VerbosePrint("... Remove Test Started.\n");
        hr = DoRemoveTest(&cPkgCount);
        VerbosePrint("... Remove Test Ended.(%d Packages).\n",
            cPkgCount);
        if (SUCCEEDED(hr))
            printf ("PASSED ---- Remove Test Suite.\n");
        else
            printf ("FAILED ---- Remove Test Suite. hr = 0x%x.\n", hr);
    }

    if (fDllTest)
    {
      /* BUGBUG. Deleted now. Add later.
        IClassAdmin *pClassAdmin = NULL;
        extern Sname TestProgId1, TestClassDesc1;
        extern GUID TestClsid1;

        //
        // Test entry points in csadm.dll
        //
        VerbosePrint("... Dll Test Started.\n");

        // 1. Create an empty store

        hr = CsCreateClassStore(szNewContainer, L"CN=DrtClassStore");

        // 2. Get an IClassAdmin for it.

        if (SUCCEEDED(hr))
        {
            VerbosePrint ("...... New Class Store created.\n");
            wcscat (szNewContainer, L"/");
            wcscat (szNewContainer, L"CN=DRTClassStore");
            hr = CsGetClassStore(szNewContainer, (void **)&pClassAdmin);
        }

        // 3. Use the IClassAdmin to add a class

        if (SUCCEEDED(hr))
        {
            VerbosePrint ("...... Connected to New Class Store.\n");
            CLASSDETAIL ClassDetail;

            memset (&ClassDetail, NULL, sizeof (CLASSDETAIL));
            memcpy (&ClassDetail.Clsid, &TestClsid1, sizeof (GUID));
            ClassDetail.pDefaultProgId = TestProgId1;
            ClassDetail.pszDesc = TestClassDesc1;

            hr = pClassAdmin->NewClass(&ClassDetail);
            if (!SUCCEEDED(hr))
            {
                printf ("ERROR! NewClass() returned 0x%x.\n", hr);
                return hr;
            }

            VerbosePrint ("...... Added a class definition.\n");

        // 4. Then delete the class

            hr = pClassAdmin->DeleteClass(TestClsid1);

            if (!SUCCEEDED(hr))
            {
                printf ("ERROR! DeleteClass() returned 0x%x.\n", hr);
                return hr;
            }

            VerbosePrint ("...... Deleted a class definition.\n");

        // 5. Release the IClassAdmin

            hr = pClassAdmin->Release();

        // 6. Delete the Class Store
            hr = CsDeleteClassStore(szNewContainer);
            if (!SUCCEEDED(hr))
            {
                printf ("ERROR! Deleting ClassStore.\n", hr);
                return hr;
            }
            VerbosePrint ("...... Deleted the class store.\n");
        }

        VerbosePrint("... Dll Test Ended.\n");

        if (SUCCEEDED(hr))
            printf ("PASSED ---- Dll Test Suite.\n");
        else
            printf ("FAILED ---- Dll Test Suite. hr = 0x%x.\n", hr);
        */
      }

    return hr;
}


void CleanUp()
{
    if (pIClassAdmin)
    {
        pIClassAdmin->Release();
        pIClassAdmin = NULL;
    }

    if (pIClassAdmin2)
    {
        pIClassAdmin2->Release();
        pIClassAdmin2 = NULL;
    }

    if (pIClassAccess)
    {
        pIClassAccess->Release();
        pIClassAccess = NULL;
    }

}


void _cdecl main( int argc, char ** argv )
{
    HRESULT         hr;
    INT             i;
    LPWSTR          szEnvVar;

    //
    // Check run parameters
    //

    fBrowseTest = FALSE;
    fVerbose = FALSE;
    fAdminTest = FALSE;
    fClassInfoTest = FALSE;
    fComprehensive = FALSE;
    fStress = FALSE;
    fRemoveTest = FALSE;
    fRefreshTest = FALSE;
    fMultiStore = FALSE;
    fEmptyTest = FALSE;
    fDllTest = FALSE;
    fCatTest = FALSE;
    fLogon = FALSE;
    fLogonPerf = FALSE;
    fClassInfoVerify = FALSE;

    szPassword[0] = NULL;
    szContainer[0] = NULL;
    szLookupPackageName[0] = NULL;
    //
    // Check if the env variable CLASSSTORE is defined
    // Get the value of the CLASSSTORE environment variable.
    //
    szEnvVar = _wgetenv(L"DRT_CLASSSTORE");

    //
    // if so use that as the default path
    //

    if (szEnvVar != NULL)
    {
        wcscpy (szContainer, szEnvVar);
    }

    BOOL fLoop = FALSE;

    for (i=1; i < argc; ++i)
    {
        if (toupper(*argv[i]) != '-')
        {
            printf ("ERROR! Parameters must start with a hyphen.\n");
            Usage();
            return;
        }

        switch (toupper(*(argv[i]+1)))
        {
        case 'P':
 		    MultiByteToWideChar (
                CP_ACP, 0,
                (argv[i]+2),
                strlen (argv[i]+2) + 1,
                szContainer,
                _MAX_PATH);
            break;
        case 'E':
            fEmptyTest = TRUE;
            break;
        case 'B':
            fBrowseTest = TRUE;
            break;
        case 'V':
            fVerbose = TRUE;
            break;
        case 'A':
            fAdminTest = TRUE;
            break;
        case 'O':
            fOverwritePath = TRUE;
            break;
        case 'Q':
            fCatTest = TRUE;
            break;
        case 'G':
            fClassInfoTest = TRUE;
             if (*(argv[i]+2) == 'V')
                 fClassInfoVerify = TRUE;
            break;
        case 'D':
            fDllTest = TRUE;
            break;
        case 'R':
            fRefreshTest = TRUE;
            break;
        case 'M':
            fMultiStore = TRUE;
            break;
        case 'C':
            fComprehensive = TRUE;
            break;
        case 'S':
            fStress = TRUE;
            break;
        case 'L':
            cLoops = atoi(argv[i]+2);
            fLoop = TRUE;
            break;
        case 'T':
             fLogonPerf = TRUE;
             if (*(argv[i]+2) == 'I')
                 fLogonPerfInitialize = TRUE;
             break;
        case 'U':
 		    MultiByteToWideChar (
                CP_ACP, 0,
                (argv[i]+2),
                strlen (argv[i]+2) + 1,
                szUserName,
                _MAX_PATH);
            pszDomain = pszUser = &szUserName[0];

            while (*pszUser)
            {
                if (*pszUser == L'\\')
                {
                    *pszUser = NULL;
                    pszUser++;
                    break;
                }
                pszUser++;
            }

            if (*pszUser == NULL)
            {
                printf ("ERROR! Incorrect domain\\user specified.\nAborting ...\n");
                return;
            }

            fLogon = TRUE;
            break;

        case 'W':
 		    MultiByteToWideChar (
                CP_ACP, 0,
                (argv[i]+2),
                strlen (argv[i]+2) + 1,
                szPassword,
                _MAX_PATH);
            break;
        default:
            Usage();
            return;
        }
    }

    if (szContainer[0] == NULL)
    {
        //
        // No default for container and none specified
        //
        printf ("ERROR! Class Container not specified and DRT_CLASSSTORE not set.\nAborting ...\n");
        return;
    }

    if (fMultiStore)
    {
        szEnvVar = _wgetenv(L"DRT_CLASSSTORE2");
        if (szEnvVar != NULL)
        {
            wcscpy (szContainer2, szEnvVar);
        }
        else
        {
            printf ("ERROR! DRT_CLASSSTORE2 not set. Aborting ...\n");
            return;
        }
    }

    if (fDllTest)
    {
        szEnvVar = _wgetenv(L"DRT_NEWOU");

        if (szEnvVar != NULL)
        {
            wcscpy (szNewContainer, szEnvVar);
        }
        else
        {
            printf ("ERROR! DRT_NEWOU not set. Aborting ...\n");
            return;
        }
    }

    if (!(fStress || fEmptyTest || fComprehensive ||
        fBrowseTest || fClassInfoTest || fAdminTest || fCatTest || fLogonPerf))
    {
        printf ("ERROR! No Tests specified. Aborting ...\n");
        return;
    }

    if (fStress &&
        (fEmptyTest || fComprehensive || fAdminTest || fMultiStore))
    {
        printf ("ERROR! For 'Stress Test' the only options are -g, -b and -l. \nAborting ...\n");
        return;
    }

    if ((fLogonPerf || fEmptyTest) &&
        (fComprehensive || fBrowseTest || fClassInfoTest || fAdminTest))
    {
        printf ("ERROR! Cant combine Empty or Logon Tests with any other test. \nAborting ...\n");
        return;
    }

    if (fComprehensive &&
        (fBrowseTest || fClassInfoTest || fAdminTest))
    {
        printf ("ERROR! Cant combine 'Comprehensive Test Suite' with any other individual tests. \nAborting ...\n");
        return;
    }

    if (fStress &&
        (!(fBrowseTest || fClassInfoTest )))
    {
        fClassInfoTest = TRUE;
    }

    if (fLoop)
    {
        if (!fStress)
        {
            printf ("ERROR! Loop count applies only to Stress Test. Aborting ...\n");
            return;
        }
        else
        {
            if (cLoops%100 != 0)
            {
                printf ("ERROR! Loop count can only be in multiple of 100s. Aborting ...\n");
                return;
            }
        }
    }

    //
    // If test is to be run for a different user,
    // do LogonUser
    //

    if (fLogon)
    {
        HANDLE hToken;
        BOOLEAN fEnable;
        NTSTATUS NtStatus;

        printf( "Will run test as user: %S, domain: %S.\n", pszUser, pszDomain);

        NtStatus = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &fEnable);


        if ( NtStatus != STATUS_SUCCESS )
        {
            printf( "ERROR! In RtlAdjustPrivilege. 0x%x. Aborting ...\n", NtStatus);
            return;
        }

        if (!LogonUser(
            pszUser, // string that specifies the user name
            pszDomain, // string that specifies the domain or server
            szPassword, // string that specifies the password
            LOGON32_LOGON_INTERACTIVE, // specifies the type of logon operation
            LOGON32_PROVIDER_DEFAULT, // specifies the logon provider
            &hToken // pointer to variable to receive token handle
            ))
        {
            printf( "ERROR! Invalid username or password - 0x%x. Aborting ...\n",
                GetLastError());
            return;
        }

        if (!ImpersonateLoggedOnUser(hToken))
        {
            printf( "ERROR! Impersonation failed. Aborting ...\n");
            return;
        }

        CloseHandle(hToken);
    }

    hr = CoInitialize(NULL);

    if( FAILED(hr) )
    {
        printf( "ERROR! Client CoInitialize failed Ox%x. Aborting ...\n", hr );
        return;
    }

    VerbosePrint ("Using Class Store at:\n   %S.\n", szContainer);
    if (fMultiStore)
        VerbosePrint ("Using Class Store 2 at:\n   %S.\n", szContainer2);

    if (fOverwritePath)
    {
        // Flush Class Store Cache and Overwrite Path
        UpdateClassStoreSettings(szContainer);
        VerbosePrint("... Overwrote Class Store Path.\n");
    }
    else
    {
        GetUserClassStore(szClassStorePath);
        VerbosePrint ("Profile ClassStore:\n   %S.\n", szClassStorePath);

        //
        // Verify that the Profile matches the input.
        //

        if (NULL == wcsstr(szClassStorePath, szContainer))
        {
            printf( "Warning! Class Store is different from Profile.\n");
        }

        if (NULL == wcsstr(szClassStorePath, szContainer2))
        {
            printf( "Warning! Second Class Store is different from Profile.\n");
        }

    }

    InitTempNames();

    if (fComprehensive)
    {
        hr = RunComprehensive();
    }

    else
    {
        if (fStress)
        {
            fVerbose = FALSE;
            hr = RunStress();
        }
        else
        {
            hr = RunTests();
            CleanUp();
        }
    }


    CoUninitialize();

}

//
// This routine takes a pathname and binds to a Class container
// and returns an IClassAdmin interface pointer
//


HRESULT GetClassAdmin (LPOLESTR pszPath, IClassAdmin **ppCA)
{
    HRESULT         hr;
    LPOLESTR        szPath;


    *ppCA = NULL;
    if (wcsncmp (pszPath, L"ADCS:", 5) == 0)
    {
        szPath = pszPath + 5;
    }
    else
        szPath = pszPath;

    hr = CsGetClassStore(szPath, (void **)ppCA);

    if ( FAILED(hr) )
    {
        printf("ERROR! Could not get IClassAdmin. Error- 0x%x\n", hr);
        return hr;
    }

    return S_OK;

}

//
// This routine binds to a CClassAccess on the desktop and
//   returns an IClassAccess interface pointer
//

HRESULT GetClassAccess ()
{
    HRESULT         hr;
    pIClassAccess = NULL;
    hr = CsGetClassAccess (&pIClassAccess);

    if ( FAILED(hr) )
    {
        printf("ERROR! Could not get IClassAccess. Error- 0x%x\n", hr);
        return hr;
    }
    return S_OK;
}

void
GetDefaultPlatform(CSPLATFORM *pPlatform)
{
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId;
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;
    pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;
}


//
// This routine enumerates all classes, packages and
//  cleans up the entire Class Container by deleting these objects.
//

HRESULT EmptyClassStore (IClassAdmin *pIClassAdmin)
{
    HRESULT hr;
    ULONG   cCount;

    hr = EnumPackagesAndDelete(pIClassAdmin, TRUE, &cCount);
    if (!SUCCEEDED(hr))
        return hr;
    VerbosePrint ("...... Deleted all %d Packages.\n", cCount);
    return S_OK;
}

//
// This routine enumerates all classes and packages
//

HRESULT DoBrowseTest (IClassAdmin *pCA)
{
    HRESULT hr;
    ULONG   cCount;

    hr = EnumPackagesAndDelete(pCA, FALSE, &cCount);
    if (!SUCCEEDED(hr))
        return hr;

    VerbosePrint ("...... Browsed %d Packages.\n", cCount);

    return S_OK;
}




void PrintPackageInfo(PACKAGEDISPINFO *pPackageInfo)
{
    SYSTEMTIME SystemTime;
    
    if (fVerbose)
    {
        FileTimeToSystemTime(
            (CONST FILETIME *)(&pPackageInfo->Usn),
            &SystemTime);
        
        VerbosePrint("........ Package: %S \n........   Last Update: %d-%d-%d %d:%d:%d\n",
            pPackageInfo->pszPackageName,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
        VerbosePrint("........   Script Size = %d. Path = %S\n",
            pPackageInfo->cScriptLen,
            pPackageInfo->pszScriptPath);
    }
}

void PrintInstallInfo(INSTALLINFO *pInstallInfo)
{
    SYSTEMTIME SystemTime;

    FileTimeToSystemTime(
        (CONST FILETIME *)(&pInstallInfo->Usn),
        &SystemTime);

    VerbosePrint("........ Script: %S (Size = %d)\n........   Last Update: %d-%d-%d %d:%d:%d\n",
        pInstallInfo->pszScriptPath,
        pInstallInfo->cScriptLen,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);
 }

/*
void PrintCategoryDetail(CATEGORYINFO *pCatInfo)
{
    VerbosePrint("........ Category Description: %S\n", pCatInfo->szDescription);
}
*/


HRESULT EnumPackagesAndDelete(IClassAdmin *pIClassAdmin,
                              BOOL fDelete,
                              ULONG *pcPackages)
{
    ULONG              cFetched;
    IEnumPackage      *pIEnumPackage = NULL;
    HRESULT            hr;
    PACKAGEDISPINFO        PackageInfo;

    *pcPackages=0;

    hr = pIClassAdmin->EnumPackages(
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        &pIEnumPackage);

    if ( FAILED(hr))
    {
        printf("ERROR! EnumPackages returned 0x%x\n", hr);
        return hr;
    }

    while (TRUE)
    {
        memset (&PackageInfo, 0, sizeof(PACKAGEDISPINFO));
        hr = pIEnumPackage->Next(1, &PackageInfo, &cFetched);
        if (FAILED(hr))
        {
            break;
        }
        if ((hr == S_FALSE) || (cFetched < 1))
        {
            hr = S_OK;
            break;
        }
        (*pcPackages)++;

        if (fVerbose && !fDelete)
        {
            PrintPackageInfo(&PackageInfo);
        }

        if (fDelete)
        {
            hr = pIClassAdmin->RemovePackage(PackageInfo.pszPackageName, 0);
        }

        ReleasePackageInfo(&PackageInfo);
    }

    pIEnumPackage->Release();
    if (fVerbose)
    {
        if (!SUCCEEDED(hr))
            printf("ERROR! 0x%x.\n", hr);
    }

    return hr;
}

/*
HRESULT EnumCategoriesAndDelete (IClassAdmin *pIClassAdmin,
                                 BOOL fDelete,
                                 ULONG *pcCategories)
{
    ULONG               cFetched;
    IEnumCATEGORYINFO  *pIEnumCat;
    HRESULT             hr;
    CATEGORYINFO        CatInfo;
    ICatRegister       *pICatReg;
    ICatInformation    *pICatInfo;
    LCID                lcid = 0;

    *pcCategories = 0;
    hr = pIClassAdmin->QueryInterface(IID_ICatRegister, (void **)&pICatReg);
    if (FAILED(hr))
    {
        printf("Error! QI CR hr = 0x%x\n", hr);
        return hr;
    }
    hr = pIClassAccess->QueryInterface(IID_ICatInformation, (void **)&pICatInfo);
    if (FAILED(hr))
    {
        printf("Error! QI CI hr = 0x%x\n", hr);
        return hr;
    }

    hr = pICatInfo->EnumCategories(lcid, &pIEnumCat);
    if ( FAILED(hr))
    {
        return hr;
    }

    while (TRUE)
    {
        hr = pIEnumCat->Next(1, &CatInfo, &cFetched);
        if (FAILED(hr))
        {
            break;
        }
        if ((hr == S_FALSE) || (cFetched < 1))
        {
            hr = S_OK;
            break;
        }
        (*pcCategories)++;

        if (fVerbose && !fDelete)
        {
            PrintCategoryDetail(&CatInfo);
        }

        if (fDelete)
        {
            hr = pICatReg->UnRegisterCategories(1, &(CatInfo.catid));
            if (!SUCCEEDED(hr))
                break;
        }

    }

    pIEnumCat->Release();
    if (fVerbose)
    {
        if (!SUCCEEDED(hr))
            printf("ERROR! 0x%x.\n", hr);
    }

    pICatReg->Release();
    pICatInfo->Release();

    return hr;
}
*/


void
ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail, BOOL fPartial)
{
   if (pPackageDetail->pActInfo)
   {
       CoTaskMemFree(pPackageDetail->pActInfo->prgShellFileExt);
       CoTaskMemFree(pPackageDetail->pActInfo->prgPriority);
       CoTaskMemFree(pPackageDetail->pActInfo->prgInterfaceId);
       CoTaskMemFree(pPackageDetail->pActInfo->prgTlbId);
       CoTaskMemFree(pPackageDetail->pActInfo);
   }

   if (pPackageDetail->pPlatformInfo)
   {
       CoTaskMemFree(pPackageDetail->pPlatformInfo->prgPlatform);
       CoTaskMemFree(pPackageDetail->pPlatformInfo->prgLocale);
       CoTaskMemFree(pPackageDetail->pPlatformInfo);
   }

   if (pPackageDetail->pInstallInfo)
   {
       if (!fPartial)
		   ReleaseInstallInfo(pPackageDetail->pInstallInfo);
       CoTaskMemFree(pPackageDetail->pInstallInfo);
   }

   CoTaskMemFree(pPackageDetail->pszSourceList);
   CoTaskMemFree(pPackageDetail->rpCategory);
}


void GetUserClassStore(LPWSTR szPath)
{
    LONG    lErrorCode;
    DWORD    dwDataLen = 1000;
    DWORD    dwType;
    HKEY    hKey = NULL;
    HRESULT hr = S_OK;

    *szPath = NULL;

    lErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                              L"Software\\Microsoft\\ClassStore",
                              NULL,
                              KEY_ALL_ACCESS,
                              &hKey);

    if ( lErrorCode != ERROR_SUCCESS)
    {
        return;
    }

    lErrorCode = RegQueryValueEx(hKey,
                                 L"Path",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)szPath,
                                 &dwDataLen);

    RegCloseKey(hKey);

    return;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\cclsacc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclsacc.cxx
//
//  Contents:    Class factory and IUnknown methods for CClassAccess
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


HRESULT  __stdcall  CClassAccess::QueryInterface(REFIID riid, void  * * ppvObject)
    
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    else  if( IsEqualIID( IID_IClassAccess, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    /*
    else  if( IsEqualIID( IID_IClassRefresh, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassRefresh *)this;
    }
    */
    else   
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);

}

ULONG __stdcall  CClassAccess::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccess::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


//
// Constructor 
//
unsigned long gulcClassFactory = 0;

CClassAccessCF::CClassAccessCF() 
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcClassFactory );
}

//
// Destructor 
//
CClassAccessCF::~CClassAccessCF()
{
    InterlockedDecrement((long *) &gulcClassFactory );
}

HRESULT  __stdcall  CClassAccessCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) ) 
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else   
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassAccessCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccessCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}

//
// IClassFactory Overide
//
HRESULT  __stdcall  CClassAccessCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void  * * ppvObject)
{
    CClassAccess *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassAccess()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}

HRESULT  __stdcall  CClassAccessCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcClassFactory ); }
    else
    { InterlockedDecrement((long *) &gulcClassFactory ); }
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\csdrt\csdrtad.cxx ===
//
//  Author: DebiM
//  Date:   March 97
//  File:   csdrtad.cxx
//
//      Class Store DRTs
//
//      This source file contains DRTs for
//          CClassContainer::IClassAdmin
//
//
//      It tests the following Class Store functionality
//
//         Admin Interfaces
//
//
//---------------------------------------------------------------------

#include "csdrt.hxx"
extern BOOL fVerbose;
extern BOOL fMultiStore;

extern IClassAdmin *pIClassAdmin;
extern IClassAdmin *pIClassAdmin2;
extern IClassAccess *pIClassAccess;


Sname TestFileExt1, TestFileExt2, TestFileExt4, TestProgId1, TestClassDesc1;
Sname TestOtherProgID1, TestOtherProgID2;
Sname TestMimeType2, TestClassDesc2;
Sname TestProgId3;
Sname TestVendor;
Sname TestPackName1, TestProduct1, TestPackagePath1;
Sname TestPackName2, TestPackagePath2;
Sname TestPackName4, TestPackagePath4, TestProduct4;
Sname TestPackName5, TestPackName6, TestPackName7, TestProduct2;
Sname RefreshPackName3;
Sname TestFailFileExt1, TestFailMimeType1, TestFailProgId1;
Sname TestHelpUrl1, TestHelpUrl2, TestHelpUrl3;
Sname TestAppCat1, TestAppCat2;
Sname RenTestPackName2;

LPOLESTR ConstTestFileExt1 =  L".ex1-";
LPOLESTR ConstTestFileExt2 =  L".ex2-";
LPOLESTR ConstTestProgId1 =  L"Really Long Long Long ProgId1-";
LPOLESTR ConstTestMimeType2 =  L"MimeType2-";
LPOLESTR ConstTestProgId3 =  L"ProgId3-";
LPOLESTR ConstTestFileExt4 =  L".ex4-";


LPOLESTR ConstTestPackName1 = L"CSDRT Pkg1-DRW-PUBL-VIS-AUTO(CLSID1-Ext4-Cat1)-";
LPOLESTR ConstTestProduct1 = L"CS DRT Product1-";
LPOLESTR ConstTestPackagePath1 = L"p1-";

LPOLESTR ConstTestPackName2 = L"Wrong Pkg2-DRW-PUBL-HIDDEN-AUTO(CLSID1-Cat2)-";
LPOLESTR ConstRenTestPackName2 = L"CSDRT Pkg2-DRW-PUBL-HIDDEN-AUTO(CLSID1-Cat2)-";
LPOLESTR ConstTestPackagePath2 = L"p2-";
LPOLESTR ConstTestOtherProgID1 = L"Really Long Long Long OtherProgId1-";
LPOLESTR ConstTestOtherProgID2 = L"OtherProgId2-";

LPOLESTR ConstTestPackName4 = L"CSDRT Pkg3-DRW-ASSG-VIS-AUTO(Ext4-Cat2)-";
LPOLESTR ConstTestPackagePath4 = L"p4-";

LPOLESTR ConstTestProduct2 = L"CS DRT Product2-";
LPOLESTR ConstTestProduct4 = L"CS DRT Product4-";

LPOLESTR ConstTestPackName5 = L"CS DRT pkg 5(Tlb2)-";
LPOLESTR ConstTestPackName6 = L"CS DRT pkg 6 Cls 3 4-";
LPOLESTR ConstTestPackName7 = L"CS DRT Tlb 7(CLS4)-";

LPOLESTR ConstRefreshPackName3 = L"CS DRT Refresh Package 3(Clsid3)-";

LPOLESTR ConstTestFailFileExt1 = L"fai";
LPOLESTR ConstTestFailMimeType1 =  L"FailMimeType";
LPOLESTR ConstTestFailProgId1 = L"Expected Failure Prog ID";

LPOLESTR ConstTestHelpUrl = L"http://junk";

LPOLESTR ConstTestAppCat1 = L"Test App Cat Id-1";
LPOLESTR ConstTestAppCat2 = L"Test App Cat Id-2";

//--------------
// {Fa11ed00-c151-d000-0000-000000000000}
GUID TestFailClsid1 =
{ 0xfa11ed00, 0xc151, 0xd000, { 0x00, 0x00, 0x0, 0x00, 0x00, 0x0, 0x00, 0x00 } };

//---------------


DWORD gData1 = 0;

GUID TestClsid1;
GUID TestClsid2;
GUID TestClsid3;
GUID TestClsid4;
GUID TestClsid5;
GUID TestClsid6;
GUID TestIid1;
GUID TestIid2;
GUID TestTlbId1;

GUID TestAppCatId1, TestAppCatId2;

PACKAGEDISPINFO PackageDisp[3];

void CreateGuid(GUID *pGuid)
{
    CoCreateGuid(pGuid);
    pGuid->Data2 = 0xabcd;
    gData1 = pGuid->Data1;
}

void ReleaseObj(PACKAGEDISPINFO obj)
{
   ReleasePackageInfo(&obj);
}

void CreateUnique (WCHAR *VName, WCHAR *ConstName)
{
    swprintf (VName, L"%s%x", ConstName, gData1);
}

void InitTempNames()
{
    //
    // Create all GUIDs
    //
    CreateGuid(&TestClsid1);
    CreateGuid(&TestClsid2);
    CreateGuid(&TestClsid3);
    CreateGuid(&TestIid1);
    CreateGuid(&TestIid2);
    CreateGuid(&TestTlbId1);

    CreateGuid(&TestAppCatId1);
    CreateGuid(&TestAppCatId2);

    if (fMultiStore)
    {
        CreateGuid(&TestClsid4);
        CreateGuid(&TestClsid5);
        CreateGuid(&TestClsid6);
    }

    //
    // Create Unique Package Names, File Ext, ProgID
    //
    CreateUnique (TestFileExt1, ConstTestFileExt1);
    CreateUnique (TestFileExt2, ConstTestFileExt2);
    CreateUnique (TestProgId1, ConstTestProgId1);

    CreateUnique (TestOtherProgID1, ConstTestOtherProgID1);
    CreateUnique (TestOtherProgID2, ConstTestOtherProgID2);

    CreateUnique (TestMimeType2, ConstTestMimeType2);

    CreateUnique (TestProgId3, ConstTestProgId3);

    CreateUnique (TestFileExt4, ConstTestFileExt4);

    CreateUnique (TestPackName1, ConstTestPackName1);
    CreateUnique (TestProduct1, ConstTestProduct1);
    CreateUnique (TestPackagePath1, ConstTestPackagePath1);

    CreateUnique (TestPackName2, ConstTestPackName2);
    CreateUnique (RenTestPackName2, ConstRenTestPackName2);
    CreateUnique (TestPackagePath2, ConstTestPackagePath2);
    CreateUnique (TestProduct2, ConstTestProduct2);

    CreateUnique (RefreshPackName3, ConstRefreshPackName3);

    CreateUnique (TestPackName4, ConstTestPackName4);
    CreateUnique (TestPackagePath4, ConstTestPackagePath4);
    CreateUnique (TestProduct4, ConstTestProduct4);

    CreateUnique (TestPackName5, ConstTestPackName5);
    CreateUnique (TestPackName6, ConstTestPackName6);
    CreateUnique (TestPackName7, ConstTestPackName7);

    CreateUnique (TestFailFileExt1, ConstTestFailFileExt1);
    CreateUnique (TestFailProgId1, ConstTestFailProgId1);

    CreateUnique(TestHelpUrl1, ConstTestHelpUrl);
    CreateUnique(TestHelpUrl2, ConstTestHelpUrl);
    CreateUnique(TestHelpUrl3, ConstTestHelpUrl);

    CreateUnique(TestAppCat1, ConstTestAppCat1);
    CreateUnique(TestAppCat2, ConstTestAppCat2);
}


HRESULT AddRandomPackage(PACKAGEDETAIL &PackageDetail, int i)
{
   HRESULT hr = S_OK;
   WCHAR   szPackageName[_MAX_PATH];

    // activation flag to be set outside.

   wsprintf(szPackageName, L"LogonTestPackage-%d", i);
   PackageDetail.pInstallInfo->PathType = DrwFilePath;

   PackageDetail.pActInfo->cShellFileExt = 2;
   PackageDetail.pActInfo->prgShellFileExt = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*2);
   PackageDetail.pActInfo->prgShellFileExt[0] = TestFileExt4;
   PackageDetail.pActInfo->prgShellFileExt[1] = TestFileExt1;
   PackageDetail.pActInfo->prgPriority = (UINT *)CoTaskMemAlloc(sizeof(UINT)*2);
   PackageDetail.pActInfo->prgPriority[0] = 1;
   PackageDetail.pActInfo->prgPriority[1] = 2;

   PackageDetail.pActInfo->cInterfaces = 1;
   PackageDetail.pActInfo->prgInterfaceId = (IID *)CoTaskMemAlloc(sizeof(IID));
   PackageDetail.pActInfo->prgInterfaceId[0] = TestIid2;
   PackageDetail.pActInfo->cTypeLib = 1;
   PackageDetail.pActInfo->prgTlbId = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.pActInfo->prgTlbId[0] = TestTlbId1;

   PackageDetail.pPlatformInfo->cPlatforms = 1;
   PackageDetail.pPlatformInfo->prgPlatform = (CSPLATFORM *)CoTaskMemAlloc(sizeof(CSPLATFORM));
   GetDefaultPlatform(&PackageDetail.pPlatformInfo->prgPlatform[0]);
   PackageDetail.pPlatformInfo->cLocales = 2;
   PackageDetail.pPlatformInfo->prgLocale = (LCID *)CoTaskMemAlloc(sizeof(LCID)*2);
   PackageDetail.pPlatformInfo->prgLocale[0] = 0x409;
   PackageDetail.pPlatformInfo->prgLocale[1] = 0x410;

   PackageDetail.pInstallInfo->pszScriptPath = TestPackagePath1;
   PackageDetail.pInstallInfo->pszSetupCommand = TestPackagePath1;
   PackageDetail.pInstallInfo->pszUrl = TestHelpUrl1;

   PackageDetail.cSources = 1;
   PackageDetail.pszSourceList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
   PackageDetail.pszSourceList[0] = TestPackagePath1;
   PackageDetail.cCategories = 1;
   PackageDetail.rpCategory = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.rpCategory[0] = TestAppCatId1;

#if 0
   PackageDetail.pInstallInfo->cScriptLen = 160 + (GetTickCount() % 11783);
   PackageDetail.pInstallInfo->pScript = (BYTE *) CoTaskMemAlloc (PackageDetail.pInstallInfo->cScriptLen);

   for (UINT i=0; i < PackageDetail.pInstallInfo->cScriptLen; i++)
   {
       PackageDetail.pInstallInfo->pScript[i] = i%128;
   }
#endif

   hr = pIClassAdmin->AddPackage(szPackageName, &PackageDetail);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! AddPackage() returned 0x%x.\n", hr);
       return hr;
   }

   return hr;
}


HRESULT AddPackage1(PACKAGEDETAIL &PackageDetail)
{
   HRESULT hr = S_OK;

   PackageDetail.pActInfo->cShellFileExt = 2;
   PackageDetail.pActInfo->prgShellFileExt = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*2);
   PackageDetail.pActInfo->prgShellFileExt[0] = TestFileExt4;
   PackageDetail.pActInfo->prgShellFileExt[1] = TestFileExt1;
   PackageDetail.pActInfo->prgPriority = (UINT *)CoTaskMemAlloc(sizeof(UINT)*2);
   PackageDetail.pActInfo->prgPriority[0] = 1;
   PackageDetail.pActInfo->prgPriority[1] = 2;

   PackageDetail.pActInfo->cInterfaces = 1;
   PackageDetail.pActInfo->prgInterfaceId = (IID *)CoTaskMemAlloc(sizeof(IID));
   PackageDetail.pActInfo->prgInterfaceId[0] = TestIid2;
   PackageDetail.pActInfo->cTypeLib = 1;
   PackageDetail.pActInfo->prgTlbId = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.pActInfo->prgTlbId[0] = TestTlbId1;

   PackageDetail.pPlatformInfo->cPlatforms = 1;
   PackageDetail.pPlatformInfo->prgPlatform = (CSPLATFORM *)CoTaskMemAlloc(sizeof(CSPLATFORM));
   GetDefaultPlatform(&PackageDetail.pPlatformInfo->prgPlatform[0]);
   PackageDetail.pPlatformInfo->cLocales = 2;
   PackageDetail.pPlatformInfo->prgLocale = (LCID *)CoTaskMemAlloc(sizeof(LCID)*2);
   PackageDetail.pPlatformInfo->prgLocale[0] = 0x409;
   PackageDetail.pPlatformInfo->prgLocale[1] = 0x410;

   PackageDetail.pInstallInfo->dwActFlags = 
       ACTFLG_Published +               // Published
       ACTFLG_UserInstall +             // Visible
       ACTFLG_OnDemandInstall +          // AutoInstall
       256;  // Hack. Script Present

   PackageDetail.pInstallInfo->PathType = DrwFilePath;
   PackageDetail.pInstallInfo->pszScriptPath = TestPackagePath1;
//   PackageDetail.pInstallInfo->pszSetupCommand = TestPackagePath1;

   PackageDetail.pInstallInfo->Mvipc = TestClsid1;
   PackageDetail.pInstallInfo->ProductCode = TestClsid1;

   PackageDetail.pInstallInfo->pszUrl = TestHelpUrl1;
   PackageDetail.pInstallInfo->InstallUiLevel = 42;
   PackageDetail.pInstallInfo->cUpgrades = 1;
   PackageDetail.pInstallInfo->prgUpgradeScript = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
   PackageDetail.pInstallInfo->prgUpgradeScript[0] = TestPackagePath1;
   PackageDetail.pInstallInfo->prgUpgradeFlag = (DWORD *)CoTaskMemAlloc(sizeof(DWORD));
   PackageDetail.pInstallInfo->prgUpgradeFlag[0] = UPGFLG_NoUninstall;
   PackageDetail.pInstallInfo->cScriptLen = 0;
   //160 + (GetTickCount() % 11783);
   /*
   PackageDetail.pInstallInfo->pScript = (BYTE *) CoTaskMemAlloc (PackageDetail.pInstallInfo->cScriptLen);

   for (UINT i=0; i < PackageDetail.pInstallInfo->cScriptLen; i++)
   {
       PackageDetail.pInstallInfo->pScript[i] = i%128;
   }
*/


   PackageDetail.cSources = 1;
   PackageDetail.pszSourceList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
   PackageDetail.pszSourceList[0] = TestPackagePath1;
   PackageDetail.cCategories = 1;
   PackageDetail.rpCategory = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.rpCategory[0] = TestAppCatId1;


   hr = pIClassAdmin->AddPackage(TestPackName1, &PackageDetail);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! NewPackage() returned 0x%x.\n", hr);
       return hr;
   }
   //CoTaskMemFree(PackageDetail.pInstallInfo->pScript);
   //PackageDetail.pInstallInfo->pScript = NULL;

   return hr;
}

HRESULT AddPackage2(PACKAGEDETAIL &PackageDetail)
{
   HRESULT hr = S_OK;

   PackageDetail.pInstallInfo->dwActFlags = 
       ACTFLG_Published +               // Published
       ACTFLG_UserInstall +             // Visible
       ACTFLG_OnDemandInstall;          // AutoInstall

   PackageDetail.pInstallInfo->PathType = DrwFilePath;
   PackageDetail.pActInfo->cInterfaces = 1;
   PackageDetail.pActInfo->prgInterfaceId = (IID *)CoTaskMemAlloc(sizeof(IID));
   PackageDetail.pActInfo->prgInterfaceId[0] = TestIid1;
   PackageDetail.pActInfo->cTypeLib = 1;
   PackageDetail.pActInfo->prgTlbId = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.pActInfo->prgTlbId[0] = TestTlbId1;

   PackageDetail.pPlatformInfo->cPlatforms = 1;
   PackageDetail.pPlatformInfo->prgPlatform = (CSPLATFORM *)CoTaskMemAlloc(sizeof(CSPLATFORM));
   GetDefaultPlatform(&PackageDetail.pPlatformInfo->prgPlatform[0]);
   PackageDetail.pPlatformInfo->cLocales = 2;
   PackageDetail.pPlatformInfo->prgLocale = (LCID *)CoTaskMemAlloc(sizeof(LCID)*2);
   PackageDetail.pPlatformInfo->prgLocale[0] = 0x409;
   PackageDetail.pPlatformInfo->prgLocale[1] = 0x410;

   PackageDetail.pInstallInfo->pszScriptPath = TestPackagePath2;
   PackageDetail.pInstallInfo->pszSetupCommand = TestPackagePath2;
   PackageDetail.pInstallInfo->pszUrl = TestHelpUrl2;

   PackageDetail.cSources = 1;
   PackageDetail.pszSourceList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
   PackageDetail.pszSourceList[0] = TestPackagePath2;
   PackageDetail.cCategories = 1;
   PackageDetail.rpCategory = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.rpCategory[0] = TestAppCatId2;

   // smaller scripts for this package

#if 0
   PackageDetail.pInstallInfo->cScriptLen = (GetTickCount() % 3423);
   PackageDetail.pInstallInfo->pScript = (BYTE *) CoTaskMemAlloc (PackageDetail.pInstallInfo->cScriptLen);

   for (UINT i=0; i < PackageDetail.pInstallInfo->cScriptLen; i++)
   {
       PackageDetail.pInstallInfo->pScript[i] = i%128;
   }
#endif

   hr = pIClassAdmin->AddPackage(TestPackName2, &PackageDetail);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! NewPackage() returned 0x%x.\n", hr);
       return hr;
   }


   return hr;
}

HRESULT AddPackage3(PACKAGEDETAIL &PackageDetail)
{
   HRESULT hr = S_OK;

   PackageDetail.pInstallInfo->dwActFlags = 
       ACTFLG_Assigned +                // Assigned
       ACTFLG_UserInstall +             // Visible
       ACTFLG_OnDemandInstall;          // AutoInstall

   PackageDetail.pInstallInfo->PathType = DrwFilePath;
   PackageDetail.pActInfo->cShellFileExt = 1;
   PackageDetail.pActInfo->prgShellFileExt = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*1);
   PackageDetail.pActInfo->prgShellFileExt[0] = TestFileExt4;
   PackageDetail.pActInfo->prgPriority = (UINT *)CoTaskMemAlloc(sizeof(UINT));
   PackageDetail.pActInfo->prgPriority[0] = 1;

   PackageDetail.pActInfo->cInterfaces = 1;
   PackageDetail.pActInfo->prgInterfaceId = (IID *)CoTaskMemAlloc(sizeof(IID));
   PackageDetail.pActInfo->prgInterfaceId[0] = TestIid2;
   PackageDetail.pActInfo->cTypeLib = 1;
   PackageDetail.pActInfo->prgTlbId = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.pActInfo->prgTlbId[0] = TestTlbId1;

   PackageDetail.pPlatformInfo->cPlatforms = 1;
   PackageDetail.pPlatformInfo->prgPlatform = (CSPLATFORM *)CoTaskMemAlloc(sizeof(CSPLATFORM));
   GetDefaultPlatform(&PackageDetail.pPlatformInfo->prgPlatform[0]);
   PackageDetail.pPlatformInfo->cLocales = 2;
   PackageDetail.pPlatformInfo->prgLocale = (LCID *)CoTaskMemAlloc(sizeof(LCID)*2);
   PackageDetail.pPlatformInfo->prgLocale[0] = 0x409;
   PackageDetail.pPlatformInfo->prgLocale[1] = 0x410;

   PackageDetail.pInstallInfo->pszScriptPath = TestPackagePath4;
   PackageDetail.pInstallInfo->pszSetupCommand = TestPackagePath4;
   PackageDetail.pInstallInfo->pszUrl = TestHelpUrl3;

   PackageDetail.cSources = 1;
   PackageDetail.pszSourceList = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
   PackageDetail.pszSourceList[0] = TestPackagePath4;
   PackageDetail.cCategories = 1;
   PackageDetail.rpCategory = (GUID *)CoTaskMemAlloc(sizeof(GUID));
   PackageDetail.rpCategory[0] = TestAppCatId2;

#if 0
   // smaller scripts for this package

   PackageDetail.pInstallInfo->cScriptLen = (GetTickCount() % 26423);
   PackageDetail.pInstallInfo->pScript = (BYTE *) CoTaskMemAlloc (PackageDetail.pInstallInfo->cScriptLen);

   for (UINT i=0; i < PackageDetail.pInstallInfo->cScriptLen; i++)
   {
       PackageDetail.pInstallInfo->pScript[i] = i%128;
   }
#endif

   hr = pIClassAdmin->AddPackage(TestPackName4, &PackageDetail);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! NewPackage() returned 0x%x.\n", hr);
       return hr;
   }


   return hr;
}

void VerbosePrintObj(PACKAGEDISPINFO If)
{
    VerbosePrint("Package Name %S\n", If.pszPackageName);
}

HRESULT GetPackageStructures(LPOLESTR PackName, PACKAGEDETAIL PackageDetail)
{
   PACKAGEDETAIL    PackageDetailFetched;
   PLATFORMINFO     PlatformInfo;
   HRESULT      hr = S_OK;

   hr = pIClassAdmin->GetPackageDetails(PackName, &PackageDetailFetched);
   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! GetPackageDetails() returned 0x%x.\n", hr);
       return hr;
   }

   if (!(Compare(PackageDetailFetched, PackageDetail))) 
   {
      hr = E_FAIL;
   }

   ReleasePackageDetail(&PackageDetailFetched);

   return hr;
}

CLASSDETAIL     ClassDetail[3];

HRESULT
InitPackages(ULONG *pcPkgCount, PACKAGEDETAIL &PackageDetail1,
                PACKAGEDETAIL &PackageDetail2,
                PACKAGEDETAIL &PackageDetail3)
{
   HRESULT      hr = S_OK;

   memset (&ClassDetail[0], NULL, sizeof (CLASSDETAIL));
   memcpy (&ClassDetail[0].Clsid, &TestClsid1, sizeof (GUID));

   ClassDetail[0].cProgId = 3;
   ClassDetail[0].prgProgId = (LPWSTR *) CoTaskMemAlloc(3 * sizeof (LPWSTR));
   ClassDetail[0].prgProgId[0] = TestProgId1;
   ClassDetail[0].prgProgId[1] = TestOtherProgID1;
   ClassDetail[0].prgProgId[2] = TestOtherProgID2;
   memset (&ClassDetail[1], NULL, sizeof (CLASSDETAIL));
   memcpy (&ClassDetail[1].Clsid, &TestClsid2, sizeof (GUID));
   memcpy (&ClassDetail[1].TreatAs, &TestClsid3, sizeof (GUID));

   memset (&ClassDetail[2], NULL, sizeof (CLASSDETAIL));
   memcpy (&ClassDetail[2].Clsid, &TestClsid3, sizeof (GUID));
   ClassDetail[2].cProgId = 1;
   ClassDetail[2].prgProgId = (LPWSTR *) CoTaskMemAlloc(1 * sizeof (LPWSTR));
   ClassDetail[2].prgProgId[0] = TestProgId3;

   //
   // Add Package 1
   //

   PackageDetail1.pActInfo->cClasses = 2;
   PackageDetail1.pActInfo->pClasses = (CLASSDETAIL *)CoTaskMemAlloc(sizeof(CLASSDETAIL)*2);

   PackageDetail1.pActInfo->pClasses[0] = ClassDetail[0];
   PackageDetail1.pActInfo->pClasses[1] = ClassDetail[1];

   hr = AddPackage1(PackageDetail1);
   if (SUCCEEDED(hr)) 
   {
      (*pcPkgCount)++;
   }


   //
   // Add Package 2
   //
   PackageDetail2.pActInfo->cClasses = 2;
   PackageDetail2.pActInfo->pClasses = (CLASSDETAIL *)CoTaskMemAlloc(sizeof(CLASSDETAIL)*2);
   PackageDetail2.pActInfo->pClasses[0] = ClassDetail[0];
   PackageDetail2.pActInfo->pClasses[1] = ClassDetail[2];


   hr = AddPackage2(PackageDetail2);
   if (SUCCEEDED(hr)) 
   {
      (*pcPkgCount)++;
   }


   //
   // Add Package 3
   //

   hr = AddPackage3(PackageDetail3);

   if (SUCCEEDED(hr)) 
   {
      (*pcPkgCount)++;
   }

   //
   // Test rename 
   // Rename Pkg2 
   //
   hr = pIClassAdmin->ChangePackageProperties(TestPackName2, 
       RenTestPackName2, NULL, NULL, NULL, NULL);


   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! ChangePackageProperties(rename) returned 0x%x.\n", hr);
       return hr;
   }

   //
   // Test changing properties - flags
   //
   DWORD dwActFlags = ACTFLG_Published +  ACTFLG_OnDemandInstall;   // Not visible     
   hr = pIClassAdmin->ChangePackageProperties(RenTestPackName2, 
       NULL, &dwActFlags, NULL, NULL, NULL);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! ChangePackageProperties(flags) returned 0x%x.\n", hr);
       return hr;
   }
   PackageDetail2.pInstallInfo->dwActFlags = dwActFlags;
   //
   // Test changing properties - scriptpath
   //
   hr = pIClassAdmin->ChangePackageProperties(RenTestPackName2, 
       NULL, NULL, NULL, L"foo.bar", NULL);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! ChangePackageProperties(ScriptPath) returned 0x%x.\n", hr);
       return hr;
   }

   PackageDetail2.pInstallInfo->pszScriptPath = L"foo.bar";

   //
   // Test changing fileext priority
   //
   hr = pIClassAdmin->SetPriorityByFileExt(TestPackName1,
        TestFileExt4, 12);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! SetPriorityByFileExt() returned 0x%x.\n", hr);
       return hr;
   }

   PackageDetail1.pActInfo->prgPriority[0] = 12; // we know that the corresp ext in in the first place.
   return hr;
}


HRESULT DoAdminEnumTests()
{
   HRESULT hr;
   IEnumPackage       *pEnum = NULL;

   VerbosePrint("Testing Enumerator with file ext %S\n", TestFileExt4);
   hr = pIClassAdmin->EnumPackages(TestFileExt4, 
       NULL, 
       0, 
       NULL,
       NULL,
       &pEnum);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! EnumPackages() returned 0x%x.\n", hr);
       return hr;
   }

   EnumTests<IEnumPackage, PACKAGEDISPINFO>(pEnum, 2, NULL, PackageDisp, 3, TRUE);
   if (!SUCCEEDED(hr)) 
   {
      return hr;
   }

   hr = pIClassAdmin->EnumPackages(NULL, 
       &TestAppCatId2, 
       0, 
       NULL,
       NULL,
       &pEnum);

   if (!SUCCEEDED(hr))
   {
       printf ("ERROR! EnumPackages() returned 0x%x.\n", hr);
       return hr;
   }

   hr = EnumTests<IEnumPackage, PACKAGEDISPINFO>(pEnum, 2, NULL, PackageDisp, 3, TRUE);
   if (!SUCCEEDED(hr)) {
      return hr;
   }

   return hr;
}


PACKAGEDETAIL   PackageDetail1, PackageDetail2,
                PackageDetail3, PackageDetail4;

HRESULT DoAdminTest (ULONG *pcPkgCount)
{
    HRESULT         hr = S_OK;

    
    APPCATEGORYINFO      AppCategory1, AppCategory2;
    APPCATEGORYINFOLIST  RecdAppCategoryInfoList;

    memset(&PackageDetail1, NULL, sizeof(PACKAGEDETAIL));
    memset(&PackageDetail2, NULL, sizeof(PACKAGEDETAIL));
    memset(&PackageDetail3, NULL, sizeof(PACKAGEDETAIL));
   
    PackageDetail1.pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
    memset (PackageDetail1.pInstallInfo, 0, sizeof(INSTALLINFO));

    PackageDetail1.pPlatformInfo = (PLATFORMINFO *) CoTaskMemAlloc (sizeof(PLATFORMINFO));
    memset (PackageDetail1.pPlatformInfo, 0, sizeof(PLATFORMINFO));

    PackageDetail1.pActInfo = (ACTIVATIONINFO *) CoTaskMemAlloc (sizeof(ACTIVATIONINFO));
    memset (PackageDetail1.pActInfo, 0, sizeof(ACTIVATIONINFO));

    PackageDetail2.pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
    memset (PackageDetail2.pInstallInfo, 0, sizeof(INSTALLINFO));

    PackageDetail2.pPlatformInfo = (PLATFORMINFO *) CoTaskMemAlloc (sizeof(PLATFORMINFO));
    memset (PackageDetail2.pPlatformInfo, 0, sizeof(PLATFORMINFO));

    PackageDetail2.pActInfo = (ACTIVATIONINFO *) CoTaskMemAlloc (sizeof(ACTIVATIONINFO));
    memset (PackageDetail2.pActInfo, 0, sizeof(ACTIVATIONINFO));

    PackageDetail3.pInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
    memset (PackageDetail3.pInstallInfo, 0, sizeof(INSTALLINFO));

    PackageDetail3.pPlatformInfo = (PLATFORMINFO *) CoTaskMemAlloc (sizeof(PLATFORMINFO));
    memset (PackageDetail3.pPlatformInfo, 0, sizeof(PLATFORMINFO));

    PackageDetail3.pActInfo = (ACTIVATIONINFO *) CoTaskMemAlloc (sizeof(ACTIVATIONINFO));
    memset (PackageDetail3.pActInfo, 0, sizeof(ACTIVATIONINFO));

    *pcPkgCount = 0;

    memset((void *)PackageDisp, 0, sizeof(PACKAGEDISPINFO)*3);
    hr = InitPackages(pcPkgCount, PackageDetail1, PackageDetail2,
               PackageDetail3);

    if (FAILED(hr))
       return hr;

    if (pIClassAdmin2 != NULL)
    {
    //
    // If MultiStore tests in progress

    }


    hr = GetPackageStructures(TestPackName1, PackageDetail1);

    if (!SUCCEEDED(hr)) 
	{
       return hr;
    }

    hr = GetPackageStructures(RenTestPackName2, PackageDetail2);

    if (!SUCCEEDED(hr)) 
	{
		//
		// Properties in the package detail structure has been updated.
        return hr;
    }

    hr = GetPackageStructures(TestPackName4, PackageDetail3);

    if (!SUCCEEDED(hr)) {
       return hr;
    }

    PackageDisp[0].pszPackageName = TestPackName1;
    PackageDisp[0].dwActFlags = PackageDetail1.pInstallInfo->dwActFlags;
    PackageDisp[0].PathType = PackageDetail1.pInstallInfo->PathType;
    PackageDisp[0].pszScriptPath = PackageDetail1.pInstallInfo->pszScriptPath;
    PackageDisp[0].cScriptLen = PackageDetail1.pInstallInfo->cScriptLen;
    PackageDisp[0].Usn = PackageDetail1.pInstallInfo->Usn;
    PackageDisp[0].dwVersionHi = PackageDetail1.pInstallInfo->dwVersionHi;
    PackageDisp[0].dwVersionLo = PackageDetail1.pInstallInfo->dwVersionLo;
    PackageDisp[0].cUpgrades = PackageDetail1.pInstallInfo->cUpgrades;
    PackageDisp[0].prgUpgradeScript = PackageDetail1.pInstallInfo->prgUpgradeScript;
    PackageDisp[0].prgUpgradeFlag = PackageDetail1.pInstallInfo->prgUpgradeFlag;

    PackageDisp[1].pszPackageName = RenTestPackName2;
    PackageDisp[1].dwActFlags = PackageDetail2.pInstallInfo->dwActFlags;
    PackageDisp[1].PathType = PackageDetail2.pInstallInfo->PathType;
    PackageDisp[1].pszScriptPath = PackageDetail2.pInstallInfo->pszScriptPath;
    PackageDisp[1].cScriptLen = PackageDetail2.pInstallInfo->cScriptLen;
    PackageDisp[1].Usn = PackageDetail2.pInstallInfo->Usn;
    PackageDisp[1].dwVersionHi = PackageDetail2.pInstallInfo->dwVersionHi;
    PackageDisp[1].dwVersionLo = PackageDetail2.pInstallInfo->dwVersionLo;
    PackageDisp[1].cUpgrades = PackageDetail2.pInstallInfo->cUpgrades;
    PackageDisp[1].prgUpgradeScript = PackageDetail2.pInstallInfo->prgUpgradeScript;
    PackageDisp[1].prgUpgradeFlag = PackageDetail2.pInstallInfo->prgUpgradeFlag;

    PackageDisp[2].pszPackageName = TestPackName4;
    PackageDisp[2].dwActFlags = PackageDetail3.pInstallInfo->dwActFlags;
    PackageDisp[2].PathType = PackageDetail3.pInstallInfo->PathType;
    PackageDisp[2].pszScriptPath = PackageDetail3.pInstallInfo->pszScriptPath;
    PackageDisp[2].cScriptLen = PackageDetail3.pInstallInfo->cScriptLen;
    PackageDisp[2].Usn = PackageDetail3.pInstallInfo->Usn;
    PackageDisp[2].dwVersionHi = PackageDetail3.pInstallInfo->dwVersionHi;
    PackageDisp[2].dwVersionLo = PackageDetail3.pInstallInfo->dwVersionLo;
    PackageDisp[2].cUpgrades = PackageDetail3.pInstallInfo->cUpgrades;
    PackageDisp[2].prgUpgradeScript = PackageDetail3.pInstallInfo->prgUpgradeScript;
    PackageDisp[2].prgUpgradeFlag = PackageDetail3.pInstallInfo->prgUpgradeFlag;

    hr = DoAdminEnumTests();
    if (!SUCCEEDED(hr)) {
       return hr;
    }

    memset(&AppCategory1, 0, sizeof(APPCATEGORYINFO));
    memset(&AppCategory2, 0, sizeof(APPCATEGORYINFO));

    AppCategory1.Locale = AppCategory2.Locale = 0x409;
    AppCategory1.pszDescription = TestAppCat1;
    AppCategory2.pszDescription = TestAppCat2;
    AppCategory1.AppCategoryId = TestAppCatId1;
    AppCategory2.AppCategoryId = TestAppCatId2;


    hr = pIClassAdmin->RegisterAppCategory(&AppCategory1);
    if (!SUCCEEDED(hr)) 
    {
       printf("RegisterAppCategory 1 returned 0x%x\n", hr);
       return hr;
    }

    hr = pIClassAdmin->RegisterAppCategory(&AppCategory2);
    if (!SUCCEEDED(hr)) 
	{
       printf("RegisterAppCategory 2 returned 0x%x\n", hr);
       return hr;
    }


    //hr = pIClassAdmin->GetAppCategories (0x409, &RecdAppCategoryInfoList);
    hr = CsGetAppCategories (&RecdAppCategoryInfoList);
    
	if (SUCCEEDED(hr))
	{
       printf("CsGetAppCategories returned: %d items\n", RecdAppCategoryInfoList.cCategory);
	   for (UINT k=0; k < RecdAppCategoryInfoList.cCategory; k++) 
		   printf ("    Category: %S.\n", (RecdAppCategoryInfoList.pCategoryInfo[k]).pszDescription);
	}

	if ((hr != S_OK) || (RecdAppCategoryInfoList.cCategory < 2)) 
    {
       printf("CsGetAppCategories failed. 0x%x\n", hr);
    }

    ReleaseAppCategoryInfoList(&RecdAppCategoryInfoList);

//    ReleasePackageDetail(&PackageDetail1, TRUE);
//    ReleasePackageDetail(&PackageDetail2, TRUE);
//    ReleasePackageDetail(&PackageDetail3, TRUE);

    return S_OK;
}


HRESULT DoRemoveTest (ULONG *pcPkgCount)
{
    HRESULT hr, hr1 = S_OK;
    *pcPkgCount = 0;

    VerbosePrint("Removing Packages %S\n", TestPackName1);

    hr = pIClassAdmin->RemovePackage(TestPackName1, 0);
    if (SUCCEEDED(hr))
        (*pcPkgCount)++;
    else 
    {
       printf("Remove Package returned 0x%x\n", hr);
       hr1 = hr;
    }
    VerbosePrint("Removing Packages %S\n", TestPackName2);

    hr = pIClassAdmin->RemovePackage(TestPackName2, 0);
    if (SUCCEEDED(hr))
        (*pcPkgCount)++;
    else {
       printf("Remove Package  returned 0x%x\n", hr);
       hr1 = hr;
    }
    VerbosePrint("Removing Packages %S\n", TestPackName4);

    hr = pIClassAdmin->RemovePackage(TestPackName4, 0);
    if (SUCCEEDED(hr))
        (*pcPkgCount)++;
    else {
       printf("Remove Package  returned 0x%x\n", hr);
       hr1 = hr;
    }
    
    
    hr = pIClassAdmin->UnregisterAppCategory(&TestAppCatId1);
    if (!SUCCEEDED(hr)) {
       printf("RegisterAppCategory 1 returned 0x%x\n", hr);
       return hr;
    }

    hr = pIClassAdmin->UnregisterAppCategory(&TestAppCatId2);
    if (!SUCCEEDED(hr)) {
       printf("RegisterAppCategory 1 returned 0x%x\n", hr);
       return hr;
    }

   return hr;
}


HRESULT RefreshTest()
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\catinfo.cxx ===
//
//  Author: ushaji
//  Date:   December 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for ICatInformation interfaces.                             
//
//      Refer Doc "Design for Support of File Types and Component Categories
//      in Class Store" ? (or may be Class Store Schema)
//


#include "cstore.hxx"

//---------------------------------------------------------------
// EnumCategories:
//      returns the enumerator to enumerate categories.
//        lcid:                    locale id.
//        ppenumcategoryinfo:        Enumerator that is returned.
//
// ppEnumCategoryInfo value is undefined if an error occurs
// I am assuming that except in rare conditions all the application in a
// particular environment will have the same lcid.
//---------------------------------------------------------------

HRESULT __stdcall CClassContainer::EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo)
{
    VARIANT                *pVarFilter = NULL;
    HRESULT                 hr;
    CSCEnumCategories      *pEnum;

    if (!m_fOpen)
        return E_FAIL;

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (!IsValidPtrOut(ppenumCategoryInfo, sizeof(IEnumCATEGORYINFO *)))
        return E_INVALIDARG;

    *ppenumCategoryInfo=NULL;

    pEnum=new CSCEnumCategories;
    if(NULL == pEnum)
        return E_OUTOFMEMORY;

    hr = pEnum->Initialize(m_ADsCategoryContainer, lcid);
    if (FAILED(hr))
    {
        delete pEnum;
        return hr;
    }

    hr = pEnum->QueryInterface(IID_IEnumCATEGORYINFO,(void**) ppenumCategoryInfo);

    if (FAILED(hr))
    {
        delete pEnum;
        return hr;
    }

    return S_OK;
} /* EnumCategories */

//---------------------------------------------------------------
// GetCategoryDesc:
//        returns the description of a given category.
//        rcatid:         category id.
//        lcid:           locale id.
//        ppszDesc        pointer to the description string to be returned.
//                        Allocated by the function. to be freed by client.
//--------------------------------------------------------------------------
HRESULT __stdcall CClassContainer::GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc)
{
    STRINGGUID    guidstr;
    ULONG         cdesc, i;
    LPOLESTR     *localedesc;
    IADs         *pADs;
    HRESULT       hr;

    if (!IsValidPtrOut(ppszDesc, sizeof(LPOLESTR)))
        return E_INVALIDARG;

    if (IsNullGuid(rcatid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    RdnFromGUID(rcatid, guidstr);
    hr = m_ADsCategoryContainer->GetObject(NULL, guidstr, (IDispatch **)&pADs);
    if (FAILED(hr))
        return CAT_E_CATIDNOEXIST;

    hr = GetPropertyListAlloc(pADs, LOCALEDESCRIPTION, &cdesc, &localedesc);
    if (hr == E_OUTOFMEMORY)
        return hr;

    if (FAILED(hr))
        return CAT_E_NODESCRIPTION;

    *ppszDesc = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR)*128);
    if (!(*ppszDesc))
        return E_OUTOFMEMORY;

    GetCategoryLocaleDesc(localedesc, cdesc, &lcid, *ppszDesc);

    for (i = 0; i < cdesc; i++)
        CoTaskMemFree(localedesc[i]);
    CoTaskMemFree(localedesc);
    pADs->Release();
    return S_OK;

} /* GetCategoryDesc */


//---------------------------------------------------------------
// EnumClassesOfCategories:
//        returns the enumerator for classes that implements given catids and
//                requires some given catids.
//
//        cImplemented    number of implemented categories.
//                        (0 is error and -1 is ignore implemented.
//        rgcatidImpl        list of implemented categories.
//                        should be NULL in the two cases mentioned above.
//
//        cRequired:        number of required categories.
//                        (0 is requiring nothing and -1 is ignore required.
//        rgcatidReq        list of required categories.
//                        should be NULL in the two cases mentioned above.
//
//        ppenumClsid        the enumerator of class ids.
//--------------------------------------------------------------------------

HRESULT __stdcall CClassContainer::EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[],
                                          ULONG cRequired, CATID rgcatidReq[],
                                          IEnumGUID **ppenumClsid)
{
    ULONG                          i;
    CSCEnumClassesOfCategories    *penumclasses;
    HRESULT                        hr;
    Data                          *pData;

    if (!IsValidPtrOut(ppenumClsid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;

    if ((rgcatidImpl == NULL) && (cImplemented != 0) && (cImplemented != -1))
        return E_INVALIDARG;

    if ((rgcatidReq == NULL) && (cRequired != 0) && (cRequired != -1))
        return E_INVALIDARG;

    if ((cImplemented == -1) && (rgcatidImpl != NULL))
        return E_POINTER;

    if ((cRequired == -1) && (rgcatidReq != NULL))
        return E_POINTER;

    if (cImplemented == 0)
        return E_INVALIDARG;

    if ((rgcatidImpl) && (!IsValidReadPtrIn(rgcatidImpl, sizeof(CATID)*cImplemented)))
    {
        return E_INVALIDARG;
    }

    if ((rgcatidReq) && (!IsValidReadPtrIn(rgcatidReq, sizeof(CATID)*cRequired)))
    {
        return E_INVALIDARG;
    }

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    penumclasses = new CSCEnumClassesOfCategories;
    if (!penumclasses)
    {
        return E_OUTOFMEMORY;
    }

    hr = penumclasses->Initialize(cRequired, rgcatidReq, cImplemented, rgcatidImpl,
                                 m_ADsClassContainer, (ICatInformation *)this);
    if (FAILED(hr))
    {
        delete penumclasses;
        return hr;
    }

    hr = penumclasses->QueryInterface(IID_IEnumCLSID, (void **)ppenumClsid);

    if (FAILED(hr))
    {
        delete penumclasses;
        return hr;
    }

    return hr;
} /* EnumClassesOfCategories */

//---------------------------------------------------------------
// EnumReqCategoriesOfClass:
//        see below EnumCategoriesofClass
//
//---------------------------------------------------------------

HRESULT CClassContainer::EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)

{
    if (!IsValidReadPtrIn(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(ppenumCatid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;

    return EnumCategoriesOfClass(rclsid, REQ_CATEGORIES, ppenumCatid);

} /* EnumReqClassesOfCategories */

//---------------------------------------------------------------
// EnumImplCategoriesOfClass:
//        see below EnumCategoriesofClass
//
//---------------------------------------------------------------
HRESULT CClassContainer::EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
    if (!IsValidReadPtrIn(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(ppenumCatid, sizeof(IEnumGUID *)))
        return E_INVALIDARG;

    return EnumCategoriesOfClass(rclsid, IMPL_CATEGORIES, ppenumCatid);

} /* EnumimplClassesOfCategories */

//---------------------------------------------------------------
// EnumCategoriesOfClass:
//        returns the enumerator for the implemented or required
//    rclsid:            the class id.
//    impl_or_req        the type of category to enumerated.
//    ppenumcatid        the enumerator that is returned.
// Prefetches all the catids and then enumerates them.
//---------------------------------------------------------------

HRESULT CClassContainer::EnumCategoriesOfClass(REFCLSID rclsid, BSTR impl_or_req,
                                               IEnumGUID **ppenumCatid)
{
    STRINGGUID                  szName;
    IADs                        *pADs = NULL;
    ULONG                        i;
    ULONG                        cCatid;
    CATID                       *Catid = NULL;
    CSCEnumCategoriesOfClass    *pEnumCatid;
    HRESULT                      hr = S_OK;

    if (!m_fOpen)
        return E_FAIL;

    // Get the ADs interface corresponding to the clsid that is mentioned.
    RdnFromGUID(rclsid, szName);

    hr = m_ADsClassContainer->GetObject(NULL,
                szName,
                (IDispatch **)&pADs
                );
    RETURN_ON_FAILURE(hr);

    hr = GetPropertyListAllocGuid(pADs, impl_or_req, &cCatid,  &Catid);
    pADs->Release();
    RETURN_ON_FAILURE(hr);

    pEnumCatid = new CSCEnumCategoriesOfClass;
    if (!pEnumCatid)
    {
        if (Catid)
            CoTaskMemFree(Catid);
        return E_OUTOFMEMORY;
    }

    hr = pEnumCatid->Initialize(Catid, cCatid);
    if (Catid)
        CoTaskMemFree(Catid);

    if (FAILED(hr)) {
        delete pEnumCatid;
        return hr;
    }

    return pEnumCatid->QueryInterface(IID_IEnumCATID, (void **)ppenumCatid);
}
//---------------------------------------------------------------
// IsClassOfCategories:
//    similar to EnumClassesOfCategories but returns S_OK/S_FALSE for the
//    clsid rclsid. Finds the first class that implements these categories
//    and is of this clsid and checks its required.
//---------------------------------------------------------------

HRESULT __stdcall CClassContainer::IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented,
                                      CATID __RPC_FAR rgcatidImpl[  ],
                                      ULONG cRequired, CATID __RPC_FAR rgcatidReq[ ])
{
    ULONG        cRead, i;
    Data         *pData;
    HRESULT       hr, hr1;

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (!IsValidPtrOut(this, sizeof(*this)))
        return E_ACCESSDENIED;

    if (cImplemented == 0)
        return E_INVALIDARG;

    if ((rgcatidImpl == NULL) && (cImplemented != 0) && (cImplemented != -1))
        return E_INVALIDARG;

    if ((rgcatidReq == NULL) && (cRequired != 0) && (cRequired != -1))
        return E_INVALIDARG;

    if ((cImplemented == -1) && (rgcatidImpl != NULL))
        return E_POINTER;

    if ((cRequired == -1) && (rgcatidReq != NULL))
        return E_POINTER;

    if ((rgcatidImpl) && (!IsValidReadPtrIn(rgcatidImpl, sizeof(CATID)*cImplemented)))
    {
        return E_INVALIDARG;
    }

    if ((rgcatidReq) && (!IsValidReadPtrIn(rgcatidReq, sizeof(CATID)*cRequired)))
    {
        return E_INVALIDARG;
    }

    hr = ImplSatisfied(rclsid, cImplemented, rgcatidImpl, this);
    RETURN_ON_FAILURE(hr);

    if (hr == S_OK)
    {
        hr = ReqSatisfied(rclsid, cRequired, rgcatidReq, this);
        RETURN_ON_FAILURE(hr);
    }

    if (hr != S_OK)
        return S_FALSE;
    return S_OK;
					
} /* IsClassOfCategories */


//--------------------------------------------------------------------------------
//    ReqSatisfied:
//        Returns S_OK/S_FALSE depending on whether the clsid satisfies the required
//        condition for the clsid.
//    clsid:                Class ID of the class.
//    cAvailReq:            Number of Available required classes.
//    AvailReq:            Avail required classes.
//    calls the enumerator and sees whether there is any required class not present in
//    the available list. returns S_OK if cAvailReq = -1.
//--------------------------------------------------------------------------------

HRESULT ReqSatisfied(CLSID clsid, ULONG cAvailReq, CATID *AvailReq,
               ICatInformation *pICatInfo)
{
    IEnumGUID *pIEnumCatid;
    ULONG      got, i;
    CATID      catid;
    HRESULT    hr;

    if (cAvailReq == -1)
        return S_OK;

    hr = pICatInfo->EnumReqCategoriesOfClass(clsid, &pIEnumCatid);
    if (FAILED(hr)) {
        return hr;
    }
    for (;;) {
        hr = pIEnumCatid->Next(1, &catid, &got);
        if (FAILED(hr)) {
            hr = S_FALSE;
            break;
        }

        if (!got) {
            hr = S_OK;
            break;
        }
	/// check if the required categories are available
        for (i = 0; i < cAvailReq; i++)
            if (IsEqualGUID(catid, AvailReq[i]))
                break;
        if (i == cAvailReq) {
            hr = S_FALSE;
            break;
        }
    }
    pIEnumCatid->Release();
    return hr;
}

//--------------------------------------------------------------------------------
//    Implements:
//        Returns S_OK/S_FALSE depending on whether the clsid satisfies the required
//        condition for the clsid.
//    clsid:                Class ID of the class.
//    cImplemented:         Number of Implemented categories.
//    ImplementedList:      Implemented Categories.
//    calls the enumerator and sees whether there is any required class not present in
//    the available list. returns S_OK if cImplemented = -1.
//--------------------------------------------------------------------------------
// BUGBUG:: This should return error when the enumerator return errors.

HRESULT ImplSatisfied(CLSID clsid, ULONG cImplemented, CATID *ImplementedList,
               ICatInformation *pICatInfo)
{
    IEnumGUID *pIEnumCatid;
    ULONG      got, i;
    CATID      catid;
    HRESULT    hr;

    if (cImplemented == -1)
        return S_OK;

    hr = pICatInfo->EnumImplCategoriesOfClass(clsid, &pIEnumCatid);
    if (FAILED(hr)) {
        return hr;
    }
    for (;;) {
        hr = pIEnumCatid->Next(1, &catid, &got);
        if (FAILED(hr)) {
            hr = S_FALSE;
            break;
        }

        if (!got) {
            hr = S_FALSE;
            break;
        }

	// check if it implements any of the categories requested.
        for (i = 0; i < cImplemented; i++)
            if (IsEqualGUID(catid, ImplementedList[i]))
                break;
        if (i < cImplemented) {
            hr = S_OK;
            break;
        }
    }
    pIEnumCatid->Release();
    return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\catreg.cxx ===
//
//  Author: ushaji
//  Date:   December/Jan 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for ICatRegister interfaces.                             
//
//      Refer Doc "Design for Support of File Types and Component Categories
//    in Class Store" ? (or may be Class Store Schema)
//
//----------------------------------------------------------------------------

#include "cstore.hxx"

//-------------------------------------------------------------
// RegisterCategories:
//        registering categories in the class store.
//        cCategories:        Number of Categories
//        rgCategoryInfo:        Size cCategories
//
// Returns as soon as one of them fails.
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CClassContainer::RegisterCategories(
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ])
{
    /* Registering a list of Category ID in the Class Store */

    HRESULT           hr;
    IADs             *pADs = NULL;
    IDispatch        *pUnknown = NULL;
    STRINGGUIDRDN     szCatid;
    ULONG             i, j, cdesc, posn;
    LPOLESTR         *pszDescExisting, *pszDesc;
    WCHAR            *localedescription = NULL;
                      // sizeof description + seperator length + locale in hex

    /* BUGBUG::Should check whether write permissions exist? */
    if (!IsValidReadPtrIn(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }

    if (!IsValidReadPtrIn(rgCategoryInfo, sizeof(rgCategoryInfo[0])*cCategories))
    {
        return E_INVALIDARG; // gd
    }

    if (!m_fOpen)
        return E_FAIL;

    for (i = 0; i < cCategories; i++)
    {
        localedescription = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR)*(128+16));
        if (!localedescription)
            return E_OUTOFMEMORY;

        RdnFromGUID(rgCategoryInfo[i].catid, szCatid);

        wsprintf(localedescription, L"%x %s %s", rgCategoryInfo[i].lcid, CATSEPERATOR,
                                                rgCategoryInfo[i].szDescription);

        hr = m_ADsCategoryContainer->GetObject(NULL, szCatid, (IDispatch **)&pADs);

        if (SUCCEEDED(hr))
        {
                hr = GetPropertyListAlloc (pADs, LOCALEDESCRIPTION, &cdesc, &pszDescExisting);
                RETURN_ON_FAILURE(hr);
                            // Existing list of descriptions

                pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(cdesc+1));
                if (!pszDesc)
                        return E_OUTOFMEMORY;
                for (j = 0; j < cdesc; j++)
                        pszDesc[j] = pszDescExisting[j];

                if (!(posn = FindDescription(pszDescExisting, cdesc, &(rgCategoryInfo[i].lcid), NULL, 0)))
                {
                            // if no description exists for the lcid.
                    pszDesc[cdesc] = localedescription;
                    cdesc++;
                }
                else
                {   // overwrite the old value
                    CoTaskMemFree(pszDesc[posn-1]);
                    pszDesc[posn-1] = localedescription;
                }
        }
        else
        {
                hr = m_ADsCategoryContainer->Create(
                        CLASS_CS_CATEGORY,
                        szCatid,
                        &pUnknown
                        );

                RETURN_ON_FAILURE(hr);
                pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
                if (!pszDesc)
                        return E_OUTOFMEMORY;
                cdesc = 1;
                pszDesc[0] = localedescription;

                hr = pUnknown->QueryInterface(IID_IADs, (void **)&pADs);
                RETURN_ON_FAILURE(hr);

                pUnknown->Release();
        }

//        StringFromGUID(rgCategoryInfo[i].catid, szCatid);
//        SetProperty(pADs, CATEGORYCATID, szCatid);
        hr = SetPropertyGuid(pADs, CATEGORYCATID, rgCategoryInfo[i].catid);
        RETURN_ON_FAILURE(hr);

        SetPropertyList(pADs, LOCALEDESCRIPTION, cdesc, pszDesc);
        for (j = 0; j < cdesc; j++)
                CoTaskMemFree(pszDesc[j]);
        CoTaskMemFree(pszDesc);
        RETURN_ON_FAILURE(hr);

        hr = StoreIt (pADs);
        RETURN_ON_FAILURE(hr);

        pADs->Release();
    }
    return hr;
} /* RegisterCategories */


//--------------------------------------------------------
// Unregistering categories from the class store
//        cCategories:        Number of Categories
//        rgcatid:            catids of the categories.
//
// Stops after any one of them returns a error.
// Doesn't remove the category ids from each of the class ids.

HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterCategories(
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    STRINGGUIDRDN   szCatid;
    ULONG           i;
    HRESULT         hr;


    if (!IsValidPtrOut(this, sizeof(*this))){
        return E_ACCESSDENIED;
    }
    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG;
    }
    // Checking whether the caller has permissions

    if (!m_fOpen)
        return E_FAIL;

    for (i = 0; i < cCategories; i++)
    {
        RdnFromGUID(rgcatid[i], szCatid);

        hr = m_ADsCategoryContainer->Delete(CLASS_CS_CATEGORY,
                                        szCatid);
    }
    return S_OK;
} /* UnRegisterCategories */

//------------------------------------------------------------------
// RegisterClassXXXCategories:
//        rclsid:            This category will be registered with this clsid.
//        cCategories:    The number of categories to be added.
//        rgcatid            The categories to be added (cCategories)
//        impl_or_req        The property to which this category will be added.
//                            "Implemented Categories" or "Required Categories"
//
//
// add all the categories given to the class store for this class.
// The previous entries will be lost and on error it would not be
// restored or made empty. A PRIVATE METHOD called by the 2 public methods.
//------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CClassContainer::RegisterClassXXXCategories(
           /* [in] */ REFCLSID rclsid,
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ],BSTR impl_or_req)
{
    HRESULT       hr;
    STRINGGUIDRDN szName;
    IADs         *pADs = NULL;
    ULONG         i, j, tobeadded;
    VARIANT       Var;
    GUID         *pCatids, *pOldCatids=NULL;
    IDispatch    *pUnknown = NULL;
    STRINGGUID    szGUID;

    if (!m_fOpen)
        return E_FAIL;

    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }

    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG; // gd
    }

    if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    // Get the ADs interface corresponding to the clsid that is mentioned.
    StringFromGUID(rclsid, szGUID);
    wsprintf(szName, L"CN=%s", szGUID);

    hr = m_ADsClassContainer->GetObject(NULL,
                szName,
                (IDispatch **)&pADs
                );

    // if it didn't exist create it.
    if (FAILED(hr)) {
        hr = m_ADsClassContainer->Create(
                            CLASS_CS_CLASS,
                            szName,
                            &pUnknown
                            );
    
        RETURN_ON_FAILURE(hr);
    
        hr = pUnknown->QueryInterface(
                                IID_IADs,
                                (void **)&pADs
                                );
    
        pUnknown->Release();
    }
    
    hr = SetProperty (pADs, CLASSCLSID, szGUID);
    RETURN_ON_FAILURE(hr);

    hr = GetPropertyListAllocGuid(pADs, impl_or_req, &tobeadded, &pOldCatids);
    RETURN_ON_FAILURE(hr);

    pCatids = (GUID *)CoTaskMemAlloc(sizeof(GUID)*(tobeadded+cCategories));
    if (!pCatids)
        return E_OUTOFMEMORY;

    for (i = 0; i < tobeadded; i++)
        pCatids[i] = pOldCatids[i];

    for (i=0; i < cCategories; ++i) {
        for (j = 0; j < tobeadded; j++)
        {
            if (memcmp(&rgcatid[i], &pCatids[j], sizeof(GUID)) == 0)
                break;
        }
        if (j < tobeadded)
            continue;
        // The ith element is already there in the array.
        // Make sure of this when the property name changes.

        pCatids[tobeadded] = rgcatid[i];
        tobeadded++;
    }

    VariantInit(&Var);
    hr = PackGuidArray2Variant(pCatids, tobeadded, &Var);
    RETURN_ON_FAILURE(hr);

    if (tobeadded)
        hr = pADs->Put(impl_or_req, Var);
    else
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, impl_or_req, Var);

    RETURN_ON_FAILURE(hr);

    VariantClear(&Var);

    // save the data modified
    hr = StoreIt(pADs);
    pADs->Release();

    CoTaskMemFree(pCatids);
    if (pOldCatids)
        CoTaskMemFree(pOldCatids);
    return hr;
} /* RegisterClassXXXCategories */


//---------------------------------------------------------------------
// UnRegisterClassXXXCategories
//        rclsid:            classid from which the categories have to be removed.
//        cCategories:    Number of Categories
//        rgcatid:        Categories
//        impl_or_req:    The property to which this has to be added.
//
// Presently gets all the categories from the class. parses through it
// removes the ones that match in rgcatid and reregister the category.
//---------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterClassXXXCategories(
           /* [in] */ REFCLSID rclsid,
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ],BSTR impl_or_req)
{
    HRESULT       hr;
    STRINGGUIDRDN szName;
    IADs         *pADs = NULL;
    ULONG         i, j;
    ULONG         cNewCatids, cOldCatids;
    VARIANT       Var;
    GUID         *pOldCatids=NULL, *pNewCatids;

   // BUGBUG:: Have to decide some way of removing clsids once all categories
   //          are unregistered.

   if (!m_fOpen)
        return E_FAIL;

   if (IsNullGuid(rclsid))
        return E_INVALIDARG;

    if (cCategories == 0)
        return S_OK;

    if (!IsValidPtrOut(this, sizeof(*this))) {
        return E_ACCESSDENIED;
    }

    if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories)){
        return E_INVALIDARG; // gd
    }

    if (cCategories == 0)
        return S_OK;

    // Get all the catids corresp to this clsid.
    // Get the ADs interface corresponding to the clsid that is mentioned.
    RdnFromGUID(rclsid, szName);
    hr = m_ADsClassContainer->GetObject(NULL,
                szName,
                (IDispatch **)&pADs
                );

    RETURN_ON_FAILURE(hr);

    hr = GetPropertyListAllocGuid(pADs,
              impl_or_req,
              &cOldCatids,
              &pOldCatids);

    RETURN_ON_FAILURE(hr);

    // parse through this list and delete all the catids that is part of
    // the user supplied list.

    pNewCatids = (GUID *)CoTaskMemAlloc(sizeof(GUID)*cOldCatids);
    if (!pNewCatids)
        return E_OUTOFMEMORY;

    for (i = 0, cNewCatids = 0; i < cOldCatids; i++)
    {
        for (j = 0; j < cCategories; j++)
            if (memcmp(&pOldCatids[i], &rgcatid[j], sizeof(GUID)) == 0)
                break;
        if (j == cCategories)
            pNewCatids[cNewCatids++] = pOldCatids[i];
    }

    // reregister this.

    VariantInit(&Var);
    hr = PackGuidArray2Variant(pNewCatids, cNewCatids, &Var);
    RETURN_ON_FAILURE(hr);

    if (cNewCatids)
        hr = pADs->Put(impl_or_req, Var);
    else
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, impl_or_req, Var);

    RETURN_ON_FAILURE(hr);

    VariantClear(&Var);

    // save the data modified
    hr = StoreIt(pADs);
    pADs->Release();

    CoTaskMemFree(pNewCatids);
    if (pOldCatids)
        CoTaskMemFree(pOldCatids);

    return hr;
} /* UnRegisterClassXXXCategories */



HRESULT STDMETHODCALLTYPE CClassContainer::RegisterClassImplCategories(
           /* [in] */ REFCLSID rclsid,
           /* [in] */ ULONG cCategories,
           /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                        IMPL_CATEGORIES);
} /* RegisterClassImplCategories */


HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterClassImplCategories(
          /* [in] */ REFCLSID rclsid,
          /* [in] */ ULONG cCategories,
          /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{

    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                        IMPL_CATEGORIES);

} /* UnRegisterClassImplCategories */




HRESULT STDMETHODCALLTYPE CClassContainer::RegisterClassReqCategories(
          /* [in] */ REFCLSID rclsid,
          /* [in] */ ULONG cCategories,
          /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                    REQ_CATEGORIES);

} /* RegisterClassReqCategories */




HRESULT STDMETHODCALLTYPE CClassContainer::UnRegisterClassReqCategories(
          /* [in] */ REFCLSID rclsid,
          /* [in] */ ULONG cCategories,
          /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid,
                                        REQ_CATEGORIES);

} /* UnRegisterClassReqCategories */



//--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\csdsadm.cxx ===
//
//  Author: DebiM
//  Date:   January 97
//
//
//      Class Store Administration Implementation
//
//      This source file contains implementations for
//      IClassAdmin interface.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------

#include "cstore.hxx"
void GetCurrentUsn(LPOLESTR pStoreUsn);

//----------------------------------------------------------
// Implementation for CClassContainer
//----------------------------------------------------------
//
CClassContainer::CClassContainer()

{
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_pADsClassStore = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_ADsCategoryContainer = NULL;
    
    m_uRefs = 1;
    StartQuery(&m_pIDBCreateCommand);
}


//
// CClassContainer implementation
//
CClassContainer::CClassContainer(LPOLESTR szStoreName,
                                 HRESULT  *phr)
                                 
{
    IADs        *pADs = NULL;
    LPOLESTR    pszName = NULL;
    DWORD       dwStoreVersion = 0;
    
    *phr = S_OK;
    
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_pADsClassStore = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_ADsCategoryContainer = NULL;
    
    //
    // For every interface pointer, we create a separate Query session
    //
    StartQuery(&m_pIDBCreateCommand);
    
    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);
    
    *phr = ADsGetObject(
        szStoreName,
        IID_IADsContainer,
        (void **)&m_ADsContainer
        );
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Check the Schema Version of this container
    //
    
    *phr = m_ADsContainer->QueryInterface (IID_IADs, (void **)&m_pADsClassStore);
    if (!SUCCEEDED(*phr))
        return;
    
    *phr = GetPropertyDW (m_pADsClassStore, STOREVERSION, &dwStoreVersion);
    
    if ((!SUCCEEDED(*phr)) ||
        (dwStoreVersion != SCHEMA_VERSION_NUMBER))
    {
        *phr = CS_E_INVALID_VERSION;
        return;
    }
    
    //
    // Bind to the class container Object
    // Cache the interface pointer
    //
    
    m_ADsClassContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        CLASSCONTAINERNAME,
        (IDispatch **)&pADs
        );
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsClassContainer
        );
    
    *phr = pADs->get_ADsPath(&pszName);
    wcscpy (m_szClassName, pszName);
    SysFreeString(pszName);
    
    pADs->Release();
    pADs = NULL;
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    m_ADsPackageContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        PACKAGECONTAINERNAME,
        (IDispatch **)&pADs);
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsPackageContainer
        );
    
    *phr = pADs->get_ADsPath(&pszName);
    wcscpy (m_szPackageName, pszName);
    SysFreeString(pszName);
    pADs->Release();
    pADs = NULL;
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Bind to the category container Object
    // Cache the interface pointer
    //
    m_ADsCategoryContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        CATEGORYCONTAINERNAME,
        (IDispatch **)&pADs);
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsCategoryContainer
        );
    
    pADs->Release();
    pADs = NULL;
    
    m_fOpen = TRUE;
    m_uRefs = 1;
    return;
}


CClassContainer::~CClassContainer(void)
{
    UINT i;
    
    EndQuery(m_pIDBCreateCommand);
    m_pIDBCreateCommand = NULL;
    
    
    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }
    
    if (m_ADsClassContainer)
    {
        m_ADsClassContainer->Release();
        m_ADsClassContainer = NULL;
    }
    
    if (m_ADsPackageContainer)
    {
        m_ADsPackageContainer->Release();
        m_ADsPackageContainer = NULL;
    }
    
    if (m_ADsCategoryContainer)
    {
        m_ADsCategoryContainer->Release();
        m_ADsCategoryContainer = NULL;
    }
    
    if (m_ADsContainer)
    {
        m_ADsContainer->Release();
        m_ADsContainer = NULL;
    }
    
    if (m_pADsClassStore)
    {
        m_pADsClassStore->Release();
        m_pADsClassStore = NULL;
    }
    
}


//
// Removing a class from the database
//

HRESULT CClassContainer::DeleteClass (LPOLESTR szClsid)
{
    
    WCHAR       szName[_MAX_PATH];
    HRESULT         hr = S_OK;
    IADs       *pADs = NULL;
    DWORD       refcount = 0;
    
    if (!m_fOpen)
        return E_FAIL;
    
    wsprintf(szName, L"CN=%s", szClsid);
    hr = m_ADsClassContainer->GetObject(NULL, szName, (IDispatch **)&pADs);
    
    if (SUCCEEDED(hr))
        hr = GetPropertyDW(pADs, CLASSREFCOUNTER, &refcount);
    
    if (refcount <= 1)
        hr = m_ADsClassContainer->Delete(CLASS_CS_CLASS, szName);
    else {
        refcount--;
        hr = SetPropertyDW(pADs, CLASSREFCOUNTER, refcount);
        
        if (SUCCEEDED(hr))
            hr = StoreIt(pADs);
    }
    
    if (pADs)
        pADs->Release();
    return hr;
}


extern LPOLESTR szPackageInfoColumns;

HRESULT CClassContainer::EnumPackages(
                                      LPOLESTR         pszFileExt,
                                      GUID             *pCategory,
                                      DWORD            dwAppFlags,
                                      DWORD            *pdwLocale,
                                      CSPLATFORM       *pPlatform,
                                      IEnumPackage     **ppIEnumPackage
                                      )
{
    HRESULT                 hr = S_OK;
    CEnumPackage           *pEnum = NULL;
    WCHAR           szCommand[1000], szQry[1000];
    
    if (pszFileExt && IsBadStringPtr(pszFileExt, _MAX_PATH))
        return E_INVALIDARG;
    
    if (pCategory && !IsValidReadPtrIn(pCategory, sizeof(GUID)))
        return E_INVALIDARG;
    
    if (!IsValidPtrOut(ppIEnumPackage, sizeof(IEnumPackage *)))
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    pEnum = new CEnumPackage;
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a CommandText
    //
    
    wsprintf(szCommand, L"<%s>;(& (objectClass=packageRegistration) ", m_szPackageName);
    
    if (pszFileExt)
    {
        wsprintf(szQry, L"(%s=%s*) ", PKGFILEEXTNLIST, pszFileExt);
        wcscat(szCommand, szQry);
    }
    
    if (pCategory) 
    {
        STRINGGUID szCat;
        StringFromGUID (*pCategory, szCat);
        wsprintf(szQry, L"(%s=%s) ", PKGCATEGORYLIST, szCat);
        wcscat(szCommand, szQry);
    }
    
    wcscat(szCommand, L");");
    
    wsprintf(szQry, L" %s", szPackageInfoColumns);
    wcscat(szCommand, szQry);
    
    hr = pEnum->Initialize(szCommand, dwAppFlags, pdwLocale, pPlatform);
    
    if (FAILED(hr)) {
        delete pEnum;
        return hr;
    }
    
    hr = pEnum->QueryInterface(IID_IEnumPackage, (void**)ppIEnumPackage);
    
    return hr;
}

// GetPackageDetails
//  pszPackageName  :   name of the package to be got.
//  pInstallInfo    :   InstallInfo to be filled in. ignored if NULL.
//  pPlatformInfo   :   PlatformInfo to be filled in. ignored if NULL.
// both can be sent in as NULL to check whether package exists or not.


HRESULT CClassContainer::GetPackageDetails (
                          LPOLESTR        pszPackageName,
                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
    
    hr = GetPackageDetail (pPackageADs, pPackageDetail);
    return hr;
}


HRESULT CClassContainer::ChangePackageProperties(
                LPOLESTR       pszPackageName,
                LPOLESTR       pszNewName,
                DWORD         *pdwFlags,
                LPOLESTR       pszUrl,
                LPOLESTR       pszScriptPath,
                UINT          *pInstallUiLevel
                )
{
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    WCHAR       szNewRdn [_MAX_PATH];
    LPOLESTR    pszPackageDN;
    WCHAR       Usn[20];
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);

    if (pszNewName)
    {
        //
        // rename package
        //
    
        if (IsBadStringPtr(pszNewName, _MAX_PATH))
            return E_INVALIDARG;
    
        //
        // Check to see if any other change is requested.
        //

        if (pszScriptPath   ||
            pszUrl          ||
            pdwFlags        ||
            pInstallUiLevel)
            return E_INVALIDARG;

        BuildADsPathFromParent (m_szPackageName, szRdn, &pszPackageDN);
        wcscpy (szNewRdn, L"CN=");
        wcscat (szNewRdn, pszNewName);
        hr = m_ADsPackageContainer->MoveHere(pszPackageDN, szNewRdn, (IDispatch **)&pPackageADs);
        FreeADsMem(pszPackageDN);
        
        if (SUCCEEDED(hr))
        {
        hr = SetProperty(pPackageADs, PACKAGENAME, pszNewName);
        if (SUCCEEDED(hr))
        hr = StoreIt(pPackageADs);    
            pPackageADs->Release();
        }
        return hr;
    }
    
    if (!(pszScriptPath   ||
        pszUrl            ||
        pdwFlags          ||
        pInstallUiLevel))
        return E_INVALIDARG;

    //
    // No rename.
    // Just change some properties.
    //
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
    //
    // Update the TimeStamp
    //
    GetCurrentUsn(&Usn[0]);
    hr = UsnUpd(pPackageADs, PKGUSN, &Usn[0]);
    ERROR_ON_FAILURE(hr);
    
    //
    // Change Package Flags
    //
    if (pdwFlags)
    {
        hr = SetPropertyDW (pPackageADs, PACKAGEFLAGS, *pdwFlags);
        ERROR_ON_FAILURE(hr);
    }

    //
    // Change Package Script
    //
    if (pszScriptPath) 
    {
        hr = SetProperty(pPackageADs, SCRIPTPATH, pszScriptPath);
        ERROR_ON_FAILURE(hr);
    }
        
    //
    // Change Package Help URL
    //
    if (pszUrl) 
    {
        hr = SetProperty(pPackageADs, HELPURL, pszUrl);
        ERROR_ON_FAILURE(hr);
    }

    //
    // Change UI Level
    //
    if (pInstallUiLevel) 
    {
        hr = SetPropertyDW (pPackageADs, UILEVEL, *pInstallUiLevel);
        ERROR_ON_FAILURE(hr);
    }

    hr = StoreIt(pPackageADs);    
    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
        
}


HRESULT CClassContainer::ChangePackageCategories(
                LPOLESTR       pszPackageName,
                UINT           cCategories,
                GUID          *rpCategory
                )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    LPOLESTR    *pszGuid = NULL;
    UINT        count;
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    if ((!cCategories) ||
        (!rpCategory) ||
        (!IsValidReadPtrIn(rpCategory, sizeof(GUID) * cCategories)))    
              return E_INVALIDARG;

    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
    
    // fill in the categories
    pszGuid = (LPOLESTR *)CoTaskMemAlloc(cCategories * sizeof(LPOLESTR));
    if (!pszGuid) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }
        
    
    for (count = 0; (count < cCategories); count++) 
    {
        pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
        {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        StringFromGUID(rpCategory[count], pszGuid[count]);
    }
        
    hr = SetPropertyList(pPackageADs, PKGCATEGORYLIST, cCategories,
            pszGuid);
    ERROR_ON_FAILURE(hr);
        
    for (count = 0; (count < cCategories); count++)
        CoTaskMemFree(pszGuid[count]);
        
    CoTaskMemFree(pszGuid);
    hr = StoreIt(pPackageADs);    
    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
}



HRESULT CClassContainer::SetPriorityByFileExt(
                                              LPOLESTR pszPackageName,
                                              LPOLESTR pszFileExt,
                                              UINT     Priority
                                              )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    LPOLESTR    *prgFileExt = NULL;
    ULONG       cShellFileExt;
    UINT        i;
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return CS_E_PACKAGE_NOTFOUND;
        
    hr = GetPropertyListAlloc (pPackageADs, PKGFILEEXTNLIST,
            &cShellFileExt,
            &prgFileExt);

    for (i=0; i < cShellFileExt; ++i)
    {
        if (wcsncmp(prgFileExt[i], pszFileExt, wcslen(pszFileExt)) == 0)
        {
            wsprintf(prgFileExt[i], L"%s:%2d", 
                pszFileExt, 
                Priority);
            break;
        }
    }
    
    if (i == cShellFileExt)
    {
        hr = CS_E_PACKAGE_NOTFOUND;
        ERROR_ON_FAILURE(hr);
    }

    hr = SetPropertyList(pPackageADs, PKGFILEEXTNLIST, cShellFileExt, prgFileExt);

    hr = StoreIt(pPackageADs);    
    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
}



extern LPOLESTR szAppCategoryColumns;

HRESULT CClassContainer::GetAppCategories (
                                           LCID              Locale,
                                           APPCATEGORYINFOLIST  *pAppCategoryList
                                           )
{
    HRESULT      hr = S_OK;
    WCHAR        szCommand[1000], szQry[1000];
    WCHAR        szRootPath[_MAX_PATH],
        szAppCategoryContainer[_MAX_PATH];
    IRowset            * pIRow = NULL;
    HACCESSOR            HAcc;
    IAccessor          * pIAccessor = NULL;
    IDBCreateCommand   * pIDBCreateCommand = NULL;
    LPOLESTR      ** ppszDesc = NULL;
    DWORD        cgot = 0;
    
    if (!IsValidPtrOut(pAppCategoryList, sizeof(APPCATEGORYINFOLIST)))
        return E_INVALIDARG;
    
    hr = GetRootPath(szRootPath);
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX,
        APPCATEGORYCONTAINERNAME, szRootPath+wcslen(LDAPPREFIX));
    
    wsprintf(szCommand, L"<%s>; (objectClass=categoryRegistration); %s", szAppCategoryContainer,
        szAppCategoryColumns);
    
    hr = StartQuery(&(pIDBCreateCommand));
    RETURN_ON_FAILURE(hr);
    
    hr = ExecuteQuery (pIDBCreateCommand,
        szCommand,
        APPCATEGORY_COLUMN_COUNT,
        NULL,
        &HAcc,
        &pIAccessor,
        &pIRow
        );
    
    RETURN_ON_FAILURE(hr);
    
    pAppCategoryList->cCategory = 500;
    // upper limit presently.
    
    hr = FetchCategory(pIRow,
        HAcc,
        (pAppCategoryList->cCategory),
        &cgot,
        &(pAppCategoryList->pCategoryInfo),
        Locale);
    
    pAppCategoryList->cCategory = cgot;
    
    CloseQuery(pIAccessor,
        HAcc,
        pIRow);
    
    EndQuery(pIDBCreateCommand);
    
    return hr;
}



HRESULT CClassContainer::RegisterAppCategory (
                 APPCATEGORYINFO    *pAppCategory           
                 )
{
    WCHAR       szRootPath[_MAX_PATH], *localedescription = NULL,
                szAppCategoryContainer[_MAX_PATH], szRDN[_MAX_PATH];
    HRESULT     hr = S_OK;
    IADsContainer      *pADsContainer = NULL;
    IADs               *pADs = NULL;
    IDispatch          *pUnknown = NULL;
    ULONG               i, j, cdesc, posn;
    LPOLESTR           *pszDescExisting = NULL, *pszDesc = NULL;


    if (!pAppCategory || !IsValidReadPtrIn(pAppCategory, sizeof(APPCATEGORYINFO)))
        return E_INVALIDARG;

    if ((pAppCategory->pszDescription == NULL) || 
        IsBadStringPtr(pAppCategory->pszDescription, _MAX_PATH))
        return E_INVALIDARG;

    if (IsNullGuid(pAppCategory->AppCategoryId))
        return E_INVALIDARG;

    hr = GetRootPath(szRootPath);

    // Bind to a AppCategory container
    wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX,
             APPCATEGORYCONTAINERNAME, szRootPath+wcslen(LDAPPREFIX));

    hr = ADsGetObject(
                szAppCategoryContainer,
                IID_IADsContainer,
                (void **)&pADsContainer
                );
    RETURN_ON_FAILURE(hr);

    RdnFromGUID(pAppCategory->AppCategoryId, szRDN);

    localedescription = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*(128+16));

    wsprintf(localedescription, L"%x %s %s", pAppCategory->Locale, CATSEPERATOR,
                        pAppCategory->pszDescription);

    hr = pADsContainer->GetObject(NULL, szRDN, (IDispatch **)&pADs);

    if (SUCCEEDED(hr))
    {
       hr = GetPropertyListAlloc (pADs, LOCALEDESCRIPTION, &cdesc, &pszDescExisting);
       ERROR_ON_FAILURE(hr);
       // Existing list of descriptions

       pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*(cdesc+1));
       if ((cdesc) && (!pszDesc)) {
      hr = E_OUTOFMEMORY;
      ERROR_ON_FAILURE(hr);
       }

       for (j = 0; j < cdesc; j++)
      pszDesc[j] = pszDescExisting[j];

       if (!(posn = FindDescription(pszDescExisting, cdesc, &(pAppCategory->Locale), NULL, 0)))
       {
      // if no description exists for the lcid.
      pszDesc[cdesc] = localedescription;
      cdesc++;
       }
       else
       {   // overwrite the old value
      CoTaskMemFree(pszDesc[posn-1]);
      pszDesc[posn-1] = localedescription;
       }
    }
    else
    {
       hr = pADsContainer->Create(
            CLASS_CS_CATEGORY,
            szRDN,
            &pUnknown
            );
       ERROR_ON_FAILURE(hr);

       pszDesc = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR));
       if (!pszDesc) {
      hr = E_OUTOFMEMORY;
      ERROR_ON_FAILURE(hr);
       }

       cdesc = 1;
       pszDesc[0] = localedescription;

       hr = pUnknown->QueryInterface(IID_IADs, (void **)&pADs);
       RETURN_ON_FAILURE(hr);

       pUnknown->Release();
    }

    hr = SetPropertyGuid(pADs, CATEGORYCATID, pAppCategory->AppCategoryId);
    ERROR_ON_FAILURE(hr);

    hr = SetPropertyList(pADs, LOCALEDESCRIPTION, cdesc, pszDesc);
    for (j = 0; j < cdesc; j++)
        CoTaskMemFree(pszDesc[j]);
    CoTaskMemFree(pszDesc);
    ERROR_ON_FAILURE(hr);

    hr = StoreIt(pADs);
    ERROR_ON_FAILURE(hr);

Error_Cleanup:

    if (pADs)
       pADs->Release();

    if (pADsContainer)
       pADsContainer->Release();

    // Add this category.
    return hr;
}


HRESULT CClassContainer::UnregisterAppCategory (
                 GUID         *pAppCategoryId
                 )
{
   WCHAR        szRootPath[_MAX_PATH], szRDN[_MAX_PATH],
            szAppCategoryContainer[_MAX_PATH];
   HRESULT      hr = S_OK;
   IADsContainer       *pADsContainer = NULL;

   if (!IsValidReadPtrIn(pAppCategoryId, sizeof(GUID)))
       return E_INVALIDARG;

   hr = GetRootPath(szRootPath);
   // Bind to a AppCategory container
   wsprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX,
            APPCATEGORYCONTAINERNAME, szRootPath+wcslen(LDAPPREFIX));

   hr = ADsGetObject(
           szAppCategoryContainer,
           IID_IADsContainer,
           (void **)&pADsContainer
           );

   RETURN_ON_FAILURE(hr);

   RdnFromGUID(*pAppCategoryId, szRDN);

   hr = pADsContainer->Delete(CLASS_CS_CATEGORY, szRDN);
   pADsContainer->Release();

   // Delete this category

   return hr;
}


//+

HRESULT CClassContainer::RemovePackage (LPOLESTR    pszPackageName)
//
// Remove a Package and the associated Classes from class store
//
{
    HRESULT     hr = S_OK;
    IADs       *pADs = NULL;
    DWORD       cClasses = 0, count = 0;
    WCHAR       szRdn [_MAX_PATH];
    LPOLESTR   *szClasses;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;
    
    if ((pszPackageName == NULL) ||
        (*(pszPackageName) == NULL))
        return E_INVALIDARG;
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    if (!m_fOpen)
        return E_FAIL;
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pADs);
    RETURN_ON_FAILURE(hr);
    
    hr = GetPropertyListAlloc(pADs, PKGCLSIDLIST, &cClasses, &szClasses);
    
    for (count = 0; count < cClasses; count++)
        hr = DeleteClass(szClasses[count]);
    // ignore errors
    
    for (count = 0; count < cClasses; count++)
        CoTaskMemFree(szClasses[count]);
    CoTaskMemFree(szClasses);
    
    pADs->Release();
    
    hr = m_ADsPackageContainer->Delete(CLASS_CS_PACKAGE, szRdn);
    return hr;
}

//+

HRESULT CClassContainer::NewClass (CLASSDETAIL *pClassDetail)

//
// Add a new class to the database
//
{
    HRESULT         hr = S_OK;
    IADs          * pADs = NULL;
    IDispatch     * pUnknown = NULL;
    STRINGGUID      szGUID;
    WCHAR           szRDN [_MAX_PATH];
    
    if (!m_fOpen)
        return E_FAIL;
    
    //
    // Cant be a NULL guid
    //
    if (IsNullGuid(pClassDetail->Clsid))
        return E_INVALIDARG;
    
    StringFromGUID(pClassDetail->Clsid, szGUID);
    
    //
    // Create the RDN for the Class Object
    //
    
    // BUGBUG:: attaching package name creates problems.
    wsprintf(szRDN, L"CN=%s", szGUID);
    
    hr = m_ADsClassContainer->Create(
        CLASS_CS_CLASS,
        szRDN,
        &pUnknown
        );
    
    RETURN_ON_FAILURE(hr);
    
    hr = pUnknown->QueryInterface(
        IID_IADs,
        (void **)&pADs
        );
    
    pUnknown->Release();
    
    hr = SetProperty (pADs, CLASSCLSID, szGUID);
    ERROR_ON_FAILURE(hr);
    
    if (pClassDetail->cProgId)
    {
        hr = SetPropertyList(pADs, PROGIDLIST, pClassDetail->cProgId,
            pClassDetail->prgProgId);
        
        ERROR_ON_FAILURE(hr);
    }
    
    if (!IsNullGuid(pClassDetail->TreatAs))
    {
        StringFromGUID(pClassDetail->TreatAs, szGUID);
        hr = SetProperty (pADs, TREATASCLSID, szGUID);
        ERROR_ON_FAILURE(hr);
    }
    
    hr = SetPropertyDW(pADs, CLASSREFCOUNTER, 1);
    ERROR_ON_FAILURE(hr);
    
    hr = StoreIt (pADs);
    
    // this does not return an error for an alreay existing entry.
    
    if (hr == E_ADS_LDAP_ALREADY_EXISTS)
    {
        
        DWORD refcount = 0;
        
        pADs->Release(); // release the interface pointer already got.
        
        hr = m_ADsClassContainer->GetObject(NULL, // CLASS_CS_CLASS
            szRDN,
            (IDispatch **)&pADs);
        RETURN_ON_FAILURE(hr);
        
       if (pClassDetail->cProgId)
        {
            hr = SetPropertyListMerge(pADs, PROGIDLIST, pClassDetail->cProgId,
                pClassDetail->prgProgId);
            ERROR_ON_FAILURE(hr);
        }
        
        // increment reference counter.
        hr = GetPropertyDW(pADs, CLASSREFCOUNTER, &refcount);
        ERROR_ON_FAILURE(hr);
        
        refcount++;
        
        hr = SetPropertyDW(pADs, CLASSREFCOUNTER, refcount);
        ERROR_ON_FAILURE(hr);
        
        // No merging of the treatas.
        
        hr = StoreIt(pADs);
    }
    
Error_Cleanup:
    
    pADs->Release();
    return hr;
    
}

#define SCRIPT_IN_DIRECTORY    256


HRESULT CClassContainer::AddPackage(LPOLESTR       pszPackageName,
                                    PACKAGEDETAIL *pPackageDetail)
{
    HRESULT     hr;
    IADs       *pPackageADs = NULL;
    IDispatch  *pUnknown = NULL;
    WCHAR       szRDN [_MAX_PATH];
    LPOLESTR   *pszGuid, *pszProgId;
    DWORD      *pdwArch=NULL, count = 0, cPackProgId = 0;
    WCHAR      Usn[20];
    
    if (!pszPackageName)
        return E_INVALIDARG;
    
    if (!pPackageDetail)
        return E_INVALIDARG;
    
   if (!IsValidReadPtrIn(pPackageDetail, sizeof(PACKAGEDETAIL)))
       return E_INVALIDARG;

   LPWSTR pName = pszPackageName;
   while (*pName)
   {
        if ((*pName == L':') ||
            (*pName == L',') ||
            (*pName == L';') ||
            (*pName == L'/') ||
            (*pName == L'<') ||
            (*pName == L'>') ||
            (*pName == L'\\'))
            return E_INVALIDARG;
        ++pName;
   }

   // Validating ActivationInfo

   if (pPackageDetail->pActInfo)
   {
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo, sizeof(ACTIVATIONINFO)))
           return E_INVALIDARG;

       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->pClasses,
           sizeof(CLASSDETAIL) * (pPackageDetail->pActInfo->cClasses)))
           return E_INVALIDARG;
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgShellFileExt,
           sizeof(LPOLESTR) * (pPackageDetail->pActInfo->cShellFileExt)))
           return E_INVALIDARG;
       
       for (count = 0; count < (pPackageDetail->pActInfo->cShellFileExt); count++)
       {
           if (!pPackageDetail->pActInfo->prgShellFileExt[count])
               return E_INVALIDARG;
       }  
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgPriority,
           sizeof(UINT) * (pPackageDetail->pActInfo->cShellFileExt)))
           return E_INVALIDARG;
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgInterfaceId,
           sizeof(IID) * (pPackageDetail->pActInfo->cInterfaces)))
           return E_INVALIDARG;
       
       if (!IsValidReadPtrIn(pPackageDetail->pActInfo->prgTlbId,
           sizeof(GUID) * (pPackageDetail->pActInfo->cTypeLib)))
           return E_INVALIDARG;
   }

   // Validating InstallInfo

   if ((pPackageDetail->pInstallInfo == NULL) || 
       (!IsValidReadPtrIn(pPackageDetail->pInstallInfo, sizeof(INSTALLINFO)))
      )
       return E_INVALIDARG;

   if (!IsValidReadPtrIn(pPackageDetail->pInstallInfo->prgUpgradeFlag, 
                   sizeof(DWORD)*(pPackageDetail->pInstallInfo->cUpgrades)))
       return E_INVALIDARG;

   if (!IsValidReadPtrIn(pPackageDetail->pInstallInfo->prgUpgradeScript, 
                   sizeof(LPOLESTR)*(pPackageDetail->pInstallInfo->cUpgrades)))
       return E_INVALIDARG;

   for (count = 0; count < (pPackageDetail->pInstallInfo->cUpgrades); count++)
   {
       if ((!(pPackageDetail->pInstallInfo->prgUpgradeScript[count])) || 
           IsBadStringPtr((pPackageDetail->pInstallInfo->prgUpgradeScript[count]), _MAX_PATH))
           return E_INVALIDARG;

       if ((pPackageDetail->pInstallInfo->prgUpgradeFlag[count] != UPGFLG_Uninstall) &&
           (pPackageDetail->pInstallInfo->prgUpgradeFlag[count] != UPGFLG_NoUninstall))
           return E_INVALIDARG;      
   }    

   // Validating PlatformInfo

   if ((pPackageDetail->pPlatformInfo == NULL) || 
       (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo, sizeof(PLATFORMINFO)))
      )
       return E_INVALIDARG;

   if (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo->prgPlatform,
            sizeof(CSPLATFORM) * (pPackageDetail->pPlatformInfo->cPlatforms)))
       return E_INVALIDARG;

   if ((pPackageDetail->pPlatformInfo->cLocales == 0) ||
       (pPackageDetail->pPlatformInfo->cPlatforms == 0))
       return E_INVALIDARG;

   if (!IsValidReadPtrIn(pPackageDetail->pPlatformInfo->prgLocale,
            sizeof(LCID) * (pPackageDetail->pPlatformInfo->cLocales)))
       return E_INVALIDARG;

   // Validating other fields in PackageDetail structure
   
   if ((pPackageDetail->pszSourceList == NULL) ||
       (!IsValidReadPtrIn(pPackageDetail->pszSourceList,
             sizeof(LPOLESTR) * (pPackageDetail->cSources)))
      )
      return E_INVALIDARG;

   for (count = 0; count < (pPackageDetail->cSources); count++)
       if (!pPackageDetail->pszSourceList[count])
       return E_INVALIDARG;


   if (pPackageDetail->rpCategory)
   {
       if (!IsValidReadPtrIn(pPackageDetail->rpCategory,
              sizeof(GUID) * (pPackageDetail->cCategories)))     
              return E_INVALIDARG;
   }

    //
    // Now we create the package
    //    
    
    wcscpy (szRDN, L"CN=");
    wcscat (szRDN, pszPackageName);
    
    pUnknown = NULL;
    hr = m_ADsPackageContainer->Create(
        CLASS_CS_PACKAGE,
        szRDN,
        &pUnknown
        );
    
    RETURN_ON_FAILURE(hr);
    
    hr = pUnknown->QueryInterface(
        IID_IADs,
        (void **)&pPackageADs
        );
    
    pUnknown->Release();
    
    // fill in the activation info
    
    if (pPackageDetail->pActInfo)
    {
        
        if ((pPackageDetail->pActInfo)->cClasses) 
        {
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cClasses)*sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR)*STRINGGUIDLEN);
                StringFromGUID(pPackageDetail->pActInfo->pClasses[count].Clsid, pszGuid[count]);
                cPackProgId += pPackageDetail->pActInfo->pClasses[count].cProgId;
            }
            
            hr = SetPropertyList(pPackageADs, PKGCLSIDLIST, (pPackageDetail->pActInfo)->cClasses, pszGuid);
            ERROR_ON_FAILURE(hr);
            
            for (count = 0; (count < pPackageDetail->pActInfo->cClasses); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
        }
        
        // collecting all the progids from the various clsids.
        if (cPackProgId)
        {
            pszProgId = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*cPackProgId);
            if (!pszProgId) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0, cPackProgId = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
            {
                DWORD cClassProgId = 0;
                for (cClassProgId = 0; cClassProgId < pPackageDetail->pActInfo->pClasses[count].cProgId;
                cClassProgId++) 
                {
                    pszProgId[cPackProgId++] =
                        pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId];
                }
            }
            
            hr = SetPropertyList(pPackageADs, PROGIDLIST, cPackProgId, pszProgId);
            
            CoTaskMemFree(pszProgId);
        }
        
        ERROR_ON_FAILURE(hr);
        
        if (pPackageDetail->pActInfo->cShellFileExt) 
        {
            //
            // Store a tuple in the format <file ext>:<priority>
            //
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cShellFileExt) * sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            for (count = 0; count < pPackageDetail->pActInfo->cShellFileExt; count++)
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) * 
                    (wcslen(pPackageDetail->pActInfo->prgShellFileExt[count])+1+2+1));
                // format is fileext+:+nn+NULL where nn = 2 digit priority
                wsprintf(pszGuid[count], L"%s:%2d", 
                    pPackageDetail->pActInfo->prgShellFileExt[count], 
                    pPackageDetail->pActInfo->prgPriority[count]);
            }
            hr = SetPropertyList(pPackageADs, PKGFILEEXTNLIST, pPackageDetail->pActInfo->cShellFileExt, pszGuid);
            for (count = 0; (count < pPackageDetail->pActInfo->cShellFileExt); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
            
            //
            // Now IDS Workaround
            // BUGBUG. Remove this when the DS bug is fixed. 130491 in NTDEV
            //
            hr = SetPropertyList(pPackageADs, 
                QRYFILEEXT, 
                pPackageDetail->pActInfo->cShellFileExt, 
                pPackageDetail->pActInfo->prgShellFileExt);
            
        }
        
        ERROR_ON_FAILURE(hr);
        
        if (pPackageDetail->pActInfo->cInterfaces) 
        {
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cInterfaces)*sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++) 
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
                if (!pszGuid[count]) 
                {
                    hr = E_OUTOFMEMORY;
                    ERROR_ON_FAILURE(hr);
                }
                
                StringFromGUID((pPackageDetail->pActInfo->prgInterfaceId)[count], pszGuid[count]);
            }
            
            hr = SetPropertyList(pPackageADs, PKGIIDLIST, pPackageDetail->pActInfo->cInterfaces,
                pszGuid);
            ERROR_ON_FAILURE(hr);
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
        }
        
        
        if (pPackageDetail->pActInfo->cTypeLib) 
        {
            pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->pActInfo->cTypeLib)*sizeof(LPOLESTR));
            if (!pszGuid) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            for (count = 0; (count < (pPackageDetail->pActInfo)->cTypeLib); count++) 
            {
                pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
                if (!pszGuid[count]) 
                {
                    hr = E_OUTOFMEMORY;
                    ERROR_ON_FAILURE(hr);
                }
                
                StringFromGUID((pPackageDetail->pActInfo->prgTlbId)[count], pszGuid[count]);
            }
            
            hr = SetPropertyList(pPackageADs, PKGTLBIDLIST, pPackageDetail->pActInfo->cTypeLib,
                pszGuid);
            ERROR_ON_FAILURE(hr);
            
            for (count = 0; (count < (pPackageDetail->pActInfo->cTypeLib)); count++)
                CoTaskMemFree(pszGuid[count]);
            CoTaskMemFree(pszGuid);
        }
    }
    // fill in the platforminfo
    
    // BUGBUG::***os version
    if ((pPackageDetail->pPlatformInfo)->cPlatforms) 
    {
        pdwArch = (DWORD *)CoTaskMemAlloc(sizeof(DWORD)*
            ((pPackageDetail->pPlatformInfo)->cPlatforms));
        
        for (count = 0; (count < (pPackageDetail->pPlatformInfo)->cPlatforms); count++)
            UnpackPlatform (pdwArch+count, ((pPackageDetail->pPlatformInfo)->prgPlatform)+count);
        
        hr = SetPropertyListDW (pPackageADs, ARCHLIST, (pPackageDetail->pPlatformInfo)->cPlatforms, pdwArch);
        ERROR_ON_FAILURE(hr);
        
        CoTaskMemFree(pdwArch);
    }
    
    if ((pPackageDetail->pPlatformInfo)->cLocales) 
    {
        hr = SetPropertyListDW (pPackageADs, 
            LOCALEID, (pPackageDetail->pPlatformInfo)->cLocales, 
            (pPackageDetail->pPlatformInfo)->prgLocale);
        ERROR_ON_FAILURE(hr);
    }
    
    // fill in the installinfo
    
    hr = SetProperty(pPackageADs, PACKAGENAME, pszPackageName);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, PACKAGETYPE, (DWORD)pPackageDetail->pInstallInfo->PathType);
    ERROR_ON_FAILURE(hr);
    
    if (pPackageDetail->pInstallInfo->pszScriptPath) 
    {
        hr = SetProperty(pPackageADs, SCRIPTPATH, pPackageDetail->pInstallInfo->pszScriptPath);
        ERROR_ON_FAILURE(hr);
    }
    
    if (pPackageDetail->pInstallInfo->pszSetupCommand) 
    {
        hr = SetProperty(pPackageADs, SETUPCOMMAND, pPackageDetail->pInstallInfo->pszSetupCommand);
        ERROR_ON_FAILURE(hr);
    }
    
    if (pPackageDetail->pInstallInfo->pszUrl) 
    {
        hr = SetProperty(pPackageADs, HELPURL, pPackageDetail->pInstallInfo->pszUrl);
        ERROR_ON_FAILURE(hr);
    }
    
    GetCurrentUsn(&Usn[0]);
    hr = UsnUpd(pPackageADs, PKGUSN, &Usn[0]);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, PACKAGEFLAGS, pPackageDetail->pInstallInfo->dwActFlags);
    ERROR_ON_FAILURE(hr);
        
    hr = SetPropertyDW (pPackageADs, CLASSCTX, pPackageDetail->pInstallInfo->dwComClassContext);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, VERSIONHI, pPackageDetail->pInstallInfo->dwVersionHi);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, VERSIONLO, pPackageDetail->pInstallInfo->dwVersionLo);
    ERROR_ON_FAILURE(hr);
    
    hr = SetPropertyDW (pPackageADs, SCRIPTSIZE, pPackageDetail->pInstallInfo->cScriptLen);
    ERROR_ON_FAILURE(hr);

    hr = SetPropertyDW (pPackageADs, UILEVEL, (DWORD)pPackageDetail->pInstallInfo->InstallUiLevel);
    ERROR_ON_FAILURE(hr);

    if (pPackageDetail->pInstallInfo->cUpgrades) 
    {
        LPOLESTR *rpszUpgrades;
        rpszUpgrades = (LPOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR)*pPackageDetail->pInstallInfo->cUpgrades);
        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++) 
        {
            UINT l = wcslen(pPackageDetail->pInstallInfo->prgUpgradeScript[count]);
            rpszUpgrades[count] = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) *(4+l));
            wsprintf(rpszUpgrades[count], L"%s:%1d",
                pPackageDetail->pInstallInfo->prgUpgradeScript[count],
                pPackageDetail->pInstallInfo->prgUpgradeFlag[count]);
        }

        hr = SetPropertyList(pPackageADs, UPGRADESCRIPTNAMES, pPackageDetail->pInstallInfo->cUpgrades,
            rpszUpgrades);

        ERROR_ON_FAILURE(hr);
        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++)
            CoTaskMemFree(rpszUpgrades[count]);
        CoTaskMemFree(rpszUpgrades);
    }
    
    // fill in the sources
    if (pPackageDetail->cSources) 
    {
        hr = SetPropertyList(pPackageADs, MSIFILELIST, pPackageDetail->cSources,
            pPackageDetail->pszSourceList);
        ERROR_ON_FAILURE(hr);
    }

    // fill in the categories
    if (pPackageDetail->cCategories) 
    {
        pszGuid = (LPOLESTR *)CoTaskMemAlloc((pPackageDetail->cCategories) * sizeof(LPOLESTR));
        if (!pszGuid) 
        {
            hr = E_OUTOFMEMORY;
            ERROR_ON_FAILURE(hr);
        }
        
        for (count = 0; (count < pPackageDetail->cCategories); count++) 
        {
            pszGuid[count] = (LPOLESTR)CoTaskMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
            if (!pszGuid[count]) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            
            StringFromGUID((pPackageDetail->rpCategory)[count], pszGuid[count]);
        }
        
        hr = SetPropertyList(pPackageADs, PKGCATEGORYLIST, pPackageDetail->cCategories,
            pszGuid);
        ERROR_ON_FAILURE(hr);
        
        for (count = 0; (count < pPackageDetail->cCategories); count++)
            CoTaskMemFree(pszGuid[count]);
        CoTaskMemFree(pszGuid);
    }
    
    //
    // Store the script in the directory
    //
    /*
    if ((pPackageDetail->pInstallInfo->dwActFlags & SCRIPT_IN_DIRECTORY) && 
        (pPackageDetail->pInstallInfo->cScriptLen))
    {
   
        if ((pPackageDetail->pInstallInfo->cScriptLen) &&
            (!IsValidReadPtrIn(pPackageDetail->pInstallInfo->pScript, pPackageDetail->pInstallInfo->cScriptLen)))
            return E_INVALIDARG;

        SAFEARRAYBOUND size; // Get rid of 16
        SAFEARRAY FAR *psa;
        CHAR HUGEP *pArray=NULL;
        LONG dwSLBound = 0;
        LONG dwSUBound = 0;
        VARIANT vData;

        VariantInit(&vData);
        size.cElements = pPackageDetail->pInstallInfo->cScriptLen;
        size.lLbound = 0;

        psa = SafeArrayCreate(VT_UI1, 1, &size);
        if (!psa) {
            return(E_OUTOFMEMORY);
        }

        hr = SafeArrayAccessData( psa, (void HUGEP * FAR *) &pArray );
        RETURN_ON_FAILURE(hr);
        memcpy( pArray, pPackageDetail->pInstallInfo->pScript, size.cElements );
        SafeArrayUnaccessData( psa );

        V_VT(&vData) = VT_ARRAY | VT_UI1;
        V_ARRAY(&vData) = psa;
        hr = pPackageADs->Put(PKGSCRIPT, vData);
        VariantClear(&vData);
        ERROR_ON_FAILURE(hr);
    }
    */

    hr = StoreIt(pPackageADs);
    ERROR_ON_FAILURE(hr);
    
    if (pPackageDetail->pActInfo)
    {
        for (count = 0; count < pPackageDetail->pActInfo->cClasses; count++) 
        {
            hr = NewClass((pPackageDetail->pActInfo->pClasses)+count);
            ERROR_ON_FAILURE(hr);
        }
    }

    
Error_Cleanup:
    pPackageADs->Release();
    return hr;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\cclsto.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclsto.cxx
//
//  Contents:    Class Factory and IUnknown methods for CAppContainer
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//
// Constructor for Class Container Class factory
//
unsigned long gulcappcon = 0;


CAppContainerCF::CAppContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcappcon );
}

//
// Destructor
//
CAppContainerCF::~CAppContainerCF()
{
    InterlockedDecrement((long *) &gulcappcon );
}

HRESULT  __stdcall  CAppContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
        {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//
// IClassFactory Overide
//
HRESULT  __stdcall  CAppContainerCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void  * * ppvObject)
{
    CAppContainer *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CAppContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
             pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//
// Creates an instance and binds to the container.
// Fails if the bind fails.
// Returns the errorcode as the second parameter
//
HRESULT  __stdcall  CAppContainerCF::CreateConnectedInstance(
    LPOLESTR pszPath, void  * * ppvObject)
{
    CAppContainer *  pIUnk = NULL;
    SCODE sc = S_OK;
    HRESULT  hr;

    if ((pIUnk = new CAppContainer(pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAccess, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        else
            CSDbgPrint(("CS: Connect to Store Failed. hr = 0x%x.\n", sc));

        pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;

    return (sc);
}


HRESULT  __stdcall  CAppContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcappcon ); }
    else
    { InterlockedDecrement((long *) &gulcappcon ); }
    return(S_OK);
}

//
// IUnknown methods for CAppContainer
//
//

HRESULT  __stdcall  CAppContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
     else  if( IsEqualIID( IID_IClassAccess, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    /*
    else  if( IsEqualIID( IID_IClassRefresh, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassRefresh *)this;
    }
    else  if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    */
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\cclstor.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclstor.cxx
//
//  Contents:Class Factory and IUnknown methods for CClassContainer
//
//  Author:  DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//
// Constructor for Class Container Class factory
//
unsigned long gulcInstances = 0;


CClassContainerCF::CClassContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcInstances );
}

//
// Destructor
//
CClassContainerCF::~CClassContainerCF()
{
    InterlockedDecrement((long *) &gulcInstances );
}

HRESULT  __stdcall  CClassContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
        {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateInstance
//
//  Synopsis:
//              This is the default create instance on the class factory.
//
//  Arguments:  pUnkOuter - Should be NULL
//              riid      - IID of interface wanted
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
//
HRESULT  __stdcall  CClassContainerCF::CreateInstance(
                    IUnknown    *   pUnkOuter,
                    REFIID          riid,
                    void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
             pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateConnectedInstance
//
//  Synopsis:
//              This method is called by the ParseDisplayName implementation
//              on the ClassFactory object.
//              When a display name is used to bind to a Class Store
//              an IClassAdmin is returned after binding to the container.
//              This method fails if the bind fails.
//
//  Arguments:  pszPath  - DisplayName of Class Store Container
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

HRESULT  __stdcall  CClassContainerCF::CreateConnectedInstance(
                    LPOLESTR        pszPath,
                    void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE sc = S_OK;
    HRESULT  hr;

    if ((pIUnk = new CClassContainer(pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAdmin, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        else
            printf ("Connect to Store Failed. hr = 0x%x.\n", sc);

        pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::ParseDisplayName
//
//  Synopsis:   Parse a display name and create a pointer moniker.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

STDMETHODIMP CClassContainerCF::ParseDisplayName(
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr = S_OK;
    LPOLESTR pch = pszDisplayName;
    IClassAdmin * pOleClassStore = NULL;
    DWORD ClassStoreId;

    //Validate parameters.
    *pchEaten = 0;
    *ppmkOut = NULL;

    //Eat the prefix.
    while (*pch != '\0' && *pch != ':')
    {
        pch++;
    }

    if(':' == *pch)
    {
        pch++;
    }
    else
    {
        return MK_E_SYNTAX;
    }

    hr = CreateConnectedInstance(pch, (void **) &pOleClassStore);

    if(SUCCEEDED(hr))
    {
        hr = CreatePointerMoniker(pOleClassStore, ppmkOut);
        if(SUCCEEDED(hr))
        {
            *pchEaten = lstrlenW(pszDisplayName);
        }

        pOleClassStore->Release();
    }

    return hr;
}


HRESULT  __stdcall  CClassContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcInstances ); }
    else
    { InterlockedDecrement((long *) &gulcInstances ); }
    return(S_OK);
}

//
// IUnknown methods for CClassContainer
//
//

HRESULT  __stdcall  CClassContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_IClassAdmin, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_ICatRegister, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatRegister *)this;
    }
    else if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    else {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\csacc.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//  File:   csacc.cxx
//
//      Class Store Manager implementation for a client desktop.
//
//      This source file contains implementations for IClassAccess
//      interface for CClassAccess object.
//      It also contains the IEnumPackage implementation for the 
//      aggregate of all class containers seen by the caller.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

/**

void
LogCsPathError(
    WCHAR *             pwszContainerPath,
    HRESULT             hr );

**/


#define MAXCLASSSTORES 10

IClassAccess *GetNextValidClassStore(PCLASSCONTAINER *pStoreList,
                                     DWORD cStores,
                                     DWORD *pcount);

extern HRESULT GetUserClassStores(
                    PCLASSCONTAINER     **ppStoreList,
                    DWORD               *pcStores);



//
// Link list pointer for Class Containers Seen
//
extern CLASSCONTAINER *gpContainerHead;

//
// Link list pointer for User Profiles Seen
//
extern USERPROFILE *gpUserHead;

//
// Global Class Factory for Class Container
//
extern CAppContainerCF *pCF;

//
// Critical Section used during operations on list of class stores
//
extern CRITICAL_SECTION    ClassStoreBindList;

//
// CClassAccess implementation
//

CClassAccess::CClassAccess()

{
     m_uRefs = 1;
     m_cCalls = 0;
}

CClassAccess::~CClassAccess()

{
}

//----------------------------------------------------------------------
//
// 
#ifdef DBG

void PrintClassSpec(
      uCLSSPEC       *   pclsspec         // Class Spec (GUID/Ext/MIME)
     )
{
    STRINGGUID szClsid;

    if (pclsspec->tyspec == TYSPEC_CLSID)
    {
        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);
        CSDbgPrint((" ... GetClassSpecInfo by CLSID = %ws\n", szClsid));
    }

    if (pclsspec->tyspec == TYSPEC_PROGID)
    {
        CSDbgPrint((" ... GetClassSpecInfo by ProgID = %ws\n",
            pclsspec->tagged_union.pProgId));
    }

    if (pclsspec->tyspec == TYSPEC_MIMETYPE)
    {
        CSDbgPrint((" ... GetClassSpecInfo by MimeType = %ws\n",
            pclsspec->tagged_union.pMimeType));
    }

    if (pclsspec->tyspec == TYSPEC_FILEEXT)
    {
        CSDbgPrint((" ... GetClassSpecInfo by FileExt = %ws\n",
            pclsspec->tagged_union.pFileExt));
    }

    if (pclsspec->tyspec == TYSPEC_IID)
    {
        StringFromGUID (pclsspec->tagged_union.iid, szClsid);
        CSDbgPrint((" ... GetClassSpecInfo by IID = %ws\n", szClsid));
    }
}

#endif
//----------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
CClassAccess::GetAppInfo(
         uCLSSPEC       *   pclsspec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT   *   pQryContext,         // Query Attributes
         INSTALLINFO    *   pInstallInfo
        )

        //
        // This is the most common method to access the Class Store.
        // It queries the class store for implementations for a specific
        // Class Id, or File Ext, or ProgID or MIME type.
        //
        // If a matching implementation is available for the object type,
        // client architecture, locale and class context pointer to the
        // binary is returned.
{

    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //
    //
    // Get the list of Class Stores for this user
    //
    PCLASSCONTAINER    *pStoreList;
    ULONG    cStores=0;
    HRESULT  hr;
    ULONG    i;
    ULONG chEaten;
    IMoniker *pmk;
    LPBC pbc;
    IClassAccess    *pICA = NULL;

#ifdef DBG
    PrintClassSpec(pclsspec);
#endif

    hr = GetUserClassStores(
                    &pStoreList,
                    &cStores);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    //RpcImpersonateClient( NULL );

    for (i=0; i < cStores; i++)
    {

        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, &i)))
            continue;

        //
        // Call method on this store
        //

        pICA->AddRef();

        hr = pICA->GetAppInfo(
            pclsspec,
            pQryContext,
            pInstallInfo);

        // Release it after use.

        pICA->Release();

        //
        // Special case error return E_INVALIDARG
        // Do not continue to look, return this.
        //
        if (hr == E_INVALIDARG)
        {
            //RevertToSelf();
            return hr;
        }

        //
        // maintain access counters
        //
        (pStoreList[i])->cAccess++;

        if (SUCCEEDED(hr))
        {
            //RevertToSelf();
            return hr;
        }
        else
        {
            (pStoreList[i])->cNotFound++;
            CSDbgPrint(("CS: .. CClassAccess::GetClassSpecInfo() returned 0x%x\n", hr));
        }
    }

    //RevertToSelf();
    return CS_E_PACKAGE_NOTFOUND;
}



//
// GetNextValidClassStore
//
//

IClassAccess *GetNextValidClassStore(CLASSCONTAINER **pStoreList, DWORD cStores, DWORD *pcount)
{
    HRESULT hr = S_OK;
    IClassAccess *pretICA = NULL;

    // BUGBUG:: Probably should move this inside the for loops so that the
    // read accesses to gpClassStore do not get serialized. Debi?

    EnterCriticalSection (&ClassStoreBindList);

    for (pStoreList += (*pcount); (*pcount) < cStores; (*pcount)++, pStoreList++)
    {
        if ((*pStoreList)->gpClassStore != NULL)
        {
             hr = S_OK;
             break;
        }

        if (FALSE) // ((*pStoreList)->cBindFailures >= MAX_BIND_ATTEMPTS)
        {
            // Number of continuous failures have reached MAX_BIND_ATTEMPTS
            // for this container.
            // Will temporarily disable lookups in this container.
            // Report it in EventLog once
            //

            if ((*pStoreList)->cBindFailures == MAX_BIND_ATTEMPTS)
            {
                //LogCsPathError((*pStoreList)->pszClassStorePath, hr);
                (*pStoreList)->cBindFailures++;
            }
            continue;
        }
        else
        { 
            CSDbgPrint(("CS: .. Connecting to Store %d \n ... %ws..\n",
                    (*pcount),
                    (*pStoreList)->pszClassStorePath));
            //
            // Bind to this Class Store
            //

            if (wcsncmp ((*pStoreList)->pszClassStorePath, L"ADCS:", 5) == 0)
            {
                //
                // If the Storename starts with ADCS
                // it is NTDS based implementation. Call directly.
                //
                hr = pCF->CreateConnectedInstance(
                    ((*pStoreList)->pszClassStorePath + 5),
                    (void **)&((*pStoreList)->gpClassStore));

            }
            else
            {
                //
                // Support for Third Party Pluggable
                // Class Stores is not in Beta1.
                //
#if 1
                hr = E_NOTIMPL;
#else
            ULONG chEaten;
            IMoniker *pmk;
            LPBC pbc;

                pbc = NULL;
                hr = CreateBindCtx (0, &pbc);

                if (!SUCCEEDED(hr))
                {
                    continue;
                }

                pmk = NULL;
                chEaten = 0;


                hr = MkParseDisplayName (pbc,
                         (*pStoreList)->pszClassStorePath,
                         &chEaten,
                         &pmk);

                if (SUCCEEDED(hr))
                {
                    hr = pmk->BindToObject (pbc,
                        NULL,
                        IID_IClassAccess,
                        (void **)&((*pStoreList)->gpClassStore));

                    pmk->Release();
                }

                pbc->Release();
#endif
            }

            if (SUCCEEDED(hr))
            {
                (*pStoreList)->cBindFailures = 0;
                hr = S_OK;
                break;
            }

            if (!SUCCEEDED(hr))
            {
                CSDbgPrint(("CS: ... Failed to connect to this store\n"));
                if ((*pStoreList)->cBindFailures == 0)
                {
                    // First failue or First failure after successful
                    // binding.
                    // Report it in EventLog
                    //

                    //LogCsPathError((*pStoreList)->pszClassStorePath, hr);
                }

                ((*pStoreList)->cBindFailures) ++;
                continue;
            }
        }
    }

    if ((*pcount) != cStores)
        pretICA = (*pStoreList)->gpClassStore;

    LeaveCriticalSection (&ClassStoreBindList);

    return pretICA;
}


/*

HRESULT STDMETHODCALLTYPE
CClassAccess::GetUpgrades (
        ULONG               cClasses,
        CLSID               *pClassList,     // CLSIDs Installed
        CSPLATFORM          Platform,
        LCID                Locale,
        PACKAGEINFOLIST     *pPackageInfoList)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    PCLASSCONTAINER    *pStoreList;
    DWORD       cStores=0;
    HRESULT     hr;
    ULONG       i;
    IClassRefresh   *pIClassRefresh = NULL;
    PACKAGEINFOLIST PackageInfoList;
    IClassAccess    *pICA = NULL;

    pPackageInfoList->cPackInfo = NULL;
    pPackageInfoList->pPackageInfo = NULL;

    //
    // Get the list of Class Stores for this user
    //
    hr = GetUserClassStores(
                    &pStoreList,
                    &cStores);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    RpcImpersonateClient( NULL );

    for (i=0; i < cStores; i++)
    {
        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, &i)))
            continue;
        //
        // Call method on this store
        //

        if (FAILED(pICA->QueryInterface(IID_IClassRefresh,
                            (void **)&pIClassRefresh)))
                continue;

        hr = pIClassRefresh->GetUpgrades(
            cClasses,
            pClassList,
            Platform,
            Locale,
            &PackageInfoList);

        pIClassRefresh->Release();
        pIClassRefresh = NULL;

        if (hr == E_INVALIDARG)
        {
            RevertToSelf();
            return hr;
        }

        if (SUCCEEDED(hr) && (PackageInfoList.cPackInfo > 0))
        {
            //
            // Add to the existing list of upgrades
            //
            UINT        cCount = pPackageInfoList->cPackInfo;

            if (cCount)
            {
                PACKAGEINFO *pInfo = pPackageInfoList->pPackageInfo;
                pPackageInfoList->pPackageInfo =
                    (PACKAGEINFO *) CoTaskMemAlloc
                    ((cCount + PackageInfoList.cPackInfo) * sizeof(PACKAGEINFO));

                memcpy (pPackageInfoList->pPackageInfo,
                    pInfo,
                    cCount * sizeof(PACKAGEINFO));

                memcpy ((pPackageInfoList->pPackageInfo)+cCount,
                    PackageInfoList.pPackageInfo,
                    PackageInfoList.cPackInfo * sizeof(PACKAGEINFO));

                CoTaskMemFree (pInfo);
                pPackageInfoList->cPackInfo += PackageInfoList.cPackInfo;
            }
            else
            {
                pPackageInfoList->cPackInfo = PackageInfoList.cPackInfo;
                pPackageInfoList->pPackageInfo = PackageInfoList.pPackageInfo;
            }
        }
    }

    RevertToSelf();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CClassAccess::CommitUpgrades ()
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    PCLASSCONTAINER    *pStoreList;
    DWORD       cStores=0;
    HRESULT     hr;
    ULONG       i;
    IClassRefresh   *pIClassRefresh;
    IClassAccess    *pICA = NULL;

    //
    // Get the list of Class Stores for this user
    //
    hr = GetUserClassStores(
                    &pStoreList,
                    &cStores);

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    RpcImpersonateClient( NULL );

    for (i=0; i < cStores; i++)
    {
        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, &i)))
            continue;
        //
        // Call method on this store
        //

        if (FAILED(pICA->QueryInterface(IID_IClassRefresh,
                            (void **)&pIClassRefresh)))
                continue;

        hr = pIClassRefresh->CommitUpgrades();

        pIClassRefresh->Release();
    }

    RevertToSelf();
    return hr;
}

*/


HRESULT STDMETHODCALLTYPE CClassAccess::EnumPackages(
        LPOLESTR        pszPackageName, 
        GUID            *pCategory,
        ULONGLONG       *pLastUsn,
        DWORD           dwAppFlags,      // AppType options
        IEnumPackage    **ppIEnumPackage)
{
    //
    // Get the list of Class Stores for this user
    //
    PCLASSCONTAINER    *pStoreList;
    DWORD    cStores=0;
    HRESULT  hr;
    ULONG      i;
    IEnumPackage *Enum[MAXCLASSSTORES];
    ULONG        cEnum = 0;
    CMergedEnumPackage *EnumMerged;
    IClassAccess    *pICA = NULL;

    //
    // Get the list of Class Stores for this user
    //
    hr = GetUserClassStores(
                    &pStoreList,
                    &cStores);

    *ppIEnumPackage = NULL;

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    if (cStores == 0)
    {
        return CS_E_NO_CLASSSTORE;
    }

    //RpcImpersonateClient( NULL );

    for (i=0; i < cStores; i++)
    {
        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, &i)))
            continue;
        //
        // Call method on this store
        //

        hr = pICA->EnumPackages (pszPackageName, 
            pCategory,
            pLastUsn,
            dwAppFlags,
            &(Enum[cEnum]));

        if (hr == E_INVALIDARG)
        {
            //RevertToSelf();
            return hr;
        }

        if (SUCCEEDED(hr))
            cEnum++;
    }

    EnumMerged = new CMergedEnumPackage;
    hr = EnumMerged->Initialize(Enum, cEnum);

    if (FAILED(hr))
    {
        for (i = 0; i < cEnum; i++)
            Enum[i]->Release();
        delete EnumMerged;
    }
    else
    {
        hr = EnumMerged->QueryInterface(IID_IEnumPackage, (void **)ppIEnumPackage);
        if (FAILED(hr))
            delete EnumMerged;
    }

    //RevertToSelf();
    return hr;
}


//--------------------------------------------------------------

CMergedEnumPackage::CMergedEnumPackage()
{
    m_pcsEnum = NULL;
    m_cEnum = 0;
    m_csnum = 0;
    m_dwRefCount = 0;
}

CMergedEnumPackage::~CMergedEnumPackage()
{
    ULONG    i;
    for (i = 0; i < m_cEnum; i++)
        m_pcsEnum[i]->Release();
    CoTaskMemFree(m_pcsEnum);
}

HRESULT  __stdcall  CMergedEnumPackage::QueryInterface(REFIID riid,
                                            void  * * ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumPackage))
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG  __stdcall  CMergedEnumPackage::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}



ULONG  __stdcall  CMergedEnumPackage::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


HRESULT  __stdcall CMergedEnumPackage::Next(
            ULONG             celt,
            PACKAGEDISPINFO   *rgelt,
            ULONG             *pceltFetched)
{
    ULONG count=0, total = 0;
    HRESULT hr = S_OK;

    //RpcImpersonateClient( NULL );
    for (; m_csnum < m_cEnum; m_csnum++)
    {
        count = 0;
        hr = m_pcsEnum[m_csnum]->Next(celt, rgelt+total, &count);

        if (hr == E_INVALIDARG)
        {
            //RevertToSelf();
            return hr;
        }

        total += count;
        celt -= count;

        if (!celt)
            break;
    }
    if (pceltFetched)
        *pceltFetched = total;
    //RevertToSelf();
    if (!celt)
        return S_OK;
    return S_FALSE;
}

HRESULT  __stdcall CMergedEnumPackage::Skip(
            ULONG             celt)
{
    PACKAGEDISPINFO *pPackageInfo = NULL;
    HRESULT          hr = S_OK;
    ULONG            cgot = 0, i;

    pPackageInfo = (PACKAGEDISPINFO *)CoTaskMemAlloc(sizeof(PACKAGEDISPINFO)*celt);
    hr = Next(celt, pPackageInfo, &cgot);

    for (i = 0; i < cgot; i++)
        ReleasePackageInfo(pPackageInfo+i);
    CoTaskMemFree(pPackageInfo);
    
    return hr;
}

HRESULT  __stdcall CMergedEnumPackage::Reset()
{
    ULONG i;
    //RpcImpersonateClient( NULL );
    for (i = 0; ((i <= m_csnum) && (i < m_cEnum)); i++)
        m_pcsEnum[i]->Reset(); // ignoring all error values
    m_csnum = 0;
    //RevertToSelf();
    return S_OK;
}

HRESULT  __stdcall CMergedEnumPackage::Clone(IEnumPackage   **ppIEnumPackage)
{
    ULONG i;
    CMergedEnumPackage *pClone;
    IEnumPackage *pcsEnumCloned[MAXCLASSSTORES];

    //RpcImpersonateClient( NULL );
    pClone = new CMergedEnumPackage;
    for ( i = 0; i < m_cEnum; i++)
        m_pcsEnum[i]->Clone(&(pcsEnumCloned[i]));

    pClone->m_csnum = m_csnum;
    pClone->Initialize(pcsEnumCloned, m_cEnum);
    *ppIEnumPackage = (IEnumPackage *)pClone;
    pClone->AddRef();
    //RevertToSelf();
    return S_OK;
}

HRESULT  CMergedEnumPackage::Initialize(IEnumPackage **pcsEnum, ULONG cEnum)
{
    ULONG i;
    m_csnum = 0;
    m_pcsEnum = (IEnumPackage **)CoTaskMemAlloc(sizeof(IEnumPackage *) * cEnum);
    if (!m_pcsEnum)
        return E_OUTOFMEMORY;
    for (i = 0; i < cEnum; i++)
        m_pcsEnum[i] = pcsEnum[i];
    m_cEnum = cEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\cscaten.cxx ===
//
//  Author: ushaji
//  Date:   December 1996
//
//
//    Providing support for Component Categories in Class Store
//
//      This source file contains implementations for Enumerator Interfaces.
//
//      Refer Doc "Design for Support of File Types and Component Categories
//    in Class Store" ? (or may be Class Store Schema). Most of these uses
//  OLE DB interfaces within the interfaces.
//
//----------------------------------------------------------------------------

#include "cstore.hxx"


//
// Private defines
//

#define MAX_ADS_FILTERS   10
#define MAX_ADS_ENUM      100

// BUGBUG:: Should this go to common

HRESULT
EnumCsObject(
    IADsContainer * pADsContainer,
    LPWSTR * lppPathNames,
    DWORD dwPathNames,
    IEnumVARIANT ** ppEnumVariant
    )
{
    ULONG cElementFetched = 0L;
    VARIANT  VarFilter;
    HRESULT hr;
    DWORD dwObjects = 0, dwEnumCount = 0, i = 0;
    BOOL  fContinue = TRUE;


    if (dwPathNames)
    {
        VariantInit(&VarFilter);

        hr = BuildVarArrayStr(
                lppPathNames,
                dwPathNames,
                &VarFilter
                );

        RETURN_ON_FAILURE(hr);

        hr = pADsContainer->put_Filter(VarFilter);

        RETURN_ON_FAILURE(hr);

        VariantClear(&VarFilter);
    }

    hr = ADsBuildEnumerator(
            pADsContainer,
            ppEnumVariant
            );

    return hr;
}


HRESULT
GetNextEnum(
    IEnumVARIANT * pEnum,
    IADs       **ppADs
    )
{

    HRESULT hr;
    VARIANT VariantArray[MAX_ADS_ENUM];
    IDispatch *pDispatch = NULL;


    hr = ADsEnumerateNext(
                    pEnum,
                    1,
                    VariantArray,
                    NULL
                    );

    if (hr == S_FALSE)
        return hr;

    RETURN_ON_FAILURE(hr);

    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) ppADs) ;
    pDispatch->Release();
    return(S_OK);
}

HRESULT GetCategoryProperty (IADs *pADs,
                           CATEGORYINFO *pcategoryinfo, LCID lcid)
{
     HRESULT    hr = S_OK;
     WCHAR      szName[_MAX_PATH];
     LPOLESTR  *pdesc = NULL;
     ULONG      i, cdesc;

     hr = GetPropertyGuid(pADs, CATEGORYCATID, &(pcategoryinfo->catid));
     RETURN_ON_FAILURE(hr);

     hr = GetPropertyListAlloc(pADs, LOCALEDESCRIPTION, &cdesc, &pdesc);
     RETURN_ON_FAILURE(hr);

     pcategoryinfo->lcid = lcid;

     hr = GetCategoryLocaleDesc(pdesc, cdesc, &(pcategoryinfo->lcid),
                                (pcategoryinfo->szDescription));
     for (i = 0; i < cdesc; i++)
         CoTaskMemFree(pdesc[i]);
     CoTaskMemFree(pdesc);

     if (FAILED(hr))
         *(pcategoryinfo->szDescription) = L'\0';

     return S_OK;
}
//----------------------------------------------


//    IEnumCATEGORYINFO:
//    IUnknown methods
HRESULT CSCEnumCategories::QueryInterface(REFIID riid, void** ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumCATEGORYINFO))
    {
        *ppObject=(IUnknown *)(IEnumCATEGORYINFO*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumCategories::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumCategories::Release()
{
    ULONG dwRefCount;

    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATEGORYINFO methods
//--------------------------------------------------------------------
// Next:
//        celt:            Number of elements to be fetched.
//        rgelt:           Buffer to return the elements.
//        pceltFetched:    ptr to Number of elements actually fetched.
//                         Takes care of that being NULL.
// Uses OLE DS interfaces to get the next enumerators.
//--------------------------------------------------------------------

HRESULT CSCEnumCategories::Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched)
{
    HRESULT             hr = S_OK;
    IADs               *pCatADs = NULL;
    ULONG               dwCount;

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if (m_pEnumVariant == NULL)
        return E_UNEXPECTED;

    if (celt < 0)
        return E_INVALIDARG;

    if (!IsValidPtrOut(rgelt, sizeof(CATEGORYINFO)*celt)) {
        return E_INVALIDARG;
    }

    for ((dwCount) = 0; (dwCount) < celt;) {
        hr = GetNextEnum(m_pEnumVariant, &pCatADs);
        if ((FAILED(hr)) || (hr == S_FALSE))
            break;

        hr = GetCategoryProperty(pCatADs, &(rgelt[dwCount]), m_lcid);
        pCatADs->Release();

        if (FAILED(hr))
            continue;

        (dwCount)++;
    }

    m_dwPosition += dwCount;

    if (pceltFetched)
        (*pceltFetched) = dwCount;
    return hr;
}

//---------------------------------------------------
// skip:
//            skips elements.
//    celt    Number of elements to skip.
//---------------------------------------------------

HRESULT CSCEnumCategories::Skip(ULONG celt)
{
    CATEGORYINFO *dummy;
    ULONG         got;
    HRESULT       hr;

    dummy = new CATEGORYINFO[celt];
    if (!dummy)
        return E_OUTOFMEMORY;

    if (m_pEnumVariant == NULL)
    {
        delete dummy;
        return E_UNEXPECTED;
    }
    hr = Next(celt, dummy, &got);
    delete dummy;
    return hr;
}

//---------------------------------------------------
// Reset:
//     Resets the pointer.
//---------------------------------------------------
HRESULT CSCEnumCategories::Reset(void)
{
    LPOLESTR    pszPathNames [2];
    HRESULT     hr;

    pszPathNames [0] = CLASS_CS_CATEGORY;

    if (m_pEnumVariant == NULL)
        return E_UNEXPECTED;
    m_pEnumVariant->Release();

    hr = EnumCsObject(m_ADsCategoryContainer, &pszPathNames[0],
                      0, &m_pEnumVariant);

    m_dwPosition = 0;
    return hr;
}
//--------------------------------------------------------------
//    Clone:
//            returns another interface which points to the same data.
//        ppenum:        enumerator
//------------------------------------------------------------
////////////////////////////////////////////////////////////////////
HRESULT CSCEnumCategories::Clone(IEnumCATEGORYINFO **ppenum)
{
    CSCEnumCategories* pClone=NULL;

    if (!IsValidPtrOut(ppenum, sizeof(IEnumCATEGORYINFO *))) {
        return E_INVALIDARG;
    }

    pClone=new CSCEnumCategories();

    if (!pClone)
    {
        return E_OUTOFMEMORY;
    }
    if (FAILED(pClone->Initialize(m_ADsCategoryContainer, m_lcid)))
    {
        delete pClone;
        return E_UNEXPECTED;
    }

    pClone->Skip(m_dwPosition);

    if (SUCCEEDED(pClone->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenum)))
    {
        return S_OK;
    }

    delete pClone;
    return E_UNEXPECTED;
}

CSCEnumCategories::CSCEnumCategories()
{
    m_dwRefCount=0;
    m_pEnumVariant = NULL;
    m_ADsCategoryContainer = NULL;
    m_lcid=0;
    m_dwPosition = 0;
}

HRESULT CSCEnumCategories::Initialize(IADsContainer *ADsCategoryContainer, LCID lcid)
{
    LPOLESTR pszPathNames [2];
    HRESULT hr;

    pszPathNames [0] = CLASS_CS_CATEGORY;
    m_ADsCategoryContainer = ADsCategoryContainer;
    m_ADsCategoryContainer->AddRef();

    hr = EnumCsObject(m_ADsCategoryContainer, &pszPathNames[0], 0, &m_pEnumVariant);
    RETURN_ON_FAILURE(hr);

    m_lcid = lcid;
    return S_OK;
} /* EnumCategories */


CSCEnumCategories::~CSCEnumCategories()
{
    if (m_ADsCategoryContainer)
        m_ADsCategoryContainer->Release();
    if (m_pEnumVariant)
        m_pEnumVariant->Release();
}

// CSCEnumCategoriesOfClass:
// IUnknown methods
HRESULT CSCEnumCategoriesOfClass::QueryInterface(REFIID riid, void** ppObject)
{
    if ((riid==IID_IUnknown) || (riid==IID_IEnumCATID))
    {
        *ppObject=(IEnumCATID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumCategoriesOfClass::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumCategoriesOfClass::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATID methods
HRESULT CSCEnumCategoriesOfClass::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    ULONG dwCount;

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if (celt < 0)
        return E_INVALIDARG;

    if (!IsValidPtrOut(rgelt, sizeof(GUID)*celt))
        return E_INVALIDARG;

    for ( (dwCount) = 0; (((dwCount) < celt) && (m_dwPosition < m_cCatid));
                                            (dwCount)++, m_dwPosition++)
        rgelt[(dwCount)] = m_catid[m_dwPosition];

    if (pceltFetched)
        (*pceltFetched) = dwCount;
    if (dwCount == celt)
        return S_OK;
    return S_FALSE;
}

HRESULT CSCEnumCategoriesOfClass::Skip(ULONG celt)
{
    if (m_cCatid >= (celt + m_dwPosition)) {
        m_dwPosition += celt;
        return S_OK;
    }
    m_dwPosition = m_cCatid;
    return S_FALSE;
}


HRESULT CSCEnumCategoriesOfClass::Reset(void)
{
    m_dwPosition = 0;
    return S_OK;
}

HRESULT CSCEnumCategoriesOfClass::Clone(IEnumGUID **ppenum)
{
    HRESULT                         hr = S_OK;
    CSCEnumCategoriesOfClass       *pEnumClone = NULL;

    if (!IsValidPtrOut(ppenum, sizeof(IEnumGUID *)))
        return E_POINTER;

    pEnumClone = new CSCEnumCategoriesOfClass;
    if (pEnumClone == NULL)
        return E_OUTOFMEMORY;

    pEnumClone->Initialize(m_catid, m_cCatid);
    pEnumClone->m_dwPosition = m_dwPosition;
    if (SUCCEEDED(hr = pEnumClone->QueryInterface(IID_IEnumCATID, (void**) ppenum)))
        return S_OK;

    delete pEnumClone;
    return hr;
}


CSCEnumCategoriesOfClass::CSCEnumCategoriesOfClass()
{
    m_dwRefCount=0;
    m_dwPosition = 0;
    m_catid = NULL;
}

HRESULT CSCEnumCategoriesOfClass::Initialize(CATID catid[], ULONG cCatid)
{
    ULONG   i;

    m_catid = new CATID[cCatid];
    if (!m_catid)
        return E_OUTOFMEMORY;
    m_cCatid = cCatid;
    for (i = 0; i < cCatid; i++)
        m_catid[i] = catid[i];
    m_dwPosition = 0;
    return S_OK;
}

CSCEnumCategoriesOfClass::~CSCEnumCategoriesOfClass()
{
    if (m_catid)
        delete m_catid;
}

// CEnumClassesOfCategories:
// IUnknown methods
HRESULT CSCEnumClassesOfCategories::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCLSID)
    {
        *ppObject=(IEnumCLSID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CSCEnumClassesOfCategories::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CSCEnumClassesOfCategories::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumGUID methods
HRESULT CSCEnumClassesOfCategories::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    ULONG        cRead;
    ULONG        i, dwCount, cgot;
    HRESULT      hr;
    CLSID        clsid;
    IADs        *pclsid;
    WCHAR        szClsid[_MAX_PATH];

    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;

    if (pceltFetched)
        (*pceltFetched) = 0;

    if ((celt < 0) || (!IsValidPtrOut(rgelt, sizeof(GUID)*celt)))
        return E_INVALIDARG;

    for ((dwCount) = 0; (dwCount) < celt;) {

        hr = GetNextEnum(m_pEnumVariant, &pclsid);
        if ((FAILED(hr)) || (hr == S_FALSE))
        {
            if (pceltFetched)
                *pceltFetched = dwCount;
            return S_FALSE;
        }

        hr = GetProperty (pclsid, CLASSCLSID, szClsid);
        pclsid->Release();

        if (FAILED(hr)) {
            if (pceltFetched)
                *pceltFetched = dwCount;
            return S_FALSE;
        }

        GUIDFromString(szClsid, &clsid);

        if ((ImplSatisfied(clsid, m_cImplemented, m_rgcatidImpl, m_pICatInfo) == S_OK) &&
                (ReqSatisfied(clsid, m_cRequired, m_rgcatidReq, m_pICatInfo) == S_OK))
        {
            rgelt[dwCount] = clsid;
            (dwCount)++;
        }
    }

    m_dwPosition += dwCount;

    if (pceltFetched)
        *pceltFetched = dwCount;

    return S_OK;
}

HRESULT CSCEnumClassesOfCategories::Skip(ULONG celt)
{
    CLSID       *dummyclasses;
    ULONG        celtFetched;
    HRESULT      hr;

    dummyclasses = new CLSID[celt];
    hr = Next(celt, dummyclasses, &celtFetched);
    delete dummyclasses;
    return hr;
}

HRESULT CSCEnumClassesOfCategories::Reset()
{
    LPOLESTR    pszPathNames [2];
    HRESULT     hr;

    pszPathNames [0] = CLASS_CS_CLASS;

    if (m_pEnumVariant == NULL)
        return E_UNEXPECTED;
    m_pEnumVariant->Release();

    hr = EnumCsObject(m_ADsClassContainer, &pszPathNames[0],
                      0, &m_pEnumVariant);
    m_dwPosition = 0;
    return hr;
}

HRESULT CSCEnumClassesOfCategories::Clone(IEnumGUID **ppenum)
{
    HRESULT                         hr;
    CSCEnumClassesOfCategories    *pEnumClone;

    if (!ppenum)
        return E_INVALIDARG;

    pEnumClone = new CSCEnumClassesOfCategories;
    if (!pEnumClone)
        return E_OUTOFMEMORY;
    hr = pEnumClone->Initialize(m_cRequired, m_rgcatidReq,
                                m_cImplemented, m_rgcatidImpl,
                                m_ADsClassContainer,
                                m_pICatInfo);
    if (FAILED(hr))
    {
        delete pEnumClone;
        return hr;
    }
    pEnumClone->Skip(m_dwPosition);

    hr = pEnumClone->QueryInterface(IID_IEnumCLSID, (void **)ppenum);
    if (FAILED(hr))
    {
        delete pEnumClone;
    }

    return hr;
}

CSCEnumClassesOfCategories::CSCEnumClassesOfCategories()
{
    m_dwRefCount = 0;
    m_rgcatidReq = NULL;
    m_rgcatidImpl = NULL;
    m_pICatInfo = NULL;
    m_ADsClassContainer = NULL;
    m_pEnumVariant = NULL;
    m_dwPosition = 0;
}

HRESULT CSCEnumClassesOfCategories::Initialize(ULONG cRequired, CATID rgcatidReq[],
                                               ULONG cImplemented, CATID rgcatidImpl[],
                                               IADsContainer *ADsClassContainer,
                                               ICatInformation *pICatInfo)
{
    ULONG       i;
    HRESULT     hr;
    LPOLESTR    pszPathNames [2];

    pszPathNames [0] = CLASS_CS_CLASS;
    m_ADsClassContainer = ADsClassContainer;
    m_ADsClassContainer->AddRef();

    hr = EnumCsObject(m_ADsClassContainer, &pszPathNames[0], 0, &m_pEnumVariant);
    RETURN_ON_FAILURE(hr);

    m_pICatInfo = pICatInfo;
    RETURN_ON_FAILURE(m_pICatInfo->AddRef());

    m_cRequired = cRequired;
    if (cRequired != -1)
    {
        m_rgcatidReq = new CATID[cRequired];
        if (!m_rgcatidReq)
            return E_OUTOFMEMORY;
        for (i = 0; i < m_cRequired; i++)
            m_rgcatidReq[i] = rgcatidReq[i];
    }

    m_cImplemented = cImplemented;
    if (cImplemented != -1)
    {
        m_rgcatidImpl = new CATID[cImplemented];
        if (!m_rgcatidImpl)
            return E_OUTOFMEMORY;
        for (i = 0; i < m_cImplemented; i++)
            m_rgcatidImpl[i] = rgcatidImpl[i];
    }
    return S_OK;
}

CSCEnumClassesOfCategories::~CSCEnumClassesOfCategories()
{
    if (m_rgcatidReq)
        delete m_rgcatidReq;
    if (m_rgcatidImpl)
        delete m_rgcatidImpl;
    if (m_pICatInfo)
        m_pICatInfo->Release();
    if (m_ADsClassContainer)
        m_ADsClassContainer->Release();
    if (m_pEnumVariant)
        m_pEnumVariant->Release();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\csds.cxx ===
//
//  Author: DebiM
//  Date:   January 97
//
//
//      Class Access Implementation
//
//      This source file contains implementations for IClassAccess
//      interface on CAppContainer object.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------
//

#include "cstore.hxx"

void
GetDefaultPlatform(CSPLATFORM *pPlatform);

BOOL 
CheckMatching (QUERYCONTEXT *pQryContext,
               INSTALLINFO *pInstallInfo,
               PLATFORMINFO *pPlatformInfo
               );

extern LPOLESTR szInstallInfoColumns;
extern LPOLESTR szPackageInfoColumns;

void FreeInstallInfo(INSTALLINFO *pInstallInfo)
{
    CoTaskMemFree(pInstallInfo->pszScriptPath);
    CoTaskMemFree(pInstallInfo->pszSetupCommand);
    CoTaskMemFree(pInstallInfo->pszUrl);
    CoTaskMemFree(pInstallInfo->pClsid);
    memset(pInstallInfo, 0, sizeof (INSTALLINFO));
}

void FreePlatformInfo(PLATFORMINFO *pPlatformInfo)
{
    CoTaskMemFree(pPlatformInfo->prgLocale);
    CoTaskMemFree(pPlatformInfo->prgPlatform);
}

//
// CAppContainer implementation
//
CAppContainer::CAppContainer()

{
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_pADsClassStore = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    
    m_uRefs = 1;
    StartQuery(&m_pIDBCreateCommand);
}


//
// CAppContainer implementation
//
CAppContainer::CAppContainer(LPOLESTR szStoreName,
                                 HRESULT  *phr)
                                 
{
    IADs        *pADs = NULL;
    LPOLESTR    pszName = NULL;
    DWORD       dwStoreVersion = 0;
    
    *phr = S_OK;
    
#ifdef DBG
    WCHAR   Name[32];
    DWORD   NameSize = 32;
    
    if ( ! GetUserName( Name, &NameSize ) )
        CSDbgPrint(("CAppContainer::CAppContainer GetUserName failed 0x%x\n", GetLastError()));
    else
        CSDbgPrint(("CAppContainer::CAppContainer as %S\n", Name));
#endif
    
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_pADsClassStore = NULL;
    m_ADsClassContainer = NULL;
    m_ADsPackageContainer = NULL;
    
    //
    // For every interface pointer, we create a separate session
    //
    StartQuery(&m_pIDBCreateCommand);
    
    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);
    
    *phr = ADsGetObject(
        szStoreName, 
        IID_IADsContainer,
        (void **)&m_ADsContainer
        );
    
    if (!SUCCEEDED(*phr))
        return;
    
    //
    // Check the Schema Version of this container
    //
    
    *phr = m_ADsContainer->QueryInterface (IID_IADs, (void **)&m_pADsClassStore);
    if (!SUCCEEDED(*phr))
        return;
    
    *phr = GetPropertyDW (m_pADsClassStore, STOREVERSION, &dwStoreVersion);
    
    if ((!SUCCEEDED(*phr)) ||
        (dwStoreVersion != SCHEMA_VERSION_NUMBER))
    {
        CSDbgPrint(("CS: .. Wrong Version of Class Container:%ws\n",
            m_szContainerName));
        *phr = CS_E_INVALID_VERSION;
        return;
    }
        
    CSDbgPrint(("CS: .. Connected to Class Container:%ws\n",
        m_szContainerName));
    //
    // Bind to the class container Object
    // Cache the interface pointer
    //
    
    m_ADsClassContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        CLASSCONTAINERNAME,
        (IDispatch **)&pADs);
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsClassContainer
        );
    
    *phr = pADs->get_ADsPath(&pszName);
    wcscpy (m_szClassName, pszName);
    SysFreeString(pszName);
    
    pADs->Release();
    pADs = NULL;
    if (!SUCCEEDED(*phr))
        return;
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    m_ADsPackageContainer = NULL;
    
    *phr = m_ADsContainer->GetObject(
        NULL,
        PACKAGECONTAINERNAME,
        (IDispatch **)&pADs);
    
    if (!SUCCEEDED(*phr))
        return;
    
    pADs->QueryInterface(IID_IADsContainer,
        (void **)&m_ADsPackageContainer
        );
    
    *phr = pADs->get_ADsPath(&pszName);
    wcscpy (m_szPackageName, pszName);
    SysFreeString(pszName);
    pADs->Release();
    pADs = NULL;
    
    if (!SUCCEEDED(*phr))
        return;
    
    m_fOpen = TRUE;
    m_uRefs = 1;
}


CAppContainer::~CAppContainer(void)
{
    UINT i;
    
    EndQuery(m_pIDBCreateCommand);
    m_pIDBCreateCommand = NULL;
    
    
    if (m_fOpen)
    {
        //UnlistDB (this);
        m_fOpen = FALSE;
    }
    
    if (m_ADsClassContainer)
    {
        m_ADsClassContainer->Release();
        m_ADsClassContainer = NULL;
    }
    
    if (m_ADsPackageContainer)
    {
        m_ADsPackageContainer->Release();
        m_ADsPackageContainer = NULL;
    }
    
    if (m_ADsContainer)
    {
        m_ADsContainer->Release();
        m_ADsContainer = NULL;
    }
    
    if (m_pADsClassStore)
    {
        m_pADsClassStore->Release();
        m_pADsClassStore = NULL;
    }
    
}

HRESULT CAppContainer::GetPackageDetails (
                                            LPOLESTR        pszPackageName,
                                            PACKAGEDETAIL   *pPackageDetail) 
{
    HRESULT     hr = S_OK;
    IADs       *pPackageADs = NULL;
    WCHAR       szRdn [_MAX_PATH];
    
    wcscpy (szRdn, L"CN=");
    wcscat (szRdn, pszPackageName);
    
    hr = m_ADsPackageContainer->GetObject(NULL, szRdn, (IDispatch **)&pPackageADs);
    if (!SUCCEEDED(hr))
        return hr;
    
    hr = GetPackageDetail (pPackageADs, pPackageDetail);
    return hr;
}

//
// ::EnumPackages
//----------------
//
// Obtains an enumerator for packages in the app container.
// Takes the following optional filter specifications:
//
//    [in] pszPackageName : Substring match for a package name
//    [in] pCategory      : Category id of interest
//    [in] dwAppFlags     : following bits set to select specific ones
//         Published Only APPINFO_PUBLISHED
//         Assigned Only  APPINFO_ASSIGNED
//         Msi Only       APPINFO_MSI
//         Visible        APPINFO_VISIBLE
//         Auto-Install   APPINFO_AUTOINSTALL
//
//         All Locale     APPINFO_ALLLOCALE
//         All Platform   APPINFO_ALLPLATFORM
//
//
HRESULT CAppContainer::EnumPackages (
                                       LPOLESTR        pszPackageName, 
                                       GUID            *pCategory,
                                       ULONGLONG       *pLastUsn,
                                       DWORD           dwAppFlags,     
                                       IEnumPackage    **ppIEnumPackage
                                       )
{
    HRESULT                 hr;
    CEnumPackage           *pEnum;
    WCHAR                   szLdapFilter [2000];
    UINT                    len;
    UINT                    fFilters = 0;
    LCID                    dwLocale, *pdwLocale;
    CSPLATFORM              *pPlatform, Platform;
    
    if (!IsValidPtrOut(ppIEnumPackage, sizeof(IEnumPackage *))) 
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    pEnum = new CEnumPackage;
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a LDAP Search Filter based on input params
    //
    
    // Count Filters
    
    if (pszPackageName && (*pszPackageName))
        fFilters++;
    if (pLastUsn)
        fFilters++;
    if (pCategory)
        fFilters++;
    if (dwAppFlags & APPINFO_ASSIGNED)  
        fFilters++;

    if (fFilters == 0)
    {
        // No Conditionals
        wsprintf (szLdapFilter,
            L"<%s>;(objectClass=packageRegistration)",  
            m_szPackageName);
        
        len = wcslen (szLdapFilter);
    }
    else
    {
        
        if (fFilters == 1)
        {
            wsprintf (szLdapFilter,
                L"<%s>;",  
                m_szPackageName);
        }
        else
        {
            wsprintf (szLdapFilter,
                L"<%s>;(&",  
                m_szPackageName);
        }
        
        len = wcslen (szLdapFilter);
        
        if (pszPackageName)
        {
            //
            // Validate 
            //
            
            if (IsBadStringPtr(pszPackageName, _MAX_PATH))
                return E_INVALIDARG;
            
            if (*pszPackageName)
            {
                wsprintf (&szLdapFilter[len], 
                    L"(%s=*%s*)", 
                    PACKAGENAME,
                    pszPackageName);
                
                len = wcslen (szLdapFilter);
            }
        }
        
        if (pLastUsn)
        {
            //
            // Validate 
            //
            
            if (!IsValidReadPtrIn(pLastUsn, sizeof(ULONGLONG)))
                return E_INVALIDARG;
            
            wsprintf (&szLdapFilter[len], 
                    L"(%s>=%ul)", 
                    PKGUSN,
                    *pLastUsn);
                
            len = wcslen (szLdapFilter);
        }

        if (pCategory)
        {
            //
            // Validate 
            //
            STRINGGUID szCat;
            
            if (!IsValidReadPtrIn(pCategory, sizeof(GUID)))
                return E_INVALIDARG;
            
            StringFromGUID (*pCategory, szCat);
            wsprintf (&szLdapFilter[len], 
                L"(%s=%s)", 
                PKGCATEGORYLIST,
                szCat);
            
            len = wcslen (szLdapFilter);
        }
        
        if (dwAppFlags & APPINFO_ASSIGNED)  
            // if only Assigned Packages are in demand
        {
            wsprintf (&szLdapFilter[len], 
                L"(%s>=%d)", 
                PACKAGEFLAGS,
                (ACTFLG_Assigned));
            
            len = wcslen (szLdapFilter);
        }
        
        if (fFilters > 1)
        {
            szLdapFilter[len] = L')';
            szLdapFilter[++len] = NULL;
        }
    }     
    //
    // Now append the attribute list to the search string
    //
    wsprintf (&szLdapFilter[len], L";%s", szPackageInfoColumns);
    //
    // Check all local/platform flags
    //
    
    if (dwAppFlags & APPINFO_ALLLOCALE)
    {
        pdwLocale = NULL;
    }
    else
    {
        dwLocale = GetThreadLocale();  
        pdwLocale = &dwLocale;
    }
    
    if (dwAppFlags & APPINFO_ALLPLATFORM)
    {
        pPlatform = NULL;
    }
    else
    {
        pPlatform = &Platform;
        GetDefaultPlatform(pPlatform);
    }
    
    hr = pEnum->Initialize(szLdapFilter, dwAppFlags, pdwLocale, pPlatform);
    
    if (FAILED(hr))
    {
        delete pEnum;
        return hr;
    }
    
    hr = pEnum->QueryInterface(IID_IEnumPackage,(void**) ppIEnumPackage);
    
    if (FAILED(hr))
    {
        delete pEnum;
        return hr;
    }
    
    return S_OK;
}



//
// CAppContainer::GetAppInfo
// -----------------------------
//
//
//
//  Synopsis:       This is the most common access point to the Class Store.
//                  It receives a CLSID and a QUERYCONTEXT.
//                  It looks up the Class Store container for a matching set
//                  of packages with in the context of the QUERYCONTEXT.
//
//                  QUERYCONTEXT includes
//                      Execution Context
//                      Locale Id
//                      Platform/OS
//
//                  If i finds an app that matches the requirements, it returns 
//                  an INSTALLINFO structure containing installation details. 
//
//  Arguments:      [in]  clsid
//                  [in]  pQryContext
//                  [out] pInstallInfo
//
//  Returns:        CS_E_PACKAGE_NOTFOUND
//                  S_OK
//
//
//

HRESULT STDMETHODCALLTYPE
CAppContainer::GetAppInfo(
                            uCLSSPEC       *   pclsspec,          // Class Spec (GUID/Ext/MIME)
                            QUERYCONTEXT   *   pQryContext,       // Query Attributes
                            INSTALLINFO    *   pInstallInfo
                            )
                            
                            //
                            // This is the most common method to access the Class Store.
                            // It queries the class store for implementations for a specific
                            // Class Id, or File Ext, or ProgID.
                            //
                            // If a matching implementation is available (for the object type,
                            // client architecture, locale and class context) then the installation
                            // parameters of the package is returned.
{
    GUID        clsid;
    WCHAR       pszCommandText[1000];
    STRINGGUID  szClsid;
    UINT        i;
    ULONG       cRead;
    HRESULT     hr;
    ULONG       cSize = _MAX_PATH;
    BOOL        fFound = FALSE;
    PLATFORMINFO PlatformInfo;
    LPOLESTR    pFileExt = NULL;
    
    
    memset(pInstallInfo, 0, sizeof(INSTALLINFO));
    
    if (!m_fOpen)
        return E_FAIL;
    
    //
    // Check if the TypeSpec is MIMEType
    // then map it to a CLSID
    //
    
    if (pclsspec->tyspec == TYSPEC_MIMETYPE)
    {
        //
        // BUGBUG.
        //    Considering removal of MimeType support from Class Store
        //     Till it is decided the code is OUT.
        
        return E_NOTIMPL;
        
        /*
        if (IsBadStringPtr(pclsspec->tagged_union.pMimeType, _MAX_PATH))
        return E_INVALIDARG;
        
          if ((pclsspec->tagged_union.pMimeType == NULL) ||
          (*(pclsspec->tagged_union.pMimeType) == NULL))
          return E_INVALIDARG;
          
            wsprintf (pszCommandText,
            L"<%s>;(%s=%s);name",
            m_szClassName, MIMETYPES, pclsspec->tagged_union.pMimeType);
        */
    }
    
    switch (pclsspec->tyspec)
    {
    case TYSPEC_TYPELIB:
        if (IsNullGuid(pclsspec->tagged_union.typelibID))
            return E_INVALIDARG;
        StringFromGUID (pclsspec->tagged_union.typelibID, szClsid);
        wsprintf (pszCommandText,
            L"<%s>;(%s=%s);",
            m_szPackageName, PKGTLBIDLIST, szClsid);
        break;
        
    case TYSPEC_IID:
        if (IsNullGuid(pclsspec->tagged_union.iid))
            return E_INVALIDARG;
        StringFromGUID (pclsspec->tagged_union.iid, szClsid);
        wsprintf (pszCommandText,
            L"<%s>;(%s=%s);",
            m_szPackageName, PKGIIDLIST, szClsid);
        break;
        
    case TYSPEC_CLSID:
        //
        // Check TreatAs
        
        /* BUGBUG
        Considering removal of support for TreatAs in Class Store.
        Till this is closed the code is out.
        
          if ((hr = GetTreatAs (clsid, &MapClsid, &(pPackageInfo->pszClassIconPath)))
          == S_OK)
          {
          //
          // Put the result in the TreatAs field of PackageInfo
          //
          pPackageInfo->pTreatAsClsid = (GUID *)CoTaskMemAlloc(sizeof (CLSID));
          memcpy (pPackageInfo->pTreatAsClsid, &MapClsid, sizeof (CLSID));
          
            //
            // BUGBUG. Must cache presence/absence of TreatAs info as it is
            // a very common lookup into DS.
            //
            }
        */
        
        if (IsNullGuid(pclsspec->tagged_union.clsid))
            return E_INVALIDARG;
        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);
        wsprintf (pszCommandText,
            L"<%s>;(%s=%s);",
            m_szPackageName, PKGCLSIDLIST, szClsid);
        break;
        
    case TYSPEC_FILEEXT:
        
        if (IsBadStringPtr(pclsspec->tagged_union.pFileExt, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.pFileExt == NULL) ||
            (*(pclsspec->tagged_union.pFileExt) == NULL))
            return E_INVALIDARG;
        
            /*
            //
            // BUGBUG. Because FileExt is stored with priority
            // make sure that wildcard at end is used.
            //
            wsprintf (pszCommandText,
            L"<%s>;(%s=%s*);",
            m_szPackageName, PKGFILEEXTNLIST, pclsspec->tagged_union.pFileExt);
        */
        
        //
        // BUGBUG. Workaround for IDS bug. 
        // Change the below to the code above when this is fixed in NTDEV
        //
        wsprintf (pszCommandText,
            L"<%s>;(%s=%s);",
            m_szPackageName, QRYFILEEXT, pclsspec->tagged_union.pFileExt);
        
        pFileExt = pclsspec->tagged_union.pFileExt;
        break;
        
        
    case TYSPEC_PROGID:
        
        if (IsBadStringPtr(pclsspec->tagged_union.pProgId, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.pProgId == NULL) ||
            (*(pclsspec->tagged_union.pProgId) == NULL))
            return E_INVALIDARG;
        
        wsprintf (pszCommandText,
            L"<%s>;(%s=%s);",
            m_szPackageName, PKGPROGIDLIST, pclsspec->tagged_union.pProgId);
        break;
        
    case TYSPEC_PACKAGENAME:
        //
        // Validate package name
        //
        
        if (IsBadStringPtr(pclsspec->tagged_union.pPackageName, _MAX_PATH))
            return E_INVALIDARG;
        
        if ((pclsspec->tagged_union.pPackageName == NULL) ||
            (*(pclsspec->tagged_union.pPackageName) == NULL))
            return E_INVALIDARG;
        
        
        // 
        PACKAGEDETAIL   PackageDetail;
        hr = GetPackageDetails (pclsspec->tagged_union.pPackageName, 
            &PackageDetail);
        
        if (SUCCEEDED(hr))
        {
            memcpy (pInstallInfo, PackageDetail.pInstallInfo, sizeof(INSTALLINFO));
            if (PackageDetail.pActInfo)
            {
                CoTaskMemFree(PackageDetail.pActInfo->prgShellFileExt);
                CoTaskMemFree(PackageDetail.pActInfo->prgPriority);
                CoTaskMemFree(PackageDetail.pActInfo->prgInterfaceId);
                CoTaskMemFree(PackageDetail.pActInfo->prgTlbId);
                CoTaskMemFree(PackageDetail.pActInfo);
            }
            
            if (PackageDetail.pPlatformInfo)
            {
                CoTaskMemFree(PackageDetail.pPlatformInfo->prgPlatform);
                CoTaskMemFree(PackageDetail.pPlatformInfo->prgLocale);
                CoTaskMemFree(PackageDetail.pPlatformInfo);
            }
            
            CoTaskMemFree(PackageDetail.pszSourceList);
            CoTaskMemFree(PackageDetail.rpCategory);
            CoTaskMemFree(PackageDetail.pInstallInfo);
        }
        return hr;
        
    default:
        return E_NOTIMPL;
    }
    
    //
    //
    HACCESSOR          hAccessor = NULL;
    IAccessor          * pIAccessor = NULL;
    IRowset            * pIRowset = NULL;
    ULONG              cRowsFetched;
    INSTALLINFO        InstallInfo[10];
    UINT               rgPriority [10];
    
    wcscat (pszCommandText,
        szInstallInfoColumns);
    
    hr = ExecuteQuery (m_pIDBCreateCommand,
        pszCommandText,
        PACKAGEQUERY_COLUMN_COUNT,
        NULL, 
        &hAccessor,
        &pIAccessor,
        &pIRowset
        );
    
    if (!SUCCEEDED(hr))
        goto done;
    
    
    //
    // BUGBUG. Currently limited to 10.
    // Must put a loop to retry more in future.
    //
    hr = FetchInstallData(pIRowset,
        hAccessor,
        pQryContext,
        pFileExt,
        10,
        &cRowsFetched,
        &InstallInfo[0],
        &rgPriority[0]
        );
    
    if ((hr != S_OK) || (cRowsFetched == 0))
    {
        hr = CS_E_PACKAGE_NOTFOUND;
    }
    else
    {
        //
        // Selected one is j
        //
        UINT j = 0;
        //
        // process file-ext priority.
        //
        if ((pFileExt) && (cRowsFetched > 1))
        {
            UINT Pri = rgPriority[0]; 
            
            for (i=1; i < cRowsFetched; ++i)
            {
                if (rgPriority[i] > Pri)
                {
                    Pri = rgPriority[i];
                    j = i;
                }
            }
        }
        
        //
        // return the jth one
        //
        memcpy (pInstallInfo, &InstallInfo[j], sizeof(INSTALLINFO));
        memset (&InstallInfo[j], NULL, sizeof(INSTALLINFO));
        
        // Clean up all fetched except for jth one
        for (i=0; i < cRowsFetched; i++)
        {
            if (i != j)
                FreeInstallInfo(&InstallInfo[i]);
        }
    }
    
    CloseQuery(pIAccessor, 
        hAccessor,
        pIRowset);
    
done:
    return hr;
    
}


BOOL 
CheckMatching (QUERYCONTEXT *pQryContext,
               INSTALLINFO *pInstallInfo,
               PLATFORMINFO *pPlatformInfo
               )
{
    HRESULT     hr;
    DWORD       dwCtx, dwLocale;
    ULONG       i;
    BOOL        fMatch;
    CSPLATFORM  *pPlatform;
    
    //
    // Get all the specifics of this package
    //
    
    
    dwCtx   = pInstallInfo->dwComClassContext;
    
    //
    // if the implementation is a remote server,
    // then skip matching platform
    //
    fMatch = FALSE;
    
    for (i=0; i < pPlatformInfo->cPlatforms; i++)
    {
        if (MatchPlatform (&(pQryContext->Platform), pPlatformInfo->prgPlatform+i))
        {
            // matches
            fMatch = TRUE;
            break;
        }
    }
    
    //
    // either the locale seen is LANG_NEUTRAL (means does not matter)
    // or the locale matches as specified
    // then treat this as found.
    // BUGBUG. In future we should be going thru the
    //          entire list to pick the best match
    
    if (fMatch)
    {
        fMatch = FALSE;
        for (i=0; i < pPlatformInfo->cLocales; i++)
        {
            if (MatchLocale (pQryContext->Locale, pPlatformInfo->prgLocale[i]))
            {
                // Does not match the Locale requested
                fMatch = TRUE;
                break;
            }
        }
    }
    
    return fMatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\inc\cscommon.h ===
/*
 *  cscommon.h
 */

#define ISNULLGUID(x)   (x.Data1 == NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\csmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    csmain.cxx
//
//  Contents:    Main cxx for Directory Class Access Implementation
//              Local Server.
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


//
// Link list pointer for Class Containers Seen
//
CLASSCONTAINER *gpContainerHead = NULL;

//
// Link list pointer for User Profiles Seen
//
USERPROFILE *gpUserHead = NULL;

//
// Class Factory Objects
//
long ObjectCount = 0;

CAppContainerCF   *   pCF = NULL;
CClassAccessCF      *   pCSAccessCF = NULL;
extern CClassContainerCF  *g_pCF;

//IClassAccess        *   gpClassAccess = NULL;

//
// Critical Section for Sid List
//
CRITICAL_SECTION ClassStoreBindList;

//
//---------------------------------------------------------------------
// Following are used for Supporting Test Scenarios thru FlushSidCache.
WCHAR pwszDebugPath [_MAX_PATH];
BOOL  fDebugPath = FALSE;
//---------------------------------------------------------------------


//
// ResetClassStoreState
// --------------------
//
//  Synopsis:       Calling this will close all Class Containers 
//                  in use and also cleanup state information about all user sids
//                  that have initiated Class Store requests. 
//                  This routine is called at during shut down of 
//                  Class Store Server. 
//
//  Arguments:      None
//
//  Returns:        None
//

void ResetClassStoreState()
//
// This routine is called at during shut down of Class Store Server
//
{
    //
    // Check if there are any outstanding open Class Stores
    //

    CLASSCONTAINER *pCS = gpContainerHead, *pCSTemp;

    while (pCS != NULL)
    {
        if (pCS->gpClassStore)
        {
            (pCS->gpClassStore)->Release();
            pCS->gpClassStore = NULL;
            CSDbgPrint(("Found open container and closed.\n"));
        }

        if (pCS->pszClassStorePath)
        {
            CoTaskMemFree (pCS->pszClassStorePath);
            pCS->pszClassStorePath = NULL;
        }
        pCSTemp = pCS->pNextClassStore;
        CoTaskMemFree (pCS);
        pCS = pCSTemp;
    }

    gpContainerHead = NULL;


    USERPROFILE *pUser = gpUserHead, *pUserTemp;
    while (pUser != NULL)
    {
        if (pUser->pCachedSid)
            CoTaskMemFree (pUser->pCachedSid);

        if (pUser->pUserStoreList)
            CoTaskMemFree (pUser->pUserStoreList);

        pUser->cUserStoreCount = 0;

        pUserTemp = pUser->pNextUser;
        CoTaskMemFree (pUser);
        pUser = pUserTemp;
    }
    
    gpUserHead = NULL;

    CSDbgPrint(("ResetClassStoreState completed.\n"));
}

//
// ResetUserState
// --------------
//
//  Synopsis:       Calling this will flush all state information 
//                  about all user sids that have initiated 
//                  Class Store requests. 
//                  
//                  It is called by the special test entry point 
//                  FlushSidCache.
//
//  Arguments:      LPOLESTR pwszNewPath as the new Class Store path for All
//
//  Returns:        None
//


void ResetUserState(LPOLESTR pwszNewPath)
//
{
    USERPROFILE *pUser = gpUserHead, *pUserTemp;
    while (pUser != NULL)
    {
        if (pUser->pCachedSid)
            CoTaskMemFree (pUser->pCachedSid);

        pUser->cUserStoreCount = 0;

        pUserTemp = pUser->pNextUser;
        CoTaskMemFree (pUser);
        pUser = pUserTemp;
    }
    
    gpUserHead = NULL;
    wcscpy (&pwszDebugPath[0], pwszNewPath);
    fDebugPath = TRUE;

    CSDbgPrint(("ResetUserState completed.\n"));
}

//
// Uninitialize
// -------------
//
//  Synopsis:       Class Store Server Uninitialization.
//                  Disconnects from all Class Containers in use.
//                  Flushes out all State information using ResetClassStoreState.
//                  Unregisters Server registrations etc..
//
//  Arguments:      None
//
//  Returns:        None
//

void Uninitialize()
{
    //
    // Cleanup all open containers
    //

    //ResetClassStoreState();
    //
    // release the Class Factory objects
    //
    if (pCF)
        pCF->Release();
    if (pCSAccessCF)
        pCSAccessCF->Release();

    if (g_pCF)
        g_pCF->Release();
    //
    // get rid of the critical section
    //

    DeleteCriticalSection(&ClassStoreBindList);

}


//
// FlushSidCache
// -------------
//
//  Synopsis:       Supported for Testing Only. Not exposed thru any header.
//                  Calling this empties out Class Store Cache.
//
//  Arguments:      pwszNewPath
//
//  Returns:        S_OK
//

HRESULT FlushSidCache (LPOLESTR pwszNewPath)
{

    EnterCriticalSection (&ClassStoreBindList);

    ResetUserState(pwszNewPath);

    LeaveCriticalSection (&ClassStoreBindList);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeClassStore
//
//  History:    7-25-96   DebiM   Created
//
//  This entry point is called at DLL attach
//----------------------------------------------------------------------------
BOOL InitializeClassStore(BOOL fInit)
{
    HRESULT     hr;
    BOOL        bStatus;
    
    ObjectCount = 1;
    /*
    ACL *       pAcl;
    DWORD       AclSize;
    SECURITY_DESCRIPTOR * pSD;

    SID     LocalSystemSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
    SID     InteractiveSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_INTERACTIVE_RID };


    // Started manually.  Don't go away.
    AclSize = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) + 2 * sizeof(SID);

    pSD = (SECURITY_DESCRIPTOR *)
          PrivMemAlloc( sizeof(SECURITY_DESCRIPTOR) + 2 * sizeof(SID) + AclSize );

    if ( ! pSD )
        return FALSE;

    bStatus = TRUE;
    pAcl = (ACL *) ( ((BYTE *)&pSD[1]) + 2 * sizeof(SID) );

    if ( ! InitializeAcl( pAcl, AclSize, ACL_REVISION2 ) ||
         ! AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE, &LocalSystemSid ) ||
         ! AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE, &InteractiveSid ) )
        bStatus = FALSE;

    if ( ! InitializeSecurityDescriptor( pSD, SECURITY_DESCRIPTOR_REVISION ) ||
         ! SetSecurityDescriptorDacl( pSD, TRUE, pAcl, FALSE ) ||
         ! SetSecurityDescriptorGroup( pSD, &LocalSystemSid, FALSE ) ||
         ! SetSecurityDescriptorOwner( pSD, &LocalSystemSid, FALSE ) )
        bStatus = FALSE;

    if ( bStatus )
    {
        hr = CoInitializeSecurity(
                    pSD,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    NULL,
                    EOAC_NONE,
                    NULL );
    }

    PrivMemFree( pSD );

    if ( ! bStatus || (hr != S_OK) )
    {
        CSDbgPrint(("Class Store: Couldn't initialize security\n"));
    }
    */


    /*
    if (fInit)
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (hr)
            CSDbgPrint(("RPCSS : CoInitialize returned 0x%x.\n", hr));
    }
    */

    pCF = new CAppContainerCF();
    pCSAccessCF = new CClassAccessCF();

    NTSTATUS status = RtlInitializeCriticalSection(&ClassStoreBindList);

/*    hr = pCSAccessCF->CreateInstance( NULL, IID_IClassAccess, (void **) &gpClassAccess );

    if ( hr != S_OK )
    {
        CSDbgPrint(("RPCSS : Counldn't create ClassAccess 0x%x\n", hr));
        return FALSE;
    }
*/    
    g_pCF = new CClassContainerCF;

    if (!pCF || !pCSAccessCF || !g_pCF || !NT_SUCCESS(status))
    {
        ASSERT(FALSE);
    	goto fail;
    }

    return TRUE;

fail:
    if (pCF)
        delete pCF;
    if (pCSAccessCF)
        delete pCSAccessCF;
    if (g_pCF)
    	{
    	delete g_pCF;
    	g_pCF = NULL;
    	}
    
    return FALSE;

}
/*

//  Globals
HINSTANCE g_hInst = NULL;

   

//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    if (IsEqualCLSID(clsid, CLSID_ClassAccess))
    {
        return pCSAccessCF->QueryInterface(iid, ppv);
    }

    *ppv = NULL;

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // BugBug 
    //
    if (ulObjectCount > 0)
        hr = S_FALSE;
    else
        hr = S_OK;
    return hr;
}


//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL _CRTAPI1
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    DWORD cbSize = _MAX_PATH;
    WCHAR wszUserName [_MAX_PATH];

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_hInst = hInst;
        InitializeClassStore();
        break;


    case DLL_PROCESS_DETACH:
        Uninitialize();
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}
*/

//+-------------------------------------------------------------------------
//
//  Function:   CsGetClassAccess
//
//  Synopsis:   Returns an instantiated interface to the Class Store
//              Co-ordinator object in Rpcss.
//
//  Arguments:  [ppIClassAccess] - where to put class access interface pointer
//
//  Returns:    S_OK - Got a Class Access Successfully
//              E_FAIL
//
//--------------------------------------------------------------------------

STDAPI CsGetClassAccess(
    IClassAccess     **     ppIClassAccess)
{
    HRESULT     hr;
    *ppIClassAccess = NULL;

    hr = pCSAccessCF->CreateInstance( NULL, 
        IID_IClassAccess, 
        (void **)ppIClassAccess);

    return hr;

}

//+-------------------------------------------------------------------
//
// CsEnumApps (DebiM 11/7/97)
//
// Returns an enumerator for packages in the Class Store (s).
// The enumerator works across all class stores in the calling users profile.
//
//
// This is used by:
//    - Add/Remove programs to select Corporate Apps
//    - winlogon to obtain the list of assigned apps
//
// Arguments:
//  [in]
//        pszPackageName    :   Optional Wildcard string for PackageName
//        pLastUsn          :   Optional Time Stamp for new packages
//        pCategory         :   Optional CategoryId
//        dwAppFlags        :   Per APPINFO_xxx in objbase.h
//  [out]
//        ppIEnumPackage    :   Returned Interface Pointer
//
// Returns :
//      S_OK or E_NO_CLASSSTORE
//
//--------------------------------------------------------------------
STDAPI
CsEnumApps(
        LPOLESTR        pszPackageName,    // Wildcard string for PackageName
        GUID            *pCategory,        // CategoryId
        ULONGLONG       *pLastUsn,         // Time Stamp for new packages
        DWORD           dwAppFlags,        // Per APPINFO_xxx in objbase.h
        IEnumPackage    **ppIEnumPackage   // Returned Interface Pointer
        )
{
    HRESULT         hr;
    IClassAccess  * pIClassAccess = NULL;

    *ppIEnumPackage = NULL;

    //
    // Get an IClassAccess 
    //
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    //
    // Get the enumerator
    //
    hr = pIClassAccess->EnumPackages (
        pszPackageName,
        pCategory,
        pLastUsn,
        dwAppFlags,
        ppIEnumPackage
        );

    pIClassAccess->Release();
    return hr;
}

void
GetDefaultPlatform(CSPLATFORM *pPlatform)
{
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId;
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;
    pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;
}

//+-------------------------------------------------------------------
//
// CsGetAppInfo
//
// Looks up the given class specification in the DS.  If an application for
// this class specification is found, then the application details are returned.
//
// Arguments :
//
//--------------------------------------------------------------------
STDAPI
CsGetAppInfo(
         uCLSSPEC       *   pClassSpec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT   *   pQueryContext,
         INSTALLINFO    *   pInstallInfo
        )
{
    HRESULT         hr;
    QUERYCONTEXT    QueryContext;
    IClassAccess  * pIClassAccess = NULL;
    
    if ( pQueryContext )
    {
        QueryContext = *pQueryContext;
    }
    else
    {
        QueryContext.dwContext = CLSCTX_ALL;
        GetDefaultPlatform( &QueryContext.Platform );
        QueryContext.Locale = GetThreadLocale();
        QueryContext.dwVersionHi = (DWORD) -1;
        QueryContext.dwVersionLo = (DWORD) -1;
    }

    //
    // Get an IClassAccess 
    //
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;
    hr = pIClassAccess->GetAppInfo(pClassSpec, &QueryContext, pInstallInfo );
    pIClassAccess->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dchannel.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dchannel.cxx
//
//  Contents:   Ole NTSD extension routines to display the RPC channel
//              associated with a remote handler.  This includes the
//              interestiong pieces of CRpcChannelBuffer, CRpcService and
//              CEndPoint.
//
//  Functions:  channelHelp
//              displayChannel
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dipid.h"
#include "dchannel.h"
#include "dstdid.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);





//+-------------------------------------------------------------------------
//
//  Function:   channelHelp
//
//  Synopsis:   Display a menu for the command 'ch'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void channelHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("\nch addr   - Display a CRpcChannelBuffer object:\n");
    Printf("refs stdid state clientThread processLocal? handle OXID IPID destCtx\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayChannel
//
//  Synopsis:   Display an RPC channel starting from the address of the
//              CRpcChannelBuffer object
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [pChnlBfr]        -       Address of channel buffer
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayChannel(HANDLE hProcess,
                    PNTSD_EXTENSION_APIS lpExtensionApis,
                    ULONG pChannel,
                    char *arg)
{
    SRpcChannelBuffer chnlBfr;
    SStdIdentity      stdid;
    SOXIDEntry        oxid;
    SIPIDEntry        ipid;
    char              szClsid[CLSIDSTR_MAX];

    // Check for help
    if (arg[0] == '?')
    {
        Printf("refs stdid state clientThread processLocal? handle OXID IPID destCtx\n");
        return;
    }

    // Read the rpc channel buffer
    ReadMem(&chnlBfr, pChannel, sizeof(SRpcChannelBuffer));

    // References
    Printf("%d ", chnlBfr.ref_count);

    // Standard identity object address
    Printf("%x ", chnlBfr.pStdId);

    // State
    switch (chnlBfr.state)
    {
    case client_cs:
        Printf("client_cs ");
        break;
        
    case proxy_cs:
        Printf("proxy_cs ");
        break;
        
    case server_cs:
        Printf("server_cs ");
        break;
        
    case freethreaded_cs:
        Printf("freethreaded_cs ");
        break;

    default:
        Printf("unknown ");
        break;
    }

    // Client thread
    Printf("%3x ", chnlBfr.client_thread);

    // Process local
    if (chnlBfr.process_local)
    {
        Printf("local ");
    }
    else
    {
        Printf("not-local ");
    }

    // Handle
    Printf("%x ", chnlBfr.handle);

    // OXID entry address
    Printf("%x ", chnlBfr.pOXIDEntry);

    // IPID entry address
    Printf("%x ", chnlBfr.pIPIDEntry);

    // Destination context
    Printf("%x\n", chnlBfr.iDestCtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\inc\cscons.h ===
//
// Sample Locale values 
// Complete Locale definitions are in winnt.h
//
#define LOCALE_ANY             LANG_NEUTRAL // MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT)       
#define LOCALE_USENGLISH       LANG_ENGLISH // MAKELANGID (LANG_ENGLISH, SUBLANG_ENGLISH_US) 
#define LOCALE_JAPANESE        LANG_JAPANESE //MAKELANGID (LANG_JAPANESE, 0)
#define LOCALE_UKENGLISH       MAKELANGID (LANG_ENGLISH, SUBLANG_ENGLISH_UK) 
#define LOCALE_GERMAN          MAKELANGID (LANG_GERMAN, SUBLANG_GERMAN)
#define LOCALE_FRENCH          MAKELANGID (LANG_FRENCH, SUBLANG_FRENCH)


//
// OS values (BUGBUG. Needs syncing with any already defined ones)
//
#define OS_WINNT               VER_PLATFORM_WIN32_NT
#define OS_WIN95               VER_PLATFORM_WIN32_WINDOWS
#define OS_WIN31               VER_PLATFORM_WIN32s


//
// Processor values (BUGBUG. Add JavaVM)
//
#define HW_ANY           PROCESSOR_ARCHITECTURE_UNKNOWN
#define HW_X86           PROCESSOR_ARCHITECTURE_INTEL
#define HW_MIPS          PROCESSOR_ARCHITECTURE_MIPS
#define HW_ALPHA         PROCESSOR_ARCHITECTURE_ALPHA
#define HW_PPC           PROCESSOR_ARCHITECTURE_PPC

#define MAKEARCHITECTURE(h,o)   (h << 8 + o)
//
// Context values (BUGBUG. Needs syncing with any already defined ones)
//
#define CTX_LOCAL_SERVER        CLSCTX_LOCAL_SERVER         // x04
#define CTX_INPROC_SERVER       CLSCTX_INPROC_SERVER        // x01
#define CTX_INPROC_HANDLER      CLSCTX_INPROC_HANDLER       // x02
#define CTX_REMOTE_SERVER	    CLSCTX_REMOTE_SERVER	    //0x10,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\install.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       install.cxx
//
//  Contents:   Routines for queries/install of application state in the DS.
//
//  Functions:
//
//  History:    Feb-97  DKays   Created
//              Nov-97  DebiM   Changed for Beta2
//
//--------------------------------------------------------------------------

#include "cstore.hxx"

extern IClassAccess * gpClassAccess;

//HRESULT InstallAppDetail( DWORD dwActFlags, APPDETAIL *pAppDetail );
HRESULT DarwinPackageAssign( LPCWSTR pwszScript, BOOL InstallNow );
void GetDefaultPlatform(CSPLATFORM *pPlatform);

//+-------------------------------------------------------------------------
//
//  CSGetClass
//
//  Attempts to lookup and possibly install a class.
//
//--------------------------------------------------------------------------
HRESULT CSGetClass(
    DWORD               dwFlags,
    uCLSSPEC *          pClassSpec,
    QUERYCONTEXT *      pQueryContext,
    CLSID *             pClsid,
    INSTALLINFO  **     ppInstallInfo
    )
{
    HRESULT         hr;
    QUERYCONTEXT    QueryContext;
    INSTALLINFO     InstallInfo;

    *pClsid = CLSID_NULL;
    *ppInstallInfo = 0;

    if ( pQueryContext )
    {
        QueryContext = *pQueryContext;
    }
    else
    {
        QueryContext.dwContext = CLSCTX_ALL;
        GetDefaultPlatform( &QueryContext.Platform );
        QueryContext.Locale = GetThreadLocale();
        QueryContext.dwVersionHi = (DWORD) -1;
        QueryContext.dwVersionLo = (DWORD) -1;
    }

    if ( ! gpClassAccess )
        return CS_E_NO_CLASSSTORE;

    hr = gpClassAccess->GetAppInfo( pClassSpec, &QueryContext, &InstallInfo );

    if ( hr != S_OK )
        return hr;

    //
    // Only one package is returned.
    //

#ifdef DARWIN_ENABLED
    if ( DrwFilePath == InstallInfo.PathType )
    {
        hr = DarwinPackageAssign( InstallInfo.pszScriptPath, FALSE );
    }
    else
#endif
    {
        /*
         * The APPDETAIL contains a bunch of useless info that we're not
         * using.  If you need this stuff, then you'll have to change
         * the InstallAppDetail routine to work correctly with per-user
         * registry.
         *
        if ( pPackageDetail->pAppDetail )
        {
            for ( DWORD i = 0; i < pPackageDetail->cApps; i++ )
            {
                hr = InstallAppDetail( pPackageDetail->dwActFlags,
                                       &pPackageDetail->pAppDetail[i] );

                if ( hr != S_OK )
                {
                    FreePackageInfo( &Package );
                    return hr;
                }
            }
        }
         */

        //
        // Return one of the ClassIDs. This is for IE use only.
        //
        if ( pClassSpec->tyspec != TYSPEC_CLSID )
        {
            if ( InstallInfo.pClsid )
                 *pClsid = *(InstallInfo.pClsid);
        }

        /* following is not necessary with the simplification for beta2 - DebiM
        //
        // This information is processed here and does not need to be sent
        // to the client.
        //


        FreeAppDetail( pPackageDetail->pAppDetail );
        MIDL_user_free( pPackageDetail->pAppDetail );
        pPackageDetail->cApps = 0;
        pPackageDetail->pAppDetail = 0;

        if ( Package.cPackages > 1 )
        {
            *ppPackageDetail = (PACKAGEDETAIL *) MIDL_user_allocate( sizeof(PACKAGEDETAIL) );
            if ( *ppPackageDetail )
            {
                **ppPackageDetail = *pPackageDetail;
                Package.pPackageDetail[0] = Package.pPackageDetail[Package.cPackages - 1];
            }
        }
        else
        {
            *ppPackageDetail = pPackageDetail;
            Package.pPackageDetail = 0;
        }

        if ( *ppPackageDetail )
            Package.cPackages--;

        //End of Beta2 simplification
        */
    }

    *ppInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
    memcpy( *ppInstallInfo, &InstallInfo, sizeof(INSTALLINFO) );

    return hr;
}

/*
//+---------------------------------------------------------------------------
//
//  Function:   InstallAppDetail
//
//  Synopsis:   Installs an APPDETAIL obtained from the class store.
//
//----------------------------------------------------------------------------
HRESULT InstallAppDetail(
    DWORD      dwActFlags//,
    //APPDETAIL *pAppDetail)
{
    HRESULT hr = S_OK;
    DWORD   status;
    WCHAR   wszAppid[40];
    DWORD   dwOptions;
    HKEY    hkAppID;
    HKEY    hkCLSID;
    DWORD   Count;
    DWORD   Type;
    DWORD   Size;
    DWORD   Length;
    DWORD   Disp;


    if(!pAppDetail)
        return E_INVALIDARG;

    if(pAppDetail->AppID == GUID_NULL)
        return E_INVALIDARG;

    (void) wStringFromGUID2(
                    pAppDetail->AppID,
                    wszAppid,
                    sizeof(wszAppid) );

    if(dwActFlags & ACTFLG_RunOnce)
    {
        dwOptions = REG_OPTION_VOLATILE;
    }
    else
    {
        dwOptions = REG_OPTION_NON_VOLATILE;
    }

    //
    //Register the APPID.
    //
    if(dwActFlags & ACTFLG_SystemWide)
    {
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              L"Software\\Classes\\AppID",
                              0,
                              KEY_WRITE,
                              &hkAppID);
    }
    else
    {
        status = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                              L"AppID",
                              0,
                              KEY_WRITE,
                              &hkAppID);
    }

    if(ERROR_SUCCESS == status)
    {
        HKEY hAppid;

        status = RegCreateKeyEx(
                    hkAppID,
                    wszAppid,
                    0,
                    NULL,
                    dwOptions,
                    KEY_WRITE,
                    NULL,
                    &hAppid,
                    &Disp );

        if(ERROR_SUCCESS == status)
        {
            WCHAR *    pwszNames = 0;
            HKEY       hkSettings;
            unsigned   __int64 time;
            SYSTEMTIME systemTime;

            //
            //Write the last refresh time.
            //

            GetLocalTime(&systemTime);
            SystemTimeToFileTime(&systemTime, (FILETIME *)&time);
            status = RegSetValueEx(hAppid,
                                   L"LastRefresh",
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) &time,
                                   sizeof(time));

            //
            //Write the remote server name.
            //
            Size = 0;
            for ( Count = 0; Count < pAppDetail->cServers; Count++ )
                Size += (lstrlenW(pAppDetail->prgServerNames[Count]) + 1) * sizeof(WCHAR);

            if (pAppDetail->cServers == 1)
            {
                Type = REG_SZ;
                pwszNames = pAppDetail->prgServerNames[0];
            }
            else if (pAppDetail->cServers > 1)
            {
                Size += sizeof(WCHAR);
                pwszNames = (WCHAR *) alloca( Size );
                if(pwszNames != 0)
                {
                    pwszNames[0] = 0;
                    Length = 0;

                    for ( Count = 0; Count < pAppDetail->cServers; Count++ )
                    {
                        lstrcpyW( &pwszNames[Length], pAppDetail->prgServerNames[Count] );
                        Length += lstrlenW(pAppDetail->prgServerNames[Count]) + 1;
                    }
                    pwszNames[Length] = 0;
                    Type = REG_MULTI_SZ;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            if(pwszNames != NULL)
            {
                status = RegSetValueEx(hAppid,
                                       L"RemoteServerName",
                                       0,
                                       Type,
                                       (PBYTE) pwszNames,
                                       Size );
                if(STATUS_SUCCESS != status)
                {
                    hr = HRESULT_FROM_WIN32(status);
                }
            }
            RegCloseKey( hAppid );
        }
        else
        {
            hr = HRESULT_FROM_WIN32(status);
        }
        RegCloseKey(hkAppID);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(status);
    }

    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Add the APPID value to all of the CLSIDs.
    //
    if(dwActFlags & ACTFLG_SystemWide)
    {
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              L"Software\\Classes\\CLSID",
                              0,
                              KEY_WRITE,
                              &hkCLSID);
    }
    else
    {
        status = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_WRITE,
                              &hkCLSID);
    }

    if(STATUS_SUCCESS == status)
    {
        HKEY    hClsid;
        WCHAR   wszClsid[40];

        for ( Count = 0; Count < pAppDetail->cClasses; Count++ )
        {
            (void) wStringFromGUID2(
                        pAppDetail->prgClsIdList[Count],
                        wszClsid,
                        sizeof(wszClsid) );

            status = RegCreateKeyEx(hkCLSID,
                                    wszClsid,
                                    0,
                                    NULL,
                                    dwOptions,
                                    KEY_SET_VALUE,
                                    NULL,
                                    &hClsid,
                                    &Disp );

            if (STATUS_SUCCESS == status)
            {
                status = RegSetValueEx(hClsid,
                                       L"APPID",
                                       0,
                                       REG_SZ,
                                       (PBYTE) wszAppid,
                                       GUIDSTR_MAX * sizeof(WCHAR) );

                if (status != STATUS_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(status);
                }
                RegCloseKey(hClsid);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(status);
            }
        }
        RegCloseKey(hkCLSID);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(status);
    }
    return hr;
}
*/

#ifdef DARWIN_ENABLED
HRESULT
DarwinPackageAssign(
    IN  LPCWSTR pwszScript,
    IN  BOOL    InstallNow )
{
    BOOL    bStatus;
    HRESULT hr;

    hr = RpcImpersonateClient( NULL );
    if (hr != RPC_S_OK)
        return hr;

    bStatus = AssignApplication( pwszScript, InstallNow );

    RevertToSelf();

    if ( ! bStatus )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}
#endif

void
GetDefaultPlatform(CSPLATFORM *pPlatform)
{
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId;
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;
    pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\inc\csguid.h ===
//
// Temporary file for holding the CLSID_ClassStore CLSID.
//

#ifndef _CSGUID_H_
#define _CSGUID_H_

#ifdef __cplusplus
extern "C" {
#endif

const GUID CLSID_DirectoryClassBase = { // 89E30300-764D-11d0-B282-00A0C90F56FC
		0x89e30300, 
		0x764d, 
		0x11d0, 
		{ 0xb2, 0x82, 0x0, 0xa0, 0xc9, 0xf, 0x56, 0xfc }
		};


const GUID CLSID_ClassAccess = { /* 62392950-1AF8-11d0-B267-00A0C90F56FC */
        0x62392950,
        0x1af8,
        0x11d0,
        {0xb2, 0x67, 0x00, 0xa0, 0xc9, 0x0f, 0x56, 0xfc}
        };


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\csuser.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//  File:   csuser.cxx
//
//      Maintains a list of class containers per User SID.
//      Looks up this list for every IClassAccess call from OLE32/SCM.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"
void GetCurrentUsn(LPOLESTR pStoreUsn);

//
// Link list pointer for Class Containers Seen
//
extern CLASSCONTAINER *gpContainerHead;

//
// Link list pointer for User Profiles Seen
//
extern USERPROFILE *gpUserHead;


// Initialzed in InitializeClassStore at startup

extern CRITICAL_SECTION    ClassStoreBindList;

//-------------------------------------------------------------------------
//
// OpenUserRegKey
//
//  Opens a key under a user's HKEY_CLASSES_ROOT registry key.  On NT5
//  HKCR is equivalent to HKEY_USERS\{sid string}\Software\Classes.
//
//  A SID string is used to create
//  the proper registry key name to open.
//
//-------------------------------------------------------------------------
DWORD
OpenUserRegKey(
    IN  PSID        pSid,
    IN  WCHAR *     pwszSubKey,
    OUT HKEY *      phKey
    )
{
    UNICODE_STRING  UnicodeString;
    WCHAR *         pwszKey;
    DWORD           AllocSize;
    NTSTATUS        Status;

    UnicodeString.Length = UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = 0;

    Status = RtlConvertSidToUnicodeString(
                    &UnicodeString,
                    pSid,
                    (BOOLEAN)TRUE // Allocate
                    );

    //
    // Don't return a raw NT status code.  This is the only possible error
    // condition presuming our sid is valid.
    //
    if ( Status != STATUS_SUCCESS )
        return ERROR_OUTOFMEMORY;

    //
    // Your friendly reminder, unicode string length is in bytes and doesn't include
    // null terminator, if any.
    // Add byte for '\\' and end null.
    //
    AllocSize = UnicodeString.Length + ((1 + lstrlen(pwszSubKey) + 1) * sizeof(WCHAR));
    pwszKey = (WCHAR *) PrivMemAlloc( AllocSize );

    if ( pwszKey )
    {
        memcpy( pwszKey, UnicodeString.Buffer, UnicodeString.Length );
        pwszKey[UnicodeString.Length / 2] = L'\\';
        lstrcpyW( &pwszKey[(UnicodeString.Length / 2) + 1], pwszSubKey );
    }

    RtlFreeUnicodeString( &UnicodeString );

    if ( ! pwszKey )
        return ERROR_OUTOFMEMORY;

    Status = RegOpenKeyEx(
                    HKEY_USERS,
                    pwszKey,
                    0,
                    KEY_READ,
                    phKey );

    PrivMemFree( pwszKey );

    return Status;
}

//
// GetUserSid
// ----------
//
//  Synopsis:       return the user SID of the caller.
//
//  Arguments:      &PSID       -       Where to store the caller's PSID
//
//  Returns:        HRESULT     -       S_OK if successful
//                                      E_FAIL otherwise
//
SID     LocalSystemSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };

#define CS_CALL_LOCALSYSTEM    1
#define CS_CALL_USERPROCESS    2
#define CS_CALL_IMPERSONATED   3

HRESULT GetUserSid(PSID *ppUserSid, UINT *pCallType)
{
    BYTE achBuffer[100];
    PTOKEN_USER pUser = (PTOKEN_USER) &achBuffer;
    PSID pSid;
    DWORD dwBytesRequired;
    BOOL fAllocatedBuffer = FALSE;
    HRESULT hr = S_OK;
    HANDLE   hUserToken = NULL;
    BOOL     fImpersonated = TRUE;


    *pCallType = CS_CALL_USERPROCESS;

    // Initialize
    *ppUserSid = NULL;

    // Get caller's token while impersonating

    if (!OpenThreadToken(GetCurrentThread(),
        TOKEN_DUPLICATE | TOKEN_QUERY,
        TRUE,
        &hUserToken))
    {
        fImpersonated = FALSE;
        if (ERROR_NO_TOKEN != GetLastError())
            return HRESULT_FROM_WIN32(GetLastError());

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_DUPLICATE | TOKEN_QUERY,
                &hUserToken))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!GetTokenInformation(
                 hUserToken,                // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 sizeof(achBuffer),         // TokenInformationLength
                 &dwBytesRequired           // ReturnLength
                 ))
        {

            //
            // Need to handle the case of insufficient buffer size.
            //

            if (sizeof(achBuffer) >= dwBytesRequired)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }


            if (SUCCEEDED(hr))
            {
                //
                // Allocate space for the user info
                //

                pUser = (PTOKEN_USER) CoTaskMemAlloc(dwBytesRequired);
                if (pUser == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            if (SUCCEEDED(hr))
            {
                fAllocatedBuffer = TRUE;

                //
                // Read in the UserInfo
                //


                if (!GetTokenInformation(
                     hUserToken,                // Handle
                     TokenUser,                 // TokenInformationClass
                     pUser,                     // TokenInformation
                     dwBytesRequired,           // TokenInformationLength
                     &dwBytesRequired           // ReturnLength
                     ))

                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }

    }


    if (SUCCEEDED(hr))
    {

        //
        // Distinguish between
        //            a) LOCAL_SYSTEM,
        //            b) Impersonated Call from a LOCAL_SYSTEM
        // and        c) In_proc call from a user process
        //
        // For case (c) make the SID null.
        //

        if (EqualSid(pUser->User.Sid, &LocalSystemSid))
        {
            *pCallType = CS_CALL_LOCALSYSTEM;
        }
        else
            if (fImpersonated)
            {
                *pCallType = CS_CALL_IMPERSONATED;
            }
            else
            {
                *pCallType = CS_CALL_USERPROCESS;
            }

        // Alloc buffer for copy of SID

        dwBytesRequired = GetLengthSid(pUser->User.Sid);
        *ppUserSid = CoTaskMemAlloc(dwBytesRequired);
        if (*ppUserSid == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Copy SID

            if (!CopySid(dwBytesRequired, *ppUserSid, pUser->User.Sid))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CoTaskMemFree(*ppUserSid);
                *ppUserSid = NULL;
            }
        }
    }

    if (fAllocatedBuffer == TRUE)
    {
        CoTaskMemFree(pUser);
    }

    if (hUserToken)
        CloseHandle( hUserToken );

    return hr;
}


#if 0
//
// GetDomainClassStore
// -------------------
//
//  This will go away.
//
//  Currently this is used to get the Class Store Path
//  for the domain.
//


#define     DEFAULTSTORENAME  L"CN=ClassStore"


HRESULT
GetDomainClassStore(
       LPOLESTR * pszDefaultContainer,
       LPOLESTR * pszDefaultStore)

       //
       // Finds the Root Path for the DC for this machine
       // Then gets the Default Known CLass Store for the DC
       //
{
    HRESULT         hr;
    LPOLESTR        PathNames[2];
    VARIANT         * pVarFilter = NULL;
    IEnumVARIANT    * pEnum;
    IADs          * pADs;
    VARIANT         VariantArray[2];
    IDispatch       * pDispatch = NULL;
    ULONG           cFetched;
    IADsContainer * pContainer = NULL;

    //
    // Do a bind to the DC by a GetObject for the Path LDAP:
    //
    hr = ADsGetObject(
                L"LDAP:",
                IID_IADsContainer,
                (void **)&pContainer
                );

    RETURN_ON_FAILURE(hr);

    hr = ADsBuildEnumerator(
            pContainer,
            &pEnum
            );

    hr = ADsEnumerateNext(
                    pEnum,
                    1,
                    VariantArray,
                    &cFetched
                    );

    pEnum->Release();

    if ((hr == S_FALSE) || (cFetched == 0))
    {
        return E_FAIL;
    }

    pDispatch = VariantArray[0].pdispVal;
    memset(VariantArray, 0, sizeof(VARIANT)*2);
    hr = pDispatch->QueryInterface(IID_IADs, (void **) &pADs) ;
    pDispatch->Release();

    pADs->get_ADsPath(pszDefaultContainer);
    pADs->Release();
    pContainer->Release();

    *pszDefaultStore = DEFAULTSTORENAME;

    return S_OK;
}


#endif

// GetKnownClassStore
// -------------------
//
//
//  Synopsis:       Gets a class container path.
//                  Looks up list of containers seen
//                  and returns the pointer for this container.
//                  If a new class container is seen,
//                  it is added to this list and its pointer is returned.
//
//  Arguments:      [in] pszPath - Class container Path
//  Returns:        pClassStoreNode : Class Container Node
//
//


PCLASSCONTAINER
GetKnownClassStore (LPOLESTR pszPath)
{
    PCLASSCONTAINER pCS = gpContainerHead;

    //
    // Chain thru the link list of containers ...
    //
    while (pCS != NULL)
    {
        if (!wcscmp (pszPath, pCS->pszClassStorePath))
        {
            break;
        }
        pCS = pCS->pNextClassStore;
    }

    //
    // If not matched ..
    //   Add it to the beginning of the list.
    //

    if (pCS == NULL)
    {
        pCS = (CLASSCONTAINER *) CoTaskMemAlloc (sizeof(CLASSCONTAINER));
        pCS->pNextClassStore = gpContainerHead;
        gpContainerHead = pCS;
        pCS->gpClassStore = NULL;
        pCS->cBindFailures = 0;
        pCS->cAccess = 0;
        pCS->cNotFound = 0;
        pCS->pszClassStorePath = (LPOLESTR)CoTaskMemAlloc
            (sizeof(WCHAR) * (wcslen(pszPath)+1));
        wcscpy (pCS->pszClassStorePath, pszPath);
        //++cStores;
    }

    return pCS;

}

/*
//
// GetUserSyncPoint
// ----------------
//
//  Synopsis:       Receives and Stores the Next Sync Point.
//                  Reads and returns the current sync point.
//                  When Advance is called the current becomes the lastsyncpoint.
//                  No error returned,
//
// BUGBUG. This is NOT thread-safe now. Fix it!
//
HRESULT GetUserSyncPoint(LPWSTR pszContainer, CSUSN *pPrevUsn)
{
    LONG     lErrorCode;
    DWORD    dwDataLen = _MAX_PATH;
    DWORD    dwType;
    HKEY     hKey = NULL;
    HRESULT  hr = S_OK;
    WCHAR    wszSync[_MAX_PATH + 1];
    PSID     pUserSid;
    CSUSN    CurrUsn;

    //
    // Get the current USN
    //

    GetCurrentUsn(&CurrUsn);

    //
    // Get the SID of the calling process
    //

    hr = GetUserSid(&pUserSid);
    RETURN_ON_FAILURE(hr);

    //
    // This should be outside of impersonation
    // So revert to LOCAL SYSTEM.

    RpcRevertToSelf();

    lErrorCode = OpenUserRegKey(
        pUserSid,
        L"Software\\Microsoft\\ClassStore",
        &hKey);


    if (lErrorCode != ERROR_SUCCESS)
    {
        DWORD dwDisp;

        lErrorCode = RegCreateKeyEx(HKEY_CURRENT_USER,
                              L"Software\\Microsoft\\ClassStore",
                              NULL,
                              L"REG_SZ",
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              &dwDisp);
    }


    lErrorCode = RegQueryValueEx(hKey,
                                 pszContainer,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)wszSync,
                                 &dwDataLen);


    if (lErrorCode != ERROR_SUCCESS)
    {
        pPrevUsn->dwLowDateTime = CurrUsn.dwLowDateTime;
        pPrevUsn->dwHighDateTime = CurrUsn.dwHighDateTime;

        wsprintf (wszSync, L"%lu %lu %lu %lu",
            pPrevUsn->dwHighDateTime,
            pPrevUsn->dwLowDateTime,
            pPrevUsn->dwHighDateTime,
            pPrevUsn->dwLowDateTime);

        lErrorCode = RegSetValueEx(
            hKey,
            pszContainer, //L"LastSync",
            NULL,
            REG_SZ,
            (LPBYTE)wszSync,
            (2 * wcslen(wszSync)) + 2);

        RegCloseKey(hKey);
    }
    else
    {
        swscanf (wszSync, L"%lu %lu",
            &pPrevUsn->dwHighDateTime,
            &pPrevUsn->dwLowDateTime);

        wsprintf (wszSync, L"%lu %lu %lu %lu",
            pPrevUsn->dwHighDateTime,
            pPrevUsn->dwLowDateTime,
            CurrUsn.dwHighDateTime,
            CurrUsn.dwLowDateTime);

        lErrorCode = RegSetValueEx(
            hKey,
            pszContainer, //L"LastSync",
            NULL,
            REG_SZ,
            (LPBYTE)wszSync,
            (2 * wcslen(wszSync)) + 2);

        RegCloseKey(hKey);
    }

    // Impersonate again

    RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    return S_OK;
}

//
// AdvanceUserSyncPoint
// --------------------
//
//  Synopsis:       Makes the Next Sync Point as Last Sync Point.
//                  No error returned,
//
//
HRESULT AdvanceUserSyncPoint(LPWSTR pszContainer)
{
    LONG     lErrorCode;
    DWORD    dwDataLen = _MAX_PATH;
    DWORD    dwType;
    HKEY     hKey = NULL;
    HRESULT  hr = S_OK;
    WCHAR    wszSync[_MAX_PATH + 1];
    CSUSN    PrevUsn, NextUsn;
    PSID     pUserSid;

    //
    // Get the SID of the calling process
    // Already assumed to be under impersonation
    //
    hr = GetUserSid(&pUserSid);
    RETURN_ON_FAILURE(hr);

    //
    // This should be outside of impersonation
    // So revert to LOCAL SYSTEM.

    RpcRevertToSelf();

    lErrorCode = OpenUserRegKey(
        pUserSid,
        L"Software\\Microsoft\\ClassStore",
        &hKey);

    if ( lErrorCode == ERROR_SUCCESS)
    {
        lErrorCode = RegQueryValueEx(hKey,
                                 pszContainer,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)wszSync,
                                 &dwDataLen);

        if (lErrorCode != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
        }
    }

    if (lErrorCode == ERROR_SUCCESS)
    {
        swscanf (wszSync, L"%lu %lu %lu %lu",
            &PrevUsn.dwHighDateTime,
            &PrevUsn.dwLowDateTime,
            &NextUsn.dwHighDateTime,
            &NextUsn.dwLowDateTime);

        wsprintf (wszSync, L"%lu %lu %lu %lu",
            NextUsn.dwHighDateTime,
            NextUsn.dwLowDateTime,
            NextUsn.dwHighDateTime,
            NextUsn.dwLowDateTime);

        lErrorCode = RegSetValueEx(
            hKey,
            pszContainer, //L"LastSync",
            NULL,
            REG_SZ,
            (LPBYTE)wszSync,
            (2 * wcslen(wszSync)) + 2);

        RegCloseKey(hKey);
    }

    // Impersonate again

    RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    return S_OK;
}
*/

extern WCHAR pwszDebugPath [];
extern BOOL  fDebugPath;

//
// GetPerUserClassStore
// ---------------------
//
//  Synopsis:       Gets the ADT Class Store List from the
//                  per-user Registry.
//                  Returns error if none defined,
//
//  Arguments:
//                  [out] ppStoreList : where to store list of class container
//                                      serial numbers
//                  [out] pcStores    : where to store number of class containers
//
//  Returns:        S_OK,
//
//  History:        Changed by (DebiM)
//                  2/24/97
//                  return a NULL list of Class Stores when none defined.
//
#define MAXCLASSSTORES  10

HRESULT GetPerUserClassStore(
                    PSID      pSid,
                    UINT      CallType,
                    LPOLESTR  **ppStoreList,
                    DWORD     *pcStores)

{
    LONG    lErrorCode;
    DWORD    dwDataLen = 2000;
    DWORD    dwType;
    HKEY    hKey = NULL;
    HRESULT hr = S_OK;
    LPOLESTR pszPath, pszStart;
    LPOLESTR *ppszPath;
    WCHAR    pszPathList [2000 + 1];

    *pcStores = 0;
    *ppStoreList = NULL;

    if (!fDebugPath)
    {
        switch (CallType)
        {
        case CS_CALL_LOCALSYSTEM :

            lErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy",
                NULL,
                KEY_READ,
                &hKey);
            break;

        case CS_CALL_IMPERSONATED :

            lErrorCode = OpenUserRegKey(
                pSid,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy",
                &hKey);
            break;

        case CS_CALL_USERPROCESS :

            lErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy",
                NULL,
                KEY_ALL_ACCESS,
                &hKey);
            break;
        default:
            return E_FAIL;
        }

        if ( lErrorCode != ERROR_SUCCESS)
        {
            // treat as NULL list of Class Stores
            return S_OK;
        }

        lErrorCode = RegQueryValueEx(hKey,
                                 L"ClassStorePath",
                                 NULL,
                                 &dwType,
                                 (LPBYTE)pszPathList,
                                 &dwDataLen);

        RegCloseKey(hKey);

        if (lErrorCode != ERROR_SUCCESS)
        {
            // treat as NULL list of Class Stores
            return S_OK;
        }
    }
    else  // Test Mode - Privately Set Path - Only for testing
    {
        wcscpy (&pszPathList[0], &pwszDebugPath[0]);
    }


    pszPath = pszPathList;

    ppszPath = *ppStoreList = (LPOLESTR *) CoTaskMemAlloc
        (sizeof(LPOLESTR) * MAXCLASSSTORES);

    if (*ppStoreList == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Parse the list to separate different class containers
    //

    while (*pszPath)
    {
        while (*pszPath == L' ')
            ++pszPath;
        pszStart = pszPath;

        if (!*pszPath)
            break;
        if (*pszPath == L';')
        {
            ++pszPath;
            continue;
        }

        while (*pszPath && (*pszPath != L';'))
            ++pszPath;

        //
        // got one. save it.
        //
        *ppszPath = (LPOLESTR) CoTaskMemAlloc (sizeof(WCHAR) * (pszPath - pszStart + 1));

        memcpy (*ppszPath, pszStart, sizeof (WCHAR) * (pszPath - pszStart));
        *((*ppszPath)+(pszPath - pszStart)) = NULL;

        (ppszPath)++;
        ++(*pcStores);

        if (*pszPath == L';')
        {
            ++pszPath;
        }
    }

    return S_OK;
}

//
// CacheSid
// ---------
//
//  Synopsis:       Gets a SID.
//                  Gets a list of class container paths for this SID.
//                  Looks up known class containers to map these to
//                  ClassStore Node pointers.
//                  Caches the SID and associated class store list.
//
//  Arguments:
//                  [in]   pUserSid: SID
//                  [in]   ppStoreList: Class Store Path List,
//                  [in]   cStores: Number of Class Stores
//
//
//  Returns:        ppStoreList: Class Store Node List
//

PCLASSCONTAINER * CacheSid (PSID pUserSid,
                  LPOLESTR *ppStoreList,
                  DWORD cStores)
{
    ULONG i;
    PCLASSCONTAINER *pStoreList, *pList;
    USERPROFILE *pUser;

    //
    // Allocate a User structure
    // and store the user specific values in it
    //
    pUser = (USERPROFILE *) CoTaskMemAlloc (sizeof(USERPROFILE));
    if (pUserSid)
    {
        pUser->pCachedSid = (PSID) CoTaskMemAlloc (GetLengthSid(pUserSid));


        CopySid(GetLengthSid(pUserSid),
            pUser->pCachedSid,
            pUserSid);
    }
    else
        pUser->pCachedSid = NULL;


    //
    // Link it to the beginning of the User Linklist
    //
    pUser->pNextUser = gpUserHead;
    gpUserHead = pUser;

    //
    // Find its ClassStore Path and setup the class store node chain
    //
    if (cStores == 0)
    {
        // NULL list of Class Stores

        pStoreList = pUser->pUserStoreList = NULL;
    }
    else
    {
        pStoreList = pList =
            pUser->pUserStoreList = (PCLASSCONTAINER *)
            CoTaskMemAlloc (sizeof(PCLASSCONTAINER) * cStores);

        for (i=0; i < cStores; i++)
        {
            *pList = GetKnownClassStore (*ppStoreList);
            ppStoreList++;
            pList++;
        }
    }

    pUser->cUserStoreCount = cStores;

    return pStoreList;
}


//
// GetUserClassStores
// ------------------
//
//  Synopsis:       This routine finds out the SID of the user.
//                  It then looks up a global cache of SIDs to see if it
//                  has accessed the list of Class Stores for this user.
//
//                  If not, it reads the Class Store list and parses it.
//                  If it has prior knowledge it reurns the parsed list.
//  Arguments:
//                  [out]  pcStores: Number of Class Stores
//                  [out]  ppStoreIdList: Class Store Id List,
//
//  Returns:        S_OK
//                  See change note for GetPerUserClassStore().
//                  May return a NULL list of Class Stores.
//
//

HRESULT GetUserClassStores(
                    PCLASSCONTAINER     **ppStoreList,
                    DWORD     *pcStores)

{
    int l;
    PSID pUserSid;
    HRESULT hr = S_OK;
    UINT    CallType;

    // Impersonate before accessing SID

    //RpcImpersonateClient((RPC_BINDING_HANDLE)0);

    //
    // Get the SID of the calling process
    //

    hr = GetUserSid(&pUserSid, &CallType);

    if (FAILED(hr))
    {
        pUserSid = NULL;
        hr = S_OK;
    }

    //RpcRevertToSelf();

    EnterCriticalSection (&ClassStoreBindList);

    //
    // Look this up in the global list of SIDs
    //
    USERPROFILE *pUser = gpUserHead;

    while (pUser != NULL)
    {
        if ((pUserSid == pUser->pCachedSid) ||              // Null UserSid
            (EqualSid(pUserSid, pUser->pCachedSid)))
        //
        // Found the match
        //
        {
            *ppStoreList = pUser->pUserStoreList;
            *pcStores = pUser->cUserStoreCount;
            break;
        }
        pUser = pUser->pNextUser;
    }


    if (pUser == NULL)
    {
        //
        // Didnt find this User's Sid
        // Get the Class Store List and cache it along with this SID
        //
        LPOLESTR *ppStoreNameList = NULL;
        UINT     i;

        hr = GetPerUserClassStore(
                pUserSid, CallType, &ppStoreNameList, pcStores);

        //
        // Note that the above may return a NULL list of Class Stores
        //

        if (SUCCEEDED(hr))
        {
            *ppStoreList = CacheSid (pUserSid, ppStoreNameList, *pcStores);
            //
            // release memory allocated in GetPerUserClassStore()
            //
            for (i=0; i < *pcStores; ++i)
            {
                CoTaskMemFree (ppStoreNameList[i]);
            }

            if (ppStoreNameList)
                CoTaskMemFree (ppStoreNameList);
        }
    }

    LeaveCriticalSection (&ClassStoreBindList);
    //
    // Free the Sid
    //
    if (pUserSid)
        CoTaskMemFree (pUserSid);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\cs\cstore\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   DllMain for csadm.dll
//
//  Functions:  DllMain, DllGetClassObject
//
//  History:    05-May-97  DebiM   Created.
//              16-Feb-98  UShaji  CsGetClassStorePathForUser 
//----------------------------------------------------------------------------
#include "cstore.hxx"

#pragma hdrstop

void Uninitialize();
BOOL InitializeClassStore(BOOL fInit);

//  Globals
HINSTANCE g_hInst = NULL;
ULONG  g_ulObjCount = 0;    // Number of objects alive in csadm.dll

CClassContainerCF  *g_pCF = NULL;
extern CClassAccessCF      *   pCSAccessCF;


/*
void Uninit()
//
// This routine is called at dll detach time
//
{
    //
    // release the Class Factory object
    //
    if (g_pCF)
        g_pCF->Release();
}

*/    


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    if (IsEqualCLSID(clsid, CLSID_DirectoryClassBase))
    {
        return g_pCF->QueryInterface(iid, ppv);
    }
    
    if (IsEqualCLSID(clsid, CLSID_ClassAccess))
    {
        return pCSAccessCF->QueryInterface(iid, ppv);
    }

    *ppv = NULL;

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    //
    // BugBug 
    //
    /*
    if (ulObjectCount > 0)
        hr = S_FALSE;
    else
        hr = S_OK;
    */
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    DWORD cbSize = _MAX_PATH;
    WCHAR wszUserName [_MAX_PATH];

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_hInst = hInst;
        //g_pCF = new CClassContainerCF;
        InitializeClassStore(FALSE);
        break;


    case DLL_PROCESS_DETACH:
        //Uninit();
        Uninitialize();
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}

//+---------------------------------------------------------------
//
//  Function:   CsCreateClassStore
//
//  Synopsis:   Public entrypoint for creating an empty class store. factories
//
//----------------------------------------------------------------

STDAPI
CsCreateClassStore(LPOLESTR szParentPath, LPOLESTR szStoreName)
{
    LPOLESTR szPath;
    if (wcsncmp (szParentPath, L"ADCS:", 5) == 0)
        szPath = szParentPath + 5;
    else
        szPath = szParentPath;
    return CreateRepository(szPath, szStoreName);
}

//+---------------------------------------------------------------
//
//  Function:   CsGetClassStore
//
//  Synopsis:   Public entrypoint for binding to a class store and
//              get back IClassAdmin
//
//----------------------------------------------------------------

STDAPI
CsGetClassStore(LPOLESTR szPath, void **ppIClassAdmin)
{
    return g_pCF->CreateConnectedInstance(
                  szPath, 
                  ppIClassAdmin);
}

//+---------------------------------------------------------------
//
//  Function:   CsDeleteClassStore
//
//  Synopsis:   Public entrypoint for deleting a class store container from DS.
//
//----------------------------------------------------------------

STDAPI
CsDeleteClassStore(LPOLESTR szPath)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
// CsGetAppCategories 
//
// Returns the complete list of Category GUIDs and Category Descriptions 
// per the input Locale.
//
//
// This is used by Add/Remove programs to get the definitive list of 
// Application Categories.
//
// The caller needs to free the memory allocated using CoTaskMemFree().
//
// Arguments:
//  [in]
//        LCID : Locale
//  [out]
//        APPCATEGORYINFOLIST *pAppCategoryList:   
//               Returned list of GUIDs and Unicode descriptions
//
// Returns :
//      S_OK 
//
//--------------------------------------------------------------------
STDAPI
CsGetAppCategories (APPCATEGORYINFOLIST  *pAppCategoryList)
{
    HRESULT         hr;
    IClassAdmin   * pIClassAdmin = NULL;

    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    hr = pIClassAdmin->GetAppCategories (
		GetUserDefaultLCID(), 
		pAppCategoryList);

    pIClassAdmin->Release();

    return hr;
}


//+-------------------------------------------------------------------
//
// CsGetClassStorePath
//
// Returns the class store path for the user.
//
//
// This is used by Winlogon to get the class store path for a given user.
//
// The caller needs to free the memory allocated using CoTaskMemFree().
//
// Arguments:
//  [in]
//         DSProfilePath: Path For the DS Object given to winlogon.
//                        User Doesn't have to any checks.
//         
//  [out]
//        pCSPath: Unicode Path to the class store for the user.
//
// Returns :
//      S_OK, or whatever error underlying DS layer returns.
//      BUGBUG:: Error code have to be remapped.
//
//--------------------------------------------------------------------
STDAPI
CsGetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR *pCSPath)
{
#if (0)
    HRESULT hr = S_OK;
    IADs    *pADs = NULL;

    if ((!DSProfilePath) || (IsBadStringPtr(DSProfilePath, _MAX_PATH)))
        return E_INVALIDARG;

    hr = ADsGetObject(
                        DSProfilePath, 
                        IID_IADs,
                        (void **)&pADs
                    );
    
    RETURN_ON_FAILURE(hr);

    hr = GetPropertyAlloc(pADs, DEFAULTCLASSSTOREPATH, pCSPath);

    pADs->Release();

    return hr;
#else // temporary hack until property is written to ds

    if (!(*pCSPath = (WCHAR*) CoTaskMemAlloc(lstrlen(DSProfilePath) * sizeof (WCHAR) + sizeof L"CN=Class Store,")))
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(*pCSPath, L"LDAP://");
    lstrcat(*pCSPath, L"CN=Class Store,");
    lstrcat(*pCSPath, DSProfilePath + ((sizeof(L"LDAP://") / sizeof(WCHAR)) - 1));

    return S_OK;
#endif
}

//+-------------------------------------------------------------------
//
// CsSetClassStorePath
//
// Writes the user class store path.
//
//
// This is used by MMC snapin to write the class store path for a given user.
//
// Arguments:
//  [in]
//         DSProfilePath: Path For the DS Object.
//                        User Doesn't have to any checks.
//
//        pCSPath: Unicode Path to the class store for the user.
//
// Returns :
//      S_OK, or whatever error underlying DS layer returns.
//      BUGBUG:: Error code have to be remapped.
//
//--------------------------------------------------------------------
STDAPI
CsSetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR szCSPath)
{
    HRESULT  hr = S_OK;
    IADs    *pADs = NULL;

    if ((!DSProfilePath) || (IsBadStringPtr(DSProfilePath, _MAX_PATH)))
        return E_INVALIDARG;

    hr = ADsGetObject(
                        DSProfilePath, 
                        IID_IADs,
                        (void **)&pADs
                    );
    
    RETURN_ON_FAILURE(hr);

    hr = SetProperty(pADs, DEFAULTCLASSSTOREPATH, szCSPath);

    if (SUCCEEDED(hr))
        hr = StoreIt(pADs);
    
    pADs->Release();

    return hr;
}
STDAPI
ReleasePackageInfo(PACKAGEDISPINFO *pPackageInfo)
{
    DWORD i;
    if (pPackageInfo) 
    {
        CoTaskMemFree(pPackageInfo->pszScriptPath);
        CoTaskMemFree(pPackageInfo->pszPackageName);
        for (i = 0; i < (pPackageInfo->cUpgrades); i++) 
            CoTaskMemFree(pPackageInfo->prgUpgradeScript[i]);
        CoTaskMemFree(pPackageInfo->prgUpgradeScript);
        CoTaskMemFree(pPackageInfo->prgUpgradeFlag);
    }
    return S_OK;
}


STDAPI
ReleaseInstallInfo(INSTALLINFO *pInstallInfo)
{
    DWORD i;
    if (pInstallInfo)
    {
        CoTaskMemFree(pInstallInfo->pszSetupCommand);
        CoTaskMemFree(pInstallInfo->pszScriptPath);
        CoTaskMemFree(pInstallInfo->pszUrl);
        CoTaskMemFree(pInstallInfo->pClsid);
        for (i = 0; i < (pInstallInfo->cUpgrades); i++) 
            CoTaskMemFree(pInstallInfo->prgUpgradeScript[i]);
        CoTaskMemFree(pInstallInfo->prgUpgradeScript);
        CoTaskMemFree(pInstallInfo->prgUpgradeFlag);
    }
    return S_OK;
}

void
ReleaseClassDetail(CLASSDETAIL ClassDetail)
{
    DWORD i;
    for (i = 0; i < ClassDetail.cProgId; i++)
        CoTaskMemFree(ClassDetail.prgProgId[i]);
    CoTaskMemFree(ClassDetail.prgProgId);
}

STDAPI
ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail)
{
   DWORD i;
   if (pPackageDetail) 
   {
       if (pPackageDetail->pActInfo)
       {   
           for (i = 0; i < pPackageDetail->pActInfo->cClasses; i++)
               ReleaseClassDetail((pPackageDetail->pActInfo->pClasses)[i]);
           CoTaskMemFree(pPackageDetail->pActInfo->pClasses);
           
           CoTaskMemFree(pPackageDetail->pActInfo->prgShellFileExt);
           CoTaskMemFree(pPackageDetail->pActInfo->prgPriority);
           CoTaskMemFree(pPackageDetail->pActInfo->prgInterfaceId);
           CoTaskMemFree(pPackageDetail->pActInfo->prgTlbId);
           CoTaskMemFree(pPackageDetail->pActInfo);
       }
       
       if (pPackageDetail->pPlatformInfo)
       {
           CoTaskMemFree(pPackageDetail->pPlatformInfo->prgPlatform);
           CoTaskMemFree(pPackageDetail->pPlatformInfo->prgLocale);
           CoTaskMemFree(pPackageDetail->pPlatformInfo);
       }
       
       if (pPackageDetail->pInstallInfo)
       {
           ReleaseInstallInfo(pPackageDetail->pInstallInfo);
           CoTaskMemFree(pPackageDetail->pInstallInfo);
       }
       
       for (i = 0; i < (pPackageDetail->cSources); i++)
           CoTaskMemFree(pPackageDetail->pszSourceList[i]);

       CoTaskMemFree(pPackageDetail->pszSourceList);
       CoTaskMemFree(pPackageDetail->rpCategory);
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dchannel.h ===
typedef enum EChannelState
{
  // The channel on the client side held by the remote handler.
  client_cs = 1,

  // The channels on the client side held by proxies.
  proxy_cs = 2,

  // The server channels held by remote handlers.
  server_cs = 16,

  // Flag to indicate that the channel may be used on any thread.
  freethreaded_cs = 64
} EChannelState;




// Forward reference
struct SStdIdentity;



struct SRpcChannelBuffer
{
    void              *_vtbl1;
    ULONG              ref_count;
    SStdIdentity      *pStdId;
    DWORD              state;
    DWORD	       client_thread;
    BOOL	       process_local;
    handle_t           handle;
    SOXIDEntry        *pOXIDEntry;
    SIPIDEntry        *pIPIDEntry;
    DWORD              iDestCtx;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dclscach.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dclscach.cxx
//
//  Contents:   Ole NTSD extension routines to display the class cache in
//              the scm
//
//  Functions:  displayClassCache
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dclscach.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);




//+-------------------------------------------------------------------------
//
//  Function:   classCacheHelp
//
//  Synopsis:   Prints a short help menu for !ole.cc
//
//  Arguments:  [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    27-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void classCacheHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("cc         - Display class cache info\n");
    Printf("local-server-path[(16)] clsid debug? [handler]\n");
    Printf("  hRpc hWnd flags PSID desktop\n");
    Printf("    ...\n");
}




//+-------------------------------------------------------------------------
//
//  Function:   displayClassCache
//
//  Synopsis:   Displays the retail scm class cache
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    27-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayClassCache(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG             addr;
    SClassCacheList   sClassCacheList;
    SSkipListEntry    sSkipListEntry;
    SClassData        sClassData;
    SLocalServer      sLocalServer;
    SStringID         sStringId;
    WCHAR            *pwszUni;
    WCHAR             wszUni[128];
    char              szAnsi[128];
    SArrayFValue      sArrayFValue;
    SSrvRegistration *pSrvReg;
    
    // Read the class cache
    addr = GetExpression("scm!g_pcllClassCache");
    ReadMem(&addr, addr, sizeof(ULONG));
    ReadMem(&sClassCacheList, addr, sizeof(SClassCacheList));
    
    // Read the initial skiplist entry
    ReadMem(&sSkipListEntry, sClassCacheList._pSkipList,
            sizeof(SSkipListEntry));

    // Do over skiplist entries
    do
    {
        // Just in case
        if (CheckControlC())
        {
            return;
        }
        
        // Read the next skiplist entry
        ReadMem(&sSkipListEntry, sSkipListEntry._apBaseForward,
                sizeof(SSkipListEntry));
        
        // Read the CClassData structure
        ReadMem(&sClassData, sSkipListEntry._pvEntry, sizeof(SClassData));
        
        // Read the CLocalServer structure
        ReadMem(&sLocalServer, sClassData._slocalsrv, sizeof(SLocalServer));
        
        // Print the path
        pwszUni = (WCHAR *) OleAlloc(sLocalServer._stringId._cPath *
                                     sizeof(WCHAR));
        ReadMem(pwszUni, sLocalServer._stringId._pwszPath,
                sLocalServer._stringId._cPath * sizeof(WCHAR));
        Unicode2Ansi(szAnsi, pwszUni, sLocalServer._stringId._cPath *
                     sizeof(WCHAR));
        if (sClassData._fLocalServer16)
        {
            Printf("%s(16) ", szAnsi);
        }
        else
        {
            Printf("%s ", szAnsi);
        }
        OleFree(pwszUni);
        
        // Print the clsid
        FormatCLSID(sClassData._clsid, szAnsi);
        Printf("%s ", szAnsi);
        
        // Whether activated under a debugger
        if (sClassData._fDebug)
        {
            Printf("*Debug*");
        }

        // Any specified handler
        if (sClassData._shandlr)
        {
            ReadMem(&sStringId, sClassData._shandlr, sizeof(SStringID));
            
            // Print the path
            pwszUni = (WCHAR *) OleAlloc(sStringId._cPath * sizeof(WCHAR));
            ReadMem(pwszUni, sStringId._pwszPath,
                    sStringId._cPath * sizeof(WCHAR));
            Unicode2Ansi(szAnsi, pwszUni, sStringId._cPath *
                         sizeof(WCHAR));
            if (sClassData._fInprocHandler16)
            {
                Printf("%s(16) ", szAnsi);
            }
            else
            {
                Printf("%s ", szAnsi);
            }
            OleFree(pwszUni);
        }
        
        // Close the print line
        Printf("\n");

        // Read the endpoint registration array base
        ReadMem(&sArrayFValue, sClassData._pssrvreg, sizeof(SArrayFValue));

        // Read the array of endpoint registrations
        pSrvReg = (SSrvRegistration *) OleAlloc(sArrayFValue.m_nSize *
                                                sizeof(SSrvRegistration));
        ReadMem(pSrvReg, sArrayFValue.m_pData,
                sArrayFValue.m_nSize * sizeof(SSrvRegistration));
                
        // Do over the RPC endpoints registered for this server
        for (int cReg = 0; cReg < sArrayFValue.m_nSize; cReg++)
        {
            // Only look at non-empty binding handles
            if (pSrvReg[cReg]._hRpc)
            {
                // The RPC binding handle
                Printf("  %x ", pSrvReg[cReg]._hRpc);
                
                // The window handle
                Printf("%x ", pSrvReg[cReg]._ulWnd);
                
                // Flags
                Printf("%x ", pSrvReg[cReg]._dwFlags);
                
                // Security Id
                Printf("%x ", pSrvReg[cReg]._psid);
                
                // The desktop
                UINT cb = 0;

                // We have to read memory one WCHAR at a time because any
                // av prevents any reading
                do
                {
                    ReadMem(&wszUni[cb], &pSrvReg[cReg]._lpDesktop[cb],
                            sizeof(WCHAR));
                    cb++;
                } until_(wszUni[cb - 1] == L'\0');
                Unicode2Ansi(szAnsi, wszUni, cb);
                Printf("%s\n\n", szAnsi);
            }
        }
    } until_(sSkipListEntry._apBaseForward == sClassCacheList._pSkipList);
}







//+-------------------------------------------------------------------------
//
//  Function:   displayClassCacheCk
//
//  Synopsis:   Displays the checked scm class cache
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    27-Jun-95   BruceMa    Created
//
//  Notes:      This was necessary because certain of the class cache
//              structures different depending on retail vs. checked
//
//--------------------------------------------------------------------------
void displayClassCacheCk(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG             addr;
    SClassCacheList   sClassCacheList;
    SSkipListEntry    sSkipListEntry;
    SClassDataCk      sClassData;
    SLocalServerCk    sLocalServer;
    SStringIDCk       sStringId;
    WCHAR            *pwszUni;
    WCHAR             wszUni[128];
    char              szAnsi[128];
    SArrayFValue      sArrayFValue;
    SSrvRegistration *pSrvReg;
    
    // Read the class cache
    addr = GetExpression("scm!g_pcllClassCache");
    ReadMem(&addr, addr, sizeof(ULONG));
    ReadMem(&sClassCacheList, addr, sizeof(SClassCacheList));
    
    // Read the initial skiplist entry
    ReadMem(&sSkipListEntry, sClassCacheList._pSkipList,
            sizeof(SSkipListEntry));

    // Do over skiplist entries
    do
    {
        // Just in case
        if (CheckControlC())
        {
            return;
        }
        
        // Read the next skiplist entry
        ReadMem(&sSkipListEntry, sSkipListEntry._apBaseForward,
                sizeof(SSkipListEntry));
        
        // Read the CClassData structure
        ReadMem(&sClassData, sSkipListEntry._pvEntry, sizeof(SClassDataCk));
        
        // Read the CLocalServer structure
        ReadMem(&sLocalServer, sClassData._slocalsrv, sizeof(SLocalServerCk));
        
        // Print the path
        pwszUni = (WCHAR *) OleAlloc(sLocalServer._stringId._cPath *
                                     sizeof(WCHAR));
        ReadMem(pwszUni, sLocalServer._stringId._pwszPath,
                sLocalServer._stringId._cPath * sizeof(WCHAR));
        Unicode2Ansi(szAnsi, pwszUni, sLocalServer._stringId._cPath *
                     sizeof(WCHAR));
        if (sClassData._fLocalServer16)
        {
            Printf("%s(16) ", szAnsi);
        }
        else
        {
            Printf("%s ", szAnsi);
        }
        OleFree(pwszUni);
        
        // Print the clsid
        FormatCLSID(sClassData._clsid, szAnsi);
        Printf("%s ", szAnsi);
        
        // Whether activated under a debugger
        if (sClassData._fDebug)
        {
            Printf("*Debug*");
        }

        // Any specified handler
        if (sClassData._shandlr)
        {
            ReadMem(&sStringId, sClassData._shandlr, sizeof(SStringIDCk));
            
            // Print the path
            pwszUni = (WCHAR *) OleAlloc(sStringId._cPath * sizeof(WCHAR));
            ReadMem(pwszUni, sStringId._pwszPath,
                    sStringId._cPath * sizeof(WCHAR));
            Unicode2Ansi(szAnsi, pwszUni, sStringId._cPath *
                         sizeof(WCHAR));
            if (sClassData._fInprocHandler16)
            {
                Printf("%s(16) ", szAnsi);
            }
            else
            {
                Printf("%s ", szAnsi);
            }
            OleFree(pwszUni);
        }
        
        // Close the print line
        Printf("\n");

        // Read the endpoint registration array base
        ReadMem(&sArrayFValue, sClassData._pssrvreg, sizeof(SArrayFValue));

        // Read the array of endpoint registrations
        pSrvReg = (SSrvRegistration *) OleAlloc(sArrayFValue.m_nSize *
                                                sizeof(SSrvRegistration));
        ReadMem(pSrvReg, sArrayFValue.m_pData,
                sArrayFValue.m_nSize * sizeof(SSrvRegistration));
                
        // Do over the RPC endpoints registered for this server
        for (int cReg = 0; cReg < sArrayFValue.m_nSize; cReg++)
        {
            // Only look at non-empty binding handles
            if (pSrvReg[cReg]._hRpc)
            {
                // The RPC binding handle
                Printf("  %x ", pSrvReg[cReg]._hRpc);
                
                // The window handle
                Printf("%x ", pSrvReg[cReg]._ulWnd);
                
                // Flags
                Printf("%x ", pSrvReg[cReg]._dwFlags);
                
                // Security Id
                Printf("%x ", pSrvReg[cReg]._psid);
                
                // The desktop
                UINT cb = 0;

                // We have to read memory one WCHAR at a time because any
                // av prevents any reading
                do
                {
                    ReadMem(&wszUni[cb], &pSrvReg[cReg]._lpDesktop[cb],
                            sizeof(WCHAR));
                    cb++;
                } until_(wszUni[cb - 1] == L'\0');
                Unicode2Ansi(szAnsi, wszUni, cb);
                Printf("%s\n\n", szAnsi);
            }
        }
    } until_(sSkipListEntry._apBaseForward == sClassCacheList._pSkipList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\ddllcach.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ddllcach.cxx
//
//  Contents:   Ole NTSD extension routines to display a dll/class cache
//
//  Functions:  displayDllCache
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "ddllcach.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);





//+-------------------------------------------------------------------------
//
//  Function:   dllCacheHelp
//
//  Synopsis:   Display a menu for the command 'ds'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void dllCacheHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("\nds         - Display entire Inproc Server dll/class cache:\n");
    Printf("dh         - Display entire Inproc Handler dll/class cache:\n\n");
    Printf("Dll's\n");
    Printf("-----\n");
    Printf("path hModule DllGetClassObject() DllCanUnloadNow()  apt ... apt \n");
    Printf("   CLSID\n");
    Printf("   ...\n");
    Printf("...\n\n");
    Printf("LocalServers\n");
    Printf("------------\n");
    Printf("CLSID IUnknown* [M|S|MS] reg_key reg_@_scm\n");
    Printf("...\n\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayDllCache
//
//  Synopsis:   Formats and writes a dll/class cache structure to the
//              debugger terminal
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayDllCache(HANDLE hProcess,
                     PNTSD_EXTENSION_APIS lpExtensionApis,
                     SDllCache *pDllCache)
{
    SDllPathEntry *pDllPathEntries;
    SClassEntry   *pClassEntries;
    DWORD          cbSize;

//    dbt("pDllCache", pDllCache, sizeof(SDllCache));

    // Fetch the array of dll path entries
    cbSize = sizeof(SDllPathEntry) * pDllCache->_cDllPathEntries;
    pDllPathEntries = (SDllPathEntry *) OleAlloc(cbSize);
    ReadMem(pDllPathEntries, pDllCache->_pDllPathEntries, cbSize);

//    dbt("pDllPathEntries", pDllPathEntries, cbSize);

    // Fetch the array of class entries
    cbSize = sizeof(SClassEntry) * pDllCache->_cClassEntries;
    pClassEntries = (SClassEntry *) OleAlloc(cbSize);
    ReadMem(pClassEntries, pDllCache->_pClassEntries, cbSize);

//    dbt("pClassEntries", pClassEntries, cbSize);

    // We do the dll's first
    Printf("Dll's:\n-----\n");

    // Do over the registered dll's
    for (DWORD dwDll = pDllCache->_nDllPathEntryInUse; dwDll != NONE;
         dwDll = pDllPathEntries[dwDll]._dwNext)
    {
        // Fetch the dll path
        WCHAR  wszPath[MAX_PATH + 1];
        CHAR   szPath[2 * MAX_PATH + 1];

        // We don't know the length of the path, so read one WCHAR
        // at a time
         INT k = -1;

        do
        {
            k++;
            ReadMem(&wszPath[k], &pDllPathEntries[dwDll]._pwszPath[k],
                    sizeof(WCHAR));
        } until_(wszPath[k] == L'\0'); 
        Unicode2Ansi(szPath, wszPath, 2 * MAX_PATH + 1);

        // Fetch the apartment entries for this dll path entry
        SDllAptEntry *pAptEntries;

        cbSize = sizeof(SDllAptEntry) * pDllPathEntries[dwDll]._cAptEntries;
        pAptEntries = (SDllAptEntry *) OleAlloc(cbSize);
        ReadMem(pAptEntries, pDllPathEntries[dwDll]._pAptEntries,
                cbSize);

//        dbt("pAptEntries", pAptEntries, cbSize);

        // Display path
        Printf("%s ", szPath);

        // Display hModule and DllGetClassObject and DllCanUnloadNow entry
        // points
        Printf("%08x %08x %08x  ",
               pAptEntries[pDllPathEntries[dwDll]._nAptInUse]._hDll,
               pDllPathEntries[dwDll]._pfnGetClassObject,
               pDllPathEntries[dwDll]._pfnDllCanUnload);

        // Display apartment id's
        for (DWORD dwApt = pDllPathEntries[dwDll]._nAptInUse; dwApt != NONE;
             dwApt = pAptEntries[dwApt]._dwNext)
        {
            Printf("%x ", pAptEntries[dwApt]._hApt);
        }
        Printf("\n");

        // Do over CLSID's for this dll
        for (DWORD dwCls = pDllPathEntries[dwDll]._dw1stClass; dwCls != NONE;
             dwCls = pClassEntries[dwCls]._dwNextDllCls)
        {
            // Display the CLSID
            CHAR szClsid[CLSIDSTR_MAX];

            FormatCLSID(pClassEntries[dwCls]._clsid, szClsid);
            Printf("   %s \n", szClsid);
        }

        // Release the apartment entries for this dll
        OleFree(pAptEntries);

        Printf("\n");
    }

    // Release the array of dll path entries
    OleFree(pDllPathEntries);


        
    // Then we do the local servers
    Printf("Local Servers:\n----------\n");
    
    // Do over the locally registerd local servers
    for (DWORD dwCls = pDllCache->_nClassEntryInUse; dwCls != NONE;
         dwCls = pClassEntries[dwCls]._dwNext)
    {
        // Skip class entries associated with dll's
        if (pClassEntries[dwCls]._dwDllEnt == NONE)
        {
            // Display the CLSID
            CHAR szClsid[CLSIDSTR_MAX];

            FormatCLSID(pClassEntries[dwCls]._clsid, szClsid);
            Printf("   %s ", szClsid);

            // The class factory punk
            Printf("%08x ", pClassEntries[dwCls]._pUnk);

            // The flags
            if (pClassEntries[dwCls]._dwFlags == REGCLS_SINGLEUSE)
            {
                Printf("S ");
            }
            else if (pClassEntries[dwCls]._dwFlags == REGCLS_MULTIPLEUSE)
            {
                Printf("M ");
            }
            else if (pClassEntries[dwCls]._dwFlags == REGCLS_MULTI_SEPARATE)
            {
                Printf("MS ");
            }

            // The registration key given to the user
            Printf("%08x ", pClassEntries[dwCls]._dwReg);            

            // The registration key at the scm
            Printf("%08x ", pClassEntries[dwCls]._dwScmReg);

            // Whether this is an AtBits server
            if (pClassEntries[dwCls]._fAtBits)
            {
                Printf("AtBits\n");
            }
            else
            {
                Printf("\n");
            }
        }
    }

    Printf("\n");

    // Release the array of class entries
    OleFree(pClassEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dclscach.h ===
struct SStringID
{
    void               *_vtbl;
    ULONG		_culRefs;
    int         	_cPathBytes;
    int         	_cPath;
    WCHAR  	       *_pwszPath;
};



struct SStringIDCk
{
    void               *_vtbl;
    ULONG               _ulSig;
    ULONG		_culRefs;
    int         	_cPathBytes;
    int         	_cPath;
    WCHAR  	       *_pwszPath;
};



struct SLocalServer
{
    SStringID           _stringId;
    SMutexSem      	_mxsProcessStart;
    BOOL		_fDebug;
};



struct SLocalServerCk
{
    SStringIDCk         _stringId;
    ULONG               _ulSig;
    SMutexSem      	_mxsProcessStart;
    BOOL		_fDebug;
};



struct SSrvRegistration
{
    HANDLE              _hRpc;
    ULONG	        _ulWnd;
    DWORD               _dwFlags;
    PSID                _psid;
    WCHAR              *_lpDesktop;
};



struct SClassData
{
    LPVOID              _vtbl;
    CLSID               _clsid;
    SStringID          *_shandlr;
    SStringID          *_sinproc;
    SStringID          *_sinproc16;
    SLocalServer       *_slocalsrv;
    ULONG		_fActivateAtBits:1;
    ULONG		_fDebug:1;
    ULONG		_fInprocHandler16:1;
    ULONG		_fLocalServer16:1;
    ULONG               _ulInprocThreadModel:2;
    ULONG               _ulHandlerThreadModel:2;
    HANDLE		_hClassStart;
    SArrayFValue       *_pssrvreg;
    ULONG               _ulRefs;
};



struct SClassDataCk
{
    LPVOID              _vtbl;
    CLSID               _clsid;
    SStringIDCk        *_shandlr;
    SStringIDCk        *_sinproc;
    SStringIDCk        *_sinproc16;
    SLocalServerCk     *_slocalsrv;
    ULONG		_fActivateAtBits:1;
    ULONG		_fDebug:1;
    ULONG		_fInprocHandler16:1;
    ULONG		_fLocalServer16:1;
    ULONG               _ulInprocThreadModel:2;
    ULONG               _ulHandlerThreadModel:2;
    HANDLE		_hClassStart;
    SArrayFValue       *_pssrvreg;
    ULONG               _ulRefs;
};



struct SSkipListEntry
{
    DWORD               _UNUSED;
    SClassData         *_pvEntry;
    SSkipListEntry     *_apBaseForward;
};



struct SClassCacheList
{
    DWORD               _UNUSED[2];
    SSkipListEntry     *_pSkipList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dclsinfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dclassInfo.cxx
//
//  Contents:   Display registry class information
//
//  Functions:  classInfoHelp
//              displayclassInfo
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


// DOLATERIFEVER: Add threading model flags


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dinfolvl.h"
#include "debnot.h"



BOOL ScanCLSID(char *szClsid, CLSID *pClsid);
void FormatCLSID(REFGUID rguid, LPSTR lpsz);

static void GetSomeClsidValues(HKEY   hKey,
                               char  *szName,
                               char  *szInprocHandler,
                               char  *szInprocHandler32,
                               char  *szInprocServer,
                               char  *szInprocServer32,
                               char  *szLocalServer,
                               char  *szLocalServer32,
                               char  *szProgid,
                               char  *szTreatAs,
                               char  *szAutoConvertTo,
                               char  *szOle1Class);

static void DisplayValues(PNTSD_EXTENSION_APIS lpExtensionApis,
                          char                *szName,
                          char                *szInprocHandler,
                          char                *szInprocHandler32,
                          char                *szInprocServer,
                          char                *szInprocServer32,
                          char                *szLocalServer,
                          char                *szLocalServer32,
                          char                *szProgid,
                          char                *szTreatAs,
                          char                *szAutoConvertTo,
                          char                *szOle1Class);

static void MungePath(char *szPath);

static DWORD dwRESERVED = 0;




//+-------------------------------------------------------------------------
//
//  Function:   classInfoHelp
//
//  Synopsis:   Display a menu for the command 'id'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void classInfoHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("ci            - Display registry class information\n");
    Printf("ci clsid      - Display registry class information for clsid\n");

}








//+-------------------------------------------------------------------------
//
//  Function:   displayclassInfo
//
//  Synopsis:   Display/set debug info levels
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [CLSID *]         -       Get info for this clsid
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
BOOL displayClassInfo(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      CLSID *pClsid)
{
    HKEY   hKey;
    char   szCLSID[CLSIDSTR_MAX];
    char   szClsid[5 + 1 + CLSIDSTR_MAX];
    char   szName[64];
    char   szInprocHandler[64];
    char   szInprocHandler32[64];
    char   szInprocServer[64];
    char   szInprocServer32[64];
    char   szLocalServer[64];
    char   szLocalServer32[64];
    char   szProgid[64];
    char   szTreatAs[64];
    char   szAutoConvertTo[64];
    char   szOle1Class[64];


    // Information for a specific clsid?
    if (pClsid)
    {
        // Prepare to open the "...CLSID\<clsid>" key
        FormatCLSID(*pClsid, szCLSID);
        lstrcpy(szClsid, "CLSID\\");
        lstrcat(szClsid, szCLSID);

        // Open the key for the specified clsid
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szClsid, dwRESERVED,
                         KEY_READ, &hKey) != ERROR_SUCCESS)
        {
            return FALSE;
        }

        // Read interesting values for this clsid
        GetSomeClsidValues(hKey,
                           szName,
                           szInprocHandler,
                           szInprocHandler32,
                           szInprocServer,
                           szInprocServer32,
                           szLocalServer,
                           szLocalServer32,
                           szProgid,
                           szTreatAs,
                           szAutoConvertTo,
                           szOle1Class);

            // Only display "interesting" entries
            if ((szInprocHandler[0]  &&
                 _stricmp(szInprocHandler, "ole2.dll") != 0)     ||
                (szInprocHandler32[0]  &&
                 _stricmp(szInprocHandler32, "ole32.dll") != 0)  ||
                (szInprocServer[0]  &&
                 _stricmp(szInprocServer, "ole2.dll") != 0)      ||
                (szInprocServer32[0]  &&
                 _stricmp(szInprocServer32, "ole32.dll") != 0)   ||
                szLocalServer[0]                                ||
                szLocalServer32[0]                              ||
                szTreatAs[0]                                    ||
                szAutoConvertTo[0])
            {
                // Display them
                DisplayValues(lpExtensionApis,
                              szName,
                              szInprocHandler,
                              szInprocHandler32,
                              szInprocServer,
                              szInprocServer32,
                              szLocalServer,
                              szLocalServer32,
                              szProgid,
                              szTreatAs,
                              szAutoConvertTo,
                              szOle1Class);
            }

        // Close registry handle and return success
        CloseHandle(hKey);
        return TRUE;
    }

    // Else display all of them
    else
    {
        HKEY     hKey2;
        DWORD    dwErr;
        DWORD    cbSubKey = 0;
        char     szClsid[64];
        DWORD    cbClsid;
        DWORD    cbClass;
        FILETIME sLastWrite;

        // Open the key for the root "CLSID"
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", dwRESERVED,
                         KEY_ENUMERATE_SUB_KEYS, &hKey) != ERROR_SUCCESS)
        {
            return FALSE;
        }

        // Enumerate over the keys under "HKEY_CLASSES_ROOT\CLSID"
        do
        {
            // Enumerate the next subkey
            cbClsid = 64;
            dwErr = RegEnumKeyEx(hKey, cbSubKey, szClsid, &cbClsid,
                                 NULL, NULL, NULL, &sLastWrite);

            // Prepare for next subkey
            cbSubKey++;

            // If it does look like a clsid, skip it
            CLSID clsid;

            if (!ScanCLSID(szClsid, &clsid))
            {
                continue;
            }

            // Open this clsid key
            if (RegOpenKeyEx(hKey, szClsid, dwRESERVED,
                             KEY_READ, &hKey2) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            // Get the interesting values
            GetSomeClsidValues(hKey2,
                               szName,
                               szInprocHandler,
                               szInprocHandler32,
                               szInprocServer,
                               szInprocServer32,
                               szLocalServer,
                               szLocalServer32,
                               szProgid,
                               szTreatAs,
                               szAutoConvertTo,
                               szOle1Class);

            // Only display "interesting" entries
            if ((szInprocHandler[0]  &&
                 _stricmp(szInprocHandler, "ole2.dll") != 0)     ||
                (szInprocHandler32[0]  &&
                 _stricmp(szInprocHandler32, "ole32.dll") != 0)  ||
                (szInprocServer[0]  &&
                 _stricmp(szInprocServer, "ole2.dll") != 0)      ||
                (szInprocServer32[0]  &&
                 _stricmp(szInprocServer32, "ole32.dll") != 0)   ||
                szLocalServer[0]                                ||
                szLocalServer32[0]                              ||
                szTreatAs[0]                                    ||
                szAutoConvertTo[0])
            {
                // Display the clsid
                Printf("%s ", szClsid);

                // Display its values
                DisplayValues(lpExtensionApis,
                              szName,
                              szInprocHandler,
                              szInprocHandler32,
                              szInprocServer,
                              szInprocServer32,
                              szLocalServer,
                              szLocalServer32,
                              szProgid,
                              szTreatAs,
                              szAutoConvertTo,
                              szOle1Class);
            }

            // Close registry handle
            CloseHandle(hKey2);

        } until_(dwErr == ERROR_NO_MORE_ITEMS  ||  dwErr != ERROR_SUCCESS);

        // Close clsid registry handle
        CloseHandle(hKey);

        return TRUE;
    }
}









//+-------------------------------------------------------------------------
//
//  Function:   GetSomeClsidValues
//
//  Synopsis:   Given an open registry key to a clsid, read some of
//              the more interesting subkey values
//
//  Arguments:  [hkey]                Open registry key
//              [szName]              Where to store the name
//              [szInprocHandler]     Where to store the InprocHandler
//              [szInprocHandler32]   Where to store the InprocHandler32
//              [szInprocServer]      Where to store the InprocServer
//              [szInprocServer32]    Where to store the InprocServer32
//              [szLocalServer]       Where to store the LocalServer
//              [szLocalServer32]     Where to store the LocalServer32
//              [ProgId]              Where to store the ProgId
//              [TreatAs]             Where to store the TreatAs
//              [AutoConvertTo]       Where to store the AutoConvertTo
//              [Ole1Class]           Where to store the Ole1Class
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void GetSomeClsidValues(HKEY   hKey,
                               char  *szName,
                               char  *szInprocHandler,
                               char  *szInprocHandler32,
                               char  *szInprocServer,
                               char  *szInprocServer32,
                               char  *szLocalServer,
                               char  *szLocalServer32,
                               char  *szProgId,
                               char  *szTreatAs,
                               char  *szAutoConvertTo,
                               char  *szOle1Class)
{
    DWORD  dwRESERVED = 0;
    HKEY   hKey2;
    DWORD  dwValueType;
    DWORD  cbValue;

    // Initialize
    szName[0]            = '\0';
    szInprocHandler[0]   = '\0';
    szInprocHandler32[0] = '\0';
    szInprocServer[0]    = '\0';
    szInprocServer32[0]  = '\0';
    szLocalServer[0]     = '\0';
    szLocalServer32[0]   = '\0';
    szProgId[0]          = '\0';
    szTreatAs[0]         = '\0';
    szAutoConvertTo[0]   = '\0';
    szOle1Class[0]       = '\0';

    // Name
    cbValue = 64;
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) szName, &cbValue) != ERROR_SUCCESS)
    {
        return;
    }

    // InprocHandler
    if (RegOpenKeyEx(hKey, "InprocHandler", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szInprocHandler, &cbValue);
        MungePath(szInprocHandler);
        CloseHandle(hKey2);
    }

    // InprocHandler32
    if (RegOpenKeyEx(hKey, "InprocHandler32", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szInprocHandler32, &cbValue);
        MungePath(szInprocHandler32);
        CloseHandle(hKey2);
    }

    // InprocServer
    if (RegOpenKeyEx(hKey, "InprocServer", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szInprocServer, &cbValue);
        MungePath(szInprocServer);
        CloseHandle(hKey2);
    }

    // InprocServer32
    if (RegOpenKeyEx(hKey, "InprocServer32", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szInprocServer32, &cbValue);
        MungePath(szInprocServer32);
        CloseHandle(hKey2);
    }

    // LocalServer
    if (RegOpenKeyEx(hKey, "LocalServer", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szLocalServer, &cbValue);
        MungePath(szLocalServer);
        CloseHandle(hKey2);
    }

    // LocalServer32
    if (RegOpenKeyEx(hKey, "LocalServer32", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szLocalServer32, &cbValue);
        MungePath(szLocalServer32);
        CloseHandle(hKey2);
    }

    // ProgId
    if (RegOpenKeyEx(hKey, "ProgId", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szProgId, &cbValue);
        CloseHandle(hKey2);
    }

    // TreatAs
    if (RegOpenKeyEx(hKey, "TreatAs", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szTreatAs, &cbValue);
        CloseHandle(hKey2);
    }

    // AutoConvertTo
    if (RegOpenKeyEx(hKey, "AutoConvertTo", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        cbValue = 64;
        RegQueryValueEx(hKey2, NULL, NULL, &dwValueType,
                        (LPBYTE) szAutoConvertTo, &cbValue);
        CloseHandle(hKey2);
    }

    // Ole1Class
    if (RegOpenKeyEx(hKey, "Ole1Class", dwRESERVED,
                     KEY_READ, &hKey2) == ERROR_SUCCESS)
    {
        szOle1Class[0] = '1';
        CloseHandle(hKey2);
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   DisplayValues
//
//  Synopsis:   Display the values read above
//
//  Arguments:  [hkey]                Open registry key
//              [szName]              Where to store the name
//              [szInprocHandler]     Where to store the InprocHandler
//              [szInprocHandler32]   Where to store the InprocHandler32
//              [szInprocServer]      Where to store the InprocServer
//              [szInprocServer32]    Where to store the InprocServer32
//              [szLocalServer]       Where to store the LocalServer
//              [szLocalServer32]     Where to store the LocalServer32
//              [ProgId]              Where to store the ProgId
//              [TreatAs]             Where to store the TreatAs
//              [AutoConvertTo]       Where to store the AutoConvertTo
//              [Ole1Class]           Where to store the Ole1Class
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void DisplayValues(PNTSD_EXTENSION_APIS lpExtensionApis,
                          char                *szName,
                          char                *szInprocHandler,
                          char                *szInprocHandler32,
                          char                *szInprocServer,
                          char                *szInprocServer32,
                          char                *szLocalServer,
                          char                *szLocalServer32,
                          char                *szProgId,
                          char                *szTreatAs,
                          char                *szAutoConvertTo,
                          char                *szOle1Class)

{
    // Display the name
    Printf("%s ", szName);

    // Display ProgId (if unique)
    if (szProgId[0]  &&  lstrcmp(szProgId, szName) != 0)
    {
        Printf("%s ", szProgId);
    }

    // Display the server executable
    if (szLocalServer[0])
    {
        Printf("%s ", szLocalServer32);
    }
    else if (szInprocServer32[0])
    {
        Printf("%s ", szInprocServer32);
    }
    else if (szLocalServer[0])
    {
        Printf("%s(16) ", szLocalServer);
    }
    else if (szInprocServer[0])
    {
        Printf("%s(16) ", szInprocServer);
    }

    // Display handler information
    if (szInprocHandler32[0]  &&
        _stricmp(szInprocHandler32, "ole32.dll") != 0)
    {
        Printf("Hndlr: %s ", szInprocHandler32);
    }
    else if (szInprocHandler[0]  &&
             _stricmp(szInprocHandler, "ole2.dll") != 0)
    {
        Printf("Hndlr: %s(16) ", szInprocHandler);
    }

    // Display any TreatAs or AutoConvertTo information
    if (szTreatAs[0])
    {
        Printf("TA: %s", szTreatAs);
    }
    if (szAutoConvertTo[0])
    {
        Printf("ACT: %s", szAutoConvertTo);
    }

    // Check if this is an ole1 class
    if (szOle1Class[0])
    {
        Printf("ole1 class");
    }

    // We're done
    Printf("\n");
}








//+-------------------------------------------------------------------------
//
//  Function:   MungePath
//
//  Synopsis:   Remove directory components from a file path
//
//  Arguments:  [szPath]                Path to munge
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void MungePath(char *szPath)
{
    int   cbLen = lstrlen(szPath);
    DWORD cbPath;

    for (cbPath = cbLen; cbPath > 0  &&  szPath[cbPath] != '\\'; cbPath--)
    {
    }
    if (cbPath > 0)
    {
        lstrcpy(szPath, &szPath[cbPath + 1]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dfilepat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dfilepat.cxx
//
//  Contents:   Ole NTSD extension routines to dump the file type (bit
//              patterns) cache
//
//  Functions:  filePatHelp
//              displayFilePatTbl
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dshrdmem.h"




BOOL IsEqualCLSID(CLSID *pClsid1, CLSID *pClsid2);
void FormatCLSID(REFGUID rguid, LPSTR lpsz);




//+-------------------------------------------------------------------------
//
//  Function:   filePatHelp
//
//  Synopsis:   Display a menu for the command 'ft'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void filePatHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("ft         - Display entire file type patterns table\n");
    Printf("ft clsid   - Display file type patterns for clsid\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayFilePatTbl
//
//  Synopsis:   Display some or all of the file type patterns table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [lpFileExtTbl]    -       Address of file extensions table
//              [pClsid]          -       Only for this clsid
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayFilePatTbl(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis,
                       SDllShrdTbl *pShrdTbl,
                       CLSID *pClsid)
{
    SDllShrdTbl  sDllTbl;
    STblHdr     *pTblHdr;
    STblHdr      sTblHdr;
    BYTE        *pStart;
    LPVOID       pEnd;
    CLSID        oldClsid = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    UINT         ulCnt = 0;

    
    // Read the shared table locally
    ReadMem(&sDllTbl, pShrdTbl, sizeof(SDllShrdTbl));

    // Read the table header locally
    pTblHdr = sDllTbl._PatternTbl._pTblHdr;
    ReadMem(&sTblHdr, pTblHdr, sizeof(STblHdr));

    // Set up to read the entries
    pStart = sDllTbl._PatternTbl._pStart;
    pEnd = pStart + sTblHdr.OffsEnd - sizeof(STblHdr);

    // Do over the file extension entries
    while (pStart < pEnd)
    {
        ULONG         ulLen;
        SPatternEntry sPatEnt;
        char          szClsid[CLSIDSTR_MAX];

        // Just in case the loop gets away from us
        if (CheckControlC())
        {
            return;
        }

        // Read the length of this entry
        ReadMem(&ulLen, pStart + sizeof(CLSID), sizeof(ULONG));

        // Read the next entry locally
        ReadMem(&sPatEnt, pStart, ulLen);

        // Print the clsid if we haven't yet
        if (pClsid == NULL  &&  !IsEqualCLSID(&sPatEnt.clsid, &oldClsid))
        {
            FormatCLSID(sPatEnt.clsid, szClsid);
            Printf("\n%s\n", szClsid);

            // Save the clisd
            oldClsid = sPatEnt.clsid;

            // Initialize a count per clsid
            ulCnt = 0;
        }

        // Print only if printing the whole table or at our sought clsid
        if (pClsid == NULL  ||  IsEqualCLSID(pClsid, &sPatEnt.clsid))
        {
            // Print the index of this pattern
            Printf("%2d  ", ulCnt++);

            // Print the file offset
            Printf("%d\t", sPatEnt.lFileOffset);

            // Print the length of the pattern in bytes
            Printf("%3d  ", sPatEnt.ulCb);

            // Print the mask
            for (UINT k = 0; k < sPatEnt.ulCb; k++)
            {
                Printf("%02x", sPatEnt.abData[k]);
            }
            Printf("  ");

            // Print the pattern
            for (k = 0; k < sPatEnt.ulCb; k++)
            {
                Printf("%02x", sPatEnt.abData[sPatEnt.ulCb + k]);
            }
            Printf("\n");
        }
        
        // Go to the next entry
        pStart += ulLen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dfileext.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dfileext.cxx
//
//  Contents:   Ole NTSD extension routines to dump the clsid/file extensions
//              cache
//
//  Functions:  fileExtHelp
//              displayFileExtTbl
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dshrdmem.h"




BOOL IsEqualCLSID(CLSID *pClsid1, CLSID *pClsid2);
void FormatCLSID(REFGUID rguid, LPSTR lpsz);




//+-------------------------------------------------------------------------
//
//  Function:   fileExtHelp
//
//  Synopsis:   Display a menu for the command 'fe'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void fileExtHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("fe         - Display entire file extensions table\n");
    Printf("fe clsid   - Display file extensions for clsid\n");
    Printf("fe .ext    - Display clsid for file extension ext\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayFileExtTbl
//
//  Synopsis:   Display some or all of the file extensions table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [lpFileExtTbl]    -       Address of file extensions table
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayFileExtTbl(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis,
                       SDllShrdTbl *pShrdTbl,
                       CLSID *pClsid,
                       WCHAR *wszExt)
{
    SDllShrdTbl  sDllTbl;
    SExtTblHdr  *pExtTblHdr;
    SExtTblHdr   sExtTblHdr;
    BYTE        *pExtEntry;
    LPVOID       pEnd;
    CLSID        oldClsid = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    
    // Read the shared table locally
    ReadMem(&sDllTbl, pShrdTbl, sizeof(SDllShrdTbl));

    // Read the table header locally
    pExtTblHdr = sDllTbl._FileExtTbl._pTblHdr;
    ReadMem(&sExtTblHdr, pExtTblHdr, sizeof(SExtTblHdr));

    // Set up to read the entries
    pExtEntry = sDllTbl._FileExtTbl._pStart;
    pEnd = pExtEntry + sExtTblHdr.OffsEnd - sizeof(SExtTblHdr);

    // Do over the file extension entries
    while (pExtEntry < pEnd)
    {
        ULONG     ulLen;
        SExtEntry sExtEnt;
        WCHAR     slop[16];
        char      szClsid[CLSIDSTR_MAX];
        BOOL      fNL = FALSE;

        // Just in case the loop gets away from us
        if (CheckControlC())
        {
            return;
        }

        // Read the length of this entry
        ReadMem(&ulLen, pExtEntry + sizeof(CLSID), sizeof(ULONG));

        // Read the next entry locally
        ReadMem(&sExtEnt, pExtEntry, ulLen);

        // Print the clsid if dumping the whole table or searching by
        // extension
        if ((pClsid == NULL  &&  wszExt == NULL)  ||
            (wszExt  &&  !lstrcmpW(wszExt, sExtEnt.wszExt)))
        {
            FormatCLSID(sExtEnt.Clsid, szClsid);
            Printf("%s ", szClsid);

            // Save the clisd
            oldClsid = sExtEnt.Clsid;

            // Remember to printf a newline
            fNL = TRUE;
        }

        // Print the extension if dumping the whole table or seraching
        // by clsid
        if ((pClsid == NULL  &&  wszExt == NULL)                ||
            (pClsid  &&  IsEqualCLSID(&sExtEnt.Clsid, pClsid)))
        {
            // Print the associated file extension
            Printf("%ws ", sExtEnt.wszExt);

            // Remember to printf a newline
            fNL = TRUE;
        }

        // Check if we need to print a newline
        if (fNL)
        {
            Printf("\n");
            fNL = FALSE;
        }
        
        // Go to the next entry
        pExtEntry += ulLen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\derror.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       derror.cxx
//
//  Contents:   Ole NTSD extension routines to display the error
//              message for a Win32 or OLE error code
//
//  Functions:  displayVtbl
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"







//+-------------------------------------------------------------------------
//
//  Function:   displayHr
//
//  Synopsis:   Display the mnesage for a Win32 error or OLE HRESULT
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayHr  (HANDLE hProcess,
                 PNTSD_EXTENSION_APIS lpExtensionApis,
                 char *arg)
{
    DWORD err = 0;
    BOOL  fHex = FALSE;

    // Determine if it's hex or decimal.  Also allow '800xxxxx' to implicitly
    // be treated as hexadecimal
    if (arg[0] == '0'  &&  (arg[1] == 'x'  ||  arg[1] == 'X'))
    {
        fHex = TRUE;
        arg += 2;
    }
    else if (arg[0] == '8'  &&  arg[1] == '0'  &&  arg[2] == '0')
    {
        fHex = TRUE;
    }
    else
    {
        char *s = arg;

        while (*s)
        {
            if (('a' <= *s  &&  *s <= 'f')  ||  ('A' <= *s  &&  *s <= 'F'))
            {
                fHex = TRUE;
                break;
            }
            s++;
        }
    }
            
    // Parse the error number
    if (fHex)
    {
        int  k = 0;
        char c;
        
        while (c = arg[k++])
        {
            c = c - '0';
            if (c > 9)
            {
                if (c <= 'F'  &&  c >= 'A')
                {
                    c = c + '0' - 'A' + 10;
                }
                else
                {
                    c = c + '0' - 'a' + 10;
                }
            }
            err = (16 * err) + c;
        }
    }
    else
    {
        int  k = 0;
        char c;
        
        while (c = arg[k++])
        {
            c = c - '0';
            err = (10 * err) + c;
        }
    }

    // Fetch the associated error message
    int  cbMsgLen;
    char szBuffer[512];
    
    cbMsgLen = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             err,
                             (DWORD) NULL,
                             szBuffer,
                             511,
                             NULL);

    // Output the message
    if (cbMsgLen == 0)
    {
        Printf("...No such error code\n");
    }
    else
    {
        szBuffer[cbMsgLen] = '\0';
        Printf("%s\n", szBuffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\ddllcach.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ddllcach.h
//
//  Contents:   Contains structure definitons for the significant dll class/
//              cache ole classes which the ntsd extensions need to access.
//              These ole classes cannot be accessed more cleanly because
//              typically the members of interest are protected.
//
//              WARNING.  IF THE REFERENCED OLE CLASSES CHANGE, THEN THESE
//              DEFINITIONS MUST CHANGE!
//
//  History:    06-01-95 BruceMa    Created
//
//--------------------------------------------------------------------------


typedef HRESULT (*DLLUNLOADFNP)(void);

const DWORD NONE = ~0UL;


struct SClassEntry
{
    DWORD               _fAtBits;       // Whether server is an at bits server
    DWORD               _dwNext;        // Next entry in in-use or avail list
    DWORD               _dwSig;         // Marks entry as in use
    CLSID               _clsid;         // Class of this server
    IUnknown           *_pUnk;          // Class factory IUnknown
    DWORD               _dwContext;     // Class context
    DWORD               _dwFlags;       // Single vs. multiple use
    DWORD               _dwReg;         // Registration key for caller
    DWORD               _dwScmReg;      // Registration ID at the SCM
    HAPT                _hApt;          // Thread Id
    DWORD               _cCallOut;      // Count of active call outs
    DWORD               _fRevokePending;// Whether revoked while calling out
    DWORD               _dwDllEnt;      // Associated dll path entry
    DWORD               _dwNextDllCls;  // Next class entrry for this dll
    HWND                _hWndDdeServer; // Handle of associated DDE window
};





struct SDllAptEntry
{
    DWORD               _dwNext;        // Next entry in avail or in use list
    DWORD               _dwSig;         // Unique signature for apt entries
    HAPT         	_hApt;          // apartment id
    HMODULE		_hDll;		// module handle
};





struct SDllPathEntry
{
    DWORD               _dwNext;               // Next in-use/avail entry
    DWORD               _dwSig;                // Unique signature for safty
    LPWSTR              _pwszPath;             // The dll pathname
    DWORD               _dwHash;               // Hash value for searching
    LPFNGETCLASSOBJECT  _pfnGetClassObject;    // Create object entry point
    DLLUNLOADFNP        _pfnDllCanUnload;      // DllCanUnloadNow entry point
    DWORD		_dwFlags;              // Internal flags
    DWORD               _dwDllThreadModel:2;   // Threading model for the DLL
    DWORD               _dw1stClass;           // First class entry for dll
    DWORD               _cUsing;               // Count of using threads
    DWORD               _cAptEntries;          // Total apt entries
    DWORD               _nAptAvail;            // List of available apt entries
    DWORD               _nAptInUse;            // List of in use apt entries
    SDllAptEntry       *_pAptEntries;          // Per thread info
};




struct SDllCache
{
    SMutexSem           _mxsLoadLibrary;     // Protects LoadLibrary calls
    SMutexSem           _mxs;                // Protects from multiple threads
    DWORD               _cClassEntries;      // Count of class entries
    DWORD               _nClassEntryInUse;   // First in-use class entry
    DWORD               _nClassEntryAvail;   // First available class entry
    SClassEntry        *_pClassEntries;      // Array of class entries
    DWORD               _cDllPathEntries;    // Count of dll path entries
    DWORD               _nDllPathEntryInUse; // First in-use dll path entry
    DWORD               _nDllPathEntryAvail; // First available dll path entry
    SDllPathEntry      *_pDllPathEntries;    // Array of DLL path entries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dinfolvl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dinfoLevel.cxx
//
//  Contents:   Display and/or set vaious debug info levels
//
//  Functions:  infoLevelHelp
//              displayInfoLevel
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dinfolvl.h"
#include "debnot.h"


void getArgument(LPSTR *lpArgumentString, LPSTR a);
ULONG ScanAddr(char *lpsz);

static void initInfoLevels(PNTSD_EXTENSION_APIS lpExtensionApis);
static BOOL parseVal(char *arg, ULONG *val);



STable1 debFlags[NUMDEBFLAGS] = {{"error",  DEB_ERROR},
                                 {"warn",   DEB_WARN},
                                 {"trace",  DEB_TRACE},
                                 {"dbgout", DEB_DBGOUT},
                                 {"stdout", DEB_STDOUT},
                                 {"ierror", DEB_IERROR},
                                 {"iwarn",  DEB_IWARN},
                                 {"itrace", DEB_ITRACE},
                                 {"user1",  DEB_USER1},
                                 {"user2",  DEB_USER2},
                                 {"user3",  DEB_USER3},
                                 {"user4",  DEB_USER4},
                                 {"user5",  DEB_USER5},
                                 {"user6",  DEB_USER6},
                                 {"user7",  DEB_USER7},
                                 {"user8",  DEB_USER8},
                                 {"user9",  DEB_USER9},
                                 {"user10", DEB_USER10},
                                 {"user11", DEB_USER11},
                                 {"user12", DEB_USER12},
                                 {"user13", DEB_USER13},
                                 {"user14", DEB_USER14},
                                 {"user15", DEB_USER15}};


STable2 infoLevel[NUMINFOLEVELS] = {{"com", NULL, "ole32!_CairoleInfoLevel"},
                                    {"dd",  NULL, "ole32!_DDInfoLevel"},
                                    {"hep", NULL, "ole32!_heapInfoLevel"},
                                    {"hk",  NULL, "ole32!_hkInfoLevel"},
                                    {"int", NULL, "ole32!_intrInfoLevel"},
                                    {"le",  NULL, "ole32!_LEInfoLevel"},
                                    {"mem", NULL, "ole32!_memInfoLevel"},
                                    {"mnk", NULL, "ole32!_mnkInfoLevel"},
                                    {"msf", NULL, "ole32!_msfInfoLevel"},
                                    {"ol",  NULL, "ole32!_olInfoLevel"},
                                    {"ref", NULL, "ole32!_RefInfoLevel"},
                                    {"sim", NULL, "ole32!_simpInfoLevel"},
                                    {"stk", NULL, "ole32!_StackInfoLevel"},
                                    {"usr", NULL, "ole32!_UserNdrInfoLevel"}};
    
    
    
    
    
    
//+-------------------------------------------------------------------------
//
//  Function:   infoLevelHelp
//
//  Synopsis:   Display a menu for the command 'id'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void infoLevelHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("in            - Display current value of all debug info levels\n");
    Printf("in x          - Display the current value of debug info level x\n");
    Printf("in x y z ...  - Set the value of debug info level x to\n");
    Printf("                 y | z | ... \n");
    Printf("\nwhere   x    corresponds to:\n");
    Printf("       ---   --------------\n");
    Printf("       com   ole32!_CairoleInfoLevel\n");
    Printf("       dd    ole32!_DDInfoLevel\n");
    Printf("       hep   ole32!_heapInfoLevel\n");
    Printf("       hk    ole32!_hkInfoLevel\n");
    Printf("       int   ole32!_intrInfoLevel\n");
    Printf("       le    ole32!_LEInfoLevel\n");
    Printf("       mem   ole32!_memInfoLevel\n");
    Printf("       mnk   ole32!_mnkInfoLevel\n");
    Printf("       msf   ole32!_msfInfoLevel\n");
    Printf("       ol    ole32!_olInfoLevel\n");
    Printf("       ref   ole32!_RefInfoLevel\n");
    Printf("       sim   ole32!_simpInfoLevel\n");
    Printf("       stk   ole32!_StackInfoLevel\n");
    Printf("       ndr   ole32!_UserNdrInfoLevel\n");
    Printf("\nand   y...   corresponds to:\n");
    Printf("      ----   --------------\n");
    Printf("      error  DEB_ERROR\n");
    Printf("      warn   DEB_WARN\n");
    Printf("      trace  DEB_TRACE\n");
    Printf("      dbgout DEB_DBGOUT\n");
    Printf("      stdout DEB_STDOUT\n");
    Printf("      ierror DEB_IERROR\n");
    Printf("      iwarn  DEB_IWARN\n");
    Printf("      itrace DEB_ITRACE\n");
    Printf("      user1  DEB_USER1\n");
    Printf("      user2  DEB_USER2\n");
    Printf("      user3  DEB_USER3\n");
    Printf("      user4  DEB_USER4\n");
    Printf("      user5  DEB_USER5\n");
    Printf("      user6  DEB_USER6\n");
    Printf("      user7  DEB_USER7\n");
    Printf("      user8  DEB_USER8\n");
    Printf("      user9  DEB_USER9\n");
    Printf("      user10 DEB_USER10\n");
    Printf("      user11 DEB_USER11\n");
    Printf("      user12 DEB_USER12\n");
    Printf("      user13 DEB_USER13\n");
    Printf("      user14 DEB_USER14\n");
    Printf("      user15 DEB_USER15\n");
    Printf("      <hex>\n");
}








//+-------------------------------------------------------------------------
//
//  Function:   displayInfoLevel
//
//  Synopsis:   Display/set debug info levels
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [char *]          -       Command line argument(s)
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayInfoLevel(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      LPSTR lpArgumentString)
{
    Arg   arg;
    UINT  k;
    ULONG val;
    ULONG argVal;
    BOOL  fSet = FALSE;

    // Fetch the addresses for the various debug info levels
    initInfoLevels(lpExtensionApis);

    // Fetch the first argument
    GetArg(arg);
    Printf("%s   %s\n", arg, lpArgumentString);
    
    // If no argument simply display all info levels
    if (!arg[0])
    {
        for (k = 0; k < NUMINFOLEVELS; k++)
        {
            ReadMem(&val, infoLevel[k].adr, sizeof(ULONG));
            Printf("%s\t%08x\n", infoLevel[k].name, val);
        }

        return;
    }

    // Check the info level name
    for (k = 0; k < NUMINFOLEVELS; k++)
    {
        if (lstrcmp(arg, infoLevel[k].name) == 0)
        {
            break;
        }
    }
    if (k == NUMINFOLEVELS)
    {
        Printf("...unknown debug info level name\n");
        return;
    }

    // Scan any values to set
    val = 0;
    for (GetArg(arg); *arg; GetArg(arg))
    {
        if (!parseVal(arg, &argVal))
        {
            Printf("...invalid flag expresson\n");
            return;
        }
        val |= argVal;
        fSet = TRUE;
    }

    // If only an info level name, then display its value
    if (!fSet)
    {
        ReadMem(&val, infoLevel[k].adr, sizeof(ULONG));
        Printf("%s\t%08x\n", infoLevel[k].name, val);
        return;
    }        

    // Otherwise we're setting an info level
    WriteMem(infoLevel[k].adr, &val, sizeof(ULONG));
    Printf("%s\t%08x\n", infoLevel[k].name, val);
}







//+-------------------------------------------------------------------------
//
//  Function:   initInfoLevels
//
//  Synopsis:   Find the addresses of the various infolevels
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void initInfoLevels(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    // Check whether already initialized
    if (infoLevel[0].adr != NULL)
    {
        return;
    }

    // Do over the info levels
    for (UINT k = 0; k < NUMINFOLEVELS; k++)
    {
         infoLevel[k].adr = GetExpression(infoLevel[k].symbol);
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   parseVal
//
//  Synopsis:   Parse the next flag expression on the command line
//
//  Arguments:  [char *]        -       Command line
//              [ULONG *]       -       Where to return the parsed value
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static BOOL parseVal(char *arg, ULONG *val)
{
    UINT k;

    // Check whether it's a flag name
    for (k = 0; k < NUMDEBFLAGS; k++)
    {
        if (lstrcmp(arg, debFlags[k].name) == 0)
        {
            *val = debFlags[k].flag;
            return TRUE;
        }
    }

    // It's not so it better be hex
    k = 0;
    if (arg[0] == '0'  &&  arg[1] == 'x')
    {
        k += 2;
    }
    while (arg[k])
    {
        if (!(('0' <= arg[k]  &&  arg[k] <= '9')  ||
              ('a' <= arg[k]  &&  arg[k] <= 'f')))
        {
            return FALSE;
        }
        k++;
    }
    *val = ScanAddr(arg);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dinfolvl.h ===
// Because these are not defined in retail mode
#if DBG == 0
# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined
#endif


const UINT MAXDEBFLAG    = 8;
const UINT NUMDEBFLAGS   = 23;
const UINT NUMINFOLEVELS = 14;
const UINT MAXSYMBOL     = 32;


struct STable1
{
    char  name[MAXDEBFLAG];
    ULONG flag;
};




struct STable2
{
    char  name[4];
    ULONG adr;
    char  symbol[MAXSYMBOL];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dipid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dipid.cxx
//
//  Contents:   Ole NTSD extension routines to display CIPID table
//
//  Functions:  ipidHelp
//              displayIpid
//
//
//  History:    21-Aug-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dipid.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);
BOOL GetRegistryInterfaceName(REFIID iid, char *szValue, DWORD *pcbValue);
ULONG ScanAddr(char *lpsz);




//+-------------------------------------------------------------------------
//
//  Function:   ipidHelp
//
//  Synopsis:   Display a menu for the command 'id'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    21-Aug-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void ipidHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("\nip       - Display entire IPID table:\n");
    Printf("index  IPID oxidAddr nextIPIDsameObj\n");
    Printf("...\n\n");
    Printf("ip ipid    - Display specific IPID entry:\n");
    Printf("PID TID seq IID ChnlBfr* prxy/stub realPv oxidAddr flags strongRefs weakRefs nextIPIDsameObj\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayIpid
//
//  Synopsis:   Display the entire IPID table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    21-Aug-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayIpid(HANDLE hProcess,
                  PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG        pAdr;
    ULONG        pStart;
    ULONG        pEnd;
    UINT         cPages;
    SIPIDEntry **pIndexTable;
    SIPIDEntry   sIPIDentry[IPIDsPerPage];
    SOXIDEntry   sOXIDentry;
    char         szGuid[CLSIDSTR_MAX];


    // Read the IPID page index table
    pAdr = GetExpression("ole32!CIPIDTable___pTbl");
    ReadMem(&pStart, pAdr, sizeof(SIPIDEntry **));
    pAdr =   GetExpression("ole32!CIPIDTable___pTblEnd");
    ReadMem(&pEnd, pAdr, sizeof(SIPIDEntry **));
    cPages = (pEnd - pStart) / sizeof(SIPIDEntry **);
    pIndexTable = (SIPIDEntry **) OleAlloc(cPages * sizeof(SIPIDEntry *));
    ReadMem(pIndexTable, pStart, cPages * sizeof(SIPIDEntry *));

    // Do over IPID entry pages
    for (UINT k = 0; k < cPages; k++)
    {
        // Read the next page of IPID entries
        ReadMem(sIPIDentry, pIndexTable[k], IPIDTBL_PAGESIZE);

        // Do over entries within this page
        for (UINT j = 0; j < IPIDsPerPage; j++)
        {
            // Only look at non-vacant entries
            if (!(sIPIDentry[j].dwFlags & IPIDF_VACANT))
            {
                // Print the page/offset for this entry
                Printf("%d.%d  ", k, j);
                
                // Print the IPID
                if (sIPIDentry[j].ipid.page > 1000  ||
                    sIPIDentry[j].ipid.page < 0)
                {
                    FormatCLSID((GUID &) sIPIDentry[j].ipid, szGuid);
                    Printf("%s ", szGuid);
                }
                else
                {
                    Printf("[%d.%d %3x %3x %d] ",
                           sIPIDentry[j].ipid.page,
                           sIPIDentry[j].ipid.offset,
                           sIPIDentry[j].ipid.pid,
                           sIPIDentry[j].ipid.tid,
                           sIPIDentry[j].ipid.seq);
                }

                // Print the associated OXID addr
                Printf("%x ", sIPIDentry[j].pOXIDEntry);

                // Next IPID for this object
                if (sIPIDentry[j].iNextOID != -1)
                {
                    Printf("%d.%d\n",
                           sIPIDentry[j].iNextOID >> 16,
                           sIPIDentry[j].iNextOID & 0xffff);
                }
                else
                {
                    Printf("NULL\n");
                }
            }
        }
    }

    // Release resources
    OleFree(pIndexTable);
}






//+-------------------------------------------------------------------------
//
//  Function:   displayIpidEntry
//
//  Synopsis:   Display an entry in the IPID table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [arg]             -       IPID of entry to display
//
//  Returns:    -
//
//  History:    21-Aug-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayIpidEntry(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      char *arg)
{
    char        *s;
    IPID         ipid;
    ULONG        ppIPIDentry;;
    SIPIDEntry  *pIPIDentry;
    SIPIDEntry   sIPIDentry;
    char         szGuid[CLSIDSTR_MAX];
    SOXIDEntry   sOXID;


    // Check for help
    if (arg[0] == '?')
    {
        Printf("PID TID seq IID ChnlBfr* prxy/stub realPv oxidAddr flags strongRefs weakRefs nextIPIDsameObj\n");
        return;
    }

    // arg may be either page.offset or a hex address
    BOOL fAdr = TRUE;
    for (s = arg; *s; s++)
    {
        if (*s == '.')
        {
            fAdr = FALSE;
        }
    }

    // The argument is a hex address
    if (fAdr)
    {
        pIPIDentry = (SIPIDEntry *) ScanAddr(arg);
    }

    // The argment has the form page.offset
    else
    {
        // Make sure the argument looks like an IPID
        BOOL fOk = TRUE;
        UINT cPoint = 0;
        if (!IsDecimal(arg[0]))
        {
            fOk = FALSE;
        }
        for (s = arg; *s; s++)
        {
            if (*s != '.'  &&  !IsDecimal(*s))
            {
                fOk = FALSE;
            }
            if (*s == '.')
            {
                cPoint++;
            }
        }
        if (!IsDecimal(*(s - 1)))
        {
            fOk = FALSE;
        }
        if (!(fOk  &&  cPoint == 1))
        {
            Printf("...%s is not an IPID\n", arg);
            return;
        }
        
        // Convert the argument to an IPID
        for (ipid.page = 0; *arg  &&  *arg != '.'; arg++)
        {
            ipid.page = 10 * ipid.page + *arg - '0';
        }
        for (arg++, ipid.offset = 0; *arg; arg++)
        {
            ipid.offset = 10 * ipid.offset + *arg - '0';
        }
        
        // Read the address of the page containing the entry we want
        ppIPIDentry = GetExpression("ole32!CIPIDTable___pTbl");
        ReadMem(&ppIPIDentry, ppIPIDentry, sizeof(SIPIDEntry **));
        ppIPIDentry += ipid.page * sizeof(SIPIDEntry **);
        ReadMem(&pIPIDentry, ppIPIDentry, sizeof(SIPIDEntry *));
        
        // Compute the address of the entry we're seeking
        pIPIDentry += ipid.offset;
    }

    // Now read the entry
    ReadMem(&sIPIDentry, pIPIDentry, sizeof(SIPIDEntry));

    // Check whether the entry is vacant
    if (sIPIDentry.dwFlags & IPIDF_VACANT)
    {
        Printf("VACANT\n");
        return;
    }

    // The ipid may just be a GUID; e.g. client side scm interfaces
    if (sIPIDentry.ipid.page >> 1000  ||  sIPIDentry.ipid.page < 0)
    {
        FormatCLSID((GUID &) sIPIDentry.ipid, szGuid);
        Printf("%s ", szGuid);
    }
    else
    {
        // Server PID
        Printf("%3x ", sIPIDentry.ipid.pid);
    
        // Server TID
        Printf("%3x ", sIPIDentry.ipid.tid);

        // Sequence number
        Printf("%d ", sIPIDentry.ipid.seq);
    }

    // IID
    DWORD cbValue;
    if (!GetRegistryInterfaceName(sIPIDentry.iid, szGuid, &cbValue))
    {
        FormatCLSID(sIPIDentry.iid, szGuid);
    }
    Printf("%s ", szGuid);

    // CRpcChannelBuffer *
    Printf("%x ", sIPIDentry.pChnl);

    // Address of proxy/stub
    Printf("%x ", sIPIDentry.pStub);

    // Real interface pinter
    Printf("%x ", sIPIDentry.pv);

    // Associated OXID
    Printf("%x ", sIPIDentry.pOXIDEntry);

    // Flags
    if (sIPIDentry.dwFlags & IPIDF_CONNECTING)
    {
        Printf("C");
    }
    if (sIPIDentry.dwFlags & IPIDF_DISCONNECTED)
    {
        Printf("D");
    }
    if (sIPIDentry.dwFlags & IPIDF_SERVERENTRY)
    {
        Printf("S");
    }
    if (sIPIDentry.dwFlags & IPIDF_NOPING)
    {
        Printf("N");
    }
    Printf(" ole32!CCacheEnum__Skip+0x82");

    // Strong references
    Printf("%d ", sIPIDentry.cStrongRefs);

    // Weak references
    Printf("%d ", sIPIDentry.cWeakRefs);

    // Next IPID for this object (if any)
    if (sIPIDentry.iNextOID != -1)
    {
        Printf("%d.%d\n",
               sIPIDentry.iNextOID >> 16,
               sIPIDentry.iNextOID & 0xffff);
    }
    else
    {
        Printf("NULL\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dmoniker.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dmoniker.cxx
//
//  Contents:   Interpret a moniker object
//
//  Functions:  monikersHelp
//              displayMonikers
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dmoniker.h"





static void displayFileMoniker(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker);

static void displayFileMonikerCk(HANDLE hProcess,
                                 PNTSD_EXTENSION_APIS lpExtensionApis,
                                 ULONG pMoniker);

static void displayItemMoniker(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker);

static void displayItemMonikerCk(HANDLE hProcess,
                                 PNTSD_EXTENSION_APIS lpExtensionApis,
                                 ULONG pMoniker);

static void displayCompositeMoniker(HANDLE hProcess,
                                    PNTSD_EXTENSION_APIS lpExtensionApis,
                                    ULONG pMoniker);

static void displayCompositeMonikerCk(HANDLE hProcess,
                                      PNTSD_EXTENSION_APIS lpExtensionApis,
                                      ULONG pMoniker);

static void displayPointerMoniker(HANDLE hProcess,
                                  PNTSD_EXTENSION_APIS lpExtensionApis,
                                  ULONG pMoniker);

static void displayPointerMonikerCk(HANDLE hProcess,
                                    PNTSD_EXTENSION_APIS lpExtensionApis,
                                    ULONG pMoniker);

static void displayAntiMoniker(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker);

static void displayAntiMonikerCk(HANDLE hProcess,
                                 PNTSD_EXTENSION_APIS lpExtensionApis,
                                 ULONG pMoniker);

static enum mnkType findMnkType(HANDLE hProcess,
                                PNTSD_EXTENSION_APIS lpExtensionApis,
                                ULONG pMoniker);


extern BOOL fInScm;
static BOOL fRetail;


//+-------------------------------------------------------------------------
//
//  Function:   monikerHelp
//
//  Synopsis:   Display a menu for the command 'mk'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void monikerHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("mk addr  - Interpret addr as a moniker\n");
}







//+-------------------------------------------------------------------------
//
//  Function:   displayMoniker
//
//  Synopsis:   Display a moniker
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
BOOL displayMoniker(HANDLE hProcess,
                    PNTSD_EXTENSION_APIS lpExtensionApis,
                    ULONG pMoniker)
{
    ULONG        pAdr;
    enum mnkType mType;

    // Determine if this is checked or retail ole
    if (fInScm)
    {
        pAdr = GetExpression("scm!_CairoleInfoLevel");
    }
    else
    {
        pAdr = GetExpression("ole32!_CairoleInfoLevel");
    }
    fRetail = pAdr == NULL ? TRUE : FALSE;


    mType = findMnkType(hProcess, lpExtensionApis, pMoniker);
    switch (mType)
    {
    case NOMNK:
        return FALSE;
        
    case FILEMNK:
        if (fRetail)
        {
            displayFileMoniker(hProcess, lpExtensionApis, pMoniker);
        }
        else
        {
            displayFileMonikerCk(hProcess, lpExtensionApis, pMoniker);
        }
        return TRUE;
        
    case POINTERMNK:
        if (fRetail)
        {
            displayPointerMoniker(hProcess, lpExtensionApis, pMoniker);
        }
        else
        {
            displayPointerMonikerCk(hProcess, lpExtensionApis, pMoniker);
        }
        return TRUE;
        
    case ITEMMNK:
        if (fRetail)
        {
            displayItemMoniker(hProcess, lpExtensionApis, pMoniker);
        }
        else
        {
            displayItemMonikerCk(hProcess, lpExtensionApis, pMoniker);
        }
        return TRUE;
        
    case ANTIMNK:
        if (fRetail)
        {
            displayAntiMoniker(hProcess, lpExtensionApis, pMoniker);
        }
        else
        {
            displayAntiMonikerCk(hProcess, lpExtensionApis, pMoniker);
        }
        return TRUE;
        
    case COMPOSITEMNK:
        if (fRetail)
        {
            displayCompositeMoniker(hProcess, lpExtensionApis, pMoniker);
        }
        else
        {
            displayCompositeMonikerCk(hProcess, lpExtensionApis, pMoniker);
        }
        return TRUE;
    }

    return FALSE;
}








//+-------------------------------------------------------------------------
//
//  Function:   displayFileMoniker
//
//  Synopsis:   Display a retail file moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayFileMoniker(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker)
{
    SFileMonikerCk file;
    WCHAR         *pwszPath;

    // Fetch the moniker
    ReadMem(&file, pMoniker, sizeof(SFileMoniker));

    // It's a file moniker
    Printf("File Moniker\n");

    // The current references
    Printf("refs = %d\n", file.m_refs);

    // The path
    pwszPath = (WCHAR *) OleAlloc(2 * (file.m_ccPath + 1));
    ReadMem(pwszPath, file.m_szPath, 2 * (file.m_ccPath + 1));
    Printf("%ws", pwszPath);
    OleFree(pwszPath);
    if (file.m_fHashValueValid)
    {
        Printf(" (%d)\n", file.m_dwHashValue);
    }
    else
    {
        Printf("\n");
    }

    // The version
    if (file.m_ole1 == ole1)
    {
        Printf("ole1\n");
    }

    // The anti count (if any)
    if (file.m_cAnti)
    {
        Printf("CAnti count = %d\n", file.m_cAnti);
    }

    // The extents (if any)
    if (file.m_ExtentList.m_cbMonikerExtents)
    {
        BYTE *pExtent;
        BYTE *pEnd   ;
        ULONG cbExtentBytes;

        // A header
        Printf("Extents:\n");
        
        // Read all the extents
        pExtent = (BYTE *) OleAlloc(file.m_ExtentList.m_cbMonikerExtents);
        ReadMem(pExtent, file.m_ExtentList.m_pchMonikerExtents,
                file.m_ExtentList.m_cbMonikerExtents);
        pEnd = pExtent;

        // Do over the extents
        while (pExtent < pEnd)
        {
            // Fetch length
            cbExtentBytes = (*pExtent++  << 16) | *pExtent++;

            // Fetch and display key
            switch (*pExtent++)
            {
            case mnk_MAC:
                Printf("mnk_MAC         ");
                break;
                
            case mnk_DFS:
                Printf("mnk_DFS         ");
                break;
                
            case mnk_UNICODE:
                Printf("mnk_UNICODE     ");
                break;
                
            case mnk_MacPathName:
                Printf("mnk_MacPathName ");
                break;
                
            case mnk_ShellLink:
                Printf("mnk_ShellLink   ");
                break;

            default:
                Printf("%15d ");
            }

            // Display the extent in hexadecimal
            UINT k = 0;
            
            while (cbExtentBytes--)
            {
                Printf("%2x ", *pExtent++);
                k++;
                if (k % 16 == 0)
                {
                    Printf("\n                ");
                    k = 0;
                }
            }
            if (k % 8 != 0)
            {
                Printf("\n");
            }
        }

        // Release the allocated extent buffer
        OleFree(pExtent);
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   displayFileMonikerCk
//
//  Synopsis:   Display a checked file moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayFileMonikerCk(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker)
{
    SFileMonikerCk file;
    WCHAR         *pwszPath;

    // Fetch the moniker
    ReadMem(&file, pMoniker, sizeof(SFileMonikerCk));

    // It's a file moniker
    Printf("File Moniker\n");

    // The current references
    Printf("refs = %d\n", file.m_refs);

    // The path
    pwszPath = (WCHAR *) OleAlloc(2 * (file.m_ccPath + 1));
    ReadMem(pwszPath, file.m_szPath, 2 * (file.m_ccPath + 1));
    Printf("%ws", pwszPath);
    OleFree(pwszPath);
    if (file.m_fHashValueValid)
    {
        Printf(" (%d)\n", file.m_dwHashValue);
    }
    else
    {
        Printf("\n");
    }

    // The version
    if (file.m_ole1 == ole1)
    {
        Printf("ole1\n");
    }

    // The anti count (if any)
    if (file.m_cAnti)
    {
        Printf("CAnti count = %d\n", file.m_cAnti);
    }

    // The extents (if any)
    if (file.m_ExtentList.m_cbMonikerExtents)
    {
        BYTE *pExtent;
        BYTE *pEnd   ;
        ULONG cbExtentBytes;

        // A header
        Printf("Extents:\n");
        
        // Read all the extents
        pExtent = (BYTE *) OleAlloc(file.m_ExtentList.m_cbMonikerExtents);
        ReadMem(pExtent, file.m_ExtentList.m_pchMonikerExtents,
                file.m_ExtentList.m_cbMonikerExtents);
        pEnd = pExtent;

        // Do over the extents
        while (pExtent < pEnd)
        {
            // Fetch length
            cbExtentBytes = (*pExtent++  << 16) | *pExtent++;

            // Fetch and display key
            switch (*pExtent++)
            {
            case mnk_MAC:
                Printf("mnk_MAC         ");
                break;
                
            case mnk_DFS:
                Printf("mnk_DFS         ");
                break;
                
            case mnk_UNICODE:
                Printf("mnk_UNICODE     ");
                break;
                
            case mnk_MacPathName:
                Printf("mnk_MacPathName ");
                break;
                
            case mnk_ShellLink:
                Printf("mnk_ShellLink   ");
                break;

            default:
                Printf("%15d ");
            }

            // Display the extent in hexadecimal
            UINT k = 0;
            
            while (cbExtentBytes--)
            {
                Printf("%2x ", *pExtent++);
                k++;
                if (k % 16 == 0)
                {
                    Printf("\n                ");
                    k = 0;
                }
            }
            if (k % 8 != 0)
            {
                Printf("\n");
            }
        }

        // Release the allocated extent buffer
        OleFree(pExtent);
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   displayItemMoniker
//
//  Synopsis:   Display a retail item moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayItemMoniker(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker)
{
    SItemMonikerCk item;
    WCHAR         *pwszItem;
    WCHAR         *pwszDelimiter;

    // Fetch the moniker
    ReadMem(&item, pMoniker, sizeof(SItemMoniker));
    
    // It's an item moniker
    Printf("Item Moniker\n");

    // The current references
    Printf("refs = %d\n", item.m_refs);

    // The delimiter plus item
    pwszDelimiter = (WCHAR *) OleAlloc(2 * (item.m_ccDelimiter + 1));
    ReadMem(pwszDelimiter, item.m_lpszDelimiter, 2 * (item.m_ccDelimiter + 1));
    pwszItem = (WCHAR *) OleAlloc(2 * (item.m_ccItem + 1));
    ReadMem(pwszItem, item.m_lpszItem, 2 * (item.m_ccItem + 1));
    Printf("item = %ws%ws\n", pwszDelimiter, pwszItem);
    OleFree(pwszItem);

    // The hash value
    if (item.m_fHashValueValid)
    {
        Printf("hash = %d\n", item.m_dwHashValue);
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   displayItemMonikerCk
//
//  Synopsis:   Display a checked item moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayItemMonikerCk(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker)
{
    SItemMonikerCk item;
    WCHAR         *pwszItem;
    WCHAR         *pwszDelimiter;

    // Fetch the moniker
    ReadMem(&item, pMoniker, sizeof(SItemMonikerCk));
    
    // It's an item moniker
    Printf("Item Moniker\n");

    // The current references
    Printf("refs = %d\n", item.m_refs);

    // The delimiter plus item
    pwszDelimiter = (WCHAR *) OleAlloc(2 * (item.m_ccDelimiter + 1));
    ReadMem(pwszDelimiter, item.m_lpszDelimiter, 2 * (item.m_ccDelimiter + 1));
    pwszItem = (WCHAR *) OleAlloc(2 * (item.m_ccItem + 1));
    ReadMem(pwszItem, item.m_lpszItem, 2 * (item.m_ccItem + 1));
    Printf("item = %ws%ws\n", pwszDelimiter, pwszItem);
    OleFree(pwszItem);

    // The hash value
    if (item.m_fHashValueValid)
    {
        Printf("hash = %d\n", item.m_dwHashValue);
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   displayCompositeMoniker
//
//  Synopsis:   Display a retail composite moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayCompositeMoniker(HANDLE hProcess,
                                    PNTSD_EXTENSION_APIS lpExtensionApis,
                                    ULONG pMoniker)
{
    SCompositeMonikerCk composite;

    // Fetch the moniker
    ReadMem(&composite, pMoniker, sizeof(SCompositeMoniker));
    
    // It's a composite moniker
    Printf("Composite Moniker\n");

    // The current references
    Printf("refs = %d\n", composite.m_refs);

    // Reduced?
    if (composite.m_fReduced)
    {
        Printf("reduced\n");
    }

    // The left component
    Printf("\nleft component\n");
    Printf("--------------\n");
    if (composite.m_pmkLeft)
    {
        displayMoniker(hProcess, lpExtensionApis,
                       (ULONG) composite.m_pmkLeft);
    }
    else
    {
        Printf("NULL\n");
    }

    // The right component
    Printf("\nright component\n");
    Printf("---------------\n");
    if (composite.m_pmkRight)
    {
        displayMoniker(hProcess, lpExtensionApis,
                       (ULONG) composite.m_pmkRight);
    }
    else
    {
        Printf("NULL\n");
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   displayCompositeMonikerCk
//
//  Synopsis:   Display a checked composite moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayCompositeMonikerCk(HANDLE hProcess,
                                      PNTSD_EXTENSION_APIS lpExtensionApis,
                                      ULONG pMoniker)
{
    SCompositeMonikerCk composite;

    // Fetch the moniker
    ReadMem(&composite, pMoniker, sizeof(SCompositeMonikerCk));
    
    // It's a composite moniker
    Printf("Composite Moniker\n");

    // The current references
    Printf("refs = %d\n", composite.m_refs);

    // Reduced?
    if (composite.m_fReduced)
    {
        Printf("reduced\n");
    }

    // The left component
    Printf("\nleft component\n");
    Printf("--------------\n");
    if (composite.m_pmkLeft)
    {
        displayMoniker(hProcess, lpExtensionApis,
                       (ULONG) composite.m_pmkLeft);
    }
    else
    {
        Printf("NULL\n");
    }

    // The right component
    Printf("\nright component\n");
    Printf("---------------\n");
    if (composite.m_pmkRight)
    {
        displayMoniker(hProcess, lpExtensionApis,
                       (ULONG) composite.m_pmkRight);
    }
    else
    {
        Printf("NULL\n");
    }
}








//+-------------------------------------------------------------------------
//
//  Function:   displayPointerMoniker
//
//  Synopsis:   Display a retail pointer moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayPointerMoniker(HANDLE hProcess,
                                  PNTSD_EXTENSION_APIS lpExtensionApis,
                                  ULONG pMoniker)
{
    SPointerMoniker pointer;

    // Fetch the moniker
    ReadMem(&pointer, pMoniker, sizeof(SPointerMoniker));
    
    // It's a pointer moniker
    Printf("Pointer Moniker\n");

    // The current references
    Printf("refs = %d\n", pointer.m_refs);

    // The pointer
    Printf("IUnknown = %08x\n", pointer.m_pUnk);
}








//+-------------------------------------------------------------------------
//
//  Function:   displayPointerMonikerCk
//
//  Synopsis:   Display a checked pointer moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayPointerMonikerCk(HANDLE hProcess,
                                  PNTSD_EXTENSION_APIS lpExtensionApis,
                                  ULONG pMoniker)
{
    SPointerMonikerCk pointer;

    // Fetch the moniker
    ReadMem(&pointer, pMoniker, sizeof(SPointerMonikerCk));
    
    // It's a pointer moniker
    Printf("Pointer Moniker\n");

    // The current references
    Printf("refs = %d\n", pointer.m_refs);

    // The pointer
    Printf("IUnknown = %08x\n", pointer.m_pUnk);
}








//+-------------------------------------------------------------------------
//
//  Function:   displayAntiMoniker
//
//  Synopsis:   Display a retail anti moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayAntiMoniker(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker)
{
    SAntiMoniker anti;

    // Fetch the moniker
    ReadMem(&anti, pMoniker, sizeof(SAntiMoniker));
    
    // It's a pointer moniker
    Printf("Anti Moniker\n");

    // The current references
    Printf("refs = %d\n", anti.m_refs);

    // The count
    Printf("count = %d\n", anti.m_count);
}








//+-------------------------------------------------------------------------
//
//  Function:   displayAntiMonikerCk
//
//  Synopsis:   Display a checked anti moniker
//
//  Arguments:  [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static void displayAntiMonikerCk(HANDLE hProcess,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               ULONG pMoniker)
{
    SAntiMonikerCk anti;

    // Fetch the moniker
    ReadMem(&anti, pMoniker, sizeof(SAntiMonikerCk));
    
    // It's a pointer moniker
    Printf("Anti Moniker\n");

    // The current references
    Printf("refs = %d\n", anti.m_refs);

    // The count
    Printf("count = %d\n", anti.m_count);
}








//+-------------------------------------------------------------------------
//
//  Function:   findMnkType
//
//  Synopsis:   Given a moniker, compute its type
//
//  Arguments:  [HANDLE]       -       process handle
//              [PNTSD_EXTENSION_APIS] Convenience routines
//              [ULONG]        -       The moniker
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
static enum mnkType findMnkType(HANDLE hProcess,
                                PNTSD_EXTENSION_APIS lpExtensionApis,
                                ULONG pMoniker)
{
    void *vtbl;
    char  szSymbol[128];
    DWORD dwOffset;
    
    // Read the symbol for the first element in the first vtbl
    ReadMem(&vtbl, pMoniker, sizeof(ULONG));
    ReadMem(&vtbl, vtbl, sizeof(ULONG));
    szSymbol[0] = '\0';
    GetSymbol(vtbl, (UCHAR *) szSymbol, &dwOffset);

    // We better be looking at a QueryInterface on a moniker
    if (dwOffset != 0)
    {
        return NOMNK;
    }
    if (lstrcmp(szSymbol, "ole32!CFileMoniker__QueryInterface") == 0)
    {
        return FILEMNK;
    }
    else if (lstrcmp(szSymbol, "ole32!CItemMoniker__QueryInterface") == 0)
    {
        return ITEMMNK;
    }
    else if (lstrcmp(szSymbol, "ole32!CCompositeMoniker__QueryInterface") == 0)
    {
        return COMPOSITEMNK;
    }
    else if (lstrcmp(szSymbol, "ole32!CPointerMoniker__QueryInterface") == 0)
    {
        return POINTERMNK;
    }
    else if (lstrcmp(szSymbol, "ole32!CAntiMoniker__QueryInterface") == 0)
    {
        return ANTIMNK;
    }
    else
    {
        return NOMNK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dmoniker.h ===
enum mnkType {NOMNK, FILEMNK, POINTERMNK, ITEMMNK, ANTIMNK, COMPOSITEMNK};



enum olever {undetermined, ole1, ole2 };



enum ExtentKeys
{
    mnk_MAC         = 1,
    mnk_DFS         = 2,
    mnk_UNICODE     = 3,
    mnk_MacPathName = 4,
    mnk_ShellLink   = 5
};



struct SExtentList
{
    ULONG     m_cbMonikerExtents;
    BYTE     *m_pchMonikerExtents;
};



struct SFileMoniker
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    CLSID       m_clsid;
    SExtentList m_ExtentList;
    WCHAR      *m_szPath;
    char       *m_pszAnsiPath;
    USHORT	m_ccPath;
    USHORT	m_cbAnsiPath;
    DWORD	m_dwHashValue;
    ULONG	m_fUnicodeExtent:1;
    ULONG	m_fClassVerified:1;
    ULONG	m_fHashValueValid:1;
    USHORT     	m_cAnti;
    USHORT      m_endServer;
    enum olever m_ole1;
};



struct SFileMonikerCk
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    void       *vtbl4;
    ULONG       m_debug;
    CLSID       m_clsid;
    SExtentList m_ExtentList;
    WCHAR      *m_szPath;
    char       *m_pszAnsiPath;
    USHORT	m_ccPath;
    USHORT	m_cbAnsiPath;
    DWORD	m_dwHashValue;
    ULONG	m_fUnicodeExtent:1;
    ULONG	m_fClassVerified:1;
    ULONG	m_fHashValueValid:1;
    USHORT     	m_cAnti;
    USHORT      m_endServer;
    enum olever m_ole1;
};




struct SPointerMoniker
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    LPUNKNOWN	m_pUnk;
};




struct SPointerMonikerCk
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    void       *vtbl4;
    ULONG       m_debug;
    LPUNKNOWN	m_pUnk;
};




struct SItemMoniker
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    WCHAR      *m_lpszItem;
    char       *m_pszAnsiItem;
    USHORT	m_ccItem;
    USHORT	m_cbAnsiItem;
    WCHAR      *m_lpszDelimiter;
    char       *m_pszAnsiDelimiter;
    USHORT      m_ccDelimiter;
    USHORT	m_cbAnsiDelimiter;
    ULONG	m_fHashValueValid:1;
    DWORD	m_dwHashValue;
};




struct SItemMonikerCk
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    void       *vtbl4;
    ULONG       m_debug;
    WCHAR      *m_lpszItem;
    char       *m_pszAnsiItem;
    USHORT	m_ccItem;
    USHORT	m_cbAnsiItem;
    WCHAR      *m_lpszDelimiter;
    char       *m_pszAnsiDelimiter;
    USHORT      m_ccDelimiter;
    USHORT	m_cbAnsiDelimiter;
    ULONG	m_fHashValueValid:1;
    DWORD	m_dwHashValue;
};





struct SAntiMoniker
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    ULONG	m_count;
};





struct SAntiMonikerCk
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    void       *vtbl4;
    ULONG       m_debug;
    ULONG	m_count;
};





struct SCompositeMoniker
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    LPMONIKER	m_pmkLeft;
    LPMONIKER	m_pmkRight;
    BOOL        m_fReduced;
};





struct SCompositeMonikerCk
{
    void       *vtbl1;
    void       *vtbl2;
    ULONG	m_refs;
    void       *vtbl3;
    ULONG       m_marshal;
    void       *vtbl4;
    ULONG       m_debug;
    LPMONIKER	m_pmkLeft;
    LPMONIKER	m_pmkRight;
    BOOL        m_fReduced;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dipid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dipid.h
//
//  Contents:   Contains structure definitons for the significant OXID and
//              IPID structures which the ntsd extensions need to access.
//              These ole classes cannot be accessed more cleanly because
//              typically the members of interest are protected.
//
//              WARNING.  IF THE REFERENCED OLE CLASSES CHANGE, THEN THESE
//              DEFINITIONS MUST CHANGE!
//
//  History:    08-11-95 BruceMa    Created
//
//--------------------------------------------------------------------------



typedef GUID OXID;


struct IPID
{
    WORD  offset;     // These are reversed because of little-endian
    WORD  page;       // These are reversed because of little-endian
    DWORD pid;
    DWORD tid;
    DWORD seq;
};


struct  STRINGARRAY
{
    unsigned long size;
    unsigned short awszStringArray[1];
};



struct SOXIDEntry
{
    struct SOXIDEntry  *pPrev;	    // previous entry on inuse list
    struct SOXIDEntry  *pNext;	    // next entry on free/inuse list
    DWORD		dwPid;	    // process id of server
    DWORD		dwTid;	    // thread id of server
    OXID		oxid;	    // object exporter identifier
    STRINGARRAY        *psa;	    // ptr to server obj exp string arrary
    DWORD		dwFlags;    // state flags
    handle_t		hServer;    // rpc binding handle of server
    void               *pRU;        // proxy for Remote Unknown
    IPID		ipidRundown;// IPID of IRundown and Remote Unknown
    LONG		cRefs;	    // count of IPIDs using this OXIDEntry
};




typedef enum tagOXIDFLAGS
{
    OXIDF_REGISTERED	= 1,	    // oxid is registered with Resolver
    OXIDF_MACHINE_LOCAL = 2,	    // oxid is local to this machine
    OXIDF_STOPPED	= 4,	    // thread can no longer receive calls
    OXIDF_PENDINGRELEASE= 8	    // oxid entry is already being released
} OXIDFLAGS;


#define OXIDTBL_PAGESIZE	4096


// Forward reference
struct SRpcChannelBuffer;


struct SIPIDEntry
{
    IPID		ipid;	    // interface pointer identifier
    IID 		iid;	    // interface iid
    SRpcChannelBuffer  *pChnl;	    // channel pointer
    IUnknown	       *pStub;	    // proxy or stub pointer
    void	       *pv;	    // real interface pointer
    SOXIDEntry	       *pOXIDEntry; // ptr to OXIDEntry in OXID Table
    DWORD		dwFlags;    // flags (see IPIDFLAGS)
    ULONG		cStrongRefs;// strong reference count
    ULONG		cWeakRefs;  // weak reference count
    LONG		iNextOID;   // next entry in this table for same object
};



typedef enum tagIPIDFLAGS
{
    IPIDF_CONNECTING   = 1,	    // ipid is being connected
    IPIDF_DISCONNECTED = 2,	    // ipid is disconnected
    IPIDF_SERVERENTRY  = 4,	    // SERVER IPID vs CLIENT IPID
    IPIDF_NOPING       = 8,	    // dont need to ping the server or release
    IPIDF_VACANT       = 128	    // entry is vacant (ie available to reuse)
} IPIDFLAGS;


#define IPIDTBL_PAGESIZE	4096
#define IPIDTBL_PAGESHIFT	16
#define IPIDTBL_PAGEMASK	0x0000ffff

#define IPIDsPerPage            (IPIDTBL_PAGESIZE / sizeof(SIPIDEntry))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dpsclsid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dpsclsid.cxx
//
//  Contents:   Ole NTSD extension routines to dump the proxy/stub
//              clsid cache
//
//  Functions:  psClsidHelp
//              displayPsClsidTbl
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dshrdmem.h"




BOOL IsEqualCLSID(CLSID *pClsid1, CLSID *pClsid2);
void FormatCLSID(REFGUID rguid, LPSTR lpsz);
BOOL GetRegistryInterfaceName(REFIID iid, char *szValue, DWORD *pcbValue);
BOOL GetRegistryClsidKey(REFCLSID clsid, char *szKey,
                         char *szValue, DWORD *pcbValue);


//+-------------------------------------------------------------------------
//
//  Function:   psClsidHelp
//
//  Synopsis:   Display a menu for the command 'ps'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void psClsidHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("ps          - Display infomation for all IID's\n");
    Printf("ps IID      - Display infomation for IID\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayPsClsidTbl
//
//  Synopsis:   Given an interface IID display the CLSID of the
//              associated proxy/stub handler dll
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [lpFileExtTbl]    -       Address of file extensions table
//              [pClsid]          -       Only for this clsid
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayPsClsidTbl(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis,
                       SDllShrdTbl *pShrdTbl,
                       IID *pIid)
{
    SDllShrdTbl  sDllTbl;
    GUIDMAP      sGuidMap;
    GUIDPAIR    *pGuidPair;
    DWORDPAIR   *pDwordPair;
    IID          iid = {0, 0, 0, {0xc0, 0, 0, 0, 0, 0, 0, 0x46}};
    char         szClsid[CLSIDSTR_MAX];
    char         szName[129];
    DWORD        cbValue;
    
    // Read the shared table locally
    ReadMem(&sDllTbl, pShrdTbl, sizeof(SDllShrdTbl));

    // Read the guid map locally
    ReadMem(&sGuidMap, sDllTbl._PSClsidTbl._pGuidMap, sizeof(GUIDMAP));

    // Allocate for the guid pair list
    pGuidPair = (GUIDPAIR *) OleAlloc(sGuidMap.ulCntLong * sizeof(GUIDPAIR));

    // Allocate for the dword pair list
    pDwordPair = (DWORDPAIR *) OleAlloc(sGuidMap.ulCntShort *
                                        sizeof(DWORDPAIR));

    // Read the guid pair list
    ReadMem(pGuidPair, sDllTbl._PSClsidTbl._pLongList -
            (sGuidMap.ulCntLong - 1),
            sGuidMap.ulCntLong * sizeof(GUIDPAIR));

    // Read the dword pair list
    ReadMem(pDwordPair, sDllTbl._PSClsidTbl._pShortList,
            sGuidMap.ulCntShort * sizeof(DWORDPAIR));

    // Are we looking for a specific IID?
    if (pIid != NULL)
    {
        // Search the short list first
        for (UINT cCnt = 0; cCnt < sGuidMap.ulCntShort; pDwordPair++, cCnt++)
        {
            if (pIid->Data1 == pDwordPair->dw1)
            {
                iid.Data1 = pIid->Data1;
                
                // Fetch and print the interface name
                cbValue = 64;
                if(GetRegistryInterfaceName(iid, szName, &cbValue))
                {
                    Printf("%s\t", szName);
                }
                else
                {
                    Printf("-\t");
                }
                
                // The clsid
                iid.Data1 = pDwordPair->dw2;
                FormatCLSID(iid, szClsid);
                Printf("%s\t", szClsid);
                
                // Fetch and print the proxy/stub handler dll
                cbValue = 128;
                if (GetRegistryClsidKey(iid, "InprocServer32", szName,
                                        &cbValue))
                {
                    Printf("%s\n", szName);
                }
                else if(GetRegistryClsidKey(iid, "InprocServer", szName,
                                            &cbValue))
                {
                    Printf("%s(16)\n", szName);
                }
                else
                {
                    Printf("-\n");
                }

                return;
            }
        }
        
        // Search the long list next
        for (cCnt = 0; cCnt < sGuidMap.ulCntLong; pGuidPair++, cCnt++)
        {
            if (IsEqualCLSID(pIid, &pGuidPair->guid1))
            {
                // Fetch and print the interface name
                cbValue = 64;
                if(GetRegistryInterfaceName(pGuidPair->guid1, szName,
                                            &cbValue))
                {
                    Printf("%s\t", szName);
                }
                else
                {
                    Printf("-\t");
                }
                
                // The clsid
                FormatCLSID(pGuidPair->guid2, szClsid);
                Printf("%s\t", szClsid);
                
                // Fetch and print the proxy/stub handler dll
                cbValue = 128;
                if (GetRegistryClsidKey(pGuidPair->guid2, "InprocServer32",
                                        szName,
                                        &cbValue))
                {
                    Printf("%s\n", szName);
                }
                else if(GetRegistryClsidKey(pGuidPair->guid2, "InprocServer",
                                            szName, &cbValue))
                {
                    Printf("%s(16)\n", szName);
                }
                else
                {
                    Printf("-\n");
                }

                return;
            }
        }
    }

    // Else dump everything
    else
    {
        // Print header
        Printf("where -. = '-0000-0000-C000-000000000046}'\n\n");
        Printf("   IID           interface               clsid           p/s dll\n");
        Printf("-----------   ------------------       -----------      ---------\n");
        // Do over the short list
        for (UINT cCnt = 0 ; cCnt < sGuidMap.ulCntShort; pDwordPair++, cCnt++)
        {
            // Print the IID
            iid.Data1 = pDwordPair->dw1;
            FormatCLSID(iid, szClsid);
            if (lstrcmp(&szClsid[9], "-0000-0000-C000-000000000046}") == 0)
            {
                szClsid[9] = '\0';
                Printf("%s-.", szClsid);
            }
            else
            {
                Printf("%s\n", szClsid);
            }
               
            // Fetch and print the interface name
            cbValue = 64;
            if(GetRegistryInterfaceName(iid, szName, &cbValue))
            {
                Printf("   %s", szName);
            }
            else
            {
                Printf("   -");
            }

            // Do some pretty printing alignment
            for (UINT cCh = 24 - lstrlen(szName); cCh > 0; cCh--)
            {
                Printf(" ");
            }
            Printf(" ");

            // The clsid
            iid.Data1 = pDwordPair->dw2;
            FormatCLSID(iid, szClsid);
            if (lstrcmp(&szClsid[9], "-0000-0000-C000-000000000046}") == 0)
            {
                szClsid[9] = '\0';
                Printf("%s-.\t", szClsid);
            }
            else
            {
                Printf("%s\t", szClsid);
            }

            // Fetch and print the proxy/stub handler dll
            cbValue = 128;
            if (GetRegistryClsidKey(iid, "InprocServer32", szName, &cbValue))
            {
                Printf("%s\n", szName);
            }
            else if(GetRegistryClsidKey(iid, "InprocServer", szName,
                                        &cbValue))
            {
                Printf("%s(16)\n", szName);
            }
            else
            {
                Printf("-\n");
            }
        }
        
        // Do over the long list
        for (cCnt = 0; cCnt < sGuidMap.ulCntLong; pGuidPair++, cCnt++)
        {
            // Print the IID
            FormatCLSID(pGuidPair->guid1, szClsid);
            Printf("%s ", szClsid);

            // Fetch and print the interface name
            cbValue = 64;
            if(GetRegistryInterfaceName(pGuidPair->guid1, szName, &cbValue))
            {
                Printf("   %s", szName);
            }
            else
            {
                Printf("   -");
            }

            // Do some pretty printing alignment
            for (UINT cCh = 24 - lstrlen(szName); cCh > 0; cCh--)
            {
                Printf(" ");
            }
            Printf(" ");

            // The clsid
            FormatCLSID(pGuidPair->guid2, szClsid);
            if (lstrcmp(&szClsid[9], "-0000-0000-C000-000000000046}") == 0)
            {
                szClsid[9] = '\0';
                Printf("%s-.\t", szClsid);
            }
            else
            {
                Printf("%s\t", szClsid);
            }

            // Fetch and print the proxy/stub handler dll
            cbValue = 128;
            if (GetRegistryClsidKey(pGuidPair->guid2, "InprocServer32",
                                    szName, &cbValue))
            {
                Printf("%s\n", szName);
            }
            else if(GetRegistryClsidKey(iid, "InprocServer32", szName,
                                        &cbValue))
            {
                Printf("%s(16)\n", szName);
            }
            else
            {
                Printf("-\n");
            }
        }
    }
    
    // Release allocated resources
    OleFree(pGuidPair);
    OleFree(pDwordPair);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\doxid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       doxid.cxx
//
//  Contents:   Ole NTSD extension routines to display COXID table
//
//  Functions:  oxidHelp
//              displayOxid
//
//
//  History:    21-Aug-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dipid.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);
BOOL ScanCLSID(LPSTR lpsz, CLSID *pClsid);
ULONG ScanAddr(char *lpsz);



static char *aszProtSeq[] = {/* 0x00 */ 0,
                             /* 0x01 */ "mswmsg",
                             /* 0x02 */ 0,
                             /* 0x03 */ 0,
                             /* 0x04 */ "ncacn_dnet_dsp",
                             /* 0x05 */ 0,
                             /* 0x06 */ 0,
                             /* 0x07 */ "ncacn_ip_tcp",
                             /* 0x08 */ "ncadg_ip_udp",
                             /* 0x09 */ "ncacn_nb_tcp",
                             /* 0x0a */ 0,
                             /* 0x0b */ 0,
                             /* 0x0c */ "ncacn_spx",
                             /* 0x0d */ "ncacn_nb_ipx",
                             /* 0x0e */ "ncadg_ipx",
                             /* 0x0f */ "ncacn_np",
                             /* 0x10 */ "ncalrpc",
                             /* 0x11 */ 0,
                             /* 0x12 */ 0,
                             /* 0x13 */ "ncacn_nb_nb"};





//+-------------------------------------------------------------------------
//
//  Function:   oxidHelp
//
//  Synopsis:   Display a menu for the command 'id'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    21-Aug-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void oxidHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("\nox       - Display entire OXID table:\n");
    Printf("addr oxid\n");
    Printf("...\n\n");
    Printf("ox addr    - Display specific OXID entry:\n");
    Printf("oxid serverPid serverTid flags hRpc IRemUnknown* runDownIPID refs stringBindings\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayOxid
//
//  Synopsis:   Display the entire OXID table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    21-Aug-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayOxid(HANDLE hProcess,
                  PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG        pAdr;
    SOXIDEntry  *pOXIDentry;
    SOXIDEntry  *pFirstOXIDentry;
    SOXIDEntry   sOXIDentry;
    char         szGuid[CLSIDSTR_MAX];
    STRINGARRAY *pBindings;
    ULONG        ulSize;


    // Read the address of the first in use OXID entry
    pAdr = GetExpression("ole32!COXIDTable___InUseHead");
    pFirstOXIDentry = (SOXIDEntry *) pAdr;
    ReadMem(&pOXIDentry, pAdr + sizeof(ULONG), sizeof(SOXIDEntry *));

    // Do over in use OXID entries
    do
    {
        // Read the next OXID entry
        ReadMem(&sOXIDentry, pOXIDentry, sizeof(SOXIDEntry));

        // Print the address
        Printf("%x ", pOXIDentry);

        // Print the OXID
        FormatCLSID((GUID &) sOXIDentry.oxid, szGuid);
        Printf("%s\n", szGuid);
        
        // Go to the next in use OXID entry
        pOXIDentry = sOXIDentry.pNext;

        // Just in case
        if (CheckControlC())
        {
            return;
        }
    } until_(pOXIDentry == pFirstOXIDentry);
}






//+-------------------------------------------------------------------------
//
//  Function:   displayOxidEntry
//
//  Synopsis:   Display an entry in the OXID table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [arg]             -       OXID of entry to display
//
//  Returns:    -
//
//  History:    21-Aug-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayOxidEntry(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      char *arg)
{
    OXID         oxid;
    ULONG        pAdr;
    SOXIDEntry  *pOXIDentry;
    SOXIDEntry  *pFirstOXIDentry;
    SOXIDEntry   sOXIDentry;
    char         szGuid[CLSIDSTR_MAX];
    STRINGARRAY *pBindings;
    ULONG        ulSize;


    // Check for help
    if (arg[0] == '?')
    {
        Printf("oxid serverPid serverTid flags hRpc IRemUnknown* runDownIPID refs stringBindings\n");
        return;
    }

    // Convert the argument to an OXID
    pAdr = ScanAddr(arg);
    
    // Read the OXID entry
    ReadMem(&sOXIDentry, pAdr, sizeof(SOXIDEntry));

    // OXID
    FormatCLSID((GUID &) sOXIDentry.oxid, szGuid);
    Printf("%s ", szGuid);
        
    // Server PID
    Printf("%3x ", sOXIDentry.dwPid);
            
    // Server TID
    Printf("%3x ", sOXIDentry.dwTid);
    
    // Flags
    if (sOXIDentry.dwFlags & OXIDF_REGISTERED)
    {
        Printf("R");
    }
    if (sOXIDentry.dwFlags & OXIDF_MACHINE_LOCAL)
    {
        Printf("L");
    }
    if (sOXIDentry.dwFlags & OXIDF_STOPPED)
    {
        Printf("S");
    }
    if (sOXIDentry.dwFlags & OXIDF_PENDINGRELEASE)
    {
        Printf("P");
    }
    Printf(" ");
    
    // RPC binding handle
    Printf("%x ", sOXIDentry.hServer);

    // Proxy for RemUnknown
    Printf("%x ", sOXIDentry.pRU);

    // IPID of IRunDown and Remote Unknown
    Printf("[%d.%d %3x %3x %d] ",
           sOXIDentry.ipidRundown.page,
           sOXIDentry.ipidRundown.offset,
           sOXIDentry.ipidRundown.pid,
           sOXIDentry.ipidRundown.tid,
           sOXIDentry.ipidRundown.seq);

    // References
    Printf("%d\n ", sOXIDentry.cRefs);
            
    // Print the string bindings
    ReadMem(&ulSize, sOXIDentry.psa, sizeof(ULONG));
    pBindings = (STRINGARRAY *) OleAlloc(ulSize * sizeof(WCHAR));
    ReadMem(pBindings, sOXIDentry.psa, ulSize * sizeof(WCHAR));
    
    // Do over protocol sequence/network address pairs
    for (UINT k = 0; k < ulSize - 2  ||
         pBindings->awszStringArray[k] == 0; )
    {
        char *pszProtSeq;
        
        // The protocol sequence
        pszProtSeq = aszProtSeq[pBindings->awszStringArray[k]];
        if (pszProtSeq == NULL)
        {
            Printf("%d", pBindings->awszStringArray[k]);
        }
        else
        {
            Printf("%s", pszProtSeq);
        }
        k++;
        
        // The network address
        Printf("%ws ", &pBindings->awszStringArray[k]);
        k += lstrlenW(&pBindings->awszStringArray[k]) + 1;
    }
    Printf("\n");
    OleFree(pBindings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\drot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       drot.cxx
//
//  Contents:   Ole NTSD extension routines to display the ROT
//
//  Functions:  displayRot
//
//
//  History:    06-01-95 BruceMa    Created
//              06-26-95 BruceMa    Add SCM ROT support
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "drot.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);




//+-------------------------------------------------------------------------
//
//  Function:   cliRotHelp
//
//  Synopsis:   Display a menu for the command 'rt'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void cliRotHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("rt         - Display the Running Object Table:\n");
    Printf("Client side ROT\n");
    Printf("sig\tcall?\t(scmLoc scmId)\thApt\n");
    Printf("...\n\n");
    Printf("Client side hint table\n");
    Printf("<indices of set indicators>\n");
}







//+-------------------------------------------------------------------------
//
//  Function:   scmRotHelp
//
//  Synopsis:   Display a menu for the command 'rt'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void scmRotHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("rt         - Display the Running Object Table:\n");
    Printf("Client side ROT\n");
    Printf("sig\tcall?\t(scmLoc scmId)\thApt\n");
    Printf("...\n\n");
    Printf("Client side hint table\n");
    Printf("<indices of set indicators>\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayCliRot
//
//  Synopsis:   Formats and writes an ole processes' version of the
//              ROT to the debug terminal
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayCliRot(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG                padr;
    SRunningObjectTable *psRot;
    SRunningObjectTable  sRot;
    SRotItem             sRotItm;
    SRotItem           **ppsRotItm;
    SRotItem            *psRotItm;
    int                  cSize;

    // Read the CRunningObjectTable
    padr = GetExpression("ole32!pRot");
    ReadMem(&psRot, padr, sizeof(SRunningObjectTable *));
    ReadMem(&sRot, psRot, sizeof(SRunningObjectTable));
    
    // Read the array of pointers to ROT items
    UINT ulSize = sRot._afvRotList.m_nSize * sizeof(SRotItem *);
    
    ppsRotItm = (SRotItem **) OleAlloc(ulSize);
    ReadMem(ppsRotItm, sRot._afvRotList.m_pData, ulSize);

    // Display the ROT items in the table
    Printf("Client side ROT\n");
    for (cSize = 0; cSize < sRot._afvRotList.m_nSize; cSize++)
    {
        psRotItm = ppsRotItm[cSize];
        if (psRotItm != NULL)
        {
            // Fetch the next ROT item
            ReadMem(&sRotItm, psRotItm, sizeof(SRotItem));

            // Display this ROT item
            if (sRotItm._fDontCallApp)
            {
                Printf("%d\tTRUE\t(0x%p %x)\t%x\n",
                       sRotItm._wItemSig,
                       sRotItm._scmregkey.dwEntryLoc,
                       sRotItm._scmregkey.dwScmId,
                       sRotItm._hApt);
            }
            else
            {
                Printf("%d\tFALSE\t(0x%p %x)\t%x\n",
                       sRotItm._wItemSig,
                       sRotItm._scmregkey.dwEntryLoc,
                       sRotItm._scmregkey.dwScmId,
                       sRotItm._hApt);
            }
        }
    }

    
    // Display the client side ROT hint table
    BYTE *pHint;
    UINT  k, l; 

    // Read the client side ROT hint table
    pHint = (BYTE *) OleAlloc(SCM_HASH_SIZE * sizeof(DWORD));
    ReadMem(pHint, sRot._crht._pbHintArray, SCM_HASH_SIZE * sizeof(BYTE));

    // Display the client side hint table
    Printf("\nClient side hint table\n");
    for (l = 0, k = 0; k < SCM_HASH_SIZE; k++)
    {
        if (l == 16)
        {
            Printf("\n");
            l = 0;
        }
        if (pHint[k])
        {
            Printf("%02d ", k);
            l++;
        }
    }
    if (l > 1)
    {
        Printf("\n");
    }


    // Delete resources
    OleFree(ppsRotItm);
    OleFree(pHint);
}






//+-------------------------------------------------------------------------
//
//  Function:   displayScmRot
//
//  Synopsis:   Formats and writes the full ROT to the debug terminal
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    26-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayScmRot(HANDLE hProcess,
                   PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG          addr;
    UINT           cEnt;
    char           szClsid[CLSIDSTR_MAX];
    SPerMachineROT sPerMachineRot;
    SRotAcctEntry  sRotAcctEntry;
    SScmRot        sScmRot;
    SScmRotEntry **ppScmHashTbl;
    SScmRotEntry  *pScmRotEntry;
    SScmRotEntry   sScmRotEntry;
    WCHAR          wszSID[64];
    char           szSID[64];
    MNKEQBUF      *pMnkEqBfr;
    IFData         sIFData;
    SYSTEMTIME     sSystemTime;
    
    // Get the address of the per machine ROT global
    addr = GetExpression("scm!pPerMachineRot");

    // Read the CPerMachineRot
    ReadMem(&addr, addr, sizeof(ULONG));
    ReadMem(&sPerMachineRot, addr, sizeof(SPerMachineROT));

    // Read the first CRotAcctEntry
    ReadMem(&sRotAcctEntry, sPerMachineRot._safvRotAcctTable.m_pData,
            sizeof(SRotAcctEntry));

    // Read the CScmRot table
    ReadMem(&sScmRot, sRotAcctEntry.pscmrot, sizeof(SScmRot));

    // Read the hash table of CScmRotEntry *'s
    ppScmHashTbl = (SScmRotEntry **) OleAlloc(sScmRot._sht._ndwHashTableSize *
                                              sizeof(SScmRotEntry *));
    ReadMem(ppScmHashTbl, sScmRot._sht._apsheHashTable,
            sScmRot._sht._ndwHashTableSize * sizeof(SScmRotEntry *));

    // A header
    ReadMem(wszSID, sRotAcctEntry.unicodestringSID, 64);
    Unicode2Ansi(szSID, wszSID, 64);
    szSID[32] = '\0';
    Printf("\nSCM side ROT for SID %s\n\n", szSID);

    // Do over entries in the hash table
    for (cEnt = 0, pScmRotEntry = ppScmHashTbl[0];
         cEnt < sScmRot._sht._ndwHashTableSize;
         cEnt++, pScmRotEntry = ppScmHashTbl[cEnt])
    {
        // Only look at non-empty entries
        while (pScmRotEntry)
        {
            // Read the CScmRotEntry
            ReadMem(&sScmRotEntry, pScmRotEntry, sizeof(SScmRotEntry));

            // Read the moniker comparison buffer
            ULONG ulSize;

            ReadMem(&ulSize, sScmRotEntry._pmkeqbufKey, sizeof(ULONG));
            pMnkEqBfr = (MNKEQBUF *) OleAlloc(sizeof(ULONG) + ulSize);
            ReadMem(pMnkEqBfr, sScmRotEntry._pmkeqbufKey,
                    sizeof(ULONG) + ulSize);

            // Read the interface data buffer
            ReadMem(&sIFData, sScmRotEntry._pifdObject,
                    sizeof(IFData));

            // The registration Id
            Printf("RegID:          %x\n", sScmRotEntry._dwScmRotId);

            // The moniker display name
            Unicode2Ansi(szSID, pMnkEqBfr->_wszName, 64);
            Printf("Display Name:   %s\n", szSID);

            // The last time changed
            FileTimeToSystemTime(&sScmRotEntry._filetimeLastChange,
                                 &sSystemTime);
            Printf("Last Change:    %2d:%02d:%02d %2d/%2d/%2d\n",
                   sSystemTime.wHour - 7,
                   sSystemTime.wMinute,
                   sSystemTime.wSecond,
                   sSystemTime.wMonth,
                   sSystemTime.wDay,
                   sSystemTime.wYear - 1900);

            // The clsid of the moniker
            FormatCLSID(pMnkEqBfr->_clsid, szClsid);
            Printf("Moniker Type:   %s\n", szClsid);

            // The server unique id (from CoGetCurrentProcess())
            Printf("Server ID:      %d\n", sScmRotEntry._dwProcessID);

            // The RPC end point
            Unicode2Ansi(szSID, sIFData._wszEndPoint, 64);
            Printf("Endpoint:       %s\n", szSID);

            // The object ID
            FormatCLSID(sIFData._oid, szClsid);
            Printf("Object OID:     %s\n", szClsid);

            // The IID of the object
            FormatCLSID(sIFData._iid, szClsid);
            Printf("Object IID:     %s\n\n", szClsid);

            // The hash table entry can be a list, i.e. a hash bucket, of
            // ROT entries having the same hash value
            pScmRotEntry = sScmRotEntry._sheNext;

            // Release the moniker compare buffer
            OleFree(pMnkEqBfr);
        }
    }
    
    OleFree(ppScmHashTbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\drot.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       drot.h
//
//  Contents:   Contains structure definitons for the significant ROT
//              classes which the ntsd extensions need to access.
//              These ole classes cannot be accessed more cleanly because
//              typically the members of interest are private.
//
//              WARNING.  IF THE REFERENCED OLE CLASSES CHANGE, THEN THESE
//              DEFINITIONS MUST CHANGE!
//
//  History:    06-01-95 BruceMa    Created
//              06-26-95 BruceMa    Add SCM ROT support
//
//--------------------------------------------------------------------------


#define SCM_HASH_SIZE 251


struct SCMREGKEY
{
    ULONG64             dwEntryLoc;
    DWORD               dwScmId;
};




struct SRotItem
{
    WORD		_wItemSig;
    BOOL                _fDontCallApp;
    SCMREGKEY           _scmregkey;
    HAPT		_hApt;
};





struct SCliRotHintTable
{
    BYTE               *_pbHintArray;
    HANDLE              _hSm;
};





struct SRunningObjectTable
{
    LPVOID              _vtbl;
    SArrayFValue     	_afvRotList;
    SCliRotHintTable    _crht;
    WORD                _wSigRotItem;
};




struct SPerMachineROT
{
    SMutexSem           _mxs;
    DWORD               _dwTotalAcctsReg;
    SArrayFValue        _safvRotAcctTable;
};




struct SScmRotHintTable
{
    HANDLE              _hSm;
};




struct MNKEQBUF
{
    DWORD               _cbSize;
    CLSID               _clsid;
    WCHAR               _wszName[1];
};




struct IFData
{
    DWORD               _UNUSED[3];
    GUID                _oid;
    DWORD               _UNUSED2;
    IID                 _iid;
    DWORD               _UNUSED3[4];
    WCHAR               _wszEndPoint[64];
};




struct SScmRotEntry
{
    LPVOID              _vtbl;
    SScmRotEntry       *_sheNext;
    DWORD               _dwSig;
    DWORD               _dwScmRotId;
    DWORD               _dwProcessID;
    FILETIME            _filetimeLastChange;
    IFData             *_pifdObject;
    MNKEQBUF           *_pmkeqbufKey;
    IFData             *_pifdObjectName;
    BYTE                _ab[1];
};




struct SScmHashEntry
{
    SScmHashEntry *     _sheNext;
};




struct SScmHashTable
{
    DWORD               UNUSED;
    SScmHashEntry     **_apsheHashTable;
    DWORD               _ndwHashTableSize;
    DWORD               _ndwCount;
};




struct SScmRot
{
    SMutexSem           _mxs;
    DWORD               _dwIdCntr;
    SScmRotHintTable    _rht;
    SScmHashTable       _sht;
};




struct SRotAcctEntry
{
    DWORD               UNUSED;
    WCHAR              *unicodestringSID;
    SScmRot            *pscmrot;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dtreatas.h ===
struct STreatEntry
{
    CLSID               _clsid;
    CLSID		_treatAsClsid;
};



struct STreatList
{
    SArrayFValue    _array;
    DWORD           UNUSED[7];
    DWORD           _centries;
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dstdid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dstdid.cxx
//
//  Contents:   Ole NTSD extension routines to display CStdIdentity table
//
//  Functions:  stdidHelp
//              displayStdid
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dipid.h"
#include "dchannel.h"
#include "dstdid.h"


void FormatCLSID(REFGUID rguid, LPSTR lpsz);
ULONG ScanAddr(char *lpsz);




//+-------------------------------------------------------------------------
//
//  Function:   stdidHelp
//
//  Synopsis:   Display a menu for the command 'id'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void stdidHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("\nid       - Display entire CStdIdentity table:\n");
    Printf("addr  oid tid pUnkControl\n");
    Printf("...\n\n");
    Printf("\nid <stdidAdr> - Display CStdIdentity entry:\n");
    Printf("oid mrshlFlags 1stIPID chnlBfr nestedCalls mrshlTime pUnkOuter [pIEC] strongRefs\n");
    Printf("...\n\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayStdid
//
//  Synopsis:   Display the CStdIdentify table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayStdid(HANDLE hProcess,
                  PNTSD_EXTENSION_APIS lpExtensionApis,
                  ULONG p)
{
    SIDArray          stdidtbl;
    int               nEnt;
    IDENTRY          *pStdEntries;
    IDENTRY           stdEntry;
    SStdIdentity      stdid;
    char              szOID[CLSIDSTR_MAX];
    SRpcChannelBuffer chanBfr;
    
    // Read the standard identity table
    ReadMem(&stdidtbl, p, sizeof(SIDArray));

    // Do over entries in this table
    for (nEnt = 0, pStdEntries = (IDENTRY *) stdidtbl.m_afv.m_pData;
         nEnt < stdidtbl.m_afv.m_nSize;
         nEnt++, pStdEntries++)
    {
        // Read the next entry
        ReadMem(&stdEntry, pStdEntries, sizeof(IDENTRY));

        // CStdIdentity address
        Printf("%x  ", stdEntry.m_pStdID);

        // Display the object identifier
        FormatCLSID(stdEntry.m_oid, szOID);
        Printf("%s ", szOID);

        // The thread ID
        Printf("%3x ", stdEntry.m_tid);

        // pUnkControl
        Printf("%x\n", stdEntry.m_pUnkControl);
    }

    Printf("\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayStdidEntry
//
//  Synopsis:   Display an entry in the CStdIdentify table
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayStdidEntry(HANDLE hProcess,
                  PNTSD_EXTENSION_APIS lpExtensionApis,
                  ULONG p,
                  char *arg)
{
    ULONG             pAdr;
    SStdIdentity      stdid;
    char              szOID[CLSIDSTR_MAX];


    // Check for help
    if (arg[0] == '?')
    {
        Printf("oid mrshlFlags 1stIPID chnlBfr nestedCalls mrshlTime pUnkOuter [pIEC] strongRefs\n");
        return;
    }

    // Read the standard identity entry
    pAdr = ScanAddr(arg);
    ReadMem(&stdid, pAdr, sizeof(SStdIdentity));

    // Display the object identifier
    FormatCLSID(stdid.m_oid, szOID);
    Printf("%s ", szOID);

    // Marshal flags
    Printf("%08x ", stdid._dwFlags);

    // First IPID       
    Printf("%d.%d ", stdid._iFirstIPID >> 16, stdid._iFirstIPID & 0xffff);

    // Address of CRpcChannelBuffer
    Printf("%x ", stdid._pChnl);

    // Count of nested calls
    Printf("%d ", stdid._cNestedCalls);

    // Marshal time
    Printf("%d ", stdid._dwMarshalTime);

    // Address of pUnkOuter
    Printf("%x ", stdid.m_pUnkOuter);

    // Address of IExternalConnection (if present)
    if (stdid.m_pIEC)
    {
        Printf("%x ", stdid.m_pIEC);
    }

    // Count of strong references
    Printf("%d\n", stdid.m_cStrongRefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dtreatas.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dtreatas.cxx
//
//  Contents:   Ole NTSD extension routines to display a dll/class cache
//
//  Functions:  displayTreatAsCache
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"
#include "dtreatas.h"


extern BOOL fInScm;


void FormatCLSID(REFGUID rguid, LPSTR lpsz);
BOOL IsEqualCLSID(CLSID *pClsid1, CLSID *pClsid2);




//+-------------------------------------------------------------------------
//
//  Function:   treatAsCacheHelp
//
//  Synopsis:   Display a menu for the command 'ds'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void treatAsCacheHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("ta         - Display entire TreatAs class cache:\n");
    Printf("ta clsid   - Display Treat As class for clsid (if any)\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayTreatAsCache
//
//  Synopsis:   Formats and writes all or part of the TreatAs class cache
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//              [REFCLSID]        -       If not CLSID_NULL only for this clsid
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayTreatAsCache(HANDLE hProcess,
                         PNTSD_EXTENSION_APIS lpExtensionApis,
                         CLSID *clsid)
{
    ULONG          pAdr;
    BOOL           fRetail;
    ULONG          gptrtlstTreatClasses;
    ULONG          pTreatAs;
    STreatList     sTreatList;
    STreatEntry    *pTreatEntry;
    BOOL           fInit = TRUE;
    char           szClsid[CLSIDSTR_MAX];

    // Determine if this is checked or retail ole
    if (fInScm)
    {
        pAdr = GetExpression("scm!_CairoleInfoLevel");
    }
    else
    {
        pAdr = GetExpression("ole32!_CairoleInfoLevel");
    }
    fRetail = pAdr == NULL ? TRUE : FALSE;

    // Read the pointer to the TreatAs class cache
    gptrtlstTreatClasses = GetExpression("ole32!gptrtlstTreatClasses");
    ReadMem(&pTreatAs, gptrtlstTreatClasses, sizeof(ULONG));
    if (pTreatAs == NULL)
    {
        return;
    }

    // Read the TreatAs cache header
    ReadMem(&sTreatList, pTreatAs, sizeof(STreatList));

    Printf("                clsid                         is treated as clsid\n");
    Printf("-------------------------------------- --------------------------------------\n");

    if (sTreatList._centries > 0)
    {
        // Read the array of entries
        pTreatEntry = (STreatEntry *) OleAlloc(sTreatList._centries *
                                               sizeof(STreatEntry));
        ReadMem(pTreatEntry, sTreatList._array.m_pData,
                sTreatList._centries * sizeof(STreatEntry));

        for (DWORD i = 0; i < sTreatList._centries; i++)
        {
            // Display the clsid and the TreatAs clsid
            if (clsid == NULL)
            {
                FormatCLSID(pTreatEntry[i]._clsid, szClsid);
                Printf("%s ", szClsid);
                FormatCLSID(pTreatEntry[i]._treatAsClsid, szClsid);
                Printf("%s\n", szClsid);
            }

            // We are looking for a particular clsid
            else if (IsEqualCLSID(clsid, &pTreatEntry[i]._clsid))
            {
                FormatCLSID(pTreatEntry[i]._clsid, szClsid);
                Printf("%s ", szClsid);
                FormatCLSID(pTreatEntry[i]._treatAsClsid, szClsid);
                Printf("%s\n", szClsid);
                return;
            }
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dstdid.h ===
typedef enum tagSTDID_FLAGS
{
    STDID_SERVER	= 0,	    // on server side
    STDID_CLIENT	= 1,	    // on client side (non-local in RH terms)
    STDID_STDMARSHAL	= 2,	    // was created with PSTDMARSHAL
    STDID_HASEC	=         4,        // server supports IEC for connections
} STDID_FLAGS;





struct SIDArray
{
    SArrayFValue m_afv;
};





struct IDENTRY
{
    OID           m_oid;
    DWORD         m_tid;
    IUnknown     *m_pUnkControl;
    IStdIdentity *m_pStdID;
};


// Forward reference
struct SRpcChannelBuffer;


struct SStdIdentity
{
    void                *vtbl1;
    void                *vtbl2;
    DWORD	         _dwFlags; 
    LONG	         _iFirstIPID;
    SStdIdentity        *_pStdId;	
    SRpcChannelBuffer   *_pChnl;	
    CLSID	         _clsidHandler;	
    LONG	         _cNestedCalls;	
    DWORD                _dwMarshalTime;
    void                *vtbl3;
    DWORD                m_refs;
    DWORD                m_flags;
    IUnknown            *m_pUnkOuter;
    IUnknown            *m_pUnkControl;
    OID                  m_oid;
    IExternalConnection *m_pIEC;
    ULONG	         m_cStrongRefs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dshrdmem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dshrdmem.h
//
//  Contents:   Contains structure definitons for the significant file
//              extensions table classes which the ntsd extensions need
//              to access.  These ole classes cannot be accessed more
//              cleanly because typically the members of interest are private.
//
//              WARNING.  IF THE REFERENCED OLE CLASSES CHANGE, THEN THESE
//              DEFINITIONS MUST CHANGE!
//
//  History:    06-01-95 BruceMa    Created
//
//--------------------------------------------------------------------------





struct DWORDPAIR
{
    DWORD   dw1;		    // IID
    DWORD   dw2;		    // CLSID
};




struct GUIDPAIR
{
    GUID    guid1;		    // IID
    GUID    guid2;		    // CLSID
};




struct GUIDMAP
{
    ULONG	ulSize; 	    // size of table
    ULONG	ulFreeSpace;	    // Free space in table
    ULONG	ulCntShort;	    // number of entries in the short list
    ULONG	ulCntLong;	    // number of entries in the long list
};



struct	SShrdTblHdr
{
    DWORD	dwSeqNum;	// update sequence number
    ULONG	OffsIIDTbl;	// offset of the start of IID table
    ULONG	OffsPatTbl;	// offset to start of file pattern table
    ULONG	OffsExtTbl;	// offset to file extension table
    ULONG	OffsClsTbl;	// offset to start of CLSID table
    ULONG	pad[1];		// pad to 8 byte boundary
};




struct SSharedMemoryBlock
{
    HANDLE _hMem;
    BYTE *_pbBase;
    ULONG _culCommitSize;	    //	current commit size
    ULONG _culInitCommitSize;	    //	initial commit size
    BOOL _fCreated;		    //	mem created vs already existed
    BOOL _fReadWrite;		    //	want read/write access
};




struct SSmMutex
{
    BOOL		_fCreated;
    HANDLE		_hMutex;
};




struct SPSClsidTbl
{
    GUIDMAP   *	_pGuidMap;	// ptr to table header
    DWORDPAIR * _pShortList;	// list of OLE style guids
    GUIDPAIR  *	_pLongList;	// list of non OLE style guids
};




struct STblHdr
{
    ULONG	ulSize; 	//  size of pattern table
    ULONG	cbLargest;	//  largest pattern size
    ULONG	OffsStart;	//  offset to start of entries
    ULONG	OffsEnd;	//  offset to end of entries
};




struct SPatternEntry
{
    CLSID	clsid;		//  index of clsid the pattern maps to
    ULONG	ulEntryLen;	//  length of this entry
    LONG	lFileOffset;	//  offset in file where pattern begins
    ULONG	ulCb;		//  count bytes in pattern
    BYTE	abData[128];	//  start of mask & pattern strings
};




struct SPatternTbl
{
    STblHdr	   *_pTblHdr;	//  ptr to table header struct
    BYTE	   *_pStart;	//  ptr to first entry in the memory block
};




struct SExtTblHdr
{
    ULONG   ulSize;		//  table size
    ULONG   cEntries;		//  count of entries in table
    ULONG   OffsStart;		//  offset to start of entries
    ULONG   OffsEnd;		//  offset to end of entries
};





struct SExtEntry
{
    CLSID	Clsid;		//  clsid the extension maps to
    ULONG	ulEntryLen;	//  length of this entry
    WCHAR	wszExt[1];	//  start of filename extension
};





struct  SFileExtTbl
{
    SExtTblHdr	   *_pTblHdr;	//  ptr to table header structure
    BYTE	   *_pStart;	//  ptr to first entry in the memory block
};




struct SDllShrdTbl
{
    SSharedMemoryBlock	_smb;		// shared memory block
    SSmMutex		_mxs;		// shared mutex
    HANDLE		_hRegEvent;	// shared event handle

    SPSClsidTbl 	_PSClsidTbl;	// proxy stub clsid table
    SPatternTbl 	_PatternTbl;	// file pattern table
    SFileExtTbl 	_FileExtTbl;	// file extension table

    SShrdTblHdr	       *_pShrdTblHdr;	// shared mem copy of table
    DWORD		_dwSeqNum;	// sequence number
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\dvtbl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dvtbl.cxx
//
//  Contents:   Ole NTSD extension routines to dump a vtbl
//
//  Functions:  displayVtbl
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"







//+-------------------------------------------------------------------------
//
//  Function:   vtblHelp
//
//  Synopsis:   Display a menu for the command 'vt'
//
//  Arguments:  -
//
//  Returns:    -
//
//  History:    07-Mar-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void vtblHelp(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("vt obj     - Interpret vtbl for object obj:\n");
}






//+-------------------------------------------------------------------------
//
//  Function:   displayVtbl
//
//  Synopsis:   Given an object interpret its vtbl
//
//  Arguments:  [hProcess]        -       Handle of this process
//              [lpExtensionApis] -       Table of extension functions
//
//  Returns:    -
//
//  History:    01-Jun-95   BruceMa    Created
//
//--------------------------------------------------------------------------
void displayVtbl(HANDLE hProcess,
                 PNTSD_EXTENSION_APIS lpExtensionApis,
                 void *lpObj)
{
    DWORD  lpVtbl = 0xdeaddead;
    DWORD  dwVtblOffset;
    char   achSymbol[256];
    

    // Get the address of the vtbl
    ReadMem(&lpVtbl, lpObj, sizeof(LPVOID));

    // Check for some reasonableness
    if (lpVtbl == 0  ||  lpVtbl == 0xdededede  ||  lpVtbl == 0xedededed  ||
        lpVtbl == 0xdeaddead)
    {
        if (lpVtbl == 0xdeaddead)
        {
            Printf("...vtbl pointer could not be read\n");
        }
        else
        {
            Printf("...vtbl pointer == 0x%x is unreasonable\n", lpVtbl);
        }
        return;
    }

    // vtbl entries should always point at functions. Therefore, we should
    // always have a displacement of zero. To check for the end of the table
    // we will reevaluate the vtbl pointer. If the offset isn't what we
    // expected, then we are done.
    
    DWORD dwIndex;
    for (dwIndex = 0 ; dwIndex < 512 ; dwIndex += 4, lpVtbl += 4)
    {
        DWORD dwVtblEntry;
        
        // Just in case the loop gets away from us
        if (CheckControlC())
        {
            return;
        }
        
        // Read the next vtbl entry
        ReadMem(&dwVtblEntry, lpVtbl, sizeof(dwVtblEntry));

        // If the function is at zero, then must be at end of table
        if (dwVtblEntry == 0)
        {
            return;
        }
        
        // Now, determine the symbol for the entry in the vtbl
        GetSymbol((LPVOID) dwVtblEntry, (UCHAR *) achSymbol, &dwVtblOffset);

        // If it doesn't point to the start of a routine, then it
        // probably isn't part of the vtbl
        if (dwVtblOffset != 0)
        {
            return;
        }
        
        // Print the vtbl entry symbolically
        Printf("   0x%08x  %s\n", dwVtblEntry, achSymbol);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\ole.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ole.h
//
//  Contents:   Implements ntsd extensions to dump ole tables
//
//  Functions:
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------



#include <ntsdexts.h>


////////////////////////////////////////////////////////
const UINT MAX_ARG      = 64;
const UINT MAX_FILESIZE = 128;

////////////////////////////////////////////////////////
typedef char Arg[MAX_ARG];




////////////////////////////////////////////////////////
#define until_(x) while(!(x))

#define DEFINE_EXT(e) void e(HANDLE hProcess,HANDLE hThread,DWORD dwPc,PNTSD_EXTENSION_APIS lpExtensionApis,LPSTR lpArgumentString)

#define Printf         (*(lpExtensionApis->lpOutputRoutine))

#define CheckForScm()  checkForScm(lpExtensionApis)

#define GetExpression  (*(lpExtensionApis->lpGetExpressionRoutine))

#define GetSymbol      (*(lpExtensionApis->lpGetSymbolRoutine))

#define CheckControlC  (*(lpExtensionApis->lpCheckControlCRoutine))

#define ReadMem(a,b,c) readMemory(hProcess, lpExtensionApis, (BYTE *) (a), (BYTE *) (b), (c))

#define WriteMem(a,b,c) writeMemory(hProcess, lpExtensionApis, (BYTE *) (a), (BYTE *) (b), (c))

#define OleAlloc(n) HeapAlloc(GetProcessHeap(),0,(n))

#define OleFree(p)  HeapFree(GetProcessHeap(),0,(p))

#define GetArg(a) getArgument(&lpArgumentString, a)

#define IsDecimal(x) ('0' <= (x)  &&  (x) <= '9')

#define Unicode2Ansi(x, y, z) AreFileApisANSI?WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, y, -1, x, z, NULL, NULL):WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, y, -1, x, z, NULL, NULL);

#define NOTINSCM if(fInScm){NotInScm(lpExtensionApis);return;}
#define NOTINOLE if(!fInScm){NotInOle(lpExtensionApis);return;}

#define dbt(a, b, c) dbTrace(a, (DWORD *) b, (c) / (sizeof(DWORD)), lpExtensionApis)

#define NOTIMPLEMENTED Printf("...Not implemented yet!\n");




////////////////////////////////////////////////////////
void dbTrace(char *sz, DWORD *adr, ULONG amt,
             PNTSD_EXTENSION_APIS lpExtensionApis);
void getArgument(LPSTR lpArgumentString, LPSTR a);
void FormatCLSID(REFGUID rguid, LPWSTR lpsz);
void readMemory(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis,
                BYTE *to, BYTE *from, INT cbSize);
void writeMemory(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis,
                BYTE *to, BYTE *from, INT cbSize);



// Common structures
struct SMutexSem
{
    CRITICAL_SECTION _cs;
};




struct SArrayFValue
{
    BYTE    **m_pData;
    UINT      m_cbValue;
    int       m_nSize;
    int       m_nMaxSize;
    int       m_nGrowBy;
};







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\util.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ole.cxx
//
//  Contents:   Implements ntsd extensions to dump ole tables
//
//  Functions:
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include "ole.h"




//+-------------------------------------------------------------------------
//
//  Function:	readMemory
//
//  Synopsis:	Transfer memory from debuggee virtual space to a local
//              kernel memory
//
//  Arguments:	[lpArgumentString] - command line string
//              [a]                - where to return next argument
//
//  Returns:	-
//
//--------------------------------------------------------------------------
void readMemory(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis,
                BYTE *to, BYTE *from, INT cbSize)
{
    __try
    {
        NtReadVirtualMemory(hProcess, (void *) from, (void *) to,
                            cbSize , NULL);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Printf("...Exception reading %08x-%08x\n", from, from + cbSize - 1);
    }
}





//+-------------------------------------------------------------------------
//
//  Function:	writeMemory
//
//  Synopsis:	Transfer memory from local memoryto debuggee virtual space
//
//  Arguments:	
//
//  Returns:	-
//
//--------------------------------------------------------------------------
void writeMemory(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis,
                 BYTE *to, BYTE *from, INT cbSize)
{
    __try
    {
        NtWriteVirtualMemory(hProcess, (void *) to, (void *) from,
                             cbSize, NULL);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Printf("...Exception writing %08x-%08x\n", to, to + cbSize - 1);
    }
}




//+-------------------------------------------------------------------------
//
//  Function:	getArgument
//
//  Synopsis:	Return next command line argument
//
//  Arguments:	[lpArgumentString] - command line string
//              [a]                - where to return next argument
//
//  Returns:	-
//
//--------------------------------------------------------------------------
void getArgument(LPSTR *lpArgumentString, LPSTR a)
{
    char *s = *lpArgumentString;

    // Skip whitespace
    while (*s  &&  (*s == ' '  ||  *s == '\t'))
    {
        s++;
    }
    while (*s  &&  *s != ' '  &&  *s != '\t')
    {
        *a++ = *s++;
    }
    *a = '\0';
    *lpArgumentString = s;
}





//+-------------------------------------------------------------------------
//
//  Function:	IsEqualGUID
//
//  Synopsis:	Compares two guids for equality
//
//  Arguments:	[pClsid1]	- the first clsid
//		[pClsid2] - the second clsid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//--------------------------------------------------------------------------

BOOL IsEqualCLSID(CLSID *pClsid1, CLSID *pClsid2)
{
    return !memcmp((void *) pClsid1,(void *) pClsid2, sizeof(CLSID));
}





//+-------------------------------------------------------------------------
//
//  Function:	ScanAddr
//
//  Synopsis:	Parse the indput string as a hexadecimal address
//
//  Arguments:	[lpsz]	  - the hex string to convert
//
//  Returns:	TRUE for success
//
//--------------------------------------------------------------------------
ULONG ScanAddr(char *lpsz)
{
    ULONG val = NULL;

    // Peel off any leading "0x"
    if (lpsz[0] == '0'  &&  lpsz[1] == 'x')
    {
        lpsz += 2;
    }

    // Parse as a hex address
    while (*lpsz)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
        {
            val = (val << 4) + *lpsz - '0';
        }
        else if (*lpsz >= 'A' && *lpsz <= 'F')
        {
            val = (val << 4) + *lpsz - 'A' + 10;
        }
        else if (*lpsz >= 'a' && *lpsz <= 'f')
        {
            val = (val << 4) + *lpsz - 'a' + 10;
        }
        else
        {
            return NULL;
        }

        lpsz++;
    }

    return val;
}





//+-------------------------------------------------------------------------
//
//  Function:	HexStringToDword
//
//  Synopsis:	scan lpsz for a number of hex digits (at most 8); update lpsz
//		return value in Value; check for chDelim;
//
//  Arguments:	[lpsz]	  - the hex string to convert
//		[Value]   - the returned value
//		[cDigits] - count of digits
//
//  Returns:	TRUE for success
//
//--------------------------------------------------------------------------
static BOOL HexStringToDword(LPSTR &lpsz, DWORD &Value,
			     int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    if (chDelim != 0)
	return *lpsz++ == chDelim;
    else
	return TRUE;
}






//+-------------------------------------------------------------------------
//
//  Function:	CLSIDFromString
//
//  Synopsis:	Parse above format;  always writes over *pguid.
//
//  Arguments:	[lpsz]	- the guid string to convert
//		[pguid] - guid to return
//
//  Returns:	TRUE if successful
//
//--------------------------------------------------------------------------
BOOL ScanCLSID(LPSTR lpsz, CLSID *pClsid)
{
    DWORD dw;
    if (*lpsz++ != '{')
        return FALSE;

    if (!HexStringToDword(lpsz, pClsid->Data1, sizeof(DWORD)*2, '-'))
        return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pClsid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
        return FALSE;

    pClsid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pClsid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
        return FALSE;

    pClsid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pClsid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pClsid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pClsid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pClsid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
        return FALSE;

    pClsid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, /*(*/ '}'))
        return FALSE;

    pClsid->Data4[7] = (BYTE)dw;

    return TRUE;
}






//+-------------------------------------------------------------------------
//
//  Function:	FormatCLSID
//
//  Synopsis:	converts GUID into {...} form without leading identifier;
//
//  Arguments:	[rguid]	- the guid to convert
//		[lpszy] - buffer to hold the results
//		[cbMax] - sizeof the buffer
//
//  Returns:	amount of data copied to lpsz if successful
//		0 if buffer too small.
//
//--------------------------------------------------------------------------
void FormatCLSID(REFGUID rguid, LPSTR lpsz)
{
    wsprintf(lpsz, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\0",
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);
}






extern BOOL fScmNeedsInit;
extern BOOL fInScm;


//+-------------------------------------------------------------------------
//
//  Function:	CheckForScm
//
//  Synopsis:	Checks whether the debuggee is 'scm'
//
//  Arguments:	-
//
//  Returns:	Sets global boolean fInScm to TRUE if this is the scm;
//              FALSE otherwise
//
//--------------------------------------------------------------------------
void checkForScm(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    ULONG padr = NULL;

    if (fScmNeedsInit)
    {
        fScmNeedsInit = FALSE;
        padr = GetExpression("scm!CPerMachineROT__CPerMachineROT");
        fInScm = padr != NULL ? TRUE : FALSE;
    }
}






//+-------------------------------------------------------------------------
//
//  Function:	NotInScm
//
//  Synopsis:	Prints error message
//
//  Arguments:	-
//
//  Returns:	
//
//--------------------------------------------------------------------------
void NotInScm(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("...not meaningful in the scm\n");
}






//+-------------------------------------------------------------------------
//
//  Function:	NotInOle
//
//  Synopsis:	Prints error message
//
//  Arguments:	-
//
//  Returns:	
//
//--------------------------------------------------------------------------
void NotInOle(PNTSD_EXTENSION_APIS lpExtensionApis)
{
    Printf("...only meaningful in the scm\n");
}






///////////////////////////////////////////////////////////////////
// F O R   D E B U G G I N G


void dbTrace(char *sz, DWORD *adr, ULONG amt,
             PNTSD_EXTENSION_APIS lpExtensionApis)
{
    UINT k;

    Printf("\n%s", sz);
    for (k = 0; k < amt; k++)
    {
        if (k % 8 == 0)
        {
            Printf("\n");
        }
        Printf("%08x ", *adr++);
    }
    Printf("\n");
}









//+--------------------------------------------------------
//
//  Function:  GetRegistryInterfaceName
//
//  Algorithm: Fetch the name from the registry for the specified interface
//
//  History:   21-Jun-95  BruceMa       Created
//
//---------------------------------------------------------
BOOL GetRegistryInterfaceName(REFIID iid, char *szValue, DWORD *pcbValue)
{
    DWORD  dwRESERVED = 0;
    HKEY   hKey;
    char   szIID[CLSIDSTR_MAX];
    char   szInterface[32 + 1 + CLSIDSTR_MAX];
    DWORD  dwValueType;
    HKEY   hClsidKey;
    HKEY   hInproc32Key;

    // Prepare to open the "...Interface\<iid>" key
    FormatCLSID(iid, szIID);
    lstrcpy(szInterface, "Interface\\");
    lstrcat(szInterface, szIID);

    // Open the key for the specified interface
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szInterface, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Read the value as the interface name
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) szValue, pcbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Close registry handle and return success
    CloseHandle(hKey);
    return TRUE;
}









//+--------------------------------------------------------
//
//  Function:  GetRegistryClsidKey
//
//  Algorithm: Fetch the value from the registry for the specified clsid
//             and key
//
//  History:   21-Jun-95  BruceMa       Created
//
//---------------------------------------------------------
BOOL GetRegistryClsidKey(REFCLSID clsid, char *szKey,
                         char *szValue, DWORD *pcbValue)
{
    DWORD  dwRESERVED = 0;
    HKEY   hKey;
    char   szCLSID[CLSIDSTR_MAX];
    char   szClsid[5 + 1 + CLSIDSTR_MAX + 1 + 32];
    DWORD  dwValueType;
    HKEY   hClsidKey;
    HKEY   hInproc32Key;

    // Prepare to open the "...Interface\<clsid>" key
    FormatCLSID(clsid, szCLSID);
    lstrcpy(szClsid, "CLSID\\");
    lstrcat(szClsid, szCLSID);
    lstrcat(szClsid,"\\");
    lstrcat(szClsid, szKey);

    // Open the key for the specified clsid and key
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szClsid, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Read the value for the specified key
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) szValue, pcbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Close registry handle and return success
    CloseHandle(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\actdbg\commands.cxx ===
/*
 *
 * actdbg.c
 *
 *  This file contains ntsd debugger extensions for DCOM Activation
 *
 */

#include "actdbg.hxx"

DWORD   MajorVersion = 0;
DWORD   MinorVersion = 1;

void
help(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   PC,
    PNTSD_EXTENSION_APIS    pExtApis,
    LPSTR                   pArgString
    )
{
    APIPREAMBLE

    (*pfnPrint)( "  RPCSS activation debug extention for ntsd (version %d.%d) :\n\n", MajorVersion, MinorVersion );
    (*pfnPrint)( "  help           Displays this help\n" );
    (*pfnPrint)( "  ap <addr>      Dumps ACTIVATION_PARAMS\n" );
    (*pfnPrint)( "  sd <addr>      Dumps SECURITY_DESCRIPTOR\n" );
    (*pfnPrint)( "  clsid <addr>   Dumps CClsidData\n" );
		(*pfnPrint)( "  process <addr> Dumps CProcess\n" );
		(*pfnPrint)( "  dsa <addr>     Dumps DUALSTRINGARRAY\n");
    (*pfnPrint)( "  surrogates     Dumps info about all registered surrogates (old style servers)\n" );
    (*pfnPrint)( "  servers <gpProcessTable | gpClassTable>  Dumps the list of registered servers\n" );    
    (*pfnPrint)( "  remlist        Dumps the cache of bindings to remote machines\n" );
    (*pfnPrint)( "\n");
}

//
// Dumps the activation parameters struct.
//
// ap  <address of activation params>
//
void
ap(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{
    ACTIVATION_PARAMS   ActParams;

    APIPREAMBLE

    RpcTryExcept

    bStatus = ReadMemory( pExtApis, hProcess, Argv[0], (void *)&ActParams, sizeof(ActParams) );

    if ( bStatus )
        DumpActivationParams( pExtApis, hProcess, &ActParams );

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps a security descriptor.
//
// sd  <address of security descriptor>
//
void
sd(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{
    SECURITY_DESCRIPTOR SD;
    DWORD_PTR           Address;

    APIPREAMBLE

    RpcTryExcept

    Address = (*pExtApis->lpGetExpressionRoutine)( Argv[0] );
    bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)&SD, sizeof(SD) );

    if ( bStatus )
    {
        if ( SD.Control & SE_SELF_RELATIVE ) {

            DWORD OwnerOffset = ((SECURITY_DESCRIPTOR_RELATIVE *)&SD)->Owner;
            DWORD GroupOffset = ((SECURITY_DESCRIPTOR_RELATIVE *)&SD)->Group;
            DWORD SaclOffset = ((SECURITY_DESCRIPTOR_RELATIVE *)&SD)->Sacl;
            DWORD DaclOffset = ((SECURITY_DESCRIPTOR_RELATIVE *)&SD)->Dacl;

            SD.Owner = (PSID)(Address + OwnerOffset);
            SD.Group = (PSID)(Address + GroupOffset);
            SD.Sacl = (PACL)(Address + SaclOffset);
            SD.Dacl = (PACL)(Address + DaclOffset);
        }

        DumpSecurityDescriptor( pExtApis, hProcess, &SD );
    }

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps an CLSID's settings.
//
// clsid <address of CClsidData>
//
void
clsid(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{
    CClsidData *    pClsidData;

    APIPREAMBLE

    RpcTryExcept

    pClsidData = (CClsidData *) Alloc( sizeof(CClsidData) );

    bStatus = ReadMemory( pExtApis, hProcess, Argv[0], (void *)pClsidData, sizeof(CClsidData) );

    if ( bStatus )
        DumpClsid( pExtApis, hProcess, pClsidData );

    Free( pClsidData );

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps info about all registered surrogates (old style servers).
//
// surrogates
//
void
surrogates(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{
    APIPREAMBLE

    RpcTryExcept

    DumpSurrogates( pExtApis, hProcess );

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps info about all registered servers.
//
// servers
//
void
servers(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{

    APIPREAMBLE

    RpcTryExcept

    DumpServers( pExtApis, hProcess, Argv[0] );

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps CProcess identity information.
//
// process
//
void
process(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{
    CProcess *  pProcess;

    APIPREAMBLE

    RpcTryExcept

    pProcess = (CProcess *) Alloc( sizeof(CProcess) );

    bStatus = ReadMemory( pExtApis, hProcess, Argv[0], (void *)pProcess, sizeof(CProcess) );

    if ( bStatus )
        DumpProcess( pExtApis, hProcess, pProcess, Argv[0]);

    Free( pProcess );

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps the list of cached binding handles to remote machines.
//
// remlist
//
void
remlist(
   HANDLE                  hProcess,
   HANDLE                  hThread,
   DWORD                   PC,
   PNTSD_EXTENSION_APIS    pExtApis,
   LPSTR                   pArgString
   )
{
    APIPREAMBLE

    RpcTryExcept

    DumpRemoteList( pExtApis, hProcess );

    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}


//
// Dumps the contents of a DUALSTRINGARRAY structure
//
// dsa
//
void
dsa(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   PC,
    PNTSD_EXTENSION_APIS    pExtApis,
    LPSTR                   pArgString
    )
{
    APIPREAMBLE

    RpcTryExcept
		
		DUALSTRINGARRAY dsaStub;

    bStatus = ReadMemory( pExtApis, hProcess, Argv[0], (void *)&dsaStub, sizeof(DUALSTRINGARRAY));
    if (bStatus)
		{
			// The first read gives us the stub structure; need to calculate the size of the entire
			// marshalled thing, then read in the whole thing
			DWORD dwSize;
			DUALSTRINGARRAY* pdsaReal;

			dwSize = sizeof(unsigned short) * (2 + dsaStub.wNumEntries);
			//(*pfnPrint)("dwSize = %d\n", dwSize);

			pdsaReal = (DUALSTRINGARRAY*)alloca(dwSize);
			bStatus = ReadMemory(pExtApis, hProcess, Argv[0], (void*)pdsaReal, dwSize);
			if (bStatus)
			{
				DumpDUALSTRINGARRAY(pExtApis, hProcess, pdsaReal, "  ");
			}
		}
		
    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}

//
// Dumps the contents of a CBList of CServerOxids
//
// blsoxids
//
void
blsoxids(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   PC,
    PNTSD_EXTENSION_APIS    pExtApis,
    LPSTR                   pArgString
    )
{
    APIPREAMBLE

    RpcTryExcept
		
		CBList* plist = (CBList*)_alloca(sizeof(CBList));

    bStatus = ReadMemory( pExtApis, hProcess, Argv[0], (void *)plist, sizeof(CBList));
		if (bStatus)
			DumpBListSOxids(pExtApis, hProcess, plist);
			
    RpcExcept( TRUE )

    (*pfnPrint)( "Oops, I've faulted and I can't get up!\n" );

    RpcEndExcept
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\dcomss.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dcomss.h

Abstract:

    Common services provided by core the orpcss service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     06-14-95    Bits 'n pieces

--*/

#ifndef __DCOMSS_H
#define __DCOMSS_H

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <winsvc.h>
#include <winsafer.h>

#ifdef __cplusplus
extern "C" {
#endif

#if DBG
#if !defined(DEBUGRPC)
#define DEBUGRPC
#endif
#endif // DBG

// Endpoint related functions
RPC_STATUS InitializeEndpointManager(VOID);
USHORT     GetProtseqId(PWSTR Protseq);
USHORT     GetProtseqIdAnsi(PSTR Protseq);
PWSTR      GetProtseq(USHORT ProtseqId);
PWSTR      GetEndpoint(USHORT ProtseqId);
RPC_STATUS UseProtseqIfNecessary(USHORT id);
RPC_STATUS DelayedUseProtseq(USHORT id);
VOID       CompleteDelayedUseProtseqs();
BOOL       IsLocal(USHORT ProtseqId);
void       RegisterAuthInfoIfNecessary();

// Must be given dedicated a thread after startup.
DWORD      ObjectExporterWorkerThread(PVOID);

// Update service state
VOID UpdateState(DWORD dwNewState);

extern BOOL s_fEnableDCOM; // Set by StartObjectExporter.

DWORD StartEndpointMapper(VOID);
DWORD StartMqManagement(VOID);
DWORD StartObjectExporter(VOID);
DWORD InitializeSCMBeforeListen(VOID);
DWORD InitializeSCM(VOID);
void  InitializeSCMAfterListen(VOID);

// Shared by wrapper\epts.c and olescm\clsdata.cxx.

typedef enum {
    STOPPED = 1,
    START,
    STARTED
    } PROTSEQ_STATE;

typedef struct {
    PROTSEQ_STATE state;
    PWSTR         pwstrProtseq;
    PWSTR         pwstrEndpoint;
    } PROTSEQ_INFO;


#if DBG==1 && defined(WIN32)
#define SCMVDATEHEAP() if(!HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define SCMVDATEHEAP()
#endif  //  DBG==1 && defined(WIN32)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dbgexts\oleexts.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ole.cxx
//
//  Contents:   Implements ntsd extensions to dump ole tables
//
//  Functions:  
//
//
//  History:    06-01-95 BruceMa    Created
//
//
//--------------------------------------------------------------------------


#include <ole2int.h>
#include <windows.h>
#include <ole2.h>
#include "ole.h"
#include "ddllcach.h"
#include "dshrdmem.h"


#define OLE_VERSION     "1.0"


void getArgument(LPSTR *lpArgumentString, LPSTR a);
void checkForScm(PNTSD_EXTENSION_APIS lpExtensionApis);
void NotInScm(PNTSD_EXTENSION_APIS lpExtensionApis);
void NotInOle(PNTSD_EXTENSION_APIS lpExtensionApis);
ULONG ScanAddr(char *lpsz);

void channelHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayChannel(HANDLE hProcess,
                    PNTSD_EXTENSION_APIS lpExtensionApis,
                    ULONG pChannel,
                    char *arg);

void classCacheHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayClassCache(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis);
void displayClassCacheCk(HANDLE hProcess,
                         PNTSD_EXTENSION_APIS lpExtensionApis);

void classInfoHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
BOOL displayClassInfo(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      CLSID *clsid);

void dllCacheHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayDllCache(HANDLE hProcess,
                     PNTSD_EXTENSION_APIS lpExtensionApis,
                     SDllCache *p);


void displayHr(HANDLE hProcess,
               PNTSD_EXTENSION_APIS lpExtensionApis,
               char *arg);

void fileExtHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayFileExtTbl(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      SDllShrdTbl *pShrdTbl,
                      CLSID *pClsid,
                      WCHAR *wszExt);

void filePatHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayFilePatTbl(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis,
                       SDllShrdTbl *pShrdTbl,
                       CLSID *pClsid);

void stdidHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayStdidEntry(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis,
                       ULONG p,
                       char *arg);
void displayStdid(HANDLE hProcess,
                  PNTSD_EXTENSION_APIS lpExtensionApis,
                  ULONG p);

void infoLevelHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayInfoLevel(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      LPSTR lpArgumentString);

void monikerHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
BOOL displayMoniker(HANDLE hProcess,
                    PNTSD_EXTENSION_APIS lpExtensionApis,
                    ULONG pMoniker);

void psClsidHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayPsClsidTbl(HANDLE hProcess,
                       PNTSD_EXTENSION_APIS lpExtensionApis,
                       SDllShrdTbl *pShrdTbl,
                       CLSID *clisd);

void ipidHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayIpid(HANDLE hProcess,
                 PNTSD_EXTENSION_APIS lpExtensionApis);
void displayIpidEntry(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      char *arg);

void oxidHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayOxid(HANDLE hProcess,
                 PNTSD_EXTENSION_APIS lpExtensionApis);
void displayOxidEntry(HANDLE hProcess,
                      PNTSD_EXTENSION_APIS lpExtensionApis,
                      char *arg);

void displayCliRot(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis);
void displayScmRot(HANDLE hProcess, PNTSD_EXTENSION_APIS lpExtensionApis);
void cliRotHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void scmRotHelp(PNTSD_EXTENSION_APIS lpExtensionApis);

void vtblHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayVtbl(HANDLE hProcess,
                 PNTSD_EXTENSION_APIS lpExtensionApis,
                 void *lpObj);

void treatAsCacheHelp(PNTSD_EXTENSION_APIS lpExtensionApis);
void displayTreatAsCache(HANDLE hProcess,
                         PNTSD_EXTENSION_APIS lpExtensionApis,
                         CLSID *clsid);



void determineIfScm(void);
BOOL ScanCLSID(LPSTR lpsz, LPGUID pguid);
void FormatCLSID(REFGUID rguid, LPSTR lpsz);


BOOL fScmNeedsInit = TRUE;
BOOL fInScm        = FALSE;






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.help
//
//  Synopsis:   Display a help menu of all the supported extensions
//              in this dll
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(help)
{
    Arg arg;

    // Check whether debuggee is the scm
    CheckForScm();

    // Help menu for an OLE client or server
    if (!fInScm)
    {
        // Check for any argument
        GetArg(arg);

        // CRpcChannelBuffer help
        if (lstrcmpA(arg, "ch") == 0)
        {
            channelHelp(lpExtensionApis);
        }

        // Class information help
        else if (lstrcmpA(arg, "ci") == 0)
        {
            classInfoHelp(lpExtensionApis);
        }
        
        // DllCache help
        else if (lstrcmpA(arg, "ds") == 0  ||  lstrcmpA(arg, "dh") == 0)
        {
            dllCacheHelp(lpExtensionApis);
        }

        // File extension cache help
        else if (lstrcmpA(arg, "fe") == 0)
        {
            fileExtHelp(lpExtensionApis);
        }

        // File type patterns cache help
        else if (lstrcmpA(arg, "ft") == 0)
        {
            filePatHelp(lpExtensionApis);
        }

        // Standard identity table
        else if (lstrcmpA(arg, "id") == 0)
        {
            stdidHelp(lpExtensionApis);
        }

        // Debug info levels
        else if (lstrcmpA(arg, "in") == 0)
        {
            infoLevelHelp(lpExtensionApis);
        }

        // IPID table
        else if (lstrcmpA(arg, "ip") == 0)
        {
            ipidHelp(lpExtensionApis);
        }

        // A moniker
        else if (lstrcmpA(arg, "mk") == 0)
        {
            monikerHelp(lpExtensionApis);
        }

        // OXID table
        else if (lstrcmpA(arg, "ox") == 0)
        {
            oxidHelp(lpExtensionApis);
        }

        // IID to class mapping
        else if (lstrcmpA(arg, "ps") == 0)
        {
            psClsidHelp(lpExtensionApis);
        }
        
        // ROT help
        else if (lstrcmpA(arg, "rt") == 0)
        {
            cliRotHelp(lpExtensionApis);
        }
        
        // TreatAs help
        else if (lstrcmpA(arg, "ta") == 0)
        {
            treatAsCacheHelp(lpExtensionApis);
        }
        
        // Vtbl help
        else if (lstrcmpA(arg, "vt") == 0)
        {
            vtblHelp(lpExtensionApis);
        }
        
        // Print the full help menu
        else
        {
            Printf("Ole32 NTSD extensions - Version %s\n\n", OLE_VERSION);
            
            Printf("ch addr    - Decode addr as an RPC channel\n");
            Printf("ci [clsid] - Display registry class information\n");
            Printf("ck         - Is this a checked or retail version of ole32?\n");
            Printf("dh         - Display Inproc Handler dll/class cache\n");
            Printf("ds         - Display Inproc Server dll/class cache\n");
            Printf("ep         - Display current RPC endpoints\n");
            Printf("er err     - Display the message for error number err \n");
            Printf("fe [e|c]   - Display file extensions cache\n");
            Printf("ft [clsid] - Display file type pattern(s)\n");
            Printf("help [cmd] - Display this menu or specific help\n");
            Printf("id         - Display CStdIdentity table\n");
            Printf("in         - Set/reset debug info level\n");
            Printf("ip         - Display IPID table information\n");
            Printf("mk addr    - Decode addr as a moniker\n");
            Printf("ox         - Display OXID table information\n");
            Printf("pg addr    - Display addr as a guid\n");
            Printf("pl         - Display platform information\n");
            Printf("ps         - Display proxy/stub clsid cache\n");
            Printf("rh addr    - Decode addr as a remote handler\n");
            Printf("rt         - Display Running Object Table\n");
            Printf("ta [clsid] - Display TreatAs cache\n");
            Printf("vt obj     - Interpret vtbl for object obj\n");
        }
    }


    // Help menu for the scm
    else
    {
        // Check for any argument
        GetArg(arg);

        if (lstrcmp(arg, "rt") == 0)
        {
            scmRotHelp(lpExtensionApis);
        }

        if (lstrcmp(arg, "cc") == 0)
        {
            classCacheHelp(lpExtensionApis);
        }

        // Print the full help menu
        else
        {
            Printf("Ole32 NTSD extensions - Version %s\n\n", OLE_VERSION);
            
            Printf("cc         - Display class cache info\n");
            Printf("ck         - Is this a checked or retail version of scm?\n");
            Printf("ep         - Display current RPC endpoints\n");
            Printf("er err     - Display the message for error number err \n");
            Printf("help [cmd] - Display this menu or specific help\n");
            Printf("in         - Set/reset debug info level\n");
            Printf("mk addr    - Decode addr as a moniker\n");
            Printf("pg addr    - Display addr as a guid\n");
            Printf("rh         - Display active remote handlers\n");
            Printf("rt         - Display Running Object Table\n");
            Printf("ts         - Display thread information\n");
            Printf("vt obj     - Interpret vtbl for object obj\n");
        }
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.cc
//
//  Synopsis:   Display the scm class cache
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(cc)
{
    ULONG padr;
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINOLE

    // Determine if thisis checked or retail scm
   padr = GetExpression("scm!_CairoleInfoLevel");

    // Display the scm's class cache
    if (padr == NULL)
    {
        displayClassCache(hProcess, lpExtensionApis);
    }
    else
    {
        displayClassCacheCk(hProcess, lpExtensionApis);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ch
//
//  Synopsis:   Display a channel controller
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ch)
{
    Arg   arg;
    ULONG addr;

    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

   // Fetch the argument
   GetArg(arg);
   if (!arg[0])
   {
       Printf("...use !ole.ch <address CRpcChannelBuffer>\n");
       return;
   }

    // Parse it as a hexadecimal address
    if (arg[0] != '?')
    {
        addr = ScanAddr(arg);
        if (addr == NULL)
        {
            Printf("...%s is not a valid address\n", arg);
            return;
        }
    }

    // DOLATERIFEVER: Check that this is indeed an CRpcChannelBuffer
    // Display the parsed address as a CRpcChannelBuffer
    displayChannel(hProcess, lpExtensionApis, addr, arg);
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ci
//
//  Synopsis:   Display registry class information
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ci)
{
    Arg   arg;
    CLSID clsid;

    // Check whether debuggee is the scm
    CheckForScm();

    // Fetch the argument
    GetArg(arg);

    // Parse it as a clsid
    if (arg[0])
    {
        if (!ScanCLSID(arg, &clsid))
        {
            Printf("...%s is not a valid clsid\n", arg);
            return;
        }
    }

    // Display all or particular registry class information
    if (arg[0])
    {
        displayClassInfo(hProcess, lpExtensionApis, &clsid);
    }
    else
    {
        displayClassInfo(hProcess, lpExtensionApis, NULL);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ck
//
//  Synopsis:   Is this the checked or retail version of OLE?
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ck)
{
    ULONG padr;

    // Check whether debuggee is the scm
    CheckForScm();

    if (fInScm)
    {
        padr = GetExpression("scm!_CairoleInfoLevel");
    }
    else
    {
        padr = GetExpression("ole32!_CairoleInfoLevel");
    }
    if (padr == NULL)
    {
        Printf("Retail\n");
    }
    else
    {
        Printf("Checked\n");
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.dh
//
//  Synopsis:   Display the dll/class cache for inproc handlers
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(dh)
{
    SDllCache dllCache;
    ULONG     padr;

    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Fetch the dll/class cache object
    padr = GetExpression("ole32!gdllcacheHandler");
    ReadMem((void *) &dllCache, padr, sizeof(SDllCache));
    Printf("Dll/class cache for in-process handlers\n\n");
    displayDllCache(hProcess, lpExtensionApis, &dllCache);
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ds
//
//  Synopsis:   Display the dll/class cache for inproc servers
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ds)
{
    SDllCache dllCache;
    ULONG     padr;

    // Check whether debuggee is the scm
    CheckForScm();

    padr = GetExpression("ole32!gdllcacheInprocSrv");
    ReadMem(&dllCache, padr, sizeof(SDllCache));
    Printf("Dll/class cache for in-process servers\n\n");
    displayDllCache(hProcess, lpExtensionApis, &dllCache);
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.er
//
//  Synopsis:   Display a Win32 or OLE error message
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(er)
{
    Arg arg;

    // Check whether debuggee is the scm
    CheckForScm();

    GetArg(arg);
    displayHr(hProcess, lpExtensionApis, arg);
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.fe
//
//  Synopsis:   Display file extension information
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(fe)
{
    Arg          arg;
    ULONG        pAdr;
    SDllShrdTbl *pShrdTbl;
    CLSID        clsid;
    WCHAR        wszExt[16];
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Check for any argument
    GetArg(arg);
    if (arg[0])
    {
        if (arg[0] == '{')
        {
            if(!ScanCLSID(arg, &clsid))
            {
                Printf("...%s is not a valid CLSID\n", arg);
                return;
            }
        }
        else if (arg[0] == '.')
        {
            if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, arg, -1, wszExt,
                                     16 * sizeof(WCHAR)))
            {
                Printf("..%ws\n", wszExt);
                Printf("...invalid extension %s\n", arg);
                return;
            }
        }
        else
        {
            Printf("...can't understand argument\n");
        }
    }

    // Fetch the address of the shared memory table
    pAdr = GetExpression("ole32!g_pShrdTbl");
    ReadMem(&pShrdTbl, pAdr, sizeof(ULONG));
    if (arg[0])
    {
        if (arg[0] == '{')
        {
            displayFileExtTbl(hProcess, lpExtensionApis, pShrdTbl, &clsid,
                              NULL);
        }
        else
        {
            displayFileExtTbl(hProcess, lpExtensionApis, pShrdTbl, NULL,
                              wszExt);
        }            
    }
    else
    {
        displayFileExtTbl(hProcess, lpExtensionApis, pShrdTbl, NULL, NULL);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ft
//
//  Synopsis:   Display file type patterns
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ft)
{
    Arg          arg;
    ULONG        pAdr;
    SDllShrdTbl *pShrdTbl;
    CLSID        clsid;
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Check for an argument
    GetArg(arg);
    if (arg[0])
    {
        if (arg[0] == '{')
        {
            if(!ScanCLSID(arg, &clsid))
            {
                Printf("...%s is not a valid CLSID\n", arg);
                return;
            }
        }
        else
        {
            Printf("...%s is not a valid CLSID\n", arg);
            return;
        }
    }

    // Fetch the address of the shared memory table
    pAdr = GetExpression("ole32!g_pShrdTbl");
    ReadMem(&pShrdTbl, pAdr, sizeof(ULONG));
    if (arg[0] == '{')
    {
        displayFilePatTbl(hProcess, lpExtensionApis, pShrdTbl, &clsid);
    }
    else
    {
        displayFilePatTbl(hProcess, lpExtensionApis, pShrdTbl, NULL);
    }            
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.id
//
//  Synopsis:   Display the CStdIdentity taable
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(id)
{
    ULONG pAdr;
    Arg   arg;
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Fetch the address of the standard identity table
    pAdr = GetExpression("ole32!sg_idtable");

    // Check for any argument
    GetArg(arg);

    // Display all or one entry
    if (arg[0])
    {
        displayStdidEntry(hProcess, lpExtensionApis, pAdr, arg);
    }
    else
    {
        displayStdid(hProcess, lpExtensionApis, pAdr);
    }        
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.in
//
//  Synopsis:   Display/change debug info levels
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(in)
{
    // Check whether debuggee is the scm
    CheckForScm();

    // Set/display an info level
    displayInfoLevel(hProcess, lpExtensionApis, lpArgumentString);
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ip
//
//  Synopsis:   Display IPID table
//
//  History:    11-Aug-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ip)
{
    Arg arg;
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Check for an argument
    GetArg(arg);

    // The whole table or a single entry
    if (arg[0])
    {
        displayIpidEntry(hProcess, lpExtensionApis, arg);
    }
    else
    {
        displayIpid(hProcess, lpExtensionApis);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.mk
//
//  Synopsis:   Interpret a moniker object
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(mk)
{
    Arg   arg;
    ULONG pAdr;
    
    // Check whether debuggee is the scm
    CheckForScm();

    // Scan the argument
    GetArg(arg);
    if (!arg[0])
    {
        Printf("...use !ole.mk <moniker address>\n");
        return;
    }
    pAdr = ScanAddr(arg);

    // Interpret this address as a moniker
    if (!displayMoniker(hProcess, lpExtensionApis, pAdr))
    {
        Printf("...%08x isn't a system moniker\n", pAdr);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ox
//
//  Synopsis:   Display OXID table
//
//  History:    11-Aug-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ox)
{
    Arg arg;
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Check for an argument
    GetArg(arg);

    // The whole table or a single entry
    if (arg[0])
    {
        displayOxidEntry(hProcess, lpExtensionApis, arg);
    }
    else
    {
        displayOxid(hProcess, lpExtensionApis);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.pg
//
//  Synopsis:   Pretty print a guid
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(pg)
{
    Arg   arg;
    ULONG addr;
    GUID  guid;
    char  szGuid[CLSIDSTR_MAX];
    
    // Fetch the argument
    GetArg(arg);
    if (!arg[0])
    {
        Printf("...requires an addr argument\n");
        return;
    }
    addr = ScanAddr(arg);

    // Fetch the guid
    ReadMem(&guid, addr, sizeof(GUID));

    // Format and print the guid
    FormatCLSID((GUID &) guid, szGuid);
    Printf("%s\n", szGuid);
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.pl
//
//  Synopsis:   Display platform information
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(pl)
{
    OSVERSIONINFO osInfo;

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osInfo))
    {
        Printf("Cairo %d.%d Build %d\n",
               osInfo.dwMajorVersion,
               osInfo.dwMinorVersion,
               osInfo.dwBuildNumber);
    }
    else
    {
        Printf("...Unable to get version/platform info\n");
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ps
//
//  Synopsis:   Display CLSID of proxy/stub handler dll for given IID
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ps)
{
    Arg          arg;
    ULONG        pAdr;
    SDllShrdTbl *pShrdTbl;
    IID          iid;
    WCHAR        wszExt[16];
    
    // Check whether debuggee is the scm
    CheckForScm();

    NOTINSCM

    // Check for any argument
    GetArg(arg);
    if (arg[0])
    {
        if(!ScanCLSID(arg, &iid))
        {
            Printf("...%s is not a valid CLSID\n", arg);
            return;
        }
    }

    // Fetch the address of the shared memory table
    pAdr = GetExpression("ole32!g_pShrdTbl");
    ReadMem(&pShrdTbl, pAdr, sizeof(ULONG));
    if (arg[0])
    {
        displayPsClsidTbl(hProcess, lpExtensionApis, pShrdTbl, &iid);
    }
    else
    {
        displayPsClsidTbl(hProcess, lpExtensionApis, pShrdTbl, NULL);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.rt
//
//  Synopsis:   Display the ROT
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(rt)
{
    // Check whether debuggee is the scm
    CheckForScm();
    
    if (fInScm)
    {
        displayScmRot(hProcess, lpExtensionApis);
    }
    else
    {
        displayCliRot(hProcess, lpExtensionApis);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ta
//
//  Synopsis:   Display TreatAs cache
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ta)
{
    Arg   arg;
    CLSID clsid;
    
    // Check whether debuggee is the scm
    CheckForScm();

    // Check whether a clsid was supplied
    GetArg(arg);
    if (arg[0])
    {
        if (!ScanCLSID(arg, &clsid))
        {
            Printf("..%s is not a valid CLSID\n", arg);
            return;
        }
        displayTreatAsCache(hProcess, lpExtensionApis, &clsid);
    }

    // Display the entire TreatAs class cache
    else
    {
        displayTreatAsCache(hProcess, lpExtensionApis, NULL);
    }
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.ts
//
//  Synopsis:   Display thread information
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(ts)
{
    // Check whether debuggee is the scm
    CheckForScm();

    Printf("...NOT IMPLEMENTED YET\n");
}






//+-------------------------------------------------------------------------
//
//  Extension:  !ole.vt
//
//  Synopsis:   Display a vtbl
//
//  History:    01-Jun-95 BruceMa    Created
//
//--------------------------------------------------------------------------
DEFINE_EXT(vt)
{
    Arg   arg;
    DWORD dwObj = NULL;
    char *s;

    // Check whether debuggee is the scm
    CheckForScm();

    // Get the object
    GetArg(arg);
    for (s = arg; *s; s++)
    {
        dwObj = 16 * dwObj + *s - '0';
        if ('A' <= *s  &&  *s <= 'F')
        {
            dwObj -= 7;
        }
        if ('a' <= *s  &&  *s <= 'f')
        {
            dwObj -= 39;
        }
    }

    // Display the vtbl
    if (dwObj != NULL)
    {
        displayVtbl(hProcess, lpExtensionApis, (LPVOID) dwObj);
    }
    else
    {
        Printf("...vtbl address of NULL is not meaningful\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\actdbg\dump.cxx ===
/*
 *
 * dump.cxx
 *
 *  Routines for dumping data structures.
 *
 */

#include "actdbg.hxx"

//
//  Dumps a CBList containing CServerOxids 
//
//  
void DumpBListSOxids(PNTSD_EXTENSION_APIS pExtApis,
										 HANDLE hProcess,
										 CBList* pblistoxids)
{
	BOOL bStatus;
	DWORD i;
  PNTSD_OUTPUT_ROUTINE    pfnPrint;
  pfnPrint = pExtApis->lpOutputRoutine;

	CServerOxid** poxids = (CServerOxid**)alloca(pblistoxids->_ulmaxData * sizeof(CServerOxid*));
	
	bStatus = ReadMemory(pExtApis, hProcess, (DWORD_PTR)pblistoxids->_data, (void*)poxids, pblistoxids->_ulmaxData  * sizeof(CServerOxid*));
	if (!bStatus)
		return;
	
	CServerOxid* psoxid;
	psoxid = (CServerOxid*)alloca(sizeof(CServerOxid));
	
	(*pfnPrint)("\n");
	(*pfnPrint)("  CBList::_ulcElements 0x%x\n", pblistoxids->_ulcElements);
	(*pfnPrint)("  CBList::_ulmaxData 0x%x\n", pblistoxids->_ulmaxData);
	(*pfnPrint)("  CBList::_data 0x%x\n", pblistoxids->_data);
	(*pfnPrint)("\n");
	
	for (i = 0; i < pblistoxids->_ulmaxData; i++)
	{		
		ZeroMemory(psoxid, sizeof(CServerOxid));
		// The valid entries in the list's array are not always in contiguous order.
		if (poxids[i])
		{

			bStatus = ReadMemory(pExtApis, hProcess, (DWORD_PTR)poxids[i], (void*)psoxid, sizeof(CServerOxid));
			if (!bStatus)
			{
				(*pfnPrint)("Failed to read memory for list element #%d\n", i);
				return;
			}
			(*pfnPrint)("    _pProcess 0x%x\n", psoxid->_pProcess);
			(*pfnPrint)("    _info (OXID_INFO)\n");
			(*pfnPrint)("      dwTid = %d\n", psoxid->_info.dwTid);
			(*pfnPrint)("      dwPid = %d\n", psoxid->_info.dwPid);
			(*pfnPrint)("      dwAuthnHint = %d\n", psoxid->_info.dwAuthnHint);
			(*pfnPrint)("      version (COMVERSION) MajorVersion=%d, MinorVersion=%d\n", psoxid->_info.version.MajorVersion, psoxid->_info.version.MinorVersion);
			(*pfnPrint)("      ipidRemUnknown ");
			DumpGuid(pExtApis, psoxid->_info.ipidRemUnknown);
			(*pfnPrint)("\n");
			(*pfnPrint)("      dwFlags 0x%x\n", psoxid->_info.dwFlags);
			(*pfnPrint)("      psa 0x%x", psoxid->_info.psa);
			if (psoxid->_info.psa)
			{
				(*pfnPrint)(" (run \"!rpcssext.dsa 0x%x\" to see contents)\n", psoxid->_info.psa);
			}
			(*pfnPrint)("\n");
			(*pfnPrint)("    _fApartment 0x%x\n", psoxid->_fApartment);
			(*pfnPrint)("    _fRunning 0x%x\n", psoxid->_fRunning);
			(*pfnPrint)("\n");
		}
	}
	(*pfnPrint)("\n");
}

//
//  Dumps the contents of a dualstringarray structure:
//
//  wNumEntries       ->  # of elements in the array
//  wSecurityOffset   ->  points to the beginning of the security bindings within the array
//  aStringArray      ->  the actual bindings, in the following format
//		
//    (SB=StringBinding, SeB=SecurityBinding)
//
//     [SB1]0[SB2]0...[SBn]00[SeB1]0[SeB2]0...[SeBn]00
//
//     The shortest possible array has four entries, as follows:
// 
//     0000
//
void DumpDUALSTRINGARRAY(
												 PNTSD_EXTENSION_APIS pExtApis,
												 HANDLE hProcess,
												 DUALSTRINGARRAY* pdsa,
												 char* pszPrefix) // for easier-to-read formatting
{
	BOOL            bStatus;
	BOOL            bDone;
	DWORD           dwcStringBindings = 0;
	DWORD           dwcSecBindings = 0;
  PNTSD_OUTPUT_ROUTINE    pfnPrint;
  pfnPrint = pExtApis->lpOutputRoutine;
	
	(*pfnPrint)("%swNumEntries 0x%x(%d)\n", pszPrefix, pdsa->wNumEntries, pdsa->wNumEntries);
	(*pfnPrint)("%swSecurityOffset 0x%x\n", pszPrefix, pdsa->wSecurityOffset);
	(*pfnPrint)("%sString bindings:\n", pszPrefix);

	USHORT* pCurrent;
	USHORT* pStart;

	pStart = pCurrent = &(pdsa->aStringArray[0]);

	bDone = FALSE;
	while (!bDone)
	{
		while (*pCurrent != 0)
		{
			pCurrent++;
		}

		if (*(pCurrent+1) == 0)  // double zero, end of string bindings
		{
			bDone = TRUE;
		}
		
		if (pStart != pCurrent)
		{
			dwcStringBindings++;
			STRINGBINDING* psb = (STRINGBINDING*)pStart;
			(*pfnPrint)("%s  wTowerId 0x%x, aNetworkAddr=%S\n", pszPrefix, psb->wTowerId, &(psb->aNetworkAddr));
		}
		pCurrent++;
		pStart = pCurrent;
	}

	if (dwcStringBindings == 0)
	{
		(*pfnPrint)("%s  <no string bindings were present>\n", pszPrefix);
	}

	pCurrent++;
	pStart = pCurrent;

	(*pfnPrint)("%sSecurity bindings:\n", pszPrefix);
	bDone = FALSE;
	if (!bDone)
	{
		while (*pCurrent != 0)
		{
			pCurrent++;
		}

		if (*(pCurrent+1) == 0)  // double zero, end of security bindings
		{
			bDone = TRUE;
		}

		if (pStart != pCurrent)
		{
			dwcSecBindings++;
			SECURITYBINDING* pseb = (SECURITYBINDING*)pStart;
			(*pfnPrint)("%s  wAuthnSvc 0x%x, wAuthzSvc 0x%x, aPrincName=%S\n", 
										 pszPrefix,
				             pseb->wAuthnSvc, 
										 pseb->wAuthzSvc,
										 &(pseb->aPrincName));
		}
		pCurrent++;
		pStart = pCurrent;
	}

	if (dwcSecBindings == 0)
	{
		(*pfnPrint)("%s  <no security bindings were present>\n", pszPrefix);
	}
	(*pfnPrint)("\n");

	return;
}

void
DumpGuid(
    PNTSD_EXTENSION_APIS    pExtApis,
    GUID &                  Guid
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;

    pfnPrint = pExtApis->lpOutputRoutine;

    (*pfnPrint)( "{%8.8x-", Guid.Data1 );
    (*pfnPrint)( "%4.4x-", Guid.Data2 );
    (*pfnPrint)( "%4.4x-", Guid.Data3 );
    (*pfnPrint)( "%2.2x", Guid.Data4[0] );
    (*pfnPrint)( "%2.2x-", Guid.Data4[1] );
    (*pfnPrint)( "%2.2x", Guid.Data4[2] );
    (*pfnPrint)( "%2.2x", Guid.Data4[3] );
    (*pfnPrint)( "%2.2x", Guid.Data4[4] );
    (*pfnPrint)( "%2.2x", Guid.Data4[5] );
    (*pfnPrint)( "%2.2x", Guid.Data4[6] );
    (*pfnPrint)( "%2.2x}", Guid.Data4[7] );
}

void
DumpActivationParams(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    ACTIVATION_PARAMS  *    pActParams
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    WCHAR                   String[256];
    GUID                    Guid;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    pfnPrint( "  hRpc\t\t\t0x%x\n", pActParams->hRpc );
    pfnPrint( "  ProcessSignature\t0x%p\n", pActParams->ProcessSignature );
    pfnPrint( "  pProcess\t\t0x%x\n", pActParams->pProcess );
    pfnPrint( "  pToken\t\t0x%x\n", pActParams->pToken );
    pfnPrint( "  pAuthInfo\t\t0x%x\n", pActParams->pAuthInfo );

    // UnsecureActivation

    pfnPrint( "  MsgType\t\t%d ", pActParams->MsgType );
    switch ( pActParams->MsgType )
    {
    case GETCLASSOBJECT :
        pfnPrint( "(GetClassObject)\n" );
        break;
    case CREATEINSTANCE :
        pfnPrint( "(CreateInstance)\n" );
        break;
    case GETPERSISTENTINSTANCE :
        pfnPrint( "(GetPersistentInstance)\n" );
        break;
    default :
        pfnPrint( "(Invalid MsgType, bad ACTIVATION_PARAMS?)\n" );
        break;
    }

    pfnPrint( "  Clsid\t\t\t0x%x " );
    DumpGuid( pExtApis, pActParams->Clsid );
    pfnPrint( "\n" );

    pfnPrint( "  pwszServer\t\t0x%x", pActParams->pwszServer );
    if ( pActParams->pwszServer )
    {
        bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pActParams->pwszServer, (void *)String, sizeof(String) );
        if ( bStatus )
            pfnPrint( " %S", String );
    }
    pfnPrint( "\n" );

    pfnPrint( "  pwszWinstaDesktop\t0x%x", pActParams->pwszWinstaDesktop );
    if ( pActParams->pwszWinstaDesktop )
    {
        bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pActParams->pwszWinstaDesktop, (void *)String, sizeof(String) );
        if ( bStatus )
            pfnPrint( " %S", String );
    }
    pfnPrint( "\n" );

    pfnPrint( "  EnvBlock\t\t0x%x\n", pActParams->pEnvBlock );
    pfnPrint( "  ClsContext\t\t0x%x\n", pActParams->ClsContext );
    
    pfnPrint( "  dwPID     \t\t0x%x (%d)\n", pActParams->dwPID);
    pfnPrint( "  dwProcReqType\t\t%d ->", pActParams->dwProcessReqType);
    switch(pActParams->dwProcessReqType)
    {
    case PRT_IGNORE:  pfnPrint("PRT_IGNORE\n"); break;
    case PRT_CREATE_NEW:  pfnPrint("PRT_CREATE_NEW\n"); break;
    case PRT_USE_THIS:  pfnPrint("PRT_USE_THIS\n"); break;
    case PRT_USE_THIS_ONLY:  pfnPrint("PRT_USE_THIS_ONLY\n"); break;
    default:
      pfnPrint(" !ERROR! Unknown process request type!\n");
    }

    pfnPrint( "  RemoteActivation\t%s\n", pActParams->RemoteActivation ? "TRUE" : "FALSE" );

    pfnPrint( "  Interfaces\t\t%d\n", pActParams->Interfaces );
    pfnPrint( "  pIIDs\t\t\t0x%x ", pActParams->pIIDs );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pActParams->pIIDs, (void *)&Guid, sizeof(Guid) );
    if ( bStatus )
        DumpGuid( pExtApis, Guid );
    pfnPrint( "\n" );

    pfnPrint( "  pwszPath\t\t0x%x", pActParams->pwszPath );
    if ( pActParams->pwszPath )
    {
        bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pActParams->pwszPath, (void *)String, sizeof(String) );
        if ( bStatus )
            pfnPrint( " %S", String );
    }
    pfnPrint( "\n" );

    pfnPrint( "  pIFDStorage\t\t0x%x\n", pActParams->pIFDStorage );
    pfnPrint( "  pIFDROT\t\t0x%x\n", pActParams->pIFDROT );

    pfnPrint( "  Apartment\t\t0x%x\n", pActParams->Apartment );
    pfnPrint( "  pOxidServer\t\t0x%x\n", pActParams->pOxidServer );
    pfnPrint( "  ppServerORBindings\t\t0x%x\n", pActParams->ppServerORBindings );
    pfnPrint( "  pOxidInfo\t\t0x%x\n", pActParams->pOxidInfo );
    pfnPrint( "  pLocalMidOfRemote\t\t0x%x\n", pActParams->pLocalMidOfRemote );
    pfnPrint( "  ProtseqId\t\t%d\n", pActParams->ProtseqId );

    pfnPrint( "  FoundInROT\t\t%s\n", pActParams->FoundInROT ? "TRUE" : "FALSE" );
    pfnPrint( "  ppIFD\t\t\t0x%x\n", pActParams->ppIFD );
    pfnPrint( "  pResults\t\t0x%x\n", pActParams->pResults );

    pfnPrint( "  fComPlusOnly\t\t%s\n", pActParams->fComplusOnly ? "TRUE" : "FALSE");

    pfnPrint( "  pActPropsIn\t\t0x%x\n", pActParams->pActPropsIn);
    pfnPrint( "  pActPropsOut\t\t0x%x\n", pActParams->pActPropsOut);
    pfnPrint( "  pInstantiationInfo\t\t0x%x\n", pActParams->pInstantiationInfo);
    pfnPrint( "  pInstanceInfo\t\t0x%x\n", pActParams->pInstanceInfo);
    pfnPrint( "  pInScmResolverInfo\t\t0x%x\n", pActParams->pInScmResolverInfo);

    pfnPrint( "  oldActivationCall\t\t%s\n", pActParams->oldActivationCall ? "TRUE" : "FALSE");
    pfnPrint( "  activatedRemote\t\t%s\n", pActParams->activatedRemote ? "TRUE" : "FALSE");
    pfnPrint( "  IsLocalOxid\t\t%s\n", pActParams->IsLocalOxid ? "TRUE" : "FALSE");

    pfnPrint( "\n" );
}

void
DumpSecurityDescriptor(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    SECURITY_DESCRIPTOR *   pSD
    )
{
    const ACCT_DOM_NAME_SIZE = 64;
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    PACL                    pDacl;
    ACL                     AclHeader;
    ACCESS_ALLOWED_ACE *    pAce = NULL;
    WCHAR                   ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD                   cchComputer = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR                   AccountName[ACCT_DOM_NAME_SIZE];
    DWORD                   cchAccount = ACCT_DOM_NAME_SIZE;
    WCHAR                   DomainName[ACCT_DOM_NAME_SIZE];
    DWORD                   cchDomain = ACCT_DOM_NAME_SIZE;
    SID_NAME_USE            SidNameType;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    pDacl = 0;

    if ( ! (pSD->Control & SE_DACL_PRESENT) || (0 == pSD->Dacl) )
    {
        (*pfnPrint)( "Security Descriptor has no discretionary ACL.  Everyone allowed access.\n" );
    }

    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pSD->Dacl, (void *)&AclHeader, sizeof(AclHeader) );
    if ( ! bStatus )
        return;

    pDacl = (PACL) Alloc( AclHeader.AclSize );

    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pSD->Dacl, (void *)pDacl, AclHeader.AclSize );
    if ( ! bStatus )
    {
        (*pfnPr