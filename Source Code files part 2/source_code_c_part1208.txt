d not be stopping its activity.
	Too bad about COM calls in progress - the running clients will get an error.

Called by:

	CVsServiceModule::Handler

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnSignalShutdown" );

    try
    {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = llVSSVCShutdownTimeout;

        // Trace the fact that the service will be shutdown
		ft.Trace( VSSDBG_COORD, L"VSSVC: Trying to shutdown the service");

        // Set the timer to become signaled immediately.
		if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
        		L"Error on setting the shutdown event 0x%08lx", GetLastError());
		BS_ASSERT(GetLastError() == 0);
		m_bShutdownInProgress = true;
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()) {
		m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		m_status.dwServiceSpecificExitCode = ft.hr;
	}
}


///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//


LONG CVsServiceModule::Lock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Lock" );

    // If we are not shutting down then we are cancelling the "idle timeout" timer.
    if (!m_bShutdownInProgress) {

        // Trace the fact that the idle period is done.
    	ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period is finished");

        // Cancel the timer
        if (!::CancelWaitableTimer(m_hShutdownTimer))
            ft.Warning(VSSDBG_COORD, L"Error cancelling the waitable timer 0x%08lx",
                GetLastError());
    }

    return CComModule::Lock();
}


LONG CVsServiceModule::Unlock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Unlock" );

    // Check if we entered in the idle period.
    LONG lRefCount = CComModule::Unlock();
    if ( lRefCount == 0) {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = llVSSVCIdleTimeout;

        // Trace the fact that the idle period begins
    	ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period begins");

        // Set the timer to become signaled after the proper idle time.
        // We cannot fail at this point (BUG 265455)
		if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE)) 
		    ft.LogGenericWarning( VSSDBG_COORD, L"SetWaitableTimer(...) [0x%08lx]", GetLastError());
		BS_ASSERT(GetLastError() == 0);
		
        return 0;
    }
    return lRefCount;
}



///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//



LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (*p1 != NULL)
    {
        LPCTSTR p = p2;
        while (*p != NULL)
        {
            if (*p1 == *p++)
                return p1+1;
        }
        p1++;
    }
    return NULL;
}


extern "C" int WINAPI _tWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE, /* hPrevInstance */
    IN LPTSTR lpCmdLine,
    IN int /* nShowCmd */
    )
{
    return _Module._WinMain( hInstance, lpCmdLine );
}


int WINAPI CVsServiceModule::_WinMain(
    IN HINSTANCE hInstance,
    IN LPTSTR /* lpCmdLine */
    )

/*++

Routine Description:

    Called in the main execution path.
	Used to:
		- start the service, if no parameters on the command line.
		- register the service, if the "/Register" or "-Register" command line parameter is present

Called by:

    _WinMain()

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::_WinMain");

    try
    {
		// Get the command line
        LPTSTR lpCmdLine = GetCommandLine();
        ft.Trace( VSSDBG_COORD, L"Trace: VSS command-line: '%s'", T2W(lpCmdLine) );

        // Set the reporting mode for ATLASSERT and BS_ASSERT macros.
//        VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

		// Initialize the internal variables
        Init(ObjectMap, hInstance);
        m_hInstance = hInstance;

		// Parse the command line
        TCHAR szTokens[] = _T("-/");
        LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);

		bool bRegisterTentative = false;
        while (lpszToken != NULL)
        {
			ft.Trace( VSSDBG_COORD, L"Current token = \'%s\'", lpszToken );

            // Register as Server
            if (lstrcmpi(lpszToken, _T("Register"))==0)
			{
				bRegisterTentative = true;
                ft.hr = RegisterServer(TRUE);
				break;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
        }

		// Start the dispatcher function
		if (!bRegisterTentative)
			StartDispatcher();
    }
    VSS_STANDARD_CATCH(ft)

    // When we get here, the service has been stopped
    return m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\event\src\impl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module EventMonImpl.h : Declaration of the CVssEventClassImpl

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/



#ifndef __EventMonIMPL_H_
#define __EventMonIMPL_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CVssEventClassImpl
class ATL_NO_VTABLE CVssEventClassImpl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVssEventClassImpl, &__uuidof(VssEvent)>
{
public:
	CVssEventClassImpl()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTMONIMPL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVssEventClassImpl)
END_COM_MAP()

public:


};

#endif //__EventMonIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\event\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ZooEventClass.rc
//
#define IDS_PROJNAME                    100
#define IDR_EVENTMONIMPL                     101
#define IDR_TYPELIB1                    201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\event\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.h : include file for standard system include files,          
         or project specific include files that are used frequently,    
         but are changed infrequently                                   

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/




#if !defined(AFX_STDAFX_H__036BCDC7_D1E3_11D2_9A34_00C04F72EB9B__INCLUDED_)
#define AFX_STDAFX_H__036BCDC7_D1E3_11D2_9A34_00C04F72EB9B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__036BCDC7_D1E3_11D2_9A34_00C04F72EB9B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\event\src\stdafx.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cpp : source file that includes just the standard includes
        stdafx.pch will be the pre-compiled header
        stdafx.obj will contain the pre-compiled type information

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/



#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\jetwriter\stdafx.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)

#include "vs_assert.hxx"

#include <oleauto.h>
#include <comadmin.h>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\filter\filter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    @doc
    @module filter.cxx | publisher filter for IVssWriter event
    @end

Author:

    Brian Berkowitz  [brianb]  11/09/2000

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      10/09/2000  Created.

--*/

#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "sddl.h"
#include "vs_idl.hxx"
#include "lmerr.h"
#include "lmaccess.h"
#include "lmapibuf.h"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "FILFILTC"
//
////////////////////////////////////////////////////////////////////////


// auto sid class,  destroys sid when going out of scope
class CAutoSid
	{
public:
	CAutoSid() : m_psid(NULL)
		{
		}

	~CAutoSid()
		{
		if (m_psid)
			LocalFree(m_psid);
		}

	// create a sid base on a well known sid type
	void CreateBasicSid(WELL_KNOWN_SID_TYPE type);

	// create a sid from a string
	void CreateFromString(LPCWSTR wsz);

	// return pointer to sid
	SID *GetSid() { return m_psid; }

	void Empty()
		{
		LocalFree(m_psid);
		m_psid = NULL;
		}
private:
	SID *m_psid;

	};

// create a basic well known sid such as LOCAL_SERVICE, LOCAL_SYSTEM,
// or NETWORK_SERVICE.
void CAutoSid::CreateBasicSid(WELL_KNOWN_SID_TYPE type)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateBasicSid");

	BS_ASSERT(m_psid == NULL);

	DWORD cbSid = 0;
	CreateWellKnownSid(type, NULL, NULL, &cbSid);
	DWORD dwErr = GetLastError();
	if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		{
		ft.hr = HRESULT_FROM_WIN32(dwErr);
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
		}

	m_psid = (SID *) LocalAlloc(0, cbSid);
	if (m_psid == NULL)
		ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate SID");

	if (!CreateWellKnownSid(type, NULL, m_psid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
		}
	}

// create a sid based on a STRING sid
void CAutoSid::CreateFromString(LPCWSTR wsz)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateFromString");

	if (!ConvertStringSidToSid (wsz, (PSID *) &m_psid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"ConvertStringSidToSid");
		}
	}



// filter class
class CVssWriterPublisherFilter : public IMultiInterfacePublisherFilter
	{
public:
	CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl);

	STDMETHOD(Initialize)(IMultiInterfaceEventControl *pEc);
	STDMETHOD(PrepareToFire)(REFIID iid, BSTR bstrMethod, IFiringControl *pFiringControl);

	STDMETHOD(QueryInterface)(REFIID riid, void **ppvUnknown);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	static void CreatePublisherFilter
		(
		IMultiInterfaceEventControl *pControl,
		IMultiInterfacePublisherFilter **ppFilter
		);

private:
	// setup well known sids
	void SetupGenericSids();

	// determine if a SID is a member of a local group
	bool IsSidInGroup(SID *psid, LPCWSTR wszGroup);

	// cached pointer to event control
	CComPtr<IMultiInterfaceEventControl> m_pControl;

	// reference count
	LONG m_cRef;

	// well known sids

	// local service
	CAutoSid m_asidLocalService;

	// local system
	CAutoSid m_asidLocalSystem;

	// network service
	CAutoSid m_asidNetworkService;

	// Administrators
	CAutoSid m_asidAdministrators;

	// backup operators
	CAutoSid m_asidBackupOperators;

	// name of administrators group
	WCHAR m_wszAdministrators[MAX_PATH];

	// name of backup operators group
	WCHAR m_wszBackupOperators[MAX_PATH];

	// have well known sids beeen compouted
	bool m_bSidsAssigned;
	};

// constructor
CVssWriterPublisherFilter::CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl) :
	m_cRef(0),
	m_pControl(pControl),
	m_bSidsAssigned(false)
	{
	}

// create a publisher filter and return an interface pointer to it
void CVssWriterPublisherFilter::CreatePublisherFilter
	(
	IMultiInterfaceEventControl *pControl,
	IMultiInterfacePublisherFilter **ppFilter
	)
	{
	CVssWriterPublisherFilter *pFilter = new CVssWriterPublisherFilter(pControl);
	if (pFilter == NULL)
		throw E_OUTOFMEMORY;

	pFilter->QueryInterface(IID_IMultiInterfacePublisherFilter, (void **) ppFilter);
	}

// query interface method
STDMETHODIMP CVssWriterPublisherFilter::QueryInterface(REFIID riid, void **ppvUnk)
	{
	if (riid == IID_IUnknown)
		*ppvUnk = (IUnknown *) this;
	else if (riid == IID_IMultiInterfacePublisherFilter)
		*ppvUnk = (IMultiInterfacePublisherFilter *) (IUnknown *) this;
	else
		return E_NOINTERFACE;

	((IUnknown *) (*ppvUnk))->AddRef();
	return S_OK;
	}

// add ref method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// release method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);

	if (cRef == 0)
		{
		delete this;

		return 0;
		}
	else
		return (ULONG) cRef;
	}



// initialize method (does nothing.  All the work is done in PrepareToFire)
STDMETHODIMP CVssWriterPublisherFilter::Initialize
	(
	IMultiInterfaceEventControl *pec
	)
	{
	UNREFERENCED_PARAMETER(pec);

	return S_OK;
	}

// setup well known sids so that they only are computed once
void CVssWriterPublisherFilter::SetupGenericSids()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssPublisherFilter::SetupGenericSids");

	if (m_bSidsAssigned)
		return;

	m_asidLocalService.Empty();
	m_asidLocalSystem.Empty();
	m_asidNetworkService.Empty();

	m_asidLocalService.CreateBasicSid(WinLocalServiceSid);
	m_asidLocalSystem.CreateBasicSid(WinLocalSystemSid);
	m_asidNetworkService.CreateBasicSid(WinNetworkServiceSid);
	m_asidAdministrators.CreateBasicSid(WinBuiltinAdministratorsSid);
	m_asidBackupOperators.CreateBasicSid(WinBuiltinBackupOperatorsSid);

	DWORD cbName = MAX_PATH;
	WCHAR wszDomain[MAX_PATH];
	DWORD cbDomainName = MAX_PATH;
	SID_NAME_USE snu;

	// lookup name of administrators group
	if (!LookupAccountSid
			(
			NULL,
			m_asidAdministrators.GetSid(),
			m_wszAdministrators,
			&cbName,
			wszDomain,
			&cbDomainName,
			&snu))
        {
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"LookupAccountSid");
		}

	// lookup name of backup operators group
	cbName = MAX_PATH;
	cbDomainName= MAX_PATH;

	if (!LookupAccountSid
			(
			NULL,
			m_asidBackupOperators.GetSid(),
			m_wszBackupOperators,
			&cbName,
			wszDomain,
			&cbDomainName,
			&snu))
        {
		DWORD dwErr = GetLastError();
		// the backup operators group does not exist on the personal
		// SKU.  A NULL name indicates that it doesn't exist
		if (dwErr == ERROR_NONE_MAPPED)
			m_wszBackupOperators[0] = L'\0';
		else
			{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_GEN, L"LookupAccountSid");
			}
		}


	m_bSidsAssigned = true;
	}

// is a sid a member of a local group
bool CVssWriterPublisherFilter::IsSidInGroup(SID *psid, LPCWSTR wszGroup)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::IsSidInGroup");

	NET_API_STATUS status;
	BYTE *buffer;
	DWORD_PTR ResumeHandle = NULL;
	DWORD cEntriesRead, cEntriesTotal;

	// if group name is NULL, then the group does not exist.  It must have
	// no members
	if (wszGroup[0] == L'\0')
		return false;

	// get list of local group members
	status = NetLocalGroupGetMembers
				(
				NULL,
				wszGroup,
				0,
				&buffer,
				MAX_PREFERRED_LENGTH,
				&cEntriesRead,
				&cEntriesTotal,
				&ResumeHandle
				);

    if (status != NERR_Success)
		{
		ft.hr = HRESULT_FROM_WIN32(status);
		ft.CheckForError(VSSDBG_GEN, L"NetGroupGetUsers");
		}

	BS_ASSERT(cEntriesRead == cEntriesTotal);

	bool bFound = false;
	try
		{
		LOCALGROUP_MEMBERS_INFO_0 *rgMembers = (LOCALGROUP_MEMBERS_INFO_0 *) buffer;

		// loop through member list to see if any sids mach the sid of the owner
		// of the subscription
		for(DWORD iEntry = 0; iEntry < cEntriesRead; iEntry++)
			{
			PSID psidMember = rgMembers[iEntry].lgrmi0_sid;
			if (EqualSid(psidMember, psid))
				{
				bFound = true;
				break;
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	// free buffer allocated in NetLocalGroupGetMembers
	NetApiBufferFree(buffer);
	if (ft.HrFailed())
		{
		HRESULT hr = ft.hr;
		throw hr;
		}

	return bFound;
	}


// key method that determines which subscriptions shoud receive the event
STDMETHODIMP CVssWriterPublisherFilter::PrepareToFire
	(
	REFIID iid,
	BSTR bstrMethod,
	IFiringControl *pFiringControl
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::PrepareToFire");

	BS_ASSERT(iid == IID_IVssWriter);
	// validate iid we are being called on
	if (iid != IID_IVssWriter)
		return E_INVALIDARG;

	try
		{
		SetupGenericSids();

		CComPtr<IEventObjectCollection> pCollection;
		int location;

		// get subscriptions
		ft.hr = m_pControl->GetSubscriptions
					(
					IID_IVssWriter,
					bstrMethod,
					NULL,
					&location,
					&pCollection
					);

		ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::GetSubscriptions");

		// create enumerator
		CComPtr<IEnumEventObject> pEnum;
		ft.hr = pCollection->get_NewEnum(&pEnum);
		ft.CheckForError(VSSDBG_GEN, L"IEventObjectCollection::get_NewEnum");

		while(TRUE)
			{
			CComPtr<IEventSubscription> pSubscription;
			DWORD cElt;

			// get next subscription
			ft.hr = pEnum->Next(1, (IUnknown **) &pSubscription, &cElt);
			ft.CheckForError(VSSDBG_GEN, L"IEnumEventObject::Next");
			if (ft.hr == S_FALSE)
				break;

			// get owner of subscription
			CComBSTR bstrSID;
			ft.hr = pSubscription->get_OwnerSID(&bstrSID);
			ft.CheckForError(VSSDBG_GEN, L"IEventSubscription::get_OwnerSID");

			// convert string representation to sid
			CAutoSid asid;
			asid.CreateFromString(bstrSID);
			SID *psid = asid.GetSid();

			// determine if subscription should be fired
			bool bFire = false;

			if (EqualSid(psid, m_asidLocalSystem.GetSid()) ||
				EqualSid(psid, m_asidLocalService.GetSid()) ||
				EqualSid(psid, m_asidNetworkService.GetSid()))

				// fire if owner is LOCALSYSTEM, LOCALSERVICE, or NETWORKSERVICE
				bFire = true;
			else if (IsSidInGroup(psid, m_wszAdministrators) ||
					 IsSidInGroup(psid, m_wszBackupOperators))

                // fire if owner is a member of the Administrators
				// or Backup Operators group
				bFire = true;

			if (bFire)
				pFiringControl->FireSubscription(pSubscription);
			}

		ft.hr = S_OK;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// setup a filter on an event object
void SetupPublisherFilter(IVssWriter *pWriter)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"SetupPublisherFilter");

	CComPtr<IMultiInterfaceEventControl> pControl;

	// get event control interface
	ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
		ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
			ft.hr
			);
        }

	// create filter
	CComPtr<IMultiInterfacePublisherFilter> pFilter;
	CVssWriterPublisherFilter::CreatePublisherFilter(pControl, &pFilter);

	// set filter for event
	ft.hr = pControl->SetMultiInterfacePublisherFilter(pFilter);
	ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");

	// indicate that subscriptions should be fired in parallel
	ft.hr = pControl->put_FireInParallel(TRUE);
	ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::put_FireInParallel");
	}

// clear the publisher filter from an event
void ClearPublisherFilter(IVssWriter *pWriter)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"ClearPublisherFilter");

	try
		{
		CComPtr<IMultiInterfaceEventControl> pControl;

		// get event control interface
		ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
		if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
				ft.hr
				);	
				}
	
		// set filter for event
		ft.hr = pControl->SetMultiInterfacePublisherFilter(NULL);
		ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");
		}
	VSS_STANDARD_CATCH(ft)

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\jetwriter\ijetwriter.cpp ===
/*
**++
**
**  Copyright (c) 2000-2001  Microsoft Corporation
**
**  Module Name:
**
**	wrtrrsm.cpp
**
**
**  Abstract:
**
**	Writer shim module for RSM
**
**
**  Author:
**
**	Brian Berkowitz [brianb]
**
**
**  Revision History:
**
**	X-11	MCJ		Michael C. Johnson		19-Sep-2000
**		215218: Wildcard name of log files returned by OnIdentify()
**		215390: Incorporate multiple '.' fix in MatchFileName from NtBackup
**
**	X-10	MCJ		Michael C. Johnson		19-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-9	MCJ		Michael C. Johnson		21-Aug-2000
**		Added copyright and edit history
**		161899: Don't add a component for a database file in the
**		        exclude list.
**		165873: Remove trailing '\' from metadata file paths
**		165913: Deallocate memory on class destruction
**
**
**--
*/

#include <stdafx.h>

#include <esent.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>


#include "ijetwriter.h"
#include "vs_inc.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "JTWIJTWC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  local functions


#define UMAX(_a, _b)			((_a) > (_b)      ? (_a)    : (_b))
#define	EXECUTEIF(_bSuccess, _fn)	((_bSuccess)      ? (_fn)   : (_bSuccess))
#define	GET_STATUS_FROM_BOOL(_bSucceed)	((_bSucceed)      ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))


typedef struct _ExpandedPathInfo
    {
    LIST_ENTRY	leQueueHead;
    PWCHAR	pwszOriginalFilePath;
    PWCHAR	pwszOriginalFileName;
    PWCHAR	pwszExpandedFilePath;
    PWCHAR	pwszExpandedFileName;
    bool	bRecurseIntoSubdirectories;
    } EXPANDEDPATHINFO, *PEXPANDEDPATHINFO, **PPEXPANDEDPATHINFO;



static void RemoveAnyTrailingSeparator (PCHAR szPath)
    {
    ULONG	ulPathLength = strlen (szPath);

    if ('\\' == szPath [ulPathLength - 1])
	{
	szPath [ulPathLength - 1] = '\0';
	}
    }


static void RemoveAnyTrailingSeparator (PWCHAR wszPath)
    {
    ULONG	ulPathLength = wcslen (wszPath);

    if (L'\\' == wszPath [ulPathLength - 1])
	{
	wszPath [ulPathLength - 1] = UNICODE_NULL;
	}
    }


static bool ConvertName (PCHAR  szSourceName,
			 ULONG  ulTargetBufferLengthInChars,
			 PWCHAR wszTargetBuffer)
    {
    bool bSucceeded = true;


    wszTargetBuffer [0] = '\0';


    /*
    ** Only need to do the conversion for non-zero length
    ** strings. Returning a zero length string for a zero length
    ** argument is an ok thing to do.
    */
    if ('\0' != szSourceName [0])
	{
	bSucceeded = (0 != MultiByteToWideChar (CP_OEMCP,
						0,
						szSourceName,
						-1,
						wszTargetBuffer,
						ulTargetBufferLengthInChars));
	}


    return (bSucceeded);
    } /* ConvertName () */


static bool ConvertNameAndSeparateFilePaths (PCHAR	pszSourcePath,
					     ULONG	ulTargetBufferLength,
					     PWCHAR	pwszTargetPath,
					     PWCHAR&	pwszTargetFileSpec)
    {
    bool	bSucceeded;
    PWCHAR	pwchLastSlash;


    bSucceeded = ConvertName (pszSourcePath, ulTargetBufferLength, pwszTargetPath);

    if (bSucceeded)
	{
	/*
	** Scan backwards from the end of the target path, zap the
	** end-most '\' and point the file spec at the character
	** following where the '\' used to be.
	*/
	pwchLastSlash = wcsrchr (pwszTargetPath, L'\\');

	bSucceeded = (NULL != pwchLastSlash);
	}


    if (bSucceeded)
	{
	pwszTargetFileSpec = pwchLastSlash + 1;

	*pwchLastSlash = UNICODE_NULL;
	}


    return (bSucceeded);
    } /* ConvertNameAndSeparateFilePaths () */



/*
** This routine breaks out the next path and filespec from a list of
** filespecs. The expected format of the input string is
**
**	path\[filespec] [/s]
**
**
** The list can contain an arbitrary number of filespecs each
** separated by a semi-colon.
*/
static bool DetermineNextPathWorker (LPCWSTR  pwszFileList,
				     LPCWSTR& pwszReturnedCursor,
				     ULONG&   ulReturnedDirectoryStart,
				     ULONG&   ulReturnedDirectoryLength,
				     ULONG&   ulReturnedFilenameStart,
				     ULONG&   ulReturnedFilenameLength,
				     bool&    bReturnedRecurseIntoSubdirectories,
				     bool&    bReturnedFoundSpec)
    {
    bool	bSucceeded                    = true;
    bool	bFoundSpec                    = false;
    ULONG	ulPathNameLength;
    ULONG	ulFileNameLength;
    ULONG	ulIndex;
    ULONG	ulIndexSubDirectory           = 0;
    ULONG	ulIndexLastDirectorySeparator = 0;
    ULONG	ulIndexFirstCharInSpec        = 0;
    ULONG	ulIndexLastCharInSpec         = 0;
    const ULONG	ulLengthFileList              = wcslen (pwszFileList);


    /*
    ** The format of the string we are expecting is "filename.ext /s
    ** ;nextname", ie a list of semi-colon separated names with an
    ** optional trailing '/s'. There can be an arbitrary number of
    ** spaces before the '/' and before the ';': these will be
    ** stripped out and discarded. So we start by scanning for the
    ** first '/' or ';' characters.
    **
    ** Look for a ';' first to determine the end point.
    */
    if ((NULL         == pwszFileList) ||
	(UNICODE_NULL == pwszFileList [0]))
	{
	bFoundSpec = false;
	}

    else if (( L';'  == pwszFileList [0]) ||
	     ( L'/'  == pwszFileList [0]) ||
	     ((L'\\' == pwszFileList [0]) && (UNICODE_NULL == pwszFileList [1])))
	{
	bSucceeded = false;
	bFoundSpec = false;
	}

    else
	{
	bFoundSpec = true;
	}


    if (bSucceeded && bFoundSpec)
	{
	while (L' ' == pwszFileList [ulIndexFirstCharInSpec])
	    {
	    ulIndexFirstCharInSpec++;
	    }


	for (ulIndex = ulIndexFirstCharInSpec; ulIndex < ulLengthFileList; ulIndex++)
	    {
	    if ((UNICODE_NULL == pwszFileList [ulIndex]) ||
		(L';'         == pwszFileList [ulIndex]))
		{
		/*
		** We found the end of this specification
		*/
		break;
		}

	    else if (L'\\' == pwszFileList [ulIndex])
		{
		/*
		** Found a backslash? Record it's location. We'll want
		** this later when determining what the file name is
		** and so on.
		*/
		ulIndexLastDirectorySeparator = ulIndex;
		}

	    else if ((L'/' ==           pwszFileList [ulIndex]) &&
		     (L's' == towlower (pwszFileList [ulIndex + 1])))
		{
		ulIndexSubDirectory = ulIndex;
		}
	    }
	


	ulIndexLastCharInSpec = (0 == ulIndexSubDirectory) ? ulIndex - 1 : ulIndexSubDirectory - 1;

	while (L' ' == pwszFileList [ulIndexLastCharInSpec])
	    {
	    ulIndexLastCharInSpec--;
	    }


	_ASSERTE (ulIndex                       >  ulIndexSubDirectory);
	_ASSERTE (ulIndexSubDirectory == 0 ||
	          ulIndexSubDirectory           >  ulIndexLastCharInSpec);
	_ASSERTE (ulIndexLastCharInSpec         >= ulIndexLastDirectorySeparator);
	_ASSERTE (ulIndexLastDirectorySeparator >  ulIndexFirstCharInSpec);


	/*
	** We may have an illegal spec here with a missing '\'. Come
	** on folks, there ought to be at least one. one measly '\' is
	** all I'm after.
	*/
	bSucceeded = (0 < ulIndexLastDirectorySeparator);
	}




    if (bSucceeded)
	{
	if (bFoundSpec)
	    {
	    ulPathNameLength = ulIndexLastDirectorySeparator - ulIndexFirstCharInSpec;
	    ulFileNameLength = ulIndexLastCharInSpec         - ulIndexLastDirectorySeparator;


	    pwszReturnedCursor                 = (UNICODE_NULL == pwszFileList [ulIndex])
									? &pwszFileList [ulIndex]
									: &pwszFileList [ulIndex + 1];

	    ulReturnedDirectoryStart           = ulIndexFirstCharInSpec;
	    ulReturnedDirectoryLength          = ulPathNameLength;
	    ulReturnedFilenameStart            = ulIndexLastDirectorySeparator + 1;
	    ulReturnedFilenameLength           = ulFileNameLength;

	    bReturnedRecurseIntoSubdirectories = (0 != ulIndexSubDirectory);
	    bReturnedFoundSpec                 = true;
	    }

	else
	    {
	    pwszReturnedCursor                 = pwszFileList;

	    ulReturnedDirectoryStart           = 0;
	    ulReturnedDirectoryLength          = 0;
	    ulReturnedFilenameStart            = 0;
	    ulReturnedFilenameLength           = 0;

	    bReturnedRecurseIntoSubdirectories = false;
	    bReturnedFoundSpec                 = false;
	    }
	}



    return (bSucceeded);
    } /* DetermineNextPathWorker () */



static bool DetermineNextPathLengths (LPCWSTR pwszFileList,
				      ULONG&  ulReturnedLengthDirectory,
				      ULONG&  ulReturnedLengthFilename,
				      bool&   bReturnedRecurseIntoSubdirectories,
				      bool&   bReturnedFoundSpec)
    {
    bool	bSucceeded;
    LPCWSTR	pwszUpdatedCursor;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
					  pwszUpdatedCursor,
					  ulIndexDirectoryStart,
					  ulReturnedLengthDirectory,
					  ulIndexFilenameStart,
					  ulReturnedLengthFilename,
					  bReturnedRecurseIntoSubdirectories,
					  bReturnedFoundSpec);

    return (bSucceeded);
    } /* DetermineNextPathLengths () */


static bool DetermineNextPath (LPCWSTR  pwszFileList,
			       LPCWSTR& pwszReturnedCursor,
			       ULONG    ulLengthBufferDirectory,
			       PWCHAR   pwszBufferDirectory,
			       ULONG    ulLengthBufferFilename,
			       PWCHAR   pwszBufferFilename,
			       bool&    bReturnedRecurseIntoSubdirectories,
			       bool&    bReturnedFoundSpec)
    {
    bool	bSucceeded                    = true;
    bool	bRecurseIntoSubdirectories;
    bool	bFoundSpec;
    bool	bWildcardFilename;
    LPCWSTR	pwszUpdatedCursor;
    ULONG	ulLengthDirectory;
    ULONG	ulLengthFilename;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
					  pwszUpdatedCursor,
					  ulIndexDirectoryStart,
					  ulLengthDirectory,
					  ulIndexFilenameStart,
					  ulLengthFilename,
					  bRecurseIntoSubdirectories,
					  bFoundSpec);

    if (bSucceeded && bFoundSpec)
	{
	if ((ulLengthBufferDirectory < ((sizeof (WCHAR) * ulLengthDirectory) + sizeof (UNICODE_NULL))) ||
	    (ulLengthBufferFilename  < ((sizeof (WCHAR) * ulLengthFilename)  + sizeof (UNICODE_NULL))))
	    {
	    /*
	    ** Oops, buffer overflow would occur if we were to proceed
	    ** with the copy.
	    */
	    bSucceeded = false;
	    }
	}


    if (bSucceeded)
	{
	bReturnedRecurseIntoSubdirectories = bRecurseIntoSubdirectories;
	bReturnedFoundSpec                 = bFoundSpec;
	pwszReturnedCursor                 = pwszUpdatedCursor;


	if (bFoundSpec)
	    {
	    /*
	    ** Everything up to, but excluding the last directory
	    ** separator is the path. Everything after the last directory
	    ** separator up to and including the last char is the
	    ** filespec. If the filespec is zero length, then add the '*'
	    ** wildcard.
	    */
	    bWildcardFilename = (0 == ulLengthFilename);

	    ulLengthFilename += bWildcardFilename ? 1 : 0;


	    memcpy (pwszBufferDirectory,
		    &pwszFileList [ulIndexDirectoryStart],
		    sizeof (WCHAR) * ulLengthDirectory);

	    memcpy (pwszBufferFilename,
		    (bWildcardFilename) ? L"*" : &pwszFileList [ulIndexFilenameStart],
		    sizeof (WCHAR) * ulLengthFilename);

	    pwszBufferDirectory [ulLengthDirectory] = UNICODE_NULL;
	    pwszBufferFilename  [ulLengthFilename]  = UNICODE_NULL;
	    }
	}


    return (bSucceeded);
    } /* DetermineNextPath () */



static bool ValidateIncludeExcludeList (LPCWSTR pwszFileList)
    {
    LPCWSTR	pwszCursor  = pwszFileList;
    bool	bSucceeded  = true;
    bool	bFoundFiles = true;
    bool	bRecurseIntoSubdirectories;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;
    ULONG	ulLengthDirectory;
    ULONG	ulLengthFilename;

    while (bSucceeded && bFoundFiles)
	{
	bSucceeded = EXECUTEIF (bSucceeded, (DetermineNextPathWorker (pwszCursor,
								      pwszCursor,
								      ulIndexDirectoryStart,
								      ulLengthDirectory,
								      ulIndexFilenameStart,
								      ulLengthFilename,
								      bRecurseIntoSubdirectories,
								      bFoundFiles)));
	}


    return (bSucceeded);
    } /* ValidateIncludeExcludeList () */


/*
** Based on MatchFname() from \nt\base\fs\utils\ntback50\be\bsdmatch.cpp
*/
static bool MatchFilename (LPCWSTR pwszPattern,    /* I - file name (with wildcards)     */
			   LPCWSTR pwszFilename)   /* I - file name (without wildcards ) */
    {
    ULONG	ulIndexPattern;					/* index for pwszPattern */
    ULONG	ulIndexFilename;				/* index for pwszFilename */
    ULONG	ulLengthPattern;
    const ULONG	ulLengthFilename        = wcslen (pwszFilename);
    bool	bSucceeded              = true;
    PWCHAR	pwszNameBufferAllocated = NULL;			/* allocated temp name buffer  */
    PWCHAR	pwszNameBufferTemp;				/* pointer to one of the above */
    PWCHAR	pwchTemp;
    WCHAR	pwszNameBufferStatic [256];			/* static temp name buffer     */
    WCHAR	wchSavedChar ;


    ulIndexFilename = 0;

    if (wcscmp (pwszPattern, L"*") && wcscmp (pwszPattern, L"*.*"))
	{
	bool bTryWithDot = false;

	do
	    {
	    if (bTryWithDot)
		{
		/*
		** Size of name_buff minus a null, minus a dot for the
		** "bTryWithDot" code below. If the name is longer than the
		** static buffer, allocate one from the heap.
		*/
		if (((ulLengthFilename + 2) * sizeof (WCHAR)) > sizeof (pwszNameBufferStatic))
		    {
		    pwszNameBufferAllocated = new WCHAR [ulLengthFilename + 2];
		    pwszNameBufferTemp = pwszNameBufferAllocated;
		    }
		else
		    {
		    pwszNameBufferTemp = pwszNameBufferStatic;
		    }

		if (pwszNameBufferTemp != NULL)
		    {
		    wcscpy (pwszNameBufferTemp, pwszFilename);
		    wcscat (pwszNameBufferTemp, L".");
		    pwszFilename = pwszNameBufferTemp;
		    ulIndexFilename = 0;
		    bSucceeded = true;
		    }

		bTryWithDot = false;
		}

	    else if (wcschr (pwszFilename, L'.') == NULL)
		{
		bTryWithDot = true;
		}


	    for (ulIndexPattern = 0; (pwszPattern [ulIndexPattern] != 0) && (bSucceeded) ; ulIndexPattern++)
		{
		switch (pwszPattern [ulIndexPattern])
		    {
		    case L'*':
			while (pwszPattern [ulIndexPattern + 1] != UNICODE_NULL)
			    {
			    if (pwszPattern [ulIndexPattern + 1] == L'?')
				{
				if (pwszFilename [++ulIndexFilename] == UNICODE_NULL)
				    {
				    break ;
				    }
				}

			    else if (pwszPattern [ulIndexPattern + 1] != L'*')
				{
				break ;
				}

			    ulIndexPattern++ ;
			    }

			pwchTemp = wcspbrk (&pwszPattern [ulIndexPattern + 1], L"*?");

			if (pwchTemp != NULL)
			    {
			    wchSavedChar = *pwchTemp;
			    *pwchTemp = UNICODE_NULL;

			    ulLengthPattern = wcslen (&pwszPattern [ulIndexPattern + 1]);

			    while (pwszFilename [ulIndexFilename] &&
				   _wcsnicmp (&pwszFilename [ulIndexFilename],
					      &pwszPattern [ulIndexPattern + 1],
					      ulLengthPattern))
				{
				ulIndexFilename++;
				}

			    ulIndexPattern += ulLengthPattern;

			    *pwchTemp = wchSavedChar;

			    if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
				{
				bSucceeded = false;
				}
			    else
				{
				ulIndexFilename++;
				}
			    }
			else
			    {
			    if (pwszPattern [ulIndexPattern + 1] == UNICODE_NULL)
				{
				ulIndexFilename = wcslen (pwszFilename);
				break;
				}
			    else
				{
				pwchTemp = wcschr (&pwszFilename [ulIndexFilename],
						   pwszPattern [ulIndexPattern + 1]);

				if (pwchTemp != NULL)
				    {
				    ulIndexFilename += (ULONG)(pwchTemp - &pwszFilename [ulIndexFilename]);
				    }
				else
				    {
				    bSucceeded = false;
				    }
				}
			    }
			break;


		    case L'?' :
			if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
			    {
			    ulIndexFilename++;
			    }
			break;


		    default:
			if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
			    {
			    bSucceeded = false;
			    }

			else if (towupper (pwszFilename [ulIndexFilename]) != towupper (pwszPattern [ulIndexPattern]))
			    {
			    ULONG	ulIndexPreviousStar = ulIndexPattern;


			    /*
			    ** Set the index back to the last '*'
			    */
			    bSucceeded = false;

			    do
				{
				if (pwszPattern [ulIndexPreviousStar] == L'*')
				    {
				    ulIndexPattern = ulIndexPreviousStar;
				    ulIndexFilename++;
				    bSucceeded = true;
				    break;
				    }
				} while (ulIndexPreviousStar-- > 0);
			    }
			else
			    {
			    ulIndexFilename++;
			    }

		    }
		}


	    if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
		{
		bSucceeded = false;
		}

	    } while ((!bSucceeded) && (bTryWithDot));
	}


    delete [] pwszNameBufferAllocated;


    return (bSucceeded);
    } /* MatchFilename () */


/////////////////////////////////////////////////////////////////////////////
//  class CVssIJetWriter
//
// logical path   == instance name
// component name == dbfilename (minus the extension?)
// caption        == display name
//
//
// add db and slv files as database files
// add the per-instance log file to each database even though is is the same each time.



STDMETHODCALLTYPE CVssIJetWriter::~CVssIJetWriter()
    {
    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);

    delete m_wszWriterName;
    delete m_wszFilesToInclude;
    delete m_wszFilesToExclude;
    }



BOOL CVssIJetWriter::CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
						    LPCWSTR pwszDatabaseFileSpec)
    {
    BOOL		bMatchFound	= false;
    PLIST_ENTRY		pleElement	= m_leFilesToExcludeEntries.Flink;
    UNICODE_STRING	ucsExcludedFilePath;
    UNICODE_STRING	ucsDatabaseFilePath;
    PEXPANDEDPATHINFO	pepnPathInfomation;


    RtlInitUnicodeString (&ucsDatabaseFilePath, pwszDatabaseFilePath);


    while ((&m_leFilesToExcludeEntries != pleElement) && !bMatchFound)
	{
	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

	RtlInitUnicodeString (&ucsExcludedFilePath,
			      pepnPathInfomation->pwszExpandedFilePath);

	
	if (pepnPathInfomation->bRecurseIntoSubdirectories)
	    {
	    bMatchFound = RtlPrefixUnicodeString (&ucsExcludedFilePath,
						  &ucsDatabaseFilePath,
						  true);
	    }
	else
	    {
	    bMatchFound = RtlEqualUnicodeString (&ucsExcludedFilePath, &ucsDatabaseFilePath, true) &&
			  MatchFilename (pepnPathInfomation->pwszExpandedFileName, pwszDatabaseFileSpec);
	    }



	pleElement = pleElement->Flink;
	}




    return (bMatchFound);
    } /* CVssIJetWriter::CheckExcludedFileListForMatch () */




bool CVssIJetWriter::ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo)
    {
    JET_ERR	jetStatus;
    HRESULT	hrStatus;
    DWORD	dwStatus;
    bool	bSucceeded;
    bool	bRestoreMetadata        = false;
    bool	bNotifyOnBackupComplete = false;
    bool	bSelectable             = false;
    bool	bIncludeComponent;
    CHAR	szPathShortName        [MAX_PATH];
    CHAR	szPathFullName         [MAX_PATH];
    WCHAR	wszInstanceName        [MAX_PATH];
    WCHAR	wszDatabaseName        [MAX_PATH];
    WCHAR	wszDatabaseDisplayName [MAX_PATH];
    WCHAR	wszDatabaseFilePath    [MAX_PATH];
    WCHAR	wszDatabaseSLVFilePath [MAX_PATH];
    WCHAR	wszLogFilePath         [MAX_PATH];
    WCHAR	wszLogFileName         [MAX_PATH];
    WCHAR	wszCheckpointFilePath  [MAX_PATH];
    WCHAR	wszCheckpointFileName  [MAX_PATH];

    PWCHAR	pwszDatabaseFileName    = L"";
    PWCHAR	pwszDatabaseSLVFileName = L"";




    /*
    ** A valid instance will have an instance Id, but if it's not
    ** actually being used for anything it may well not have a name,
    ** any log or database files.
    **
    ** See if we can get hold of the name of the log file for this
    ** instance.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramLogFilePath,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	dwStatus = GetFullPathNameA (szPathShortName,
				     sizeof (szPathFullName),
				     szPathFullName,
				     NULL);

	bSucceeded = (dwStatus > 0);
	}


    if (bSucceeded)
	{
	RemoveAnyTrailingSeparator (szPathFullName);

	bSucceeded = ConvertName (szPathFullName,
				  MAX_PATH,
				  wszLogFilePath);
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() with instance Log file path '%S' (shortname) or '%s' full name",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszLogFilePath));





    /*
    ** Ok, now get the SystemPath which we will need to construct the
    ** path for the checkpoint file.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramSystemPath,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	dwStatus = GetFullPathNameA (szPathShortName,
				     sizeof (szPathFullName),
				     szPathFullName,
				     NULL);

	bSucceeded = (dwStatus > 0);
	}


    if (bSucceeded)
	{
	RemoveAnyTrailingSeparator (szPathFullName);

	bSucceeded = ConvertName (szPathFullName,
				  MAX_PATH,
				  wszCheckpointFilePath);
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() with checkpoint file path '%S' (shortname) or '%s' full name",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszCheckpointFilePath));



    /*
    ** Ok, now get the base name which we will need to construct the
    ** file spec for the log and checkpoint files. Note that we expect
    ** this to be just 3 chars long.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramBaseName,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	/*
	** Convert to wide char ensuring that we leave a little room
	** for the "*.log"/".chk" strings to be appended to form the
	** log file spec and the checkpoint file specs respectively.
	*/
	bSucceeded = ConvertName (szPathShortName,
				  MAX_PATH - sizeof ("*.log"),
				  wszCheckpointFileName);
	}


    if (bSucceeded)
	{
	wcscpy (wszLogFileName, wszCheckpointFileName);


	wcscat (wszCheckpointFileName, L".chk" );
	wcscat (wszLogFileName,        L"*.log");
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() for base name '%S' to form LogFileName '%s' and CheckpointFileName '%s'",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszLogFileName,
		   wszCheckpointFileName));




    if (bSucceeded && (pInstanceInfo->cDatabases > 0))
	{
	/*
	** Ok, we think we have an instance that is actually being
	** used for something. so go ahead and construct a 'component'
	** for it.
	*/
	if ((NULL == pInstanceInfo->szInstanceName) ||
	    ('\0' == pInstanceInfo->szInstanceName [0]))
	    {
	    /*
	    ** We seem to have a NULL pointer or a zero length
	    ** string. Just set to a zero length unicode string.
	    */
	    wszInstanceName [0] = UNICODE_NULL;
	    }

	else
	    {
	    bSucceeded = ConvertName (pInstanceInfo->szInstanceName,
				      MAX_PATH,
				      wszInstanceName);
	    }



	for (ULONG ulDatabase = 0; bSucceeded && (ulDatabase < pInstanceInfo->cDatabases); ulDatabase++)
	    {
	    bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseFileName [ulDatabase],
							  MAX_PATH,
							  wszDatabaseFilePath,
							  pwszDatabaseFileName);


	    /*
	    ** Convert the database display name to unicode but allow
	    ** for a possible NULL pointer or a non-zero length file
	    ** spec.
	    */
	    if (bSucceeded)
		{
		if ((NULL == pInstanceInfo->szDatabaseDisplayName [ulDatabase]) ||
		    ('\0' == pInstanceInfo->szDatabaseDisplayName [ulDatabase][0]))
		    {
		    wszDatabaseDisplayName [0] = UNICODE_NULL;
		    }
		else
		    {
		    bSucceeded = ConvertName (pInstanceInfo->szDatabaseDisplayName [ulDatabase],
					      MAX_PATH,
					      wszDatabaseDisplayName);
		    }
		}


	    /*
	    ** Convert the SLV filename to unicode but allow for a
	    ** possible NULL pointer or a non-zero length file spec.
	    */
	    if (bSucceeded)
		{
		if ((NULL == pInstanceInfo->szDatabaseSLVFileName [ulDatabase]) ||
		    ('\0' == pInstanceInfo->szDatabaseSLVFileName [ulDatabase][0]))
		    {
		    wszDatabaseSLVFilePath [0] = UNICODE_NULL;
		    pwszDatabaseSLVFileName    = wszDatabaseSLVFilePath;
		    }
		else
		    {
		    bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseSLVFileName [ulDatabase],
								  MAX_PATH,
								  wszDatabaseSLVFilePath,
								  pwszDatabaseSLVFileName);
		    }
		}




	    /*
	    ** We've now done all the name conversions to unicode so
	    ** add a component and the log and database files where
	    ** they're available.
	    */
	    if (bSucceeded)
		{
		bIncludeComponent = !CheckExcludedFileListForMatch (wszDatabaseFilePath,
								    pwszDatabaseFileName);
		}


	    if (bSucceeded && bIncludeComponent)
		{
		PWCHAR	pwchLastDot          = wcsrchr (pwszDatabaseFileName, L'.');
		ULONG	ulDatabaseNameLength = (ULONG) (pwchLastDot - pwszDatabaseFileName);

		wcsncpy (wszDatabaseName, pwszDatabaseFileName, ulDatabaseNameLength);
		wszDatabaseName [ulDatabaseNameLength] = '\0';



		hrStatus = m_pIMetadata->AddComponent (VSS_CT_DATABASE,
						       wszInstanceName,
						       wszDatabaseName,
						       wszDatabaseDisplayName,
						       NULL,
						       0,
						       bRestoreMetadata,
						       bNotifyOnBackupComplete,
						       bSelectable);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding component '%s' for database '%s' with display name '%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseDisplayName));
		}
	


	    if (bSucceeded && bIncludeComponent)
		{
		hrStatus = m_pIMetadata->AddDatabaseFiles (wszInstanceName,
							   wszDatabaseName,
							   wszDatabaseFilePath,
							   pwszDatabaseFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding database files for instance '%s', database '%s', database file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseFilePath,
			       pwszDatabaseFileName));
		}
	


	    /*
	    ** May not have an SLV file so only add it if we have a
	    ** non-zero length file spec
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != pwszDatabaseSLVFileName [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseFiles (wszInstanceName,
							   wszDatabaseName,
							   wszDatabaseSLVFilePath,
							   pwszDatabaseSLVFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding SLV file for instance '%s', database '%s', SLV file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseSLVFilePath,
			       pwszDatabaseSLVFileName));
		}


	    /*
	    ** May not have an instance log file so only add it if we
	    ** have a non-zero length file path
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszLogFilePath [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszInstanceName,
							      wszDatabaseName,
							      wszLogFilePath,
							      wszLogFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding log file for instance '%s', database '%s', log file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszLogFilePath,
			       wszLogFileName));
		}


	    /*
	    ** May not have a checkpoint file so only add it if we
	    ** have a non-zero length file path
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszCheckpointFilePath [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszInstanceName,
							      wszDatabaseName,
							      wszCheckpointFilePath,
							      wszCheckpointFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding checkpoint file for instance '%s', database '%s', checkpoint file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszCheckpointFilePath,
			       wszCheckpointFileName));
		}
	    }
	}


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessJetInstance () */



bool CVssIJetWriter::PreProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** Parse the m_wszFilesToInclude and m_wszFilesToExclude adding
    ** and enty to the appropriate list as necessary. This will
    ** minimize the number of passes over the un-processed lists.
    */
    ULONG		ulPathLength;
    ULONG		ulNameLength;
    bool		bRecurseIntoSubdirectories;
    bool		bSucceeded         = true;
    bool		bFoundFiles        = true;
    PEXPANDEDPATHINFO	pepnPathInfomation = NULL;
    PWCHAR		pwszCursor         = bProcessingIncludeList
						? m_wszFilesToInclude
						: m_wszFilesToExclude;



    while (bSucceeded && bFoundFiles)
	{
	bSucceeded = DetermineNextPathLengths (pwszCursor,
					       ulPathLength,
					       ulNameLength,
					       bRecurseIntoSubdirectories,
					       bFoundFiles);


	if (bSucceeded && bFoundFiles)
	    {
	    pepnPathInfomation = new EXPANDEDPATHINFO;

	    bSucceeded = (NULL != pepnPathInfomation);
	    }
	else
	    {
	    /*
	    ** We either failed and/or found no files. In either case
	    ** there is no point in continuing.
	    */
	    break;
	    }



	if (bSucceeded)
	    {
	    InitializeListHead (&pepnPathInfomation->leQueueHead);


	    if (0 == ulNameLength)
		{
		/*
		** If the filename component is zero length, then it
		** will be turned into a "*" so add a character to the
		** buffer to make room.
		*/
		ulNameLength++;
		}

	    /*
	    ** Allow extra space for terminating UNICODE_NULL
	    */
	    ulPathLength++;
	    ulNameLength++;


	    pepnPathInfomation->pwszExpandedFilePath = NULL;
	    pepnPathInfomation->pwszExpandedFileName = NULL;
	    pepnPathInfomation->pwszOriginalFilePath = new WCHAR [ulPathLength];
	    pepnPathInfomation->pwszOriginalFileName = new WCHAR [ulNameLength];

	    bSucceeded = ((NULL != pepnPathInfomation->pwszOriginalFilePath) &&
			  (NULL != pepnPathInfomation->pwszOriginalFileName));
	    }


	if (bSucceeded)
	    {
	    bSucceeded = DetermineNextPath (pwszCursor,
					    pwszCursor,
					    ulPathLength * sizeof (WCHAR),
					    pepnPathInfomation->pwszOriginalFilePath,
					    ulNameLength * sizeof (WCHAR),
					    pepnPathInfomation->pwszOriginalFileName,
					    pepnPathInfomation->bRecurseIntoSubdirectories,
					    bFoundFiles);

	    BS_ASSERT (bFoundFiles && L"Second attempt to locate files failed unexpectedly");
	    }


	if (bSucceeded)
	    {
	    ulPathLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath, NULL, 0);
	    ulNameLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName, NULL, 0);

	    bSucceeded = (0 < ulPathLength) && (0 < ulNameLength);
	    }


	if (bSucceeded)
	    {
	    pepnPathInfomation->pwszExpandedFilePath = new WCHAR [ulPathLength];
	    pepnPathInfomation->pwszExpandedFileName = new WCHAR [ulNameLength];

	    bSucceeded = ((NULL != pepnPathInfomation->pwszExpandedFilePath) &&
			  (NULL != pepnPathInfomation->pwszExpandedFileName));
	    }


	if (bSucceeded)
	    {
	    ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath,
				       pepnPathInfomation->pwszExpandedFilePath,
				       ulPathLength);


	    ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName,
				       pepnPathInfomation->pwszExpandedFileName,
				       ulNameLength);
	    }


	if (bSucceeded)
	    {
	    InsertTailList (bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries,
			    &pepnPathInfomation->leQueueHead);

	    pepnPathInfomation = NULL;
	    }



	if (NULL != pepnPathInfomation)
	    {
	    delete [] pepnPathInfomation->pwszOriginalFilePath;
	    delete [] pepnPathInfomation->pwszOriginalFileName;
	    delete [] pepnPathInfomation->pwszExpandedFilePath;
	    delete [] pepnPathInfomation->pwszExpandedFileName;
	    delete pepnPathInfomation;

	    pepnPathInfomation = NULL;
	    }
	}


    return (bSucceeded);
    } /* CVssIJetWriter::PreProcessIncludeExcludeLists () */



bool CVssIJetWriter::ProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** parse the m_wszFilesToInclude and m_wszFilesToExclude
    ** calling the m_pIMetadata->IncludeFiles() and/or
    ** m_pIMetadata->ExcludeFiles() routines as necessary
    */
    HRESULT		hrStatus;
    bool		bSucceeded   = true;
    const PLIST_ENTRY	pleQueueHead = bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries;
    PLIST_ENTRY		pleElement   = pleQueueHead->Flink;
    PEXPANDEDPATHINFO	pepnPathInfomation;



    while (bSucceeded && (pleQueueHead != pleElement))
	{
	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));


	if (bProcessingIncludeList)
	    {
	    hrStatus = m_pIMetadata->AddIncludeFiles (pepnPathInfomation->pwszOriginalFilePath,
						      pepnPathInfomation->pwszOriginalFileName,
						      pepnPathInfomation->bRecurseIntoSubdirectories,
						      NULL);
	    }
	else
	    {
	    hrStatus = m_pIMetadata->AddExcludeFiles (pepnPathInfomation->pwszOriginalFilePath,
						      pepnPathInfomation->pwszOriginalFileName,
						      pepnPathInfomation->bRecurseIntoSubdirectories);
	    }


	bSucceeded = SUCCEEDED (hrStatus);

	pleElement = pleElement->Flink;
	}


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessIncludeExcludeLists () */



void CVssIJetWriter::PostProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    PEXPANDEDPATHINFO	pepnPathInfomation;
    PLIST_ENTRY		pleElement;
    const PLIST_ENTRY	pleQueueHead = bProcessingIncludeList
						? &m_leFilesToIncludeEntries
						: &m_leFilesToExcludeEntries;


    while (!IsListEmpty (pleQueueHead))
	{
	pleElement = RemoveHeadList (pleQueueHead);

	BS_ASSERT (NULL != pleElement);


	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

	delete [] pepnPathInfomation->pwszOriginalFilePath;
	delete [] pepnPathInfomation->pwszOriginalFileName;
	delete [] pepnPathInfomation->pwszExpandedFilePath;
	delete [] pepnPathInfomation->pwszExpandedFileName;
	delete pepnPathInfomation;
	}
    } /* CVssIJetWriter::PostProcessIncludeExcludeLists () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnIdentify (IN IVssCreateWriterMetadata *pMetadata)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnIdentify");

    JET_ERR		 jetStatus;
    HRESULT		 hrStatus;
    bool		 bSucceeded = true;
    ULONG		 ulInstanceInfoCount = 0;
    JET_INSTANCE_INFO	*pInstanceInfo;


    m_pIMetadata = pMetadata;


    /*
    ** Set up list of include and exclude files. ready for use in
    ** filtering Jet databases and adding include/exclude files lists.
    */
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (false)));

    bSucceeded = EXECUTEIF (bSucceeded, (JET_errSuccess <= JetGetInstanceInfo (&ulInstanceInfoCount,
									       &pInstanceInfo)));

    for (ULONG ulInstanceIndex = 0; ulInstanceIndex < ulInstanceInfoCount; ulInstanceIndex++)
	{
	bSucceeded = EXECUTEIF (bSucceeded, (ProcessJetInstance (pInstanceInfo + ulInstanceIndex)));
	}


    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (false)));
    bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnIdentify (pMetadata)));



    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);


    m_pIMetadata = NULL;

    return (bSucceeded);
    } /* CVssIJetWriter::OnIdentify () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareBackup (IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareBackup");

	bool	bSucceeded;
	

	bSucceeded = m_pwrapper->OnPrepareBackupBegin (pIVssWriterComponents);

	bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnPrepareBackupEnd (pIVssWriterComponents, bSucceeded)));

	return (bSucceeded);
	} /* CVssIJetWriter::OnPrepareBackup () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnBackupComplete (IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnBackupComplete");

	bool	bSucceeded;
	

	bSucceeded = m_pwrapper->OnBackupCompleteBegin (pIVssWriterComponents);

	bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnBackupCompleteEnd (pIVssWriterComponents, bSucceeded)));

	return (bSucceeded);
	} /* CVssIJetWriter::OnBackupComplete () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareSnapshot()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareSnapshot");

	if (!m_pwrapper->OnPrepareSnapshotBegin())
		return false;

	// go to Jet level directly
	bool fSuccess = JET_errSuccess <= JetOSSnapshotPrepare( &m_idJet , 0 );
	return m_pwrapper->OnPrepareSnapshotEnd(fSuccess);
	} /* CVssIJetWriter::OnPrepareSnapshot () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnFreeze()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnFreeze");

	unsigned long 			cInstanceInfo 	= 0;
	JET_INSTANCE_INFO *		aInstanceInfo 	= NULL;
	bool 					fDependence		= true;

	if (!m_pwrapper->OnFreezeBegin())
		return false;


	// we need to freeze at Jet level, then check from this DLL the dependencies
	// (as here we hagve the snapshot object implementation and COM registration)
	
	if ( JET_errSuccess > JetOSSnapshotFreeze( m_idJet , &cInstanceInfo, &aInstanceInfo, 0 ) )
		{
		return false;
		}

	// return false if some instances are only partialy affected
	fDependence = FCheckVolumeDependencies(cInstanceInfo, aInstanceInfo);
	(void)JetFreeBuffer( (char *)aInstanceInfo );
	
	if ( !fDependence )
		{
		JET_ERR 	err;
 		// on error, stop the snapshot, return false
		err = JetOSSnapshotThaw( m_idJet , 0 );
		// shell we check for time-out error here ?
		// (debugging may result in time-out error the call)
		BS_ASSERT ( JET_errSuccess == err );
 		}

	return m_pwrapper->OnFreezeEnd(fDependence);	
	} /* CVssIJetWriter::OnFreeze () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnThaw()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnThaw");

	bool fSuccess1 = m_pwrapper->OnThawBegin();
	// go to Jet level directly. It will eventualy return timeout errors
	bool fSuccess2 = JET_errSuccess <= JetOSSnapshotThaw( m_idJet , 0 );
	return fSuccess1 && m_pwrapper->OnThawEnd(fSuccess2);
	} /* CVssIJetWriter::OnThaw () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPostSnapshot
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	return m_pwrapper->OnPostSnapshot(pIVssWriterComponents);
	}



bool STDMETHODCALLTYPE CVssIJetWriter::OnAbort()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnAbort");

	m_pwrapper->OnAbortBegin();
	JetOSSnapshotThaw( m_idJet , 0 );
	m_pwrapper->OnAbortEnd();
	return true;
	} /* CVssIJetWriter::OnAbort () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPreRestore
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

	if (!m_pwrapper->OnPreRestoreBegin(pIVssWriterComponents))
		return false;

	// go to Jet level directly
	// BUGBUG - need to add the correct Jet restore call/code here (MCJ)
	//	bool fSuccess = JET_errSuccess <= JetRestore ( ??? &m_idJet , 0 );
	bool fSuccess = TRUE;
	return m_pwrapper->OnPreRestoreEnd(pIVssWriterComponents, fSuccess);
	} /* CVssIJetWriter::OnPreRestore () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPostRestore
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

	if (!m_pwrapper->OnPostRestoreBegin(pIVssWriterComponents))
		return false;

	// go to Jet level directly
	// BUGBUG - need to add the correct Jet restore call/code here (MCJ)
	//	bool fSuccess = JET_errSuccess <= JetRestore ( ??? &m_idJet , 0 );
	bool fSuccess = TRUE;
	return m_pwrapper->OnPostRestoreEnd(pIVssWriterComponents, fSuccess);
	} /* CVssIJetWriter::OnPostRestore () */



bool CVssIJetWriter::FCheckPathVolumeDependencies(const char * szPath) const
	{
	// use static variable in order to avoid alloc/free
	WCHAR wszPath[MAX_PATH];

	if (MultiByteToWideChar(CP_OEMCP, 0, szPath, -1, wszPath, MAX_PATH ) == 0 )
		{
		BS_ASSERT( ERROR_INSUFFICIENT_BUFFER != GetLastError() );
		return false;
		}

	// use standart Writer call to check the affected path
	return IsPathAffected(wszPath);
	} /* CVssIJetWriter::FCheckPathVolumeDependencies () */



// all or nothing check: all path in instance are affected or none !
//
bool CVssIJetWriter::FCheckInstanceVolumeDependencies (const JET_INSTANCE_INFO * pInstanceInfo) const
	{
	BS_ASSERT(pInstanceInfo);

	JET_ERR 	err 			= JET_errSuccess;
	bool		fAffected		= false;
	char 		szPath[ MAX_PATH ];		
	
	
	// check first system and log path
	err = JetGetSystemParameter( pInstanceInfo->hInstanceId, JET_sesidNil, JET_paramLogFilePath, NULL, szPath, sizeof( szPath ) );
	if ( JET_errSuccess > err )
		return false;

	fAffected = FCheckPathVolumeDependencies( szPath );

	err = JetGetSystemParameter
		(
		pInstanceInfo->hInstanceId,
		JET_sesidNil,
		JET_paramSystemPath,
		NULL,
		szPath,
		sizeof(szPath)
		);

	if (JET_errSuccess > err)
		return false;

		
	fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szPath));
	if (!fAffected)
		return false;
		
	for (ULONG_PTR iDatabase = 0;
		iDatabase < pInstanceInfo->cDatabases;
		iDatabase++)
		{
		char * szFile = pInstanceInfo->szDatabaseFileName[iDatabase];
		
		BS_ASSERT(szFile); // we always have a db file name
		fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szFile));
		if (!fAffected)
			return false;

		szFile = pInstanceInfo->szDatabaseSLVFileName[iDatabase];

		// if no SLV file, go to next database
		if (!szFile)
			continue;
			
		fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szFile));
		if ( !fAffected )
			return false;
		}

	// all set !
	return true;
	} /* CVssIJetWriter::FCheckInstanceVolumeDependencies () */



bool CVssIJetWriter::FCheckVolumeDependencies
	(
	unsigned long cInstanceInfo,
	JET_INSTANCE_INFO *	aInstanceInfo
	) const
	{
	bool fResult = true;

	// check each instance
	while (cInstanceInfo && fResult)
		{
		cInstanceInfo--;
		fResult = FCheckInstanceVolumeDependencies (aInstanceInfo + cInstanceInfo);
		}
		
	return fResult;
	} /* CVssIJetWriter::FCheckVolumeDependencies () */



// internal method to assign basic members
HRESULT CVssIJetWriter::InternalInitialize (IN VSS_ID  idWriter,
					    IN LPCWSTR wszWriterName,
					    IN bool    bSystemService,
					    IN bool    bBootableSystemState,
					    IN LPCWSTR wszFilesToInclude,
					    IN LPCWSTR wszFilesToExclude)
    {
    HRESULT hrStatus = NOERROR;


    CVssWriter::Initialize (idWriter,
				wszWriterName,
				bBootableSystemState
					? VSS_UT_BOOTABLESYSTEMSTATE
					: (bSystemService
						? VSS_UT_SYSTEMSERVICE
						: VSS_UT_USERDATA),
				VSS_ST_TRANSACTEDDB,
				VSS_APP_BACK_END);


    m_idWriter             = idWriter;
    m_bSystemService       = bSystemService;
    m_bBootableSystemState = bBootableSystemState;
    m_wszWriterName        = _wcsdup(wszWriterName);
    m_wszFilesToInclude    = _wcsdup(wszFilesToInclude);
    m_wszFilesToExclude    = _wcsdup(wszFilesToExclude);

    if ((NULL == m_wszWriterName)     ||
	(NULL == m_wszFilesToInclude) ||
	(NULL == m_wszFilesToExclude))
	{
	delete m_wszWriterName;
	delete m_wszFilesToInclude;
	delete m_wszFilesToExclude;

	m_wszWriterName     = NULL;
	m_wszFilesToInclude = NULL;
	m_wszFilesToExclude = NULL;

	hrStatus = E_OUTOFMEMORY;
	}


    return (hrStatus);
    } /* CVssIJetWriter::InternalInitialize () */



// do initialization
HRESULT STDMETHODCALLTYPE CVssIJetWriter::Initialize (IN VSS_ID idWriter,			// id of writer
						      IN LPCWSTR wszWriterName,		// writer name
						      IN bool bSystemService,		// is this a system service
						      IN bool bBootableSystemState,	// is this writer part of bootable system state
						      IN LPCWSTR wszFilesToInclude,	// additional files to include
						      IN LPCWSTR wszFilesToExclude,	// additional files to exclude
						      IN CVssJetWriter *pWriter,		// writer wrapper class
						      OUT void **ppInstance)		// output instance
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Initialize");

    try
	{
	// check parameters
	if (ppInstance == NULL)
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"NULL output parameter.");
	    }

	// change null pointer to null strings for files to include
	// and files to exclude
    if (wszFilesToInclude == NULL)
		wszFilesToInclude = L"";

	if (wszFilesToExclude == NULL)
		wszFilesToExclude = L"";


	if (!ValidateIncludeExcludeList (wszFilesToInclude))
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToInclude list.");
	    }

	if (!ValidateIncludeExcludeList (wszFilesToExclude))
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToExclude list.");
	    }



	// null output parameter
	*ppInstance = NULL;

	// create instance
	PVSSIJETWRITER pInstance = new CVssIJetWriter;

	// create instance
	ft.ThrowIf (NULL == pInstance,
		    VSSDBG_GEN,
		    E_OUTOFMEMORY,
		    L"FAILED creating CVssIJetWriter object due to allocation failure.");



	// call internal initialization
	ft.hr = pInstance->InternalInitialize (idWriter,
					       wszWriterName,
					       bSystemService,
					       bBootableSystemState,
					       wszFilesToInclude,
					       wszFilesToExclude);

	ft.ThrowIf (ft.HrFailed(),
		    VSSDBG_GEN,
		    ft.hr,
		    L"FAILED during internal initialisation of CVssIJetWriter object");



	// Subscribe the object.
	ft.hr = pInstance->Subscribe();

	ft.ThrowIf (ft.HrFailed(),
		    VSSDBG_GEN,
		    ft.hr,
		    L"FAILED during internal initialisation of CVssIJetWriter object");



	((CVssIJetWriter *) pInstance)->m_pwrapper = pWriter;
	*ppInstance = (void *) pInstance;
	} VSS_STANDARD_CATCH(ft)


    return (ft.hr);
    } /* CVssIJetWriter::Initialize () */



void STDMETHODCALLTYPE CVssIJetWriter::Uninitialize(IN PVSSIJETWRITER pInstance)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Uninitialize");

	try
		{
		CVssIJetWriter *pWriter = (CVssIJetWriter *) pInstance;
		// Unsubscribe the object.

		BS_ASSERT(pWriter);

		pWriter->Unsubscribe();
		delete pWriter;
		}
	VSS_STANDARD_CATCH(ft)
	} /* CVssIJetWriter::Uninitialize () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\prop\copy.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Copy.cxx | Implementation of VSS_OBJECT_PROP_Copy and VSS_OBJECT_PROP_Ptr classes
    @end

Author:

    Adi Oltean  [aoltean]  09/01/1999

Remarks:

	It cannot be put into a library because of ATL code.

Revision History:

    Name        Date        Comments
    aoltean     09/01/1999  Created
    aoltean     09/09/1999  dss -> vss
	aoltean		09/13/1999	Moved to inc. Renamed to copy.inl
	aoltean		09/20/1999	Adding methods for creating the snapshot, snapshot set,
							provider and volume property structures.
							Also VSS_OBJECT_PROP_Manager renamed to VSS_OBJECT_PROP_Manager.
	aoltean		09/21/1999	Renaming back VSS_OBJECT_PROP_Manager to VSS_OBJECT_PROP_Copy.
							Moving the CreateXXX into VSS_OBJECT_PROP_Ptr::InstantiateAsXXX
	aoltean		09/22/1999	Fixing VSSDBG_GEN.
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		12/16/1999	Adding specialized copyXXX methods

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes

#include "stdafx.hxx"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "copy.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPCOPYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Copy class


HRESULT VSS_OBJECT_PROP_Copy::copySnapshot(
			IN	VSS_SNAPSHOT_PROP* pObj1,
			IN	VSS_SNAPSHOT_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copySnapshot" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_SnapshotId = pObj2->m_SnapshotId;
        pObj1->m_SnapshotSetId = pObj2->m_SnapshotSetId;
        pObj1->m_lSnapshotsCount = pObj2->m_lSnapshotsCount;
		::VssSafeDuplicateStr( ft, pObj1->m_pwszSnapshotDeviceObject, pObj2->m_pwszSnapshotDeviceObject );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginalVolumeName, pObj2->m_pwszOriginalVolumeName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginatingMachine, pObj2->m_pwszOriginatingMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszServiceMachine, pObj2->m_pwszServiceMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedName, pObj2->m_pwszExposedName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedPath, pObj2->m_pwszExposedPath );
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        pObj1->m_lSnapshotAttributes = pObj2->m_lSnapshotAttributes;
        pObj1->m_tsCreationTimestamp = pObj2->m_tsCreationTimestamp;
        pObj1->m_eStatus = pObj2->m_eStatus;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copyProvider(
		IN	VSS_PROVIDER_PROP* pObj1,
		IN	VSS_PROVIDER_PROP* pObj2
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copyProvider" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderName, pObj2->m_pwszProviderName );
        pObj1->m_eProviderType = pObj2->m_eProviderType;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderVersion, pObj2->m_pwszProviderVersion );
        pObj1->m_ProviderVersionId = pObj2->m_ProviderVersionId;
        pObj1->m_ClassId = pObj2->m_ClassId;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copy(
		IN	VSS_OBJECT_PROP* pObj1,
		IN	VSS_OBJECT_PROP* pObj2
		)
{
	HRESULT hr;

    // Testing arguments
    if ((pObj1 == NULL) || (pObj2 == NULL))
        return E_INVALIDARG;

    // Zeroing the contents of the destination structure
    ::VssZeroOut(pObj1);

    // Copy the type
    pObj1->Type = pObj2->Type;

    // Effective copy
    switch(pObj2->Type)
    {
    case VSS_OBJECT_SNAPSHOT:
		hr = copySnapshot( &(pObj1->Obj.Snap), &(pObj2->Obj.Snap) );
        break;

    case VSS_OBJECT_PROVIDER:
		hr = copyProvider( &(pObj1->Obj.Prov), &(pObj2->Obj.Prov) );
        break;

    default:
		BS_ASSERT(false);
		hr = E_UNEXPECTED;
        break;
    }

    return hr;
}


void VSS_OBJECT_PROP_Copy::init(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::init" );

    try
    {
        // Zeroing the contents of the structure
        ::VssZeroOut(pObjectProp);
    }
    VSS_STANDARD_CATCH(ft)
}


void VSS_OBJECT_PROP_Copy::destroy(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::destroy" );

    try
    {
        if (pObjectProp)
        {
            switch(pObjectProp->Type)
            {
            case VSS_OBJECT_SNAPSHOT:
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginalVolumeName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszSnapshotDeviceObject);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginatingMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszServiceMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedPath);
                break;

            case VSS_OBJECT_PROVIDER:
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderName);
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderVersion);
                break;

            default:
                break;
            }
            pObjectProp->Type = VSS_OBJECT_UNKNOWN;
        }
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\prop\pointer.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Pointer.cxx | Implementation of VSS_OBJECT_PROP_Ptr class
    @end

Author:

    Adi Oltean  [aoltean]  09/21/1999

Revision History:

    Name        Date        Comments

    aoltean     09/21/1999	VSS_OBJECT_PROP_Ptr as a pointer to the properties structure.
							This pointer will serve as element in CSimpleArray constructs.
	aoltean		09/22/1999	Adding InitializeAsEmpty and Print
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		03/27/2000	Adding Writers

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes


#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "copy.hxx"	
#include "pointer.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPPNTRC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Ptr class


void VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot(
    IN  CVssFunctionTracer& ft,
	IN  VSS_ID SnapshotId,
	IN  VSS_ID SnapshotSetId,
	IN  LONG lSnapshotsCount,
	IN  VSS_PWSZ pwszSnapshotDeviceObject,
	IN  VSS_PWSZ pwszOriginalVolumeName,
	IN  VSS_PWSZ pwszOriginatingMachine,
	IN  VSS_PWSZ pwszServiceMachine,
	IN  VSS_PWSZ pwszExposedName,
	IN  VSS_PWSZ pwszExposedPath,
	IN  VSS_ID ProviderId,
	IN  LONG lSnapshotAttributes,
	IN  VSS_TIMESTAMP tsCreationTimestamp,
	IN  VSS_SNAPSHOT_STATE eStatus
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_SNAPSHOT structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot";
	VSS_OBJECT_PROP* pProp = NULL;

    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_SNAPSHOT;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_SNAPSHOT_PROP& SnapshotProp = pProp->Obj.Snap;

		// Setting the internal members
		SnapshotProp.m_SnapshotId			= SnapshotId;
		SnapshotProp.m_SnapshotSetId		= SnapshotSetId;
		SnapshotProp.m_lSnapshotsCount      = lSnapshotsCount;
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszSnapshotDeviceObject, pwszSnapshotDeviceObject);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginalVolumeName, pwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginatingMachine, pwszOriginatingMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszServiceMachine, pwszServiceMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedName, pwszExposedName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedPath, pwszExposedPath);
		SnapshotProp.m_ProviderId			= ProviderId;
		SnapshotProp.m_lSnapshotAttributes	= lSnapshotAttributes;
		SnapshotProp.m_tsCreationTimestamp = tsCreationTimestamp;
		SnapshotProp.m_eStatus				= eStatus;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsProvider(
    IN  CVssFunctionTracer& ft,
    IN	VSS_ID ProviderId,
    IN	VSS_PWSZ pwszProviderName,
    IN  VSS_PROVIDER_TYPE eProviderType,
    IN	VSS_PWSZ pwszProviderVersion,
    IN	VSS_ID ProviderVersionId,
	IN	CLSID ClassId
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsProvider";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(pwszProviderName == NULL || pwszProviderName[0] != L'\0');
		BS_ASSERT(eProviderType == VSS_PROV_SYSTEM ||
            eProviderType == VSS_PROV_SOFTWARE ||
            eProviderType == VSS_PROV_HARDWARE
            );

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_PROVIDER;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_PROVIDER_PROP& ProviderProp = pProp->Obj.Prov;

		// Setting the internal members
		ProviderProp.m_ProviderId		 = ProviderId;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderName, pwszProviderName);
		ProviderProp.m_eProviderType	 = eProviderType;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderVersion, pwszProviderVersion);
		ProviderProp.m_ProviderVersionId = ProviderVersionId;
		ProviderProp.m_ClassId			 = ClassId;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsEmpty(
    IN  CVssFunctionTracer& ft
	)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to appear as an empty structure (to be filled later).

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeEmpty";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		BS_ASSERT(pProp == NULL);
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::Print(
    IN  CVssFunctionTracer& ft,
	IN  LPWSTR wszOutputBuffer,
	IN  LONG lBufferSize
	)
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::Print";

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		if (m_pStruct == NULL)
			::_snwprintf(wszOutputBuffer, lBufferSize, L"NULL object\n\n");

        // Effective copy
        switch(m_pStruct->Type)
        {
        case VSS_OBJECT_SNAPSHOT:

			::_snwprintf(wszOutputBuffer, lBufferSize,
				L"Id = " WSTR_GUID_FMT L", "
				L"SnapshotSetId = " WSTR_GUID_FMT L"\n"
				L"SnapCount = %ld "
				L"DevObj = %s\n"
				L"OriginalVolumeName = %s\n"
				L"OriginatingMachine = %s\n"
				L"ServiceMachine = %s\n"
				L"Exposed name = %s\n"
				L"Exposed path = %s\n"
				L"ProviderId = " WSTR_GUID_FMT L"\n"
				L"Attributes = 0x%08lx\n"
				L"Timestamp = " WSTR_LONGLONG_FMT L"\n"
				L"Status = %d\n ",
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotId ),
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotSetId ),
				m_pStruct->Obj.Snap.m_lSnapshotsCount,
				m_pStruct->Obj.Snap.m_pwszSnapshotDeviceObject,
				m_pStruct->Obj.Snap.m_pwszOriginalVolumeName,
				m_pStruct->Obj.Snap.m_pwszOriginatingMachine,
				m_pStruct->Obj.Snap.m_pwszServiceMachine,
				m_pStruct->Obj.Snap.m_pwszExposedName,
				m_pStruct->Obj.Snap.m_pwszExposedPath,
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_ProviderId ),
				m_pStruct->Obj.Snap.m_lSnapshotAttributes,
				LONGLONG_PRINTF_ARG( m_pStruct->Obj.Snap.m_tsCreationTimestamp ),
				m_pStruct->Obj.Snap.m_eStatus);
            break;

        case VSS_OBJECT_PROVIDER:
            ::_snwprintf(wszOutputBuffer, lBufferSize,
				L"m_ProviderId = " WSTR_GUID_FMT L"\n"
				L"m_pwszProviderName = %s\n"
				L"m_ProviderType = %d\n"
				L"m_pwszProviderVersion = %s\n"
				L"m_ProviderVersionId = " WSTR_GUID_FMT L"\n"
				L"m_ClassID: " WSTR_GUID_FMT L"\n\n",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderId ),
                m_pStruct->Obj.Prov.m_pwszProviderName? m_pStruct->Obj.Prov.m_pwszProviderName: L"NULL",
                m_pStruct->Obj.Prov.m_eProviderType,
                m_pStruct->Obj.Prov.m_pwszProviderVersion? m_pStruct->Obj.Prov.m_pwszProviderVersion: L"NULL",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderVersionId ),
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ClassId )
                );
            break;

        default:
			ft.ErrBox( VSSDBG_GEN, E_UNEXPECTED,
					   L"%s: Wrong object type %d", wszFunctionName, m_pStruct->Type );
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
		BS_ASSERT(m_pStruct == NULL);
		ft.Throw( VSSDBG_GEN, E_UNEXPECTED,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\prop\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sec\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sec\security.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module security.cxx | Implementation of IsAdministrator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding new headers
	aoltean		10/15/1999  Moving declaration in security.hxx
	aoltean		01/18/2000	Moved into a separate directory
	brianb		04/04/2000	Add IsBackupOperator
	brianb		04/27/2000  Change IsBackupOperator to check SE_BACKUP_NAME privilege
	brianb		05/03/2000	Added GetClientTokenOwner method
	brianb		05/10/2000  fix problem with uninitialized variable
	brianb		05/12/2000	handle in proc case for impersonation failures

--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

#include "vs_inc.hxx"

#include "vs_sec.hxx"

#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SECSECRC"
//
////////////////////////////////////////////////////////////////////////

BOOL DoImpersonate
	(
	BOOL bImpersonate,
	HANDLE *phToken
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"DoImpersonate");
	if (bImpersonate)
		{
		//  Impersonate the client to get its identity access token.
		//  The client should not have RPC_C_IMP_LEVEL_ANONYMOUS otherwise an error will be returned
		ft.hr = ::CoImpersonateClient();
		if (ft.hr == RPC_E_CALL_COMPLETE)
			{
			// this means that the call came from the same thread
			// do not do impersonation.  Just use the process
			// token
			bImpersonate = false;
			ft.hr = S_OK;
			}
		else
			{
			BOOL bRes;

			ft.CheckForError(VSSDBG_GEN, L"CoImpersonateClient");

			//  Get the Access Token of the client calling process in order to establish the client identity
			CVssAutoWin32Handle  hThread = ::GetCurrentThread(); // CloseHandle have no effect here

			bRes = ::OpenThreadToken
					(
					hThread,        //  IN HANDLE ThreadHandle,
					TOKEN_QUERY,    //  IN DWORD DesiredAccess,
					TRUE,           //  IN BOOL OpenAsSelf      (TRUE means not the client calling thread's access token)
					phToken         //  OUT PHANDLE TokenHandle
					);

			DWORD dwErr = GetLastError();

			// Revert the thread's access token - finish the impersonation
			ft.hr = ::CoRevertToSelf();
			ft.CheckForError(VSSDBG_GEN, L"CoRevertToSelf");

			if (!bRes)
				ft.TranslateError
					(
					VSSDBG_GEN,
					HRESULT_FROM_WIN32(dwErr),
					L"OpenThreadToken"
					);
			}
		}

	// note that the previous if statement may change the value
	// of bImpersonate.  This is why we can't just put this in an
	// else clause
	if (!bImpersonate)
		{
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,phToken))
			ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"OpenProcessToken"
				);
        }

	return bImpersonate;
	}




bool IsInGroup(DWORD dwGroup, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"IsInGroup" );

    BOOL bIsInGroup = FALSE;
    PSID psidGroup = NULL;
	BOOL bRes;

	// Reset the error code
	ft.hr = S_OK;

	//  Build the SID for the Administrators group
	SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
	bRes = AllocateAndInitializeSid
			(
            &SidAuth,                       //  IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
            2,                              //  IN BYTE nSubAuthorityCount,
			SECURITY_BUILTIN_DOMAIN_RID,	//  IN DWORD nSubAuthority0,
            dwGroup,  						//  IN DWORD nSubAuthority1,
            0,                              //  IN DWORD nSubAuthority2,
            0,                              //  IN DWORD nSubAuthority3,
            0,                              //  IN DWORD nSubAuthority4,
            0,                              //  IN DWORD nSubAuthority5,
            0,                              //  IN DWORD nSubAuthority6,
            0,                              //  IN DWORD nSubAuthority7,
            &psidGroup                      //  OUT PSID *pSid
            );

	if (!bRes)
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"AllocateAndInitializeSid"
			);

    try
		{

		if (!bImpersonate)
			bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
		else
			{
			CVssAutoWin32Handle  hToken;

			// impersonate client (or get process token)
			if (DoImpersonate(true, hToken.ResetAndGetAddress()))
				// check token membership
				bRes = CheckTokenMembership(hToken, psidGroup, &bIsInGroup);
            else
				// called from same thread
				bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
			}

		if (!bRes)
            ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"CheckTokenMembership"
				);

		}
    VSS_STANDARD_CATCH(ft)

	HRESULT hr = ft.hr;

    // Catch possible AVs
    try
		{
        //  Free the previously allocated SID
        if (psidGroup)
            ::FreeSid( psidGroup );
		}
    VSS_STANDARD_CATCH(ft)

    // Pass down the exception, if any
    if (FAILED(hr))
        throw(hr);

    return bIsInGroup ? true : false;
	}

bool HasPrivilege(LPWSTR wszPriv, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process has a specific privilege

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"HasPrivilege" );

	BOOL bHasPrivilege = false;
	CVssAutoWin32Handle  hToken;

	LUID TokenValue;
	if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"LookupPrivilegeValue"
			);

    DoImpersonate(bImpersonate, hToken.ResetAndGetAddress());

	BYTE rgb[sizeof(LUID_AND_ATTRIBUTES) + sizeof(PRIVILEGE_SET)];
	PRIVILEGE_SET *pSet = (PRIVILEGE_SET *) rgb;

	pSet->PrivilegeCount = 1;
	pSet->Control = PRIVILEGE_SET_ALL_NECESSARY;
	pSet->Privilege[0].Luid = TokenValue;
	pSet->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
	
	if (!PrivilegeCheck(hToken, pSet, &bHasPrivilege))
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"PrivilegeCheck"
			);

    return bHasPrivilege ? true : false;
	}


TOKEN_OWNER *GetClientTokenOwner(BOOL bImpersonate)

/*++

Routine Description:

    Return TOKEN_OWNER of client process

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we return the client sid of that token

Return Value:

	SID of client thread

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"GetClientTokenOwner" );

	BOOL bRes;

    CVssAutoWin32Handle  hToken;

	DoImpersonate(bImpersonate, hToken.ResetAndGetAddress());

    DWORD cbSid;
    bRes = ::GetTokenInformation
			(
            hToken,         //  IN HANDLE TokenHandle,
            TokenOwner,  //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
            NULL,           //  OUT LPVOID TokenInformation,
            0,              //  IN DWORD TokenInformationLength,
            &cbSid     		//  OUT PDWORD ReturnLength
            );

	BS_ASSERT( bRes == FALSE );

    DWORD dwError = GetLastError();
    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
		{
		ft.LogError(VSS_ERROR_EXPECTED_INSUFFICENT_BUFFER, VSSDBG_GEN << (HRESULT) dwError);
        ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]",
			dwError
			);
        }

    //  Allocate the buffer needed to get the Token Groups information
	TOKEN_OWNER *pToken = (TOKEN_OWNER*) new BYTE[cbSid];
    if (pToken == NULL)
		ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error.");

	//  Get the all Group SIDs in the token
	DWORD cbTokenObtained;
	bRes = ::GetTokenInformation
		(
		hToken,             //  IN HANDLE TokenHandle,
		TokenOwner,        	//  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
		pToken,            	//  OUT LPVOID TokenInformation,
		cbSid,         		//  IN DWORD TokenInformationLength,
		&cbTokenObtained 	//  OUT PDWORD ReturnLength
		);

	if ( !bRes )
        ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
            L"GetTokenInformation"
			);

    if (cbTokenObtained != cbSid)
		{
		ft.LogError(VSS_ERROR_GET_TOKEN_INFORMATION_BUFFER_SIZE_MISMATCH, VSSDBG_GEN << (INT) cbTokenObtained << (INT) cbSid);
		ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"Unexpected error. Final buffer size = %lu, original size was %lu",
			cbTokenObtained,
			cbSid
			);
        }

    return pToken;
	}



bool IsAdministrator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, true);
	}

bool IsProcessAdministrator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of an administrator

Arguments:

    none

Remarks:
    The current process is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the process is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, false);
	}



bool IsBackupOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a backup operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the groups token
	or the backup privilege is enabled

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_BACKUP_NAME, true) || IsAdministrator();
	}

bool IsRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a restore operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the token groups or
	if the restore privilege is enabled.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_RESTORE_NAME, true) || IsAdministrator();
	}


bool IsProcessBackupOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a backup operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator or
	has SE_BACKUP_NAME privilege enabled
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_BACKUP_NAME, false) || IsProcessAdministrator();
	}

bool IsProcessRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a restore operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator
	or has the SE_RESTORE_NAME privilege; false otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_RESTORE_NAME, false) || IsProcessAdministrator();
	}



// turn on a particular security privilege
HRESULT TurnOnSecurityPrivilege(LPCWSTR wszPriv)

/*++

Routine Description:

    sets the specified privilege on the process token

Arguments:

    none

Remarks:

Return Value:
	status code for operation

Thrown exceptions:
	none
--*/

    {
	HANDLE	hProcessToken = INVALID_HANDLE_VALUE;
	BOOL	bProcessTokenValid = FALSE;

	CVssFunctionTracer ft(VSSDBG_GEN, L"TurnOnSecurityPrivilege");
	try
		{
		LUID	TokenValue = {0, 0};


		bProcessTokenValid = OpenProcessToken
								(
								GetCurrentProcess(),
								TOKEN_ADJUST_PRIVILEGES,
								&hProcessToken
								);

		if (!bProcessTokenValid)
			ft.TranslateError
				(
				VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
				L"OpenProcessToken"
				);

				
		if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
			ft.TranslateError
				(
				VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
				L"LookupPrivilegeValue"
				);

		TOKEN_PRIVILEGES	NewTokenPrivileges;

		NewTokenPrivileges.PrivilegeCount           = 1;
		NewTokenPrivileges.Privileges[0].Luid       = TokenValue;
		NewTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		// AdjustTokenPrivileges succeeds even the token isn't set
		SetLastError(ERROR_SUCCESS);

		AdjustTokenPrivileges
			(	
			hProcessToken,
			FALSE,
			&NewTokenPrivileges,
			sizeof (NewTokenPrivileges),
			NULL,
			NULL
			);


        DWORD dwErr = GetLastError();
		if (dwErr != ERROR_SUCCESS)
			ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"AdjustTokenPrivileges"
				);
		}
	VSS_STANDARD_CATCH(ft)

	if (bProcessTokenValid)
		CloseHandle (hProcessToken);

    return ft.hr;
    }

// turn on backup security privilege
HRESULT TurnOnSecurityPrivilegeBackup()
	{
	return TurnOnSecurityPrivilege(SE_BACKUP_NAME);
	}

// turn on restore security privilege
HRESULT TurnOnSecurityPrivilegeRestore()
	{
	return TurnOnSecurityPrivilege(SE_RESTORE_NAME);
	}



// determine if the process is a local service
bool IsProcessLocalService()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"IsProcessLocalService");

	BYTE rgbSid[256];
	DWORD cbSid = sizeof(rgbSid);
	TOKEN_OWNER *pOwner = GetClientTokenOwner(FALSE);

	if (!CreateWellKnownSid(WinLocalServiceSid, NULL, (SID *) rgbSid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSid");
		}

	return EqualSid(pOwner->Owner, (SID *) rgbSid) ? true : false;
	}

// determine if the process is a local service
bool IsProcessNetworkService()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"IsProcessNetworkService");

	BYTE rgbSid[256];
	TOKEN_OWNER *pOwner = GetClientTokenOwner(FALSE);
	DWORD cbSid = sizeof(rgbSid);

	if (!CreateWellKnownSid(WinNetworkServiceSid, NULL, (SID *) rgbSid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSid");
		}

	return EqualSid(pOwner->Owner, (SID *) rgbSid) ? true : false;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\alloc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Alloc.cxx | Automatic allocation of diff areas
    @end

Author:

    Adi Oltean  [aoltean]   06/01/2000

Revision History:

    Name        Date        Comments

    aoltean     06/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"
#include "vssmsg.h"

//  Generated MIDL headers
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRALLOC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Constants

const WCHAR wszFileSystemNameNTFS[] = L"NTFS";

// The minimum free space for a diff area
const nRemainingFreeSpace = 20 * 1024 * 1024;


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator constructors/destructors


CVssDiffAreaAllocator::CVssDiffAreaAllocator(
    IN  VSS_ID SnapshotSetID
    ):
    m_bChangesCommitted(false),
    m_bNoChangesNeeded(false),
    m_SnapshotSetID(SnapshotSetID)
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::CVssDiffAreaAllocator");

    BS_ASSERT(SnapshotSetID != GUID_NULL);
}


CVssDiffAreaAllocator::~CVssDiffAreaAllocator()
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::~CVssDiffAreaAllocator");
    int nIndex;

    // The Rollback function should not throw.
    if (!m_bChangesCommitted && !m_bNoChangesNeeded)
        Rollback();

    // Deallocate all the volume names
    for (nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++)
        ::VssFreeString(m_arrOriginalVolumes[nIndex]);

    // Deallocate all the diff area candidates
    // This will delete the associated volume names also (which are the keys)
    for (nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++)
	    delete m_mapDiffAreaCandidates.GetValueAt(nIndex);
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Public operations

void CVssDiffAreaAllocator::AssignDiffAreas() throw(HRESULT)
/*++

Routine description:

    Assign all the diff areas for the current snapshot set.

Throws:

    VSS_E_PROVIDER_VETO
    E_UNEXPECTED

    [CVssDiffAreaAllocator::Initialize() failures]
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignDiffAreas");


    // Fill out various internal structures (like the list of original volumes)
    Initialize();

    // If no volumes to snapshot then we are done.
    if (m_arrOriginalVolumes.GetSize() == 0)
        return;

    // Find the candidates for the diff areas
    FindDiffAreaCandidates();

    // Deal with no candidates scenario... 
    // If no candidates then we will stop here and inform the user to add more NTFS disk space.
    if (m_mapDiffAreaCandidates.GetSize() == 0) {
        ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
        ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO, L"Cannot find a diff area candidate");
    }

    // Clear the non-necessary diff areas and compute the number of allocated
    // diff areas that already exist on each candidate
    ComputeExistingDiffAreasCount();

    // planning of new diff areas
    PlanNewDiffAreas();

    // effectively allocate the diff areas for the voluems to be snapshotted
    AssignPlannedDiffAreas();
}


void CVssDiffAreaAllocator::Commit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Commit");

    m_bChangesCommitted = true;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Private operations


void CVssDiffAreaAllocator::Initialize() throw(HRESULT)
/*++

Routine description:

    Initialize the internal data structures

Throws:

    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Initialize");

    // Get the list of volumes to be snapshotted
    BS_ASSERT(m_arrOriginalVolumes.GetSize() == 0);
	CVssSnapIterator snapIterator;
    while (true)
    {
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(m_SnapshotSetID);

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;

		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);

        // Ignore the snapshots that are not in the PREPARING state.
        if (ptrQueuedSnapshot->GetStatus() == VSS_SS_PREPARING) {
            // Make a copy of the volume name 
            BS_ASSERT(pProp->m_pwszOriginalVolumeName && pProp->m_pwszOriginalVolumeName[0]);
            LPWSTR wszOriginalVolumeName = NULL;
            ::VssSafeDuplicateStr( ft, wszOriginalVolumeName, pProp->m_pwszOriginalVolumeName );
            BS_ASSERT(wszOriginalVolumeName);

            if (!m_arrOriginalVolumes.Add(wszOriginalVolumeName)) {
                ::VssFreeString(wszOriginalVolumeName);
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
            }
        }
    }

    // If there are no volumes to process then make this explicit
    if (m_arrOriginalVolumes.GetSize() == 0) {
        m_bNoChangesNeeded = true;
        return;
    }
}


void CVssDiffAreaAllocator::FindDiffAreaCandidates() throw(HRESULT)
/*++

Routine description:

    Find the candidates for the diff areas
    Compute various parameters like the number of allocated diff areas on each candidate

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        - FindFirstVolume, FindNextVolume errors

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::FindDiffAreaCandidates");

	// Search between all mounted volumes
	bool bFirstVolume = true;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
	WCHAR wszVolumeName[MAX_PATH+1];
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
			}
		}

        BS_ASSERT( wszVolumeName[0] );

        // Check if the volume is NTFS
        // This is likely to fail, for example on CD-ROM drives
        DWORD dwFileSystemFlags = 0;
        WCHAR wszFileSystemNameBuffer[MAX_PATH+1];
        if (!::GetVolumeInformationW(wszVolumeName,
                NULL,   // lpVolumeNameBuffer
                0,      // nVolumeNameSize
                NULL,   // lpVolumeSerialNumber
                NULL,   // lpMaximumComponentLength
                &dwFileSystemFlags,
                wszFileSystemNameBuffer,
                MAX_PATH
                )) {
            ft.Trace( VSSDBG_SWPRV,
                      L"Warning: Error calling GetVolumeInformation on volume '%s' 0x%08lx",
                      wszVolumeName, GetLastError());
            continue;
        }

        // If the file system is not NTFS, ignore it
        if (::wcscmp(wszFileSystemNameBuffer, wszFileSystemNameNTFS) != 0) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a non-NTFS volume (%s) - %s",
                      wszVolumeName, wszFileSystemNameBuffer);
            continue;
        }

        // If the volume is read-only, ignore it
        if (dwFileSystemFlags & FILE_READ_ONLY_VOLUME) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a read-only volume (%s)", wszVolumeName);
            continue;
        }

        // Check if the volume is fixed (i.e. no CD-ROM, no removable)
        UINT uDriveType = ::GetDriveTypeW(wszVolumeName);
        if ( uDriveType != DRIVE_FIXED) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a non-fixed volume (%s) - %ud",
                      wszVolumeName, uDriveType);
            continue;
        }

        // Get its free space
        ULARGE_INTEGER ulnFreeBytesAvailable;
        ULARGE_INTEGER ulnTotalNumberOfBytes;
        ULARGE_INTEGER ulnTotalNumberOfFreeBytes;
        if (!::GetDiskFreeSpaceEx(wszVolumeName,
                &ulnFreeBytesAvailable,
                &ulnTotalNumberOfBytes,
                &ulnTotalNumberOfFreeBytes
                )){
            ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                      wszVolumeName, GetLastError());
            continue;
        }

        // Check to see if the free space is enough for at least one diff area
        if (ulnTotalNumberOfFreeBytes.QuadPart <
                (ULONGLONG)(nRemainingFreeSpace + nDefaultInitialSnapshotAllocation)) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a volume (%s) with "
                      L"insufficient free space for one allocation (%I64u)",
                      wszVolumeName, ulnFreeBytesAvailable);
            continue;
        }

        // Add the local volume as a candidate
        LPWSTR wszCandidate = NULL;
        ::VssSafeDuplicateStr(ft, wszCandidate, wszVolumeName);

        // Create the candidate object that must keep this information.
        CVssDiffAreaCandidate* pObj =
            new CVssDiffAreaCandidate(wszCandidate, ulnFreeBytesAvailable);
        if (pObj == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

        // Add the candidate object into the array
        if (!m_mapDiffAreaCandidates.Add(wszCandidate, pObj)) {
            delete pObj;
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ft.Trace( VSSDBG_SWPRV, L"Candidate added: (\'%s\', %I64u)",
                  wszCandidate, ulnFreeBytesAvailable );
    }
}


void CVssDiffAreaAllocator::ComputeExistingDiffAreasCount() throw(HRESULT)
/*++

Description:

    Compute the nunber of original volumes that keeps diff areas on this volume.
    This does not include volumes on which there are no existing shapshots.

    Stores the results in the properties of the existing candidates objects list.

WARNING:

    This method will clear the diff area settings for volumes who keep no snapshots
    (but for us it doesn't matter)

Throws:

    VSS_E_PROVIDER_VETO
        - failure in FindFirstVolume/FindNextVolume, IVssEnumObject::Next
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::ComputeExistingDiffAreasCount" );

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() != 0);

    CVsDiffArea diffobj;
	bool bFirstVolume = true;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
	WCHAR wszQueriedVolumeName[MAX_PATH+1];

	// Search between all mounted volumes
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch = ::FindFirstVolumeW( wszQueriedVolumeName, MAX_PATH);
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszQueriedVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszQueriedVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW(%p,[%s],MAX_PATH)", hSearch, wszQueriedVolumeName);
			}
		}

        BS_ASSERT( wszQueriedVolumeName[0] );

        // Initialize the diff area object
        // This might fail...
        ft.hr = diffobj.Initialize(wszQueriedVolumeName);
        if (ft.HrFailed()) {
            ft.Trace( VSSDBG_SWPRV, 
                L"INFO: Failed to initialize the diff area object on volume %s [0x%08lx]. Going with the next volume.", 
                wszQueriedVolumeName,
                ft.hr );
            continue;
	    }

        // Clear the diff area on the queried volume.
        // If succeeds, then it is clear that the queried volume does not refer anymore the current volume
        // as its diff area.
        // Also, if such a diff area was present then the clear is harmless since there are no existing snapshots.
        // on that volume
        ft.hr = diffobj.Clear();
        if (ft.HrSucceeded())
            continue;

        // Enumerate the diff area volumes for the queried volume.
        // This is likely to fail, for example on non-NTFS volumes.
        // Increment the "diff areas" counter for the corresponding diff area volume
        ft.hr = diffobj.Query( this );
        if (ft.HrFailed()) {
            ft.Trace( VSSDBG_SWPRV, 
                L"INFO: Failed to query diff areas on volume %s. Going with the next volume.", 
                wszQueriedVolumeName);
            continue;
        }
    }

    // Result of computation
    for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++) {
	    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
        ft.Trace( VSSDBG_SWPRV, L"Number of diff areas for volume '%s' = %d",
                  pObj->GetVolumeName(), pObj->GetExistingDiffAreas() );
    }
}


void CVssDiffAreaAllocator::OnDiffAreaVolume(
    IN  LPWSTR pwszDiffAreaVolumeName
    )
    
/*++

Description:

    Increment the "diff areas" counter for the corresponding diff area volume
    This routine is called for each diff area voplume for the queried volume name.

Arguments:

    pwszDiffAreaVolumeName - The diff area for the queried volume name

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::OnDiffAreaVolume");
    
    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pwszDiffAreaVolumeName);

    // If this volume is also a diff area candidate then increment the
    // associated counter of existing diff areas
    if (pObj)
        pObj->IncrementExistingDiffAreas();
}


void CVssDiffAreaAllocator::PlanNewDiffAreas() throw(HRESULT)
/*++

Description:

    Planning of new diff areas

Throws:

    VSS_E_PROVIDER_VETO
        - Not enough space for the diff area.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::PlanNewDiffAreas");

    INT nVolumesCount = m_arrOriginalVolumes.GetSize();
    BS_ASSERT(nVolumesCount > 0);
    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() > 0);

    // Repeat the allocation sequence for each volume to be snapshotted.
    for(;nVolumesCount--;) {

        // Find a diff area candidate that will remain with
        // maximum free space per hosted diff area
        INT nCandidateIndex = -1;
        double lfMaxFreeSpacePerHostedDiffArea = 0;
        for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++) {

	        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
            BS_ASSERT(pObj);

            // We try to add *another* diff area and we estimate the results.
            INT nEstimatedDiffAreas = 1 + pObj->GetPlannedDiffAreas();

            // What will be the free space if we will allocate another diff area?
            // We will ignore the allocated space for the new diff areas in order to keep
            // the algorithm simple to understand
            double lfRemainingFreeSpaceAfterAllocation = pObj->GetVolumeFreeSpace();

            // What will be the free space per hosted diff area (including estimated ones)?
            double lfFreeSpacePerHostedDiffArea =
                lfRemainingFreeSpaceAfterAllocation / (nEstimatedDiffAreas + pObj->GetExistingDiffAreas());

            // Is the current volume a better candidate?
            if (lfFreeSpacePerHostedDiffArea > lfMaxFreeSpacePerHostedDiffArea) {
                nCandidateIndex = nIndex;
                lfMaxFreeSpacePerHostedDiffArea = lfFreeSpacePerHostedDiffArea;
            }
        }

        BS_ASSERT( nCandidateIndex >= 0 );

        // We found another candidate.
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nCandidateIndex);

        // Check to see if we have enough free space per diff area
        if (lfMaxFreeSpacePerHostedDiffArea < nRemainingFreeSpace) {
            // Indicate to the user the requirement that it should provide more space.
            ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
            ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO,
                      L"Not enough free space (%.1f) on any diff area. Best bet: '%s - %.1f'",
                      lfMaxFreeSpacePerHostedDiffArea,
                      pObj->GetVolumeName(),
                      pObj->GetVolumeFreeSpace());
        }
        
        // Increment the planned diff areas
        pObj->IncrementPlannedDiffAreas();

        ft.Trace( VSSDBG_SWPRV,
            L"\r\n   New hosting candidate: '%s'. \r\n\tExisting: %d, \r\n\tplanned: %d, \r\n\tFree: (%.1f). \r\n\tRelative (%.1f)\r\n",
            pObj->GetVolumeName(),
            pObj->GetExistingDiffAreas(),
            pObj->GetPlannedDiffAreas(),
            pObj->GetVolumeFreeSpace(),
            lfMaxFreeSpacePerHostedDiffArea
            );
    }
}


// effectively allocate the diff areas for the voluems to be snapshotted
void CVssDiffAreaAllocator::AssignPlannedDiffAreas() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignPlannedDiffAreas");

    CVsDiffArea diffobj;

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() > 0);

    //
    // For each volume to be snapshotted, find its diff area
    //

    // Keep an array of properties whether a volume is auto-assigned or not
    bool bTmp = false;
    CSimpleArray<bool>    m_arrIsVolumeAutoAssigned;
    for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++)
        m_arrIsVolumeAutoAssigned.Add(bTmp);

    // For each volume to be snapshotted, check to see if we can put the diff area on the same volume
    for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++) {
        LPCWSTR wszVolumeName = m_arrOriginalVolumes[nIndex];
        BS_ASSERT( wszVolumeName && wszVolumeName[0] );

        // The current volume is a diff area candidate also?
        // If not we cannot reasingn the diff area to itself
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(wszVolumeName);
        if (pObj == NULL)
            continue;
        BS_ASSERT(::wcscmp(pObj->GetVolumeName(), wszVolumeName) == 0);

        // We have remaining planned diff areas on the same volume?
        BS_ASSERT(pObj->GetPlannedDiffAreas() >= 0);
        if (pObj->GetPlannedDiffAreas() == 0)
            continue;

        // We convert a planned diff area into an "existing" one.
        BS_ASSERT(pObj);
        pObj->DecrementPlannedDiffAreas();

        // We mark taht volume as auto-assigned
        m_arrIsVolumeAutoAssigned[nIndex] = true;

        //
        // Assign the found diff area to the snapshotted volume
        //

        // Initialize the diff area object
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.Initialize(wszVolumeName);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to initialize the diff area object 0x%08lx", ft.hr);

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.AddVolume(const_cast<LPWSTR>(wszVolumeName));
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to add the volume '%s' as the diff area for itself [0x%08lx]",
                      wszVolumeName, ft.hr);
        else
            ft.Trace( VSSDBG_SWPRV,
                      L"Assigning the diff area '%s' to itself",
                      wszVolumeName);
    }

    // For each remaining volume to be snapshotted, find its diff area
    for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++) {
        LPCWSTR wszVolumeName = m_arrOriginalVolumes[nIndex];
        BS_ASSERT( wszVolumeName && wszVolumeName[0] );

        // The current volume was treated in previous step as an auto-assigned diff area?
        // If yes we will continue with the next one
        if (m_arrIsVolumeAutoAssigned[nIndex])
            continue;

        // We will find the first available diff area candidate
        bool bFound = false;
        CVssDiffAreaCandidate* pObj = NULL;
        for(int nDiffIndex = 0; nDiffIndex < m_mapDiffAreaCandidates.GetSize(); nDiffIndex++) {

	        pObj = m_mapDiffAreaCandidates.GetValueAt(nDiffIndex);
            BS_ASSERT(pObj);

            // We have remaining planned diff areas?
            if (pObj->GetPlannedDiffAreas() > 0) {
                bFound = true;
                break;
            }
        }

        // convert a planned diff area into an "existing" one.
        BS_ASSERT(bFound);
        BS_ASSERT(pObj);
        pObj->DecrementPlannedDiffAreas();

        //
        // Assign the found diff area to the snapshotted volume
        //

        // Initialize the diff area object
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.Initialize(wszVolumeName);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to initialize the diff area object 0x%08lx", ft.hr);

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.AddVolume(const_cast<LPWSTR>(pObj->GetVolumeName()));
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to add the volume '%s' as the diff area for '%s' [0x%08lx]",
                      pObj->GetVolumeName(), wszVolumeName, ft.hr);
        else
            ft.Trace( VSSDBG_SWPRV,
                      L"Assigning the diff area '%s' to the volume '%s'",
                      wszVolumeName, pObj->GetVolumeName());
    }

    // Check if all planned diff areas were used.
    for(int nDiffIndex = 0; nDiffIndex < m_mapDiffAreaCandidates.GetSize(); nDiffIndex++) {
	    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nDiffIndex);
        BS_ASSERT(pObj);

        // We have remaining planned diff areas?
        if (pObj->GetPlannedDiffAreas() != 0)
            ft.Trace( VSSDBG_SWPRV,
                      L"FALSE ASSERT: remaining planned diff areas (%d) on '%s'",
                      pObj->GetPlannedDiffAreas(), pObj->GetVolumeName() );
    }
}


void CVssDiffAreaAllocator::Rollback()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Rollback");

    BS_ASSERT(m_bChangesCommitted == false);
    BS_ASSERT(m_bNoChangesNeeded == false);

    try
    {
        CVsDiffArea diffobj;

        // For each volume to be snapshoted, rollback the diff area assignments
        for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++) {
            LPCWSTR wszVolumeName = m_arrOriginalVolumes[nIndex];
            BS_ASSERT( wszVolumeName && wszVolumeName[0] );

            // Initialize the diff area object. Ignore the errors
            ft.hr = diffobj.Initialize(wszVolumeName);
            if (ft.HrFailed())
                ft.Trace( VSSDBG_SWPRV,
                          L"Failed to initialize the diff area object on volume '%s' 0x%08lx",
                          wszVolumeName, ft.hr);
            else {
                // Clear the diff area on the queried volume.  Ignore the errors
                ft.hr = diffobj.Clear();
                if (ft.HrFailed())
                    ft.Trace( VSSDBG_SWPRV,
                              L"Failed to clear the diff area object on volume '%s' 0x%08lx",
                              wszVolumeName, ft.hr);
            }
        }
    }
    VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaCandidate methods


CVssDiffAreaCandidate::CVssDiffAreaCandidate(
    IN  LPCWSTR wszVolumeName,       // Transfer ownership!
    IN  ULARGE_INTEGER ulFreeSpace
    ):
    m_wszVolumeName(wszVolumeName),
    m_ulFreeSpace(ulFreeSpace),
    m_nPlannedDiffAreas(0),
    m_nExistingDiffAreas(0)
{
}


CVssDiffAreaCandidate::~CVssDiffAreaCandidate()
{
    ::VssFreeString(m_wszVolumeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   02/01/2000

Revision History:

    Name        Date        Comments

    aoltean     02/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"


#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDELEC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots that match the proper filter criteria.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then S_OK is returned.

Throws:

    E_ACCESSDENIED
        - The user is not an administrator (this should be the SYSTEM account).
    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::DeleteSnapshots" );

    try
    {
    	// Zero out parameters
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

		// Check arguments
		BS_ASSERT(plDeletedSnapshots);
		if (plDeletedSnapshots == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plDeletedSnapshots == NULL");
		BS_ASSERT(pNondeletedSnapshotID);
		if (pNondeletedSnapshotID == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pNondeletedSnapshotID == NULL");

		// Delete snapshots based on the given filter
        switch(eSourceObjectType) {
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
    		ft.hr = InternalDeleteSnapshots(SourceObjectId,
    					eSourceObjectType,
    					plDeletedSnapshots,
    					pNondeletedSnapshotID);
			break;
			
		default:
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible type %d", eSourceObjectType);
		}
		
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


HRESULT CVsSoftwareProvider::InternalDeleteSnapshots(
    IN      VSS_ID			SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::InternalDeleteSnapshotSet" );
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

    try
    {
		BS_ASSERT(*plDeletedSnapshots == 0);
		BS_ASSERT(*pNondeletedSnapshotID == GUID_NULL);

		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
		CVssIOCTLChannel volumeIChannel2;	// For snapshots deletion
		CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		bool bObjectFound = false;

		// Search for snapshots in all mounted volumes
		while(true) {
		
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
        				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

			// Check if the snapshot(s) within this snapshot set is belonging to that volume
			// Open a IOCTL channel on that volume
			// Eliminate the last backslash in order to open the volume
			// The call will throw on error
			ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE);
			if (ft.HrFailed()) {
			    ft.hr = S_OK;
			    continue;
			}

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.

			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// Get the length of snapshot names multistring
			ULONG ulMultiszLen;
			volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
			// Try to find the snapshot with the corresponding Id
			DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif
            bool bFirstSnapshot = true;
			while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {

                // In this version we will have only one snapshot per volume
			    if (!bFirstSnapshot) {
    			    BS_ASSERT(false);
    			    break;
			    } else {
    			    bFirstSnapshot = false;
			    }
			    
				// Compose the snapshot name in a user-mode style
				WCHAR wszUserModeSnapshotName[MAX_PATH];
                ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                    wszGlobalRootPrefix, pwszSnapshotName );
					
				// Open that snapshot and verify if it has our ID
                // If we fail we do not throw since the snapshot may be deleted in the meantime
                // Do NOT eliminate the trailing backslash
                // The call will NOT throw on error
				ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false);
                if (ft.HrFailed()) {
                    ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                    continue;
                }

				// Get the application buffer
                // If we fail we do not throw since the snapshot may be deleted in the meantime
				ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
                if (ft.HrFailed()) {
                    ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                              wszUserModeSnapshotName);
                    continue;
                }

				// Get the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0) {
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
            	    BS_ASSERT(false);
					continue;
				}

                // Unpacking the app info ID
            	VSS_ID AppinfoId;
            	snapshotIChannel.Unpack(ft, &AppinfoId);
            	if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
            	{
            	    BS_ASSERT(false);
					continue;
                }
            	
				// Get the snapshot Id
				VSS_ID CurrentSnapshotId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

				// Get the snapshot set Id
				VSS_ID CurrentSnapshotSetId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

                switch(eSourceObjectType) {
        		case VSS_OBJECT_SNAPSHOT_SET:
    				// Check if this snapshot belongs to the snapshot set.
    				if (CurrentSnapshotSetId != SourceObjectId) 
    					continue;
    				break;

        		case VSS_OBJECT_SNAPSHOT:
    				if (CurrentSnapshotId != SourceObjectId)
    					continue;
        			break;
        			
        		default:
        			BS_ASSERT(false);
        			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Incompatible type %d", eSourceObjectType);
        		}

				// We found a snapshot belonging to the set.
				bObjectFound = true;

				// Set in order to deal with failure cases
				(*pNondeletedSnapshotID) = CurrentSnapshotId;
				
				// We found a snapshot. 
				volumeIChannel2.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);

				// Delete the snapshot
				volumeIChannel2.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
				
				(*plDeletedSnapshots)++;
			}

#ifdef _DEBUG
			// Check if all strings were browsed correctly
			DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
			BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
		}

		if (!bObjectFound)
			ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Object not found");
    }
    VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	// Delete the temporary snapshot name
	::VssFreeString(pwszSnapshotName);

	if (ft.HrSucceeded())
		(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\diff.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Diff.cxx | Diff area object implementation
    @end

Author:

    Adi Oltean  [aoltean]   01/24/2000

Revision History:

    Name        Date        Comments

    aoltean     01/24/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL headers
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDIFFC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Operations


CVsDiffArea::CVsDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsDiffArea::CVsDiffArea" );
}


CVsDiffArea::~CVsDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsDiffArea::~CVsDiffArea" );
}


HRESULT CVsDiffArea::Initialize(
    IN      LPCWSTR pwszVolumeMountPoint	// DO NOT transfer ownership
    )
/*++

Routine description:

    Initialize the internal structure for a new diff area.

Return codes:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW
        - Error in opening the IOCTL channel
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Initialize" );

    try
    {
		// Test the arguments
		if ((pwszVolumeMountPoint == NULL) ||
			(pwszVolumeMountPoint[0] == L'\0')) {
			BS_ASSERT(false);
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"NULL volume mount point");
		}

    	// Convert the volume mount point into a volume name
    	WCHAR wszVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
				wszVolumeName, ARRAY_LEN(wszVolumeName)))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
		BS_ASSERT(::wcslen(wszVolumeName) != 0);
    		
		// Opening the channel
        // (if already opened then it will be closed automatically)
		// Eliminate the last backslash from the volume name.
		// The call will throw on error
		// Warning: Always do the logging 
		m_volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Interface methods

STDMETHODIMP CVsDiffArea::AddVolume(                      			
    IN      VSS_PWSZ pwszVolumeMountPoint						
    )
/*++

Routine description:

    Add a volume to the diff area.
    
Return codes:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, ConvertVolMgmtVolumeNameIntoKernelObject
        - Error in sending the IOCTL
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::AddVolume" );

    try
    {
		// Test arguments
        if (pwszVolumeMountPoint == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		BS_ASSERT(m_volumeIChannel.IsOpen());

    	// Convert the volume mount point into a volume name
    	WCHAR wszVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
				wszVolumeName, ARRAY_LEN(wszVolumeName)))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
		BS_ASSERT(::wcslen(wszVolumeName) != 0);

		if (!::ConvertVolMgmtVolumeNameIntoKernelObject(wszVolumeName))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    E_UNEXPECTED, VSS_E_PROVIDER_VETO,
			    L"ConvertVolMgmtVolumeNameIntoKernelObject( %s, ...)", wszVolumeName);

		// Send the IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA ioctl
		// Logs the error, if any, as a provider error.
    	m_volumeIChannel.PackSmallString(ft, wszVolumeName);
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA, true, VSS_ICHANNEL_LOG_PROV);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsDiffArea::Query(									
    IN OUT  CVssDiffAreaAllocator* pObj
    )												
    
/*++

Routine description:

    Query the diff area volumes for the current volume.
    and call CVssDiffAreaAllocator::OnDiffAreaVolume 
    for each volume in the diff area.
    
Return codes:

    E_OUTOFMEMORY
        - lock failures
    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, GetVolumeGuid
    E_UNEXPECTED
        - Nothing to log. (wrong volume) The result is anyway ignored by the client.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Query" );

	LPWSTR pwszVolumeName = NULL;
	
    try
    {
        // Initialize [out] arguments
        BS_ASSERT( pObj );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Get the list of volumes that are part of the diff area
		// Do not perform any logging.
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA);

		// Get the length of snapshot names multistring
		ULONG ulMultiszLen;
		m_volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
		// Try to find the snapshot with the corresponding Id
		DWORD dwInitialOffset = m_volumeIChannel.GetCurrentOutputOffset();
#endif

		while(m_volumeIChannel.UnpackZeroString(ft, pwszVolumeName))
		{
			// Compose the volume name in a user-mode style
			WCHAR wszMountPoint[MAX_PATH];
			if (::_snwprintf(wszMountPoint, MAX_PATH - 1,
					L"%s%s\\", wszGlobalRootPrefix, pwszVolumeName) < 0)
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory." );

			// Get the mount point for the volume name
			// If an error occurs then DO the logging.
	    	WCHAR wszUserModeVolumeName[MAX_PATH];
			if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
					wszUserModeVolumeName, MAX_PATH))
    			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszMountPoint);
			BS_ASSERT(::wcslen(wszUserModeVolumeName) != 0);

            // Invoke the callback
            pObj->OnDiffAreaVolume(wszUserModeVolumeName);
		}

#ifdef _DEBUG
		// Check if all strings were browsed correctly
		DWORD dwFinalOffset = m_volumeIChannel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
    }
    VSS_STANDARD_CATCH(ft)

    ::VssFreeString(pwszVolumeName);

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::Clear(                      				
    )												
/*++

Routine description:

    Add a volume to the diff area.
    
Return codes:

    E_UNEXPECTED
        - Error in sending the IOCTL (ignored anyway in the client)
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Clear" );

    try
    {
		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Try to clear the diff area on the current volume
		// Do not log anything at this point!
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_CLEAR_DIFF_AREA);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\find.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Find.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRFINDC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::EnumerateSnapshots(
    IN  bool bSearchBySnapshotID,
    IN  VSS_ID SnapshotID,
	VSS_OBJECT_PROP_Array* pArray
	) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots

Throws:

    VSS_E_PROVIDER_VETO
        - On runtime errors
    E_OUTOFMEMORY

--*/

{	
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EnumerateSnapshots");
		
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

	try
	{
		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;
		CVssIOCTLChannel snapshotIChannel;
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		while(true) {
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
        				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

			// Check if the snapshot is belonging to that volume
			// Open a IOCTL channel on that volume
			// Eliminate the last backslash in order to open the volume
			// On error the call will throw and it will log it
			ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}
			

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.
			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// Get the length of snapshot names multistring
			ULONG ulMultiszLen;
			volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
			// Try to find the snapshot with the corresponding Id
			DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

            bool bFirstSnapshot = true;
			while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {
			    
                // In this version we will have only one snapshot per volume
			    if (!bFirstSnapshot) {
    			    BS_ASSERT(false);
    			    break;
			    } else {
    			    bFirstSnapshot = false;
			    }
			    
    			// Compose the snapshot name in a user-mode style
    			WCHAR wszUserModeSnapshotName[MAX_PATH];
                ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                    wszGlobalRootPrefix, pwszSnapshotName );
				
				// Open that snapshot 
				// Do not eliminate the trailing backslash
				// Do not throw on error
				ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false);
				if (ft.HrFailed()) {
					ft.Warning( VSSDBG_SWPRV, L"Warning: Error opening the snapshot device name %s [0x%08lx]",
								wszUserModeSnapshotName, ft.hr );
					continue;
				}

				// Send the IOCTL to get the application buffer
				ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
				if (ft.HrFailed()) {
					ft.Warning( VSSDBG_SWPRV,
								L"Warning: Error sending the query IOCTL to the snapshot device name %s [0x%08lx]",
								wszUserModeSnapshotName, ft.hr );
					continue;
				}

				// Unpack the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0) {
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
            	    BS_ASSERT(false);
					continue;
				}

                // Unpacking the app info ID
            	VSS_ID AppinfoId;
            	snapshotIChannel.Unpack(ft, &AppinfoId);
            	if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
            	{
            	    BS_ASSERT(false);
					continue;
                }
            	
				// Get the snapshot Id
				VSS_ID CurrentSnapshotId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

                // If we are filtering, ignore the rest...
                if (bSearchBySnapshotID)
                    if (SnapshotID != CurrentSnapshotId)
                        continue;

				// Get the snapshot set Id
				VSS_ID CurrentSnapshotSetId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);
				
                //
				// Process the snapshot that was just found
				//
				
    			// Initialize an empty snapshot properties structure
    			VSS_OBJECT_PROP_Ptr ptrSnapProp;
    			ptrSnapProp.InitializeAsSnapshot( ft,
    				CurrentSnapshotId,
    				CurrentSnapshotSetId,
    				0,
    				wszUserModeSnapshotName,
    				wszVolumeName,
    				NULL,
    				NULL,
    				NULL,
    				NULL,
    				VSS_SWPRV_ProviderId,
    				0,
    				0,
    				VSS_SS_UNKNOWN);

    			// Get the snapshot structure
    			VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
    			BS_ASSERT(pObj);
    			VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

    			// Load the rest of properties
    			// Do not load the Name and the Original volume name fields
    			// twice since they are already known
    			LoadStructure( snapshotIChannel, pSnap, true );

            	// Get the original volume name and Id
        		CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
        		    snapshotIChannel, 
        		    &(pSnap->m_pwszOriginalVolumeName));

            	// Get the timestamp
            	CVssQueuedSnapshot::LoadTimestampIoctl(
            	    snapshotIChannel, 
            	    &(pSnap->m_tsCreationTimestamp));
    			
    			if (!pArray->Add(ptrSnapProp))
    				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
    						  L"Cannot add element to the array");

    			// Reset the current pointer to NULL
    			ptrSnapProp.Reset(); // The internal pointer was detached into pArray.
			}

#ifdef _DEBUG
			// Check if all strings were browsed correctly
			DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
			BS_ASSERT( (dwFinalOffset - dwInitialOffset == ulMultiszLen));
#endif
		}
	}
	VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	::VssFreeString(pwszSnapshotName);

	if (ft.HrFailed())
		ft.Throw( VSSDBG_SWPRV, ft.hr, L"Error while searching the snapshot 0x%08lx", ft.hr);
}


bool CVssQueuedSnapshot::FindPersistedSnapshotByID(
    IN  VSS_ID SnapshotID,
    OUT LPWSTR * ppwszSnapshotDeviceObject
    ) throw(HRESULT)

/*++

Description:

	Finds a snapshot (and its device name) based on ID.

Throws:

    E_OUTOFMEMORY

    [EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors (like Unpack)
        E_OUTOFMEMORY    

--*/
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::FindPersistedSnapshotByID");
		
	BS_ASSERT(SnapshotID != GUID_NULL);
	if (ppwszSnapshotDeviceObject != NULL) {
    	BS_ASSERT((*ppwszSnapshotDeviceObject) == NULL);
	}

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
    if (pArray == NULL)
        ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
    BS_ASSERT(pArrayItf);

    // Put into the array only one element.
    EnumerateSnapshots(
	    true,
    	SnapshotID,
    	pArray
    	);

    // Extract the element from the array.
    if (pArray->GetSize() == 0)
    	return false;

    if (ppwszSnapshotDeviceObject) {
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);
    	BS_ASSERT(pSnap->m_pwszSnapshotDeviceObject);
    	::VssSafeDuplicateStr(ft, (*ppwszSnapshotDeviceObject), 
    	    pSnap->m_pwszSnapshotDeviceObject);
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\persist.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Persist.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


Storage Format for all structures:

	The snapshot structures for the MS Software Snapshot Provider
	have the following format:

	+-----------------+
	|  AppInfo GUID   |   GUID: VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot ID     |   GUID: Snapshot ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot Set ID |   GUID: Snapshot Set ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshots count |   LONG: Snapshots count in the snapshot set.
	+-----------------+


Storage place:

	typedef struct _VSS_SNAPSHOT_PROP {
		VSS_ID			m_SnapshotId;						//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	We need a special IOCTL in the future
		VSS_ID			m_SnapshotSetId;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	Mentioned above
		LONG			m_lSnapshotsCount;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		VSS_PWSZ		m_pwszSnapshotDeviceObject; 		//	None						IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS	None
		VSS_PWSZ		m_pwszOriginalVolumeName;			//	LoadOriginalVolumeNameIoctl	IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME None									
		VSS_ID			m_ProviderId;						//	None																None 									Always the Software Provider ID
		LONG            m_lSnapshotAttributes;              //  None                                                                                                        Always zero
		VSS_TIMESTAMP	m_tsCreationTimestamp;				//	LoadTimestampIoctl		    None (driver)		                    IOCTL_VOLSNAP_QUERY_CONFIG_INFO
		VSS_SNAPSHOT_STATE	m_eStatus;						//	None.                                                                                                       Always VSS_SS_CREATED after creation
	} VSS_SNAPSHOT_PROP, *PVSS_SNAPSHOT_PROP;				

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPERSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::SaveSnapshotPropertiesIoctl() throw(HRESULT)

/*++

Description:

	This function will save the properties related to the snapshot

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveSnapshotPropertiesIoctl");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Open the snapshot channel, if needed.
	// It will log on error.
	OpenSnapshotChannel();

	// Pack the snapshot structure
	SaveStructure(m_snapIChannel, pProp);

	// send the IOCTL
	// It will log on error...
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::SaveStructure(
    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp
    ) throw(HRESULT)

/*++

Description:

	This function will save the properties related to the snapshot in the given IOCTL channel

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveStructure");

    BS_ASSERT(pProp);
    BS_ASSERT(channel.IsOpen());

	// Pack the length of the entire buffer
	PVOID pulBufferLength = channel.Pack(ft, (ULONG)0 ); // unknown right now
	
	// Start counting entire buffer length
	DWORD dwInitialOffset = channel.GetCurrentInputOffset();
	
	// Pack the AppInfo ID
	VSS_ID AppinfoId = VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU;
	channel.Pack(ft, AppinfoId);
	
	// Pack the Snapshot ID
	channel.Pack(ft, pProp->m_SnapshotId);
	
	// Pack the Snapshot Set ID
	channel.Pack(ft, pProp->m_SnapshotSetId);
	
	// Pack the number of snapshots in this snapshot set
	channel.Pack(ft, pProp->m_lSnapshotsCount);

	// Compute the entire buffer length and save it.
	// TBD: move to ULONG
	DWORD dwFinalOffset = channel.GetCurrentInputOffset();
	
	BS_ASSERT( dwFinalOffset > dwInitialOffset );
	DWORD dwBufferLength = dwFinalOffset - dwInitialOffset;
	if ( dwBufferLength > (DWORD)((USHORT)(-1)) )
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
				L"Error: the buffer length cannot be stored in a USHORT %ld", dwBufferLength );
				
	ULONG ulBufferLength = (ULONG)dwBufferLength;
	BS_ASSERT( pulBufferLength );
	::CopyMemory(pulBufferLength, &ulBufferLength, sizeof(ULONG));
	BS_ASSERT( (DWORD)ulBufferLength == dwBufferLength );
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::LoadXXX methods
//



void CVssQueuedSnapshot::LoadSnapshotProperties() throw(HRESULT)

/*++

Description:

	This method loads various properties of a snapshot.
	It can call:
		- LoadDeviceNameFromID to load the device name
		- Load the properties kept in the Application data
		- LoadOriginalVolumeIoctl for getting the original volume name

	If bGetOnly == true then this method was called in a Get call.
	Otherwise it was called in a Set call.

Throws:

    E_OUTOFMEMORY
    VSS_E_OBJECT_NOT_FOUND
        - The snapshot with this ID was not found.

    [FindPersistedSnapshotByID() failures]
        E_OUTOFMEMORY

        [EnumerateSnapshots() failures]
            VSS_E_PROVIDER_VETO
                - On runtime errors (like Unpack)
            E_OUTOFMEMORY  

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadSnapshotProperties");
		
	// Get the snapshot properties structure
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Assume that the Snapshot is completed
	BS_ASSERT(!IsDuringCreation());
	BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);
	
	// If the device name is not completed, search for it
	if (pProp->m_pwszSnapshotDeviceObject == NULL)
	{
		// Try to find a created snapshot with this ID
    	BS_ASSERT(!IsDuringCreation());
		bool bFound = CVssQueuedSnapshot::FindPersistedSnapshotByID(
		    pProp->m_SnapshotId, 
		    &(pProp->m_pwszSnapshotDeviceObject)
		    );

		// Handle the "snapshot not found" special error
		if (!bFound)
			ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
					L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
					GUID_PRINTF_ARG(pProp->m_SnapshotId) );
		BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
	}

	// Load the needed fields saved in snapshot header and standard structure
	// Open the snapshot channel, if needed.
	OpenSnapshotChannel();

	// send the IOCTL.
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);

	// Unpack the snapshot structure
	LoadStructure(m_snapIChannel, pProp);

	// Get the original volume name
	CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
	    m_snapIChannel, 
	    &(pProp->m_pwszOriginalVolumeName));

	// Get the timestamp
	CVssQueuedSnapshot::LoadTimestampIoctl(
	    m_snapIChannel, 
	    &(pProp->m_tsCreationTimestamp));
}


void CVssQueuedSnapshot::LoadStructure(
    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp,
	IN  bool bIDsAlreadyLoaded /* = false */
    ) throw(HRESULT)

/*++

Description:

	This function will load the properties related to the snapshot from the given IOCTL channel

Arguments:

    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp,
	IN  bool bIDsAlreadyLoaded = false  // If true, do not load the buffer length and the IDs

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadStructure");

	ULONG ulBufferLength = 0;
    DWORD dwInitialOffset = 0;

    // Set the properties that have a constant value.
    pProp->m_eStatus = VSS_SS_CREATED;

    // if IDs not loaded yet
    if (!bIDsAlreadyLoaded) {
    	// Unpack the length of the entire buffer
    	channel.Unpack(ft, &ulBufferLength );
    	
    	// Start counting entire buffer length, for checking
    	dwInitialOffset = channel.GetCurrentOutputOffset();
    	
    	// Unpack the Appinfo ID
    	VSS_ID AppinfoId;
    	channel.Unpack(ft, &AppinfoId);
    	if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
    	{
    	    BS_ASSERT(false);
    	    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown app info " WSTR_GUID_FMT, GUID_PRINTF_ARG(AppinfoId));
    	}
    	
    	// Unpack the Snapshot ID
    	channel.Unpack(ft, &(pProp->m_SnapshotId));
    	
    	// Unpack the Snapshot Set ID
    	channel.Unpack(ft, &(pProp->m_SnapshotSetId));
    }

    // Unpack the snapshots count
    channel.Unpack(ft, &(pProp->m_lSnapshotsCount) );

    if (bIDsAlreadyLoaded == false) {
		// Compute the entire buffer length and check it.
#ifdef _DEBUG
		DWORD dwFinalOffset = channel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset > dwInitialOffset );
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulBufferLength );
#endif
    }
}



void CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
    IN  CVssIOCTLChannel & snapshotIChannel,
    OUT LPWSTR * ppwszOriginalVolumeName
    ) throw(HRESULT)

/*++

Description:

	Load the original volume name and ID.
	Uses IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures (like OpenSnapshotChannel, GetVolumeNameForVolumeMountPointW)
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");
	LPCWSTR pwszDeviceVolumeName = NULL;

	try
	{
	    BS_ASSERT(ppwszOriginalVolumeName);
	    
    	// send the IOCTL.
    	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, 
    	    true, VSS_ICHANNEL_LOG_PROV);

    	// Load the Original volume name
    	snapshotIChannel.UnpackSmallString(ft, pwszDeviceVolumeName);

    	// Get the user-mode style device name
    	WCHAR wszVolNameUsermode[MAX_PATH];
    	if (::_snwprintf(wszVolNameUsermode, MAX_PATH - 1,
    			L"%s%s\\", wszGlobalRootPrefix, pwszDeviceVolumeName) < 0)
    		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory" );

    	// Get the mount point for the original volume
    	WCHAR wszMPMVolumeName[MAX_PATH];
    	BOOL bSucceeded = ::GetVolumeNameForVolumeMountPointW(
    							wszVolNameUsermode,
    							wszMPMVolumeName, MAX_PATH );			
    	if (!bSucceeded)
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszVolNameUsermode);

        ::VssFreeString(*ppwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, *ppwszOriginalVolumeName, wszMPMVolumeName);
    }
	VSS_STANDARD_CATCH(ft)

	::VssFreeString(pwszDeviceVolumeName);

	if (ft.HrFailed())
	    ft.Throw( VSSDBG_SWPRV, ft.hr, L"Exception detected");
}


void CVssQueuedSnapshot::LoadTimestampIoctl(
    IN  CVssIOCTLChannel &  snapshotIChannel,
    OUT VSS_TIMESTAMP    *  pTimestamp
    ) throw(HRESULT)

/*++

Description:

	Load the timestamp
	Uses IOCTL_VOLSNAP_QUERY_CONFIG_INFO.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");

    BS_ASSERT(pTimestamp);
    
	// send the IOCTL.
	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, 
	    true, VSS_ICHANNEL_LOG_PROV);

	// Load the attributes
	ULONG ulAttributes = 0;
	snapshotIChannel.Unpack(ft, &ulAttributes);

	// Load the reserved field
	ULONG ulReserved = 0;
	snapshotIChannel.Unpack(ft, &ulReserved);

	// Load the timestamp
	BS_ASSERT(sizeof(LARGE_INTEGER) == sizeof(*pTimestamp));
	snapshotIChannel.Unpack(ft, pTimestamp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     08/17/1999  Change CommitSnapshots to CommitSnapshot
    aoltean     09/23/1999  Using CComXXX classes for better memory management
                            Renaming back XXXSnapshots -> XXXSnapshot
    aoltean     09/26/1999  Returning a Provider Id in OnRegister
    aoltean     09/09/1999  Adding PostCommitSnapshots
                            dss->vss
	aoltean		09/20/1999	Making asserts more cleaner.
	aoltean		09/21/1999	Small renames

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diff.hxx"
#include "alloc.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPROVC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Global Definitions

CVssCriticalSection CVsSoftwareProvider::m_cs;

CVssDLList<CVssQueuedSnapshot*>	 CVssQueuedSnapshot::m_list;


/////////////////////////////////////////////////////////////////////////////
//  Definitions


STDMETHODIMP CVsSoftwareProvider::SetContext(
	IN		LONG     lContext
    )
/*++

Routine description:

    Implements IVsSoftwareProvider::SetContext

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsSoftwareProvider::SetContext" );

    return ft.hr;
    UNREFERENCED_PARAMETER(lContext);
}


STDMETHODIMP CVsSoftwareProvider::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ		pwszVolumeName
    )

/*++

Description:

	Creates a Queued Snapshot object to be committed later.

Algorithm:

	1) Creates an internal VSS_SNAPSHOT_PROP structure that will keep most of the properties.
	2) Creates an CVssQueuedSnapshot object and insert it into the global queue of snapshots pending to commit.
	3) Set the state of the snapshot as PREPARING.
	4) If needed, create the snapshot object and return it to the caller.

Remarks:

	The queued snapshot object keeps a reference count. At the end of this function it will be:
		1 = the queued snap obj is reffered by the global queue (if no snapshot COM object was returned)
		2 = reffered by the global queue and by the returned snapshot COM object

Called by:

	IVssCoordinator::AddToSnapshotSet

Error codes:

    VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        - Volume not supported by provider.
    VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        - Maximum number of snapshots reached.
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid arguments

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::BeginPrepareSnapshot" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT 	L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT 	L"\n"
             L"  VolumeName = %s,\n"
             L"  ppSnapshot = %p,\n",
             GUID_PRINTF_ARG( SnapshotId ),
             GUID_PRINTF_ARG( SnapshotSetId ),
             pwszVolumeName);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
        if ( pwszVolumeName == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if ( SnapshotId == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Snapshot ID is NULL");

        if (m_ProviderInstanceID == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"The Provider instance ID could not be generated");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        // Check to see if the volume is supported. 
        // This may throw VSS_E_OBJECT_NOT_FOUND or even VSS_E_PROVIDER_VETO if an error occurs.
        //
        LONG lVolAttr = GetVolumeInformation(pwszVolumeName);
        if ((lVolAttr & VSS_VOLATTR_SUPPORTED) == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER, L"Volume not supported");

        //
        // Check to see if the volume already has snapshots
        //
        if ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED, L"Maximum number of snapshots reached");

        //
        //  Reset the provider interface state
        //

		// Create the structure that will keep the prepared snapshot state.
		VSS_OBJECT_PROP_Ptr ptrSnapshot;
		ptrSnapshot.InitializeAsSnapshot( ft,
			SnapshotId,
			SnapshotSetId,
			0,
			NULL,
			pwszVolumeName,
			NULL,
			NULL,
			NULL,
			NULL,
			VSS_SWPRV_ProviderId,
			0,
			0,
			VSS_SS_PREPARING
			);

		// Create the snapshot object. After this assignment the ref count becomes 1.
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnap = new CVssQueuedSnapshot(
            ptrSnapshot, m_ProviderInstanceID);
		if (ptrQueuedSnap == NULL)
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

		// The structure was detached into the queued object
		// since the ownership was passed to the constructor.
		ptrSnapshot.Reset();

		// Add the snapshot object to the global queue. No exceptions should be thrown here.
		// The reference count will be 2.
		ptrQueuedSnap->AttachToGlobalList();

        // The destructor for the smart pointer will be called. The reference count will be 1
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareProvider::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as a rendez-vous method
    in order to finish the prepare phase for snapshots
    (like ending the background prepare tasks or performing the lengthly operations before
    issuing the snapshots freeze).

	This function acts on the given snapshot set (i.e. to call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
    on each snapshotted volume)

Algorithm:

	For each preparing snapshot (but not prepared yet) in this snapshot set:
		2) Call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_PREPARED

	Compute the number of prepared snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the first phase (i.e. EndPrepare All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many EndPrepareSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after PrepareSnapshots therefore the state of all snapshots must be PREPARING before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::EndPrepareSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        // Allocate the diff areas
        //

        CVssDiffAreaAllocator allocator(SnapshotSetId);

        // Compute all new diff areas
        // This method may throw
        allocator.AssignDiffAreas();

        //
        // Change the state for the existing snapshots
        //

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARING:

                // Remark - we are supposing here that only one snaphsot set can be 
                // in progress. We are not checking again if the volume has snapshots.

				// Mark the state of this snapshot as failed
                // in order to correctly handle the state
				ptrQueuedSnapshot->MarkAsProcessingPrepare();

				// Open the volume IOCTL channel for that snapshot.
				ptrQueuedSnapshot->OpenVolumeChannel();
					
				// Send the IOCTL_VOLSNAP_AUTO_CLEANUP ioctl.
				ptrQueuedSnapshot->AutoDeleteIoctl();

				// Send the IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT ioctl.
				ptrQueuedSnapshot->PrepareForSnapshotIoctl();

				// Mark the snapshot as prepared
				ptrQueuedSnapshot->MarkAsPrepared();
				break;

			case VSS_SS_PREPARED:

				// Snapshot was already prepared in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }

        // Commit all diff areas allocations
        // (otherwise the diff areas changes will be rollbacked in destructor)
        allocator.Commit();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to pre-commit all snapshots
	on the given snapshot set

Algorithm:

	For each prepared snapshot (but not precommitted yet) in this snapshot set:
		1) Change the state of the snapshot to VSS_SS_PRECOMMITTED

	Compute the number of pre-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordiantor::DoSnapshotsSet in the second phase (i.e. Pre-Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many PreCommitSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after EndPrepareSnapshots therefore the state of all snapshots must be PREPARED before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PreCommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARED:

				// Mark the snapshot as processing pre-commit
				ptrQueuedSnapshot->MarkAsProcessingPreCommit();

				// Mark the snapshot as pre-committed
                // Do nothing in Babbage provider
				ptrQueuedSnapshot->MarkAsPreCommitted();

				break;

			case VSS_SS_PRECOMMITTED:

				// Snapshot was already pre-committed in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to commit all snapshots
	on the given snapshot set (i.e. to call IOCTL_VOLSNAP_COMMIT_SNAPSHOT on each snapshotted volume)

Algorithm:

	For each precommitted (but not yet committed) snapshot in this snapshot set:
		2) Call IOCTL_VOLSNAP_COMMIT_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_COMMITTED

	Return the number of committed snapshots, if success.
	Otherwise return 0 (even if some snapshots were committed).

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is already holding writes on snapshotted volumes.
	- The coordinator may issue many CommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::CommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Commit the snapshot, if not failed in pre-commit phase.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PRECOMMITTED:

				// Mark the snapshot as processing commit
				ptrQueuedSnapshot->MarkAsProcessingCommit();

				// Send the IOCTL_VOLSNAP_COMMIT_SNAPSHOT ioctl.
				ptrQueuedSnapshot->CommitSnapshotIoctl();

				// Mark the snapshot as committed
				ptrQueuedSnapshot->MarkAsCommitted();
				break;

			case VSS_SS_COMMITTED:

				// Commit was already done.
				// The provider may receive many CommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator as a last phase after commit for all snapshots
	on the given snapshot set

Algorithm:

	For each committed snapshot in this snapshot set:
		1) Call IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. The purpose of this
			IOCTL is to get the Snapshot Device object name.
		2) Create a unique snapshot ID
		3) Change the state of the snapshot to VSS_SS_CREATED
		4) Set the "number of committed snapshots" attribute of the snapshot set
		5) Save the snapshot properties using the IOCTL_VOLSNAP_SET_APPLICATION_INFO ioctl.
		6) If everything is OK then remove all snapshots from the global list.

	Keep the number of post-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots), after releasing writes
	by Lovelace

Remarks:

	- While calling this, Lovelace is not holding writes anymore.
	- The coordinator may issue many PostCommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PostCommitSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				  L"  SnapshotSetId = " WSTR_GUID_FMT L" \n"
				  L"  lSnapshotsCount = %ld",
				  GUID_PRINTF_ARG( SnapshotSetId ),
				  lSnapshotsCount);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		if ( lSnapshotsCount < 0 )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"lSnapshotsCount < 0");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		// On each committed snapshot store the lSnapshotsCount
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Get the snapshot volume name and set the snapshot data.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_COMMITTED:

				// Mark the snapshot as processing post-commit
				ptrQueuedSnapshot->MarkAsProcessingPostCommit();

				// Remark: the snapshot device name will not be persisted

				// Fill the required properties - BEFORE the snapshot properties are saved!
				ptrQueuedSnapshot->SetPostcommitInfo(lSnapshotsCount);

				// Send the IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT ioctl.
				// Get the snapshot device name
				ptrQueuedSnapshot->EndCommitSnapshotIoctl(pProp);
				ft.Trace( VSSDBG_SWPRV, L"Snapshot created at %s", pProp->m_pwszSnapshotDeviceObject);

				// Increment the number of processed snapshots
				lProcessedSnapshotsCount++;

				// Mark the snapshot as created
				ptrQueuedSnapshot->MarkAsCreated();

				break;
				
			case VSS_SS_CREATED:

				// This snapshot is already created.
				// The provider may receive many PostCommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        } // end while(true)
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then the coordinator is responsible to call AbortSnapshots
    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as to abort all snapshots from the given snapshot set.
    The snapshots are "reset" to the preparing state, so that a new DoSnapshotSet sequence can start.

Algorithm:

 	For each pre-committed snapshot in this snapshot set calls IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
 	For each committed or created snapshot it deletes the snapshot

Called by:

	IVssCoordinator::DoSnapshotsSet to abort precommitted snapshots

Remarks:

	- While calling this, Lovelace is not holding writes on snapshotted volumes.
	- The coordinator may receive many AbortSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::AbortSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		LONG lProcessedSnapshotsCount = 0;
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Switch the snapshot back to "Preparing" state
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PREPARING:
			case VSS_SS_PROCESSING_PREPARE: // Bug 207793

                // Nothing to do.
				break;

			case VSS_SS_PREPARED:
			case VSS_SS_PROCESSING_PRECOMMIT:
			case VSS_SS_PRECOMMITTED:

				// If snapshot was prepared, send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
				ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV,
                                L"sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed 0x%08lx", ft.hr);
                break;

			case VSS_SS_PROCESSING_COMMIT:
			case VSS_SS_COMMITTED:
			case VSS_SS_PROCESSING_POSTCOMMIT:
			case VSS_SS_CREATED:

				// If snapshot was committed, delete the snapshot
				ft.hr = ptrQueuedSnapshot->DeleteSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV,
                                L"sending IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT failed 0x%08lx", ft.hr);
                break;

			default:
				BS_ASSERT(false);
			}

            // Reset the snapshot as preparing
            ptrQueuedSnapshot->ResetAsPreparing();

			lProcessedSnapshotsCount++;
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snapshots were aborted", lProcessedSnapshotsCount);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
    OUT     PVSS_SNAPSHOT_PROP  pSavedProp
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::GetSnapshotProperties

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
    E_UNEXPECTED
        - Dev error. No logging.
    E_ACCESSDENIED
        - The user is not a backup operator or administrator

    [LoadSnapshotProperties() failures]
        E_OUTOFMEMORY
        VSS_E_OBJECT_NOT_FOUND
            - The snapshot with this ID was not found.

        [FindPersistedSnapshotByID() failures]
            E_OUTOFMEMORY

            [EnumerateSnapshots() failures]
                VSS_E_PROVIDER_VETO
                    - On runtime errors (like Unpack)
                E_OUTOFMEMORY  

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::GetSnapshotProperties" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSavedProp );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: pSavedProp = %p", pSavedProp );

        // Argument validation
		BS_ASSERT(pSavedProp);
		if ( SnapshotId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotId == GUID_NULL");
        if (pSavedProp == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pSavedProp");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( true, SnapshotId, pArray);

        // Extract the element from the array.
        if (pArray->GetSize() == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot not found.");

        // Get the snapshot structure
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

        // Fill out the [out] parameter
        VSS_OBJECT_PROP_Copy::copySnapshot(pSavedProp, pSnap);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::MakeSnapshotReadWrite(
    IN      VSS_ID          SnapshotId
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::MakeSnapshotReadWrite

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
    E_UNEXPECTED
        - Dev error. No logging.
    E_ACCESSDENIED
        - The user is not a backup operator or administrator

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::MakeSnapshotReadWrite" );

    return E_NOTIMPL;
    
    UNREFERENCED_PARAMETER(SnapshotId);
}


STDMETHODIMP CVsSoftwareProvider::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::SetSnapshotProperty" );

    return E_NOTIMPL;
    
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(eSnapshotPropertyId);
    UNREFERENCED_PARAMETER(vProperty);
}


STDMETHODIMP CVsSoftwareProvider::IsVolumeSupported(
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSupportedByThisProvider
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the 
    corresponding provider.
 
Parameters
    pwszVolumeName
        [in] The volume name to be checked. It must be one of those returned by 
        GetVolumeNameForVolumeMountPoint, in other words in
        the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format 
        with the corresponding unique ID.(with trailing backslash)
    pbSupportedByThisProvider
        [out] Non-NULL pointer that receives TRUE if the volume can be 
        snapshotted using this provider or FALSE otherwise.
 
Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not an administrator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    E_OUTOFMEMORY
        Out of memory or other system resources           
    E_UNEXPECTED
        Unexpected programming error. Logging not done and not needed.
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

 
Remarks
    The function will return TRUE in the pbSupportedByThisProvider 
    parameter if it is possible to create a snapshot on the given volume. 
    The function must return TRUE on that volume even if the current 
    configuration does not allow the creation of a snapshot on that volume. 
    For example, if the maximum number of snapshots were reached on the 
    given volume (and therefore no more snapshots can be created on that volume), 
    the method must still indicate that the volume can be snapshotted.
 
--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::IsVolumeSupported" );

    try
    {
        ::VssZeroOut(pbSupportedByThisProvider);
    
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n",
             pwszVolumeName,
             pbSupportedByThisProvider);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSupportedByThisProvider == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid bool");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Get volume information. This may throw.
        LONG lVolAttr = GetVolumeInformation(pwszVolumeName);
        (*pbSupportedByThisProvider) = ((lVolAttr & VSS_VOLATTR_SUPPORTED) != 0);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::IsVolumeSnapshotted(
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSnapshotsPresent,
	OUT 	LONG *		    plSnapshotCompatibility
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the 
    corresponding provider.
 
Parameters
    pwszVolumeName
        [in] The volume name to be checked. It must be one of those returned by 
        GetVolumeNameForVolumeMountPoint, in other words in
        the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format 
        with the corresponding unique ID.(with trailing backslash)
    pbSnapshotPresent
        [out] Non-NULL pointer that receives TRUE if the volume has at least 
        one snapshot or FALSE otherwise.
    plSnapshotCompatibility
        [out] Flags denoting the compatibility of the snapshotted volume with various operations 
 
Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not an administrator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    E_OUTOFMEMORY
        Out of memory or other system resources           
    E_UNEXPECTED
        Unexpected programming error. Logging not done and not needed.
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.


Remarks
    The function will return S_OK even if the current volume is a non-supported one. 
    In this case FALSE must be returned in the pbSnapshotPresent parameter.
 
--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::IsVolumeSnapshotted" );

    try
    {
        ::VssZeroOut(pbSnapshotsPresent);
        
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %p\n"
             L"  pbSnapshotsPresent = %p\n"
             L"  plSnapshotCompatibility = %p\n",
             pwszVolumeName,
             pbSnapshotsPresent,
             plSnapshotCompatibility);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSnapshotsPresent == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid bool");
        if (plSnapshotCompatibility == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid plSnapshotCompatibility");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Get volume information. This may throw,
        LONG lVolAttr = GetVolumeInformation(pwszVolumeName);

        (*pbSnapshotsPresent) = ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0);
        (*plSnapshotCompatibility) = ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0)? 
            (VSS_SC_DISABLE_DEFRAG|VSS_SC_DISABLE_CONTENTINDEX): 0 ;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


LONG CVsSoftwareProvider::GetVolumeInformation(
    IN  LPCWSTR pwszVolumeName
    ) throw(HRESULT)

/*++

Description:

    This function returns various attributes that describe
        - if the volume is supported by this provider
        - if the volume has snapshots.

Parameter:

    [in] The volume name to be checked. It must be one of those returned by 
    GetVolumeNameForVolumeMountPoint, in other words in
    the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format 
    with the corresponding unique ID.(with trailing backslash)

Return values: 

    A combination of _VSS_VOLUME_INFORMATION_ATTR flags.

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.
    E_UNEXPECTED
        Unexpected programming error. Nothing is logged.
    VSS_E_OBJECT_NOT_FOUND
        The device does not exist or it is not ready.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::GetVolumeInformation" );
	CVssIOCTLChannel volumeIChannel;	// For checking the snapshots on a volume
    LONG lReturnedFlags = 0;

    // Argument validation
    BS_ASSERT(pwszVolumeName);

    // Open the volume. Throw "object not found" if needed.
	volumeIChannel.Open(ft, pwszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);

    // Check to see if there are existing snapshots
	ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS);
    if (ft.HrFailed()) {
        // The volume is not even supported
        ft.hr = S_OK;
        return 0;
    }

	// Mark the volume as supported since the query succeeded.
	lReturnedFlags |= VSS_VOLATTR_SUPPORTED;

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	volumeIChannel.Unpack(ft, &ulMultiszLen);

    // If the multistring is empty, then ulMultiszLen is necesarily 2
    // (i.e. two l"\0' characters)
    // Then mark the volume as snapshotted.
	if (ulMultiszLen != nEmptyVssMultiszLen) 
	    lReturnedFlags |= VSS_VOLATTR_SNAPSHOTTED;

    return lReturnedFlags;
}



STDMETHODIMP CVsSoftwareProvider::OnLoad(
	IN  	IUnknown* pCallback	
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::OnLoad" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED, L"Access denied");
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    UNREFERENCED_PARAMETER(pCallback);
}


STDMETHODIMP CVsSoftwareProvider::OnUnload(
	IN  	BOOL	bForceUnload				
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::OnUnload" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED, L"Access denied");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Remove all snapshots that belong to all provider instance IDs
    	RemoveSnapshotsFromGlobalList(GUID_NULL, VSS_QST_REMOVE_ALL_QS);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    UNREFERENCED_PARAMETER(bForceUnload);
}




void CVsSoftwareProvider::RemoveSnapshotsFromGlobalList(
	IN	VSS_ID FilterID,
    IN  VSS_QSNAP_REMOVE_TYPE eRemoveType
	) throw(HRESULT)

/*++

Description:

	Detach from the global list all snapshots in this snapshot set

Remark:

	We detach all snapshots at once only in case of total success or total failure.
	This is because we want to be able to retry DoSnapshotSet if a failure happens.
	Therefore we must keep the list of snapshots as long as the client wants.

    VSS_QST_REMOVE_SPECIFIC_QS,  // Remove the remaining specific QS     (called in Provider itf. destructor)
    VSS_QST_REMOVE_ALL_QS,       // Remove all remaining QS              (called in OnUnload)

Called by:

	PostCommitSnapshots, AbortSnapshots, destructor and OnUnload

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::RemoveSnapshotsFromGlobalList" );
		
    ft.Trace( VSSDBG_SWPRV, L"FilterId = " WSTR_GUID_FMT L"eRemoveType = %d",
                            GUID_PRINTF_ARG(FilterID),eRemoveType );

	// For each snapshot in the snapshot set...
	LONG lProcessedSnapshotsCount = 0;
	CVssSnapIterator snapIterator;
    while (true)
    {
        CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot;

        // Check if we need to return all snapshots (OnUnload case)
        switch( eRemoveType ) {
        case VSS_QST_REMOVE_ALL_QS:
            BS_ASSERT( FilterID == GUID_NULL )
		    ptrQueuedSnapshot = snapIterator.GetNext();
            break;
        case VSS_QST_REMOVE_SPECIFIC_QS:
	        BS_ASSERT(FilterID != GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNextByProviderInstance(FilterID);
            break;
        default:
            BS_ASSERT(false);
            ptrQueuedSnapshot = NULL;
        }

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;
		
		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);

        ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
             L" *ProvInstanceId = " WSTR_GUID_FMT L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
             L"  VolumeName = %s\n"
             L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
             L"  lAttributes = 0x%08lx\n"
             L"  status = %d\n",
             pProp,
             GUID_PRINTF_ARG( ptrQueuedSnapshot->GetProviderInstanceId() ),
             GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
			 pProp->m_pwszOriginalVolumeName,
             LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
             pProp->m_lSnapshotAttributes,
			 pProp->m_eStatus);

        // The destructor (and the autodelete stuff) is called here.
		ptrQueuedSnapshot->DetachFromGlobalList();
		lProcessedSnapshotsCount++;
	}

	ft.Trace( VSSDBG_SWPRV, L" %ld snapshots were detached", lProcessedSnapshotsCount);
}



CVsSoftwareProvider::CVsSoftwareProvider()
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::CVsSoftwareProvider");

    // Create the provider instance Id (which is used to mark the queued snapshots that belongs to it)
    ft.hr = ::CoCreateGuid(&m_ProviderInstanceID);
    if (ft.HrFailed()) {
        m_ProviderInstanceID = GUID_NULL;
        ft.Trace( VSSDBG_SWPRV, L"CoCreateGuid failed 0x%08lx", ft.hr );
        // TBD: Add event log here.
    }
    else {
        BS_ASSERT(m_ProviderInstanceID != GUID_NULL);
    }
}


CVsSoftwareProvider::~CVsSoftwareProvider()
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::~CVsSoftwareProvider");

    // Remove here all [Auto-Delete] queued snapshots that belong to this particular
    // Provider Instance ID.
    // The volume handle gets closed here and this will delete the underlying snapshots.
    if (m_ProviderInstanceID != GUID_NULL)
        RemoveSnapshotsFromGlobalList(m_ProviderInstanceID, VSS_QST_REMOVE_SPECIFIC_QS);
    else {
        BS_ASSERT(false);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\qsnap.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module QSnap.hxx | Defines the internal data structure attached to a snapshot.
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     11/??/1999  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"
#include "vssmsg.h"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRQSNPC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot IOCTL commands


void CVssQueuedSnapshot::OpenVolumeChannel() throw(HRESULT)

/*++

Description:

	Open the volume IOCTL.

Warning:

	The original volume name must be already known!

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::OpenVolumeChannel");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Open the volume channel, if needed.
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszOriginalVolumeName == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown volume name." );
		}

		// Open the channel. Remove the trailing backslash. It will throw on error.
		BS_ASSERT(::wcslen(pProp->m_pwszOriginalVolumeName) == nLengthOfVolMgmtVolumeName);
		m_volumeIChannel.Open(ft, pProp->m_pwszOriginalVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
	}
}


void CVssQueuedSnapshot::OpenSnapshotChannel() throw(HRESULT)

/*++

Description:

	Open the snapshot IOCTL.

Warning:

	The snapshot device name must be already known!

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::OpenSnapshotChannel");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Open the snapshot channel, if needed.
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszSnapshotDeviceObject == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown device object." );
		}
		
        // Open the snapshot. There is no trailing backslash to eliminate.
        // It will throw on error and log it.
		m_snapIChannel.Open(ft, pProp->m_pwszSnapshotDeviceObject, false, true, VSS_ICHANNEL_LOG_PROV);
	}
}


void CVssQueuedSnapshot::PrepareForSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::PrepareForSnapshotIoctl");

	BS_ASSERT(m_volumeIChannel.IsOpen());
	

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_pwszOriginalVolumeName != NULL);

    // Check to see if there are existing snapshots
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, true, VSS_ICHANNEL_LOG_PROV);

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	m_volumeIChannel.Unpack(ft, &ulMultiszLen);

    // If the multistring is empty, then ulMultiszLen is necesarily 2
    // (i.e. two l"\0' characters)
	if (ulMultiszLen != 2) {
	    ft.LogError( VSS_ERROR_MULTIPLE_SNAPSHOTS_UNSUPPORTED,
	        VSSDBG_SWPRV << pProp->m_pwszOriginalVolumeName );
	    ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO,
	              L"A snapshot already exist on the current volume" );
	}

	// Pack snapshot attributes
	ULONG ulTmp = static_cast<ULONG>(0);
	m_volumeIChannel.Pack(ft, ulTmp);

	// Pach the reserved field
	ulTmp = 0;
	m_volumeIChannel.Pack(ft, ulTmp);

	// Pack initial allocation size
	m_volumeIChannel.Pack(ft, m_llInitialAllocation);

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::CommitSnapshotIoctl()  throw(HRESULT)

/*++

Description:

	Send IOCTL_VOLSNAP_COMMIT_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CommitSnapshotIoctl");

	BS_ASSERT(m_volumeIChannel.IsOpen());

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_COMMIT_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::EndCommitSnapshotIoctl(
	IN	PVSS_SNAPSHOT_PROP pProp
	) throw(HRESULT)

/*++

Description:

	Send IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. Save also the snapshot properties.

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EndCommitSnapshotIoctl");

    BS_ASSERT(pProp);
    BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);
	BS_ASSERT(m_volumeIChannel.IsOpen());

    // Save the snapshot properties
    SaveStructure(m_volumeIChannel, pProp);

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);

	// Get the volume name length
	USHORT uKernelDeviceNameLengthInBytes;
	m_volumeIChannel.Unpack(ft, &uKernelDeviceNameLengthInBytes);
	size_t nKernelDeviceNameLength = uKernelDeviceNameLengthInBytes/sizeof(WCHAR);

    // Copy the globalroot prefix
	WCHAR wszDeviceNameInternal[MAX_PATH];
    ::wcscpy( wszDeviceNameInternal, wszGlobalRootPrefix );

	// Unpack ulVolumeNameLength wide characters.
	LPWSTR wszSnapshotKernelDeviceName = wszDeviceNameInternal + nGlobalRootPrefixLength;
	m_volumeIChannel.Unpack( ft, wszSnapshotKernelDeviceName, nKernelDeviceNameLength );	
	wszSnapshotKernelDeviceName[nKernelDeviceNameLength] = L'\0';

	// Send the device name as an OUT parameter
	::VssSafeDuplicateStr( ft, pProp->m_pwszSnapshotDeviceObject, wszDeviceNameInternal );
}



/*++

Description:

	Send IOCTL_VOLSNAP_AUTO_CLEANUP

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

void CVssQueuedSnapshot::AutoDeleteIoctl()
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AutoDeleteIoctl");

	if (!m_volumeAutoCleanupIChannel.IsOpen())
    {
        // Get the properties structure
        PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

        // Get the original volume name
	    if (pProp->m_pwszOriginalVolumeName == NULL)
	    {
		    BS_ASSERT(false);
		    ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown volume name." );
	    }
	    LPWSTR wszVolumeName = pProp->m_pwszOriginalVolumeName;
	    BS_ASSERT(::wcslen(wszVolumeName) == nLengthOfVolMgmtVolumeName);

	    // Open the channel with zero access requested.
	    // Eliminate the trailing backslash
	    // Throw on error.
	    m_volumeAutoCleanupIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV, 0);

	    // Send the IOCTL
	    ft.hr = m_volumeAutoCleanupIChannel.Call(ft, IOCTL_VOLSNAP_AUTO_CLEANUP, false);
        if (ft.HrFailed())
            ft.Trace(VSSDBG_SWPRV, L"Warning: sending IOCTL_VOLSNAP_AUTO_CLEANUP failed");
        ft.hr = S_OK;
	}
}



HRESULT CVssQueuedSnapshot::AbortPreparedSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AbortPreparedSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


HRESULT CVssQueuedSnapshot::DeleteSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::DeleteSnapshotIoctl");

	try
	{
		if (!m_volumeIChannel.IsOpen())
            OpenVolumeChannel();

		// send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot constructor


CVssQueuedSnapshot::CVssQueuedSnapshot(
	IN  VSS_OBJECT_PROP_Ptr& ptrSnap,	// Ownership passed to the Constructor
    IN  VSS_ID ProviderInstanceId
	):
	m_cookie(VSS_NULL_COOKIE),
	m_llInitialAllocation(nDefaultInitialSnapshotAllocation),			// Babbage-related properties
	m_ptrSnap(ptrSnap),					// Properties related to the standard structure.
	m_lRefCount(0),						// Life-management
    m_ProviderInstanceId(ProviderInstanceId)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CVssQueuedSnapshot");
}


CVssQueuedSnapshot::~CVssQueuedSnapshot()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::~CVssQueuedSnapshot");

    // Also this destructor will close the Auto-Cleanup volume handle
    // which will generate he autocleanup event.
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot Operations


PVSS_SNAPSHOT_PROP CVssQueuedSnapshot::GetSnapshotProperties()
{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVssQueuedSnapshot::GetSnapshotProperties");

	if (m_ptrSnap.GetStruct() == NULL ||
		m_ptrSnap.GetStruct()->Type != VSS_OBJECT_SNAPSHOT)
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL  or invalid properties structure.");

	return &(m_ptrSnap.GetStruct()->Obj.Snap);
}

void CVssQueuedSnapshot::SetInitialAllocation(
	LONGLONG llInitialAllocation
	)
{
	m_llInitialAllocation = llInitialAllocation;
}


LONGLONG CVssQueuedSnapshot::GetInitialAllocation()
{
	return m_llInitialAllocation;
}


VSS_SNAPSHOT_STATE CVssQueuedSnapshot::GetStatus()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	return pProp->m_eStatus;
}


bool CVssQueuedSnapshot::IsDuringCreation()

/*++

Description:

	This method returns true if the snapshot is during creation

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::IsDuringCreation");

	VSS_SNAPSHOT_STATE eState = GetStatus();

	switch(eState)
	{
	case VSS_SS_PREPARING:
	case VSS_SS_PROCESSING_PREPARE:
	case VSS_SS_PREPARED:
	case VSS_SS_PROCESSING_PRECOMMIT:
	case VSS_SS_PRECOMMITTED:
	case VSS_SS_PROCESSING_COMMIT:
	case VSS_SS_COMMITTED:
	case VSS_SS_PROCESSING_POSTCOMMIT:
		return true;
	default:
		return false;
	}
}


void CVssQueuedSnapshot::ResetSnapshotProperties() throw(HRESULT)

/*++

Description:

	Reset the internal fields that can change between Get calls.
	Cache only the immutable fields (for the future Gets on the same interface):
	- Snapshot ID
	- Snapshot Set ID
	- Provider ID
	- Snapshot Device name
	
--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::ResetSnapshotProperties");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Reset the non-immutable property fields
	::VssFreeString(pProp->m_pwszOriginalVolumeName);
	pProp->m_eStatus = VSS_SS_UNKNOWN;

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
}


void CVssQueuedSnapshot::ResetAsPreparing()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::ResetAsPreparing");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT((pProp->m_eStatus == VSS_SS_PREPARING)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_PREPARE)||
        (pProp->m_eStatus == VSS_SS_PREPARED)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_PRECOMMIT)||
		(pProp->m_eStatus == VSS_SS_PRECOMMITTED) ||
        (pProp->m_eStatus == VSS_SS_PROCESSING_COMMIT)||
		(pProp->m_eStatus == VSS_SS_COMMITTED)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_POSTCOMMIT)||
		(pProp->m_eStatus == VSS_SS_CREATED));

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	pProp->m_SnapshotId = GUID_NULL;
	::VssFreeString(pProp->m_pwszSnapshotDeviceObject);
	pProp->m_eStatus = VSS_SS_PREPARING;

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
	m_volumeAutoCleanupIChannel.Close();
}


void CVssQueuedSnapshot::MarkAsProcessingPrepare()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPrepare");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARING);
    pProp->m_eStatus = VSS_SS_PROCESSING_PREPARE;
}


void CVssQueuedSnapshot::MarkAsPrepared()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsPrepared");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_PREPARE);
	pProp->m_eStatus = VSS_SS_PREPARED;
}


void CVssQueuedSnapshot::MarkAsProcessingPreCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPreCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARED);
    pProp->m_eStatus = VSS_SS_PROCESSING_PRECOMMIT;
}


void CVssQueuedSnapshot::MarkAsPreCommitted()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsPreCommitted");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_PRECOMMIT);
	pProp->m_eStatus = VSS_SS_PRECOMMITTED;
}


void CVssQueuedSnapshot::MarkAsProcessingCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PRECOMMITTED);
    pProp->m_eStatus = VSS_SS_PROCESSING_COMMIT;
}


void CVssQueuedSnapshot::MarkAsCommitted()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsCommitted");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_COMMIT);
	pProp->m_eStatus = VSS_SS_COMMITTED;
}


void CVssQueuedSnapshot::MarkAsProcessingPostCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPostCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_COMMITTED);
    pProp->m_eStatus = VSS_SS_PROCESSING_POSTCOMMIT;
}


void CVssQueuedSnapshot::MarkAsCreated()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsCreated");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	::VssFreeString(pProp->m_pwszSnapshotDeviceObject);

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();

	// Assert that the snapshot state
	// is set before "save"
	BS_ASSERT(pProp->m_eStatus == VSS_SS_CREATED);
}


void CVssQueuedSnapshot::SetPostcommitInfo(
    IN  LONG lSnapshotsCount
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SetPostcommitInfo");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);

	// Set the snapshots count
	BS_ASSERT(lSnapshotsCount != 0);
	BS_ASSERT(pProp->m_lSnapshotsCount == 0);
	pProp->m_lSnapshotsCount = lSnapshotsCount;

	// Set the snapshot state to "created" since it will be saved.
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_POSTCOMMIT);
	pProp->m_eStatus = VSS_SS_CREATED;
}


VSS_ID CVssQueuedSnapshot::GetProviderInstanceId()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::GetProviderInstanceId");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

    return m_ProviderInstanceId;
}


void CVssQueuedSnapshot::AttachToGlobalList() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AttachToGlobalList");

	// The caller must have a separate reference to the object
	AddRef();

	BS_ASSERT( m_cookie == VSS_NULL_COOKIE );
	m_cookie = m_list.AddTail( ft, this );
}


void CVssQueuedSnapshot::DetachFromGlobalList()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::DetachFromGlobalList");

	BS_ASSERT( m_cookie != VSS_NULL_COOKIE );

	CVssQueuedSnapshot* pThis;
	m_list.ExtractByCookie( m_cookie, pThis );
	BS_ASSERT( this == pThis );
	m_cookie = VSS_NULL_COOKIE;

	// The caller must have a separate reference to the object
	Release();
}


VSS_ID CVssQueuedSnapshot::GetSnapshotID()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

    return pProp->m_SnapshotId;
}


VSS_ID CVssQueuedSnapshot::GetSnapshotSetID()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

    return pProp->m_SnapshotSetId;
}
	


/////////////////////////////////////////////////////////////////////////////
// CVssSnapIterator
//


CVssSnapIterator::CVssSnapIterator():
	CVssDLListIterator<CVssQueuedSnapshot*>(CVssQueuedSnapshot::m_list)
{}


CVssQueuedSnapshot* CVssSnapIterator::GetNext()
{
	CVssQueuedSnapshot* pObj;
	if (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
        return pObj;
    else
        return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextBySnapshot(
	IN		VSS_ID SID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->GetSnapshotID() == SID)
			return pObj;
	return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextBySnapshotSet(
	IN		VSS_ID SSID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->GetSnapshotSetID() == SSID)
			return pObj;
	return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextByProviderInstance(
	IN		VSS_ID PIID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->m_ProviderInstanceId == PIID)
			return pObj;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swprv.rc
//
#define IDS_PROJNAME                    100
#define IDR_SWPRV                       101
#define IDS_SERVICE_DESCRIPTION         102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
#include "swprv.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   09/15/1999

Revision History:

    Name        Date        Comments

    aoltean     09/23/1999  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )
/*++

Routine description:

    Implements IVssSnapshotProvider::Query

Return values:

    E_OUTOFMEORY
    E_ACCESSDENIED
        - if the user is not administrator
    E_INVALIARG
    E_UNEXPECTED
        - Dev error - no logging.

    [CVssQueuedSnapshot::EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");
        
        ft.Trace( VSSDBG_SWPRV, L"Parameters: QueriedObjectId = " WSTR_GUID_FMT
				  L"eQueriedObjectType = %d. eReturnedObjectsType = %d, ppEnum = %p",
				  GUID_PRINTF_ARG( QueriedObjectId ),
				  eQueriedObjectType,
				  eReturnedObjectsType,
				  ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if (eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( false, GUID_NULL, pArray);

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) { 
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\clogmsg.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: snapsql.cpp
//
// PURPOSE:
//
//      Implement the SQLServer Volume Snapshot Writer.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

class CLogMsg
	{
public:
	CLogMsg() :
		m_cwc(0),
		m_bEof(false)
		{
		m_rgwc[0] = L'\0';
		}

	LPCWSTR GetMsg()
		{
		return m_rgwc;
		}

	void Add(LPCWSTR wsz)
		{
		if (m_bEof)
			return;

		UINT cwc = (UINT) wcslen(wsz);

		if (cwc + m_cwc + 5 > x_MAX_MSG_SIZE)
			{
			wcscpy(m_rgwc + m_cwc, L" ...");
			m_cwc += 4;
			m_bEof = TRUE;
			}
		else
			{
			wcscpy(m_rgwc + m_cwc, wsz);
			m_cwc += cwc;
			}
		}

private:
	enum
		{
		x_MAX_MSG_SIZE = 2048
		};

    // size of string
    UINT m_cwc;

	// string
	WCHAR m_rgwc[x_MAX_MSG_SIZE];

	// end of string encountered
	bool m_bEof;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\softprv\src\swprv.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module swprv.hxx | Definition the COM server of the Software Snapshot provider
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     09/09/1999  dss->vss

--*/


///////////////////////////////////////////////////////////////////////////////
//   Includes
//


#include "stdafx.hxx"
#include <process.h>
#include "initguid.h"

// Generated MIDL header
#include "vs_idl.hxx"

#include "vssmsg.h"
#include "resource.h"
#include "vs_inc.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provider.hxx"

#include <comadmin.h>
#include "comadmin.hxx"


/////////////////////////////////////////////////////////////////////////////
// Constants

// The old COM+ application name.  DO NOT CHANGE THIS STRING.  It is used
// for upgrades from older builds of Whistler.
const WCHAR g_wszAppNameOldName[]  = L"MS Software Snapshot Provider";

const WCHAR g_wszAppName[]  = L"MS Software Shadow Copy Provider";
const WCHAR g_wszSvcName[]  = L"SwPrv";
const WCHAR g_wszDllName[]  = L"\\SWPRV.DLL";

const MAX_STRING_RESOURCE_LEN = 1024;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRSWPRC"
//
////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//   Static objects
//

CSwPrvSnapshotSrvModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSoftwareProvider, CVsSoftwareProvider)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT GetDllPathName(
	IN	INT nBufferLength, // Does not include terminating zero character
    IN  LPCWSTR wszDllName,
    OUT LPWSTR wszDllPath
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"GetDllPathName" );

    try
    {
		WCHAR wszDir[MAX_PATH];
        if (!::GetCurrentDirectory(MAX_PATH, wszDir)) {
            ft.LogError(VSS_ERROR_GETTING_CURRENT_DIR, VSSDBG_SWPRV << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED,
				L"Error on getting the current path. hr = 0x%08lx",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( ::wcslen(wszDir) +
			 ::wcslen(wszDllName) >= (size_t) nBufferLength )
            ft.Throw(VSSDBG_SWPRV, E_OUTOFMEMORY, L"Out of memory.");

        ::_snwprintf(wszDllPath, nBufferLength,
				L"%s%s", wszDir, wszDllName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

void MakeChangeable(LPCWSTR wszAppName, bool fChangeable)
	{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"MakeChangeable");

	CVssCOMAdminCatalog     catalog;
	ft.hr = catalog.Attach(wszAppName);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

	// Get the list of applications
	CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
	ft.hr = appsList.Attach(catalog);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

	CVssCOMApplication application;
	ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
	if (ft.HrFailed())
		ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_SWPRV << catalog.GetAppName() << ft.hr);


	// if the application doesn't exist then return
	if (ft.hr == S_FALSE)
		return;

	application.m_bChangeable = fChangeable;
	application.m_bDeleteable = fChangeable;
	ft.hr = appsList.SaveChanges();
	if (ft.HrFailed())
		{
		ft.TraceComError();
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
		}
	}

void DeleteOldAppIfExists(LPCWSTR wszAppName)
	{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"DeleteOldAppIfExists");

	CVssCOMAdminCatalog     catalog;
	ft.hr = catalog.Attach(wszAppName);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

	// Get the list of applications
	CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
	ft.hr = appsList.Attach(catalog);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

    // Attach to app
	CVssCOMApplication application;
	ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
	if (ft.HrFailed())
		ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_SWPRV << catalog.GetAppName() << ft.hr);


	// if the application doesn't exist then return
	if (ft.hr == S_FALSE)
		return;

    // now make the application changeable so we can delete it.
	application.m_bChangeable = true;
	application.m_bDeleteable = true;
	ft.hr = appsList.SaveChanges();
	if (ft.HrFailed())
		{
		ft.TraceComError();
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
		}

	// now delete it
	LONG lIndex = application.GetIndex();
	BS_ASSERT(lIndex != -1);
	ft.hr = appsList.GetInterface()->Remove(lIndex);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_REMOVING_APPLICATION, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
		ft.TraceComError();
		ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure to remove swprv application object 0x %08lx", ft.hr);
		}

	// commit changes
	ft.hr = appsList.SaveChanges();
	if (ft.HrFailed())
		{
        ft.TraceComError();
		ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
		}	
	}

HRESULT RegisterNewCOMApp()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"RegisterNewCOMApp" );

    try
    {
        //
        //  Delete the swprv application using the old name with "snapshot"
        //  in it if it exists.
        //
        DeleteOldAppIfExists(g_wszAppNameOldName);

        //
        //  Delete the swprv application using the current name if it exists.  Fixes
        //  a problem with certain upgrades.
        //
        DeleteOldAppIfExists(g_wszAppName);
        
        //
        // Initialize the catalog
        //

        CVssCOMAdminCatalog     catalog;
        ft.hr = catalog.Attach(g_wszAppName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

        //
        //  Create a new application, it shouldn't exist yet (because of the above)
        //

        // Get the list of applications
        CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
        ft.hr = appsList.Attach(catalog);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

        CVssCOMApplication application;
		ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
		if (ft.HrFailed()) {
            ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_SWPRV << catalog.GetAppName() << ft.hr);
		}

        if (ft.hr == S_OK )
        {
            // This should never happen, unless the application is being registered twice at
            // the same time.
            ft.Trace( VSSDBG_SWPRV, L"COM+ SwPrv application found again after it should have been deleted!" );
        }
		else if (ft.hr == S_FALSE)
		{
    		// The application doesn't exist.
    		ft.hr = application.InsertInto(appsList);
    		if (ft.HrFailed())
    			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in creating a new application object 0x%08lx", ft.hr);

    		// Set application name
    		application.m_bstrName = catalog.GetAppName();

            // Loads the application description
            WCHAR wszBuffer[MAX_STRING_RESOURCE_LEN];
            if (0 == ::LoadStringW(_Module.GetModuleInstance(), 
                IDS_SERVICE_DESCRIPTION, wszBuffer, MAX_STRING_RESOURCE_LEN - 1)) 
            {
                BS_ASSERT(false);
                ft.Throw(VSSDBG_SWPRV, HRESULT_FROM_WIN32(GetLastError()),
        			L"Error on loading the app description. [0x%08lx]", 
        			HRESULT_FROM_WIN32(GetLastError()));
            }

            CComBSTR bstrAppDescription = wszBuffer;
            if ((LPWSTR)bstrAppDescription == NULL)
                ft.Throw(VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");
    		application.m_bstrDescription = bstrAppDescription;
    		    
    		// Register as Server package
    		application.m_lActivation = COMAdminActivationLocal;

    		// Commit changes
    		ft.hr = appsList.SaveChanges();
    		if (ft.HrFailed())
    			{
    			ft.TraceComError();
    			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
        	    }
    		// Make the application a true NT service
//			BS_ASSERT(false);
    		ft.hr = catalog.CreateServiceForApplication(g_wszSvcName);
    		if (ft.HrFailed())
    			{
    			BS_ASSERT(false);
    			ft.TraceComError();
    			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error on installing the service. hr = 0x%08lx", ft.hr);
                }

            //
            //  Insert this component into the application
            //

            WCHAR wszFileName[MAX_PATH];
            ft.hr = GetDllPathName(MAX_PATH - 1, g_wszDllName, wszFileName);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error in getting the DLL path. hr = 0x%08lx", ft.hr);

            // Install the component
            ft.hr = catalog.InstallComponent(wszFileName, NULL, NULL);
            if (ft.HrFailed()) {
                ft.TraceComError();
                ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error on install the event class. hr = 0x%08lx", ft.hr);
    			}

    	    BS_ASSERT(ft.hr != S_FALSE);

            // now make the application hard to delete and change.
            MakeChangeable( g_wszAppName, false );
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
//        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


// DllInstall - install the component into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	HRESULT hr = S_OK;

	// Registers the COM+ application
	// This will implicitely call DllRegisterServer
	if (bInstall)
		hr = RegisterNewCOMApp();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\auto.h ===
//--------------------------------------------------------------------
// Microsoft DART Utilities
//
// Copyright 1994 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module auto.h | Definition of <c CAutoRg> and <c CAutoP>
//
// @devnote None
//
// @rev   0 | 24-Oct-94 | matthewb	| Created
// @rev   1 | 01-May-95 | rossbu	| Updated and consolidated interface
// @rev   2 | 23-May-95 | eugenez	| Added support for TaskAlloc'ed pointers
//

extern IMalloc * g_pIMalloc;

//--------------------------------------------------------------------
//
// @class CAutoBase | This template class is a base class, used to give dynamic memory
// local (auto) scope within a function.  For instance a large character
// buffer can be allocated from a memory object, but be cleanup up as if were
// allocated on the stack.	An additional feature is the ability to
// 'unhook' the object from the local scope using the PvReturn().  For
// instance, you may want to return a  newly allocated object to the
// caller, but still have the benefit of error clean up any error
// scenario.  <c CAutoRg> is a derived class which cleans up arrays allocated
// with new[].	<c CAutoP> is an analagous but works for single objects
// rather than arrays (allocated with new).
//
// @tcarg class | T | Type of auto object
//
// @ex This declaration would allocate a 100 char buffer from pmem, and
// automatically free the buffer when rgbBuf goes out of scope. |
//
//	CAutoRg<lt>char<gt> rgbBuf(New(pmem) char[100]);
//
// @xref <c CAutoRg>
//
// @ex This CAutoP example allocates a CFoo object and returns it if there
// are no errors. |
//
//	/* inilize pfoo */
//	CAutoP<lt>CFoo<gt> pfoo(New(pmem) CFoo);
//	/* do stuff */
//	/* call pfoo methods */
//	pfoo->Bar();
//	/* return w/o destroying foo */
//	return pfoo .PvReturn;
//
// @xref <c CAutoP>
//

// ************************ CAutoBase - base class for all AutoPointers *****************************

template <class T>
class CAutoBase
	{
public:		// @access public
	inline CAutoBase(T* pt);
	inline ~CAutoBase();

	inline T* operator= (T*);
	inline operator T* (void);
	inline operator const T* (void)const;
	inline T ** operator & (void);
	inline T* PvReturn(void);

protected:	// @access protected
	T* m_pt;

private:	// Never-to-use
	inline CAutoBase& operator= (CAutoBase&);
	CAutoBase(CAutoBase&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoBase giving the array of objects pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoBase<T>::CAutoBase(T *pt)
	{
	m_pt = pt;
	}

//--------------------------------------------------------------------
// @mfunc CAutoBase destructor.  Asserts that the object has been free'd
// 	(set to NULL).	Setting to NULL does not happen in the retail build
// @side None
// @rdesc None
//

template <class T>
inline CAutoBase<T>::~CAutoBase()
	{
//	_ASSERT(NULL == m_pt);
	}

//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//
// @ex Assign CAutoBase variable after construction. |
//
//		CAutoBase<lt>char<gt>	rgb;
//		/* ... */
//		rgb(NewG char[100]);
//

template <class T>
inline T* CAutoBase<T>::operator=(T* pt)
	{
	_ASSERT(m_pt == NULL);
	m_pt = pt;
	return pt;
	}

//--------------------------------------------------------------------
// @mfunc Cast operator used to "unwrap" the pointed object
// as if the CAutoBase variable were a pointer of type T.
// In many situations this is enough for an autopointer to
// look exactly like an ordinary pointer.
// @side None
// @rdesc None
//

template <class T>
inline CAutoBase<T>::operator T*(void)
	{
	return m_pt;
	}

template <class T>
inline CAutoBase<T>::operator const T*(void)const
	{
	return m_pt;
	}

//--------------------------------------------------------------------
// @mfunc Address-of operator is used to make the autopointer even more
//	similar to an ordinary pointer. When you take an address of an
//	autopointer, you actually get an address of the wrapped
//	pointer.
// @side None
// @rdesc None

template <class T>
inline T ** CAutoBase<T>::operator & ()
	{
	return & m_pt;
	}

//--------------------------------------------------------------------
// @mfunc Returns the object(s) pointed to by the CAutoBase variable.
// In addition this method 'unhooks' the object(s), such that
// the scope of the object(s) are no longer local.
//
// See <c CAutoBase> for an example.
// @side None
// @rdesc None
//

template <class T>
inline T * CAutoBase<T>::PvReturn(void)
	{
	T *ptT = m_pt;
	m_pt = NULL;
	return ptT;
	}



//************************* CAutoRg - autopointers to arrays ******************************

//--------------------------------------------------------------------
// @class This derived class is primarily used to implement the
//	vector deleting destructor.  Should only be used on objects allocated
//	with new[]
//

template <class T>
class CAutoRg :
	public CAutoBase<T>
	{
public:		// @access public
	inline CAutoRg(T *pt);
	inline ~CAutoRg();

	inline T* operator= (T*);

private:	// Never-to-use
	inline CAutoRg& operator= (CAutoRg&);
	CAutoRg(CAutoRg&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoRg giving the array of objects pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoRg<T>::CAutoRg(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc CAutoRg destructor.  When an object of class CAutoRg goes out
// of scope, free the associated object (if any).
// @side calls the vector delete method
// @rdesc None
//

template <class T>
inline CAutoRg<T>::~CAutoRg()
	{
	delete [] m_pt;
	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//
// @ex Assign CAutoRg variable after construction. |
//
//		CAutoRg<lt>char<gt>	rgb;
//		/* ... */
//		rgb(NewG char[100]);
//

template <class T>
inline T* CAutoRg<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//*************************** CAutoP - autopointers to scalars **************

//--------------------------------------------------------------------
// @class This is analagous to <c CAutoRg> but calls scalar delete
//	of an object rather than arrays.
//
// @xref <c CAutoRg>

template <class T>
class CAutoP :
	public CAutoBase<T>
	{
public: 	// @access public
	inline CAutoP(T *pt);
	inline ~CAutoP();
	inline T* operator= (T*);
	inline T* operator->(void);

private:	// Never-to-use
	inline CAutoP& operator= (CAutoP&);
	CAutoP(CAutoP&);
	};


//--------------------------------------------------------------------
// @mfunc Create a CAutoP giving the object pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoP<T>::CAutoP(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc Delete the object pointed by CAutoP variable if any.
// @side None
// @rdesc None
//

template <class T>
inline CAutoP<T>::~CAutoP()
	{
	delete m_pt;
	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoP<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//--------------------------------------------------------------------
// @mfunc The 'follow' operator on the CAutoP allows an CAutoP variable
// to act like a pointer of type T.  This overloading generally makes using
// a CAutoP simple as using a regular T pointer.
//
// See <c CAutoRg> example.
// @side None
// @rdesc None

template <class T>
inline T * CAutoP<T>::operator->()
	{
	_ASSERT(m_pt != NULL);
	return m_pt;
	}


//******************** CAutoTask - autopointers to TaskAlloc'ed memory ***************

//--------------------------------------------------------------------
// @class CAutoTask is an autopointer to an area allocated using TaskAlloc.
//	May be used for scalars or vectors alike, but beware: object destructors
//	are not called by the autopointer, just the memory gets released.
//

template <class T>
class CAutoTask :
	public CAutoBase<T>
	{
public: 	// @access public
	inline CAutoTask (T *pt);
	inline ~CAutoTask ();
	inline T* operator= (T*);

private:	// Never-to-use
	inline CAutoTask& operator= (CAutoTask&);
	CAutoTask(CAutoTask&);
	};


//--------------------------------------------------------------------
// @mfunc Constructor simply calls the constructor for CAutoBase<lt>T<gt>.
// @side None
// @rdesc None

template <class T>
inline CAutoTask<T>::CAutoTask(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc Free the memory pointed to by CAutoTask variable.
// @side None
// @rdesc None
//

template <class T>
inline CAutoTask<T>::~CAutoTask()
	{
	if (m_pt)
		g_pIMalloc->Free(m_pt);

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoTask<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//************************* CAutoUnivRg - universal autopointers to arrays ******************************

//--------------------------------------------------------------------
// @class CAutoUnivRg and CAutoUnivP are "universal" autopointer classes.
//	They can handle those rare occasions when the "auto-scoped" pointer
//	might have been allocated by either New or TaskAlloc, depending on
//	the circumstances. You have to always know however just how it was
//	allocated this time, and pass this knowledge to the CAutoUniv object
//	at construction time.
//
//	CAutoUniv objects have the additional construction parameter of type
//	BOOL. It is used in fact as a BOOL flag: TRUE means that the
//	pointer is allocated by TaskAlloc, and FALSE means NewG.
//

template <class T>
class CAutoUnivRg :
	public CAutoRg<T>
	{
public:		// @access public
	inline CAutoUnivRg (T *pt, BOOL fIsTaskAlloc);
	inline ~CAutoUnivRg ();

	inline T* operator= (T*);

private:
	BOOL m_fTaskAlloc;

private:	// Never-to-use
	inline CAutoUnivRg& operator= (CAutoUnivRg&);
	CAutoUnivRg(CAutoUnivRg&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoUnivRg giving the array of objects pointed to by pt
// auto scope. Takes a pointer to a memory object, NULL indicates global
// IMalloc (not a global memory object!).
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoUnivRg<T>::CAutoUnivRg (T *pt, BOOL fIsTaskAlloc)
	: CAutoRg<T>(pt)
	{
	m_fTaskAlloc = fIsTaskAlloc;
	}

//--------------------------------------------------------------------
// @mfunc CAutoUnivRg destructor.  When an object of class CAutoUnivRg goes out
// of scope, free the associated object (if any).
// @side calls the vector delete method
// @rdesc None
//

template <class T>
inline CAutoUnivRg<T>::~CAutoUnivRg()
	{
	if (m_fTaskAlloc)
		{
		// m_pt->~T();	// Awaits VC++ 3.0...
		g_pIMalloc->Free(m_pt);
		}
	else
		delete [] m_pt;

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoUnivRg<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//*************************** CAutoUnivP - universal autopointers to scalars **************

//--------------------------------------------------------------------
// @class This is analagous to <c CAutoUnivRg> but calls scalar delete
//	of an object rather than arrays.
//

template <class T>
class CAutoUnivP :
	public CAutoP<T>
	{
public: 	// @access public
	inline CAutoUnivP(T *pt, BOOL fIsTaskAlloc);
	inline ~CAutoUnivP();
	inline T* operator= (T*);
	inline T* operator->(void);

private:
	BOOL m_fTaskAlloc;

private:	// Never-to-use
	inline CAutoUnivP& operator= (CAutoUnivP&);
	CAutoUnivP(CAutoUnivP&);
	};


//--------------------------------------------------------------------
// @mfunc Constructor
// @side None
// @rdesc None

template <class T>
inline CAutoUnivP<T>::CAutoUnivP(T *pt, BOOL fIsTaskAlloc)
	: CAutoBase<T>(pt)
	{
	m_fTaskAlloc = fIsTaskAlloc;
	}


//--------------------------------------------------------------------
// @mfunc Delete the object pointed by CAutoUnivP variable if any.
// @side None
// @rdesc None
//

template <class T>
inline CAutoUnivP<T>::~CAutoUnivP()
	{
	if (m_fTaskAlloc)
		{
		// m_pt->~T();	// Awaits VC++ 3.0...
		g_pIMalloc->Free(m_pt);
		}
	else
		delete m_pt;

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoUnivP<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//--------------------------------------------------------------------
// @mfunc The 'follow' operator on the CAutoUnivP allows an CAutoUnivP variable
// to act like a pointer of type T.  This overloading generally makes using
// a CAutoUnivP simple as using a regular T pointer.
//
// @side None
// @rdesc None

template <class T>
inline T * CAutoUnivP<T>::operator->()
	{
	_ASSERT(m_pt != NULL);
	return m_pt;
	}


//------------------------------------------------------------------
// @class auto handle class
//
class CAutoHandle
	{
public:
	// @cmember constructor
	inline CAutoHandle(HANDLE h) : m_handle(h)
		{
		}

	inline CAutoHandle() :
		m_handle(INVALID_HANDLE_VALUE)
		{
		}

	// @cmember destructor
	inline ~CAutoHandle()
		{
		if (m_handle != INVALID_HANDLE_VALUE)
			CloseHandle(m_handle);
		}

	// coercion to handle value
	inline operator HANDLE (void)
		{
		return m_handle;
		}

	inline HANDLE PvReturn(void)
		{
		HANDLE h = m_handle;
		m_handle = INVALID_HANDLE_VALUE;
		return h;
		}

private:

	// @cmember handle value
	HANDLE m_handle;
	};


//----------------------------------------------------------------------
// @class auto class for registry keys
//
class CAutoHKEY
	{
public:
	// @cmember constructor
	inline CAutoHKEY(HKEY hkey) : m_hkey(hkey)
		{
		}

	// @cmember destructor
	inline ~CAutoHKEY()
		{
		if (m_hkey != NULL)
			RegCloseKey(m_hkey);
		}

	inline operator HKEY(void)
		{
		return m_hkey;
		}

	inline HKEY PvReturn(void)
		{
		HKEY hkey = m_hkey;

		m_hkey = NULL;
		return hkey;
		}
private:
	HKEY m_hkey;
	};


//------------------------------------------------------------------
// @class automatically unmap view of file on function exit
//
class CAutoUnmapViewOfFile
	{
public:
	// @cmember constructor
	inline CAutoUnmapViewOfFile(PVOID pv) : m_pv(pv)
		{
		}

	// @cmember destructor
	inline ~CAutoUnmapViewOfFile()
		{
		if (m_pv != NULL)
			UnmapViewOfFile(m_pv);
		}

	// @cmember indicate that region should not be unmapped by destructor
	inline PVOID PvReturn()
		{
		PVOID pv = m_pv;
		m_pv = NULL;
		return pv;
		}

private:
	// @cmember handle value
	PVOID m_pv;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\snapsql.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: snapsql.cpp
//
// PURPOSE:
//
//      Implement the SQLServer Volume Snapshot Writer.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

#if HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>

#include <new.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLSNAPC"
//
////////////////////////////////////////////////////////////////////////

int __cdecl out_of_store(size_t size)
	{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"out_of_store");
	ft.Trace(VSSDBG_SQLLIB, L"out of memory");

	throw HRESULT (E_OUTOFMEMORY);
	return 0;
	}

class AutoNewHandler
{
public:
	AutoNewHandler ()
	{
	   m_oldHandler = _set_new_handler (out_of_store);
	}

	~AutoNewHandler ()
	{
	   _set_new_handler (m_oldHandler);
	}

private:
   _PNH		m_oldHandler;
};

//-------------------------------------------------------------------------
// Handle enviroment stuff:
//	- tracing/error logging
//  - mem alloc
//
IMalloc * g_pIMalloc = NULL;

HRESULT
InitSQLEnvironment()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"InitSqlEnvironment");
	try
	{
		ft.hr = CoGetMalloc(1, &g_pIMalloc);
		if (ft.HrFailed())
			ft.Trace(VSSDBG_SQLLIB, L"Failed to get task allocator: hr=0x%X", ft.hr);
	}
	catch (...)
	{
		ft.hr = E_SQLLIB_GENERIC;
	}

	return ft.hr;
}


//-------------------------------------------------------------------------
// Return TRUE if the server is online and a connection shouldn't take forever!
//
BOOL
IsServerOnline (const WCHAR*	serverName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"IsServerOnline");

	WCHAR	eventName [300];
	WCHAR*	pInstance;

	wcscpy (eventName, L"Global\\sqlserverRecComplete");

	// A "\" indicates a named instance, so append the name...
	//
	pInstance = wcschr (serverName, L'\\');

	if (pInstance)
	{
		wcscat (eventName, L"$");
		wcscat (eventName, pInstance+1);
	}

	HANDLE hEvent = CreateEventW (NULL, TRUE, FALSE, eventName);

	if (hEvent == NULL)
	{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.LogError(VSS_ERROR_SQLLIB_CANT_CREATE_EVENT, VSSDBG_SQLLIB << ft.hr);
		THROW_GENERIC;
	}

	// If the event isn't signaled, the server is not up.
	//
	BOOL result = (WaitForSingleObject (hEvent, 0) == WAIT_OBJECT_0);

	CloseHandle (hEvent);

	return result;
}

//-------------------------------------------------------------------------
// Return TRUE if the database properties are retrieved:
//		simple: TRUE if using the simple recovery model.
//		online: TRUE if the database is usable and currently open
//
void
FrozenServer::GetDatabaseProperties (const WString& dbName,
	BOOL*	pSimple,
	BOOL*	pOnline)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::GetDatabaseProperties");

	// We use status bit 0x40000000 (1073741824) to identify
	// clean-shutdown databases which are "offline".
	//
	WString		query =
		L"select databaseproperty(N'" + dbName + L"','IsTruncLog'),"
		L"case status & 1073741824 "
			L"when 1073741824 then 0 "
			L"else 1 end "
		L"from master..sysdatabases where name = N'" + dbName + L"'";		

	m_Connection.SetCommand (query);
	m_Connection.ExecCommand ();

	if (!m_Connection.FetchFirst ())
	{
		LPCWSTR wsz = dbName.c_str();
		ft.LogError(VSS_ERROR_SQLLIB_DATABASE_NOT_IN_SYSDATABASES, VSSDBG_SQLLIB << wsz);
		THROW_GENERIC;
	}

	*pSimple = (BOOL)(*(int*)m_Connection.AccessColumn (1));
	*pOnline = (BOOL)(*(int*)m_Connection.AccessColumn (2));
}


//------------------------------------------------------------------------------
// Called only by "FindDatabasesToFreeze" to implement a smart access strategy:
//    - use sysaltfiles to qualify the databases.
//      This avoids access to shutdown or damaged databases.
//
// Autoclose databases which are not started are left out of the freeze-list.
// We do this to avoid scaling problems, especially on desktop systems.
// However, such db's are still evaluated to see if they are "torn".
//
// The 'model' database is allowed to be a full recovery database, since only
// database backups are sensible for it.
//
BOOL
FrozenServer::FindDatabases2000 (
	CCheckPath*		checker)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::FindDatabases2000");

	// Create an ordered set of tuples (dbname, filename, simpleRecovery, dbIsActive)
	//
	// We use status bit 0x40000000 (1073741824) to identify
	// clean-shutdown databases which are not active.
	//
	m_Connection.SetCommand (
		L"select db_name(af.dbid),rtrim(af.filename), "
		L"case databasepropertyex(db_name(af.dbid),'recovery') "
			L"when 'SIMPLE' then 1 "
			L"else 0 end,"
		L"case databasepropertyex(db_name(af.dbid),'Status') "
			L"when 'ONLINE' then case db.status & 1073741824 "
				L"when 1073741824 then 0 "
				L"else 1 end "
			L"else 0 end "
		L"from master..sysaltfiles af, master..sysdatabases db "
		L"where af.dbid = db.dbid and af.dbid != db_id('tempdb') "
		L"order by af.dbid"
		);

	m_Connection.ExecCommand ();

	WCHAR*	pDbName;
	WCHAR*	pFileName;
	int*	pSimple;
	int*	pIsOnline;
	WString currentDbName;
	BOOL	firstDb = TRUE;
	BOOL	firstFile;
	BOOL	shouldFreeze = FALSE;
	BOOL	masterLast = FALSE;
	BOOL	currDbIsOnline;

	if (!m_Connection.FetchFirst ())
	{
		ft.LogError(VSS_ERROR_SQLLIB_SYSALTFILESEMPTY, VSSDBG_SQLLIB);
		THROW_GENERIC;
	}

	pDbName = (WCHAR*)m_Connection.AccessColumn (1);
	pFileName = (WCHAR*)m_Connection.AccessColumn (2);
	pSimple = (int*)m_Connection.AccessColumn (3);
	pIsOnline = (int*)m_Connection.AccessColumn (4);

	while (1)
	{

		// Check out the current row
		//
		BOOL fileInSnap = checker->IsPathInSnapshot (pFileName);
		if (fileInSnap && !*pSimple && wcscmp (L"model", pDbName))
		{
			ft.LogError(VSS_ERROR_SQLLIB_DATABASENOTSIMPLE, VSSDBG_SQLLIB << pDbName);
			throw HRESULT (E_SQLLIB_NONSIMPLE);
		}

		// Is this the next database?
		//
		if (firstDb || currentDbName.compare (pDbName))
		{
			if (!firstDb)
			{
				// Deal with completed database
				//
				if (shouldFreeze && currDbIsOnline)
				{
					if (currentDbName == L"master")
					{
						masterLast = TRUE;
					}
					else
					{
						m_FrozenDatabases.push_back (currentDbName);
					}
				}
			}

			// Keep info about the newly encountered db
			//
			currentDbName = WString (pDbName);
			currDbIsOnline = *pIsOnline;
			firstFile = TRUE;
			firstDb = FALSE;
			ft.Trace(VSSDBG_SQLLIB, L"Examining %s. SimpleRecovery:%d Online:%d\n", pDbName, *pSimple, *pIsOnline);
		}

		ft.Trace(VSSDBG_SQLLIB, L"%s\n", pFileName);

		if (firstFile)
		{
			shouldFreeze = fileInSnap;
			firstFile = FALSE;
		}
		else
		{
			if (shouldFreeze ^ fileInSnap)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASEISTORN, VSSDBG_SQLLIB);
				throw HRESULT (E_SQLLIB_TORN_DB);
			}
		}

		if (!m_Connection.FetchNext ())
		{
			// Deal with the current database
			//
			if (shouldFreeze && currDbIsOnline)
			{
				m_FrozenDatabases.push_back (currentDbName);
			}
			break;
		}
	}

	if (masterLast)
	{
		m_FrozenDatabases.push_back (L"master");
	}

	return m_FrozenDatabases.size () > 0;
}

//------------------------------------------------------------------------------
// Determine if there are databases which qualify for a freeze on this server.
// Returns TRUE if so.
// Throws if any qualified databases are any of:
//    - "torn" (not fully covered by the snapshot)
//    - hosted by a server which can't support freeze
//    - are not "simple" databases
//
BOOL
FrozenServer::FindDatabasesToFreeze (
	CCheckPath*		checker)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::FindDatabasesToFreeze");

	m_Connection.Connect (m_Name);

	m_FrozenDatabases.clear ();

	if (m_Connection.GetServerVersion () > 7)
	{
		// SQL2000 allows us to use a better access strategy.
		//
		return FindDatabases2000 (checker);
	}

	m_Connection.SetCommand (L"select name from sysdatabases where name != 'tempdb'");
	m_Connection.ExecCommand ();
	std::auto_ptr<StringVector> dbList (m_Connection.GetStringColumn ());
	BOOL	masterLast = FALSE;

	for (StringVectorIter i = dbList->begin (); i != dbList->end (); i++)
	{
		// UNDONE: SKIP OVER DB'S in SHUTDOWN DB'S?
		// DB'S IN LOAD, ETC?
		// We'll avoid freezing shutdown db's, but we don't avoid
		// enumerating their files (they might be torn)
		//

		// Note the [] around the dbname to handle non-trivial dbnames.
		//
		WString		command = L"select rtrim(filename) from [";
		command += *i + L"]..sysfiles";

		m_Connection.SetCommand (command);
		try
		{
			m_Connection.ExecCommand ();
		}
		catch (...)
		{
			// We've decided to be optimistic:
			// If we can't get the list of files, ignore this database.
			//
			ft.Trace(VSSDBG_SQLLIB, L"Failed to get db files for %s\n", i->c_str ());

			continue;
		}

		std::auto_ptr<StringVector> fileList (m_Connection.GetStringColumn ());

		BOOL first=TRUE;
		BOOL shouldFreeze;

		for (StringVectorIter iFile = fileList->begin ();
			iFile != fileList->end (); iFile++)
		{
			BOOL fileInSnap = checker->IsPathInSnapshot (iFile->c_str ());

			if (first)
			{
				shouldFreeze = fileInSnap;
			}
			else
			{
				if (shouldFreeze ^ fileInSnap)
				{
					ft.LogError(VSS_ERROR_SQLLIB_DATABASEISTORN, VSSDBG_SQLLIB << i->c_str());
					throw HRESULT (E_SQLLIB_TORN_DB);
				}
			}
		}

		if (shouldFreeze)
		{
			BOOL	simple, online;
			GetDatabaseProperties (i->c_str (), &simple, &online);
			if (!simple && L"model" != *i)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASENOTSIMPLE, VSSDBG_SQLLIB << i->c_str ());
				throw HRESULT (E_SQLLIB_NONSIMPLE);
			}
			if (online)
			{
				if (L"master" == *i)
				{
					masterLast = TRUE;
				}
				else
				{
					m_FrozenDatabases.push_back (*i);
				}
			}
		}
	}
	if (masterLast)
	{
		m_FrozenDatabases.push_back (L"master");
	}


	return m_FrozenDatabases.size () > 0;
}

//-------------------------------------------------------------------
// Prep the server for the freeze.
// For SQL2000, start a BACKUP WITH SNAPSHOT.
// For SQL7, issuing checkpoints to each database.
// This minimizes the recovery processing needed when the snapshot is restored.
//
BOOL
FrozenServer::Prepare ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Prepare");

	if (m_Connection.GetServerVersion () > 7)
	{
		m_pFreeze2000 = new Freeze2000 (m_Name, m_FrozenDatabases.size ());

		// Release the connection, we won't need it anymore
		//
		m_Connection.Disconnect ();

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			m_pFreeze2000->PrepareDatabase (*i);
		}
		m_pFreeze2000->WaitForPrepare ();
	}
	else
	{
		WString		command;

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			command += L"use [" + *i + L"]\ncheckpoint\n";
		}
		
		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}
	return TRUE;
}

//---------------------------------------------
// Freeze the server by issuing freeze commands
// to each database.
// Returns an exception if any failure occurs.
//
BOOL
FrozenServer::Freeze ()
{
    CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Freeze");
	if (m_pFreeze2000)
	{
		m_pFreeze2000->Freeze ();
	}
	else
	{
		WString		command;

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			command += L"dbcc freeze_io (N'" + *i + L"')\n";
		}
		
		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}

	return TRUE;
}

//---------------------------------------------
// Thaw the server by issuing thaw commands
// to each database.
// For SQL7, we can't tell if the database was
// already thawn.
// But for SQL2000, we'll return TRUE only if
// the databases were still all frozen at the thaw time.
BOOL
FrozenServer::Thaw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Thaw");
	if (m_pFreeze2000)
	{
		return m_pFreeze2000->Thaw ();
	}

	WString		command;

	for (StringListIter i=m_FrozenDatabases.begin ();
		i != m_FrozenDatabases.end (); i++)
	{
		command += L"dbcc thaw_io (N'" + *i + L"')\n";
	}
	
	m_Connection.SetCommand (command);
	m_Connection.ExecCommand ();

	return TRUE;
}


//-------------------------------------------------------------------------
// Create an object to handle the SQL end of the snapshot.
//
CSqlSnapshot*
CreateSqlSnapshot () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlSnapshot");
	try
	{
		return new Snapshot;
	}
	catch (...)
	{
	ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

//---------------------------------------------------------------
// Move to an uninitialized state.
//
void
Snapshot::Deinitialize ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Deinitialize");

	if (m_Status == Frozen)
	{
		Thaw ();
	}
	for (ServerIter i=m_FrozenServers.begin ();
		i != m_FrozenServers.end (); i++)
	{
		delete *i;
	}
	m_FrozenServers.clear ();
	m_Status = NotInitialized;
}

Snapshot::~Snapshot ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::~Snapshot");

	try
	{
		ft.Trace(VSSDBG_SQLLIB, L"\n~CSqlSnapshot called\n");
		Deinitialize ();
	}
	catch (...)
	{
		// swallow!
	}
}


//---------------------------------------------------------------------------------------
// Prepare for the snapshot:
//   - identify the installed servers
//   - for each server that is "up":
//		- identify databases affected by the snapshot
//		- if there are such databases, fail the snapshot if:
//			- the server doesn't support snapshots
//			- the database isn't a SIMPLE database
//			- the database is "torn" (not all files in the snapshot)
//
//
HRESULT
Snapshot::Prepare (CCheckPath*	checker) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Prepare");

	HRESULT		hr = S_OK;

	try
	{
		AutoNewHandler	t;

		// hack in a test of the new handler
		//
#if 0
		while (1)
		{
			char*p = new char [100000];
			if (p==NULL)
			{
				ft.Trace(VSSDBG_SQLLIB, L"Can never happen!\n");
				THROW_GENERIC;
			}
		}
#endif

		if (m_Status != NotInitialized)
		{
			Deinitialize ();
		}

		// The state moves immediately to enumerated, indicating
		// that the frozen server list may be non-empty.
		//
		m_Status = Enumerated;

		// Build a list of servers on this machine.
		//
		{
			std::auto_ptr<StringVector>	servers (EnumerateServers ());

			// Scan over the servers, picking out the online ones.
			//
			for (int i=0; i < servers->size (); i++)
			{
				if (IsServerOnline ((*servers)[i].c_str ()))
				{
					FrozenServer* p = new FrozenServer ((*servers)[i]);

					m_FrozenServers.push_back (p);
				}
				else
				{
					ft.Trace(VSSDBG_SQLLIB, L"Server %s is not online\n", (*servers)[i].c_str ());
				}
			}
		}

		// Evaulate the server databases to find those which need to freeze.
		//
		ServerIter i=m_FrozenServers.begin ();
		while (i != m_FrozenServers.end ())
		{
			if (!(**i).FindDatabasesToFreeze (checker))
			{
				ft.Trace(VSSDBG_SQLLIB, L"Server %s has no databases to freeze\n", ((**i).GetName ()).c_str ());

				// Forget about this server, it's got nothing to do.
				//
				delete *i;
				i = m_FrozenServers.erase (i);
			}
			else
			{
				i++;
			}
		}
		
		// Prep the servers for the freeze
		// 	
		for (i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
		{
			(*i)->Prepare ();
		}

#if 0
		// debug: print the frozen list
		//
		for (i=m_FrozenServers.begin ();
			i != m_FrozenServers.end (); i++)
		{
			ft.Trace(VSSDBG_SQLLIB, L"FrozenServer: %s\n", ((**i).GetName ()).c_str ());
		}
#endif
		
		m_Status = Prepared;
	}
	catch (HRESULT& e)
	{
		hr = e;
	}
	catch (...)
	{
		hr = E_SQLLIB_GENERIC;
	}

	return hr;
}

//---------------------------------------------------------------------------------------
// Freeze any prepared servers
//
HRESULT
Snapshot::Freeze () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Freeze");
	HRESULT hr = S_OK;

	if (m_Status != Prepared)
	{
		return E_SQLLIB_PROTO;
	}

	try
	{
		AutoNewHandler	t;

		// If any server is frozen, we are frozen.
		//
		m_Status = Frozen;

		// Ask the servers to freeze
		// 	
		for (ServerIter i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
		{
			(*i)->Freeze ();
		}
	}
	catch (...)
	{
		hr = E_SQLLIB_GENERIC;
	}

	return hr;
}

//-----------------------------------------------
// Thaw all the servers.
// This routine must not throw.  It's safe in a destructor
//
// DISCUSS WITH BRIAN....WE MUST RETURN "SUCCESS" only if the
// servers were all still frozen.  Otherwise the snapshot must
// have been cancelled.
//
HRESULT
Snapshot::Thaw () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Thaw");
	HRESULT	hr = S_OK;
	AutoNewHandler	t;

	// Ask the servers to thaw
	// 	
	for (ServerIter i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
	{
		try
		{
			if (!(*i)->Thaw ())
			{
				hr = E_SQLLIB_GENERIC;
			}
		}
		catch (...)
		{
			hr = E_SQLLIB_GENERIC;
			ft.LogError(VSS_ERROR_SQLLIB_ERRORTHAWSERVER, VSSDBG_SQLLIB << ((**i).GetName ()).c_str ());
		}
	}

	// We still have the original list of servers.
	// The snapshot object is reusable if another "Prepare" is done, which will
	// re-enumerate the servers.
	//
	m_Status = Enumerated;

	return hr;
}

// Setup some try/catch/handlers for our interface...
// The invoker defines "hr" which is set if an exception
// occurs.
//
#define TRY_SQLLIB \
	try	{\
		AutoNewHandler	_myNewHandler;

#define END_SQLLIB \
	} catch (HRESULT& e)\
	{\
		ft.hr = e;\
	}\
	catch (...)\
	{\
		ft.hr = E_SQLLIB_GENERIC;\
	}

//-------------------------------------------------------------------------
// Create an object to handle enumerations
//
CSqlEnumerator*
CreateSqlEnumerator () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlEnumerator");
	try
	{
		return new SqlEnumerator;
	}
	catch (...)
	{
		ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

//-------------------------------------------------------------------------
//
SqlEnumerator::~SqlEnumerator ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::~SqlEnumerator");

	if (m_pServers)
		delete m_pServers;
}

//-------------------------------------------------------------------------
// Begin retrieval of the servers.
//
HRESULT
SqlEnumerator::FirstServer (ServerInfo* pSrv) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstServer");


	if (m_pServers)
	{
		delete m_pServers;
		m_pServers = NULL;
	}

	m_CurrServer = 0;

	TRY_SQLLIB
	{
		m_pServers = EnumerateServers ();

		if (m_pServers->size () == 0)
		{
			ft.hr = DB_S_ENDOFROWSET;
		}
		else
        {
			wcscpy (pSrv->name, (*m_pServers)[0].c_str ());
			pSrv->isOnline = IsServerOnline (pSrv->name) ? true : false;

			m_CurrServer = 1;
			
			ft.hr = NOERROR;
        }
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the servers.
//
HRESULT
SqlEnumerator::NextServer (ServerInfo* pSrv) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextServer");


	if (!m_pServers)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
	{
		TRY_SQLLIB
		{
			if (m_CurrServer >= m_pServers->size ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
			{
				wcscpy (pSrv->name, (*m_pServers)[m_CurrServer].c_str ());
				m_CurrServer++;

				pSrv->isOnline = IsServerOnline (pSrv->name) ? true : false;
				
				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Begin retrieval of the databases
//
HRESULT
SqlEnumerator::FirstDatabase (const WCHAR *pServerName, DatabaseInfo* pDbInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstDatabase");

	TRY_SQLLIB
	{
		m_Connection.Connect (pServerName);
		m_Connection.SetCommand (
			L"select name,DATABASEPROPERTY(name,'IsTruncLog') from master..sysdatabases");
		m_Connection.ExecCommand ();

		if (!m_Connection.FetchFirst ())
		{
			ft.LogError(VSS_ERROR_SQLLIB_NORESULTFORSYSDB, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		WCHAR *pDbName = (WCHAR*)m_Connection.AccessColumn (1);
		int* pSimple = (int*)m_Connection.AccessColumn (2);

		wcscpy (pDbInfo->name, pDbName);
		pDbInfo->supportsFreeze = *pSimple &&
			m_Connection.GetServerVersion () >= 7;

		m_State = DatabaseQueryActive;

		ft.hr = NOERROR;
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the databases
//
HRESULT
SqlEnumerator::NextDatabase (DatabaseInfo* pDbInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextDatabase");

	if (m_State != DatabaseQueryActive)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
    {
		TRY_SQLLIB
		{
			if (!m_Connection.FetchNext ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
			{
				WCHAR* pDbName = (WCHAR*)m_Connection.AccessColumn (1);
				int* pSimple = (int*)m_Connection.AccessColumn (2);

				wcscpy (pDbInfo->name, pDbName);
				pDbInfo->supportsFreeze = *pSimple &&
					m_Connection.GetServerVersion () >= 7;

				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Begin retrieval of the database files
//
HRESULT
SqlEnumerator::FirstFile (
	const WCHAR*		pServerName,
	const WCHAR*		pDbName,
	DatabaseFileInfo*	pFileInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstFile");

	TRY_SQLLIB
	{
		m_Connection.Connect (pServerName);

		WString query;

		if (m_Connection.GetServerVersion () >= 8)
		{
			query =	L"select rtrim(filename),status & 64 from sysaltfiles where DB_ID('"
				+ WString(pDbName) + L"') = dbid";
		}
		else
		{
			query = L"select rtrim(filename),status & 64 from ["
				+ WString(pDbName) + L"]..sysfiles";
		}

		m_Connection.SetCommand (query);
		m_Connection.ExecCommand ();

		if (!m_Connection.FetchFirst ())
		{
			ft.LogError(VSS_ERROR_SQLLIB_NORESULTFORSYSDB, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		WCHAR* pName = (WCHAR*)m_Connection.AccessColumn (1);
		int* pLogFile = (int*)m_Connection.AccessColumn (2);

		wcscpy (pFileInfo->name, pName);
		pFileInfo->isLogFile = (*pLogFile != 0);

		m_State = FileQueryActive;

		ft.hr = NOERROR;
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the files
//
HRESULT
SqlEnumerator::NextFile (DatabaseFileInfo* pFileInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextFile");

	if (m_State != FileQueryActive)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
    {
		TRY_SQLLIB
		{
			if (!m_Connection.FetchNext ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
            {
				WCHAR* pName = (WCHAR*)m_Connection.AccessColumn (1);
				int* pLogFile = (int*)m_Connection.AccessColumn (2);

				wcscpy (pFileInfo->name, pName);
				pFileInfo->isLogFile = (*pLogFile != 0);

				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\sqlconnect.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlconnect.cpp
//
// PURPOSE:
//
//		Handle the OLEDB connection and commands
//
// NOTES:
//
// Extern dependencies:
//   provision of "_Module" and the COM guids....
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************


// the templates make awful, long names which result in excessive warnings
//
#ifdef HIDE_WARNINGS
#pragma warning( disable : 4663)
#pragma warning( disable : 4786)
#pragma warning( disable : 4100)
#pragma warning( disable : 4511)
#endif


#include <stdafx.h>
#include <atlbase.h>
#include <clogmsg.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLCONNC"
//
////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------
// routine to print out error information for a failed OLEDB request
//
// An optional parm is used to check for the 3014 code when a successful backup is
// erroneously marked as failed due to other problems (such as msdb access)
//
void DumpErrorInfo (
	IUnknown* pObjectWithError,
	REFIID IID_InterfaceWithError,
	CLogMsg &msg,
	BOOL*	pBackupSuccess = NULL
	)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"DumpErrorInfo");

    CComPtr<IErrorInfo> apIErrorInfoAll;
	CComPtr<IErrorInfo> apIErrorInfoRecord;
	CComPtr<IErrorRecords> apIErrorRecords;
	CComPtr<ISupportErrorInfo> apISupportErrorInfo;
	CComPtr<ISQLErrorInfo> apISQLErrorInfo;
	CComPtr<ISQLServerErrorInfo> apISQLServerErrorInfo;

    // Number of error records.
    ULONG nRecs;
    ULONG nRec;

    // Basic error information from GetBasicErrorInfo.
    ERRORINFO               errorinfo;

    // IErrorInfo values.
    CComBSTR bstrDescription;
    CComBSTR bstrSource;

    // ISQLErrorInfo parameters.
    CComBSTR bstrSQLSTATE;
    LONG lNativeError;
	

    // ISQLServerErrorInfo parameter pointers.
    SSERRORINFO* pSSErrorInfo = NULL;
    LPWSTR pSSErrorStrings = NULL;

    // Hard-code an American English locale for the example.
	//
	// **UNDONE** How should we internationalize properly?
	//
    DWORD MYLOCALEID = 0x0409;

	BOOL	msg3014seen = FALSE;
	BOOL	msg3013seen = FALSE;
	WCHAR buf[80];

    // Only ask for error information if the interface supports
    // it.
    if (FAILED(pObjectWithError->QueryInterface
					(
					IID_ISupportErrorInfo,
					(void**) &apISupportErrorInfo)
					))
    {
		ft.Trace (VSSDBG_SQLLIB, L"SupportErrorErrorInfo interface not supported");
		return;
    }

    if (FAILED(apISupportErrorInfo->InterfaceSupportsErrorInfo(IID_InterfaceWithError)))
    {
		ft.Trace (VSSDBG_SQLLIB, L"InterfaceWithError interface not supported");
		return;
    }


    // Do not test the return of GetErrorInfo. It can succeed and return
    // a NULL pointer in pIErrorInfoAll. Simply test the pointer.
    GetErrorInfo(0, &apIErrorInfoAll);

    if (apIErrorInfoAll != NULL)
    {
        // Test to see if it's a valid OLE DB IErrorInfo interface
        // exposing a list of records.

        if (SUCCEEDED(apIErrorInfoAll->QueryInterface (
						IID_IErrorRecords,
						(void**) &apIErrorRecords)))
        {
            apIErrorRecords->GetRecordCount(&nRecs);

			// Within each record, retrieve information from each
            // of the defined interfaces.
            for (nRec = 0; nRec < nRecs; nRec++)
            {
                // From IErrorRecords, get the HRESULT and a reference
                // to the ISQLErrorInfo interface.
                apIErrorRecords->GetBasicErrorInfo(nRec, &errorinfo);
				apIErrorRecords->GetCustomErrorObject (
					nRec,
                    IID_ISQLErrorInfo,
					(IUnknown**) &apISQLErrorInfo);

                // Display the HRESULT, then use the ISQLErrorInfo.
                ft.Trace(VSSDBG_SQLLIB, L"HRESULT:\t%#X\n", errorinfo.hrError);
                if (apISQLErrorInfo != NULL)
                {
                    apISQLErrorInfo->GetSQLInfo(&bstrSQLSTATE, &lNativeError);

                    // Display the SQLSTATE and native error values.
                    ft.Trace(
				        VSSDBG_SQLLIB,
						L"SQLSTATE:\t%s\nNative Error:\t%ld\n",
                        bstrSQLSTATE,
						lNativeError);

                    msg.Add(L"SQLSTATE: ");
					msg.Add(bstrSQLSTATE);
					swprintf(buf, L", Native Error: %d\n", lNativeError);
					msg.Add(buf);
					

					if (lNativeError == 3013)
						msg3013seen = TRUE;
					else if (lNativeError == 3014)
						msg3014seen = TRUE;

                    // Get the ISQLServerErrorInfo interface from
                    // ISQLErrorInfo before releasing the reference.
                    apISQLErrorInfo->QueryInterface (
                        IID_ISQLServerErrorInfo,
                        (void**) &apISQLServerErrorInfo);

					// Test to ensure the reference is valid, then
					// get error information from ISQLServerErrorInfo.
					if (apISQLServerErrorInfo != NULL)
					{
						apISQLServerErrorInfo->GetErrorInfo (
							&pSSErrorInfo,
							&pSSErrorStrings);

						// ISQLServerErrorInfo::GetErrorInfo succeeds
						// even when it has nothing to return. Test the
						// pointers before using.
						if (pSSErrorInfo)
						{
							// Display the state and severity from the
							// returned information. The error message comes
							// from IErrorInfo::GetDescription.
							ft.Trace
								(
								VSSDBG_SQLLIB,
								L"Error state:\t%d\nSeverity:\t%d\n",
								pSSErrorInfo->bState,
								pSSErrorInfo->bClass
								);

                            swprintf(buf, L"Error state: %d, Severity: %d\n",pSSErrorInfo->bState, pSSErrorInfo->bClass);
							msg.Add(buf);

							// IMalloc::Free needed to release references
							// on returned values. For the example, assume
							// the g_pIMalloc pointer is valid.
							g_pIMalloc->Free(pSSErrorStrings);
							g_pIMalloc->Free(pSSErrorInfo);
						}
						apISQLServerErrorInfo.Release ();
					}
					apISQLErrorInfo.Release ();

				} // got the custom error info

                if (SUCCEEDED(apIErrorRecords->GetErrorInfo	(
						nRec,
						MYLOCALEID,
						&apIErrorInfoRecord)))
				{
                    // Get the source and description (error message)
                    // from the record's IErrorInfo.
                    apIErrorInfoRecord->GetSource(&bstrSource);
					apIErrorInfoRecord->GetDescription(&bstrDescription);

					if (bstrSource != NULL)
						{
                        ft.Trace(VSSDBG_SQLLIB, L"Source:\t\t%s\n", bstrSource);
						msg.Add(L"Source: ");
						msg.Add(bstrSource);
						msg.Add(L"\n");
						}

                    if (bstrDescription != NULL)
						{
                        ft.Trace(VSSDBG_SQLLIB, L"Error message:\t%s\n", bstrDescription);
						msg.Add(L"Error message: ");
						msg.Add(bstrDescription);
						msg.Add(L"\n");
						}

					apIErrorInfoRecord.Release ();
                }
            } // for each record
		}
        else
        {
            // IErrorInfo is valid; get the source and
            // description to see what it is.
            apIErrorInfoAll->GetSource(&bstrSource);
            apIErrorInfoAll->GetDescription(&bstrDescription);
            if (bstrSource != NULL)
				{
                ft.Trace(VSSDBG_SQLLIB, L"Source:\t\t%s\n", bstrSource);
				msg.Add(L"Source: ");
				msg.Add(bstrSource);
				msg.Add(L"\n");
				}

            if (bstrDescription != NULL)
				{
                ft.Trace(VSSDBG_SQLLIB, L"Error message:\t%s\n", bstrDescription);
				msg.Add(L"Error message: ");
				msg.Add(bstrDescription);
				msg.Add(L"\n");
				}
        }
	}
    else
	{
        ft.Trace(VSSDBG_SQLLIB, L"GetErrorInfo failed.");
    }

	if (pBackupSuccess)
	{
		*pBackupSuccess = (msg3014seen && !msg3013seen);
	}
}

//------------------------------------------------------------------
//
SqlConnection::~SqlConnection ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::~SqlConnection");
	Disconnect ();
}

//------------------------------------------------------------------
//
void
SqlConnection::ReleaseRowset ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::ReleaseRowset");

	if (m_pBuffer)
	{
		delete[] m_pBuffer;
		m_pBuffer = NULL;
	}
	if (m_pBindings)
	{
		delete[] m_pBindings;
		m_pBindings = NULL;
	}
	m_cBindings = 0;
	if (m_pAccessor)
	{
		if (m_hAcc)
		{
			m_pAccessor->ReleaseAccessor (m_hAcc, NULL);
			m_hAcc = NULL;
		}
		m_pAccessor->Release ();
		m_pAccessor = NULL;
	}
	if (m_pRowset)
	{
		m_pRowset->Release ();
		m_pRowset = NULL;
	}
}

//------------------------------------------------------------------
//
void
SqlConnection::Disconnect ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConenction::Disconnect");

	ReleaseRowset ();
	if (m_pCommand)
	{
		m_pCommand->Release ();
		m_pCommand = NULL;
	}
	if (m_pCommandFactory)
	{
		m_pCommandFactory->Release ();
		m_pCommandFactory = NULL;
	}
}

// log an error if not an out of resource error
void SqlConnection::LogOledbError
	(
	CVssFunctionTracer &ft,
	CVssDebugInfo &dbgInfo,
	LPCWSTR wszRoutine,
	CLogMsg &msg
	)
	{
	if (ft.hr == E_OUTOFMEMORY ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		ft.Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
		ft.LogError(VSS_ERROR_SQLLIB_OLEDB_ERROR, dbgInfo << wszRoutine << ft.hr << msg.GetMsg());
		ft.Throw
			(
			dbgInfo,
			E_UNEXPECTED,
			L"Error calling %s.  hr = 0x%08lx.\n%s",
			wszRoutine,
			ft.hr,
			msg.GetMsg()
			);
        }
	}
	

//------------------------------------------------------------------
// Setup a session, ready to receive commands.
//
// This call may block for a long time while establishing the connection.
//
// See the "FrozenServer" object for a method to determine if the local
// server is up or not prior to requesting a connection.
//
// The "trick" of prepending "tcp:" to the servername isn't fast or robust
// enough to detect a shutdown server.
//
// Note for C programmers....BSTRs are used as part of the COM
// environment to be interoperable with VisualBasic.  The VARIANT
// datatype doesn't work with standard C strings.
//
void
SqlConnection::Connect (
	const WString&	serverName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::Connect");
	CLogMsg msg;

	CComPtr<IDBInitialize> apdbInitialize;

	// "Connect" always implies a "fresh" connection.
	//
	ReleaseRowset ();

	if (m_ServerName.compare (serverName) == 0 && m_pCommand)
	{
		// Requesting the same server and we are connected.
		//
		return;
	}

	Disconnect ();
	m_ServerName = serverName;

	ft.hr = CoCreateInstance
		(
		CLSID_SQLOLEDB,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IDBInitialize,
		(void **) &apdbInitialize
		);

	if (ft.HrFailed())
		ft.CheckForError(VSSDBG_SQLLIB, L"CoCreateInstance");

	CComPtr<IDBProperties> apdbProperties;
	ft.hr = apdbInitialize->QueryInterface(IID_IDBProperties, (void **) &apdbProperties);
	if (ft.HrFailed())
		ft.CheckForError(VSSDBG_SQLLIB, L"IDBInitialize::QueryInterface");

	CComBSTR bstrComputerName = serverName.c_str ();

	// initial database context
	CComBSTR bstrDatabaseName = L"master";

	// use NT Authentication
	CComBSTR bstrSSPI = L"SSPI";

	const unsigned x_CPROP = 3;
	DBPROPSET propset;
	DBPROP rgprop[x_CPROP];

	propset.guidPropertySet = DBPROPSET_DBINIT;
	propset.cProperties = x_CPROP;
	propset.rgProperties = rgprop;

	for (unsigned i = 0; i < x_CPROP; i++)
	{
		VariantInit(&rgprop[i].vValue);
		rgprop[i].dwOptions = DBPROPOPTIONS_REQUIRED;
		rgprop[i].colid = DB_NULLID;
		rgprop[i].vValue.vt = VT_BSTR;
	}

	rgprop[0].dwPropertyID = DBPROP_INIT_DATASOURCE;
	rgprop[1].dwPropertyID = DBPROP_INIT_CATALOG;
	rgprop[2].dwPropertyID = DBPROP_AUTH_INTEGRATED;
	rgprop[0].vValue.bstrVal = bstrComputerName;
	rgprop[1].vValue.bstrVal = bstrDatabaseName;
	rgprop[2].vValue.bstrVal = bstrSSPI;

	ft.hr = apdbProperties->SetProperties(1, &propset);
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbProperties, IID_IDBProperties, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBProperties::SetProperties", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Connecting to server %s...", serverName.c_str ());

	ft.hr = apdbInitialize->Initialize();
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbInitialize, IID_IDBInitialize, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBInitialize::Initialize", msg);
	}

	CComPtr<IDBCreateSession> apCreateSession;
	ft.hr = apdbInitialize->QueryInterface(IID_IDBCreateSession, (void **) &apCreateSession);
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbInitialize, IID_IDBInitialize, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBInitialize::QueryInterface", msg);
	}

	// We keep the command factory around to generate commands.
	//
	ft.hr = apCreateSession->CreateSession (
			NULL,
			IID_IDBCreateCommand,
			(IUnknown **) &m_pCommandFactory);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apCreateSession, IID_IDBCreateSession, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBCreateSession::CreateSession", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Connected\n");

	// Request the version of this server
	//
	DBPROPIDSET		versionSet;
	DBPROPID		versionID = DBPROP_DBMSVER;

	versionSet.guidPropertySet	= DBPROPSET_DATASOURCEINFO;
	versionSet.cPropertyIDs		= 1;
	versionSet.rgPropertyIDs	= &versionID;

	ULONG		propCount;
	DBPROPSET*	pPropSet;

	ft.hr = apdbProperties->GetProperties (1, &versionSet, &propCount, &pPropSet);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbProperties, IID_IDBProperties, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBProperties::GetProperties", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Version: %s\n", pPropSet->rgProperties->vValue.bstrVal);

	swscanf (pPropSet->rgProperties->vValue.bstrVal, L"%d", &m_ServerVersion);

	g_pIMalloc->Free(pPropSet->rgProperties);
	g_pIMalloc->Free(pPropSet);
}

//---------------------------------------------------------------------
//	Setup the command with some SQL text
//
void
SqlConnection::SetCommand (const WString& command)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::SetCommand");

	CLogMsg msg;

	// Release the result of the previous command
	//
	ReleaseRowset ();

	// We create the command on the first request, then keep only one
	// around in the SqlConnection.
	//
	if (!m_pCommand)
	{
		ft.hr = m_pCommandFactory->CreateCommand (NULL, IID_ICommandText,
			(IUnknown **) &m_pCommand);

		if (ft.HrFailed())
		{
			DumpErrorInfo(m_pCommandFactory, IID_IDBCreateCommand, msg);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IDBCreateCommand::CreateCommand", msg);
		}
	}

	ft.hr = m_pCommand->SetCommandText(DBGUID_DBSQL, command.c_str ());
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pCommand, IID_ICommandText, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"ICommandText::SetCommandText", msg);
	}
	ft.Trace (VSSDBG_SQLLIB, L"SetCommand (%s)\n", command.c_str ());
}

//---------------------------------------------------------------------
//	Execute the command.  "SetCommand" must have been called previously.
//
BOOL
SqlConnection::ExecCommand ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::ExecCommand");

	CLogMsg msg;

	CComPtr<IRowset> apRowset;
	DBROWCOUNT	crows;
	HRESULT		hr;

	// Release the result of the previous command
	//
	ReleaseRowset ();

	ft.hr = m_pCommand->Execute (
			NULL,
			IID_IRowset,
			NULL,
			&crows,
			(IUnknown **) &m_pRowset);

    if (ft.HrFailed())
	{
		BOOL	backupSuccess = FALSE;

		DumpErrorInfo (m_pCommand, IID_ICommandText, msg, &backupSuccess);

		if (!backupSuccess)
			LogOledbError(ft, VSSDBG_SQLLIB, L"ICommandText::Execute", msg);
	}

	if (!m_pRowset)
	{
		ft.Trace(VSSDBG_SQLLIB, L"Command completed successfully with no rowset\n");
		return FALSE;
	}
	return TRUE;
}

//---------------------------------------------------------------------
// return a vector of string, one for each row of the output.
// The query should have returned a single column.
//
StringVector*
SqlConnection::GetStringColumn ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::GetStringColumn");
	CLogMsg msg;

	//ASSERT (m_pRowset)
	//

	CComPtr<IColumnsInfo> apColumnsInfo;
	ft.hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **) &apColumnsInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	// get columns info
	//
	DBCOLUMNINFO *rgColumnInfo;
	DBORDINAL cColumns;
	WCHAR *wszColumnInfo;
	ft.hr = apColumnsInfo->GetColumnInfo(&cColumns, &rgColumnInfo, &wszColumnInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (apColumnsInfo, IID_IColumnsInfo, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IColumnsInfo::GetColumnInfo", msg);
	}

	// Auto objects ensure that memory is freed on exit
	//
	CAutoTask<DBCOLUMNINFO> argColumnInfo = rgColumnInfo;
	CAutoTask<WCHAR> awszColumnInfo = wszColumnInfo;

	// Setup a buffer to hold the string.
	// The output buffer holds a 4byte length, followed by the string column.
	//
	// "bufferSize" is in units of characters (not bytes)
	// Note that the "ulColumnSize" is in characters.
	// 1 char is used for the null term and we actually allocate one additional
	// char (hidden), just incase our provider gets the boundary condition wrong.
	//
	ULONG bufferSize = 1 + rgColumnInfo[0].ulColumnSize + (sizeof(ULONG)/sizeof(WCHAR));
	std::auto_ptr<WCHAR> rowBuffer(new WCHAR[bufferSize+1]);

	// Describe the binding for our single column of interest
	//
	DBBINDING	rgbind[1];
	unsigned	cBindings = 1;

	rgbind[0].dwPart	= DBPART_VALUE|DBPART_LENGTH;
	rgbind[0].wType		= DBTYPE_WSTR;	// retrieve a
	rgbind[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	rgbind[0].eParamIO	= DBPARAMIO_NOTPARAM;
	rgbind[0].pObject	= NULL;
	rgbind[0].pBindExt	= NULL;
	rgbind[0].pTypeInfo = NULL;
	rgbind[0].dwFlags	= 0;
	rgbind[0].obLength	= 0;		// offset to the length field
	rgbind[0].iOrdinal	= 1;		// column id's start at 1
	rgbind[0].obValue	= sizeof(ULONG);	// offset to the string field		
	rgbind[0].cbMaxLen	= (unsigned) (bufferSize*sizeof(WCHAR)-sizeof(ULONG));

	CComPtr<IAccessor> apAccessor;
	ft.hr = m_pRowset->QueryInterface(IID_IAccessor, (void **) &apAccessor);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	HACCESSOR hacc;
	ft.hr = apAccessor->CreateAccessor (
		DBACCESSOR_ROWDATA,
		cBindings,
		rgbind,
        0,
		&hacc,
		NULL);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apAccessor, IID_IAccessor, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IAccessor::CreateAccessor", msg);
	}

	// loop through rows, generating a vector of strings.
	//

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;
	std::auto_ptr<StringVector> aVec (new StringVector);
	
	// pString points into the output buffer for the string column
	//
	WCHAR*	pString = (WCHAR*)((BYTE*)rowBuffer.get () + sizeof (ULONG));

	while(TRUE)
	{
		ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
		if (ft.hr == DB_S_ENDOFROWSET)
			break;

		if (ft.HrFailed())
		{
			DumpErrorInfo (m_pRowset, IID_IRowset, msg);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
		}

		ft.hr = m_pRowset->GetData (hrow, hacc, rowBuffer.get());
		if (ft.HrFailed())
		{
			DumpErrorInfo(m_pRowset, IID_IRowset, msg);
			m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
		}

		unsigned	tempChars = (*(ULONG*)rowBuffer.get ())/sizeof (WCHAR);
		WString	tempStr (pString, tempChars);
		aVec->push_back (tempStr);

		ft.Trace(VSSDBG_SQLLIB, L"StringColumn: %s\n", tempStr.c_str ());

		m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);
	}

	// UNDONE...make this an auto object to avoid leaks
	//
	apAccessor->ReleaseAccessor (hacc, NULL);

	return aVec.release ();
}


//---------------------------------------------------------------------
// Fetch the first row of the result.
//
BOOL
SqlConnection::FetchFirst ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::FetchFirst");
	CLogMsg msg;


	// UNDONE...make this nicely restep back to the first row.
	//
	if (m_pBindings)
	{
		throw HRESULT(E_SQLLIB_PROTO);
	}

	CComPtr<IColumnsInfo> apColumnsInfo;
	ft.hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **) &apColumnsInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInteface", msg);
	}

	// get columns info
	//
	DBCOLUMNINFO *rgColumnInfo;
	DBORDINAL cColumns;
	WCHAR *wszColumnInfo;
	ft.hr = apColumnsInfo->GetColumnInfo(&cColumns, &rgColumnInfo, &wszColumnInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (apColumnsInfo, IID_IColumnsInfo, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IColumnsInfo::GetColumnInfo", msg);
	}

	// Auto objects ensure that memory is freed on exit
	//
	CAutoTask<DBCOLUMNINFO> argColumnInfo = rgColumnInfo;
	CAutoTask<WCHAR> awszColumnInfo = wszColumnInfo;

	// allocate bindings
	unsigned m_cBindings = (unsigned) cColumns;
	m_pBindings = new DBBINDING[m_cBindings];

	// Set up the bindings onto a buffer we'll allocate
	// UNDONE: do this properly for alignment & handling null indicators
	//

	unsigned cb = 0;
	for (unsigned icol = 0; icol < m_cBindings; icol++)
	{
		unsigned maxBytes;

		m_pBindings[icol].iOrdinal	= icol + 1;
		m_pBindings[icol].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_pBindings[icol].eParamIO	= DBPARAMIO_NOTPARAM;
		m_pBindings[icol].pObject	= NULL;
		m_pBindings[icol].pBindExt	= NULL;
		m_pBindings[icol].pTypeInfo	= NULL;
		m_pBindings[icol].dwFlags	= 0;
		m_pBindings[icol].bPrecision	= rgColumnInfo[icol].bPrecision;
		m_pBindings[icol].bScale		= rgColumnInfo[icol].bScale;

		m_pBindings[icol].obStatus = 0; // no status info

		if (rgColumnInfo[icol].wType == DBTYPE_WSTR)
		{	// do we need the length?
			m_pBindings[icol].dwPart = DBPART_VALUE; //|DBPART_LENGTH;
			m_pBindings[icol].wType	= DBTYPE_WSTR;
			m_pBindings[icol].obLength = 0; //icol * sizeof(DBLENGTH);
			maxBytes = rgColumnInfo[icol].ulColumnSize * sizeof(WCHAR);
		}
		else
		{
			m_pBindings[icol].dwPart = DBPART_VALUE;
			m_pBindings[icol].wType = rgColumnInfo[icol].wType;
			m_pBindings[icol].obLength = 0;  // no length
			maxBytes = rgColumnInfo[icol].ulColumnSize;
		}

		m_pBindings[icol].obValue = cb;
		m_pBindings[icol].cbMaxLen = maxBytes;
		
		cb += maxBytes;
	}

	// allocate data buffer
	//
	m_pBuffer = new BYTE[cb];
	m_BufferSize = cb;

	ft.hr = m_pRowset->QueryInterface(IID_IAccessor, (void **) &m_pAccessor);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	ft.hr = m_pAccessor->CreateAccessor (
		DBACCESSOR_ROWDATA,
		m_cBindings,
		m_pBindings,
        0,
		&m_hAcc,
		NULL);

	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pAccessor, IID_IAccessor, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IAccessor::CreateAccessor", msg);
	}

	// Fetch the first row
	//

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;

	ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
	if (ft.hr == DB_S_ENDOFROWSET)
	{
		// No rows in this set
		//
		return FALSE;
	}

	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
	}

	ft.hr = m_pRowset->GetData (hrow, m_hAcc, m_pBuffer);
	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pRowset, IID_IRowset, msg);
		m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
	}

	m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);

	return TRUE;
}


//---------------------------------------------------------------------
// Fetch the next row of the result.
//
BOOL
SqlConnection::FetchNext ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::FetchNext");

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;
	CLogMsg msg;

	ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
	if (ft.hr == DB_S_ENDOFROWSET)
	{
		return FALSE;
	}

	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
	}

	ft.hr = m_pRowset->GetData (hrow, m_hAcc, m_pBuffer);
	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pRowset, IID_IRowset, msg);
		m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
	}

	m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);

	return TRUE;
}

//-----------------------------------------------------------
// Provide a pointer to the n'th column.
//
void*
SqlConnection::AccessColumn (int colid)
{
	return m_pBuffer + m_pBindings[colid-1].obValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\sqlsnapi.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlsnapi.h
//
// PURPOSE:
//
//		The internal include file for the sql snapshot module
//
// NOTES:
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************


#include <string>
#include <vector>
#include <list>

#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

#include "vdi.h"        // interface declaration from SQLVDI kit

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLSNPIH"
//
////////////////////////////////////////////////////////////////////////

typedef unsigned long	ULONG;
typedef wchar_t			WCHAR;

#define TRUE 1
#define FALSE 0

class CLogMsg;


// Unexpected, "internal" errors can be logged with some
// generic international text, like "Internal error: <English servicibility text>"
//
// Situations we expect, for which the user needs to know should
// occur with proper internationalization
//

// Process wide globals used by the sql modules
//
extern IMalloc *	g_pIMalloc;

//-------------------------------------------------------------------------
//
typedef std::wstring					WString;
typedef std::vector<WString>			StringVector;
typedef StringVector::const_iterator	StringVectorIter;
typedef std::list<WString>				StringList;
typedef StringList::const_iterator		StringListIter;

StringVector* EnumerateServers ();

//-------------------------------------------------------------------------
// Handle our simple needs for DB services.
//
// Useage:
//    - Connect :		establish a connection to a given server
//    - SetCommand:		setup the SQL text to send
//    - ExecCommand:	execute some SQL, returns TRUE if a result set
//					is open and ready for retrieval
//	  - Get*:			retrieve info from the result set
//	
// The destructor will automatically disconnect from the server.
//
class SqlConnection
{
public:
	SqlConnection () :
		m_pCommandFactory (NULL),
		m_pCommand (NULL),
		m_pRowset (NULL),
		m_pBuffer (NULL),
		m_BufferSize (0),
		m_hAcc (NULL),
		m_pAccessor (NULL),
		m_pBindings (NULL),
		m_cBindings (0)
	{}

	~SqlConnection ();

	void
	Connect (const std::wstring& serverName);

	void
	Disconnect ();

	void
	ReleaseRowset ();
		
	void	
	SetCommand (const std::wstring& command);

	BOOL	
	ExecCommand ();

	StringVector*
	GetStringColumn ();

	ULONG
	GetServerVersion () {return m_ServerVersion;}

	BOOL
	FetchFirst ();
	
	BOOL
	FetchNext ();
	
	void*
	AccessColumn (int id);

private:
	void LogOledbError
		(
		CVssFunctionTracer &ft,
		CVssDebugInfo &dbgInfo,
		LPCWSTR wszRoutine,
		CLogMsg &msg
		);

	WString						m_ServerName;
	IDBCreateCommand*			m_pCommandFactory;
	ICommandText*				m_pCommand;
	IRowset*					m_pRowset;
	ULONG						m_ServerVersion;

	// used for the generic findfirst/findnext
	DBBINDING*					m_pBindings;
	ULONG						m_cBindings;
	BYTE*						m_pBuffer;
	ULONG						m_BufferSize;
	HACCESSOR					m_hAcc;
	IAccessor*					m_pAccessor;
};

BOOL
IsServerOnline (const WCHAR*	serverName);

//-------------------------------------------------------------------------
// In SQL2000 we'll use VDI snapshots to avoid bug 58266: thaw fails.
//
//  We'll prepare each database by starting a BACKUP WITH SNAPSHOT.
//  This will require one thread per database.
//  The backups will stall waiting for the VDI client to pull metadata.
//  When the "freeze" message comes along, the controlling thread will
//  pull all the BACKUPs to the frozen state.
//  Later the "thaw" message results in gathering the "success" report
//  from each thread.
//
//

class Freeze2000
{
public:
	enum VDState
	{
		Unknown=0, Created, Open, SnapshotOpen
	};
private:
	class FrozenDatabase
	{
		friend Freeze2000;

		FrozenDatabase () :
			m_pContext (NULL),
			m_hThread (NULL),
			m_pIVDSet (NULL),
			m_pIVD (NULL),
			m_pSnapshotCmd (NULL),
			m_VDState (Unknown),
			m_SuccessDetected (FALSE)
		{}

		Freeze2000*					m_pContext;
		HANDLE						m_hThread;
		IClientVirtualDeviceSet2*   m_pIVDSet;
		IClientVirtualDevice*       m_pIVD;
		WString						m_DbName;
	    VDC_Command*				m_pSnapshotCmd;
		VDState						m_VDState;
		WCHAR						m_SetName [80];
		bool						m_SuccessDetected;
	};

public:
	Freeze2000 (
		const WString&	serverName,
		ULONG			maxDatabases);

	~Freeze2000 ();

	void
	PrepareDatabase (
		const WString&	dbName);
	
	void
	WaitForPrepare ();

	void
	Freeze ();

	BOOL
	Thaw () throw ();

	static DWORD
	DatabaseThreadStart (LPVOID	pContext);

private:
	enum State {
		Unprepared,
		Preparing,
		Prepared,
		Frozen,
		Complete,
		Aborted
	};

	DWORD
	DatabaseThread (
		FrozenDatabase*	pDbContext);

	void
	WaitForThreads ();

	void
	AdvanceVDState (bool toSnapshot);

	void		// race-free method to persist an abort condition
	SetAbort ()
	{
		InterlockedIncrement (&m_AbortCount);
	}

	bool		// return true if the freeze is aborting
	CheckAbort ()
	{
		return 0 != InterlockedCompareExchange (&m_AbortCount, 0, 0);
	}

	void
	Abort () throw ();

	void
	Lock ()
	{
		EnterCriticalSection (&m_Latch);
	}
	void
	Unlock ()
	{	
		LeaveCriticalSection (&m_Latch);
	}
	BOOL	// return TRUE if we got the lock
	TryLock ()
	{
		return TryEnterCriticalSection (&m_Latch);
	}

	LONG				m_AbortCount;
	CRITICAL_SECTION	m_Latch;		
	State				m_State;
	WString				m_ServerName;
	GUID				m_BackupId;
	ULONG				m_NumDatabases;
	ULONG				m_MaxDatabases;
	FrozenDatabase*		m_pDBContext;
};

//-------------------------------------------------------------------------
// Represent a server which can be frozen.
//
class FrozenServer
{
public:
	FrozenServer (const std::wstring& serverName) :
		m_Name (serverName),
		m_pFreeze2000 (NULL)
	{}

	~FrozenServer ()
	{
		if (m_pFreeze2000)
		{
			delete m_pFreeze2000;
			m_pFreeze2000 = NULL;
		}
	}

	const std::wstring& GetName () const
	{ return m_Name; }

	BOOL
	FindDatabasesToFreeze (
		CCheckPath*		checker);

	BOOL
	Prepare ();

	BOOL
	Freeze ();

	BOOL
	Thaw () throw ();

private:
	BOOL
	FindDatabases2000 (
		CCheckPath*		checker);

	void
	GetDatabaseProperties (const WString& dbName,
		BOOL*	pSimple,
		BOOL*	pOnline);

private:
	std::wstring	m_Name;
	SqlConnection	m_Connection;
	StringList		m_FrozenDatabases;
	Freeze2000*		m_pFreeze2000;
};

//-------------------------------------------------------------------------
//
class Snapshot : public CSqlSnapshot
{
	enum Status {
		NotInitialized,
		Enumerated,
		Prepared,
		Frozen };

public:
	HRESULT Prepare (
		CCheckPath*		checker) throw ();

	HRESULT Freeze () throw ();

	HRESULT Thaw () throw ();

	Snapshot () {m_Status = NotInitialized;}

	~Snapshot () throw ();

private:
	void
	Deinitialize ();

	Status						m_Status;
	std::list<FrozenServer*>	m_FrozenServers;

	typedef std::list<FrozenServer*>::iterator ServerIter;
};

// We'll use very simple exception handling.
//
#define THROW_GENERIC  throw exception ();

//----------------------------------------------------------
// Implement our simple enumeration service
//
class SqlEnumerator : public CSqlEnumerator
{
	enum Status {
		Unknown = 0,
		DatabaseQueryActive,
		FileQueryActive
	};

public:
	~SqlEnumerator () throw ();

	SqlEnumerator () :
		m_State (Unknown),
		m_pServers (NULL)
	{}

	HRESULT FirstServer (
		ServerInfo*			pServer) throw ();

	HRESULT NextServer (
		ServerInfo*			pServer) throw ();

	HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pDbInfo) throw ();

	HRESULT NextFile (
		DatabaseFileInfo*	pDbInfo) throw ();

private:
	Status			m_State;
	SqlConnection	m_Connection;
	StringVector*	m_pServers;
	int				m_CurrServer;
};

#if defined (DEBUG)

// Type of assertion passed through to utassert_fail function.
//


#define DBG_ASSERT(exp)  BS_ASSERT(exp)

// Allow for noop 64 bit asserts on win32 for things like
// overflowing 32 bit long, etc.
//
#ifdef _WIN64
 #define DBG64_ASSERT(exp) BS_ASSERT(exp)
#else
 #define DBG64_ASSERT(exp)
#endif

#else
 #define DBG_ASSERT(exp)
 #define DBG64_ASSERT(exp)
 #define DBG_ASSERTSZ(exp, txt)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\sqlenum.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlenum.cpp
//
// PURPOSE:
//
//      Enumerate the sqlservers available on the local node.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     68067 srs  11/06/00 ntsnap fix
//     67026 srs  10/05/00 Server enumeration bugs
//
//
// @EndHeader@
// ***************************************************************************

#ifdef HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>
#include <clogmsg.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLENUMC"
//
////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------
// ODBC error reporter
//
void PrintODBCError
	(
	SQLSMALLINT HandleType,
	SQLHANDLE hHandle,
	CLogMsg &msg
	)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"PrintODBCError");

	INT		i;
	INT		j;
	SDWORD NativeErr;
	INT severity;
	INT msgstate;
	DBUSMALLINT LineNumber;
	WCHAR	szSQLState[SQL_SQLSTATE_SIZE + 1];
	WCHAR   szMsg     [1024 + 1];
	WCHAR   ServerName[SQL_MAX_SQLSERVERNAME + 1];
	WCHAR   ProcName  [SQL_MAX_SQLSERVERNAME + 1];


	if (SQLGetDiagField(
		HandleType,
		hHandle,
		0,
		SQL_DIAG_NUMBER,
		&i,
		sizeof(i),
		NULL) == SQL_ERROR )
	{
		ft.Trace(VSSDBG_SQLLIB, L"SQLGetDiagField failed");
	}
	else
	{
		for (j = 1; j <= i; j++)
		{
			if (SQLGetDiagRecW (
				HandleType,
				hHandle,
				(SQLSMALLINT)j,
				(SQLWCHAR*)szSQLState,	
				&NativeErr,
				(SQLWCHAR*) szMsg,
				sizeof(szMsg) / sizeof(WCHAR),
				NULL) == SQL_ERROR )
			{
				ft.Trace (VSSDBG_SQLLIB, L"SQLGetDiagRec failed");
			}
			else
			{	
				//	Get driver specific diagnostic fields
				//
				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_MSGSTATE,
					&msgstate,
					SQL_IS_INTEGER,
					NULL) == SQL_ERROR )
				{
					msgstate = 0;
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_SEVERITY,
					&severity,
					SQL_IS_INTEGER,
					NULL) == SQL_ERROR )
				{
					severity = 0;
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_SRVNAME,
					&ServerName,
					sizeof(ServerName),
					NULL) == SQL_ERROR )
				{
					ServerName[0] = L'\0';
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_PROCNAME,
					&ProcName,
					sizeof(ProcName),
					NULL) == SQL_ERROR )
				{
					ProcName[0] = L'\0';
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_LINE,
					&LineNumber,
					SQL_IS_SMALLINT,
					NULL) == SQL_ERROR )
				{
					LineNumber = 0;
				}

				ft.Trace
					(
					VSSDBG_SQLLIB,
					L"ODBC Error: Msg %d, SevLevel %d, State %d, SQLState %s\n%s\n",
                    NativeErr,
                    severity,
                    msgstate,
                    szSQLState,
					szMsg
					);

            WCHAR buf[80];
			swprintf(buf, L"Error: %d, Severity: %d, State: %d, SQLState: ", NativeErr, severity, msgstate);
			msg.Add(buf);
            msg.Add(szSQLState);
			msg.Add(L"\n ProcName: ");
			msg.Add(ProcName);
			swprintf(buf, L", Line Number: %d, ServerName: ", LineNumber);
			msg.Add(buf);
			msg.Add(L"\n");
			msg.Add(szMsg);
			}
		} // for( j = 1; j <= i; j++ )
	}
}

//------------------------------------------------------------
// Scanner to locate servernames in a "BrowseConnect" string.
//
class BrowseServers
{
public:
	const WCHAR* FindFirst (const WCHAR* source, unsigned* nameLen);
	const WCHAR* FindNext (unsigned* nameLen);

private:
	const WCHAR*	m_CurrChar;
};

const WCHAR*
BrowseServers::FindFirst (const WCHAR *source, unsigned* nameLen)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"BrowseServers::FindFirst");

	const WCHAR*	pChar;
	const WCHAR		Prefix[] = L"Server={";

	m_CurrChar = NULL;
	if (source == NULL)
		return NULL;

	pChar = wcsstr (source, Prefix);
	if (pChar == NULL)
		return NULL;

	m_CurrChar = pChar + wcslen (Prefix);

	if (*m_CurrChar == L'}')
	{
		// The server list is empty
		//
		m_CurrChar = NULL;
		return NULL;
	}

	if (nameLen)
	{
		*nameLen = wcscspn (m_CurrChar, L",;}");
	}
	return m_CurrChar;
}

const WCHAR*
BrowseServers::FindNext (unsigned* nameLen)
{
	const WCHAR*	pChar;

	if (m_CurrChar == NULL)
		return NULL;

	pChar = wcschr (m_CurrChar, L',');
	if (pChar == NULL)
	{
		m_CurrChar = NULL;
		return NULL;
	}
	m_CurrChar = pChar + 1;
	if (nameLen)
	{
		*nameLen = wcscspn (m_CurrChar, L",;}");
	}
	return m_CurrChar;
}

//------------------------------------------------------------------------
// Return true if we could fetch the version of the SQLServer ODBC driver
//
bool
GetSQLDriverVersion (int* major, int* minor)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"GetSQLDriverVersion");

	DWORD	status;
	HKEY	hKey;
	WCHAR	driver[MAX_PATH+1];
    DWORD	vType;
    DWORD	pathLen = MAX_PATH;

    status = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        L"Software\\ODBC\\ODBCINST.INI\\SQL Server",
        0,
        KEY_QUERY_VALUE,
        &hKey);

    if (status != ERROR_SUCCESS)
    {
		ft.Trace (VSSDBG_SQLLIB, L"SQL not installed. Regkey status %d", status);
		return false;
	}

    status = (DWORD) RegQueryValueExW (
        hKey,
        L"Driver",
        NULL,
        &vType,
        (BYTE*)driver,
        &pathLen);

    RegCloseKey (hKey);

    if (status != ERROR_SUCCESS)
    {
		ft.Trace(VSSDBG_SQLLIB, L"SQL Driver installed wrong: %d\n", status);
		return false;
	}

	char	versionInfo [4096];

	if (!GetFileVersionInfoW (driver, 0, 4096, versionInfo))
	{
		ft.Trace(VSSDBG_SQLLIB, L"SQL Driver version not found: %d", GetLastError ());
		return false;
	}

	VS_FIXEDFILEINFO*   pInfo;
	UINT				infoSize;
	if (!VerQueryValueW (versionInfo, L"\\", (LPVOID*)&pInfo, &infoSize))
	{
		ft.Trace(VSSDBG_SQLLIB, L"version info resource not found: %d", GetLastError ());
		return false;
	}
	
	*major = pInfo->dwFileVersionMS >> 16;
	*minor = pInfo->dwFileVersionMS & 0x0FFFF;
	return true;
}

//------------------------------------------------------------------------
// Build the list of servers on the current machine.
// Throws exception if any errors occur.
//
StringVector*
EnumerateServers ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"EnumerateServers");

	SQLHENV		henv			= SQL_NULL_HANDLE;
	SQLHDBC		hdbc			= SQL_NULL_HANDLE;
	RETCODE		rc;
	LPWSTR		lpBuffer		= NULL;
	StringVector*	serverList = new StringVector;
	CLogMsg msg;


	int major, minor;
	if (!GetSQLDriverVersion (&major, &minor))
	{
		// SQL isn't installed right, so just ignore it, return empty list.
		//
		return serverList;
	}
	if (major < 2000)
	{
		// Require the modern MDAC to give a proper enumeration.
		//
		ft.LogError(VSS_ERROR_SQLLIB_UNSUPPORTEDMDAC, VSSDBG_SQLLIB << major << minor);
		throw HRESULT (E_SQLLIB_NO_SUPPORT);

		// ORIGINAL CODE:
		// May have a 6.5 or 7.0 server.  We aren't sure, but the
		// caller can determine if the server is up itself.
		//
		//serverList->push_back (L"(local)");
		//return serverList;
	}

	// SQL2000 or better
	//
	try
	{
		if (SQLAllocHandle(SQL_HANDLE_ENV, NULL, &henv) == SQL_ERROR)
		{
			ft.LogError(VSS_ERROR_SQLLIB_SQLAllocHandle_FAILED, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		rc = SQLSetEnvAttr(
			henv,
			SQL_ATTR_ODBC_VERSION,
			(SQLPOINTER)SQL_OV_ODBC3,
			0);

		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_ENV, henv, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetEnvAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		rc = SQLSetEnvAttr(
			henv,
			SQL_ATTR_CONNECTION_POOLING,
			(SQLPOINTER)SQL_CP_OFF,
			0);
		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_ENV, henv, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetEnvAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		rc = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);
		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_ENV, henv, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetAllocHandle" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		// Note: older versions of sqlsvr32 don't support
		// these connect attributes, but the failure to
		// recognize them isn't detected until the actual
		// SQLBrowseConnect call.  For old sqlsrv32, the
		// "list of servers" performs a domain search!
		//

		rc = SQLSetConnectAttr (
			hdbc,
			SQL_COPT_SS_BROWSE_CONNECT,
			(SQLPOINTER)SQL_MORE_INFO_YES,
			SQL_IS_UINTEGER);

		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_DBC, hdbc, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetConnectAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		rc = SQLSetConnectAttrW (
			hdbc,
			SQL_COPT_SS_BROWSE_SERVER,
			(SQLPOINTER)L"(local)",
			SQL_NTS);

		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_DBC, hdbc, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetConnectAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		// We use the maximum buffer supported in ODBC.
		//
		#define MAX_BUFFER 0x7ff0
		lpBuffer = new WCHAR [MAX_BUFFER];
		SQLSMALLINT browseLen;

		rc = SQLBrowseConnectW (
			hdbc,
			L"Driver={SQL Server}",
			SQL_NTS,
			lpBuffer,
			MAX_BUFFER,
			&browseLen);

		//ft.Trace(VSSDBG_SQLLIB, L"browse connect rc: %d", rc);

		if (rc != SQL_NEED_DATA)
		{
			PrintODBCError(SQL_HANDLE_DBC, hdbc, msg);

			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetConnectAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		// check for SQL6.5 in any of the servers
		//
		WCHAR	*pVersion = lpBuffer;
		int srvVer;
		while (1)
		{
			pVersion = wcsstr (pVersion, L";Version:");
			if (!pVersion)
				break;

			pVersion += 9;
			srvVer = 0;
			swscanf (pVersion, L"%u", &srvVer);
			if (srvVer < 7)
			{
				ft.LogError(VSS_ERROR_SQLLIB_UNSUPPORTEDSQLSERVER, VSSDBG_SQLLIB << srvVer);
				throw HRESULT (E_SQLLIB_NO_SUPPORT);
			}
		}

		//ft.Trace(VSSDBG_SQLLIB, L"BrowseResult:%s", lpBuffer);

		// Scan to count the servers
		//
		BrowseServers	scanner;
		if (NULL == scanner.FindFirst (lpBuffer, NULL))
		{
			ft.Trace(VSSDBG_SQLLIB, L"No servers found!\n");
		}
		else
		{
			unsigned		i,nameLen;
			const WCHAR*	pServerName;
			unsigned int	cServers = 1;

			while (scanner.FindNext (NULL) != NULL)
			{
				cServers++;
			}

			serverList->reserve (cServers);

			pServerName = scanner.FindFirst (lpBuffer, &nameLen);
			serverList->push_back (std::wstring (pServerName, nameLen));

			i = 1;
			while (i < cServers)
			{
				pServerName = scanner.FindNext (&nameLen);
				serverList->push_back (std::wstring (pServerName, nameLen));
				i++;
			}
		}

		if (lpBuffer)
		{
			delete [] lpBuffer;
		}

		if (hdbc)
		{
			SQLDisconnect(hdbc);
			SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
		}

		if (henv)
		{
			SQLFreeHandle(SQL_HANDLE_ENV, henv);
		}
	}
	catch (...)
	{
		if (lpBuffer)
		{
			delete [] lpBuffer;
		}

		if (hdbc)
		{
			SQLDisconnect(hdbc);
			SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
		}

		if (henv)
		{
			SQLFreeHandle(SQL_HANDLE_ENV, henv);
		}

		delete serverList;

		throw;
	}

	return serverList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\stdafx.h ===
#include <memory>

#ifndef __VSS_STDAFX_HXX__
#define __VSS_STDAFX_HXX__

#if _MSC_VER > 1000
#pragma once
#endif

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)

//
// C4511: copy constructor could not be generated
//
#pragma warning(disable:4511)


//
//  Warning: ATL debugging turned off (BUG 250939)
//
//  #ifdef _DEBUG
//  #define _ATL_DEBUG_INTERFACES
//  #define _ATL_DEBUG_QI
//  #define _ATL_DEBUG_REFCOUNT
//  #endif // _DEBUG


#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>
#include <odbcss.h>

#include "vs_inc.hxx"

#include "sqlsnap.h"
#include "sqlsnapi.h"
#include <auto.h>
#include "vssmsg.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\inc\odbcss.h ===
/*
** ODBCSS.H - This is the application include file for the
** SQL Server driver specific defines.
**
** (C) Copyright 1993-1998 By Microsoft Corp.
**
*/

#ifndef __ODBCSS
#define __ODBCSS

#ifdef __cplusplus
extern "C" { 			/* Assume C declarations for C++   */
#endif  /* __cplusplus */

//	Useful defines
#define SQL_MAX_SQLSERVERNAME	128		// max SQL Server identifier length

//	SQLSetConnectOption/SQLSetStmtOption driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

//	Connection Options
#define SQL_COPT_SS_BASE				1200
#define SQL_COPT_SS_REMOTE_PWD			(SQL_COPT_SS_BASE+1) // dbrpwset SQLSetConnectOption only
#define SQL_COPT_SS_USE_PROC_FOR_PREP	(SQL_COPT_SS_BASE+2) // Use create proc for SQLPrepare
#define SQL_COPT_SS_INTEGRATED_SECURITY	(SQL_COPT_SS_BASE+3) // Force integrated security on login
#define SQL_COPT_SS_PRESERVE_CURSORS	(SQL_COPT_SS_BASE+4) // Preserve server cursors after SQLTransact
#define SQL_COPT_SS_USER_DATA			(SQL_COPT_SS_BASE+5) // dbgetuserdata/dbsetuserdata
#define SQL_COPT_SS_ENLIST_IN_DTC		SQL_ATTR_ENLIST_IN_DTC // Enlist in a DTC transaction
#define SQL_COPT_SS_ENLIST_IN_XA		SQL_ATTR_ENLIST_IN_XA // Enlist in a XA transaction
#define SQL_COPT_SS_CONNECTION_DEAD		SQL_ATTR_CONNECTION_DEAD // dbdead SQLGetConnectOption only
#define SQL_COPT_SS_FALLBACK_CONNECT	(SQL_COPT_SS_BASE+10) // Enables FallBack connections
#define SQL_COPT_SS_PERF_DATA			(SQL_COPT_SS_BASE+11) // Used to access SQL Server ODBC driver performance data
#define SQL_COPT_SS_PERF_DATA_LOG		(SQL_COPT_SS_BASE+12) // Used to set the logfile name for the Performance data
#define SQL_COPT_SS_PERF_QUERY_INTERVAL (SQL_COPT_SS_BASE+13) // Used to set the query logging threshold in milliseconds.
#define SQL_COPT_SS_PERF_QUERY_LOG		(SQL_COPT_SS_BASE+14) // Used to set the logfile name for saving queryies.
#define SQL_COPT_SS_PERF_QUERY			(SQL_COPT_SS_BASE+15) // Used to start and stop query logging.
#define SQL_COPT_SS_PERF_DATA_LOG_NOW	(SQL_COPT_SS_BASE+16) // Used to make a statistics log entry to disk.
#define SQL_COPT_SS_QUOTED_IDENT		(SQL_COPT_SS_BASE+17) // Enable/Disable Quoted Identifiers
#define SQL_COPT_SS_ANSI_NPW			(SQL_COPT_SS_BASE+18) // Enable/Disable ANSI NULL, Padding and Warnings
#define SQL_COPT_SS_BCP					(SQL_COPT_SS_BASE+19) // Allow BCP usage on connection
#define SQL_COPT_SS_TRANSLATE			(SQL_COPT_SS_BASE+20) // Perform code page translation
#define SQL_COPT_SS_ATTACHDBFILENAME	(SQL_COPT_SS_BASE+21) // File name to be attached as a database
#define SQL_COPT_SS_CONCAT_NULL			(SQL_COPT_SS_BASE+22) // Enable/Disable CONCAT_NULL_YIELDS_NULL
#define SQL_COPT_SS_ENCRYPT             (SQL_COPT_SS_BASE+23) // Allow strong encryption for data

#define SQL_COPT_SS_MAX_USED			SQL_COPT_SS_ENCRYPT

//	Statement Options
#define SQL_SOPT_SS_BASE				1225
#define SQL_SOPT_SS_TEXTPTR_LOGGING		(SQL_SOPT_SS_BASE+0) // Text pointer logging
#define SQL_SOPT_SS_CURRENT_COMMAND		(SQL_SOPT_SS_BASE+1) // dbcurcmd SQLGetStmtOption only
#define SQL_SOPT_SS_HIDDEN_COLUMNS		(SQL_SOPT_SS_BASE+2) // Expose FOR BROWSE hidden columns
#define SQL_SOPT_SS_NOBROWSETABLE		(SQL_SOPT_SS_BASE+3) // Set NOBROWSETABLE option
#define SQL_SOPT_SS_REGIONALIZE			(SQL_SOPT_SS_BASE+4) // Regionalize output character conversions
#define SQL_SOPT_SS_CURSOR_OPTIONS		(SQL_SOPT_SS_BASE+5) // Server cursor options
#define SQL_SOPT_SS_NOCOUNT_STATUS      (SQL_SOPT_SS_BASE+6) // Real vs. Not Real row count indicator
#define SQL_SOPT_SS_DEFER_PREPARE		(SQL_SOPT_SS_BASE+7) // Defer prepare until necessary

#define SQL_SOPT_SS_MAX_USED			SQL_SOPT_SS_DEFER_PREPARE

#define SQL_COPT_SS_BASE_EX   1240
#define SQL_COPT_SS_BROWSE_CONNECT		(SQL_COPT_SS_BASE_EX+1) // Browse connect mode of operation
#define SQL_COPT_SS_BROWSE_SERVER		(SQL_COPT_SS_BASE_EX+2) // Single Server browse request.
#define SQL_COPT_SS_WARN_ON_CP_ERROR	(SQL_COPT_SS_BASE_EX+3) // Issues warning when data from the server 
																// had a loss during code page conversion.

#define SQL_COPT_SS_EX_MAX_USED			SQL_COPT_SS_WARN_ON_CP_ERROR

//	Defines for use with SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_UP_OFF		0L			//	Procedures won't be used for prepare
#define SQL_UP_ON		1L			//	Procedures will be used for prepare
#define SQL_UP_ON_DROP	2L			//	Temp procedures will be explicitly dropped
#define SQL_UP_DEFAULT	SQL_UP_ON

//	Defines for use with SQL_COPT_SS_INTEGRATED_SECURITY - Pre-Connect Option only
#define SQL_IS_OFF		0L			//	Integrated security isn't used
#define SQL_IS_ON		1L			//	Integrated security is used
#define SQL_IS_DEFAULT	SQL_IS_OFF

//	Defines for use with SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_PC_OFF		0L			//	Cursors are closed on SQLTransact
#define SQL_PC_ON		1L			//	Cursors remain open on SQLTransact
#define SQL_PC_DEFAULT	SQL_PC_OFF

//	Defines for use with SQL_COPT_SS_USER_DATA
#define SQL_UD_NOTSET	NULL			//	No user data pointer set

//	Defines for use with SQL_COPT_SS_TRANSLATE
#define SQL_XL_OFF		0L			//	Code page translation is not performed
#define SQL_XL_ON		1L			//	Code page translation is performed
#define SQL_XL_DEFAULT	SQL_XL_ON

//	Defines for use with SQL_COPT_SS_FALLBACK_CONNECT - Pre-Connect Option only
#define SQL_FB_OFF		0L			//	FallBack connections are disabled
#define SQL_FB_ON		1L			//	FallBack connections are enabled
#define SQL_FB_DEFAULT	SQL_FB_OFF

//	Defines for use with SQL_COPT_SS_BCP - Pre-Connect Option only
#define SQL_BCP_OFF		0L			//	BCP is not allowed on connection
#define SQL_BCP_ON		1L			//	BCP is allowed on connection
#define SQL_BCP_DEFAULT	SQL_BCP_OFF

//	Defines for use with SQL_COPT_SS_QUOTED_IDENT
#define SQL_QI_OFF		0L			//	Quoted identifiers are enable
#define SQL_QI_ON		1L			//	Quoted identifiers are disabled
#define SQL_QI_DEFAULT	SQL_QI_ON

//	Defines for use with SQL_COPT_SS_ANSI_NPW - Pre-Connect Option only
#define SQL_AD_OFF		0L			//	ANSI NULLs, Padding and Warnings are enabled
#define SQL_AD_ON		1L			//	ANSI NULLs, Padding and Warnings are disabled
#define SQL_AD_DEFAULT	SQL_AD_ON

//	Defines for use with SQL_COPT_SS_CONCAT_NULL - Pre-Connect Option only
#define SQL_CN_OFF	  0L		  //  CONCAT_NULL_YIELDS_NULL is off
#define SQL_CN_ON	  1L		  //  CONCAT_NULL_YIELDS_NULL is on
#define SQL_CN_DEFAULT	SQL_CN_ON


//	Defines for use with SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_TL_OFF		0L			//	No logging on text pointer ops
#define SQL_TL_ON		1L			//	Logging occurs on text pointer ops
#define SQL_TL_DEFAULT	SQL_TL_ON

//	Defines for use with SQL_SOPT_SS_HIDDEN_COLUMNS
#define SQL_HC_OFF		0L		  //  FOR BROWSE columns are hidden
#define SQL_HC_ON		1L		  //  FOR BROWSE columns are exposed
#define SQL_HC_DEFAULT	SQL_HC_OFF

//	Defines for use with SQL_SOPT_SS_NOBROWSETABLE
#define SQL_NB_OFF		0L			//	NO_BROWSETABLE is off
#define SQL_NB_ON		1L			//	NO_BROWSETABLE is on
#define SQL_NB_DEFAULT	SQL_NB_OFF

//	Defines for use with SQL_SOPT_SS_REGIONALIZE
#define SQL_RE_OFF		0L			//	No regionalization occurs on output character conversions
#define SQL_RE_ON		1L			//	Regionalization occurs on output character conversions
#define SQL_RE_DEFAULT	SQL_RE_OFF

//	Defines for use with SQL_SOPT_SS_CURSOR_OPTIONS
#define SQL_CO_OFF		0L			//	Clear all cursor options
#define SQL_CO_FFO		1L			//	Fast-forward cursor will be used
#define SQL_CO_AF		2L			//	Autofetch on cursor open
#define SQL_CO_FFO_AF	(SQL_CO_FFO|SQL_CO_AF)	//	Fast-forward cursor with autofetch
#define SQL_CO_FIREHOSE_AF 4L       //  Auto fetch on fire-hose cursors 
#define SQL_CO_DEFAULT	SQL_CO_OFF

//SQL_SOPT_SS_NOCOUNT_STATUS
#define SQL_NC_OFF      0L 
#define SQL_NC_ON       1L 

//SQL_SOPT_SS_DEFER_PREPARE
#define SQL_DP_OFF      0L 
#define SQL_DP_ON       1L 

//SQL_COPT_SS_ENCRYPT
#define SQL_EN_OFF      0L
#define SQL_EN_ON       1L

//SQL_COPT_SS_BROWSE_CONNECT
#define SQL_MORE_INFO_NO  0L
#define SQL_MORE_INFO_YES 1L

//SQL_COPT_SS_WARN_ON_CP_ERROR
#define SQL_WARN_NO   0L
#define SQL_WARN_YES  1L

//	Defines returned by SQL_ATTR_CURSOR_TYPE/SQL_CURSOR_TYPE
#define SQL_CURSOR_FAST_FORWARD_ONLY	8	//	Only returned by SQLGetStmtAttr/Option


//	SQLColAttributes driver specific defines.
//	SQLSet/GetDescField driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_CA_SS_BASE				1200
#define SQL_CA_SS_COLUMN_SSTYPE		(SQL_CA_SS_BASE+0)	//	dbcoltype/dbalttype
#define SQL_CA_SS_COLUMN_UTYPE		(SQL_CA_SS_BASE+1)	//	dbcolutype/dbaltutype
#define SQL_CA_SS_NUM_ORDERS		(SQL_CA_SS_BASE+2)	//	dbnumorders
#define SQL_CA_SS_COLUMN_ORDER		(SQL_CA_SS_BASE+3)	//	dbordercol
#define SQL_CA_SS_COLUMN_VARYLEN	(SQL_CA_SS_BASE+4)	//	dbvarylen
#define SQL_CA_SS_NUM_COMPUTES		(SQL_CA_SS_BASE+5)	//	dbnumcompute
#define SQL_CA_SS_COMPUTE_ID		(SQL_CA_SS_BASE+6)	//	dbnextrow status return
#define SQL_CA_SS_COMPUTE_BYLIST	(SQL_CA_SS_BASE+7)	//	dbbylist
#define SQL_CA_SS_COLUMN_ID			(SQL_CA_SS_BASE+8)	//	dbaltcolid
#define SQL_CA_SS_COLUMN_OP			(SQL_CA_SS_BASE+9)	//	dbaltop
#define SQL_CA_SS_COLUMN_SIZE		(SQL_CA_SS_BASE+10)	//	dbcollen
#define SQL_CA_SS_COLUMN_HIDDEN		(SQL_CA_SS_BASE+11) //	Column is hidden (FOR BROWSE)
#define SQL_CA_SS_COLUMN_KEY		(SQL_CA_SS_BASE+12) //	Column is key column (FOR BROWSE)
//#define SQL_DESC_BASE_COLUMN_NAME_OLD	(SQL_CA_SS_BASE+13) //This is defined at another location.
#define SQL_CA_SS_COLUMN_COLLATION	(SQL_CA_SS_BASE+14) //	Column collation (only for chars)
#define SQL_CA_SS_VARIANT_TYPE      (SQL_CA_SS_BASE+15)
#define SQL_CA_SS_VARIANT_SQL_TYPE  (SQL_CA_SS_BASE+16)
#define SQL_CA_SS_VARIANT_SERVER_TYPE (SQL_CA_SS_BASE+17)
#define SQL_CA_SS_MAX_USED			(SQL_CA_SS_BASE+18)




//	SQL Server Data Type Tokens.
//	New types for 6.0 and later servers
/* SQL Server Data Type Tokens. */
#define SQLTEXT 			0x23
#define SQLVARBINARY		0x25
#define SQLINTN 			0x26
#define SQLVARCHAR			0x27
#define SQLBINARY			0x2d
#define SQLIMAGE			0x22
#define SQLCHARACTER		0x2f
#define SQLINT1 			0x30
#define SQLBIT				0x32
#define SQLINT2 			0x34
#define SQLINT4 			0x38
#define SQLMONEY			0x3c
#define SQLDATETIME 		0x3d
#define SQLFLT8 			0x3e
#define SQLFLTN 			0x6d
#define SQLMONEYN			0x6e
#define SQLDATETIMN 		0x6f
#define SQLFLT4 			0x3b
#define SQLMONEY4			0x7a
#define SQLDATETIM4 		0x3a
//	New types for 6.0 and later servers
#define SQLDECIMAL			0x6a
#define SQLNUMERIC			0x6c
//	New types for 7.0 and later servers
#define SQLUNIQUEID			0x24
#define SQLBIGCHAR			0xaf
#define SQLBIGVARCHAR		0xa7
#define SQLBIGBINARY		0xad
#define SQLBIGVARBINARY		0xa5
#define SQLBITN				0x68
#define SQLNCHAR			0xef
#define SQLNVARCHAR 		0xe7
#define SQLNTEXT			0x63
// New for 7.x
#define SQLINT8	            0x7f
#define SQLVARIANT          0x62

//	User Data Type definitions.
//	Returned by SQLColAttributes/SQL_CA_SS_COLUMN_UTYPE.
#define SQLudtBINARY			3
#define SQLudtBIT				16
#define SQLudtBITN				0
#define SQLudtCHAR				1
#define SQLudtDATETIM4			22
#define SQLudtDATETIME			12
#define SQLudtDATETIMN			15
#define SQLudtDECML 			24
#define SQLudtDECMLN			26
#define SQLudtFLT4				23
#define SQLudtFLT8				8
#define SQLudtFLTN				14
#define SQLudtIMAGE 			20
#define SQLudtINT1				5
#define SQLudtINT2				6
#define SQLudtINT4				7
#define SQLudtINTN				13
#define SQLudtMONEY 			11
#define SQLudtMONEY4			21
#define SQLudtMONEYN			17
#define SQLudtNUM				10
#define SQLudtNUMN				25
#define SQLudtSYSNAME			18
#define SQLudtTEXT				19
#define SQLudtTIMESTAMP 		80
#define SQLudtUNIQUEIDENTIFIER	0
#define SQLudtVARBINARY 		4
#define SQLudtVARCHAR			2
#define MIN_USER_DATATYPE		256

//	Aggregate operator types.
//	Returned by SQLColAttributes/SQL_CA_SS_COLUMN_OP.
#define SQLAOPSTDEV 	0x30	// Standard deviation
#define SQLAOPSTDEVP	0x31	// Standard deviation population
#define SQLAOPVAR		0x32	// Variance
#define SQLAOPVARP		0x33	// Variance population
#define SQLAOPCNT		0x4b	// Count
#define SQLAOPSUM		0x4d	// Sum
#define SQLAOPAVG		0x4f	// Average
#define SQLAOPMIN		0x51	// Min
#define SQLAOPMAX		0x52	// Max
#define SQLAOPANY		0x53	// Any
#define SQLAOPNOOP		0x56	// None


//	SQLGetInfo driver specific defines.
//	Microsoft has 1151 thru 1200 reserved for Microsoft SQL Server driver usage.

#define SQL_INFO_SS_FIRST		1199
#define SQL_INFO_SS_NETLIB_NAMEW (SQL_INFO_SS_FIRST+0) //  dbprocinfo
#define SQL_INFO_SS_NETLIB_NAMEA (SQL_INFO_SS_FIRST+1) //  dbprocinfo
#define SQL_INFO_SS_MAX_USED	SQL_INFO_SS_NETLIB_NAMEA
#ifdef UNICODE
#define SQL_INFO_SS_NETLIB_NAME		SQL_INFO_SS_NETLIB_NAMEW
#else
#define SQL_INFO_SS_NETLIB_NAME		SQL_INFO_SS_NETLIB_NAMEA
#endif


//	Driver specific SQL type defines.
//	Microsoft has -150 thru -199 reserved for Microsoft SQL Server driver usage.
#define SQL_SS_VARIANT    -150


//	SQLGetDiagField driver specific defines.
//	Microsoft has -1150 thru -1199 reserved for Microsoft SQL Server driver usage.

#define SQL_DIAG_SS_BASE		(-1150)
#define SQL_DIAG_SS_MSGSTATE	(SQL_DIAG_SS_BASE)
#define SQL_DIAG_SS_SEVERITY	(SQL_DIAG_SS_BASE-1)
#define SQL_DIAG_SS_SRVNAME 	(SQL_DIAG_SS_BASE-2)
#define SQL_DIAG_SS_PROCNAME	(SQL_DIAG_SS_BASE-3)
#define SQL_DIAG_SS_LINE		(SQL_DIAG_SS_BASE-4)


//	SQLGetDiagField/SQL_DIAG_DYNAMIC_FUNCTION_CODE driver specific defines.
//	Microsoft has -200 thru -299 reserved for Microsoft SQL Server driver usage.

#define SQL_DIAG_DFC_SS_BASE					(-200)
#define SQL_DIAG_DFC_SS_ALTER_DATABASE			(SQL_DIAG_DFC_SS_BASE-0)
#define SQL_DIAG_DFC_SS_CHECKPOINT				(SQL_DIAG_DFC_SS_BASE-1)
#define SQL_DIAG_DFC_SS_CONDITION				(SQL_DIAG_DFC_SS_BASE-2)
#define SQL_DIAG_DFC_SS_CREATE_DATABASE 		(SQL_DIAG_DFC_SS_BASE-3)
#define SQL_DIAG_DFC_SS_CREATE_DEFAULT			(SQL_DIAG_DFC_SS_BASE-4)
#define SQL_DIAG_DFC_SS_CREATE_PROCEDURE		(SQL_DIAG_DFC_SS_BASE-5)
#define SQL_DIAG_DFC_SS_CREATE_RULE 			(SQL_DIAG_DFC_SS_BASE-6)
#define SQL_DIAG_DFC_SS_CREATE_TRIGGER			(SQL_DIAG_DFC_SS_BASE-7)
#define SQL_DIAG_DFC_SS_CURSOR_DECLARE			(SQL_DIAG_DFC_SS_BASE-8)
#define SQL_DIAG_DFC_SS_CURSOR_OPEN 			(SQL_DIAG_DFC_SS_BASE-9)
#define SQL_DIAG_DFC_SS_CURSOR_FETCH			(SQL_DIAG_DFC_SS_BASE-10)
#define SQL_DIAG_DFC_SS_CURSOR_CLOSE			(SQL_DIAG_DFC_SS_BASE-11)
#define SQL_DIAG_DFC_SS_DEALLOCATE_CURSOR		(SQL_DIAG_DFC_SS_BASE-12)
#define SQL_DIAG_DFC_SS_DBCC					(SQL_DIAG_DFC_SS_BASE-13)
#define SQL_DIAG_DFC_SS_DISK					(SQL_DIAG_DFC_SS_BASE-14)
#define SQL_DIAG_DFC_SS_DROP_DATABASE			(SQL_DIAG_DFC_SS_BASE-15)
#define SQL_DIAG_DFC_SS_DROP_DEFAULT			(SQL_DIAG_DFC_SS_BASE-16)
#define SQL_DIAG_DFC_SS_DROP_PROCEDURE			(SQL_DIAG_DFC_SS_BASE-17)
#define SQL_DIAG_DFC_SS_DROP_RULE				(SQL_DIAG_DFC_SS_BASE-18)
#define SQL_DIAG_DFC_SS_DROP_TRIGGER			(SQL_DIAG_DFC_SS_BASE-19)
#define SQL_DIAG_DFC_SS_DUMP_DATABASE			(SQL_DIAG_DFC_SS_BASE-20)
#define SQL_DIAG_DFC_SS_DUMP_TABLE				(SQL_DIAG_DFC_SS_BASE-21)
#define SQL_DIAG_DFC_SS_DUMP_TRANSACTION		(SQL_DIAG_DFC_SS_BASE-22)
#define SQL_DIAG_DFC_SS_GOTO					(SQL_DIAG_DFC_SS_BASE-23)
#define SQL_DIAG_DFC_SS_INSERT_BULK 			(SQL_DIAG_DFC_SS_BASE-24)
#define SQL_DIAG_DFC_SS_KILL					(SQL_DIAG_DFC_SS_BASE-25)
#define SQL_DIAG_DFC_SS_LOAD_DATABASE			(SQL_DIAG_DFC_SS_BASE-26)
#define SQL_DIAG_DFC_SS_LOAD_HEADERONLY 		(SQL_DIAG_DFC_SS_BASE-27)
#define SQL_DIAG_DFC_SS_LOAD_TABLE				(SQL_DIAG_DFC_SS_BASE-28)
#define SQL_DIAG_DFC_SS_LOAD_TRANSACTION		(SQL_DIAG_DFC_SS_BASE-29)
#define SQL_DIAG_DFC_SS_PRINT					(SQL_DIAG_DFC_SS_BASE-30)
#define SQL_DIAG_DFC_SS_RAISERROR				(SQL_DIAG_DFC_SS_BASE-31)
#define SQL_DIAG_DFC_SS_READTEXT				(SQL_DIAG_DFC_SS_BASE-32)
#define SQL_DIAG_DFC_SS_RECONFIGURE 			(SQL_DIAG_DFC_SS_BASE-33)
#define SQL_DIAG_DFC_SS_RETURN					(SQL_DIAG_DFC_SS_BASE-34)
#define SQL_DIAG_DFC_SS_SELECT_INTO 			(SQL_DIAG_DFC_SS_BASE-35)
#define SQL_DIAG_DFC_SS_SET 					(SQL_DIAG_DFC_SS_BASE-36)
#define SQL_DIAG_DFC_SS_SET_IDENTITY_INSERT 	(SQL_DIAG_DFC_SS_BASE-37)
#define SQL_DIAG_DFC_SS_SET_ROW_COUNT			(SQL_DIAG_DFC_SS_BASE-38)
#define SQL_DIAG_DFC_SS_SET_STATISTICS			(SQL_DIAG_DFC_SS_BASE-39)
#define SQL_DIAG_DFC_SS_SET_TEXTSIZE			(SQL_DIAG_DFC_SS_BASE-40)
#define SQL_DIAG_DFC_SS_SETUSER 				(SQL_DIAG_DFC_SS_BASE-41)
#define SQL_DIAG_DFC_SS_SHUTDOWN				(SQL_DIAG_DFC_SS_BASE-42)
#define SQL_DIAG_DFC_SS_TRANS_BEGIN 			(SQL_DIAG_DFC_SS_BASE-43)
#define SQL_DIAG_DFC_SS_TRANS_COMMIT			(SQL_DIAG_DFC_SS_BASE-44)
#define SQL_DIAG_DFC_SS_TRANS_PREPARE			(SQL_DIAG_DFC_SS_BASE-45)
#define SQL_DIAG_DFC_SS_TRANS_ROLLBACK			(SQL_DIAG_DFC_SS_BASE-46)
#define SQL_DIAG_DFC_SS_TRANS_SAVE				(SQL_DIAG_DFC_SS_BASE-47)
#define SQL_DIAG_DFC_SS_TRUNCATE_TABLE			(SQL_DIAG_DFC_SS_BASE-48)
#define SQL_DIAG_DFC_SS_UPDATE_STATISTICS		(SQL_DIAG_DFC_SS_BASE-49)
#define SQL_DIAG_DFC_SS_UPDATETEXT				(SQL_DIAG_DFC_SS_BASE-50)
#define SQL_DIAG_DFC_SS_USE 					(SQL_DIAG_DFC_SS_BASE-51)
#define SQL_DIAG_DFC_SS_WAITFOR 				(SQL_DIAG_DFC_SS_BASE-52)
#define SQL_DIAG_DFC_SS_WRITETEXT				(SQL_DIAG_DFC_SS_BASE-53)
#define SQL_DIAG_DFC_SS_DENY					(SQL_DIAG_DFC_SS_BASE-54)
#define SQL_DIAG_DFC_SS_SET_XCTLVL				(SQL_DIAG_DFC_SS_BASE-55)

//	Severity codes for SQL_DIAG_SS_SEVERITY
#define	EX_ANY			0
#define	EX_INFO			10
#define EX_MAXISEVERITY EX_INFO
#define	EX_MISSING		11
#define	EX_TYPE			12
#define	EX_DEADLOCK		13
#define	EX_PERMIT		14
#define	EX_SYNTAX		15
#define	EX_USER			16
#define	EX_RESOURCE		17
#define	EX_INTOK		18
#define	MAXUSEVERITY	EX_INTOK
#define	EX_LIMIT		19
#define	EX_CMDFATAL		20
#define	MINFATALERR		EX_CMDFATAL
#define	EX_DBFATAL		21
#define	EX_TABCORRUPT	22
#define	EX_DBCORRUPT	23
#define	EX_HARDWARE		24
#define	EX_CONTROL		25

//	Internal server datatypes - used when binding to SQL_C_BINARY
#ifndef MAXNUMERICLEN	// Resolve ODS/DBLib conflicts
// DB-Library datatypes
#define DBMAXCHAR		(8000+1)	// Max length of DBVARBINARY and DBVARCHAR, etc. +1 for zero byte
#define MAXNAME 		(SQL_MAX_SQLSERVERNAME+1)	// Max server identifier length including zero byte

#ifdef UNICODE
typedef wchar_t			DBCHAR;
#else
typedef char            DBCHAR;
#endif
typedef unsigned char   DBBINARY;
typedef unsigned char   DBTINYINT;
typedef short           DBSMALLINT;
typedef unsigned short  DBUSMALLINT;
typedef double          DBFLT8;
typedef unsigned char   DBBIT;
typedef unsigned char   DBBOOL;
typedef float           DBFLT4;

typedef DBFLT4 DBREAL;
typedef UINT   DBUBOOL;

typedef struct dbvarychar
{
	DBSMALLINT  len;
	DBCHAR      str[DBMAXCHAR];
} DBVARYCHAR;

typedef struct dbvarybin
{
	DBSMALLINT  len;
	BYTE        array[DBMAXCHAR];
} DBVARYBIN;

typedef struct dbmoney
{						// Internal representation of MONEY data type
	LONG  mnyhigh;		// Money value *10,000 (High 32 bits/signed)
	ULONG mnylow;		// Money value *10,000 (Low 32 bits/unsigned)
} DBMONEY;

typedef struct dbdatetime
{						// Internal representation of DATETIME data type
	LONG  dtdays;		// No of days since Jan-1-1900 (maybe negative)
	ULONG dttime;		// No. of 300 hundredths of a second since midnight
} DBDATETIME;

typedef struct dbdatetime4
{						// Internal representation of SMALLDATETIME data type
	USHORT numdays; 	// No of days since Jan-1-1900
	USHORT nummins; 	// No. of minutes since midnight
} DBDATETIM4;

typedef LONG DBMONEY4;	// Internal representation of SMALLMONEY data type
						// Money value *10,000

#define DBNUM_PREC_TYPE BYTE
#define DBNUM_SCALE_TYPE BYTE
#define DBNUM_VAL_TYPE BYTE

#if (ODBCVER < 0x0300)
#define MAXNUMERICLEN 16

typedef struct dbnumeric
{							// Internal representation of NUMERIC data type
	DBNUM_PREC_TYPE   precision;			// Precision
	DBNUM_SCALE_TYPE  scale;				// Scale
	BYTE			  sign; 				// Sign (1 if positive, 0 if negative)
	DBNUM_VAL_TYPE	  val[MAXNUMERICLEN];	// Value
} DBNUMERIC;
typedef DBNUMERIC DBDECIMAL;// Internal representation of DECIMAL data type
#else	//	Use ODBC 3.0 definitions since same as DBLib
#define MAXNUMERICLEN SQL_MAX_NUMERIC_LEN
typedef SQL_NUMERIC_STRUCT DBNUMERIC;
typedef SQL_NUMERIC_STRUCT DBDECIMAL;
#endif

#endif //	MAXNUMERICLEN

#ifndef INT
typedef int INT;
typedef long            DBINT;
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const LPBYTE	LPCBYTE;
#endif
typedef DBINT *			LPDBINT;
#endif

/*****************************************************************
 This struct is a global used for 
 gathering statistical data on the driver.
 Access to this structure is controlled via the
 pStatCrit;
******************************************************************/

typedef struct sqlperf
{
	// Application Profile Statistics
	DWORD TimerResolution;
	DWORD SQLidu;
	DWORD SQLiduRows;
	DWORD SQLSelects;
	DWORD SQLSelectRows;
	DWORD Transactions;
	DWORD SQLPrepares;
	DWORD ExecDirects;
	DWORD SQLExecutes;
	DWORD CursorOpens;
	DWORD CursorSize;
	DWORD CursorUsed;
	LDOUBLE PercentCursorUsed;
	LDOUBLE AvgFetchTime;
	LDOUBLE AvgCursorSize; 
	LDOUBLE AvgCursorUsed;
	DWORD SQLFetchTime;
	DWORD SQLFetchCount;
	DWORD CurrentStmtCount;
	DWORD MaxOpenStmt;
	DWORD SumOpenStmt;
	
	// Connection Statistics
	DWORD CurrentConnectionCount;
	DWORD MaxConnectionsOpened;
	DWORD SumConnectionsOpened;
	DWORD SumConnectiontime;
	LDOUBLE AvgTimeOpened;

	// Network Statistics
	DWORD ServerRndTrips;
	DWORD BuffersSent;
	DWORD BuffersRec;
	DWORD BytesSent;
	DWORD BytesRec;

	// Time Statistics;
	DWORD msExecutionTime;
	DWORD msNetWorkServerTime;

} 	SQLPERF;

// The following are options for SQL_COPT_SS_PERF_DATA and SQL_COPT_SS_PERF_QUERY
#define SQL_PERF_START	1			// Starts the driver sampling performance data.
#define SQL_PERF_STOP	2			// Stops the counters from sampling performance data.

// The following are defines for SQL_COPT_SS_PERF_DATA_LOG
#define SQL_SS_DL_DEFAULT	TEXT("C:\\STATS.LOG")

// The following are defines for SQL_COPT_SS_PERF_QUERY_LOG
#define SQL_SS_QL_DEFAULT	TEXT("C:\\QUERY.LOG")

// The following are defines for SQL_COPT_SS_PERF_QUERY_INTERVAL
#define SQL_SS_QI_DEFAULT	30000	//	30,000 milliseconds

//	ODBC BCP prototypes and defines

//	Return codes
#define SUCCEED 		1
#define FAIL			0
#define SUCCEED_ABORT	2
#define SUCCEED_ASYNC	3

//	Transfer directions
#define DB_IN			1	// Transfer from client to server
#define DB_OUT			2	// Transfer from server to client

//	bcp_control option
#define BCPMAXERRS		1	// Sets max errors allowed
#define BCPFIRST		2	// Sets first row to be copied out
#define BCPLAST 		3	// Sets number of rows to be copied out
#define BCPBATCH		4	// Sets input batch size
#define BCPKEEPNULLS	5	// Sets to insert NULLs for empty input values
#define BCPABORT		6	// Sets to have bcpexec return SUCCEED_ABORT
#define BCPODBC 		7	// Sets ODBC canonical character output
#define BCPKEEPIDENTITY	8	// Sets IDENTITY_INSERT on
#define BCP6xFILEFMT	9	// DEPRECATED: Sets 6x file format on
#define BCPHINTSA		10	// Sets server BCP hints (ANSI string)
#define BCPHINTSW		11	// Sets server BCP hints (UNICODE string)
#define BCPFILECP		12	// Sets clients code page for the file
#define BCPUNICODEFILE	13	// Sets that the file contains unicode header
#define BCPTEXTFILE		14	// Sets BCP mode to expect a text file and to detect Unicode or ANSI automatically
#define BCPFILEFMT		15	// Sets file format version

//	BCPFILECP values
//	Any valid code page that is installed on the client can be passed plus:
#define BCPFILECP_ACP	0	// Data in file is in Windows code page
#define BCPFILECP_OEMCP	1	// Data in file is in OEM code page (default)
#define BCPFILECP_RAW	(-1)// Data in file is in Server code page (no conversion)

//	bcp_collen definition
#define SQL_VARLEN_DATA (-10)	//	Use default length for column

// BCP functions
DBINT	SQL_API bcp_batch (HDBC);
RETCODE SQL_API bcp_bind (HDBC, LPCBYTE, INT, DBINT, LPCBYTE, INT, INT, INT);
RETCODE SQL_API bcp_colfmt (HDBC, INT, BYTE, INT, DBINT, LPCBYTE, INT, INT);
RETCODE SQL_API bcp_collen (HDBC, DBINT, INT);
RETCODE SQL_API bcp_colptr (HDBC, LPCBYTE, INT);
RETCODE SQL_API bcp_columns (HDBC, INT);
RETCODE SQL_API bcp_control (HDBC, INT, void *);
DBINT	SQL_API bcp_done (HDBC);
RETCODE SQL_API bcp_exec (HDBC, LPDBINT);
RETCODE SQL_API bcp_getcolfmt (HDBC, INT, INT, void *, INT, INT *);
RETCODE SQL_API bcp_initA (HDBC, LPCSTR, LPCSTR, LPCSTR, INT);
RETCODE SQL_API bcp_initW (HDBC, LPCWSTR, LPCWSTR, LPCWSTR, INT);
RETCODE SQL_API bcp_moretext (HDBC, DBINT, LPCBYTE);
RETCODE SQL_API bcp_readfmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_readfmtW (HDBC, LPCWSTR);
RETCODE SQL_API bcp_sendrow (HDBC);
RETCODE SQL_API bcp_setcolfmt (HDBC, INT, INT, void *, INT);
RETCODE SQL_API bcp_writefmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_writefmtW (HDBC, LPCWSTR);
CHAR *	SQL_API dbprtypeA (INT);
WCHAR * SQL_API dbprtypeW (INT);

#ifdef UNICODE
#define bcp_init		bcp_initW
#define bcp_readfmt		bcp_readfmtW
#define bcp_writefmt	bcp_writefmtW
#define dbprtype		dbprtypeW
#define BCPHINTS		BCPHINTSW

#else
#define bcp_init		bcp_initA
#define bcp_readfmt		bcp_readfmtA
#define bcp_writefmt	bcp_writefmtA
#define dbprtype		dbprtypeA
#define BCPHINTS		BCPHINTSA
#endif

//	SQL Server catalog extensions for distributed queries
SQLRETURN SQL_API SQLLinkedServers (SQLHSTMT);
SQLRETURN SQL_API SQLLinkedCatalogsA (SQLHSTMT, LPCSTR, SWORD);
SQLRETURN SQL_API SQLLinkedCatalogsW (SQLHSTMT, LPCWSTR, SWORD);

//	SQL Server extensions for server enumeration
HANDLE   SQL_API SQLInitEnumServers (WCHAR * pwchServerName,WCHAR *pwchInstanceName);
RETCODE  SQL_API SQLGetNextEnumeration (HANDLE hEnumHandle,BYTE * prgEnumData,INT * piEnumLength);
RETCODE  SQL_API SQLCloseEnumServers (HANDLE hEnumHandle);

#ifdef UNICODE
#define SQLLinkedCatalogs	SQLLinkedCatalogsW
#else
#define SQLLinkedCatalogs	SQLLinkedCatalogsA
#endif

//  BCP column format properties
#define BCP_FMT_TYPE			0x01
#define BCP_FMT_INDICATOR_LEN	0x02
#define BCP_FMT_DATA_LEN		0x03
#define	BCP_FMT_TERMINATOR		0x04
#define BCP_FMT_SERVER_COL		0x05
#define BCP_FMT_COLLATION		0x06
#define BCP_FMT_COLLATION_ID	0x07

//	The following options have been deprecated

#define SQL_FAST_CONNECT				(SQL_COPT_SS_BASE+0)
//	Defines for use with SQL_FAST_CONNECT - only useable before connecting
#define SQL_FC_OFF		0L			//	Fast connect is off
#define SQL_FC_ON		1L			//	Fast connect is on
#define SQL_FC_DEFAULT	SQL_FC_OFF
#define SQL_COPT_SS_ANSI_OEM			(SQL_COPT_SS_BASE+6)
#define SQL_AO_OFF						0L
#define SQL_AO_ON						1L
#define SQL_AO_DEFAULT					SQL_AO_OFF

//	Define old names
#define SQL_REMOTE_PWD					SQL_COPT_SS_REMOTE_PWD
#define SQL_USE_PROCEDURE_FOR_PREPARE	SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_INTEGRATED_SECURITY 		SQL_COPT_SS_INTEGRATED_SECURITY
#define SQL_PRESERVE_CURSORS			SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_TEXTPTR_LOGGING 			SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_CA_SS_BASE_COLUMN_NAME		SQL_DESC_BASE_COLUMN_NAME
#define SQLDECIMALN						0x6a
#define SQLNUMERICN 					0x6c

#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */
#endif

//	End of odbcss.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\vdifreeze.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: vdifreeze.cpp
//
// PURPOSE:
//
//		Use a coordinated VDI BACKUP WITH SNAPSHOT (SQL2000 and above)
//
// NOTES:
//		The VDI method of freeze/thaw avoids the potential resource deadlock
//	which prevents SQLServer from accepting a "dbcc thaw_io" when one or more
//  databases is frozen.
//
// Extern dependencies:
//   provision of "_Module" and the COM guids....
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     68202      11/07/00 ntsnap work
//
//
// @EndHeader@
// ***************************************************************************


#if HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>

#include "vdierror.h"
#include "vdiguid.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLVFRZC"
//
////////////////////////////////////////////////////////////////////////

Freeze2000::Freeze2000 (
	const WString&	serverName,
	ULONG			maxDatabases) :
		m_ServerName (serverName),
		m_MaxDatabases (maxDatabases),
		m_NumDatabases (0),
		m_State (Unprepared),
		m_AbortCount (0)
{
	CVssFunctionTracer(VSSDBG_SQLLIB, L"Freeze2000::Freeze2000");

	m_pDBContext = new FrozenDatabase [maxDatabases];
	CoCreateGuid (&m_BackupId);
	try
		{
		InitializeCriticalSection (&m_Latch);
		}
	catch(...)
		{
		// delete created object if we fail InitializeCriticalSection
		delete m_pDBContext;
		}
}


//----------------------------------------------------------
// Wait for all the database threads to terminate.
// This is only called by the coordinating thread while
// holding exclusive access on the object.
//
void
Freeze2000::WaitForThreads ()
{
	CVssFunctionTracer(VSSDBG_SQLLIB, L"Freeze2000::WaitForThreads");

	for (int i=0; i<m_NumDatabases; i++)
	{
		FrozenDatabase* pDb = m_pDBContext+i;
		if (pDb->m_hThread != NULL)
		{
			DWORD	status;
			do
			{
				status = WaitForSingleObjectEx (pDb->m_hThread, 2000, TRUE);

				if (m_State != Aborted && CheckAbort ())
					Abort ();

			} while (status != WAIT_OBJECT_0);

			CloseHandle (pDb->m_hThread);
			pDb->m_hThread = NULL;
		}
	}
}

//---------------------------------------------------------
// Handle an abort.
// The main thread will already hold the the lock and so
// will always be successful at aborting the operation.
// The database threads will attempt to abort, but won't
// block in order to do so.  The abort count is incremented
// and the main thread is ulimately responsible for cleanup.
//
void
Freeze2000::Abort () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Abort");

	SetAbort ();	
	if (TryLock ())
	{
		m_State = Aborted;
		for (int i=0; i<m_NumDatabases; i++)
		{
			if (m_pDBContext[i].m_pIVDSet)
			{
				m_pDBContext[i].m_pIVDSet->SignalAbort ();
				m_pDBContext[i].m_pIVDSet->Close ();
				m_pDBContext[i].m_pIVDSet->Release ();
				m_pDBContext[i].m_pIVDSet = NULL;
				m_pDBContext[i].m_pIVD = NULL;
			}
		}
		Unlock ();
	}
}

Freeze2000::~Freeze2000 ()
{
	Lock ();

	if (m_State != Complete)
	{
		// Trigger any waiting threads, cleaning up any VDI's.
		//
		Abort ();

		WaitForThreads ();
	}

	delete[] m_pDBContext;
	DeleteCriticalSection (&m_Latch);
}

//-------------------------------------------
// Map the voids and proc call stuff to the real
// thread routine.
//
DWORD WINAPI FreezeThreadProc(
  LPVOID lpParameter )  // thread data
{
	return Freeze2000::DatabaseThreadStart (lpParameter);
}

DWORD Freeze2000::DatabaseThreadStart (
  LPVOID lpParameter )  // thread data
{
	FrozenDatabase*	pDbContext = (FrozenDatabase*)lpParameter;
	return pDbContext->m_pContext->DatabaseThread (pDbContext);
}

//-------------------------------------------
// Add a database to the freeze set.
//
void
Freeze2000::PrepareDatabase (
	const WString&		dbName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Free2000::PrepareDatabase");

	// can't backup tempdb!
	//
	if (dbName == L"tempdb")
		return;

	Lock ();

	try
	{
		if (m_State == Unprepared)
		{
			m_State = Preparing;
		}

		if (m_NumDatabases >= m_MaxDatabases ||
			m_State != Preparing)
		{
			DBG_ASSERT(FALSE && L"Too many databases or not preparing");
			THROW_GENERIC;
		}

		FrozenDatabase*	pDbContext = m_pDBContext+m_NumDatabases;
		m_NumDatabases++;

		pDbContext->m_pContext = this;

		ft.hr = CoCreateInstance (
			CLSID_MSSQL_ClientVirtualDeviceSet,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IClientVirtualDeviceSet2,
			(void**)&pDbContext->m_pIVDSet);

		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}

		VDConfig	config;
		memset (&config, 0, sizeof(config));
		config.deviceCount = 1;

		StringFromGUID2 (m_BackupId, pDbContext->m_SetName, sizeof (pDbContext->m_SetName));
		swprintf (pDbContext->m_SetName+wcslen(pDbContext->m_SetName), L"%d", m_NumDatabases);

		// A "\" indicates a named instance, so append the name...
		//
		WCHAR* pInstance = wcschr (m_ServerName.c_str (), L'\\');

		if (pInstance)
		{
			pInstance++;  // step over the separator
		}

		// Create the virtual device set
		//
		ft.hr = pDbContext->m_pIVDSet->CreateEx (pInstance, pDbContext->m_SetName, &config);
		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}
		pDbContext->m_VDState = Created;
		pDbContext->m_DbName = dbName;

		pDbContext->m_hThread = CreateThread (NULL, 0,
			FreezeThreadProc, pDbContext, 0, NULL);

		if (pDbContext->m_hThread == NULL)
		{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_SQLLIB, L"CreateThread");
		}
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}

//---------------------------------------------------------
// Prep a database by setting up a BACKUP WITH SNAPSHOT
// We perform a checkpoint first to minimize the backup checkpoint duration.
// Since the backup has no way to stall for the prepare, we stall it by delaying
// the VDI processing until freeze time.
//
DWORD
Freeze2000::DatabaseThread (
	FrozenDatabase*		pDbContext)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"Freeze2000::DatabaseThread");

	try
	{
		SqlConnection	sql;
		sql.Connect (m_ServerName);
		WString command =
			L"BACKUP DATABASE [" + pDbContext->m_DbName + L"] TO VIRTUAL_DEVICE='" +
			pDbContext->m_SetName + L"' WITH SNAPSHOT,BUFFERCOUNT=1,BLOCKSIZE=1024";

		sql.SetCommand (command);
		sql.ExecCommand ();
		pDbContext->m_SuccessDetected = TRUE;
	}
	catch (...)
	{
		Abort ();
	}

	return 0;
}

//---------------------------------------------------------
// Advance the status of each VD.
// Will throw if problems are encountered.
//
// This routine is called in two contexts:
//  1. During the "Prepare" phase, in which case 'toSnapshot' is FALSE
//     and the goal is to move each VD to an "open" state.
//     At that time, the backup metadata is not yet consumed, to the BACKUP will
//     be waiting (leaving the database unfrozen).
//  2. During the "Freeze" phase, the metadata is consumed (and discarded),
//	   so the BACKUP will freeze the database and send the 'VDC_Snapshot' command.
//
void
Freeze2000::AdvanceVDState (
	bool toSnapshot)	// TRUE when we want to advance to the snapshot open stage.
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::AdvanceVDState");

	// Poll over the VD's moving them to Open or SnapshotOpen
	//
	while (1)
	{
		bool	didSomething = false;
		int nDatabasesReady = 0;

		for (int i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			if (CheckAbort ())
			{
				THROW_GENERIC;
			}

			switch (pDb->m_VDState)
			{
				case Created:
					VDConfig	config;
					ft.hr = pDb->m_pIVDSet->GetConfiguration (0, &config);
					if (ft.hr == VD_E_TIMEOUT)
						break;
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDeviceSet2::GetConfiguration");

					ft.hr = pDb->m_pIVDSet->OpenDevice (pDb->m_SetName, &pDb->m_pIVD);
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDeviceSet2::OpenDevice");

					pDb->m_VDState = Open;
					didSomething = true;
					
					// fall thru

				case Open:
					if (!toSnapshot)
					{
						nDatabasesReady++;
						break;
					}

					// pull commands until we see the snapshot
					//
					VDC_Command *   cmd;
					HRESULT hr;

					while (pDb->m_VDState == Open &&
						SUCCEEDED (hr=pDb->m_pIVD->GetCommand (0, &cmd)))
					{
						DWORD           completionCode;
						DWORD           bytesTransferred;
						didSomething = true;

						switch (cmd->commandCode)
						{
							case VDC_Write:
								bytesTransferred = cmd->size;
							case VDC_Flush:
								completionCode = ERROR_SUCCESS;

								ft.hr = pDb->m_pIVD->CompleteCommand (
									cmd, completionCode, bytesTransferred, 0);
								if (ft.HrFailed())
									ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompleteCommand");

								break;

							case VDC_Snapshot:
								pDb->m_VDState = SnapshotOpen;
								pDb->m_pSnapshotCmd = cmd;
								break;

							default:
								ft.Trace(VSSDBG_SQLLIB, L"Unexpected VDCmd: x%x\n", cmd->commandCode);
								THROW_GENERIC;
						} // end command switch
					} // end command loop

					ft.hr = hr;

					if (ft.hr == VD_E_TIMEOUT)
						break;	// no command was ready.
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::GetCommand");

					DBG_ASSERT(pDb->m_VDState == SnapshotOpen);
					break;

				case SnapshotOpen:
					nDatabasesReady++;
					break;

				default:
					DBG_ASSERT(FALSE && L"Shouldn't get here");
					THROW_GENERIC;
			} // end switch to handle this db
		} // end loop over each db
	
		if (nDatabasesReady == m_NumDatabases)
			break;

		// Unless we found something to do,
		// delay a bit and try again.
		//

		if (didSomething)
			continue;
		SleepEx (100, TRUE);

	} // wait for all databases to go "Ready"
}

//---------------------------------------------------------
// Wait for the databases to finish preparing.
// This waits for the virtual devices to open up
//
void
Freeze2000::WaitForPrepare ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::WaitForPrepare");

	Lock ();
	if (m_State != Preparing || CheckAbort ())
	{
		Abort ();
		Unlock ();
		THROW_GENERIC;
	}
	m_State = Prepared;
	try
	{
		AdvanceVDState (FALSE);
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}


//------------------------------------------------------------------
// Perform the freeze, waiting for a "Take-snapshot" from each db.
//
void
Freeze2000::Freeze ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Freeze");

	Lock ();
	if (m_State != Prepared || CheckAbort ())
	{
		Abort ();
		Unlock ();
		THROW_GENERIC;
	}

	try
	{
		m_State = Frozen;
		AdvanceVDState (TRUE);
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}


//---------------------------------------------------------
// Perform the thaw.
//
// Return TRUE if the databases were all successfully backed up
// and were thawed out as expected.
// FALSE is returned in any other case.
// No exceptions are thrown (this routine can be used as a cleanup routine).
//
BOOL
Freeze2000::Thaw () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Thaw");

	Lock ();

	if (m_State != Frozen || CheckAbort ())
	{
		Abort ();
		Unlock ();
		return FALSE;
	}

	try
	{

		// Send the "snapshot complete" messages.
		//
			int i;

		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			DBG_ASSERT (pDb->m_VDState == SnapshotOpen);
			ft.hr = pDb->m_pIVD->CompleteCommand (pDb->m_pSnapshotCmd, ERROR_SUCCESS, 0, 0);
			if (FAILED (ft.hr))
				ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompleteCommand");
		}

		// Wait for the BACKUP threads to report success.
		//
		WaitForThreads ();

		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			if (!pDb->m_SuccessDetected)
			{
				THROW_GENERIC;
			}
		}

		// Pull the "close" message from each VD
		//
		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;
		    VDC_Command *   cmd;
			ft.hr=pDb->m_pIVD->GetCommand (INFINITE, &cmd);
			if (ft.hr != VD_E_CLOSE)
				ft.LogError(VSS_ERROR_SQLLIB_FINALCOMMANDNOTCLOSE, VSSDBG_SQLLIB << ft.hr);

			pDb->m_pIVDSet->Close ();
			pDb->m_pIVDSet->Release ();
			pDb->m_pIVDSet = NULL;
			pDb->m_pIVD = NULL;

		}

		m_State = Complete;
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		return FALSE;
	}
	Unlock ();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\inc\vdi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 30 16:43:31 1999
 */
/* Compiler settings for vdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vdi_h__
#define __vdi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IClientVirtualDevice_FWD_DEFINED__
#define __IClientVirtualDevice_FWD_DEFINED__
typedef interface IClientVirtualDevice IClientVirtualDevice;
#endif 	/* __IClientVirtualDevice_FWD_DEFINED__ */


#ifndef __IClientVirtualDeviceSet_FWD_DEFINED__
#define __IClientVirtualDeviceSet_FWD_DEFINED__
typedef interface IClientVirtualDeviceSet IClientVirtualDeviceSet;
#endif 	/* __IClientVirtualDeviceSet_FWD_DEFINED__ */


#ifndef __IClientVirtualDeviceSet2_FWD_DEFINED__
#define __IClientVirtualDeviceSet2_FWD_DEFINED__
typedef interface IClientVirtualDeviceSet2 IClientVirtualDeviceSet2;
#endif 	/* __IClientVirtualDeviceSet2_FWD_DEFINED__ */


#ifndef __IServerVirtualDevice_FWD_DEFINED__
#define __IServerVirtualDevice_FWD_DEFINED__
typedef interface IServerVirtualDevice IServerVirtualDevice;
#endif 	/* __IServerVirtualDevice_FWD_DEFINED__ */


#ifndef __IServerVirtualDeviceSet_FWD_DEFINED__
#define __IServerVirtualDeviceSet_FWD_DEFINED__
typedef interface IServerVirtualDeviceSet IServerVirtualDeviceSet;
#endif 	/* __IServerVirtualDeviceSet_FWD_DEFINED__ */


#ifndef __IServerVirtualDeviceSet2_FWD_DEFINED__
#define __IServerVirtualDeviceSet2_FWD_DEFINED__
typedef interface IServerVirtualDeviceSet2 IServerVirtualDeviceSet2;
#endif 	/* __IServerVirtualDeviceSet2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_vdi_0000 */
/* [local] */ 


#pragma pack(push, _vdi_h_)

#pragma pack(8)
struct  VDConfig
    {
    unsigned long deviceCount;
    unsigned long features;
    unsigned long prefixZoneSize;
    unsigned long alignment;
    unsigned long softFileMarkBlockSize;
    unsigned long EOMWarningSize;
    unsigned long serverTimeOut;
    unsigned long blockSize;
    unsigned long maxIODepth;
    unsigned long maxTransferSize;
    unsigned long bufferAreaSize;
    };

enum VDFeatures
    {	VDF_Removable	= 0x1,
	VDF_Rewind	= 0x2,
	VDF_Position	= 0x10,
	VDF_SkipBlocks	= 0x20,
	VDF_ReversePosition	= 0x40,
	VDF_Discard	= 0x80,
	VDF_FileMarks	= 0x100,
	VDF_RandomAccess	= 0x200,
	VDF_WriteMedia	= 0x10000,
	VDF_ReadMedia	= 0x20000,
	VDF_LatchStats	= 0x80000000,
	VDF_LikePipe	= 0,
	VDF_LikeTape	= VDF_FileMarks | VDF_Removable | VDF_Rewind | VDF_Position | VDF_SkipBlocks | VDF_ReversePosition,
	VDF_LikeDisk	= VDF_RandomAccess
    };

enum VDCommands
    {	VDC_Read	= 1,
	VDC_Write	= VDC_Read + 1,
	VDC_ClearError	= VDC_Write + 1,
	VDC_Rewind	= VDC_ClearError + 1,
	VDC_WriteMark	= VDC_Rewind + 1,
	VDC_SkipMarks	= VDC_WriteMark + 1,
	VDC_SkipBlocks	= VDC_SkipMarks + 1,
	VDC_Load	= VDC_SkipBlocks + 1,
	VDC_GetPosition	= VDC_Load + 1,
	VDC_SetPosition	= VDC_GetPosition + 1,
	VDC_Discard	= VDC_SetPosition + 1,
	VDC_Flush	= VDC_Discard + 1,
	VDC_Snapshot	= VDC_Flush + 1,
	VDC_MountSnapshot	= VDC_Snapshot + 1
    };

enum VDWhence
    {	VDC_Beginning	= 0,
	VDC_Current	= VDC_Beginning + 1,
	VDC_End	= VDC_Current + 1
    };
struct  VDC_Command
    {
    DWORD commandCode;
    DWORD size;
    DWORDLONG position;
    BYTE __RPC_FAR *buffer;
    };


extern RPC_IF_HANDLE __MIDL_itf_vdi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0000_v0_0_s_ifspec;

#ifndef __IClientVirtualDevice_INTERFACE_DEFINED__
#define __IClientVirtualDevice_INTERFACE_DEFINED__

/* interface IClientVirtualDevice */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40700424-0080-11d2-851f-00c04fc21759")
    IClientVirtualDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteCommand( 
            /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
            /* [in] */ DWORD dwCompletionCode,
            /* [in] */ DWORD dwBytesTransferred,
            /* [in] */ DWORDLONG dwlPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCommand )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompleteCommand )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
            /* [in] */ DWORD dwCompletionCode,
            /* [in] */ DWORD dwBytesTransferred,
            /* [in] */ DWORDLONG dwlPosition);
        
        END_INTERFACE
    } IClientVirtualDeviceVtbl;

    interface IClientVirtualDevice
    {
        CONST_VTBL struct IClientVirtualDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDevice_GetCommand(This,dwTimeOut,ppCmd)	\
    (This)->lpVtbl -> GetCommand(This,dwTimeOut,ppCmd)

#define IClientVirtualDevice_CompleteCommand(This,pCmd,dwCompletionCode,dwBytesTransferred,dwlPosition)	\
    (This)->lpVtbl -> CompleteCommand(This,pCmd,dwCompletionCode,dwBytesTransferred,dwlPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDevice_GetCommand_Proxy( 
    IClientVirtualDevice __RPC_FAR * This,
    /* [in] */ DWORD dwTimeOut,
    /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd);


void __RPC_STUB IClientVirtualDevice_GetCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDevice_CompleteCommand_Proxy( 
    IClientVirtualDevice __RPC_FAR * This,
    /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
    /* [in] */ DWORD dwCompletionCode,
    /* [in] */ DWORD dwBytesTransferred,
    /* [in] */ DWORDLONG dwlPosition);


void __RPC_STUB IClientVirtualDevice_CompleteCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDevice_INTERFACE_DEFINED__ */


#ifndef __IClientVirtualDeviceSet_INTERFACE_DEFINED__
#define __IClientVirtualDeviceSet_INTERFACE_DEFINED__

/* interface IClientVirtualDeviceSet */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDeviceSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40700425-0080-11d2-851f-00c04fc21759")
    IClientVirtualDeviceSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenInSecondary( 
            /* [in] */ LPCWSTR lpSetName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferHandle( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBufferHandle( 
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondary )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferHandle )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBufferHandle )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IClientVirtualDeviceSetVtbl;

    interface IClientVirtualDeviceSet
    {
        CONST_VTBL struct IClientVirtualDeviceSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDeviceSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDeviceSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDeviceSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDeviceSet_Create(This,lpName,pCfg)	\
    (This)->lpVtbl -> Create(This,lpName,pCfg)

#define IClientVirtualDeviceSet_GetConfiguration(This,dwTimeOut,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,dwTimeOut,pCfg)

#define IClientVirtualDeviceSet_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IClientVirtualDeviceSet_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IClientVirtualDeviceSet_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IClientVirtualDeviceSet_OpenInSecondary(This,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondary(This,lpSetName)

#define IClientVirtualDeviceSet_GetBufferHandle(This,pBuffer,pBufferHandle)	\
    (This)->lpVtbl -> GetBufferHandle(This,pBuffer,pBufferHandle)

#define IClientVirtualDeviceSet_MapBufferHandle(This,dwBuffer,ppBuffer)	\
    (This)->lpVtbl -> MapBufferHandle(This,dwBuffer,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_Create_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_GetConfiguration_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ DWORD dwTimeOut,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_OpenDevice_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IClientVirtualDeviceSet_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_Close_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IClientVirtualDeviceSet_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_SignalAbort_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IClientVirtualDeviceSet_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_OpenInSecondary_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IClientVirtualDeviceSet_OpenInSecondary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_GetBufferHandle_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [out] */ DWORD __RPC_FAR *pBufferHandle);


void __RPC_STUB IClientVirtualDeviceSet_GetBufferHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_MapBufferHandle_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ DWORD dwBuffer,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IClientVirtualDeviceSet_MapBufferHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDeviceSet_INTERFACE_DEFINED__ */


#ifndef __IClientVirtualDeviceSet2_INTERFACE_DEFINED__
#define __IClientVirtualDeviceSet2_INTERFACE_DEFINED__

/* interface IClientVirtualDeviceSet2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDeviceSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0e6eb07-7a62-11d2-8573-00c04fc21759")
    IClientVirtualDeviceSet2 : public IClientVirtualDeviceSet
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEx( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenInSecondaryEx( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondary )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferHandle )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBufferHandle )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEx )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondaryEx )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName);
        
        END_INTERFACE
    } IClientVirtualDeviceSet2Vtbl;

    interface IClientVirtualDeviceSet2
    {
        CONST_VTBL struct IClientVirtualDeviceSet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDeviceSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDeviceSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDeviceSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDeviceSet2_Create(This,lpName,pCfg)	\
    (This)->lpVtbl -> Create(This,lpName,pCfg)

#define IClientVirtualDeviceSet2_GetConfiguration(This,dwTimeOut,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,dwTimeOut,pCfg)

#define IClientVirtualDeviceSet2_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IClientVirtualDeviceSet2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IClientVirtualDeviceSet2_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IClientVirtualDeviceSet2_OpenInSecondary(This,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondary(This,lpSetName)

#define IClientVirtualDeviceSet2_GetBufferHandle(This,pBuffer,pBufferHandle)	\
    (This)->lpVtbl -> GetBufferHandle(This,pBuffer,pBufferHandle)

#define IClientVirtualDeviceSet2_MapBufferHandle(This,dwBuffer,ppBuffer)	\
    (This)->lpVtbl -> MapBufferHandle(This,dwBuffer,ppBuffer)


#define IClientVirtualDeviceSet2_CreateEx(This,lpInstanceName,lpName,pCfg)	\
    (This)->lpVtbl -> CreateEx(This,lpInstanceName,lpName,pCfg)

#define IClientVirtualDeviceSet2_OpenInSecondaryEx(This,lpInstanceName,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondaryEx(This,lpInstanceName,lpSetName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet2_CreateEx_Proxy( 
    IClientVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpName,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet2_CreateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet2_OpenInSecondaryEx_Proxy( 
    IClientVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IClientVirtualDeviceSet2_OpenInSecondaryEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDeviceSet2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdi_0008 */
/* [local] */ 

struct  VDS_Command
    {
    DWORD commandCode;
    DWORD size;
    DWORDLONG inPosition;
    DWORDLONG outPosition;
    BYTE __RPC_FAR *buffer;
    BYTE __RPC_FAR *completionRoutine;
    BYTE __RPC_FAR *completionContext;
    DWORD completionCode;
    DWORD bytesTransferred;
    };


extern RPC_IF_HANDLE __MIDL_itf_vdi_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0008_v0_0_s_ifspec;

#ifndef __IServerVirtualDevice_INTERFACE_DEFINED__
#define __IServerVirtualDevice_INTERFACE_DEFINED__

/* interface IServerVirtualDevice */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5e7a131-a7bd-11d1-84c2-00c04fc21759")
    IServerVirtualDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendCommand( 
            /* [in] */ struct VDS_Command __RPC_FAR *pCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDevice( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendCommand )( 
            IServerVirtualDevice __RPC_FAR * This,
            /* [in] */ struct VDS_Command __RPC_FAR *pCmd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDevice )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceVtbl;

    interface IServerVirtualDevice
    {
        CONST_VTBL struct IServerVirtualDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDevice_SendCommand(This,pCmd)	\
    (This)->lpVtbl -> SendCommand(This,pCmd)

#define IServerVirtualDevice_CloseDevice(This)	\
    (This)->lpVtbl -> CloseDevice(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDevice_SendCommand_Proxy( 
    IServerVirtualDevice __RPC_FAR * This,
    /* [in] */ struct VDS_Command __RPC_FAR *pCmd);


void __RPC_STUB IServerVirtualDevice_SendCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDevice_CloseDevice_Proxy( 
    IServerVirtualDevice __RPC_FAR * This);


void __RPC_STUB IServerVirtualDevice_CloseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDevice_INTERFACE_DEFINED__ */


#ifndef __IServerVirtualDeviceSet_INTERFACE_DEFINED__
#define __IServerVirtualDeviceSet_INTERFACE_DEFINED__

/* interface IServerVirtualDeviceSet */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDeviceSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5e7a132-a7bd-11d1-84c2-00c04fc21759")
    IServerVirtualDeviceSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ LPCWSTR lpName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfiguration( 
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteCompletionAgent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConfiguration )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteCompletionAgent )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceSetVtbl;

    interface IServerVirtualDeviceSet
    {
        CONST_VTBL struct IServerVirtualDeviceSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDeviceSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDeviceSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDeviceSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDeviceSet_Open(This,lpName)	\
    (This)->lpVtbl -> Open(This,lpName)

#define IServerVirtualDeviceSet_GetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet_SetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> SetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet_ExecuteCompletionAgent(This)	\
    (This)->lpVtbl -> ExecuteCompletionAgent(This)

#define IServerVirtualDeviceSet_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IServerVirtualDeviceSet_AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)	\
    (This)->lpVtbl -> AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)

#define IServerVirtualDeviceSet_FreeBuffer(This,pBuffer,dwSize)	\
    (This)->lpVtbl -> FreeBuffer(This,pBuffer,dwSize)

#define IServerVirtualDeviceSet_IsSharedBuffer(This,pBuffer)	\
    (This)->lpVtbl -> IsSharedBuffer(This,pBuffer)

#define IServerVirtualDeviceSet_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IServerVirtualDeviceSet_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_Open_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName);


void __RPC_STUB IServerVirtualDeviceSet_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_GetConfiguration_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_SetConfiguration_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet_SetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_ExecuteCompletionAgent_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_ExecuteCompletionAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_OpenDevice_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IServerVirtualDeviceSet_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_AllocateBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment);


void __RPC_STUB IServerVirtualDeviceSet_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_FreeBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IServerVirtualDeviceSet_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_IsSharedBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer);


void __RPC_STUB IServerVirtualDeviceSet_IsSharedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_SignalAbort_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_Close_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDeviceSet_INTERFACE_DEFINED__ */


#ifndef __IServerVirtualDeviceSet2_INTERFACE_DEFINED__
#define __IServerVirtualDeviceSet2_INTERFACE_DEFINED__

/* interface IServerVirtualDeviceSet2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDeviceSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AECBD0D6-24C6-11d3-85B7-00C04FC21759")
    IServerVirtualDeviceSet2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginConfiguration( 
            /* [in] */ DWORD dwFeatures,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwBlockSize,
            /* [in] */ DWORD dwMaxTransferSize,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndConfiguration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestBuffers( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAvailableBuffers( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [out] */ DWORD __RPC_FAR *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteCompletionAgent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwFeatures,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwBlockSize,
            /* [in] */ DWORD dwMaxTransferSize,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestBuffers )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAvailableBuffers )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [out] */ DWORD __RPC_FAR *pCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteCompletionAgent )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceSet2Vtbl;

    interface IServerVirtualDeviceSet2
    {
        CONST_VTBL struct IServerVirtualDeviceSet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDeviceSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDeviceSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDeviceSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDeviceSet2_Open(This,lpInstanceName,lpSetName)	\
    (This)->lpVtbl -> Open(This,lpInstanceName,lpSetName)

#define IServerVirtualDeviceSet2_GetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet2_BeginConfiguration(This,dwFeatures,dwAlignment,dwBlockSize,dwMaxTransferSize,dwTimeout)	\
    (This)->lpVtbl -> BeginConfiguration(This,dwFeatures,dwAlignment,dwBlockSize,dwMaxTransferSize,dwTimeout)

#define IServerVirtualDeviceSet2_EndConfiguration(This)	\
    (This)->lpVtbl -> EndConfiguration(This)

#define IServerVirtualDeviceSet2_RequestBuffers(This,dwSize,dwAlignment,dwCount)	\
    (This)->lpVtbl -> RequestBuffers(This,dwSize,dwAlignment,dwCount)

#define IServerVirtualDeviceSet2_QueryAvailableBuffers(This,dwSize,dwAlignment,pCount)	\
    (This)->lpVtbl -> QueryAvailableBuffers(This,dwSize,dwAlignment,pCount)

#define IServerVirtualDeviceSet2_ExecuteCompletionAgent(This)	\
    (This)->lpVtbl -> ExecuteCompletionAgent(This)

#define IServerVirtualDeviceSet2_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IServerVirtualDeviceSet2_AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)	\
    (This)->lpVtbl -> AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)

#define IServerVirtualDeviceSet2_FreeBuffer(This,pBuffer,dwSize)	\
    (This)->lpVtbl -> FreeBuffer(This,pBuffer,dwSize)

#define IServerVirtualDeviceSet2_IsSharedBuffer(This,pBuffer)	\
    (This)->lpVtbl -> IsSharedBuffer(This,pBuffer)

#define IServerVirtualDeviceSet2_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IServerVirtualDeviceSet2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_Open_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IServerVirtualDeviceSet2_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_GetConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet2_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_BeginConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwFeatures,
    /* [in] */ DWORD dwAlignment,
    /* [in] */ DWORD dwBlockSize,
    /* [in] */ DWORD dwMaxTransferSize,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IServerVirtualDeviceSet2_BeginConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_EndConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_EndConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_RequestBuffers_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment,
    /* [in] */ DWORD dwCount);


void __RPC_STUB IServerVirtualDeviceSet2_RequestBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_QueryAvailableBuffers_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment,
    /* [out] */ DWORD __RPC_FAR *pCount);


void __RPC_STUB IServerVirtualDeviceSet2_QueryAvailableBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_ExecuteCompletionAgent_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_ExecuteCompletionAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_OpenDevice_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IServerVirtualDeviceSet2_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_AllocateBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment);


void __RPC_STUB IServerVirtualDeviceSet2_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_FreeBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IServerVirtualDeviceSet2_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_IsSharedBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer);


void __RPC_STUB IServerVirtualDeviceSet2_IsSharedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_SignalAbort_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_Close_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDeviceSet2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdi_0011 */
/* [local] */ 

#define CLSID_MSSQL_ClientVirtualDeviceSet IID_IClientVirtualDeviceSet
#define CLSID_MSSQL_ServerVirtualDeviceSet IID_IServerVirtualDeviceSet

#pragma pack(pop, _vdi_h_)


extern RPC_IF_HANDLE __MIDL_itf_vdi_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqlwriter\globals.cpp ===
//
// globals.cpp : define all the stinking global vars :(
//

#define DBINITCONSTANTS

#pragma warning (disable: 4268)
#include <stdafx.hxx>

#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\inc\vdierror.h ===
#ifndef VDIERROR_H_
#define VDIERROR_H_
//****************************************************************************
//		Copyright (c) 1998-2000 Microsoft Corporation.
//
// @File: vdierror.h
//
// Purpose:
//  Declare the error codes emitted by the virtual device interface.
//
// Notes:
//	
// History:
//     
//
// @EndHeader@
//****************************************************************************

//
// Define all the VDI errors.
//


//---------------------------------------------------------------------------------------
// Error code handling will be done in standard COM fashion:
//
// an HRESULT is returned and the caller can use
// SUCCEEDED(code) or FAILED(code) to determine
// if the function failed or not.
//

// form an error code
//
#define VD_ERROR(code) MAKE_HRESULT(SEVERITY_ERROR, 0x77, code)

// The object was not open
//
#define VD_E_NOTOPEN        VD_ERROR( 2 )   /* 0x80770002 */

// The api was waiting and the timeout interval had elapsed.
//
#define VD_E_TIMEOUT        VD_ERROR( 3 )   /* 0x80770003 */

// An abort request is preventing anything except termination actions.
//
#define VD_E_ABORT          VD_ERROR( 4 )   /* 0x80770004 */

// Failed to create security environment.
//
#define VD_E_SECURITY		VD_ERROR( 5 )   /* 0x80770005 */

// An invalid parameter was supplied
//
#define VD_E_INVALID        VD_ERROR( 6 )   /* 0x80770006 */

// Failed to recognize the SQL Server instance name
//
#define VD_E_INSTANCE_NAME  VD_ERROR( 7 )   /* 0x80770007 */

// The requested configuration is invalid
#define VD_E_NOTSUPPORTED   VD_ERROR( 9 )   /* 0x80770009 */

// Out of memory
#define VD_E_MEMORY         VD_ERROR( 10 )  /* 0x8077000a */

// Unexpected internal error
#define VD_E_UNEXPECTED     VD_ERROR (11)   /* 0x8077000b */

// Protocol error
#define VD_E_PROTOCOL       VD_ERROR (12)   /* 0x8077000c */

// All devices are open
#define VD_E_OPEN           VD_ERROR (13)   /* 0x8077000d */

// the object is now closed
#define VD_E_CLOSE          VD_ERROR (14)   /* 0x8077000e */

// the resource is busy
#define VD_E_BUSY           VD_ERROR (15)   /* 0x8077000f */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqllib\inc\vdiguid.h ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 30 16:43:31 1999
 */
/* Compiler settings for vdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IClientVirtualDevice = {0x40700424,0x0080,0x11d2,{0x85,0x1f,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IClientVirtualDeviceSet = {0x40700425,0x0080,0x11d2,{0x85,0x1f,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IClientVirtualDeviceSet2 = {0xd0e6eb07,0x7a62,0x11d2,{0x85,0x73,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDevice = {0xb5e7a131,0xa7bd,0x11d1,{0x84,0xc2,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDeviceSet = {0xb5e7a132,0xa7bd,0x11d1,{0x84,0xc2,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDeviceSet2 = {0xAECBD0D6,0x24C6,0x11d3,{0x85,0xB7,0x00,0xC0,0x4F,0xC2,0x17,0x59}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\sqlwriter\sqlwriter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module sqlwriter.cpp | Implementation of Writer
    @end

Author:

    Brian Berkowitz  [brianb]  04/17/2000

TBD:
	

Revision History:

	Name		Date		Comments
	brianb		04/17/2000	created
	brianb		04/20/2000	integrated with coordinator
	brainb		05/05/2000	add OnIdentify support
	mikejohn	06/01/2000	fix minor but confusing typos in trace messages
	mikejohn	09/19/2000	176860: Add the missing calling convention specifiers

--*/
#include <stdafx.hxx>
#include "vs_idl.hxx"
#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "allerror.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQWWRTRC"
//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszSqlServerWriter = L"SqlServerWriter";

static GUID s_writerId =
	{
	0xf8544ac1, 0x0611, 0x4fa5, 0xb0, 0x4b, 0xf7, 0xee, 0x00, 0xb0, 0x32, 0x77
	};

static LPCWSTR s_wszWriterName = L"MSDEWriter";

HRESULT STDMETHODCALLTYPE CSqlWriter::Initialize()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::Initialize");

	try
		{
		InitSQLEnvironment();
		m_pSqlSnapshot = CreateSqlSnapshot();
		if (m_pSqlSnapshot == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to allocate CSqlSnapshot object.");

		ft.hr = CVssWriter::Initialize
			(
			s_writerId,
			s_wszWriterName,
			VSS_UT_SYSTEMSERVICE,
			VSS_ST_TRANSACTEDDB,
			VSS_APP_BACK_END,
			60000
			);

        if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Failed to initialize the Sql writer.  hr = 0x%08lx",
				ft.hr
				);

		ft.hr = Subscribe();
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Subscribing the Sql server writer failed. hr = %0x08lx",
				ft.hr
				);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()  && m_pSqlSnapshot)
		{
		delete m_pSqlSnapshot;
		m_pSqlSnapshot = NULL;
		}

	return ft.hr;
	}

HRESULT STDMETHODCALLTYPE CSqlWriter::Uninitialize()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::Uninitialize");

	return Unsubscribe();
	}
	

bool STDMETHODCALLTYPE CSqlWriter::OnPrepareSnapshot()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnPrepareSnapshot");


	try
		{
		BS_ASSERT(!m_fFrozen);
		ft.hr = m_pSqlSnapshot->Prepare(this);
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	return !ft.HrFailed();
	}



bool STDMETHODCALLTYPE CSqlWriter::OnFreeze()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnFreeze");


	try
		{
		BS_ASSERT(!m_fFrozen);
		ft.hr = m_pSqlSnapshot->Freeze();
		if (!ft.HrFailed())
			m_fFrozen = true;
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	return !ft.HrFailed();
	}


bool STDMETHODCALLTYPE CSqlWriter::OnThaw()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnThaw");


	try
		{
		if (m_fFrozen)
			{
			m_fFrozen = false;
			ft.hr = m_pSqlSnapshot->Thaw();
			}
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	return !ft.HrFailed();
	}


bool STDMETHODCALLTYPE CSqlWriter::OnAbort()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnAbort");


	try
		{
		if (m_fFrozen)
			{
			m_fFrozen = false;
			ft.hr = m_pSqlSnapshot->Thaw();
			}
		}
	VSS_STANDARD_CATCH(ft)

	return !ft.HrFailed();
	}

bool CSqlWriter::IsPathInSnapshot(const WCHAR *wszPath) throw()
	{
	return IsPathAffected(wszPath);
	}


// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CSqlWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnIdentify");

	ServerInfo server;
	DatabaseInfo database;
	DatabaseFileInfo file;

	// create enumerator
	CSqlEnumerator *pEnumServers = CreateSqlEnumerator();
	CSqlEnumerator *pEnumDatabases = NULL;
	CSqlEnumerator *pEnumFiles = NULL;
	try
		{
		if (pEnumServers == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

		// find first server
		ft.hr = pEnumServers->FirstServer(&server);
		while(ft.hr != DB_S_ENDOFROWSET)
			{
			// check for error code
			if (ft.HrFailed())
				ft.Throw
					(
					VSSDBG_GEN,
					E_UNEXPECTED,
					L"Enumerating database servers failed.  hr = 0x%08lx",
					ft.hr
					);

            // only look at server if it is online
			if (server.isOnline)
				{
				// recreate enumerator for databases
				BS_ASSERT(pEnumDatabases == NULL);
				pEnumDatabases = CreateSqlEnumerator();
				if (pEnumDatabases == NULL)
					ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

				// find first database
				ft.hr = pEnumDatabases->FirstDatabase(server.name, &database);


				while(ft.hr != DB_S_ENDOFROWSET)
					{
					// check for error
					if (ft.HrFailed())
						ft.Throw
							(
							VSSDBG_GEN,
							E_UNEXPECTED,
							L"Enumerating databases failed.  hr = 0x%08lx",
							ft.hr
							);

                    // only include database if it supports Freeze
					if (database.supportsFreeze &&
						wcscmp(database.name, L"tempdb") != 0)
						{
						// add database component
						ft.hr = pMetadata->AddComponent
									(
									VSS_CT_DATABASE,		// component type
									server.name,			// logical path	
									database.name,			// component name
									NULL,					// caption
									NULL,					// pbIcon
									0,						// cbIcon
									false,					// bRestoreMetadata
									false,					// bNotifyOnBackupComplete
									false					// bSelectable
									);

                        if (ft.HrFailed())
							ft.Throw
								(
								VSSDBG_GEN,
								E_UNEXPECTED,
								L"IVssCreateWriterMetadata::AddComponent failed.  hr = 0x%08lx",
								ft.hr
								);

						// recreate enumerator for files
						BS_ASSERT(pEnumFiles == NULL);
						pEnumFiles = CreateSqlEnumerator();
						if (pEnumFiles == NULL)
							ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");


                        // findfirst database file
                        ft.hr = pEnumFiles->FirstFile(server.name, database.name, &file);
						while(ft.hr != DB_S_ENDOFROWSET)
							{
							// check for error
							if (ft.HrFailed())
								ft.Throw
									(
									VSSDBG_GEN,
									E_UNEXPECTED,
									L"Enumerating database files failed.  hr = 0x%08lx",
									ft.hr
									);

                            // split file name into separate path
							// and filename components.  Path is everything
							// before the last backslash.
							WCHAR logicalPath[MAX_PATH];
							WCHAR *pFileName = file.name + wcslen(file.name);
							while(--pFileName > file.name)
								{
								if (*pFileName == '\\')
									break;
								}

							// if no backslash, then there is no path
							if (pFileName == file.name)
								logicalPath[0] = '\0';
							else
								{
								// extract path
								size_t cwc = wcslen(file.name) - wcslen(pFileName);
								memcpy(logicalPath, file.name, cwc*sizeof(WCHAR));
								logicalPath[cwc] = L'\0';
								pFileName++;
								}


							if (file.isLogFile)
								// log file
								ft.hr = pMetadata->AddDatabaseLogFiles
												(
												server.name,
												database.name,
												logicalPath,
												pFileName
												);
							else
								// physical database file
								ft.hr = pMetadata->AddDatabaseLogFiles
												(
												server.name,
												database.name,
												logicalPath,
												pFileName
												);

                            // continue at next file
							ft.hr = pEnumFiles->NextFile(&file);
							}

						delete pEnumFiles;
						pEnumFiles = NULL;
						}

					// continue at next database
					ft.hr = pEnumDatabases->NextDatabase(&database);
					}

				delete pEnumDatabases;
				pEnumDatabases = NULL;
				}

			// continue at next server
			ft.hr = pEnumServers->NextServer(&server);
			}
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	delete pEnumServers;
	delete pEnumDatabases;
	delete pEnumFiles;

	return ft.HrFailed() ? false : true;
	}

// translate a sql writer error code into a writer error
void CSqlWriter::TranslateWriterError(HRESULT hr)
	{
	switch(hr)
		{
		default:
			SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
			break;

        case S_OK:
			break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
			SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
			break;

        case HRESULT_FROM_WIN32(E_SQLLIB_TORN_DB):
			SetWriterFailure(VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT);
			break;
        }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\tracing\assrt.cxx ===
/*++

Copyright (c) 200  Microsoft Corporation

Module Name:

    assrt.cxx

Abstract:
	assertion code used by BS_ASSERT

Author:


Revision History:
	Name		Date		Comments
	brianb		04/19/2000	created
	aoltean     06/20/2000  Adding VssSetDebugReport

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <stdio.h>

#undef ASSERT

#include "vs_assert.hxx"
#include "vs_trace.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCASRTC"
//
////////////////////////////////////////////////////////////////////////


// No MP protection...
static LONG g_lVssDebugReportFlags = VSS_DBG_TO_DEBUG_CONSOLE | VSS_DBG_MESSAGE_BOX;


VOID
AssertFail
	(
    IN LPCSTR FileName,
    IN UINT LineNumber,
    IN LPCSTR Condition
    )
	{
    int i;
    CHAR Title[4096];
    CHAR Msg[4096];

    DWORD dwCurrentProcessId = GetCurrentProcessId();
    DWORD dwCurrentThreadId = GetCurrentThreadId();
    
    if (g_lVssDebugReportFlags & VSS_DBG_TO_DEBUG_CONSOLE) 
        {
        sprintf(
            Msg,
            "VSS(PID:%ld,TID:%ld): %s(%d): *** Assertion failure  *** %s\n",
            dwCurrentProcessId,
            dwCurrentThreadId,
            FileName,
            LineNumber,
            Condition
            );


        ::OutputDebugStringA(Msg);
/*
        ::DbgPrintEx(
            DPFLTR_VSS_ID,
            1,
            Msg
            );
 */
        }

    if (g_lVssDebugReportFlags & VSS_DBG_MESSAGE_BOX) 
        {
        LPSTR szCommandLine = GetCommandLineA();

        //
        // Use dll name as caption
        //
        sprintf(
            Title,
            "Volume Snapshots (PID:%ld,TID:%ld)",
            dwCurrentProcessId,
            dwCurrentThreadId
            );

        //
        // Print the assertion and the command line
        //
        sprintf(
            Msg,
            "Assertion failure at line %u in file %s: %s\n\nCommand line: %s\n\nHit Cancel to break into the debugger.",
            LineNumber,
            FileName,
            Condition,
            szCommandLine
            );

        i = MessageBoxA
    			(
                NULL,
                Msg,
    			Title,
    			MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_SERVICE_NOTIFICATION
                );

        if(i == IDCANCEL)
            DebugBreak();
        }
    }

void VssSetDebugReport( LONG lDebugReportFlags )
{
    g_lVssDebugReportFlags = lDebugReportFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\tracing\bsconcur.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsconcur.cxx

Abstract:

    Implementation of CBsXXXX classes that wrap Win32 concurrency controls.

Author:

    Stefan R. Steiner   [SSteiner]      11-Apr-1998

Revision History:

--*/

#include <windows.h>
#include "bsconcur.hxx"

//////////////////////////////////////////////////////////////////////
// CBsAutoLock class implementation
//////////////////////////////////////////////////////////////////////

CBsAutoLock::~CBsAutoLock()
{
    BOOL bStatus = TRUE;

    switch( m_type ) {
    case BS_AUTO_MUTEX_HANDLE: 
        bStatus = ::ReleaseMutex( m_hMutexHandle );
        break;
    case BS_AUTO_CRIT_SEC:
        ::LeaveCriticalSection( m_pCritSec );
        break;
    case BS_AUTO_CRIT_SEC_CLASS:
        m_pcCritSec->Leave();
        break;
    }

    if ( bStatus == FALSE ) {
        throw( ::GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\tracing\vs_seh.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_seh.cxx

Abstract:

    Exception handling support code

Author:

   Stefan R. Steiner   [SSteiner]      15-Apr-1998

Revision History:

    ssteiner   09/10/98		- Removed the exception classes.  Now only throwing
							HRESULTs.
	aoltean		02/02/2000	- moved into Vss project under the name from bsexcept.cxx 
							into "vs_seh" 
    
--*/

#include <windows.h>
#include "vs_seh.hxx"
#include "vs_trace.hxx"

/*++

Routine Description:

    The Structured Exception Handling translator function.  Translates
    SEH exceptions to C++ Native exceptions.  Generates a trace message.

Arguments:

    ExceptionCode - SEH exception code.

    pEP - pointer to a more detailed explanation of why the exception
          was thrown.
        
Return Value:

    None

Throws:

    HRESULT - translated exception code from windows exception code to HRESULT.

--*/

void _cdecl BsSeHandler::SeHandler(
    unsigned int uiExceptionCode,
    struct _EXCEPTION_POINTERS *pEP
    )
{
    BsDebugTraceAlways( 0, DEBUG_TRACE_CATCH_EXCEPTIONS, 
                        ( L"BsSeHandler::SeHandler: Caught SEH exception, code: 0x%08x", uiExceptionCode ) );                        
    BS_THROW( (HRESULT)uiExceptionCode );
    UNREFERENCED_PARAMETER( pEP );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\vss_ps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vss_ps.rc
//
#define IDS_PROJNAME                    100
#define IDR_EVENTMONIMPL                     101
#define IDR_TYPELIB1                    201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\vssadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vssadmin.rc
//
#define IDS_USAGE                       101
#define IDS_USAGE_SNAPSHOTS             102
#define IDS_USAGE_WRITERS               103
#define IDS_USAGE_PROVIDERS             104
#define IDS_ERROR                       105
#define IDS_SNAPSHOT_SET_HEADER         106
#define IDS_SNAPSHOT_CONTENTS           107
#define IDS_SNAPSHOT_CONTENTS2          108
#define IDS_UNKNOWN_PROVIDER            109
#define IDS_PROVIDER_CONTENTS           110 
#define IDS_HEADER                      111 
#define IDS_WRITER_CONTENTS             112
#define IDS_PROV_TYPE_SYSTEM            113
#define IDS_PROV_TYPE_SOFTWARE          114
#define IDS_PROV_TYPE_HARDWARE          115
#define IDS_PROV_TYPE_UNKNOWN           116
#define IDS_WRITER_STATUS_STABLE        117
#define IDS_WRITER_STATUS_FAILED        118
#define IDS_WRITER_STATUS_UNKNOWN       119
#define IDS_WRITER_STATUS_WAITING_FOR_FREEZE        120
#define IDS_WRITER_STATUS_FROZEN        121
#define IDS_WRITER_STATUS_WAITING_FOR_COMPLETION    122
#define IDS_NO_SNAPSHOTS                123
#define IDS_NO_SNAPSHOTS_FOR_SET        124
#define IDS_WAITING_RESPONSES           125

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         301
#define _APS_NEXT_SYMED_VALUE           401
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\tracing\vs_trace.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_trace.cxx

Abstract:

    This module defines the global debug\trace facilities used by the
	Long Term Storage service.
	
	Previous name: bsdebug.cxx

Author:


Revision History:
	Name		Date		Comments
    ssteiner    06/03/98    Made numerious changes and removed iostream
                            dependencies, added a few new registry entries and
                            added serialization.
	aoltean		06/06/99	Taken from atl30\atlbase.h in order to avoid linking ATL with BSCommon.lib
    ssteiner    05/15/00    Fixed bug #116688.  Added file locking to prevent multiple processes from
                            interferring with writing to the trace file.  Added code to place a UNICODE
                            BOM at the beginning of the trace file.
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <vssmsg.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>



#include "vs_inc.hxx"
#include "vs_idl.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCTRCC"
//
////////////////////////////////////////////////////////////////////////

//
//  The following global, g_cDbgTrace must be declared BEFORE any of our
//  objects including _Module, since some of our static objects have destructors
//  that call trace methods.  The following pragma ensures that this
//  module's static objects are initialized before any of our other
//  static objects, assuming they don't use this same pragma.
//
#pragma warning(disable:4073) // ignore init_seg warning
#pragma init_seg(lib)

CBsDbgTrace g_cDbgTrace;


static VOID MakeFileUnicode(
    IN HANDLE hFile
    );

/////////////////////////////////////////////////////////////////////////////
// constants
//

const WCHAR	VSS_TRACINGKEYPATH[]	=
			L"SYSTEM\\CurrentControlSet\\Services\\VSS\\Debug\\Tracing";

const WCHAR	SETUP_KEY[]	=
			L"SYSTEM\\Setup";

const WCHAR	SETUP_INPROGRESS_REG[]	=
			L"SystemSetupInProgress";

const DWORD SETUP_INPROGRESS_VALUE = 1;


/////////////////////////////////////////////////////////////////////////////
//  Globals
//

//
//  NOTE: g_cDbgTrace, the global instance of this class is declared in
//  ltss\modules\ltssvc\src\ltssvc.cxx since we have to make sure
//  this object is the last one being destructed, otherwise possible
//  calls to this object will fail.
//

//
// Define a TLS var, stores the CLTermStg & intention list index.
// The index is a counter that is incremented and set for each thread
// coming into the service, in the CLTermStg::FinalConstruct method.
// The counter is also incremented and set for each intention list
// thread that is created by the service.
//
//  WARNING
//
//
//_declspec( thread ) DWORD CBsDbgTrace::m_dwContextNum = 0;

//
//  Queries a registry value name and if found sets dwValue to the value.
//  If the value name is not found, dwValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT DWORD &dwValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );
    
    if ( dwResult == ERROR_SUCCESS )
        dwValue = dwReadValue;

    return dwResult;
}

//
//  Queries a registry value name and if found sets bValue to the value.
//  If the value name is not found, bValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT BOOL &bValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );

    if ( dwResult == ERROR_SUCCESS )
        bValue = (BOOL)(dwReadValue != 0);

    return dwResult;
}

//
//  Queries a registry value name and if found sets wsValue to the value.
//  If the value name is not found, wsValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    OUT LPWSTR &wsValue, // If allocated, must be freed before calling with ::VssFreeString
    IN LPCWSTR pwszValueName
    )
{
	WCHAR pszValueBuffer[_MAX_PATH];
    DWORD dwCount = _MAX_PATH;
    DWORD dwResult = cRegKey.QueryValue( pszValueBuffer, pwszValueName, &dwCount );

    BS_ASSERT(wsValue == NULL);
    if ( dwResult == ERROR_SUCCESS ) 
        ::VssDuplicateStr(wsValue, pszValueBuffer);

    return dwResult;
}

//
//  ***** class definitions *****
//


CBsDbgTrace::CBsDbgTrace()

/*++

Routine Description:

    Constructor method. Default values are given to operational
    parameters and overwritten using values from the registry if
    set.  Also prints out the trace file banner.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
	m_bInitialized = false;
	m_bTracingEnabled = false;
	m_pcs = NULL;
    Initialize( TRUE );
}


CBsDbgTrace::~CBsDbgTrace()
/*++

Routine Description:

    Destructor method.  Prints out the last record in the NTMS


Arguments:

	LONG Indent - NOT USED YET [todo] this is the indentation indicator
	LONG Level - this is the debug trace level

Return Value:

    BOOL

--*/
{
    if ( !m_bInitialized )
        return;

    if ( m_bTracingEnabled ) {
        //
        //  Write out a finished tracing message
        //
        m_pcs->Enter();
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING FINISHED - ProcessId: 0x%x, ContextId: 0x%x",
            m_dwCurrentProcessId, m_dwContextId ) );
        WCHAR pwszCurrentTime[128];
        time_t ltime;
        struct tm *pToday;
        time( &ltime );
        pToday = localtime( &ltime );
        wcsftime( pwszCurrentTime, sizeof pwszCurrentTime, L"%c", pToday );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Elapsed time: %d seconds", ltime- m_lTimeStarted ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        m_pcs->Leave();

        //
        //  Make sure the file is flushed before leaving
        //
        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
                ::FlushFileBuffers( m_hTraceFile );
                ::CloseHandle( m_hTraceFile );
            }
        }
    }

    ::VssFreeString(m_pwszTraceFileName);

    //
    //  Delete the critical section
    //
    delete m_pcs;
    m_pcs = NULL;
    m_bInitialized = FALSE;
}

//
//  In certain cases the global trace object doesn't seem to get it's constructor called.
//  To fix this problem, this function was added to perform the initialization of the
//  object.  This function is called both in the constructor and the set context call
//  which all DLLs that use the trace class call.
//
VOID
CBsDbgTrace::Initialize(
    IN  BOOL bInConstructor
    )
{
    if ( !m_bInitialized )
    {
		try
			{
			//
			//  Get the critical section created first
			//
			m_pcs = new CBsCritSec;
			if ( m_pcs == NULL )
				throw E_OUTOFMEMORY;
			m_bInitialized = TRUE;

			m_bTracingEnabled       = FALSE;
			m_bTraceToFile          = BS_DBG_TRACE_TO_FILE_DFLT;
			m_bTraceToDebugger      = BS_DBG_TRACE_TO_DEBUGGER_DFLT;
			m_bTraceEnterExit       = BS_DBG_TRACE_ENTER_EXIT_DFLT;
			m_dwTraceLevel          = BS_DBG_TRACE_LEVEL_DFLT;
			m_bTraceFileLineInfo    = BS_DBG_TRACE_FILE_LINE_INFO_DFLT;
			m_bTraceTimestamp       = BS_DBG_TRACE_TIMESTAMP_DFLT;
			m_pwszTraceFileName     = NULL;
			m_bForceFlush           = BS_DBG_TRACE_FORCE_FLUSH_DFLT;
			m_dwTraceIndent         = 0;
			m_bInTrace              = FALSE;
			m_hTraceFile            = INVALID_HANDLE_VALUE;
			m_dwLineNum             = 0;
			m_dwCurrentProcessId    = GetCurrentProcessId();
			m_bIsDuringSetup        = FALSE;
			
			LARGE_INTEGER liTimer;
			if ( ::QueryPerformanceCounter( &liTimer ) )
				{
				//  Got high performance counter, use the low part
				m_dwContextId = liTimer.LowPart;
				}
			else
				{
				m_dwContextId = ::GetTickCount();
				}

			ReadRegistry();

			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING STARTED - ProcessId: 0x%x, ContextId: 0x%x",
				m_dwCurrentProcessId, m_dwContextId ) );
			if ( !bInConstructor )
				BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  N.B. NOT INITIALIZED BY THE CONSTRUCTOR" ) );

			WCHAR pwszCurrentTime[128];
			struct tm *pToday;
			time( &m_lTimeStarted );
			pToday = localtime( &m_lTimeStarted );
			wcsftime( pwszCurrentTime, sizeof pwszCurrentTime, L"%c", pToday );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Product version: %d.%d.%d.%d", VER_PRODUCTVERSION ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
			}
		catch(...)
			{
			delete m_pcs;
			m_pcs = NULL;
			m_bInitialized = false;
			m_bTracingEnabled = false;
			}
		}

}


BOOL
CBsDbgTrace::IsDuringSetup()
{
    return m_bIsDuringSetup;
}



HRESULT
CBsDbgTrace::ReadRegistry()
/*++

Routine Description:

    Tries to read debug specific values from the registry and adds
    the values if they don't exist.

Arguments:

    NONE

Return Value:

    HRESULT

--*/
{

	DWORD dwRes;
	CRegKey cRegKeySetup;
	CRegKey cRegKeyTracing;


    m_bTracingEnabled = FALSE;
    m_bIsDuringSetup = FALSE;
    
	//
	// Open the Setup key
	//

	dwRes = cRegKeySetup.Open( HKEY_LOCAL_MACHINE, SETUP_KEY, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
        DWORD dwSetupInProgress = 0;
        QuerySetValue( cRegKeySetup, dwSetupInProgress, SETUP_INPROGRESS_REG );
        m_bIsDuringSetup = ( dwSetupInProgress == SETUP_INPROGRESS_VALUE );
	}
	
	//
	// Open the VSS tracing key
	//

	dwRes = cRegKeyTracing.Open( HKEY_LOCAL_MACHINE, VSS_TRACINGKEYPATH, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
		
        // The name of the optional trace file
        QuerySetValue( cRegKeyTracing, m_pwszTraceFileName, BS_DBG_TRACE_FILE_NAME_REG );

        // The trace level determines what type of traciung will occur. Zero
        // indicates that no tracing will occur, and is the default.
        QuerySetValue( cRegKeyTracing, m_dwTraceLevel, BS_DBG_TRACE_LEVEL_REG );

        // The TraceEnterExit flag determines whether or not function entry & exit
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceEnterExit, BS_DBG_TRACE_ENTER_EXIT_REG );

        // The TraceToFile flag determines whether or not trace information is output to
        // the trace file. If this value is FALSE, no output is sent to the trace file.
        QuerySetValue( cRegKeyTracing, m_bTraceToFile, BS_DBG_TRACE_TO_FILE_REG );

        // The TraceToDebugger flag determines whether or not trace information is output
        // to the debugger. If this value is FALSE, no output is sent to the debugger.
        QuerySetValue( cRegKeyTracing, m_bTraceToDebugger, BS_DBG_TRACE_TO_DEBUGGER_REG );

        // The Timestamp flag determines whether or not timestamp
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceTimestamp, BS_DBG_TRACE_TIMESTAMP_REG );

        // The FileLineInfo flag determines whether or not the module file name
        // and line number information is output to the trace file & the debug
        // output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceFileLineInfo, BS_DBG_TRACE_FILE_LINE_INFO_REG );

        // The TraceForceFlush flag specifies whether or not after each trace message is
        // written to the trace file a forced flush occurs.  If enabled, no trace records
        // are ever lost, however, performance is greatly reduced.
        QuerySetValue( cRegKeyTracing, m_bForceFlush, BS_DBG_TRACE_FORCE_FLUSH_REG );

        // Determine if tracing should be enabled
        if ( m_bTraceToDebugger || m_bTraceToFile )
            m_bTracingEnabled = TRUE;

	}

    return S_OK;
}


HRESULT
CBsDbgTrace::PrePrint(
    IN LPCWSTR pwszSourceFileName,
    IN DWORD dwLineNum,
    IN DWORD dwIndent,
    IN DWORD dwLevel,
    IN LPCWSTR pwszFunctionName,
    IN BOOL bTraceEnter
    )
/*++

Routine Description:

    Acquires the critical section so that other threads are
    now serialized.  Opens the trace file if necessary.
    N.B. Any A/V's in this code can cause a hang since the SEH translator function
    calls these trace functions.

Arguments:

    pszSourceFileName - Source file name of the module whose
        code called this method.
    dwLineNum - Line number in the source
    dwIndent - Number to increase or decrease the indendation level
    dwLevel - Trace level that specifies for which component
        the code resides in.
    pwszFunctionName - For entry/exit tracing.  Specifies the
        function name constains a call the a trace macro.
    bTraceEnter - True if this is a entry trace.

Return Value:

    HRESULT

--*/
{
    m_pcs->Enter();

    //
    //  Assume the trace macros have already filtered out traces based
    //  on m_bTracingEnabled and on the active trace level.
    //

    if ( m_bTracingEnabled && (dwLevel & m_dwTraceLevel) != 0) {
        if ( pwszSourceFileName == NULL )
            m_pwszSourceFileName = L"(Unknown source file)";
        else
        {
            //
            //  Keep only two levels deep of directory components
            //
            LPCWSTR pwszTemp = pwszSourceFileName + ::wcslen( pwszSourceFileName ) - 1;
            for ( int i = 0; pwszTemp > pwszSourceFileName && i < 3; ++i )
            {
                do
                {
                    --pwszTemp;
                }
                while( *pwszTemp != L'\\' && pwszTemp > pwszSourceFileName ) ;
            }
            if ( pwszTemp > pwszSourceFileName )
                m_pwszSourceFileName = pwszTemp + 1;
            else
                m_pwszSourceFileName = pwszSourceFileName;
        }

        m_pwszFunctionName   = pwszFunctionName;
        m_dwLineNum        = dwLineNum;
        m_bTraceEnter      = bTraceEnter;

        BS_ASSERT( m_hTraceFile == INVALID_HANDLE_VALUE );

        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile == INVALID_HANDLE_VALUE ) {
                //
                //  Error opening the file, print a message to the debugger if debugger
                //  tracing is enabled
                //
                Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to open trace file, dwRet: %u", ::GetLastError() );
            } else {
                //
                //  Now lock the process from other processes and threads that are concurrently
                //  accessing the file.  Just lock the first byte of the file.
                //
                OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
                if ( !::LockFileEx( m_hTraceFile,
                                    LOCKFILE_EXCLUSIVE_LOCK,
                                    0,
                                    1,
                                    0,
                                    &ovStart ) ) {
                    //
                    //  Tracing to file will be skipped for this record.  This should
                    //  never happen in practice.
                    //
                    ::CloseHandle( m_hTraceFile );
                    m_hTraceFile = INVALID_HANDLE_VALUE;

                    //
                    //  Try printing a trace message that will get to the debugger if debugger
                    //  tracing is enabled
                    //
                    Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to lock trace file, skipping trace record, dwRet: %u", ::GetLastError() );
                } else {
                    //
                    //  If the file is new (empty) put the UNICODE BOM at the beginning of the file
                    //
                    LARGE_INTEGER liPointer;
                    if ( ::GetFileSizeEx( m_hTraceFile, &liPointer ) ) {
                        if ( liPointer.QuadPart == 0 )
                            ::MakeFileUnicode( m_hTraceFile );
                    }

                    //
                    //  Now move the file pointer to the end of the file
                    //
                    liPointer.QuadPart = 0;
                    if ( !::SetFilePointerEx( m_hTraceFile,
                                              liPointer,
                                              NULL,
                                              FILE_END ) ) {
                        //
                        //  Don't write to the file since it might overwrite valid records.
                        //  Tracing to file will be skipped for this record.  This should
                        //  never happen in practice.
                        //
                        ::CloseHandle( m_hTraceFile );
                        m_hTraceFile = INVALID_HANDLE_VALUE;

                        //
                        //  Try printing a trace message that will get to the debugger if debugger
                        //  tracing is enabled
                        //
                        Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to set end of file, skipping trace record, dwRet: %u", ::GetLastError() );
                    }
                }
            }
        }

        m_bInTrace = TRUE;
    }

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT
CBsDbgTrace::PostPrint(
    IN DWORD dwIndent
    )
/*++

Routine Description:

    Releases the critical section so that other threads
    can now call perform tracing.  Closes the trace file
    and resets variables.

Arguments:

    dwIndent - Number to increase or decrease the indendation level

Return Value:

    HRESULT

--*/
{
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
        if ( !::UnlockFileEx( m_hTraceFile,
                              0,
                              1,
                              0,
                              &ovStart ) ) {
            Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to unlock trace file, dwRet: %u", ::GetLastError() );
        }
        if ( m_bForceFlush )
            ::FlushFileBuffers( m_hTraceFile );
        ::CloseHandle( m_hTraceFile );
        m_hTraceFile = INVALID_HANDLE_VALUE;
    }

    m_pwszSourceFileName = NULL;
    m_pwszFunctionName = NULL;
    m_dwLineNum = 0;
    m_bInTrace  = FALSE;

    m_pcs->Leave();

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT _cdecl
CBsDbgTrace::Print(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            swprintf( m_pwszOutBuf,
                      L"[%010u,",
                      GetTickCount() );
        else
            swprintf( m_pwszOutBuf,
                      L"[-," );

        swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId );

        if ( m_bTraceFileLineInfo )
          swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                    L"%s(%04u): ",
                    m_pwszSourceFileName,
                    m_dwLineNum );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    _vsnwprintf( m_pwszOutBuf, BS_DBG_OUT_BUF_SIZE-1, pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT _cdecl
CBsDbgTrace::PrintEnterExit(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the entry/exit trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            swprintf( m_pwszOutBuf,
                      L"[%010u,",
                      GetTickCount() );
        else
            swprintf( m_pwszOutBuf,
                      L"[-," );

        swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] %s {%s}: ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId,
                  m_bTraceEnter ? L"ENTER" : L"EXIT ",
                  m_pwszFunctionName );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    _vsnwprintf( m_pwszOutBuf, BS_DBG_OUT_BUF_SIZE-1, pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT
CBsDbgTrace::OutputString()
/*++

Routine Description:

    Prints the trace message out to the trace file and/or debugger.

Arguments:

    Assumes m_pwszOutBuf has the string to be printed.

Return Value:

    HRESULT

--*/
{
    //
    //  Make sure we didn't go off the end.  Can't use BS_ASSERT(), it
    //  will cause an deadlock.
    //
    _ASSERTE( wcslen( m_pwszOutBuf ) < BS_DBG_OUT_BUF_SIZE );

    //
    // Print to the debug stream for debug builds
    //
    if ( m_bTraceToDebugger )
        OutputDebugString( m_pwszOutBuf );

    //
    // If file tracing is enabled, dump to file
    //
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        DWORD dwBytesWritten;
        ::WriteFile( m_hTraceFile,
                     m_pwszOutBuf,
                     (DWORD)(wcslen( m_pwszOutBuf ) * sizeof(WCHAR)),
                     &dwBytesWritten,
                     NULL );
    }

    return S_OK;
}


VOID CBsDbgTrace::SetContextNum(
    IN DWORD dwContextNum
    )
/*++

Routine Description:

    Use to be used to set the context number of the operation.  Now it is only
    used to determine if a DLL is loading using the trace class.

Arguments:

    LTS_CONTEXT_DELAYED_DLL - DLL is using the class object.

--*/
{
    if (dwContextNum == LTS_CONTEXT_DELAYED_DLL && !m_bInitialized )
    {
        Initialize();
    }

}


/*++

Routine Description:

    Puts the UNICODE UCS-2 BOM (Byte Order Mark) at the beginning of the file
    to let applications know that 1. this is a UCS-2 UNICODE file and 2. that
    the byte ordering is little-endian.

    Assumes the file is empty.

Arguments:

    hFile - Handle to the file

Return Value:

    <Enter return values here>

--*/
static VOID MakeFileUnicode(
    IN HANDLE hFile
    )
{
    BS_ASSERT( hFile != INVALID_HANDLE_VALUE );
    BYTE byteBOM[2] = { 0xFF, 0xFE };

    DWORD dwBytesWritten;
    ::WriteFile( hFile,
                 byteBOM,
                 sizeof byteBOM,
                 &dwBytesWritten,
                 NULL );
}


void __cdecl CVssFunctionTracer::TranslateError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszRoutine
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

--*/

    {
	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
		LogError(VSS_ERROR_UNEXPECTED_CALLING_ROUTINE, dbgInfo << wszRoutine << hr);
		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error in routine %s.  hr = 0x%08lx", wszRoutine, hr);
		}
	}


void __cdecl CVssFunctionTracer::TranslateGenericError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s", wszOutputBuffer);
	else
		{
		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << wszOutputBuffer << hr);
		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s  [hr = 0x%08lx]", wszOutputBuffer, hr);
		}
	}



void __cdecl CVssFunctionTracer::TranslateProviderError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN GUID ProviderID,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a provider call

Throws:

    E_OUTOFMEMORY
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Unexpected provider error. The error code is logged into the event log.
    VSS_E_PROVIDER_VETO
        - Expected provider error. The provider already did the logging.

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

	if (hr == E_OUTOFMEMORY)
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, GUID_PRINTF_ARG(ProviderID));
	else if (hr == E_INVALIDARG) {
		LogError(VSS_ERROR_CALLING_PROVIDER_ROUTINE_INVALIDARG, dbgInfo << ProviderID << wszOutputBuffer );
		Throw(dbgInfo, E_INVALIDARG, L"Invalid argument detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, GUID_PRINTF_ARG(ProviderID));
	}
	else if (hr == VSS_E_PROVIDER_VETO)
		Throw(dbgInfo, VSS_E_PROVIDER_VETO, L"Provider veto detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, GUID_PRINTF_ARG(ProviderID));
    else
		{
		LogError(VSS_ERROR_CALLING_PROVIDER_ROUTINE, dbgInfo << ProviderID << wszOutputBuffer << hr );
		Throw(dbgInfo, VSS_E_UNEXPECTED_PROVIDER_ERROR, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, hr, GUID_PRINTF_ARG(ProviderID));
		}
	}



void __cdecl CVssFunctionTracer::TranslateInternalProviderError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hrToBeTreated,
		IN HRESULT hrToBeThrown,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a provider call

Throws:

    E_OUTOFMEMORY
    
    hrToBeThrown

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

    hr = hrToBeTreated;

	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s.", wszOutputBuffer);
	else if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
	    hr == HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED) || 
		hr == HRESULT_FROM_WIN32(ERROR_NOT_READY))
	    {
		LogError(VSS_ERROR_DEVICE_NOT_CONNECTED, dbgInfo << wszOutputBuffer );
		Throw(dbgInfo, VSS_E_OBJECT_NOT_FOUND, 
		    L"Invalid device when calling a provider routine: %s", wszOutputBuffer);
    	}
    else
		{
		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << wszOutputBuffer << hr );
		Throw(dbgInfo, hrToBeThrown, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] ", wszOutputBuffer, hr );
		}
	}



void __cdecl CVssFunctionTracer::TranslateWriterReturnCode
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a writer call (CoCreteInstance of the writer COM+ event class
	or sending an event.

Throws:

    E_OUTOFMEMORY
    VSS_E_UNEXPECTED_WRITER_ERROR
        - Unexpected writer error. The error code is logged into the event log.

--*/

    {

    if (HrSucceeded()) {
        BS_ASSERT(hr == S_OK || hr == EVENT_S_NOSUBSCRIBERS || hr == EVENT_S_SOME_SUBSCRIBERS_FAILED);
        hr = S_OK;
        return;
    }
    
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );
    
    if (hr == EVENT_E_ALL_SUBSCRIBERS_FAILED) {
		Warning( VSSDBG_COORD, L"%s event failed at one writer. hr = 0x%08lx", wszOutputBuffer, hr);
		// ignore the error;
        return;
        }
	else if (hr == E_OUTOFMEMORY)
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s.", wszOutputBuffer);
    else
		{
		LogError(VSS_ERROR_UNEXPECTED_WRITER_ERROR, dbgInfo << wszOutputBuffer << hr );
		Throw(dbgInfo, VSS_E_UNEXPECTED_WRITER_ERROR, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] ", wszOutputBuffer, hr);
		}
    }



void __cdecl CVssFunctionTracer::LogGenericWarning
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Log a generic warning.

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

	LogError(VSS_WARNING_UNEXPECTED, dbgInfo << wszOutputBuffer << hr, EVENTLOG_WARNING_TYPE);
	Trace(dbgInfo, L"WARNING: %s [hr = 0x%08lx]", wszOutputBuffer, hr);
	}


// This method must be called prior to calling a CoCreateInstance that may start VSS
void CVssFunctionTracer::LogVssStartupAttempt()
{
    // the name of the Volume Snapshot Service
    const LPCWSTR wszVssvcServiceName = L"VSS";
    
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;

    try
	{
        //
        //  Check to see if VSSVC is running. If not, we are putting an entry into the trace log if enabled.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"QueryServiceStatus (shSCService, &sSStat)");

        // If the service is not running, then we will put an informational error log entry 
        // if (sSStat.dwCurrentState != SERVICE_RUNNING)
        //     LogError(VSS_INFO_SERVICE_STARTUP, 
        //         VSSDBG_GEN << GetCommandLineW() << (HRESULT)sSStat.dwCurrentState, 
        //         EVENTLOG_INFORMATION_TYPE);
        if (sSStat.dwCurrentState != SERVICE_RUNNING)
            Trace( VSSDBG_GEN, 
                L"Volume Snapshots Service information: Service starting at request of process '%s'. [0x%08x]",
                GetCommandLineW(), sSStat.dwCurrentState );        
	} VSS_STANDARD_CATCH ((*this));

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\vssadmin\process.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module process.cpp | The processing functions for the VSS admin CLI
    @end

Author:

    Adi Oltean  [aoltean]  04/04/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     04/04/2000  Created
    ssteiner    10/20/2000  Changed List SnapshotSets to use more limited VSS queries.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include "vswriter.h"
#include "vsbackup.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMPROCC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


class CVssAdmSnapshotSetEntry {
public:
    // Constructor - Throws NOTHING
    CVssAdmSnapshotSetEntry( 
        IN VSS_ID SnapshotSetId,
        IN INT nOriginalSnapshotsCount
        ) : m_SnapshotSetId( SnapshotSetId ),
            m_nOriginalSnapshotCount(nOriginalSnapshotsCount){ }

    ~CVssAdmSnapshotSetEntry()
    {
        // Have to delete all snapshots entries
        int iCount = GetSnapshotCount();
        for ( int i = 0; i < iCount; ++i )
        {
            VSS_SNAPSHOT_PROP *pSSProp;
            pSSProp = GetSnapshotAt( i );
			::VssFreeSnapshotProperties(pSSProp);

            delete pSSProp;
        }
        
    }
    
    // Add new snapshot to the snapshot set 
    HRESULT AddSnapshot( 
        IN CVssFunctionTracer &ft,
        IN VSS_SNAPSHOT_PROP *pVssSnapshotProp )
    {
        HRESULT hr = S_OK;
        try
        {
            VSS_SNAPSHOT_PROP *pNewVssSnapshotProp = new VSS_SNAPSHOT_PROP;
            if ( pNewVssSnapshotProp == NULL )
    			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
                
            *pNewVssSnapshotProp = *pVssSnapshotProp;
            if ( !m_mapSnapshots.Add( pNewVssSnapshotProp->m_SnapshotId, pNewVssSnapshotProp ) )
            {
                delete pNewVssSnapshotProp;
    			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
            }               
        }
        BS_STANDARD_CATCH();

        return hr;
    }

    INT GetSnapshotCount() { return m_mapSnapshots.GetSize(); }

    INT GetOriginalSnapshotCount() { return m_nOriginalSnapshotCount; }

    VSS_ID GetSnapshotSetId() { return m_SnapshotSetId; }
    
    VSS_SNAPSHOT_PROP *GetSnapshotAt(
        IN int nIndex )
    {
        BS_ASSERT( !(nIndex < 0 || nIndex >= GetSnapshotCount()) );
        return m_mapSnapshots.GetValueAt( nIndex );
    }
    
private:
    VSS_ID  m_SnapshotSetId;
    INT     m_nOriginalSnapshotCount;
    CVssSimpleMap<VSS_ID, VSS_SNAPSHOT_PROP *> m_mapSnapshots;
};


// This class queries the list of all snapshots and assembles from the query
// the list of snapshotsets and the volumes which are in the snapshotset.
class CVssAdmSnapshotSets
{
public:
    // Constructor - Throws HRESULTS
    CVssAdmSnapshotSets(
        IN VSS_ID FilteredSnapshotSetId = GUID_NULL )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSets::CVssAdmSnapshotSets" );
        
        bool bFiltered = !( FilteredSnapshotSetId == GUID_NULL );

    	// Create the coordinator object
    	CComPtr<IVssCoordinator> pICoord;

        ft.LogVssStartupAttempt();
        ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

		// Get list all snapshots
		CComPtr<IVssEnumObject> pIEnumSnapshots;
		ft.hr = pICoord->Query( GUID_NULL,
					VSS_OBJECT_NONE,
					VSS_OBJECT_SNAPSHOT,
					&pIEnumSnapshots );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Query failed with hr = 0x%08lx", ft.hr);

		// For all snapshots do...
		VSS_OBJECT_PROP Prop;
		VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
		for(;;) {
			// Get next element
			ULONG ulFetched;
			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Next failed with hr = 0x%08lx", ft.hr);
			
			// Test if the cycle is finished
			if (ft.hr == S_FALSE) {
				BS_ASSERT( ulFetched == 0);
				break;
			}

            // If filtering, skip entry if snapshot is not in the specified snapshot set
			if ( bFiltered && !( Snap.m_SnapshotSetId == FilteredSnapshotSetId ) )
			    continue;

            ft.Trace( VSSDBG_VSSADMIN, L"Snapshot: %s", Snap.m_pwszOriginalVolumeName );
            
            // Look up the snapshot set id in the list of snapshot sets
            CVssAdmSnapshotSetEntry *pcSSE;
			pcSSE = m_mapSnapshotSets.Lookup( Snap.m_SnapshotSetId );
			if ( pcSSE == NULL )
			{
			    // Haven't seen this snapshot set before, add it to list
			    pcSSE = new CVssAdmSnapshotSetEntry( Snap.m_SnapshotSetId, 
			                    Snap.m_lSnapshotsCount );
			    if ( pcSSE == NULL )
        			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
			    if ( !m_mapSnapshotSets.Add( Snap.m_SnapshotSetId, pcSSE ) )
			    {
			        delete pcSSE;
        			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
			    }
			}

			// Now add the snapshot to the snapshot set
			ft.hr = pcSSE->AddSnapshot( ft, &Snap );
			if ( ft.HrFailed() )
      			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"AddSnapshot failed" );			
		}        
    }

    ~CVssAdmSnapshotSets()
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSets::~CVssAdmSnapshotSets" );
        // Have to delete all 
        int iCount;
        iCount = m_mapSnapshotSets.GetSize();
        for ( int i = 0; i < iCount; ++i )
        {
            delete m_mapSnapshotSets.GetValueAt( i );
        }
    }

    INT GetSnapshotSetCount() { return m_mapSnapshotSets.GetSize(); }

    CVssAdmSnapshotSetEntry *GetSnapshotSetAt(
        IN int nIndex )
    {
        BS_ASSERT( !(nIndex < 0 || nIndex >= GetSnapshotSetCount()) );
        return m_mapSnapshotSets.GetValueAt( nIndex );
    }
        

private:
    CVssSimpleMap<VSS_ID, CVssAdmSnapshotSetEntry *> m_mapSnapshotSets;        
};

/////////////////////////////////////////////////////////////////////////////
//  Implementation


void CVssAdminCLI::PrintUsage(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    //  Usage:\n\n
    //  vssadmin list snapshots [-set {snapshot set guid}]\n
    //  \tWill list all snapshots in the system, grouped by snapshot set Id.\n\n
    //  vssadmin list writers\n
    //  \tWill list all writers in the system\n\n
    //  vssadmin list providers\n
    //  \tWill list all currently installed snapshot providers\n
	Output( ft, IDS_USAGE );
	Output( ft, IDS_USAGE_SNAPSHOTS, 
	    wszVssOptVssadmin, wszVssOptList, wszVssOptSnapshots, wszVssOptSet );
	Output( ft, IDS_USAGE_WRITERS, 
	    wszVssOptVssadmin, wszVssOptList, wszVssOptWriters );
	Output( ft, IDS_USAGE_PROVIDERS, 
	    wszVssOptVssadmin, wszVssOptList, wszVssOptProviders);
}


void CVssAdminCLI::ListSnapshots(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    bool bNonEmptyResult = false;
    
	// Check the filter type
	switch ( m_eFilterObjectType ) {
	case VSS_OBJECT_SNAPSHOT_SET:
	case VSS_OBJECT_NONE:
		break;

	default:
		BS_ASSERT(false);
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Invalid object type %d", m_eFilterObjectType);
	}

    CVssAdmSnapshotSets cVssAdmSS( m_FilterSnapshotSetId );

    INT iSnapshotSetCount = cVssAdmSS.GetSnapshotSetCount();

    // If there are no present snapshots then display a message.
    if (iSnapshotSetCount == 0) {
    	Output( ft, 
    	    (m_eFilterObjectType == VSS_OBJECT_SNAPSHOT_SET)? 
    	        IDS_NO_SNAPSHOTS_FOR_SET: IDS_NO_SNAPSHOTS );
    }

	// For all snapshot sets do...
    for ( INT iSSS = 0; iSSS < iSnapshotSetCount; ++iSSS )
    {
        CVssAdmSnapshotSetEntry *pcSSE;

        pcSSE = cVssAdmSS.GetSnapshotSetAt( iSSS );
        BS_ASSERT( pcSSE != NULL );
        
		// Print each snapshot set
		Output( ft, IDS_SNAPSHOT_SET_HEADER,
			GUID_PRINTF_ARG( pcSSE->GetSnapshotSetId() ),
			pcSSE->GetOriginalSnapshotCount(), pcSSE->GetSnapshotCount());

		// TBD: add creation time from the first snapshot.

		INT iSnapshotCount = pcSSE->GetSnapshotCount();
		
		VSS_SNAPSHOT_PROP *pSnap;
		for( INT iSS = 0; iSS < iSnapshotCount; ++iSS ) {
		    pSnap = pcSSE->GetSnapshotAt( iSS );
            BS_ASSERT( pSnap != NULL );

    		// Get the provider name
			LPCWSTR pwszProviderName =
				GetProviderName(ft, pSnap->m_ProviderId);

			// Print each snapshot
			Output( ft, IDS_SNAPSHOT_CONTENTS,
                pwszProviderName? pwszProviderName: L"",
				GUID_PRINTF_ARG(pSnap->m_SnapshotId),
				pSnap->m_pwszOriginalVolumeName
				);

			Output( ft, wszVssFmtNewline );

			bNonEmptyResult = true;
		}
	}

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}


void CVssAdminCLI::ListWriters(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    bool bNonEmptyResult = false;
    
    // Get the backup components object
    CComPtr<IVssBackupComponents> pBackupComp;
	CComPtr<IVssAsync> pAsync;
    ft.hr = ::CreateVssBackupComponents(&pBackupComp);
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"CreateVssBackupComponents failed with hr = 0x%08lx", ft.hr);

    // BUGBUG Initialize for backup
    ft.hr = pBackupComp->InitializeForBackup();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"InitializeForBackup failed with hr = 0x%08lx", ft.hr);

	UINT unWritersCount;
	// get metadata for all writers
	ft.hr = pBackupComp->GatherWriterMetadata(&pAsync);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"GatherWriterMetadata failed with hr = 0x%08lx", ft.hr);

    // Using polling, try to obtain the list of writers as soon as possible
    HRESULT hrReturned = S_OK;
    for (int nRetries = 0; nRetries < MAX_RETRIES_COUNT; nRetries++ ) {

        // Wait a little
        ::Sleep(nPollingInterval);

        // Check if finished
        INT nReserved = 0;
    	ft.hr = pAsync->QueryStatus(
    	    &hrReturned,
    	    &nReserved
    	    );
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, 
                L"IVssAsync::QueryStatus failed with hr = 0x%08lx", ft.hr);
        if (hrReturned == VSS_S_ASYNC_FINISHED)
            break;
        if (hrReturned == VSS_S_ASYNC_PENDING)
            continue;
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, 
            L"IVssAsync::QueryStatus returned hr = 0x%08lx", hrReturned);
    }

    // If still not ready, then print the "waiting for responses" message and wait.
    if (hrReturned == VSS_S_ASYNC_PENDING) {
        Output( ft, IDS_WAITING_RESPONSES );
    	ft.hr = pAsync->Wait();
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"IVssAsync::Wait failed with hr = 0x%08lx", ft.hr);
    }

	pAsync = NULL;
	
    // Gather the status of all writers
	ft.hr = pBackupComp->GatherWriterStatus(&pAsync);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"GatherWriterMetadata failed with hr = 0x%08lx", ft.hr);

	ft.hr = pAsync->Wait();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"IVssAsync::Wait failed with hr = 0x%08lx", ft.hr);

	pAsync = NULL;

	ft.hr = pBackupComp->GetWriterStatusCount(&unWritersCount);
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"GetWriterStatusCount failed with hr = 0x%08lx", ft.hr);

    // Print each writer status+supplementary info
	for(UINT unIndex = 0; unIndex < unWritersCount; unIndex++)
	{
		VSS_ID idInstance;
		VSS_ID idWriter;
		CComBSTR bstrWriter;
		VSS_WRITER_STATE eStatus;
		HRESULT hrWriterFailure;

        // Get the status for the (unIndex)-th writer
		ft.hr = pBackupComp->GetWriterStatus(unIndex, &idInstance, &idWriter, &bstrWriter, &eStatus, &hrWriterFailure);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"GetWriterStatus failed with hr = 0x%08lx", ft.hr);

        // Get the status description strings
        LPCWSTR pwszStatusDescription;
        switch (eStatus) {
        case VSS_WS_STABLE:
            pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_STABLE);
            break;
        case VSS_WS_WAITING_FOR_FREEZE:
            pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_WAITING_FOR_FREEZE);
            break;
        case VSS_WS_WAITING_FOR_THAW:
            pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_FROZEN);
            break;
        case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_WAITING_FOR_COMPLETION);
            break;
        case VSS_WS_FAILED_AT_IDENTIFY:
        case VSS_WS_FAILED_AT_PREPARE_BACKUP:
        case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
        case VSS_WS_FAILED_AT_FREEZE:
        case VSS_WS_FAILED_AT_THAW:
            pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_FAILED);
            break;
        default:
            pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_UNKNOWN);
            break;
        }
        BS_ASSERT(pwszStatusDescription);

		// Print status+info about each writer
		Output( ft, IDS_WRITER_CONTENTS,
            (LPWSTR)bstrWriter? (LPWSTR)bstrWriter: L"",
			GUID_PRINTF_ARG(idWriter),
			GUID_PRINTF_ARG(idInstance),
            (INT)eStatus,
			pwszStatusDescription
			);

		Output( ft, wszVssFmtNewline );

		bNonEmptyResult = true;
    }

	ft.hr = pBackupComp->FreeWriterStatus();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"FreeWriterStatus failed with hr = 0x%08lx", ft.hr);

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}


void CVssAdminCLI::ListProviders(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    bool bNonEmptyResult = false;
    
	// Check the filter type
	switch ( m_eFilterObjectType ) {

	case VSS_OBJECT_NONE:
		break;

	default:
		BS_ASSERT(false);
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Invalid object type %d", m_eFilterObjectType);
	}

	// Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
    ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Query all (filtered) snapshot sets
	CComPtr<IVssEnumObject> pIEnumProv;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProv );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Query failed with hr = 0x%08lx", ft.hr);

	// For all snapshot sets do...
	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumProv->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is ended
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        // Get the provider type strings
        LPCWSTR pwszProviderType;
        switch (Prov.m_eProviderType) {
        case VSS_PROV_SYSTEM:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_SYSTEM);
            break;
        case VSS_PROV_SOFTWARE:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_SOFTWARE);
            break;
        case VSS_PROV_HARDWARE:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_HARDWARE);
            break;
        default:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_UNKNOWN);
            break;
        }
        BS_ASSERT(pwszProviderType);

		// Print each snapshot set
		Output( ft, IDS_PROVIDER_CONTENTS,
            Prov.m_pwszProviderName? Prov.m_pwszProviderName: L"",
			pwszProviderType,
			GUID_PRINTF_ARG(Prov.m_ProviderId),
            Prov.m_pwszProviderVersion? Prov.m_pwszProviderVersion: L"");

		::CoTaskMemFree(Prov.m_pwszProviderName);
		::CoTaskMemFree(Prov.m_pwszProviderVersion);

		bNonEmptyResult = true;
	}

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\vssadmin\vssadmin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vssadmin.cpp | Implementation of the Volume Snapshots demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include <locale.h>
#include <winnlsp.h>  // in public\internal\base\inc

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMVADMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation



CVssAdminCLI::CVssAdminCLI(
		IN	HINSTANCE hInstance
		)

/*++

	Description:

		Standard constructor. Initializes internal members

--*/

{
	BS_ASSERT(hInstance != NULL);
	m_hInstance = hInstance;

	m_eCommandType = VSS_CMD_UNKNOWN;
	m_eListType = VSS_LIST_UNKNOWN;
	m_eFilterObjectType = VSS_OBJECT_UNKNOWN;
	m_eListedObjectType = VSS_OBJECT_UNKNOWN;
	m_FilterSnapshotSetId = GUID_NULL;
	m_FilterSnapshotId = GUID_NULL;
	m_pwszCmdLine = NULL;
	m_nReturnValue = VSS_CMDRET_ERROR;
	m_hConsoleOutput = INVALID_HANDLE_VALUE;
}


CVssAdminCLI::~CVssAdminCLI()

/*++

	Description:

		Standard destructor. Calls Finalize and eventually frees the
		memory allocated by internal members.

--*/

{
	// Release the cached resource strings
    for( int nIndex = 0; nIndex < m_mapCachedResourceStrings.GetSize(); nIndex++) {
	    LPCWSTR& pwszResString = m_mapCachedResourceStrings.GetValueAt(nIndex);
		::VssFreeString(pwszResString);
    }

	// Release the cached provider names
    for( int nIndex = 0; nIndex < m_mapCachedProviderNames.GetSize(); nIndex++) {
	    LPCWSTR& pwszProvName = m_mapCachedProviderNames.GetValueAt(nIndex);
		::VssFreeString(pwszProvName);
    }

	// Release the cached command line
	::VssFreeString(m_pwszCmdLine);

	// Uninitialize the COM library
	Finalize();
}



/////////////////////////////////////////////////////////////////////////////
//  Implementation



LPCWSTR CVssAdminCLI::LoadString(
		IN	CVssFunctionTracer& ft,
		IN	UINT uStringId
		)
{
    LPCWSTR wszReturnedString = m_mapCachedResourceStrings.Lookup(uStringId);
	if (wszReturnedString)
		return wszReturnedString;

	// Load the string from resources.
	WCHAR	wszBuffer[nStringBufferSize];
	INT nReturnedCharacters = ::LoadStringW(
			GetInstance(),
			uStringId,
			wszBuffer,
			nStringBufferSize - 1
			);
	if (nReturnedCharacters == 0)
		ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error on loading the string %u. 0x%08lx",
				  uStringId, ::GetLastError() );

	// Duplicate the new string
	LPWSTR wszNewString = NULL;
	::VssSafeDuplicateStr( ft, wszNewString, wszBuffer );
	wszReturnedString = wszNewString;

	// Save the string in the cache
	if ( !m_mapCachedResourceStrings.Add( uStringId, wszReturnedString ) ) {
		::VssFreeString( wszReturnedString );
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	}

	return wszReturnedString;
}


LPCWSTR CVssAdminCLI::GetNextCmdlineToken(
	IN	CVssFunctionTracer& ft,
	IN	bool bFirstToken /* = false */
	) throw(HRESULT)

/*++

Description:

	This function returns the tokens in the command line.

	The function will skip any separators (space and tab).

	If bFirstCall == true then it will return the first token.
	Otherwise subsequent calls will return subsequent tokens.

	If the last token is NULL then there are no more tokens in the command line.

--*/

{
	return ::wcstok( bFirstToken? m_pwszCmdLine: NULL, wszVssFmtSpaces );
	UNREFERENCED_PARAMETER(ft);
}


bool CVssAdminCLI::Match(
	IN	CVssFunctionTracer& ft,
	IN	LPCWSTR wszString,
	IN	LPCWSTR wszPatternString
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches the
	pattern string. The comparison is case insensitive.

--*/

{
	// If the string is NULL then the Match failed.
	if (wszString == NULL) return false;

	// Check for string equality (case insensitive)
	return (::_wcsicmp( wszString, wszPatternString ) == 0);
	UNREFERENCED_PARAMETER(ft);
}


bool CVssAdminCLI::ScanGuid(
	IN	CVssFunctionTracer& /* ft */,
	IN	LPCWSTR wszString,
	IN	VSS_ID& Guid
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches a guid.
	The guid is returned in the proper variable.
	The formatting is case insensitive.

--*/

{
	return SUCCEEDED(::CLSIDFromString(W2OLE(const_cast<WCHAR*>(wszString)), &Guid));
}


void CVssAdminCLI::Output(
	IN	CVssFunctionTracer& ft,
	IN	UINT uFormatStringId,
	...
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches the
	pattern strig from resources. The comparison is case insensitive.

--*/

{
    WCHAR wszOutputBuffer[nStringBufferSize];

	// Load the format string
	LPCWSTR wszFormat = LoadString( ft, uFormatStringId );

	// Format the final string
    va_list marker;
    va_start( marker, uFormatStringId );
    _vsnwprintf( wszOutputBuffer, nStringBufferSize - 1, wszFormat, marker );
    va_end( marker );

	// Print the final string to the output
	OutputOnConsole( wszOutputBuffer );
}


void CVssAdminCLI::Output(
	IN	CVssFunctionTracer& ft,
	IN	LPCWSTR wszFormat,
	...
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches the
	pattern strig from resources. The comparison is case insensitive.

--*/

{
    WCHAR wszOutputBuffer[nStringBufferSize];

	// Format the final string
    va_list marker;
    va_start( marker, wszFormat );
    _vsnwprintf( wszOutputBuffer, nStringBufferSize - 1, wszFormat, marker );
    va_end( marker );

	// Print the final string to the output
	OutputOnConsole( wszOutputBuffer );

	UNREFERENCED_PARAMETER(ft);
}

void CVssAdminCLI::OutputOnConsole(
    IN	LPCWSTR wszStr
    )
{
	DWORD dwCharsOutput;
	DWORD fdwMode;
	static BOOL bFirstTime = TRUE;
	static BOOL bIsTrueConsoleOutput;

    if ( m_hConsoleOutput == INVALID_HANDLE_VALUE )
    {
        throw E_UNEXPECTED;
    }

    if ( bFirstTime )
    {
        //
        //  Stash away the results in static vars.  bIsTrueConsoleOutput is TRUE when the 
        //  standard output handle is pointing to a console character device.
        //
    	bIsTrueConsoleOutput = ( ::GetFileType( m_hConsoleOutput ) & FILE_TYPE_CHAR ) && 
    	                       ::GetConsoleMode( m_hConsoleOutput, &fdwMode  );
	    bFirstTime = FALSE;
    }
    
    if ( bIsTrueConsoleOutput )
    {
        //
        //  Output to the console
        //
    	if ( !::WriteConsoleW( m_hConsoleOutput, 
    	                       ( PVOID )wszStr, 
    	                       ( DWORD )::wcslen( wszStr ), 
    	                       &dwCharsOutput, 
    	                       NULL ) )
    	{
    	    throw HRESULT_FROM_WIN32( ::GetLastError() );
    	}    	
    }
    else
    {
        //
        //  Output being redirected.  WriteConsoleW doesn't work for redirected output.  Convert
        //  UNICODE to the current output CP multibyte charset.
        //

        // ---------------- To be removed later - Start -----------------
        //
        //  Translate \n to \r\n since the string might be directed to a disk file.
        //  Remove this code if the .rc file can be updated to include
        //  \r\n.  This was needed since we are in UI lockdown.
        //
        LPWSTR pwszConversion;

        //  Allocate a string twice the size of the original
        pwszConversion = ( LPWSTR )::malloc( ( ( ::wcslen( wszStr ) * 2 ) + 1 ) * sizeof( WCHAR ) );
        if ( pwszConversion == NULL )
        {
            throw E_OUTOFMEMORY;
        }
        
        //  Copy the string to the new string and place a \r in front of any \n.  Also
        //  handle the case if \r\n is already in the string.
        DWORD dwIdx = 0;
        
        while ( wszStr[0] != L'\0' )
        {
            if ( wszStr[0] == L'\r' && wszStr[1] == L'\n' )
            {
                pwszConversion[dwIdx++] = L'\r';
                pwszConversion[dwIdx++] = L'\n';                
                wszStr += 2;
            }
            else if ( wszStr[0] == L'\n' )
            {
                pwszConversion[dwIdx++] = L'\r';
                pwszConversion[dwIdx++] = L'\n';                
                wszStr += 1;                
            }
            else
            {
                pwszConversion[dwIdx++] = wszStr[0];                
                wszStr += 1;
            }
        }
        pwszConversion[dwIdx] = L'\0';
        
        // ---------------- To be removed later - End -----------------

        
        LPSTR pszMultibyteBuffer;
        DWORD dwByteCount;

        //
        //  Get size of temp buffer needed for the conversion.
        //
        dwByteCount = ::WideCharToMultiByte(
                          ::GetConsoleOutputCP(),
                            0,
                            pwszConversion,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL
                            );
        if ( dwByteCount == 0 )
        {
            ::free( pwszConversion );
            throw HRESULT_FROM_WIN32( ::GetLastError() );
        }
        
        pszMultibyteBuffer = ( LPSTR )::malloc( dwByteCount );
        if ( pszMultibyteBuffer == NULL )
        {
            ::free( pwszConversion );
            throw E_OUTOFMEMORY;
        }

        //
        //  Now convert it.
        //
        dwByteCount = ::WideCharToMultiByte(
                        ::GetConsoleOutputCP(),
                        0,
                        pwszConversion,
                        -1,
                        pszMultibyteBuffer,
                        dwByteCount,
                        NULL,
                        NULL
                        );
        ::free( pwszConversion );
        if ( dwByteCount == 0 )
        {
            ::free( pszMultibyteBuffer );
            throw HRESULT_FROM_WIN32( ::GetLastError() );
        }
        
        //  Finally output it.
        if ( !::WriteFile(
                m_hConsoleOutput,
                pszMultibyteBuffer,
                dwByteCount - 1,  // Get rid of the trailing NULL char
                &dwCharsOutput,
                NULL ) )        
    	{
    	    throw HRESULT_FROM_WIN32( ::GetLastError() );
    	}    	

        ::free( pszMultibyteBuffer );
    }
}


LPCWSTR CVssAdminCLI::GetProviderName(
	IN	CVssFunctionTracer& ft,
	IN	VSS_ID& ProviderId
	) throw(HRESULT)
{
	LPCWSTR wszReturnedString = m_mapCachedProviderNames.Lookup(ProviderId);
	if (wszReturnedString)
		return wszReturnedString;

	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
	ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

	CComPtr<IVssEnumObject> pIEnumProvider;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProvider );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Query failed with hr = 0x%08lx", ft.hr);

	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;

	// Go through the list of providers to find the one we are interested in.
	ULONG ulFetched;
	while( 1 )
	{
    	ft.hr = pIEnumProvider->Next( 1, &Prop, &ulFetched );
    	if ( ft.HrFailed() )
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Next failed with hr = 0x%08lx", ft.hr);

    	if (ft.hr == S_FALSE) {
    	    // End of enumeration.
        	// Provider not registered? Where did this snapshot come from?
        	// It might be still possible if a snapshot provider was deleted
        	// before querying the snapshot provider but after the snapshot attributes
        	// were queried.
    		BS_ASSERT(ulFetched == 0);
    		return LoadString( ft, IDS_UNKNOWN_PROVIDER );
    	}
    	
    	if (Prov.m_ProviderId == ProviderId)
    	    break;
	}	

	// Duplicate the new string
	LPWSTR wszNewString = NULL;
	BS_ASSERT(Prov.m_pwszProviderName);
	::VssSafeDuplicateStr( ft, wszNewString, Prov.m_pwszProviderName );
	wszReturnedString = wszNewString;

	// Save the string in the cache
	if (!m_mapCachedProviderNames.Add( ProviderId, wszReturnedString )) {
		::VssFreeString( wszReturnedString );
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	}

	return wszReturnedString;
}


/////////////////////////////////////////////////////////////////////////////
//  Implementation


void CVssAdminCLI::Initialize(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

	Description:

		Initializes the COM library. Called explicitely after instantiating the CVssAdminCLI object.

--*/

{
    // Use the OEM code page ...
    ::setlocale(LC_ALL, ".OCP");

    // Use the console UI language
    ::SetThreadUILanguage( 0 );

    //
    //  Use only the Console routines to output messages.  To do so, need to open standard
    //  output.
    //
    m_hConsoleOutput = ::GetStdHandle(STD_OUTPUT_HANDLE); 
    if (m_hConsoleOutput == INVALID_HANDLE_VALUE) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"Initialize - Error from GetStdHandle(), rc: %d",
				  ::GetLastError() );
    }
    
	// Initialize COM library
	ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Failure in initializing the COM library 0x%08lx", ft.hr);


        // Initialize COM security
    ft.hr = CoInitializeSecurity(
           NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );

	if (ft.HrFailed()) {
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

	// Print the header
	Output( ft, IDS_HEADER );

	// Initialize the command line
	::VssSafeDuplicateStr( ft, m_pwszCmdLine, ::GetCommandLineW() );
}


void CVssAdminCLI::ParseCmdLine(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

	Description:

		Parses the command line.

--*/

{
	// Skip the executable name
	GetNextCmdlineToken( ft, true );

	// Get the first token after the executable name
	LPCWSTR pwszArg1 = GetNextCmdlineToken( ft );

	// Check if this is a list process
	if ( Match( ft, pwszArg1, wszVssOptList)) {

		m_eCommandType = VSS_CMD_LIST;

		// Get the next token after "list"
		LPCWSTR pwszArg2 = GetNextCmdlineToken( ft );

		// Check if this is a list snapshots process
		if ( Match( ft, pwszArg2, wszVssOptSnapshots )) {

			m_eListType = VSS_LIST_SNAPSHOTS;

			// Get the next token after "snapshots"
			LPCWSTR pwszArg3 = GetNextCmdlineToken( ft );

			if ( pwszArg3 == NULL ) {
				m_FilterSnapshotSetId = GUID_NULL;
				m_eFilterObjectType = VSS_OBJECT_NONE;
				return;
			}

			// Check if this is a snapshot set filter
			if ( ::_wcsnicmp( pwszArg3, wszVssOptSet, ::wcslen( wszVssOptSet ) ) == 0 ) {

				// Get the next token after "snapshots"
				LPCWSTR pwszArg4 = pwszArg3 + ::wcslen( wszVssOptSet );

				// Get the snapshot set Id
				if ( (pwszArg4[0] != '\0' ) && ScanGuid( ft, pwszArg4, m_FilterSnapshotSetId ) && (GetNextCmdlineToken(ft) == NULL) ) {
				    
					m_eFilterObjectType = VSS_OBJECT_SNAPSHOT_SET;
					return;
				}
			}

		}

		// Check if this is a list writers process
		if ( Match( ft, pwszArg2, wszVssOptWriters) && (GetNextCmdlineToken(ft) == NULL)) {
			m_eListType = VSS_LIST_WRITERS;
			m_FilterSnapshotSetId = GUID_NULL;
			m_eFilterObjectType = VSS_OBJECT_NONE;
			return;
		}

		// Check if this is a list providers process
		if ( Match( ft, pwszArg2, wszVssOptProviders)&& (GetNextCmdlineToken(ft) == NULL)) {
			m_eListType = VSS_LIST_PROVIDERS;
			m_FilterSnapshotSetId = GUID_NULL;
			m_eFilterObjectType = VSS_OBJECT_NONE;
			return;
		}
	}
	else if (pwszArg1 == NULL)
    	m_nReturnValue = VSS_CMDRET_SUCCESS;
		
	m_eCommandType = VSS_CMD_USAGE;
}


void CVssAdminCLI::DoProcessing(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
	switch( m_eCommandType)
	{
	case VSS_CMD_USAGE:
		PrintUsage(ft);
		break;

	case VSS_CMD_LIST:
		switch (m_eListType)
		{
		case VSS_LIST_SNAPSHOTS:
			ListSnapshots(ft);
			break;

		case VSS_LIST_WRITERS:
			ListWriters(ft);
			break;

		case VSS_LIST_PROVIDERS:
			ListProviders(ft);
			break;
			
		default:
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
					  L"Invalid list type: %d %d",
					  m_eListType, m_eCommandType);
		}
		break;

	default:
		ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Invalid command type: %d", m_eCommandType);
	}
}


void CVssAdminCLI::Finalize()

/*++

	Description:

		Uninitialize the COM library. Called in CVssAdminCLI destructor.

--*/

{
	// Uninitialize COM library
	CoUninitialize();
}


HRESULT CVssAdminCLI::Main(
		IN	HINSTANCE hInstance
		)

/*++

Function:
	
	CVssAdminCLI::Main

Description:

	Static function used as the main entry point in the VSS CLI

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::Main" );
	INT nReturnValue = VSS_CMDRET_ERROR;

    try
    {
		CVssAdminCLI	program(hInstance);

		try
		{
			// Initialize the program. This calls CoInitialize()
			program.Initialize(ft);

			// Parse the command line
			program.ParseCmdLine(ft);

			// Do the work...
			program.DoProcessing(ft);
		}
		VSS_STANDARD_CATCH(ft)

		// Prints the error, if any
		if (ft.HrFailed()) 
			program.Output( ft, IDS_ERROR, ft.hr );

        nReturnValue = program.GetReturnValue();

		// The destructor automatically calls CoUninitialize()
	}
    VSS_STANDARD_CATCH(ft)

	return nReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//  WinMain



extern "C" int WINAPI _tWinMain(
	IN	HINSTANCE hInstance,
    IN	HINSTANCE /*hPrevInstance*/,
	IN	LPTSTR /*lpCmdLine*/,
	IN	int /*nShowCmd*/)
{
    return CVssAdminCLI::Main(hInstance);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\vswriter\vswrtimp.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsWrtImp.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  02/02/2000

TBD:
    
    Add comments.

    Remove the C++ exception-handler related code.

Revision History:

    Name        Date        Comments
    aoltean     02/02/2000  Created
    brianb      03/25/2000  modified to include additional events
    brianb      03/28/2000  modified to include timeouts and sync for OnPrepareBackup
    brianb      03/28/2000  renamed to vswrtimp.cpp to separate internal state from external interface
    brianb      04/19/2000  added security checks
    brianb      05/03/2000  new security model
    brianb      05/09/2000  fix problem with autolocks

--*/


#include <stdafx.hxx>
#include <eventsys.h>
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_idl.hxx"
#include "comadmin.hxx"
#include "vsevent.h"
#include "vswriter.h"
#include "vsbackup.h"
#include "vssmsg.h"

#include "vswrtimp.h"


// xml support
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"



#include "rpcdce.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WRTWRTIC"
//
////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// Constants


const WCHAR g_wszPublisherID[]          = L"VSS Publisher";

// event names
const WCHAR g_wszRequestInfoMethodName[]        = L"RequestWriterInfo";
const WCHAR g_wszPrepareForBackupMethodName[]   = L"PrepareForBackup";
const WCHAR g_wszBackupCompleteMethodName[]     = L"BackupComplete";
const WCHAR g_wszPostRestoreMethodName[]            = L"PostRestore";
const WCHAR g_wszPrepareForSnapshotMethodName[]     = L"PrepareForSnapshot";
const WCHAR g_wszFreezeMethodName[]             = L"Freeze";
const WCHAR g_wszThawMethodName[]               = L"Thaw";
const WCHAR g_wszAbortMethodName[]              = L"Abort";


// List of received volumes is in the following formatDate
// <Volume Name 1>;<Volume Name 2>: ... :<Volume Name N>
const WCHAR VSS_VOLUME_DELIMITERS[] = L";";

// class describing state machine for writer
class CVssWriterImplStateMachine
    {
private:
    // disable default and copy constructors        
    CVssWriterImplStateMachine();

public:
    CVssWriterImplStateMachine
        (
        VSS_WRITER_STATE previousState,
        VSS_WRITER_STATE successfulExitState,
        VSS_WRITER_STATE failureExitState,
        bool bBeginningState,
        bool bSuccessiveState,
        bool bResetSequenceOnLeave
        ) :
        m_previousState(previousState),
        m_successfulExitState(successfulExitState),
        m_failureExitState(failureExitState),
        m_bBeginningState(bBeginningState),
        m_bSuccessiveState(bSuccessiveState),
        m_bResetSequenceOnLeave(bResetSequenceOnLeave)
        {
        }

    // previous state writer must be in to enter the current
    // state unless this is the first state of a sequence
    VSS_WRITER_STATE m_previousState;

    // state we are in if the operation is successful
    VSS_WRITER_STATE m_successfulExitState;

    // state we are in if the operation is uncessful
    VSS_WRITER_STATE m_failureExitState;

    // is this state a possible state for the beginning of the sequence
    bool m_bBeginningState;

    // is this a possible non-beginning state in a sequence
    bool m_bSuccessiveState;

    // should the sequence be reset on successful exit of the state
    bool m_bResetSequenceOnLeave;
    };


// definition of state machine
static CVssWriterImplStateMachine s_rgWriterStates[] =
    {
    // OnPrepareBackup
    CVssWriterImplStateMachine
        (
        VSS_WS_STABLE,                      // previous state
        VSS_WS_STABLE,                      // next state if successful
        VSS_WS_FAILED_AT_PREPARE_BACKUP,    // next state if failure
        true,                               // this can be a first state
        false,                              // this must be a first state
        false                               // do not reset sequence on leaving this state
        ),

    // OnPrepareSnapshot
    CVssWriterImplStateMachine
        (
        VSS_WS_STABLE,                      // previous state
        VSS_WS_WAITING_FOR_FREEZE,          // next state if successful
        VSS_WS_FAILED_AT_PREPARE_SNAPSHOT,  // next state if failure
        true,                               // this can be a first state
        true,                               // this can be a follow on state
        false                               // do not reset sequence on leaving this state
        ),


    // OnFreeze
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_FREEZE,          // previous state
        VSS_WS_WAITING_FOR_THAW,            // next state if successful
        VSS_WS_FAILED_AT_FREEZE,            // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state
        false                               // do not reset sequence on leaving this state
        ),

    // OnThaw
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_THAW,            // previous state
        VSS_WS_WAITING_FOR_BACKUP_COMPLETE,     // next state if successful
        VSS_WS_FAILED_AT_THAW,              // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state   
        true                                // reset sequence on leaving this state
        )

    };

// state ids
static const unsigned s_ivwsmPrepareForBackup = 0;
static const unsigned s_ivwsmPrepareForSnapshot = 1;
static const unsigned s_ivwsmFreeze = 2;
static const unsigned s_ivwsmThaw = 3;




/////////////////////////////////////////////////////////////////////////////
// CVssWriterImpl constructors/destructors


// constructor
CVssWriterImpl::CVssWriterImpl():
    m_WriterID(GUID_NULL),
    m_InstanceID(GUID_NULL),
    m_usage(VSS_UT_UNDEFINED),
    m_source(VSS_ST_UNDEFINED),
    m_nLevel(VSS_APP_FRONT_END),
    m_dwTimeoutFreeze(VSS_TIMEOUT_FREEZE),
    m_CurrentSnapshotSetId(GUID_NULL),
    m_bSequenceInProgress(false),
    m_nVolumesCount(0),
    m_ppwszVolumesArray(NULL),
    m_pwszLocalVolumeNameList(NULL),
    m_dwEventMask(0),
    m_wszWriterName(NULL),
    m_state(VSS_WS_STABLE),
    m_hevtTimerThread(NULL),
    m_hmtxTimerThread(NULL),
    m_hThreadTimerThread(NULL),
    m_bLocked(false),
    m_bLockCreated(false),
    m_command(VSS_TC_UNDEFINED),
    m_iPreviousSnapshots(0),
    m_cbstrSubscriptionId(0),
    m_bOnAbortPermitted(false),
    m_bFailedAtIdentify(false),
    m_hrWriterFailure(S_OK)
    {
    for(UINT i = 0; i < MAX_PREVIOUS_SNAPSHOTS; i++)
        {
        m_rgidPreviousSnapshots[i] = GUID_NULL;
        m_rgstatePreviousSnapshots[i] = VSS_WS_UNKNOWN;
        m_rghrWriterFailurePreviousSnapshots[i] = E_UNEXPECTED;
        }
    }

// destructor
CVssWriterImpl::~CVssWriterImpl()
    {
    // terminate timer thread if it is still running
    if (m_bLockCreated)
        {
        Lock();
        TerminateTimerThread();
        Unlock();
        }

    // delete volume array
    delete[] m_ppwszVolumesArray;

    // delete volume list string
    ::VssFreeString(m_pwszLocalVolumeNameList);
    

    // delete writer name
    free(m_wszWriterName);


    if (m_hevtTimerThread)
        CloseHandle(m_hevtTimerThread);

    if (m_hmtxTimerThread)
        CloseHandle(m_hmtxTimerThread);
    }


// create an event
void CVssWriterImpl::SetupEvent(IN HANDLE *phevt)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImple::SetupEvent");

    BS_ASSERT(phevt);
    // setup events as enabled and manual reset
    *phevt = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (*phevt == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failure to create event object due to error %d.",
            GetLastError()
            );
    }

const WCHAR SETUP_KEY[] = L"SYSTEM\\Setup";

const WCHAR SETUP_INPROGRESS_REG[]  = L"SystemSetupInProgress";

const WCHAR UPGRADE_INPROGRESS_REG[] = L"UpgradeInProgress";


// initialize writer object
void CVssWriterImpl::Initialize
    (
    IN VSS_ID WriterID,             // writer class id
    IN LPCWSTR wszWriterName,       // friendly name of writer  
    IN VSS_USAGE_TYPE usage,        // usage type   
    IN VSS_SOURCE_TYPE source,      // data source type
    IN VSS_APPLICATION_LEVEL nLevel, // which freeze event this writer handles
    IN DWORD dwTimeoutFreeze         // timeout between freeze and thaw
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Initialize");

        {
        // determine if we are in setup.  If we are then reject the
        // initialize call and log an error in the application log
        CRegKey cRegKeySetup;
        DWORD dwRes;
        bool fInSetup = false;

        dwRes = cRegKeySetup.Create(HKEY_LOCAL_MACHINE, SETUP_KEY);
        if (dwRes == ERROR_SUCCESS)
            {
            DWORD dwValue;
            dwRes = cRegKeySetup.QueryValue(dwValue, SETUP_INPROGRESS_REG);
            if (dwRes == ERROR_SUCCESS && dwValue > 0)
                fInSetup = true;
            dwRes = cRegKeySetup.QueryValue(dwValue, UPGRADE_INPROGRESS_REG);
            if (dwRes == ERROR_SUCCESS && dwValue > 0)
                fInSetup = true;
            }

        if (fInSetup)
            ft.Throw(VSSDBG_WRITER, VSS_E_BAD_STATE, L"Calling Initialize during setup");
        }

    // Testing arguments validity
    if (wszWriterName == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_INVALIDARG,
            L"NULL writer name"
            );
    
    switch(nLevel) {
    case VSS_APP_SYSTEM:
    case VSS_APP_BACK_END:
    case VSS_APP_FRONT_END:
        break;
    default:
        ft.Throw
            (
            VSSDBG_WRITER,
            E_INVALIDARG,
            L"Invalid app level %d", nLevel
            );
    }

    m_cs.Init();  // Warning - may throw NT exceptions...
    m_bLockCreated = true;

    // save writer class id
    m_WriterID = WriterID;

    // save writer name
    m_wszWriterName = _wcsdup(wszWriterName);
    if (m_wszWriterName == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot allocate writer name"
            );

    // save usage type
    m_usage = usage;

    // save source type
    m_source = source;

    // create guid for this instance
    ft.hr = ::CoCreateGuid(&m_InstanceID);
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateGuid");
    ft.Trace
        (
        VSSDBG_WRITER,
        L"     InstanceId for Writer %s is" WSTR_GUID_FMT,
        m_wszWriterName,
        GUID_PRINTF_ARG(m_InstanceID)
        );

    // save app level
    m_nLevel = nLevel;

    // save timeout
    m_dwTimeoutFreeze = dwTimeoutFreeze;

    // setup thread mutex
    m_hmtxTimerThread = CreateMutex(NULL, FALSE, NULL);
    if (m_hmtxTimerThread == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failure to create mutex object due to error %d.",
            GetLastError()
            );

    // setup event used to control the timer thread
    SetupEvent(&m_hevtTimerThread);
    }


// start a sequence
// critical section (m_cs) must be locked upone entry to this routine
void CVssWriterImpl::BeginSequence
    (
    IN CVssID &SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::BeginSequence");

    AssertLocked();

    // terminate timer thread if it is still operating
    TerminateTimerThread();

    // setup current snapshot set id
    m_CurrentSnapshotSetId = SnapshotSetId;

    // indicate that sequence is in progress
    m_bSequenceInProgress = true;
    
    BS_ASSERT(m_bOnAbortPermitted == false);

    // current state is STABLE (i.e., beginning of sequence, clears
    // any completion state we were in)
    m_state = VSS_WS_STABLE;

    // indicate that there is no failure
    m_hrWriterFailure = S_OK;
    }



INT CVssWriterImpl::SearchForPreviousSequence(
    IN  VSS_ID& idSnapshotSet
    )
    {
    for(INT iSeqIndex = 0;
        iSeqIndex < MAX_PREVIOUS_SNAPSHOTS;
        iSeqIndex++)
        {
        if (idSnapshotSet == m_rgidPreviousSnapshots[iSeqIndex])
            return iSeqIndex;
        } // end for
        
    return INVALID_SEQUENCE_INDEX;
    }


//  Reset the sequence-related data members
// critical section must be locked prior to entering this state
void CVssWriterImpl::ResetSequence(bool bCalledFromTimerThread)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::ResetSequence");

    AssertLocked();

    if (m_bSequenceInProgress)
        {
        // We need to test to not add the same SSID twice - bug 228622.
        if (SearchForPreviousSequence(m_CurrentSnapshotSetId) == INVALID_SEQUENCE_INDEX)
            {
            BS_ASSERT(m_iPreviousSnapshots < MAX_PREVIOUS_SNAPSHOTS);
            m_rgidPreviousSnapshots[m_iPreviousSnapshots] = m_CurrentSnapshotSetId;
            m_rgstatePreviousSnapshots[m_iPreviousSnapshots] = m_state;
            m_rghrWriterFailurePreviousSnapshots[m_iPreviousSnapshots] = m_hrWriterFailure;
            m_iPreviousSnapshots = (m_iPreviousSnapshots + 1) % MAX_PREVIOUS_SNAPSHOTS;
            }
        else
            BS_ASSERT(false); // The same SSID was already added - programming error.
        }

    // Reset the sequence-related data members
    m_bSequenceInProgress = false;
    
    m_bOnAbortPermitted = false;

    // reset writer callback function
    m_pWriterCallback = NULL;

    // reset volumes array
    m_nVolumesCount = 0;
    delete[] m_ppwszVolumesArray;
    m_ppwszVolumesArray = NULL;

    ::VssFreeString(m_pwszLocalVolumeNameList);
    
    m_CurrentSnapshotSetId = GUID_NULL;

    // if bCalledFromTimerThread is true, this means that the timer
    // thread is causing the sequence to be reset.  We are in the timer
    // thread already and it will terminate upon completion of this call
    // so we shouldn't try causing it to terminate again.
    if (!bCalledFromTimerThread)
        TerminateTimerThread();

    }

// indicate why the writer failed
HRESULT CVssWriterImpl::SetWriterFailure(HRESULT hr)
    {
    if (hr != VSS_E_WRITERERROR_TIMEOUT &&
        hr != VSS_E_WRITERERROR_RETRYABLE &&
        hr != VSS_E_WRITERERROR_NONRETRYABLE &&
        hr != VSS_E_WRITERERROR_OUTOFRESOURCES &&
        hr != VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT)
        return E_INVALIDARG;

    m_hrWriterFailure = hr;
    return S_OK;
    }



// determine if path specified is on one of the volumes that is snapshot
bool CVssWriterImpl::IsPathAffected
    (
    IN  LPCWSTR wszPath
    ) const
    {
    // Test the status
    if (!m_bSequenceInProgress)
        return false;

    // check for empty volume count
    if (m_nVolumesCount == 0)
        return false;

    // Get the volume mount point
    WCHAR wszVolumeMP[MAX_PATH];
    BOOL bRes = ::GetVolumePathNameW(wszPath, wszVolumeMP, MAX_PATH);
    if (!bRes)
        return false;

    // Get the volume name
    WCHAR wszVolumeName[MAX_PATH];
    bRes = ::GetVolumeNameForVolumeMountPointW(wszVolumeMP, wszVolumeName, MAX_PATH);
    if (!bRes)
        return false;

    // Search to see if that volume is within snapshotted volumes
    for (int nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
        {
        BS_ASSERT(m_ppwszVolumesArray[nIndex]);
        if (::wcscmp(wszVolumeName, m_ppwszVolumesArray[nIndex]) == 0)
            return true;
        }

    return false;
    }


// obtain IVssWriterCallback from IDispatch pointer
// caller is responsible for releasing interface that is returned
void CVssWriterImpl::GetCallback
    (
    IN IDispatch *pWriterCallback,
    OUT IVssWriterCallback **ppCallback
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::GetCallback");

    // check that pointer is supplied
    BS_ASSERT(pWriterCallback != NULL);

    ft.hr = CoSetProxyBlanket
                (
                pWriterCallback,
                RPC_C_AUTHN_DEFAULT,
                RPC_C_AUTHZ_DEFAULT,
                NULL,
                RPC_C_AUTHN_LEVEL_CONNECT,
                RPC_C_IMP_LEVEL_IDENTIFY,
                NULL,
                EOAC_NONE
                );

    // note E_NOINTERFACE means that the pWriterCallback is a in-proc callback
    // and there is no proxy
    if (FAILED(ft.hr) && ft.hr != E_NOINTERFACE)
        {
        if (m_hrWriterFailure == S_OK)
            m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;

        ft.LogError(VSS_ERROR_BLANKET_FAILED, VSSDBG_WRITER << ft.hr);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Call to CoSetProxyBlanket failed.  hr = 0x%08lx", ft.hr
            );
        }


    // try QueryInterface for IVssWriterCallback interface
    ft.hr = pWriterCallback->SafeQI(IVssWriterCallback, ppCallback);
    if (FAILED(ft.hr))
        {
        if (m_hrWriterFailure == S_OK)
            m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;

        ft.LogError(VSS_ERROR_QI_IVSSWRITERCALLBACK, VSSDBG_WRITER << ft.hr);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Error querying for IVssWriterCallback interface.  hr = 0x%08lx",
            ft.hr
            );
        }
    }

// create basic writer metadata for OnIdentify method
CVssCreateWriterMetadata *CVssWriterImpl::CreateBasicWriterMetadata()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CreateBasicWriterMetadata");

    // create object supporting IVssCreateMetadata interface
    CVssCreateWriterMetadata *pMetadata = new CVssCreateWriterMetadata;
    if (pMetadata == NULL)
        {
        m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot create CVssCreateWriterMetadata due to allocation failure."
            );
        }


    // call initialize to create IDENTIFICATION section
    ft.hr = pMetadata->Initialize
                    (
                    m_InstanceID,
                    m_WriterID,
                    m_wszWriterName,
                    m_usage,
                    m_source
                    );

    if (ft.HrFailed())
        {
        m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
        delete pMetadata;
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"CVssCreateWriterMetadata::Initialize failed. hr = 0x%08lx",
            ft.hr
            );
        }


    // return object
    return pMetadata;
    }

static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementWriterComponents = L"WRITER_COMPONENTS";

// get writer components for OnPrepareBackup, OnBackupComplete, and OnPostRestore
// methods
void CVssWriterImpl::InternalGetWriterComponents
    (
    IN IVssWriterCallback *pCallback,
    OUT IVssWriterComponentsInt **ppWriter,
    bool bWriteable
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::InternalGetWriterComponents");

    BS_ASSERT(pCallback);
    BS_ASSERT(ppWriter);

    *ppWriter = NULL;

    // call GetContent callback method on the backup application
    CComBSTR bstrId(m_InstanceID);
    if (!bstrId)
        {
        m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot allocate instance Id string"
            );
        }

    try
        {
        BOOL bPartialFileSupport;

        ft.hr = pCallback->GetBackupState
            (
            &m_bComponentsSelected,
            &m_bBootableSystemStateBackup,
            &m_backupType,
            &bPartialFileSupport
            );
        }
    catch(...)
        {
        ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::GetBackupState threw an exception.");
        throw;
        }

    if (ft.HrFailed())
        {
        m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"IVssWriterCallback::GetBackupState failed.  hr = 0x%08lx",
            ft.hr
            );
        }


    CComBSTR bstrWriterComponentsDoc;
    try
        {
        ft.hr = pCallback->GetContent(bstrId, &bstrWriterComponentsDoc);
        }
    catch(...)
        {
        m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
        ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::GetContent threw an exception.");
        throw;
        }

    if (ft.HrFailed())
        {
        m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"Cannot get WRITER_COMPONENTS document.  hr = 0x%08lx",
            ft.hr
            );
        }

    if (ft.hr == S_FALSE)
        {
        // reset status code
        ft.hr = S_OK;

        // allocate null writer components object
        *ppWriter = (IVssWriterComponentsInt *) new CVssNULLWriterComponents
                                (
                                m_InstanceID,
                                m_WriterID
                                );

        if (*ppWriter == NULL)
            {
            // indicate that the writer failed due to an out of resources condition
            m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            ft.Throw (VSSDBG_WRITER, E_OUTOFMEMORY, L"Can't allocate CVssWriterComponents object");
            }

        (*ppWriter)->AddRef();
        }
    else
        {
        CXMLDocument doc;
        if (!doc.LoadFromXML(bstrWriterComponentsDoc) ||
            !doc.FindElement(x_wszElementRoot, true))
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;
            ft.LogError(VSS_ERROR_WRITER_COMPONENTS_CORRUPT, VSSDBG_WRITER);
            ft.Throw
                (
                VSSDBG_WRITER,
                VSS_E_CORRUPT_XML_DOCUMENT,
                L"Internally transferred WRITER_COMPONENTS document is invalid"
                );
            }

        doc.SetToplevel();

        *ppWriter = (IVssWriterComponentsInt *)
                        new CVssWriterComponents
                            (
                            doc.GetCurrentNode(),
                            doc.GetInterface(),
                            bWriteable
                            );

        if (*ppWriter == NULL)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            ft.Throw (VSSDBG_WRITER, E_OUTOFMEMORY, L"Can't allocate CVssWriterComponents object");
            }

        (*ppWriter)->AddRef();
        ft.hr = (*ppWriter)->Initialize(true);
        if (ft.HrFailed())
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            (*ppWriter)->Release();
            *ppWriter = NULL;
            ft.Throw
                (
                VSSDBG_WRITER,
                ft.hr,
                L"Failed to initialize WRITER_COMPONENTS document.  hr = 0x%08lx",
                ft.hr
                );
            }
        }
    }
    

// called when entering a state to verify whether this state can be
// validly entered and generate appropriate error if not.
// this routine always obtains the critical section.  If this routine
// is called then LeaveState must also be called in order to free the
// critical section.
bool CVssWriterImpl::EnterState
    (
    IN const CVssWriterImplStateMachine &vwsm,
    IN BSTR bstrSnapshotSetId
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::EnterState");

    CVssID id;

    // obtain lock just in case next call throws
    // no matter how this routine exits, the critical section must be locked
    Lock();

    // initialize id to snapshot set id
    id.Initialize(ft, (LPWSTR)bstrSnapshotSetId, E_OUTOFMEMORY);

    // If failed on Identify then we cannot enter in a new state until
    // subsequent Identify calls will succeed
    if (m_bFailedAtIdentify)
        return false;

    if (!m_bSequenceInProgress)
        {
        if (!vwsm.m_bBeginningState)
            // not a beginning state.  Sequence must have been
            // interrupted.
            return false;
        else
            {
            // BUG 219757 - PrepareForSnapshot, etc. cannot be
            // called for the same Snapshot Set if PrepareForBackup failed
            // Also we assume here that each new sequence have an UNIQUE SSID.

            // This check is needed since the PrepareForBackup phase is optional
            // and can be skipped sometimes. Therefore we need to distinguish between
            // the case when PrepareForBackup was skipped and the case when PrepareForBackup
            // was called and failed.

            // Search for a previous sequence with the same Snapshot Set ID.
            // If found (this means that a PrepareForBackup was called),
            // then reject the call.
            if (SearchForPreviousSequence(id) != INVALID_SEQUENCE_INDEX)
                return false;
            
            // it is a beginning state, start the sequence
            BeginSequence(id);
            return true;
            }
        }
    else
        {
        if (vwsm.m_bSuccessiveState)
            {
            // it is a valid non-beginning state in the sequence
            if (id != m_CurrentSnapshotSetId)
                {
                // if snapshot set id doesn't match and this is not
                // a beginning state, then the event must be ignored.
                // We must have aborted the sequence it references.
                if (!vwsm.m_bBeginningState)
                    return false;
                }
            else
                {
                // make sure current state matches previous state
                // of state we are about to enter
                return m_state == vwsm.m_previousState;
                }
            }
        }

    // We are trying to start a new sequence.
    // This means that the previous sequence was not properly
    // terminated.  Abort the previous sequence and then
    // start a new one.
    ft.Trace(VSSDBG_WRITER,
        L"*** Warning ***: Writer %s with ID "WSTR_GUID_FMT
        L"attempts to reset the previous sequence with Snapshot Set ID "WSTR_GUID_FMT
        L". Current state = %d",
        m_wszWriterName, GUID_PRINTF_ARG(m_InstanceID), GUID_PRINTF_ARG(m_CurrentSnapshotSetId), (INT)m_state);
    DoAbort(false);
    BeginSequence(id);
    return true;
    }

// do abort on failure of the sequence
// critical section must be locked prior to entering this state
void CVssWriterImpl::DoAbort
    (
    IN bool bCalledFromTimerThread
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::DoAbort");

    AssertLocked();
    // do nothing if in a sequence
    if (!m_bSequenceInProgress)
        return;

    // catch any exceptions so that we properly reset the
    // sequence
    BS_ASSERT(m_pWriter);
    try
        {
        // call writer's abort function (depending on the state)
        switch(m_state)
            {
            default:
                BS_ASSERT(m_bOnAbortPermitted == false);
                break;
            case VSS_WS_STABLE:
                // This is possible since you may get an Abort
                // in (or after) PrepareForBackup (BUG # 301686)
                BS_ASSERT(m_bOnAbortPermitted == true);
                break;
            case VSS_WS_WAITING_FOR_FREEZE:
            case VSS_WS_WAITING_FOR_THAW:
            case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            case VSS_WS_FAILED_AT_PREPARE_BACKUP:
            case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
            case VSS_WS_FAILED_AT_FREEZE:
                // Fixing bug 225936
                if (m_bOnAbortPermitted)
                    m_pWriter->OnAbort();
                else
                    ft.Trace(VSSDBG_WRITER, L"Abort skipped in state %d", m_state);
                m_bOnAbortPermitted = false;
                break;
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Trace
            (
            VSSDBG_WRITER,
            L"OnAbort failed. hr = 0x%08lx",
            ft.hr
            );

    // set appropriate failure state
    switch(m_state)
        {
        default:
            m_state = VSS_WS_UNKNOWN;
            BS_ASSERT(false);
            break;

        // This state is not really kept in the m_state member
        case VSS_WS_FAILED_AT_IDENTIFY:
            BS_ASSERT(false);
            break;

        case VSS_WS_FAILED_AT_PREPARE_BACKUP:
        case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
        case VSS_WS_FAILED_AT_FREEZE:
        case VSS_WS_FAILED_AT_THAW:
            // don't change state if already in a failure state
            break;

        case VSS_WS_STABLE:
            // if current state is STABLE then it means
            // we were in PrepareBackup
            m_state = VSS_WS_FAILED_AT_PREPARE_BACKUP;
            break;

        case VSS_WS_WAITING_FOR_FREEZE:
            // if we were waiting for freeze then we failed
            // between PrepareSync and Freeze
            m_state = VSS_WS_FAILED_AT_PREPARE_SNAPSHOT;
            break;

        case VSS_WS_WAITING_FOR_THAW:
            // if we were waiting for thaw then we failed
            // between freeze and thaw
            m_state = VSS_WS_FAILED_AT_FREEZE;
            break;

        case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            // if we were waiting for completion then
            // we failed after thaw.
            m_state = VSS_WS_FAILED_AT_THAW;
            break;
        }

    if (bCalledFromTimerThread && m_hrWriterFailure == S_OK)
        m_hrWriterFailure = VSS_E_WRITERERROR_TIMEOUT;

    // reset sequence
    ResetSequence(bCalledFromTimerThread);
    }

// exit a state.  This routine must be called with the critical
// section acquired.  For a state, EnterState is called first, then work is
// done, then LeaveState is called.  This routine will set the state upon
// exit and possibly reset the snapshot sequence if we are at the end of the
// sequence or the sequence is aborted.
void CVssWriterImpl::LeaveState
    (
    IN const CVssWriterImplStateMachine &vwsm,  // current state
    IN bool bSucceeded                          // did operation succeed
    )
    {
    AssertLocked();
    // don't change state or call abort if we are not in a sequence
    if (m_bSequenceInProgress)
        {
        m_state = bSucceeded ? vwsm.m_successfulExitState
                             : vwsm.m_failureExitState;

        // call abort on failure when we are not in the exit state
        if (!bSucceeded && !vwsm.m_bResetSequenceOnLeave)
            DoAbort(false);
        else if (vwsm.m_bResetSequenceOnLeave)
            // if sequence ends at this state (THAW) then
            // reset variables
            ResetSequence(false);
        }

    Unlock();
    }
            


// arguments to timer function
class CVssTimerArgs
    {
private:
    CVssTimerArgs();

public:
    CVssTimerArgs(CVssWriterImpl *pWriter, VSS_ID id) :
        m_snapshotSetId(id),
        m_pWriter(pWriter)
        {
        }

    // snapshot set that we are monitoring
    VSS_ID m_snapshotSetId;

    // pointer to writer
    CVssWriterImpl *m_pWriter;
    };


// timer thread startup routine
DWORD CVssWriterImpl::StartTimerThread(void *pv)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::StartTimerThread");
    CVssTimerArgs *pArgs = (CVssTimerArgs *) pv;
    BS_ASSERT(pArgs);
    BS_ASSERT(pArgs->m_pWriter);

    bool bCoInitializeSucceeded = false;
    try
        {
        // coinitialize thread

        ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (ft.HrFailed())
            {
            pArgs->m_pWriter->m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            ft.TranslateError
                (
                VSSDBG_WRITER,
                ft.hr,
                L"CoInitializeEx"
                );
            }

        bCoInitializeSucceeded = true;
        // call timer func
        pArgs->m_pWriter->TimerFunc(pArgs->m_snapshotSetId);
        }
    VSS_STANDARD_CATCH(ft)

    if (bCoInitializeSucceeded)
        CoUninitialize();

    // delete timer arguments
    delete pArgs;
    return 0;
    }



// function implementing timer functionality
void CVssWriterImpl::TimerFunc(VSS_ID snapshotSetId)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::TimerFunc");

    // wait on event to insure that only one timer is active at
    // any point in time
    if (WaitForSingleObject(m_hmtxTimerThread, INFINITE) == WAIT_FAILED)
        {
        DWORD dwErr = GetLastError();
        ft.Trace(VSSDBG_WRITER, L"WaitForSingleObject failed with error %d", dwErr);
        BS_ASSERT(FALSE && "WaitForSingleObject failed");
        }

    // reset timer event
    if (!ResetEvent(m_hevtTimerThread))
        {
        DWORD dwErr = GetLastError();
        ft.Trace(VSSDBG_WRITER, L"ResetEvent failed with error %d", dwErr);
        BS_ASSERT(FALSE && "ResetEvent failed");
        }

    Lock();
    // make sure that we are still in a snapshot sequence
    if (!m_bSequenceInProgress || snapshotSetId != GetCurrentSnapshotSetId())
        {
        // not in sequence, exit function
        Unlock();
        // allow another timer thread to start
        ReleaseMutex(m_hmtxTimerThread);
        return;
        }

    // initial command is to abort the current sequence on timeout
    m_command = VSS_TC_ABORT_CURRENT_SEQUENCE;

    Unlock();
    DWORD dwTimeout = m_dwTimeoutFreeze;

    if (WaitForSingleObject(m_hevtTimerThread, dwTimeout) == WAIT_FAILED)
        {
        ft.Trace
            (
            VSSDBG_WRITER,
            L"Wait in timer thread failed due to reason %d.",
            GetLastError()
            );

        // allow another thread to start
        ReleaseMutex(m_hmtxTimerThread);
        return;
        }

    CVssWriterImplLock lock(this);
    if (m_command != VSS_TC_TERMINATE_THREAD)
        {
        BS_ASSERT(m_command == VSS_TC_ABORT_CURRENT_SEQUENCE);

        // cause current sequence to abort
        ft.Trace(VSSDBG_WRITER, L"Aborting due to timeout\n");
        DoAbort(true);
        }

    // allow another timer thread to start
    ReleaseMutex(m_hmtxTimerThread);
    }



/////////////////////////////////////////////////////////////////////////////
// IVssWriter implementation


STDMETHODIMP CVssWriterImpl::RequestWriterInfo
    (
    IN      BSTR bstrSnapshotSetId,
    IN      BOOL bWriterMetadata,
    IN      BOOL bWriterState,
    IN      IDispatch* pWriterCallback      
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::RequestWriterInfo" );


    // created metadata, deleted on exit from routine
    CVssCreateWriterMetadata *pcwm = NULL;
    try
        {
        // validate that the flags make sense
        if (bWriterMetadata && bWriterState ||
            !bWriterMetadata && !bWriterState)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"Incorrect flags");

        // if we are requesting writer state then we must have a snapshot
        // set id
        if (bWriterState && bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        if (!IsBackupOperator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");

	 // MTA synchronization: The critical section will be left automatically at the end of scope.
	 CVssWriterImplLock lock(this);
	    
        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);

        if (bWriterMetadata)
            {
            // BUG 219757: The identify phase marked as failed
            m_bFailedAtIdentify = true;
            
            // obtain writer metadata

            // create basic metadata using initialization parameters
            pcwm = CreateBasicWriterMetadata();

            // call writer's OnIdentify method to get more metadata
            BS_ASSERT(m_pWriter);
            bool bSucceeded;
            try
                {
                bSucceeded = m_pWriter->OnIdentify
                                    (
                                    (IVssCreateWriterMetadata *) pcwm
                                    );
                }
            catch(...)
                {
                ft.Trace(VSSDBG_WRITER, L"Writer's OnIdentify method threw and exception.");
                throw;
                }

            if (!bSucceeded)
                {
                // indicate failure if writer fails OnIdentify
                ft.Throw(VSSDBG_WRITER, S_FALSE, L"Writer's OnIdentify method returned false.");
                }

            CComBSTR bstrXML;
            CComBSTR bstrInstanceId(m_InstanceID);
            CComBSTR bstrWriterId(m_WriterID);
            CComBSTR bstrWriterName(m_wszWriterName);
            if (!bstrInstanceId ||
                !bstrWriterId ||
                !bstrWriterName)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate memory for ids or name");

            // save WRITER_METADATA document as XML string
            ft.hr = pcwm->SaveAsXML(&bstrXML);
            if (FAILED(ft.hr))
                ft.Throw
                    (
                    VSSDBG_WRITER,
                    E_OUTOFMEMORY,
                    L"Cannot save XML document as string. hr = 0x%08lx",
                    ft.hr
                    );

            // callback through ExposeWriterMetadata method
            try
                {
                ft.hr = pCallback->ExposeWriterMetadata
                            (
                            bstrInstanceId,
                            bstrWriterId,
                            bstrWriterName,
                            bstrXML
                            );
                }
            catch(...)
                {
                ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::ExposeWriterMetadata threw an exception.");
                throw;
                }
            
            // BUG 219757: The identify phase marked as succeeded.
            m_bFailedAtIdentify = false;
        
            }
        else
            {
            // get writer state

            CComBSTR bstrInstanceId(m_InstanceID);
            if (!bstrInstanceId)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate memory for ids or name");

            CVssID id;
            id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);

            VSS_WRITER_STATE state;
            HRESULT hrWriterFailure;

            // BUG 219757 - deal with the Identify failures correctly.
            if (m_bFailedAtIdentify)
                {
                state = VSS_WS_FAILED_AT_IDENTIFY;
                hrWriterFailure = m_hrWriterFailure;
                }
            else
                {
                if (id == GUID_NULL ||
                    (m_bSequenceInProgress && id == m_CurrentSnapshotSetId))
                    {
                    state = m_state;
                    hrWriterFailure = m_hrWriterFailure;
                    }
                else
                    {
                    // Search for the previous sequence with the same ID
                    INT nPreviousSequence = SearchForPreviousSequence(id);
                    if (nPreviousSequence == INVALID_SEQUENCE_INDEX)
                        {
                        state = VSS_WS_UNKNOWN;
                        hrWriterFailure = E_UNEXPECTED;
                        }
                    else
                        {
                        BS_ASSERT(m_rgidPreviousSnapshots[nPreviousSequence] == id);
                        state = m_rgstatePreviousSnapshots[nPreviousSequence];
                        hrWriterFailure = m_rghrWriterFailurePreviousSnapshots[nPreviousSequence];
                        }
                    }
                }

            // call Backup's ExposeCurrentState callback method
            try
                {
                ft.hr = pCallback->ExposeCurrentState
                                (
                                bstrInstanceId,
                                state,
                                hrWriterFailure
                                );
                }
            catch(...)
                {
                ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::ExposeCurrentState threw an exception");
                throw;
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    delete pcwm;

    // Bug 255996
    return S_OK;
    }


// process PrepareForBackup event
STDMETHODIMP CVssWriterImpl::PrepareForBackup
    (
    IN      BSTR bstrSnapshotSetId,                 
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PrepareForBackup" );

    bool EnterStateCalled = false;
    try
        {
        // access check
        if (!IsBackupOperator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");

        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PrepareForBackup\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        
        // enter PrepareForBackup state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPrepareForBackup],
                bstrSnapshotSetId
                ))
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't properly begin sequence"
                );
            }


        AssertLocked();
        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);

        // get IVssWriterComponentsExt interface
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, true);

        BS_ASSERT(m_pWriter);

        // call writer's OnPrepareBackup method
        bool bResult;
        try
            {
            bResult = m_pWriter->OnPrepareBackup(pComponents);
            BS_ASSERT(m_bOnAbortPermitted == false);
            m_bOnAbortPermitted = true;
            }
        catch(...)
            {
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPrepareBackup method threw an exception");
            if (m_hrWriterFailure == S_OK)
                m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;

            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the prepare");

        // save changes to components if any
        if (pComponents)
            {
            bool bChanged;

            // determine if components are changed
            ft.hr = pComponents->IsChanged(&bChanged);
            BS_ASSERT(ft.hr == S_OK);
            if (bChanged)
                {
                // get instance id
                CComBSTR bstrWriterInstanceId(m_InstanceID);
                if (!bstrWriterInstanceId)
                    ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate instance id string");

                // get WRITER_COMPONENTS XML document
                CComBSTR bstrWriterComponentsDocument;
                ft.hr = pComponents->SaveAsXML(&bstrWriterComponentsDocument);
                if (ft.HrFailed())
                    {
                    m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
                    ft.Throw
                        (
                        VSSDBG_WRITER,
                        E_OUTOFMEMORY,
                        L"Saving WRITER_COMPONENTS document as XML failed.  hr = 0x%08lx",
                        ft.hr
                        );
                    }

                // callback to set component in BACKUP_COMPONENTS document
                try
                    {
                    ft.hr = pCallback->SetContent(bstrWriterInstanceId, bstrWriterComponentsDocument);
                    }
                catch(...)
                    {
                    m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
                    ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::SetContent threw an exception.");
                    throw;
                    }

                if (ft.HrFailed())
                    {
                    m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
                    ft.Throw
                        (
                        VSSDBG_WRITER,
                        ft.hr,
                        L"IVssWriterCallback::SetContent failed.  hr = 0x%08lx",
                        ft.hr
                        );
                    }
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    // leave PrepareBackup state
    if (EnterStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmPrepareForBackup], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }



// process PrepareForSnapshot event
STDMETHODIMP CVssWriterImpl::PrepareForSnapshot
    (
    IN  BSTR    bstrSnapshotSetId,          // snapshot set id
    IN  BSTR    bstrVolumeNamesList         // list of volume names separated by ';'
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PrepareForSnapshot" );

    bool EnterStateCalled = false;
    try
        {
        // should only be called by coordinator
        // check for admin privileges
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");
        
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PrepareForSnapshot\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        ft.Trace(VSSDBG_WRITER, L"\tVolumeNamesList = %s\n", (LPWSTR)bstrVolumeNamesList);

        // enter PrepareForSnapshot state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPrepareForSnapshot],
                bstrSnapshotSetId
                ))
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"improper state transition"
                );
            }

        AssertLocked();
        // Get the array of volume names
        BS_ASSERT(m_pwszLocalVolumeNameList == NULL);
        ::VssSafeDuplicateStr(ft, m_pwszLocalVolumeNameList, (LPWSTR)bstrVolumeNamesList);

        // Get the number of volumes
        BS_ASSERT(m_nVolumesCount == 0);
        m_nVolumesCount = 0; // For safety
        LPWSTR pwszVolumesToBeParsed = m_pwszLocalVolumeNameList;

        // parse volume name string
        while(true)
            {
            // get pointer to next volume
            WCHAR* pwszNextVolume = ::wcstok(pwszVolumesToBeParsed, VSS_VOLUME_DELIMITERS);
            pwszVolumesToBeParsed = NULL;

            if (pwszNextVolume == NULL)
                // no more volumes
                break;

            // skip if volume name is empty
            if (pwszNextVolume[0] == L'\0')
                continue;

            // count of volumes
            m_nVolumesCount++;
            }

        // make sure there is at least one volume
        if (m_nVolumesCount == 0)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.LogError(VSS_ERROR_EMPTY_SNAPSHOT_SET, VSSDBG_WRITER);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"No volumes in the snapshot set"
                );
            }
    
        // Allocate the array of pointers to volume names
        BS_ASSERT(m_nVolumesCount > 0);
        BS_ASSERT(m_ppwszVolumesArray == NULL);
        m_ppwszVolumesArray = new LPWSTR[m_nVolumesCount];
        if (m_ppwszVolumesArray == NULL)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            ft.Throw( VSSDBG_WRITER, E_OUTOFMEMORY, L"Memory allocation error");
            }

        //
        // Copy the volume names into the array.
        //

        // re-copy the whole volume list
        ::wcscpy(m_pwszLocalVolumeNameList, (LPWSTR)bstrVolumeNamesList);

        // Fill the array by re-parsing the volume list.
        INT nVolumesIndex = 0;
        pwszVolumesToBeParsed = m_pwszLocalVolumeNameList;
        while(true)
            {
            WCHAR* pwszNextVolume = ::wcstok(pwszVolumesToBeParsed, VSS_VOLUME_DELIMITERS);
            pwszVolumesToBeParsed = NULL;

            if (pwszNextVolume == NULL)
                break;

            if (pwszNextVolume[0] == L'\0')
                continue;

            BS_ASSERT(nVolumesIndex < m_nVolumesCount);
            m_ppwszVolumesArray[nVolumesIndex] = pwszNextVolume;
            
            nVolumesIndex++;
            }

        BS_ASSERT(nVolumesIndex == m_nVolumesCount);

        // Call the writer's OnPrepareSnapshot method
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnPrepareSnapshot();
            m_bOnAbortPermitted = true;
            }
        catch(...)
            {
            if (m_hrWriterFailure == S_OK)
                m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPrepareSnapshot method threw an execption");
            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the prepare");
        }
    VSS_STANDARD_CATCH(ft)

    // leave PrepareSnapshot state
    if (EnterStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmPrepareForSnapshot], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// process freeze event
STDMETHODIMP CVssWriterImpl::Freeze
    (
    IN  BSTR    bstrSnapshotSetId,
    IN  INT     nLevel
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Freeze" );

    bool EnterStateCalled = false;
    try
        {
        // should only be called by the coordinator, access check for admin privileges
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");
        
        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Freeze\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        ft.Trace( VSSDBG_WRITER, L"\tLevel = %d\n", nLevel);
        
        // Ignore other Levels
        if (m_nLevel != nLevel)
            return S_OK;

        // enter freeze state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmFreeze],
                bstrSnapshotSetId
                ))
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Improper entry into state"
                );
            }

        AssertLocked();
        // Call writer's OnFreeze
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnFreeze();
            BS_ASSERT(m_bOnAbortPermitted == true);
            }
        catch(...)
            {
            if (m_hrWriterFailure == S_OK)
                m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;
            ft.Trace(VSSDBG_WRITER, L"Writer's OnFreeze Method threw and exception");
            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the freeze");


        // setup arguments to timer thread
        CVssTimerArgs *pArgs = new CVssTimerArgs(this, m_CurrentSnapshotSetId);
        if (pArgs == NULL)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Cannot create timer args due to allocation failure"
                );
            }

        DWORD tid;

        // create timer thread
        m_hThreadTimerThread =
            CreateThread
                (
                NULL,
                VSS_STACK_SIZE,
                &CVssWriterImpl::StartTimerThread,
                pArgs,
                0,
                &tid
                );

        if (m_hThreadTimerThread == NULL)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_OUTOFRESOURCES;
            delete pArgs;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Failure to create thread due to error %d.",
                GetLastError()
                );
           }
        }
    VSS_STANDARD_CATCH(ft)

    // leave OnFreeze state
    if (EnterStateCalled)
	    LeaveState( s_rgWriterStates[s_ivwsmFreeze], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// handle IVssWriter::Thaw event
STDMETHODIMP CVssWriterImpl::Thaw
    (
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Thaw" );

    bool EnterStateCalled = false;
    try
        {
        // should only be called by coordinator.  Access check for admin
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");
        
        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Thaw\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);


        // enter Thaw state
        EnterStateCalled = true;
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmThaw],
                bstrSnapshotSetId
                ))
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Improper entry into state"
                );
            }


        AssertLocked();
        // We should "live" in a sequence since Thaw is not the first phase of the sequence.
        BS_ASSERT(m_bSequenceInProgress);

        // Call writer's OnThaw
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnThaw();
            }
        catch(...)
            {
            if (m_hrWriterFailure == S_OK)
                m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;

            ft.Trace(VSSDBG_WRITER, L"Writer's OnThaw method threw an exception");
            throw;
            }

        // throw veto if writer vetoes the event
        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the thaw");
        }
    VSS_STANDARD_CATCH(ft)

    // leave OnThaw state
    if (EnterStateCalled)
	    LeaveState(s_rgWriterStates[s_ivwsmThaw], ft.HrSucceeded());
    // Bug 255996
    return S_OK;
    }


// process backup complete event
STDMETHODIMP CVssWriterImpl::BackupComplete
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::BackupComplete" );

        // access check
    if (!IsBackupOperator())
        {
        ft.Trace(VSSDBG_WRITER, L"Backup Operator privileges are not set");
        ft.hr = E_ACCESSDENIED;
        return ft.hr;
        }
    
    // MTA synchronization: The critical section will be left automatically at the end of scope.
    CVssWriterImplLock lock(this);

    try
        {
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: OnBackupComplete\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        BS_ASSERT(m_bSequenceInProgress == false);
        BS_ASSERT(m_CurrentSnapshotSetId == GUID_NULL);

        CVssID id;
        id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);

        // We must search for a previous state - Thaw already ended the sequence.
        INT iPreviousSequence = SearchForPreviousSequence(id);
        if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't find a previous sequence with the same Snapshot Set ID"
                );
            }

        // We found a previous sequence with the same SSID.
        BS_ASSERT(id == m_rgidPreviousSnapshots[iPreviousSequence]);

        // BUG 228622 - If we do not have a previous successful Thaw transition
        // then we cannot call BackupComplete
        if (m_rgstatePreviousSnapshots[iPreviousSequence] != VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
            {
            m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't call BackupComplete without OnThaw as a previous state [%d]",
                m_rgstatePreviousSnapshots[iPreviousSequence]
                );
            }

        // BUG 219692 - indicate that sequence is complete even in the saved states
        m_rgstatePreviousSnapshots[iPreviousSequence] = VSS_WS_STABLE;

        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);

        // get IVssWriterComponentsInt object
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, false);

        // call writer's OnBackupComplete method
        BS_ASSERT(m_pWriter);
        try
            {
            if (!m_pWriter->OnBackupComplete(pComponents))
                ft.hr = S_FALSE;
            }
        catch(...)
            {
            if (m_hrWriterFailure == S_OK)
                m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;

            ft.Trace(VSSDBG_WRITER, L"Writer's OnBackupComplete method threw an exception.");
            throw;
            }

        }
    VSS_STANDARD_CATCH(ft)

    // indicate that sequence is complete
    if (m_state == VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        m_state = VSS_WS_STABLE;
    
    // Bug 255996
    return S_OK;
    }


// handle IVssWriter::Abort event
STDMETHODIMP CVssWriterImpl::Abort
    (
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Abort" );

    if (!IsBackupOperator())
        ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup privileges are not set");

    ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Abort\nParameters:\n");
    ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

    Lock();
    
    // call do abort function
    DoAbort(false);
    
    Unlock();

    return S_OK;
    }


// process restore event
STDMETHODIMP CVssWriterImpl::PostRestore
    (
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Restore" );

    // access check
    if (!IsRestoreOperator())
        {
         ft.Trace(VSSDBG_WRITER, L"Restore Operator privileges are not set");
         ft.hr = E_ACCESSDENIED;
         return ft.hr;
        }
        
    ft.Trace(VSSDBG_WRITER, L"\nReceived Event: Restore\n");

    // MTA synchronization: The critical section will be left automatically at the end of scope.
    CVssWriterImplLock lock(this);
    m_hrWriterFailure = S_OK;

    try
        {
        // get writer callback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);
        CComPtr<IVssWriterComponentsInt> pComponents;

        // get IVssWriterComponentsInt object
        InternalGetWriterComponents(pCallback, &pComponents, false);

        // call writer's OnPostRestore method
        BS_ASSERT(m_pWriter);
        try
            {
            if (!m_pWriter->OnPostRestore(pComponents))
                ft.hr = S_FALSE;
            }
        catch(...)
            {
            if (m_hrWriterFailure == S_OK)
                m_hrWriterFailure = VSS_E_WRITERERROR_NONRETRYABLE;

            ft.Trace(VSSDBG_WRITER, L"Writer's OnPostRestore method threw an exception");
            throw;
            }
        }
    VSS_STANDARD_CATCH(ft)

    // Bug 255996
    return S_OK;
    }

// process restore event
STDMETHODIMP CVssWriterImpl::PreRestore
    (
    IN      IDispatch* pWriterCallback
    )
    {
    UNREFERENCED_PARAMETER(pWriterCallback);

    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PostSnapshot" );

    BS_ASSERT(FALSE);

    return S_OK;
    }


// process restore event
STDMETHODIMP CVssWriterImpl::PostSnapshot
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback
    )
    {
    UNREFERENCED_PARAMETER(pWriterCallback);
    UNREFERENCED_PARAMETER(bstrSnapshotSetId);

    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PostSnapshot" );

    BS_ASSERT(FALSE);

    return S_OK;
    }




// table of names of events that we are subscribing to
// NOTE: this table is based on definition of VSS_EVENT_MASK.  Each
// offset corresponds to a bit on that mask
const WCHAR *g_rgwszSubscriptions[] =
    {
    g_wszPrepareForBackupMethodName,        // VSS_EVENT_PREPAREBackup
    g_wszPrepareForSnapshotMethodName,      // VSS_EVENT_PREPARESnapshot
    g_wszFreezeMethodName,                  // VSS_EVENT_FREEZE
    g_wszThawMethodName,                    // VSS_EVENT_THAW
    g_wszAbortMethodName,                   // VSS_EVENT_ABORT
    g_wszBackupCompleteMethodName,          // VSS_EVENT_BACKUPCOMPLETE
    g_wszRequestInfoMethodName,             // VSS_EVENT_REQUESTINFO
    g_wszPostRestoreMethodName              // VSS_EVENT_POST_RESTORE
    };


/////////////////////////////////////////////////////////////////////////////
//  Subscription-related members


// create subscriptions
void CVssWriterImpl::Subscribe()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Subscribe");

    // validate that caller can subscribe to the event
    if (!IsProcessBackupOperator() &&
        !IsProcessLocalService() &&
        !IsProcessNetworkService())
        ft.Throw
            (
            VSSDBG_WRITER,
            E_ACCESSDENIED,
            L"Caller is not either a backup operator, administrator, local service, or network service"
            );

    // currently we subscribe to all events
    m_dwEventMask = VSS_EVENT_ALL;

    if (m_bstrSubscriptionName.Length() > 0)
        ft.Throw
            (
            VSSDBG_XML,
            VSS_E_WRITER_ALREADY_SUBSCRIBED,
            L"The writer has already called the Subscribe function."
            );

    // create event system
    CComPtr<IEventSystem> pSystem;
    ft.hr = CoCreateInstance
                (
                CLSID_CEventSystem,
                NULL,
                CLSCTX_SERVER,
                IID_IEventSystem,
                (void **) &pSystem
                );

    ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");
    CComBSTR bstrClassId = CLSID_VssEvent;
    CComBSTR bstrIID = IID_IVssWriter;
    CComBSTR bstrProgId = PROGID_EventSubscription;

    // see if event class already exists
    CComBSTR bstrQuery = "EventClassID == ";
    if (!bstrQuery)
        ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

    bstrQuery.Append(bstrClassId);
    if (!bstrQuery)
        ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

    int location;
    CComPtr<IEventObjectCollection> pCollection;
    ft.hr = pSystem->Query
                (
                PROGID_EventClassCollection,
                bstrQuery,
                &location,
                (IUnknown **) &pCollection
                );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");
    long cEvents;
    ft.hr = pCollection->get_Count(&cEvents);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    if (cEvents == 0)
        {
        // event class does not exist, create it.  Note that there is a
        // potential race condition here if two writers try creating the event
        // class at the same time.  We create the event class during installation
        // so that this should rarely happen
        CComPtr<IEventClass> pEvent;

        CComBSTR bstrEventClassName = L"VssEvent";
        WCHAR buf[MAX_PATH*2];

        // event class typelib
        UINT cwc = ExpandEnvironmentStrings
                        (
                        L"%systemroot%\\system32\\eventcls.dll",
                        buf,
                        sizeof(buf)/sizeof(WCHAR)
                        );

        if (cwc == 0)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_WRITER, L"ExpandEnvironmentStrings");
            }

        CComBSTR bstrTypelib = buf;

        // create event class
        ft.hr = CoCreateInstance
                    (
                    CLSID_CEventClass,
                    NULL,
                    CLSCTX_SERVER,
                    IID_IEventClass,
                    (void **) &pEvent
                    );

        ft.CheckForError(VSSDBG_WRITER, L"CoCreatInstance");

        // setup class id
        ft.hr = pEvent->put_EventClassID(bstrClassId);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassID");

        // set up class name
        ft.hr = pEvent->put_EventClassName(bstrEventClassName);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassName");

        // set up typelib
        ft.hr = pEvent->put_TypeLib(bstrTypelib);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_TypeLib");

        // store event class
        ft.hr = pSystem->Store(PROGID_EventClass, pEvent);
        ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");
        }

    // create subscription id
    VSS_ID SubscriptionId;
    ft.hr = ::CoCreateGuid(&SubscriptionId);
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateGuid");
    m_bstrSubscriptionName = SubscriptionId;

    // get IUnknown for subscribers class
    IUnknown *pUnkSubscriber = GetUnknown();
    UINT iwsz, mask;

    try
        {
        // loop through subscriptions
        for(mask = 1, iwsz = 0; mask < VSS_EVENT_ALL; mask = mask << 1, iwsz++)
            {
            if (m_dwEventMask & mask && g_rgwszSubscriptions[iwsz] != NULL)
                {
                // create IEventSubscription object
                CComPtr<IEventSubscription> pSubscription;
                ft.hr = CoCreateInstance
                            (
                            CLSID_CEventSubscription,
                            NULL,
                            CLSCTX_SERVER,
                            IID_IEventSubscription,
                            (void **) &pSubscription
                            );

                ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");

                // set subscription name
                ft.hr = pSubscription->put_SubscriptionName(m_bstrSubscriptionName);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_SubscriptionName");

                // set event class id
                ft.hr = pSubscription->put_EventClassID(bstrClassId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_EventClassID");

                // set interface id
                ft.hr = pSubscription->put_InterfaceID(bstrIID);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_InterfaceID");

                // set subcriber interface
                ft.hr = pSubscription->put_SubscriberInterface(pUnkSubscriber);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_SubscriberInterface");

                // make subscription per user since this is not necessarily in local system
                ft.hr = pSubscription->put_PerUser(TRUE);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_PerUser");

                // set method name for subscrpition
                ft.hr = pSubscription->put_MethodName(CComBSTR(g_rgwszSubscriptions[iwsz]));
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_MethodName");

                // store subscription
                ft.hr = pSystem->Store(bstrProgId, pSubscription);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");

                // get constructed subscription id and save it
                ft.hr = pSubscription->get_SubscriptionID(&m_rgbstrSubscriptionId[m_cbstrSubscriptionId]);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::get_SubscriptionID");

                // increment count of
                m_cbstrSubscriptionId++;
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    // if the operation fails with us partially subscribed, then unsubscribe
    if (ft.HrFailed() && m_cbstrSubscriptionId)
        {
        Unsubscribe();
        ft.Throw(VSSDBG_WRITER, ft.hr, L"Rethrowing exception");
        }
    }


// terminate timer thread
// assumes caller has the critical section locked
void CVssWriterImpl::TerminateTimerThread()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::TerminateTimerThread");

    AssertLocked();
    if (m_hThreadTimerThread)
        {
        // cause timer thread to terminate
        m_command = VSS_TC_TERMINATE_THREAD;
        if (!SetEvent(m_hevtTimerThread))
            {
            DWORD dwErr = GetLastError();
            ft.Trace(VSSDBG_WRITER, L"SetEvent failed with error %d\n", dwErr);
            BS_ASSERT(FALSE && "SetEvent failed");
            }


        // get thread handle
        HANDLE hThread = m_hThreadTimerThread;
        m_hThreadTimerThread = NULL;

        // unlock during wait
        Unlock();
        if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
            {
            DWORD dwErr = GetLastError();
            ft.Trace(VSSDBG_WRITER, L"WaitForSingleObject failed with error %d\n", dwErr);
            BS_ASSERT(FALSE && "WaitForSingleObject failed");
            }
            
        CloseHandle(hThread);
        Lock();
        }
    }


// unsubscribe this writer from IVssWriter events
void CVssWriterImpl::Unsubscribe()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Unsubscribe");

    // terminate timer thread if active
    Lock();
    TerminateTimerThread();
    Unlock();

    // make sure subscription name was assigned; if not assume subscriptions
    // weren't created
    if (m_bstrSubscriptionName.Length() == 0)
        return;

    // create event system
    CComPtr<IEventSystem> pSystem;
    ft.hr = CoCreateInstance
                (
                CLSID_CEventSystem,
                NULL,
                CLSCTX_SERVER,
                IID_IEventSystem,
                (void **) &pSystem
                );

    ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");

#if 0
    WCHAR buf[256];
    int location;
    swprintf(buf, L"SubscriptionName = \"%s\"", m_bstrSubscriptionName);
    
    CComPtr<IEventObjectCollection> pCollection;
    
    ft.hr = pSystem->Query
        (
        PROGID_EventSubscriptionCollection,
        buf,
        &location,
        (IUnknown **) &pCollection
        );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");

    long cSub;
    ft.hr = pCollection->get_Count(&cSub);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    pCollection = NULL;
#endif

    for(UINT iSubscription = 0; iSubscription < m_cbstrSubscriptionId; iSubscription++)
        {
        // setup query string
        CComBSTR bstrQuery = L"SubscriptionID == ";
        if (!bstrQuery)
            ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"allocation of BSTR failed");

        // if subscription exists, then remove it
        if (m_rgbstrSubscriptionId[iSubscription])
            {
            bstrQuery.Append(m_rgbstrSubscriptionId[iSubscription]);
            if (!bstrQuery)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"allocation of BSTR failed");

            int location;

            // remove subscription
            ft.hr = pSystem->Remove(PROGID_EventSubscription, bstrQuery, &location);
            ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Remove");

            // indicate that subscription was removed
            m_rgbstrSubscriptionId[iSubscription].Empty();
            }
        }
#if 0
    ft.hr = pSystem->Query
        (
        PROGID_EventSubscriptionCollection,
        buf,
        &location,
        (IUnknown **) &pCollection
        );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");

    ft.hr = pCollection->get_Count(&cSub);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    pCollection = NULL;
#endif

    // reset subscription name so unsubscribe does nothing if called again
    m_bstrSubscriptionName.Empty();
    m_cbstrSubscriptionId = 0;
    }

// create a internal writer class and link it up to the external writer class
void CVssWriterImpl::CreateWriter
    (
    CVssWriter *pWriter,            // external writer
    IVssWriterImpl **ppImpl         // interface to be used by external writer
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CreateWriter");

    BS_ASSERT(ppImpl);
    BS_ASSERT(pWriter);

    *ppImpl = NULL;

    // create internal wrier class
    CComObject<CVssWriterImpl> *pImpl;
    // create CVssWriterImpl object <core writer class>
    ft.hr = CComObject<CVssWriterImpl>::CreateInstance(&pImpl);
    if (ft.HrFailed())
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failed to create CVssWriterImpl.  hr = 0x%08lx",
            ft.hr
            );

    // set reference count of internal writer to 1
    pImpl->GetUnknown()->AddRef();

    // link external writer into internal writer
    pImpl->SetWriter(pWriter);

    // return internal writer interface
    *ppImpl = (IVssWriterImpl *) pImpl;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\vssadmin\vssadmin.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vssadmin.cpp | header of VSS demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


#ifndef __VSS_DEMO_H_
#define __VSS_DEMO_H_


/////////////////////////////////////////////////////////////////////////////
//  Defines and pragmas

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>

// Application specific
#include "vs_inc.hxx"

// Generated MIDL headers
#include "vs_idl.hxx"

#include "copy.hxx"
#include "pointer.hxx"

#include "resource.h"


/////////////////////////////////////////////////////////////////////////////
//  Constants

const WCHAR wszVssOptVssadmin[]     = L"vssadmin";
const WCHAR wszVssOptList[]         = L"list";
const WCHAR wszVssOptSnapshots[]    = L"shadows";
const WCHAR wszVssOptProviders[]    = L"providers";
const WCHAR wszVssOptWriters[]      = L"writers";
const WCHAR wszVssOptSet[]          = L"/set=";
const WCHAR wszVssFmtSpaces[]       = L" \t";
const WCHAR wszVssFmtNewline[]      = L"\n";


const nStringBufferSize = 1024;	    // Includes the zero character

const nPollingInterval  = 2500;     // Three seconds

const MAX_RETRIES_COUNT = 4;        // Retries for polling

	
/////////////////////////////////////////////////////////////////////////////
//	class CVssAdminCLI


class CVssAdminCLI
{
// Enums and typedefs
private:

	typedef enum _CMD_TYPE
	{
		VSS_CMD_UNKNOWN = 0,
		VSS_CMD_USAGE,
		VSS_CMD_LIST,
		VSS_CMD_CREATE,
		VSS_CMD_DELETE,
	} CMD_TYPE;

	typedef enum _LIST_TYPE
	{
		VSS_LIST_UNKNOWN = 0,
		VSS_LIST_SNAPSHOTS,
		VSS_LIST_WRITERS,
		VSS_LIST_PROVIDERS,
	} LIST_TYPE;

	enum _RETURN_VALUE
	{
		VSS_CMDRET_SUCCESS      = 0,
		VSS_CMDRET_EMPTY_RESULT = 1,
		VSS_CMDRET_ERROR        = 2,
	};

// Constructors& destructors
private:
	CVssAdminCLI(const CVssAdminCLI&);
	CVssAdminCLI();

public:
	CVssAdminCLI(
		IN	HINSTANCE hInstance
		);
	~CVssAdminCLI();

// Attributes
private:

	LPWSTR		GetCmdLine() const { return m_pwszCmdLine; };
	HINSTANCE	GetInstance() const { return m_hInstance; };
	INT         GetReturnValue() { return m_nReturnValue; };


// Operations
public:

	static HRESULT Main(
		IN	HINSTANCE hInstance
		);

private:

	void Initialize(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ParseCmdLine(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void DoProcessing(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void Finalize();

// Processing
private:

	void PrintUsage(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListSnapshots(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListWriters(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListProviders(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

// Implementation
private:

	LPCWSTR LoadString(
		IN	CVssFunctionTracer& ft,
		IN	UINT nStringId
		) throw(HRESULT);

	LPCWSTR GetNextCmdlineToken(
		IN	CVssFunctionTracer& ft,
		IN	bool bFirstToken = false
		) throw(HRESULT);

	bool Match(
		IN	CVssFunctionTracer& ft,
		IN	LPCWSTR wszString,
		IN	LPCWSTR wszPatternString
		) throw(HRESULT);

	bool ScanGuid(
		IN	CVssFunctionTracer& ft,
		IN	LPCWSTR wszString,
		IN	VSS_ID& Guid
		) throw(HRESULT);

	void Output(
		IN	CVssFunctionTracer& ft,
    	IN	LPCWSTR wszFormat,
		...
		) throw(HRESULT);

	void Output(
		IN	CVssFunctionTracer& ft,
		IN	UINT uFormatStringId,
		...
		) throw(HRESULT);

    void OutputOnConsole(
        IN	LPCWSTR wszStr
        );

	LPCWSTR GetProviderName(
		IN	CVssFunctionTracer& ft,
		IN	VSS_ID& ProviderId
		) throw(HRESULT);

// Data members
private:

	HINSTANCE			m_hInstance;
	HANDLE              m_hConsoleOutput;
    CVssSimpleMap<UINT, LPCWSTR> m_mapCachedResourceStrings;
    CVssSimpleMap<VSS_ID, LPCWSTR> m_mapCachedProviderNames;
	LPWSTR				m_pwszCmdLine;
	INT                 m_nReturnValue;
	
	CMD_TYPE			m_eCommandType;
	LIST_TYPE			m_eListType;
	VSS_OBJECT_TYPE		m_eFilterObjectType;
	VSS_OBJECT_TYPE		m_eListedObjectType;
	VSS_ID				m_FilterSnapshotSetId;
	VSS_ID				m_FilterSnapshotId;
};


#endif //__VSS_DEMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\common.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module common.cpp | Implementation of SnapshotWriter common code



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:


	X-18	MCJ		Michael C. Johnson		18-Oct-2000
		210264: Prevent Win32 status from leaking out and return 
			one of the sanctioned error codes.

	X-18	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-17	MCJ		Michael C. Johnson		 4-Aug-2000
		 94487: Ensure VsCreateDirectories() adds security attributes 
		        to all directories that it creates.
		143435: Added new variations of StringCreateFromExpandedString()
		        StringInitialise() and StringCreateFromString() 
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree().

		Also fix a couple of minor problems in MoveFilesInDirectory()


	X-16	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.
			Remove unused routines
				ANSI version of StringXxxx routines.
				GetStringFromControlCode()
				GetTargetStateFromControlCode()
				VsGetVolumeNameFromPath()
				VsCheckPathAgainstVolumeNameList()
			Fix race conditions in VsCreateDirectories()
			Replace use of CheckShimPrivileges() with 
			IsProcessBackupOperator()

	X-15	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events


	X-14	MCJ		Michael C. Johnson		15-May-2000
		107129: Ensure that the outputs from ContextLocate () are 
		        set to known values in all cases.
		108586: Add CheckShimPrivileges() to check for the privs we 
		        require to invoke the public shim routines.

	X-13	MCJ		Michael C. Johnson		23-Mar-2000
		Add routines MoveFilesInDirectory() and EmptyDirectory()

	X-12	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-11	MCJ		Michael C. Johnson		 6-Mar-2000
		Add VsServiceChangeState () which should deal with all the
		service states that we are interested in.

	X-10	MCJ		Michael C. Johnson		 2-Mar-2000
		Inadvertantly trimmed trailing '\' if present from directory
		path when cleaning directory.

	X-9	MCJ		Michael C. Johnson		29-Feb-2000
		Fix off-by-one error testing for trailing '\' and delete
		the directory itself in CleanDirectory().

	X-8	MCJ		Michael C. Johnson		23-Feb-2000
		Add common context manipulation routines including state
		tracking and checking.

	X-7	MCJ		Michael C. Johnson		17-Feb-2000
		Move definition of ROOT_BACKUP_DIR to common.h

	X-6	MCJ		Michael C. Johnson		16-Feb-2000
		Merge in X-3v1

		X-3v1	MCJ		Michael C. Johnson		11-Feb-2000
			Added additional StringXxxx () routines and routines to
			turn on backup priviledges and restore priviledges.

	X-5	SRS		Stefan R. Steiner		14-Feb-2000
		Removed the check for CBsString's being potentially > 2^15 characters since
		the CBsString class supports strings up to 2^31 characters in length.  Added
		VsCopyFilesInDirectory()

	X-4	SRS	Stefan R. Steiner			13-Feb-2000
		Added VsExpandEnvironmentStrings()

	X-3	SRS		Stefan R. Steiner		08-Feb-2000
		Added service management code and volume name from path code

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Cleaned up some comments and fixed a string length
		calculation.
		Also made sure module can be built as part of the standalone
		writer tests.

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation.

--*/


#include "stdafx.h"
#include "vssmsg.h"
#include "common.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCOMNC"


/* 
** The first group of (overloaded) routines manipulate UNICODE_STRING
** strings. The rules which apply here are:
**
** 1) The Buffer field points to an array of characters (WCHAR) with
** the length of the buffer being specified in the MaximumLength
** field. If the Buffer field is non-NULL it must point to a valid
** buffer capable of holding at least one character.  If the Buffer
** field is NULL, the MaximumLength and Length fields must both be
** zero.
**
** 2) Any valid string in the buffer is always terminated with a
** UNICODE_NULL.
**
** 3) the MaximumLength describes the length of the buffer measured in
** bytes. This value must be even.
**
** 4) The Length field describes the number of valid characters in the
** buffer measured in BYTES, excluding the termination
** character. Since the string must always have a termination
** character ('\0'), the maximum value of Length is MaximumLength - 2.
**
**
** The routines available are:-
**
**	StringInitialise ()
**	StringTruncate ()
**	StringSetLength ()
**	StringAllocate ()
**	StringFree ()
**	StringCreateFromString ()
**	StringAppendString ()
**	StringCreateFromExpandedString ()
** 
*/


/*
**++
**
**  Routine Description:
**
**
**  Arguments:
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT StringInitialise (PUNICODE_STRING pucsString)
    {
    pucsString->Buffer        = NULL;
    pucsString->Length        = 0;
    pucsString->MaximumLength = 0;

    return (NOERROR);
    } /* StringInitialise () */


HRESULT StringInitialise (PUNICODE_STRING pucsString, LPCWSTR pwszString)
    {
    return (StringInitialise (pucsString, (PWCHAR) pwszString));
    }

HRESULT StringInitialise (PUNICODE_STRING pucsString, PWCHAR pwszString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pwszString) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Buffer        = pwszString;
	pucsString->Length        = (USHORT) ulStringLength;
	pucsString->MaximumLength = (USHORT) (ulStringLength + sizeof (UNICODE_NULL));
	}


    return (hrStatus);
    } /* StringInitialise () */


HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars)
    {
    HRESULT	hrStatus    = NOERROR;
    USHORT	usNewLength = (USHORT)(usSizeInChars * sizeof (WCHAR));

    if (usNewLength > pucsString->Length)
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Buffer [usSizeInChars] = UNICODE_NULL;
	pucsString->Length                 = usNewLength;
	}


    return (hrStatus);
    } /* StringTruncate () */


HRESULT StringSetLength (PUNICODE_STRING pucsString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pucsString->Buffer) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Length        = (USHORT) ulStringLength;
	pucsString->MaximumLength = (USHORT) UMAX (pucsString->MaximumLength,
						   pucsString->Length + sizeof (UNICODE_NULL));
	}


    return (hrStatus);
    } /* StringSetLength () */


HRESULT StringAllocate (PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes)
    {
    HRESULT	hrStatus      = NOERROR;
    LPVOID	pvBuffer      = NULL;
    SIZE_T	cActualLength = 0;


    pvBuffer = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, usMaximumStringLengthInBytes);

    hrStatus = GET_STATUS_FROM_POINTER (pvBuffer);


    if (SUCCEEDED (hrStatus))
	{
	pucsString->Buffer        = (PWCHAR)pvBuffer;
	pucsString->Length        = 0;
	pucsString->MaximumLength = usMaximumStringLengthInBytes;


	cActualLength = HeapSize (GetProcessHeap (), 0, pvBuffer);

	if ((cActualLength <= MAXUSHORT) && (cActualLength > usMaximumStringLengthInBytes))
	    {
	    pucsString->MaximumLength = (USHORT) cActualLength;
	    }
	}


    return (hrStatus);
    } /* StringAllocate () */


HRESULT StringFree (PUNICODE_STRING pucsString)
    {
    HRESULT	hrStatus = NOERROR;
    BOOL	bSucceeded;


    if (NULL != pucsString->Buffer)
	{
	bSucceeded = HeapFree (GetProcessHeap (), 0, pucsString->Buffer);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
	}


    if (SUCCEEDED (hrStatus))
	{
	pucsString->Buffer        = NULL;
	pucsString->Length        = 0;
	pucsString->MaximumLength = 0;
	}


    return (hrStatus);
    } /* StringFree () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString)
    {
    HRESULT	hrStatus = NOERROR;


    hrStatus = StringAllocate (pucsNewString, pucsOriginalString->MaximumLength);


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);

	pucsNewString->Length = pucsOriginalString->Length;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pwszOriginalString) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pwszOriginalString, ulStringLength);

	pucsNewString->Length = (USHORT) ulStringLength;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = pucsOriginalString->MaximumLength + (dwExtraChars * sizeof (WCHAR));


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);

	pucsNewString->Length = pucsOriginalString->Length;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = (wcslen (pwszOriginalString) + dwExtraChars) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pwszOriginalString, ulStringLength);

	pucsNewString->Length = (USHORT) ulStringLength;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringAppendString (PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource)
    {
    HRESULT	hrStatus = NOERROR;

    if (pucsSource->Length > (pucsTarget->MaximumLength - pucsTarget->Length - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	memmove (&pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)],
		 pucsSource->Buffer,
		 pucsSource->Length + sizeof (UNICODE_NULL));

	pucsTarget->Length += pucsSource->Length;
	}


    /*
    ** There should be no reason in this code using this routine to
    ** have to deal with a short buffer so trap potential problems.
    */
    BS_ASSERT (SUCCEEDED (hrStatus));


    return (hrStatus);
    } /* StringAppendString () */


HRESULT StringAppendString (PUNICODE_STRING pucsTarget, PWCHAR pwszSource)
    {
    HRESULT		hrStatus = NOERROR;
    UNICODE_STRING	ucsSource;


    StringInitialise (&ucsSource, pwszSource);

    hrStatus = StringAppendString (pucsTarget, &ucsSource);


    /*
    ** There should be no reason in this code using this routine to
    ** have to deal with a short buffer so trap potential problems.
    */
    BS_ASSERT (SUCCEEDED (hrStatus));


    return (hrStatus);
    } /* StringAppendString () */


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString)
    {
    return (StringCreateFromExpandedString (pucsNewString, pwszOriginalString, 0));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString)
    {
    return (StringCreateFromExpandedString (pucsNewString, pucsOriginalString->Buffer, 0));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars)
    {
    return (StringCreateFromExpandedString (pucsNewString, pucsOriginalString->Buffer, dwExtraChars));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus = NOERROR;
    DWORD	dwStringLength;


    /*
    ** Remember, ExpandEnvironmentStringsW () includes the terminating null in the response.
    */
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString, NULL, 0) + dwExtraChars;

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwStringLength);



    if (SUCCEEDED (hrStatus) && ((dwStringLength * sizeof (WCHAR)) > MAXUSHORT))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT)(dwStringLength * sizeof (WCHAR)));
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Note that if the expanded string has gotten bigger since we
	** allocated the buffer then too bad, we may not get all the
	** new translation. Not that we really expect these expanded
	** strings to have changed any time recently.
	*/
	dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString,
						    pucsNewString->Buffer,
						    pucsNewString->MaximumLength / sizeof (WCHAR));

	hrStatus = GET_STATUS_FROM_BOOL (0 != dwStringLength);


	if (SUCCEEDED (hrStatus))
	    {
	    pucsNewString->Length = (USHORT) ((dwStringLength - 1) * sizeof (WCHAR));
	    }
	}


    return (hrStatus);
    } /* StringCreateFromExpandedString () */



/*
**++
**
**  Routine Description:
**
**	Closes a standard Win32 handle and set it to INVALID_HANDLE_VALUE. 
**	Safe to be called multiple times on the same handle or on a handle 
**	initialised to INVALID_HANDLE_VALUE or NULL.
**
**
**  Arguments:
**
**	phHandle	Address of the handle to be closed
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	Any HRESULT from CloseHandle()
**
**-- 
*/

HRESULT CommonCloseHandle (PHANDLE phHandle)
    {
    HRESULT	hrStatus = NOERROR;
    BOOL	bSucceeded;


    if ((INVALID_HANDLE_VALUE != *phHandle) && (NULL != *phHandle))
	{
	bSucceeded = CloseHandle (*phHandle);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (SUCCEEDED (hrStatus))
	    {
	    *phHandle = INVALID_HANDLE_VALUE;
	    }
	}


    return (hrStatus);
    } /* CommonCloseHandle () */



#define VALID_PATH( path ) ( ( ( pwszPathName[0] == DIR_SEP_CHAR )  && ( pwszPathName[1] == DIR_SEP_CHAR ) ) || \
                             ( isalpha( pwszPathName[0] ) && ( pwszPathName[1] == L':' ) && ( pwszPathName[2] == DIR_SEP_CHAR ) ) )
/*++
**
** Routine Description:
**
**	Creates any number of directories along a path.  Only works for
**	full path names with no relative elements in it.  Other than that
**	it works identically as CreateDirectory() works and sets the same
**	error codes except it doesn't return an error if the complete
**	path already exists.
**
** Arguments:
**
**	pwszPathName - The path with possible directory components to create.
**
**	lpSecurityAttributes -
**
** Return Value:
**
**	TRUE - Sucessful
**	FALSE - GetLastError() can return one of these (and others):
**		ERROR_ALREADY_EXISTS - when something other than a file exists somewhere in the path.
**		ERROR_BAD_PATHNAME   - when \\servername alone is specified in the pathname
**		ERROR_ACCESS_DENIED  - when x:\ alone is specified in the pathname and x: exists
**		ERROR_PATH_NOT_FOUND - when x: alone is specified in the pathname and x: doesn't exist.
**				       Should not get this error code for any other reason.
**		ERROR_INVALID_NAME   - when pathname doesn't start with either x:\ or \\
**
**--
*/

BOOL VsCreateDirectories (IN LPCWSTR pwszPathName,
			  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
			  IN DWORD dwExtraAttributes)
    {
    DWORD dwObjAttribs, dwRetPreserve;
    BOOL bRet;


    /*
    ** Make sure the path starts with the valid path prefixes
    */
    if (!VALID_PATH (pwszPathName))
	{
	SetLastError (ERROR_INVALID_NAME);
        return FALSE;
	}



    /*
    ** Save away the current last error code.
    */
    dwRetPreserve = GetLastError ();


    /*
    **  Now test for the most common case, the directory already exists.  This
    **  is the performance path.
    */
    dwObjAttribs = GetFileAttributesW (pwszPathName);

    if ((dwObjAttribs != 0xFFFFFFFF) && (dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY))
	{
	/*
	** Don't return an error if the directory already exists.
	** This is the one case where this function differs from
	** CreateDirectory().  Notice that even though another type of
	** file may exist with this pathname, no error is returned yet
	** since I want the error to come from CreateDirectory() to
	** get CreateDirectory() error behavior.
	**
	** Since we're successful restore the last error code.
	*/
        SetLastError (dwRetPreserve);
        return TRUE;
	}


    /*
    ** Now try to create the directory using the full path.  Even
    ** though we might already know it exists as something other than
    ** a directory, get the error from CreateDirectory() instead of
    ** having to try to reverse engineer all possible errors that
    ** CreateDirectory() can return in the above code.
    **
    ** It is probably the second most common case that when this
    ** function is called that only the last component in the
    ** directory doesn't exist.  Let's try to make it.
    **
    ** Note that it appears if a UNC path is given with a number of
    ** non-existing path components the remote server automatically
    ** creates all of those components when CreateDirectory is called.
    ** Therefore, the next call is almost always successful when the
    ** path is a UNC.
    */
    bRet = CreateDirectoryW (pwszPathName, lpSecurityAttributes);

    if (bRet)
	{
	SetFileAttributesW (pwszPathName, dwExtraAttributes);

	/*
	** Set it back to the last error code
	*/
        SetLastError (dwRetPreserve);
        return TRUE;
	}

    else if (GetLastError () == ERROR_ALREADY_EXISTS)
	{
	/*
 	** Looks like someone created the name whilst we weren't
	** looking. Check to see if it's a directory and return
	** success if so, otherwise return the error that
	** CreateDirectoryW() set.
	*/
	dwObjAttribs = GetFileAttributesW (pwszPathName);

	if ((dwObjAttribs != 0xFFFFFFFF) && (dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY))
	    {
	    /*
	    ** It's a directory. Declare victory.
	    **
	    ** Restore the last error code
	    */
	    SetLastError (dwRetPreserve);
	    return TRUE;
	    }
	else
	    {
	    SetLastError (ERROR_ALREADY_EXISTS);

	    return FALSE;
	    }
	}

    else if (GetLastError () != ERROR_PATH_NOT_FOUND )
	{
        return FALSE;
	}



    /*
    ** Allocate memory to hold the string while processing the path.
    ** The passed in string is a const.
    */
    PWCHAR pwszTempPath = (PWCHAR) malloc ((wcslen (pwszPathName) + 1) * sizeof (WCHAR));

    BS_ASSERT (pwszTempPath != NULL);


    wcscpy (pwszTempPath, pwszPathName);

    /*
    ** Appears some components in the path don't exist.  Now try to
    ** create the components.
    */
    PWCHAR pwsz, pwszSlash;


    /*
    ** First skip the drive letter part or the \\server\sharename
    ** part and get to the first slash before the first level
    ** directory component.
    */
    if (pwszTempPath [1] == L':')
	{
	/*
        **  Path in the form of x:\..., skip first 2 chars
        */
        pwsz = pwszTempPath + 2;
	}
    else
	{
        /*
        ** Path should be in form of \\servername\sharename.  Can be
        ** \\?\d: Search to first slash after sharename
        **
        ** First search to first char of the share name
        */
        pwsz = pwszTempPath + 2;

        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	    {
            ++pwsz;
	    }


        /*
        ** Eat up all continuous slashes and get to first char of the
        ** share name
        */
        while (*pwsz == DIR_SEP_CHAR)
	    {
	    ++pwsz;
	    }


        if (*pwsz == L'\0')
	    {
            /*
            ** This shouldn't have happened since the CreateDirectory
            ** call should have caught it.  Oh, well, deal with it.
            */
            SetLastError (ERROR_BAD_PATHNAME);

            free (pwszTempPath);

            return FALSE;
	    }


        /*
	** Now at first char of share name, let's search for first
	** slash after the share name to get to the (first) shash in
	** front the first level directory.
        */
        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	    {
            ++pwsz;
	    }
	}


    
    /*
    ** Eat up all continuous slashes before the first level directory
    */
    while (*pwsz == DIR_SEP_CHAR)
	{
	++pwsz;
	}


    /*
    ** Now at first char of the first level directory, let's search
    ** for first slash after the directory.
    */
    while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	{
	++pwsz;
	}


    /*
    ** If pwsz is pointing to a null char, that means only the first
    ** level directory needs to be created.  Fall through to the leaf
    ** node create directory.
    */
    while (*pwsz != L'\0')
	{
        pwszSlash = pwsz;  //  Keep pointer to the separator

        /*
        **  Eat up all continuous slashes.
        */
        while (*pwsz == DIR_SEP_CHAR)
	    {
	    ++pwsz;
	    }


        if (*pwsz == L'\0')
	    {
	    /*
            ** There were just slashes at the end of the path.  Break
            ** out of loop, let the leaf node CreateDirectory create
            ** the last directory.
            */
            break;
	    }


        /*
        ** Terminate the directory path at the current level.
        */
        *pwszSlash = L'\0';

        dwObjAttribs = GetFileAttributesW (pwszTempPath);

        if ((dwObjAttribs == 0XFFFFFFFF) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
	    {
            bRet = CreateDirectoryW (pwszTempPath, lpSecurityAttributes);

            if (bRet)
		{
		SetFileAttributesW (pwszTempPath, dwExtraAttributes);
		}
	    else
		{
		if (ERROR_ALREADY_EXISTS != GetLastError ())
		    {
		    /*
		    **  Restore the slash.
		    */
		    *pwszSlash = DIR_SEP_CHAR;

		    free (pwszTempPath);
		    
		    return FALSE;
		    }

		else
		    {
		    /* 
		    ** Looks like someone created the name whilst we
		    ** weren't looking. Check to see if it's a
		    ** directory and continue if so, otherwise return
		    ** the error that CreateDirectoryW() set.
		    */
		    dwObjAttribs = GetFileAttributesW (pwszTempPath);

		    if ((dwObjAttribs == 0xFFFFFFFF) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
			{
			/*
			** It's not what we recognise as a
			** directory. Declare failure. Set the error
			** code to that which CreateDirectoryW()
			** returned, restore the slash, free the
			** buffer and get out of here.
			*/
			SetLastError (ERROR_ALREADY_EXISTS);

			*pwszSlash = DIR_SEP_CHAR;

			free (pwszTempPath);

			return FALSE;
			}
		    }
		}
	    }


        /*
        **  Restore the slash.
        */
        *pwszSlash = DIR_SEP_CHAR;

        /*
        ** Now at first char of the next level directory, let's search
        ** for first slash after the directory.
        */
        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	    {
            ++pwsz;
	    }
	}


    free (pwszTempPath);

    pwszTempPath = NULL;


    /*
    **  Now make the last directory.
    */
    dwObjAttribs = GetFileAttributesW (pwszPathName);

    if ((dwObjAttribs == 0xFFFFffff) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{
        bRet = CreateDirectoryW (pwszPathName, lpSecurityAttributes);

        if (bRet)
	    {
	    SetFileAttributesW (pwszPathName, dwExtraAttributes);
	    }
	else
	    {
            return FALSE;
	    }
	}


    SetLastError (dwRetPreserve);    //  Set back old last error code
    return TRUE;
    }


/*
** The next set of rountes are used to change the state of SCM
** controlled services, typically between RUNNING and either PAUSED or
** STOPPED.
**
** The initial collection are for manipulating the states, control
** codes and getting the string equivalents to be used for tracing
** purposes.
**
** The major routines is VsServiceChangeState(). This is called
** specifying the reuiqred state for the service and after some
** validation, it makes the appropriate request of the SCM and calls
** WaitForServiceToEnterState() to wait until the services reaches the
** desired state, or it times out.  
*/

static PWCHAR const GetStringFromStateCode (DWORD dwState)
    {
    PWCHAR	pwszReturnedString = NULL;


    switch (dwState)
	{
	case 0:                        pwszReturnedString = L"UnSpecified";     break;
	case SERVICE_STOPPED:          pwszReturnedString = L"Stopped";         break;
	case SERVICE_START_PENDING:    pwszReturnedString = L"StartPending";    break;
	case SERVICE_STOP_PENDING:     pwszReturnedString = L"StopPending";     break;
	case SERVICE_RUNNING:          pwszReturnedString = L"Running";         break;
	case SERVICE_CONTINUE_PENDING: pwszReturnedString = L"ContinuePending"; break;
	case SERVICE_PAUSE_PENDING:    pwszReturnedString = L"PausePending";    break;
	case SERVICE_PAUSED:           pwszReturnedString = L"Paused";          break;
	default:                       pwszReturnedString = L"UNKKNOWN STATE";  break;
	}


    return (pwszReturnedString);
    } /* GetStringFromStateCode () */


static DWORD const GetControlCodeFromTargetState (const DWORD dwTargetState)
    {
    DWORD	dwServiceControlCode;


    switch (dwTargetState)
	{
	case SERVICE_STOPPED: dwServiceControlCode = SERVICE_CONTROL_STOP;     break;
	case SERVICE_PAUSED:  dwServiceControlCode = SERVICE_CONTROL_PAUSE;    break;
	case SERVICE_RUNNING: dwServiceControlCode = SERVICE_CONTROL_CONTINUE; break;
	default:              dwServiceControlCode = 0;                        break;
	}

    return (dwServiceControlCode);
    } /* GetControlCodeFromTargetState () */


static DWORD const GetNormalisedState (DWORD dwCurrentState)
    {
    DWORD	dwNormalisedState;


    switch (dwCurrentState)
	{
	case SERVICE_STOPPED:
	case SERVICE_STOP_PENDING:
	    dwNormalisedState = SERVICE_STOPPED;
	    break;

	case SERVICE_START_PENDING:
	case SERVICE_CONTINUE_PENDING:
	case SERVICE_RUNNING:
	    dwNormalisedState = SERVICE_RUNNING;
	    break;

	case SERVICE_PAUSED:
	case SERVICE_PAUSE_PENDING:
	    dwNormalisedState = SERVICE_PAUSED;
	    break;

	default:
	    dwNormalisedState = 0;
	    break;
	}

    return (dwNormalisedState);
    } /* GetNormalisedState () */

/*
**++
**
**  Routine Description:
**
**	Wait for the specified service to enter the specified
**	state. The routine polls the serivce for it's current state
**	every dwServiceStatePollingIntervalInMilliSeconds milliseconds
**	to see if the service has reached the desired state. If the
**	repeated delay eventually reaches the timeout period the
**	routine stops polling and returns a failure status.
**
**	NOTE: since this routine just sleeps between service state 
**	interrogations, it effectively stalls from the point of view
**	of the caller.
**
**
**  Arguments:
**
**	shService			handle to the service being manipulated
**	dwMaxDelayInMilliSeconds	timeout period
**	dwDesiredState			state to move the service into
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	HRESULT for ERROR_TIMOUT if the service did not reach the required state in the required time
**
**-- 
*/

static HRESULT WaitForServiceToEnterState (SC_HANDLE   shService, 
					   DWORD       dwMaxDelayInMilliSeconds, 
					   const DWORD dwDesiredState)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"WaitForServiceToEnterState");

    DWORD		dwRemainingDelay = dwMaxDelayInMilliSeconds;
    DWORD		dwInitialState;
    const DWORD		dwServiceStatePollingIntervalInMilliSeconds = 100;
    BOOL		bSucceeded;
    SERVICE_STATUS	sSStat;



    try
	{
	bSucceeded = QueryServiceStatus (shService, &sSStat);

	ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);

	dwInitialState = sSStat.dwCurrentState;

	ft.Trace (VSSDBG_SHIM,
		  L"Initial QueryServiceStatus returned: 0x%08X with current state '%s' and desired state '%s'",
		  ft.hr,
		  GetStringFromStateCode (dwInitialState),
		  GetStringFromStateCode (dwDesiredState));


	while ((dwDesiredState != sSStat.dwCurrentState) && (dwRemainingDelay > 0))
	    {
	    Sleep (UMIN (dwServiceStatePollingIntervalInMilliSeconds, dwRemainingDelay));

	    dwRemainingDelay -= (UMIN (dwServiceStatePollingIntervalInMilliSeconds, dwRemainingDelay));

	    if (0 == dwRemainingDelay)
		{
		ft.Throw (VSSDBG_SHIM,
			  HRESULT_FROM_WIN32 (ERROR_TIMEOUT),
			  L"Exceeded maximum delay (%dms)",
			  dwMaxDelayInMilliSeconds);
		}

	    bSucceeded = QueryServiceStatus (shService, &sSStat);

	    ft.ThrowIf (!bSucceeded,
			VSSDBG_SHIM,
			GET_STATUS_FROM_BOOL (bSucceeded),
			L"QueryServiceStatus shows '%s' as current state",
			GetStringFromStateCode (sSStat.dwCurrentState));
	    }



	ft.Trace (VSSDBG_SHIM,
		  L"Service state change from '%s' to '%s' took %u milliseconds",
		  GetStringFromStateCode (dwInitialState),
		  GetStringFromStateCode (sSStat.dwCurrentState),
		  dwMaxDelayInMilliSeconds - dwRemainingDelay);
	}
    VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* WaitForServiceToEnterState () */

/*
**++
**
**  Routine Description:
**
**	Changes the state of a service if appropriate.
**
**
**  Arguments:
**
**	pwszServiceName		The real service name, i.e. cisvc
**	dwRequestedState	the state code for the state we wish to enter
**	pdwReturnedOldState	pointer to location to receive current service state.
**				Can be NULL of current state not required
**	pbReturnedStateChanged	pointer to location to receive flag indicating if  
**				service changed state. Pointer can be NULL if flag
**				value not required.
**
**
**  Return Value:
**
**	Any HRESULT resulting from faiure communication with the
**	SCM (Service Control Manager).
**
**--
*/

HRESULT VsServiceChangeState (LPCWSTR	pwszServiceName,
			      DWORD	dwRequestedState,
			      PDWORD	pdwReturnedOldState,
			      PBOOL	pbReturnedStateChanged)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VsServiceChangeState");

    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;
    DWORD		dwOldState  = 0;
    BOOL		bSucceeded;
    SERVICE_STATUS	sSStat;
    const DWORD		dwNormalisedRequestedState = GetNormalisedState (dwRequestedState);


    ft.Trace (VSSDBG_SHIM,
	      L"Service '%s' requested to change to state '%s' (normalised to '%s')",
	      pwszServiceName,
	      GetStringFromStateCode (dwRequestedState),
	      GetStringFromStateCode (dwNormalisedRequestedState));


    RETURN_VALUE_IF_REQUIRED (pbReturnedStateChanged, FALSE);


    try
	{
        /*
	**  Connect to the local service control manager
        */
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

	ft.hr = GET_STATUS_FROM_HANDLE (shSCManager);

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"Called OpenSCManager()");


        /*
	**  Get a handle to the service
        */
        shSCService = OpenService (shSCManager, pwszServiceName, SERVICE_ALL_ACCESS);

	ft.hr = GET_STATUS_FROM_HANDLE (shSCService);


	/*
	** If it's an invalid name or the service doesn't exist then
	** fail gracefully. For all other failures do the normal
	** thing. Oh yes, if on the off-chance we should happen to
	** succeed, carry on.
	*/
	if ((HRESULT_FROM_WIN32 (ERROR_INVALID_NAME)           == ft.hr) ||
	    (HRESULT_FROM_WIN32 (ERROR_SERVICE_DOES_NOT_EXIST) == ft.hr))
	    {
	    ft.Trace (VSSDBG_SHIM, L"'%s' service not found", pwszServiceName);
	    }

	else if (ft.HrFailed ())
	    {
	    /*
	    ** See if the service doesn't exist
            */
	    ft.Throw (VSSDBG_SHIM, E_FAIL, L"ERROR - OpenService() returned: %d", ft.hr);
	    }

        else
	    {
            /*
	    ** Now query the service to see what state it is in at the moment.
            */
	    bSucceeded = QueryServiceStatus (shSCService, &sSStat);

	    ft.ThrowIf (!bSucceeded,
			VSSDBG_SHIM,
			GET_STATUS_FROM_BOOL (bSucceeded),
			L"QueryServiceStatus shows '%s' as current state",
			GetStringFromStateCode (sSStat.dwCurrentState));


	    dwOldState = sSStat.dwCurrentState;



	    /*
	    ** Now we decide what to do.
	    **	    If we are already in the requested state, we do nothing.
	    **	    If we are stopped and are requested to pause, we do nothing
	    **	    otherwise we make the attempt to change state.
	    */
            if (dwNormalisedRequestedState == dwOldState)
		{
		/*
		** We are already in the requested state, so do
		** nothing. We should even tell folk of that. We're
		** proud to be doing nothing.
		*/
                ft.Trace (VSSDBG_SHIM,
			  L"'%s' service is already in requested state: doing nothing",
			  pwszServiceName);

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState, dwOldState);
		}

	    else if ((SERVICE_STOPPED == sSStat.dwCurrentState) && (SERVICE_PAUSED == dwNormalisedRequestedState))
		{
		/*
		** Do nothing. Just log the fact and move on.
		*/
		ft.Trace (VSSDBG_SHIM,
			  L"Asked to PAUSE the '%s' service which is already STOPPED",
			  pwszServiceName);

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState, dwOldState);
		}

	    else
		{
		/*
		** We want a state which is different from the one
		** we're in at the moment. Generally this just means
		** calling ControlService() asking for the new state
		** except if the service is currently stopped. If
		** that's so, then we call StartService()
		*/
		if (SERVICE_STOPPED == sSStat.dwCurrentState)
		    {
		    /*
		    ** Call StartService to get the ball rolling
		    */
		    bSucceeded = StartService (shSCService, 0, NULL);
		    }

		else
		    {
		    bSucceeded = ControlService (shSCService,
						 GetControlCodeFromTargetState (dwNormalisedRequestedState),
						 &sSStat);
		    }

		ft.ThrowIf (!bSucceeded,
			    VSSDBG_SHIM,
			    GET_STATUS_FROM_BOOL (bSucceeded),
			    (SERVICE_STOPPED == sSStat.dwCurrentState)
							? L"StartService attempting '%s' to '%s', now at '%s'"
							: L"ControlService attempting '%s' to '%s', now at '%s'",
			    GetStringFromStateCode (dwOldState),
			    GetStringFromStateCode (dwNormalisedRequestedState),
			    GetStringFromStateCode (sSStat.dwCurrentState));

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState,    dwOldState);
		RETURN_VALUE_IF_REQUIRED (pbReturnedStateChanged, TRUE);


		ft.hr = WaitForServiceToEnterState (shSCService, 15000, dwNormalisedRequestedState);

		if (ft.HrFailed ())
		    {
		    ft.Throw (VSSDBG_SHIM,
			      ft.hr,
			      L"WaitForServiceToEnterState() failed with 0x%08X",
			      ft.hr);
		    }

		}
	    }
	} VSS_STANDARD_CATCH (ft);



    /*
    **  Now close the service and service control manager handles
    */
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);

    return (ft.hr);
    } /* VsServiceChangeState () */

/*
**++
**
**  Routine Description:
**
**	Deletes all the sub-directories and files in the specified
**	directory and then deletes the directory itself.
**
**
**
**  Arguments:
**
**	pucsDirectoryPath	The diretory path to clear out
**
**
**  Side Effects:
**
**	None
**
**
**  Return Value:
**
**	Out of memory or any HRESULT from
**
**		RemoveDirectory()
**		DeleteFile()
**		FindFirstFile()
**
**--
*/

HRESULT RemoveDirectoryTree (PUNICODE_STRING pucsDirectoryPath)
    {
    HRESULT		hrStatus                = NOERROR;
    HANDLE		hFileScan               = INVALID_HANDLE_VALUE;
    DWORD		dwSubDirectoriesEntered = 0;
    USHORT		usCurrentPathCursor     = 0;
    PWCHAR		pwchLastSlash           = NULL;
    BOOL		bContinue               = TRUE;
    BOOL		bSucceeded;
    UNICODE_STRING	ucsCurrentPath;
    WIN32_FIND_DATAW	FileFindData;


    StringInitialise (&ucsCurrentPath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromString (&ucsCurrentPath, pucsDirectoryPath, MAX_PATH);
	}


    pwchLastSlash = wcsrchr (ucsCurrentPath.Buffer, DIR_SEP_CHAR);

    usCurrentPathCursor = (USHORT)(pwchLastSlash - ucsCurrentPath.Buffer) + 1;



    while (SUCCEEDED (hrStatus) && bContinue)
	{
	if (HandleInvalid (hFileScan))
	    {
	    /*
	    ** No valid scan handle so start a new scan
	    */
	    hFileScan = FindFirstFileW (ucsCurrentPath.Buffer, &FileFindData);

	    hrStatus = GET_STATUS_FROM_HANDLE (hFileScan);

	    if (SUCCEEDED (hrStatus))
		{
		StringTruncate (&ucsCurrentPath, usCurrentPathCursor);

		hrStatus = StringAppendString (&ucsCurrentPath, FileFindData.cFileName);
		}
	    }

	else
	    {
	    /*
	    ** Continue with the existing scan
	    */
	    bSucceeded = FindNextFileW (hFileScan, &FileFindData);

	    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	    if (SUCCEEDED (hrStatus))
		{
		StringTruncate (&ucsCurrentPath, usCurrentPathCursor);

		hrStatus = StringAppendString (&ucsCurrentPath, FileFindData.cFileName);
		}
		
	    else if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_FILES) == hrStatus)
		{
		FindClose (hFileScan);
		hFileScan = INVALID_HANDLE_VALUE;

		if (dwSubDirectoriesEntered > 0)
		    {
		    /*
		    ** This is a scan of a sub-directory that is now 
		    ** complete so delete the sub-directory itself.
		    */
		    StringTruncate (&ucsCurrentPath, usCurrentPathCursor - 1);

		    bSucceeded = RemoveDirectory (ucsCurrentPath.Buffer);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


		    dwSubDirectoriesEntered--;
		    }


		if (0 == dwSubDirectoriesEntered)
		    {
		    /*
		    ** We are back to where we started except that the 
		    ** requested directory is now gone. Time to leave.
		    */
		    bContinue = FALSE;
		    hrStatus  = NOERROR;
		    }

		else
		    {
		    /*
		    ** Move back up one directory level, reset the cursor 
		    ** and prepare the path buffer to begin a new scan.
		    */
		    pwchLastSlash = wcsrchr (ucsCurrentPath.Buffer, DIR_SEP_CHAR);

		    usCurrentPathCursor = (USHORT)(pwchLastSlash - ucsCurrentPath.Buffer) + 1;


		    StringTruncate (&ucsCurrentPath, usCurrentPathCursor);
		    StringAppendString (&ucsCurrentPath, L"*");
		    }


		/*
		** No files to be processed on this pass so go back and try to 
		** find another or leave the loop as we've finished the task. 
		*/
		continue;
		}
	    }



	if (SUCCEEDED (hrStatus))
	    {
	    if (FileFindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
		{
		SetFileAttributesW (ucsCurrentPath.Buffer, 
				    FileFindData.dwFileAttributes ^ (FILE_ATTRIBUTE_READONLY));
		}


	    if (!NameIsDotOrDotDot (FileFindData.cFileName))
		{
		if ( (FileFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||
		    !(FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		    {
		    bSucceeded = DeleteFileW (ucsCurrentPath.Buffer);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
		    }

		else
		    {
		    bSucceeded = RemoveDirectory (ucsCurrentPath.Buffer);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


		    if (HRESULT_FROM_WIN32 (ERROR_DIR_NOT_EMPTY) == hrStatus)
			{
			/*
			** The directory wasn't empty so move down one level, 
			** close the old scan and start a new one. 
			*/
			FindClose (hFileScan);
			hFileScan = INVALID_HANDLE_VALUE;


			hrStatus = StringAppendString (&ucsCurrentPath, DIR_SEP_STRING L"*");

			if (SUCCEEDED (hrStatus))
			    {
			    usCurrentPathCursor = (ucsCurrentPath.Length / sizeof (WCHAR)) - 1;

			    dwSubDirectoriesEntered++;
			    }
			}
		    }
		}
	    }
	}



    if (!HandleInvalid (hFileScan)) FindClose (hFileScan);

    StringFree (&ucsCurrentPath);


    return (hrStatus);
    } /* RemoveDirectoryTree () */

/*
**++
**
**  Routine Description:
**
**	Moves the contents of the source directory to the target directory.
**
**
**  Arguments:
**
**	pucsSourceDirectoryPath	Source directory for the files to be moved
**	pucsTargetDirectoryPath	Target directory for the files to be moved
**
**
**  Side Effects:
**
**	Will append a trailing '\' character on the directory paths if 
**	not already present
**
**	An intermediate error can leave directory in a partial moved
**	state where some of the files have been moved but not all.
**
**
**  Return Value:
**
**	Any HRESULT from FindFirstFile() etc or from MoveFileEx()
**
**-- 
*/

HRESULT MoveFilesInDirectory (PUNICODE_STRING pucsSourceDirectoryPath,
			      PUNICODE_STRING pucsTargetDirectoryPath)
    {
    HRESULT		hrStatus              = NOERROR;
    HANDLE		hFileScan             = INVALID_HANDLE_VALUE;
    BOOL		bMoreFiles;
    BOOL		bSucceeded;
    USHORT		usOriginalSourcePathLength;
    USHORT		usOriginalTargetPathLength;
    WIN32_FIND_DATA	sFileInformation;


    if (DIR_SEP_CHAR != pucsSourceDirectoryPath->Buffer [(pucsSourceDirectoryPath->Length / sizeof (WCHAR)) - 1])
	{
	StringAppendString (pucsSourceDirectoryPath, DIR_SEP_STRING);
	}


    if (DIR_SEP_CHAR != pucsTargetDirectoryPath->Buffer [(pucsTargetDirectoryPath->Length / sizeof (WCHAR)) - 1])
	{
	StringAppendString (pucsTargetDirectoryPath, DIR_SEP_STRING);
	}


    usOriginalSourcePathLength = pucsSourceDirectoryPath->Length / sizeof (WCHAR);
    usOriginalTargetPathLength = pucsTargetDirectoryPath->Length / sizeof (WCHAR);

    StringAppendString (pucsSourceDirectoryPath, L"*");
	

    hFileScan = FindFirstFileW (pucsSourceDirectoryPath->Buffer,
				&sFileInformation);

    hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != hFileScan);



    if (SUCCEEDED (hrStatus))
	{
	do
	    {
	    if (!NameIsDotOrDotDot (sFileInformation.cFileName))
		{
		StringTruncate (pucsSourceDirectoryPath, usOriginalSourcePathLength);
		StringTruncate (pucsTargetDirectoryPath, usOriginalTargetPathLength);

		StringAppendString (pucsSourceDirectoryPath, sFileInformation.cFileName);
		StringAppendString (pucsTargetDirectoryPath, sFileInformation.cFileName);

		bSucceeded = MoveFileExW (pucsSourceDirectoryPath->Buffer,
					  pucsTargetDirectoryPath->Buffer,
					  MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING);

		hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
		}

	    bMoreFiles = FindNextFileW (hFileScan, &sFileInformation);
	    } while (SUCCEEDED (hrStatus) && bMoreFiles);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    ** If the last move operation was successful determine the
	    ** reason for terminating the scan. No need to report an
	    ** error if all that happened was that we have finished
	    ** what we were asked to do.
	    */
	    hrStatus = GET_STATUS_FROM_FILESCAN (bMoreFiles);
	    }

	bSucceeded = FindClose (hFileScan);
	}



    /*
    ** No matter what, make sure that the path going back out is no
    ** longer than the source string plus a possible trailing '\'
    */
    StringTruncate (pucsSourceDirectoryPath, usOriginalSourcePathLength);
    StringTruncate (pucsTargetDirectoryPath, usOriginalTargetPathLength);

    return (hrStatus);
    }

/*
**++
**
**  Routine Description:
**
**	Checks a path against an array of pointers to volume names to
**	see if path is affected by any of the volumes in the array
**
**
**  Arguments:
**
**	pwszPath			Path to be checked
**	ulVolumeCount			Number of volumes in volume array
**	ppwszVolumeNamesArray		address of the array
**	pbReturnedFoundInVolumeArray	pointer to a location to store the 
**					result of the check
**
**
**  Side Effects:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from:-
**		GetVolumePathNameW()
**		GetVolumeNameForVolumeMountPoint()
**
**-- 
*/

HRESULT IsPathInVolumeArray (IN LPCWSTR      pwszPath,
			     IN const ULONG  ulVolumeCount,
			     IN LPCWSTR     *ppwszVolumeNamesArray,
			     OUT PBOOL       pbReturnedFoundInVolumeArray) 
    {
    HRESULT		hrStatus  = NOERROR;
    BOOL		bFound    = FALSE;
    BOOL		bContinue = TRUE;
    ULONG		ulIndex;
    WCHAR		wszVolumeName [MAX_VOLUMENAME_LENGTH];
    UNICODE_STRING	ucsVolumeMountPoint;


    StringInitialise (&ucsVolumeMountPoint);


    if ((0 == ulVolumeCount) || (NULL == pbReturnedFoundInVolumeArray))
	{
	BS_ASSERT (false);

	bContinue = FALSE;
	}



    if (bContinue) 
	{
	/*
	** We need a string that is at least as big as the supplied
	** path. 
	*/
	hrStatus = StringAllocate (&ucsVolumeMountPoint, wcslen (pwszPath) * sizeof (WCHAR));

	bContinue = SUCCEEDED (hrStatus);
	}



    if (bContinue) 
	{
	/*
	** Get the volume mount point
	*/
	bContinue = GetVolumePathNameW (pwszPath, 
					ucsVolumeMountPoint.Buffer, 
					ucsVolumeMountPoint.MaximumLength / sizeof (WCHAR));

	hrStatus = GET_STATUS_FROM_BOOL (bContinue);
	}



    if (bContinue)
	{
	/*
	** Get the volume name
	*/
	bContinue = GetVolumeNameForVolumeMountPointW (ucsVolumeMountPoint.Buffer, 
						       wszVolumeName, 
						       SIZEOF_ARRAY (wszVolumeName));

	hrStatus = GET_STATUS_FROM_BOOL (bContinue);
	}


    if (bContinue)
	{
	/*
	** Search to see if that volume is within snapshotted volumes
	*/
	for (ulIndex = 0; !bFound && (ulIndex < ulVolumeCount); ulIndex++)
	    {
	    BS_ASSERT (NULL != ppwszVolumeNamesArray [ulIndex]);

	    if (0 == wcscmp (wszVolumeName, ppwszVolumeNamesArray [ulIndex]))
		{
		bFound = TRUE;
		}
	    }
	}



    RETURN_VALUE_IF_REQUIRED (pbReturnedFoundInVolumeArray, bFound);

    StringFree (&ucsVolumeMountPoint);

    return (hrStatus);
    } /* IsPathInVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal writer errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
**		
**
**-- 
*/

const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure)
    {
    BOOL bStatusUpdated;

    return (ClassifyWriterFailure (hrWriterFailure, bStatusUpdated));
    } /* ClassifyWriterFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal writer errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**	bStatusUpdated	TRUE if the status is re-mapped 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **		
**
**-- 
*/

const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated)
    {
    HRESULT hrStatus;


    switch (hrWriterFailure)
	{
	case NOERROR:
	case VSS_E_WRITERERROR_OUTOFRESOURCES:
	case VSS_E_WRITERERROR_RETRYABLE:
	case VSS_E_WRITERERROR_NONRETRYABLE:
	case VSS_E_WRITERERROR_TIMEOUT:
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
	    /*
	    ** These are ok as they are so no need to transmogrify them.
	    */
	    hrStatus       = hrWriterFailure;
	    bStatusUpdated = FALSE;
	    break;


	case E_OUTOFMEMORY:
	case HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_SEARCH_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_USER_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_LOG_SPACE):
	case HRESULT_FROM_WIN32 (ERROR_DISK_FULL):
	    hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_READY):
	    hrStatus       = VSS_E_WRITERERROR_RETRYABLE;
	    bStatusUpdated = TRUE;
            break;


	case HRESULT_FROM_WIN32 (ERROR_TIMEOUT):
	    hrStatus       = VSS_E_WRITERERROR_TIMEOUT;
	    bStatusUpdated = TRUE;
	    break;



	case E_UNEXPECTED:
	case E_INVALIDARG:	// equal to HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER)
	case E_ACCESSDENIED:
	case HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_PRIVILEGE_NOT_HELD):
	case HRESULT_FROM_WIN32 (ERROR_NOT_LOCKED):
	case HRESULT_FROM_WIN32 (ERROR_LOCKED):

	default:
	    hrStatus       = VSS_E_WRITERERROR_NONRETRYABLE;
	    bStatusUpdated = TRUE;
	    break;
	}


    return (hrStatus);
    } /* ClassifyWriterFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **--
*/

const HRESULT ClassifyShimFailure (HRESULT hrWriterFailure)
    {
    BOOL bStatusUpdated;

    return (ClassifyShimFailure (hrWriterFailure, bStatusUpdated));
    } /* ClassifyShimFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**	bStatusUpdated	TRUE if the status is re-mapped 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_BAD_STATE
**		VSS_E_SNAPSHOT_SET_IN_PROGRESS
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **--
*/

const HRESULT ClassifyShimFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated)
    {
    HRESULT hrStatus;


    switch (hrWriterFailure)
	{
	case NOERROR:
	case E_OUTOFMEMORY:
	case E_ACCESSDENIED:
	case E_INVALIDARG:	// equal to HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER)
	case E_UNEXPECTED:
	case VSS_E_BAD_STATE:
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
	case VSS_E_WRITERERROR_RETRYABLE:
	case VSS_E_WRITERERROR_NONRETRYABLE:
	case VSS_E_WRITERERROR_TIMEOUT:
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
	case VSS_E_WRITERERROR_OUTOFRESOURCES:
	    /*
	    ** These are ok as they are so no need to transmogrify them.
	    */
	    hrStatus       = hrWriterFailure;
	    bStatusUpdated = FALSE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_LOCKED):
	    hrStatus       = VSS_E_BAD_STATE;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_LOCKED):
	    hrStatus       = VSS_E_SNAPSHOT_SET_IN_PROGRESS;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_SEARCH_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_USER_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_LOG_SPACE):
	case HRESULT_FROM_WIN32 (ERROR_DISK_FULL):
	    hrStatus       = E_OUTOFMEMORY;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_PRIVILEGE_NOT_HELD):
	    hrStatus       = E_ACCESSDENIED;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_TIMEOUT):
	case HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_NOT_READY):

	default:
	    hrStatus       = E_UNEXPECTED;
	    bStatusUpdated = TRUE;
	    break;
	}


    return (hrStatus);
    } /* ClassifyShimFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim or shim
**	writer errors into one of the narrow set of responses we are
**	permitted to send back to the requestor.
**
**	The determination is made to classify either as a shim error
**	or as a writer error based upon whether or not a writer name
**	is supplied. If it is supplied then the assumption is made
**	that this is a writer failure and so the error is classified
**	accordingly.
**
**	Note that this is a worker routine for the LogFailure() macro
**	and the two are intended to be used in concert.
**
**
**  Arguments:
**
**	pft			Pointer to a Function trace class
**	pwszNameWriter		The name of the applicable writer or NULL or L""
**	pwszNameCalledRoutine	The name of the routine that returned the failure status
**
**
**  Side Effects:
**
**	hr field of *pft updated 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_BAD_STATE
**		VSS_E_SNAPSHOT_SET_IN_PROGRESS
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
**
**--
*/

HRESULT LogFailureWorker (CVssFunctionTracer	*pft,
			  LPCWSTR		 pwszNameWriter,
			  LPCWSTR		 pwszNameCalledRoutine)
    {
    if (pft->HrFailed ())
	{
	BOOL	bStatusRemapped;
	HRESULT	hrStatusClassified = ((NULL == pwszNameWriter) || (L'\0' == pwszNameWriter [0])) 
						? ClassifyShimFailure   (pft->hr, bStatusRemapped)
						: ClassifyWriterFailure (pft->hr, bStatusRemapped);

	if (bStatusRemapped)
	    {
	    if (((NULL == pwszNameCalledRoutine) || (L'\0' == pwszNameCalledRoutine [0])) &&
		((NULL == pwszNameWriter)        || (L'\0' == pwszNameWriter [0])))
		{
		pft->LogError (VSS_ERROR_SHIM_GENERAL_FAILURE,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED with status 0x%08lX (converted to 0x%08lX)",
			    pft->hr,
			    hrStatusClassified);
		}


	    else if ((NULL == pwszNameCalledRoutine) || (L'\0' == pwszNameCalledRoutine [0]))
		{
		pft->LogError (VSS_ERROR_SHIM_WRITER_GENERAL_FAILURE,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified << pwszNameWriter);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED in writer %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameWriter,
			    pft->hr,
			    hrStatusClassified);
		}


	    else if ((NULL == pwszNameWriter) || (L'\0' == pwszNameWriter [0]))
		{
		pft->LogError (VSS_ERROR_SHIM_FAILED_SYSTEM_CALL,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified <<  pwszNameCalledRoutine);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED calling routine %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameCalledRoutine,
			    pft->hr,
			    hrStatusClassified);
		}


	    else
		{
		pft->LogError (VSS_ERROR_SHIM_WRITER_FAILED_SYSTEM_CALL,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified << pwszNameWriter << pwszNameCalledRoutine);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED in writer %s calling routine %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameWriter,
			    pwszNameCalledRoutine,
			    pft->hr,
			    hrStatusClassified);
		}

	    pft->hr = hrStatusClassified;
	    }
	}


    return (pft->hr);
    } /* LogFailureWorker () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\delayloadhandler.cpp ===
//***************************************************************************

//

//  DELAYLOADHANDLER.CPP

//

//  Module: Delay load handler functions

//

//  Purpose: When delay loaded libraries either fail to load, or functions

//           in them are not found, this handler is called as a result of

//           the //DELAYLOAD linker specification.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <delayimp.h>


// Skeleton DliHook function that does nothing interesting
FARPROC WINAPI DliHook(
    unsigned dliNotify,
    PDelayLoadInfo pdli)
{
   FARPROC fp = NULL;   // Default return value

   // NOTE: The members of the DelayLoadInfo structure pointed
   // to by pdli shows the results of progress made so far.

   switch (dliNotify)
   {
   case dliStartProcessing:
      // Called when __delayLoadHelper attempts to find a DLL/function
      // Return 0 to have normal behavior, or non-0 to override
      // everything (you will still get dliNoteEndProcessing)
      break;

   case dliNotePreLoadLibrary:
      // Called just before LoadLibrary
      // Return NULL to have __delayLoadHelper call LoadLibary
      // or you can call LoadLibrary yourself and return the HMODULE
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliFailLoadLib:
      // Called if LoadLibrary fails
      // Again, you can call LoadLibary yourself here and return an HMODULE
      // If you return NULL, __delayLoadHelper raises the
      // ERROR_MOD_NOT_FOUND exception
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliNotePreGetProcAddress:
      // Called just before GetProcAddress
      // Return NULL to have __delayLoadHelper call GetProcAddress
      // or you can call GetProcAddress yourself and return the address
      fp = (FARPROC) NULL;
      break;

   case dliFailGetProc:
      // Called if GetProcAddress fails
      // Again, you can call GetProcAddress yourself here and return an address
      // If you return NULL, __delayLoadHelper raises the
      // ERROR_PROC_NOT_FOUND exception
      fp = (FARPROC) NULL;
      break;

   case dliNoteEndProcessing:
      // A simple notification that __delayLoadHelper is done
      // You can examine the members of the DelayLoadInfo structure
      // pointed to by pdli and raise an exception if you desire
      break;
   }

   return(fp);
}

// Tell __delayLoadHelper to call my hook function
PfnDliHook __pfnDliNotifyHook  = DliHook;
PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\common.h ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrcomdb.cpp | Implementation of SnapshotWriter for COM+ Registration Database



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-15	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-14	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of Bootable (aka System) state directories
		        and add one for Service state
		        Added new variations of StringCreateFromExpandedString()
		        StringInitialise() and StringCreateFromString() 
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree().

	X-13	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.
			Remove ANSI version of StringXxxx() routines.
			Remove VsGetVolumeNameFromPath()
			Remove VsCheckPathAgainstVolumeNameList()
			Remove CheckShimPrivileges()

	X-12	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-11	MCJ		Michael C. Johnson		15-May-2000
		108586: Add CheckShimPrivileges() to check for the privs we 
		        require to invoke the public shim routines.

	X-10	MCJ		Michael C. Johnson		23-Mar-2000
		Add routines MoveFilesInDirectory() and EmptyDirectory()

	X-9	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-8	MCJ		Michael C. Johnson		 6-Mar-2000
		Add VsServiceChangeState () which should deal with all the
		service states that we are interested in.

	X-7	MCJ		Michael C. Johnson		29-Feb-2000
		Add macro to determine error code associated with termination
		of a filescan loop.

	X-6	MCJ		Michael C. Johnson		23-Feb-2000
		Add common context manipulation routines including state
		tracking and checking.

	X-5	MCJ		Michael C. Johnson		22-Feb-2000
		Add definition of SYSTEM_STATE_SUBDIR to allow further
		separation of writers involved in system state related
		backups.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Move definition of ROOT_BACKUP_DIR here from common.cpp

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Added additional StringXxxx () routines and routines to
		turn on backup priviledges and restore priviledges.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Added a declaration of CommonCloseHandle().

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/



#ifndef __H_COMMON_
#define __H_COMMON_

#pragma once


typedef PBYTE	*PPBYTE;
typedef	ULONG64	 FILEID,   *PFILEID;
typedef	DWORD	 VOLUMEID, *PVOLUMEID;
typedef	DWORD	 THREADID, *PTHREADID;
typedef PTCHAR	*PPTCHAR;
typedef PWCHAR	*PPWCHAR;
typedef PVOID	*PPVOID;

typedef VSS_ID	*PVSS_ID, **PPVSS_ID;




#define ROOT_BACKUP_DIR		L"%SystemRoot%\\Repair\\Backup"
#define BOOTABLE_STATE_SUBDIR	L"\\BootableSystemState"
#define SERVICE_STATE_SUBDIR	L"\\ServiceState"




/*
** In a number of places we need a buffer into which to fetch registry
** values. Define a common buffer size for the mini writers to use
*/
#ifndef REGISTRY_BUFFER_SIZE
#define REGISTRY_BUFFER_SIZE	(4096)
#endif

#ifndef MAX_VOLUMENAME_LENGTH
#define MAX_VOLUMENAME_LENGTH	(50)
#endif

#ifndef MAX_VOLUMENAME_SIZE
#define MAX_VOLUMENAME_SIZE	(MAX_VOLUMENAME_LENGTH * sizeof (WCHAR))
#endif

#ifndef DIR_SEP_STRING
#define DIR_SEP_STRING		L"\\"
#endif

#ifndef DIR_SEP_CHAR
#define DIR_SEP_CHAR		L'\\'
#endif


#ifndef UMIN
#define UMIN(_P1, _P2) (((_P1) < (_P2)) ? (_P1) : (_P2))
#endif


#ifndef UMAX
#define UMAX(_P1, _P2) (((_P1) > (_P2)) ? (_P1) : (_P2))
#endif


#define HandleInvalid(_Handle)			((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))

#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)             ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)

#define GET_STATUS_FROM_FILESCAN(_bMoreFiles)	((_bMoreFiles)					\
						 ? NOERROR 					\
						 : ((ERROR_NO_MORE_FILES == GetLastError())	\
						    ? NOERROR					\
						    : HRESULT_FROM_WIN32 (GetLastError())))


#define ROUNDUP(_value, _boundary) (((_value) + (_boundary) - 1) & ( ~((_boundary) - 1)))


#define NameIsDotOrDotDot(_ptszName)	(( '.'  == (_ptszName) [0]) &&					\
					 (('\0' == (_ptszName) [1]) || (('.'  == (_ptszName) [1]) && 	\
									('\0' == (_ptszName) [2]))))


#define DeclareStaticUnicodeString(_StringName, _StringValue)								\
				static UNICODE_STRING (_StringName) = {sizeof (_StringValue) - sizeof (UNICODE_NULL),	\
								       sizeof (_StringValue),				\
								       _StringValue}


#define RETURN_VALUE_IF_REQUIRED(_Ptr, _Value) {if (NULL != (_Ptr)) *(_Ptr) = (_Value);}

#define SIZEOF_ARRAY(_aBase)	               (sizeof (_aBase) / sizeof ((_aBase)[0]))




HRESULT StringInitialise                  (PUNICODE_STRING pucsString);
HRESULT StringInitialise                  (PUNICODE_STRING pucsString, PWCHAR pwszString);
HRESULT StringInitialise                  (PUNICODE_STRING pucsString, LPCWSTR pwszString);
HRESULT StringTruncate                    (PUNICODE_STRING pucsString, USHORT usSizeInChars);
HRESULT StringSetLength                   (PUNICODE_STRING pucsString);
HRESULT StringAllocate                    (PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes);
HRESULT StringFree                        (PUNICODE_STRING pucsString);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString, DWORD dwExtraChars);
HRESULT StringAppendString                (PUNICODE_STRING pucsTarget,    PUNICODE_STRING pucsSource);
HRESULT StringAppendString                (PUNICODE_STRING pucsTarget,    PWCHAR          pwszSource);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString, DWORD dwExtraChars);

HRESULT CommonCloseHandle                 (PHANDLE phHandle);


HRESULT VsServiceChangeState (IN  LPCWSTR pwszServiceName, 
			      IN  DWORD   dwRequestedState, 
			      OUT PDWORD  pdwReturnedOldState,
			      OUT PBOOL   pbReturnedStateChanged);

BOOL VsCreateDirectories (IN LPCWSTR               pwszPathName, 
			  IN LPSECURITY_ATTRIBUTES lpSecurityAttribute,
			  IN DWORD                 dwExtraAttributes);

HRESULT RemoveDirectoryTree (PUNICODE_STRING pucsDirectoryPath);

HRESULT MoveFilesInDirectory (PUNICODE_STRING pucsSourceDirectoryPath,
			      PUNICODE_STRING pucsTargetDirectoryPath);


HRESULT IsPathInVolumeArray (IN LPCWSTR      pwszPath,
			     IN const ULONG  ulVolumeCount,
			     IN LPCWSTR     *ppwszVolumeNamesArray,
			     OUT PBOOL       pbReturnedFoundInVolumeArray);


const HRESULT ClassifyShimFailure   (HRESULT hrShimFailure);
const HRESULT ClassifyShimFailure   (HRESULT hrShimFailure, BOOL &bStatusUpdated);
const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure);
const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated);



HRESULT LogFailureWorker (CVssFunctionTracer	*pft,
			  LPCWSTR		 pwszNameWriter,
			  LPCWSTR		 pwszNameCalledRoutine);


#define LogFailure(_pft, _hrStatus, _hrStatusRemapped, _pwszNameWriter, _pwszNameCalledRoutine, _pwszNameCallingRoutine)				\
		{																	\
		if (FAILED (_hrStatus))															\
		    {																	\
		    if (CVssFunctionTracer  *_pftLocal = (NULL != (_pft)) ? (_pft) : new CVssFunctionTracer (VSSDBG_SHIM, (_pwszNameCallingRoutine)))	\
				{															\
    		    _pftLocal->hr = (_hrStatus);													\
    																			\
    		    (_hrStatusRemapped) = LogFailureWorker (_pftLocal, (_pwszNameWriter), (_pwszNameCalledRoutine));					\
    																			\
    		    if (NULL == (_pft)) delete _pftLocal;												\
	    	    }                                                               \
		    }																	\
		}


#define LogAndThrowOnFailure(_ft, _pwszNameWriter, _pwszNameFailedRoutine)									\
			{															\
			HRESULT		_hrStatusRemapped;											\
																		\
			if (FAILED ((_ft).hr))													\
			    {															\
			    LogFailure (&(_ft), (_ft).hr, _hrStatusRemapped, (_pwszNameWriter), (_pwszNameFailedRoutine), L"(UNKNOWN)");	\
																		\
			    throw (_hrStatusRemapped);												\
			    }															\
			}



#endif // __H_COMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Precompiled header file.

Author:

    Stefan R. Steiner   [ssteiner]        02-01-2000

Revision History:

	X-3	MCJ		Michael C. Johnson		12-Jun-2000
		Added vswriter.h and vsbackup.h

	X-2	MCJ		Michael C. Johnson		 6-Mar-2000
		Added coord.h and vsevent.h to include list.

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

#pragma once

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)
#pragma warning(disable:4201)    // C4201: nonstandard extension used : nameless struct/union

// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#undef _ASSERTE

#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>

#include "vs_assert.hxx"

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <stddef.h>
#include <oleauto.h>
#include <atlconv.h>
#include <atlbase.h>

#include "vs_inc.hxx"

#include "vs_idl.hxx"
#include <vswriter.h>
#include <vsbackup.h>


#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\jetwriter.cpp ===
#include <stdafx.h>

#include <esent.h>
#include <comadmin.h>
#include "vs_inc.hxx"

#include "vs_idl.hxx"


#include "comadmin.hxx"
#include "vswriter.h"

#include <jetwriter.h>
#include <ijetwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHJTWRC"
//
////////////////////////////////////////////////////////////////////////

// destructor
__declspec(dllexport) CVssJetWriter::~CVssJetWriter()
	{
	BS_ASSERT(m_pWriter == NULL);
	}


// routine for passing arguments between threads
typedef struct _JW_INIT_ARGS
	{
	VSS_ID idWriter;
	LPCWSTR wszWriterName;
	bool bSystemService;
	bool bBootableSystemState;
	LPCWSTR wszFilesToInclude;
	LPCWSTR wszFilesToExclude;
	CVssJetWriter *pobj;
	} JW_INIT_ARGS;


// separate MTA thread for doing initialization
DWORD CVssJetWriter::InitializeThreadFunc(VOID *pv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"InitializeThreadFunc");

	JW_INIT_ARGS *pargs = (JW_INIT_ARGS *) pv;

	try
		{
		// intialize MTA thread
		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        // call internal object to initialize
		ft.hr = CVssIJetWriter::Initialize
						(
						pargs->idWriter,
						pargs->wszWriterName,
						pargs->bSystemService,
						pargs->bBootableSystemState,
						pargs->wszFilesToInclude,
						pargs->wszFilesToExclude,
						pargs->pobj,
						&pargs->pobj->m_pWriter
						);


        if(ft.HrFailed())
			ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"CvssIJetWriter::Initialize failed");
		}
	VSS_STANDARD_CATCH(ft)

	// save result of initialization
	pargs->pobj->m_hrInitialized = ft.hr;
	return 0;
	}


// initialize method on external thread
__declspec(dllexport) HRESULT CVssJetWriter::Initialize
	(
	IN GUID idWriter,
	IN LPCWSTR wszWriterName,
	bool bSystemService,
	bool bBootableSystemState,
	LPCWSTR wszFilesToInclude,
	LPCWSTR wszFilesToExclude
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::Initialize");

	try
		{
		DWORD tid;
		// setup arguments to thread
		JW_INIT_ARGS args;
		args.idWriter = idWriter;
		args.wszWriterName = wszWriterName;
		args.bSystemService = bSystemService;
		args.bBootableSystemState = bBootableSystemState;
		args.wszFilesToInclude = wszFilesToInclude;
		args.wszFilesToExclude = wszFilesToExclude;
		args.pobj = this;

		// create thread
		HANDLE hThread = CreateThread
								(
								NULL,
								256*1024,
                                CVssJetWriter::InitializeThreadFunc,
								&args,
								0,
								&tid
								);

        if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				GetLastError()
				);

		// wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		}
	VSS_STANDARD_CATCH(ft)

	if (!ft.HrFailed())
		// get result of initialization
		ft.hr = m_hrInitialized;

	return ft.hr;
	}


__declspec(dllexport) void CVssJetWriter::Uninitialize()
	{
	// call uninitialize
	if (m_pWriter)
		{
		CVssIJetWriter::Uninitialize((PVSSIJETWRITER) m_pWriter);
		m_pWriter = NULL;
		}
	}

__declspec(dllexport) bool CVssJetWriter::OnIdentify(IVssCreateWriterMetadata *pIVssWriterMetadata)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnIdentify");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareBackupBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareBackupBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareBackupEnd(IN IVssWriterComponents *pIVssWriterComponents,
							     bool fJetPrepareSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareBackupEnd");
	return fJetPrepareSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareSnapshotBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareSnapshotBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareSnapshotEnd(bool fJetPrepareSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareSnapshotEnd");
	return fJetPrepareSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnFreezeBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnFreezeBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnFreezeEnd(bool fJetFreezeSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnFreezeEnd");
	return fJetFreezeSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnThawBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnThawBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnThawEnd(bool fJetThawSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnThawEnd");
	return fJetThawSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnPostSnapshot(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostSnapshot");
	return true;
	}


__declspec(dllexport) void CVssJetWriter::OnAbortBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnAbortBegin");
  	}

__declspec(dllexport) void CVssJetWriter::OnAbortEnd()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnAbortEnd");
  	}

__declspec(dllexport) bool CVssJetWriter::OnBackupCompleteBegin(IN IVssWriterComponents *pComponent)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnBackupCompleteBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							      bool fJetBackupCompleteSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnBackupCompleteEnd");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPreRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPreRestoreBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPreRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						       IN bool fJetRestoreSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPreRestoreEnd");
	return true;
  	}


__declspec(dllexport) bool CVssJetWriter::OnPostRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostRestoreBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPostRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						       IN bool fJetRestoreSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostRestoreEnd");
	return true;
  	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\vswriter.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsWriter.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  02/02/2000

TBD:
	
	Add comments.

Revision History:

	
    Name        Date        Comments
    brianb     03/28/2000   Created
    mikejohn   05/18/2000   ~CVssWriter() should check that wrapper exists
                            before calling it
    mikejohn   06/23/2000   Add external entry point for SetWriterFailure()
    mikejohn   09/01/2000   Add extra tracing to identify writers in trace output
    mikejohn   09/18/2000   176860: Added calling convention methods where missing
    ssteiner   02/14/2001   Changed class interface to version 2.

--*/


#include <stdafx.h>
#include <comadmin.h>

extern CComModule _Module;
#include <atlcom.h>

#include "vscoordint.h"
#include "comadmin.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "vsevent.h"
#include "vswrtimp.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"
#include "vs_sec.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHVWRTC"
//
////////////////////////////////////////////////////////////////////////


static LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }



static LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }

static LPCWSTR GetStringFromAlternateWriterState (VSS_ALTERNATE_WRITER_STATE aws)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (aws)
	{
	case VSS_AWS_UNDEFINED:                pwszRetString = L"Undefined";   					break;
	case VSS_AWS_NO_ALTERNATE_WRITER:      pwszRetString = L"No alternate writer";    		break;
	case VSS_AWS_ALTERNATE_WRITER_EXISTS:  pwszRetString = L"Alternate writer exists";   	break;
	case VSS_AWS_THIS_IS_ALTERNATE_WRITER: pwszRetString = L"This is the alternate writer"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }
	
static LPCWSTR GetStringFromApplicationLevel (VSS_APPLICATION_LEVEL eApplicationLevel)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eApplicationLevel)
	{
	case VSS_APP_UNKNOWN:   pwszRetString = L"Unknown";   break;
	case VSS_APP_SYSTEM:    pwszRetString = L"System";    break;
	case VSS_APP_BACK_END:  pwszRetString = L"BackEnd";   break;
	case VSS_APP_FRONT_END: pwszRetString = L"FrontEnd";  break;
	case VSS_APP_AUTO:      pwszRetString = L"Automatic"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }





// constructor
__declspec(dllexport)
STDMETHODCALLTYPE CVssWriter::CVssWriter() :
	m_pWrapper(NULL)
	{
	}

// destructor
__declspec(dllexport)
STDMETHODCALLTYPE CVssWriter::~CVssWriter()
	{
	if (NULL != m_pWrapper)
	    {
#ifdef _DEBUG
	    LONG cRef =
#endif
	    m_pWrapper->Release();

//  disable for now
//	    BS_ASSERT(cRef == 0);
	    }

	}

// default OnPrepareBackup method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPrepareBackup(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnIdentify method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	UNREFERENCED_PARAMETER(pMetadata);

	return true;
	}

// default OnBackupComplete method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackupComplete(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnPreRestore method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPreRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnPostRestore method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPostRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnPostSnapshot method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPostSnapshot(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnBackOffIOOnVolume
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackOffIOOnVolume
    (
    IN VSS_PWSZ wszVolumeName,
    IN VSS_ID snapshotId,
    IN VSS_ID providerId
    )
{
	UNREFERENCED_PARAMETER(wszVolumeName);
	UNREFERENCED_PARAMETER(snapshotId);
	UNREFERENCED_PARAMETER(providerId);

	return true;
}

// default OnContinueIOOnVolume
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnContinueIOOnVolume
    (
    IN VSS_PWSZ wszVolumeName,
    IN VSS_ID snapshotId,
    IN VSS_ID providerId
    )
{
	UNREFERENCED_PARAMETER(wszVolumeName);
	UNREFERENCED_PARAMETER(snapshotId);
	UNREFERENCED_PARAMETER(providerId);

	return true;
}

// default OnVSSShutdown
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnVSSShutdown()
{
	return true;
}

// default OnVSSApplicationStartup
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnVSSApplicationStartup()
{
	return true;
}



// initialize the writer
__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Initialize
	(
	IN VSS_ID WriterID,
	IN LPCWSTR wszWriterName,
	IN VSS_USAGE_TYPE ut,
	IN VSS_SOURCE_TYPE st,
	IN VSS_APPLICATION_LEVEL nLevel,
	IN DWORD dwTimeoutFreeze,
    IN VSS_ALTERNATE_WRITER_STATE aws,
    IN bool bIOThrottlingOnly
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Initialize");

	try
		{
		ft.Trace (VSSDBG_SHIM, L"Called CVssWriter::Initialize() with:");
		ft.Trace (VSSDBG_SHIM, L"    WriterId             = " WSTR_GUID_FMT, GUID_PRINTF_ARG (WriterID));
		ft.Trace (VSSDBG_SHIM, L"    WriterName           = %s",      (NULL == wszWriterName) ? L"(NULL)" : wszWriterName);
		ft.Trace (VSSDBG_SHIM, L"    UsageType            = %s",      GetStringFromUsageType (ut));
		ft.Trace (VSSDBG_SHIM, L"    SourceType           = %s",      GetStringFromSourceType (st));
		ft.Trace (VSSDBG_SHIM, L"    AppLevel             = %s",      GetStringFromApplicationLevel (nLevel));
		ft.Trace (VSSDBG_SHIM, L"    FreezeTimeout        = %d (ms)", dwTimeoutFreeze);
		ft.Trace (VSSDBG_SHIM, L"    AlternateWriterState = %s",      GetStringFromAlternateWriterState(aws));
		ft.Trace (VSSDBG_SHIM, L"    IOThrottlingOnly     = %s",      bIOThrottlingOnly ? L"True" : L"False");

		// The V2 parameters can only be set with default values
		if (aws != VSS_AWS_NO_ALTERNATE_WRITER ||
			bIOThrottlingOnly != false)
			return E_INVALIDARG;
		
		if (ut != VSS_UT_BOOTABLESYSTEMSTATE &&
			ut != VSS_UT_SYSTEMSERVICE &&
			ut != VSS_UT_USERDATA &&
			ut != VSS_UT_OTHER)
			return E_INVALIDARG;
// [aoltean] Previous comment was:
// return S_OK for now since there is a bug in the iis writer
//			return S_OK;

		if (st != VSS_ST_NONTRANSACTEDDB &&
			st != VSS_ST_TRANSACTEDDB &&
			st != VSS_ST_OTHER)
			return E_INVALIDARG;
// [aoltean] Previous comment was:
// return S_OK for now since there is a bug in the IIS writer
//			return S_OK;

		CVssWriterImpl::CreateWriter(this, &m_pWrapper);
		BS_ASSERT(m_pWrapper);

		// call Initialize method on core instance
		m_pWrapper->Initialize
			(
			WriterID,
			wszWriterName,
			ut,
			st,
			nLevel,
			dwTimeoutFreeze
			);
        }
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}



__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Subscribe
	(
  	IN DWORD dwEventFlags	
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Subscribe");

	try
		{
		ft.Trace (VSSDBG_SHIM, L"Called CVssWriter::Subscribe() with:");
		ft.Trace (VSSDBG_SHIM, L"    dwEventFlags = 0x%08x ", dwEventFlags);
		//  Only the default parameter setting is supported in V1
		if ( dwEventFlags != ( VSS_SM_BACKUP_EVENTS_FLAG | VSS_SM_RESTORE_EVENTS_FLAG ) )
			return E_INVALIDARG;

		if (m_pWrapper == NULL)
			ft.Throw(VSSDBG_GEN, E_FAIL, L"CVssWriter class was not initialized.");

		m_pWrapper->Subscribe();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Unsubscribe()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Unsubscribe");

	try
		{
		if (m_pWrapper == NULL)
			ft.Throw(VSSDBG_GEN, E_FAIL, L"CVssWriter class was not initialized.");

		m_pWrapper->Unsubscribe();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::InstallAlternateWriter
    (
    IN VSS_ID writerId,
    IN CLSID persistentWriterClassId
    )
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(persistentWriterClassId);

	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::InstallAlternateWriter");

	// Not supported in V1
	ft.hr = E_NOTIMPL;

	return ft.hr;
	}


__declspec(dllexport)
LPCWSTR* STDMETHODCALLTYPE CVssWriter::GetCurrentVolumeArray() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentVolumeArray");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return NULL;
	else
		return m_pWrapper->GetCurrentVolumeArray();
	}

__declspec(dllexport)
UINT STDMETHODCALLTYPE CVssWriter::GetCurrentVolumeCount() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentVolumeCount");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return 0;
	else
		return m_pWrapper->GetCurrentVolumeCount();
	}

__declspec(dllexport)
VSS_ID STDMETHODCALLTYPE CVssWriter::GetCurrentSnapshotSetId() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentSnapshotSetId");
	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return GUID_NULL;
	else
		return m_pWrapper->GetCurrentSnapshotSetId();
	}

__declspec(dllexport)
VSS_APPLICATION_LEVEL STDMETHODCALLTYPE CVssWriter::GetCurrentLevel() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentLevel");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return VSS_APP_AUTO;
	else
		return m_pWrapper->GetCurrentLevel();
	}

__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsPathAffected(IN	LPCWSTR wszPath) const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsPathAffected");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return NULL;
	else
		return m_pWrapper->IsPathAffected(wszPath);
	}


// determine if bootable state is backed up
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsBootableSystemStateBackedUp() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsBootableSystemStateBackedUp");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return false;
	else
		return m_pWrapper->IsBootableSystemStateBackedUp();
	}

// determine if the backup application is selecting components
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::AreComponentsSelected() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::AreComponentsSelected");
	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return false;
	else
		return m_pWrapper->AreComponentsSelected();
	}

__declspec(dllexport)
VSS_BACKUP_TYPE STDMETHODCALLTYPE CVssWriter::GetBackupType() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetBackupType");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return VSS_BT_UNDEFINED;
	else
		return m_pWrapper->GetBackupType();
	}

__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsPartialFileSupportEnabled() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsPartialFileSupportEnabled");

	return false;
	}


__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::SetWriterFailure(IN HRESULT hrStatus)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::SetWriterFailure");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return VSS_BT_UNDEFINED;
	else
		return m_pWrapper->SetWriterFailure(hrStatus);
	}

// create backup components
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppBackup is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is an administrator

__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssBackupComponents(IVssBackupComponents **ppBackup)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CreateVssBackupComponents");

	try
		{
		if (ppBackup == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		*ppBackup = NULL;

		if (!IsProcessBackupOperator())
			ft.Throw
				(
				VSSDBG_XML,
				E_ACCESSDENIED,
				L"The client process is not running under an administrator account or does not have backup privilege enabled"
				);

		CComObject<CVssBackupComponents> *pvbc;
		CComObject<CVssBackupComponents>::CreateInstance(&pvbc);
		pvbc->GetUnknown()->AddRef();
		*ppBackup = (IVssBackupComponents *) pvbc;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssExamineWriterMetadata
	(
	IN BSTR bstrXML,
	OUT IVssExamineWriterMetadata **ppMetadata
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CreateVssExamineWriterMetadata");

	CVssExamineWriterMetadata *pMetadata = NULL;
	try
		{
		if (ppMetadata == NULL)
			ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL output pointer");

		*ppMetadata = NULL;
		pMetadata = new CVssExamineWriterMetadata;
		if (pMetadata == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate CVssExamineWriterMetadata");

		if (!pMetadata->Initialize(bstrXML))
			ft.Throw
				(
				VSSDBG_GEN,
				VSS_E_INVALID_XML_DOCUMENT,
				L"XML passed to CreateVssExamineWriterMetdata was invalid"
				);

		*ppMetadata = (IVssExamineWriterMetadata *) pMetadata;
		pMetadata->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		delete pMetadata;

	return ft.hr;
	}

__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssSnapshotSetDescription
	(
	IN VSS_ID idSnapshotSet,
	IN LONG lContext,
	OUT IVssSnapshotSetDescription **ppSnapshotSet
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CreateVssSnapshotSetDescription");
	try
		{
		if (ppSnapshotSet == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppSnapshotSet = NULL;
		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



__declspec(dllexport)
HRESULT STDAPICALLTYPE LoadVssSnapshotSetDescription
	(
	IN  LPCWSTR wszXML,
	OUT IVssSnapshotSetDescription **ppSnapshotSet
	)
	{
	UNREFERENCED_PARAMETER(wszXML);
	UNREFERENCED_PARAMETER(ppSnapshotSet);

	CVssFunctionTracer ft(VSSDBG_XML, L"LoadVssSnapshotSetDescription");
	
	try
		{
		if (ppSnapshotSet == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppSnapshotSet = NULL;
		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrclus.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrclus.cpp | Implementation of SnapshotWriter for Cluster Database

    NOTE: This module is not used/compiled anymore since Clusters has its own snapshot writer.

Author:

    Michael C. Johnson [mikejohn] 31-Jan-2000


Description:
	
    Add comments.


Revision History:

	X-13	MCJ		Michael C. Johnson		22-Oct-2000
		209095: Dynamically load the cluster and net libraries to
		reduce the foot print for the unclustered.
 
	X-12	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-11	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-10	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Remove trailing '\' from Include/Exclude lists.

	X-9	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-8	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()
 
	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-5	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.
		Move save path under SystemState target path.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Fix broken assert in shutdown code, some path length checks
		and calculations.

	X-1	MCJ		Michael C. Johnson		31-Jan-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.

--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <clusapi.h>
#include <lmshare.h>
#include <lmaccess.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCLUSC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING	L"ClusterDatabase"
#define COMPONENT_NAME		L"Cluster Database"
#define TARGET_PATH		ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


DeclareStaticUnicodeString (ucsShareName, L"__NtBackup_cluster");


typedef DWORD		(WINAPI *PFnGetNodeClusterState)(LPCWSTR, PDWORD);
typedef HCLUSTER	(WINAPI *PFnOpenCluster)(LPCWSTR);
typedef DWORD		(WINAPI *PFnBackupClusterDatabase)(HCLUSTER, LPCWSTR);
typedef BOOL		(WINAPI *PFnCloseCluster)(HCLUSTER);

typedef NET_API_STATUS	(WINAPI *PFnNetShareAdd)(LPWSTR, DWORD, LPBYTE, LPDWORD);
typedef NET_API_STATUS	(WINAPI *PFnNetShareDel)(LPWSTR, LPWSTR, DWORD);



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/
class CShimWriterClusterDb : public CShimWriter
    {
public:
    CShimWriterClusterDb (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bBootableState) : 
		CShimWriter (pwszWriterName, pwszTargetPath, bBootableState),
		m_pfnDynamicGetNodeClusterState   (NULL),
		m_pfnDynamicOpenCluster           (NULL),
		m_pfnDynamicCloseCluster          (NULL),
		m_pfnDynamicBackupClusterDatabase (NULL),
		m_pfnDynamicNetShareAdd           (NULL),
		m_pfnDynamicNetShareDel           (NULL),
		m_hmodClusApi                     (NULL),
		m_hmodNetApi32                    (NULL) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT DoClusterDatabaseBackup (VOID);

    HRESULT DynamicRoutinesLoadCluster (VOID);
    HRESULT DynamicRoutinesLoadNetwork (VOID);
    HRESULT DynamicRoutinesUnloadAll   (VOID);


    PFnGetNodeClusterState	m_pfnDynamicGetNodeClusterState;
    PFnOpenCluster		m_pfnDynamicOpenCluster;
    PFnCloseCluster		m_pfnDynamicCloseCluster;
    PFnBackupClusterDatabase	m_pfnDynamicBackupClusterDatabase;
    PFnNetShareAdd		m_pfnDynamicNetShareAdd;
    PFnNetShareDel		m_pfnDynamicNetShareDel;
    HMODULE			m_hmodClusApi;
    HMODULE			m_hmodNetApi32;
    };


static CShimWriterClusterDb ShimWriterClusterDb (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterClusterDb = &ShimWriterClusterDb;



/*
**++
**
** Routine Description:
**
**	This routine loads the required Cluster DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesLoadCluster ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesLoadCluster");


    try 
	{
	if ((NULL != m_pfnDynamicGetNodeClusterState)   ||
	    (NULL != m_pfnDynamicOpenCluster)           ||
	    (NULL != m_pfnDynamicCloseCluster)          ||
	    (NULL != m_pfnDynamicBackupClusterDatabase) ||
	    !HandleInvalid (m_hmodClusApi))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodClusApi = LoadLibraryW (L"ClusApi.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodClusApi);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (ClusApi.dll)");



	m_pfnDynamicGetNodeClusterState = (PFnGetNodeClusterState) GetProcAddress (m_hmodClusApi, "GetNodeClusterState");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicGetNodeClusterState);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (GetNodeClusterState)");



	m_pfnDynamicOpenCluster = (PFnOpenCluster) GetProcAddress (m_hmodClusApi, "OpenCluster");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicOpenCluster);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (OpenCluster)");



	m_pfnDynamicCloseCluster = (PFnCloseCluster) GetProcAddress (m_hmodClusApi, "CloseCluster");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicCloseCluster);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (CloseCluster)");



	m_pfnDynamicBackupClusterDatabase = (PFnBackupClusterDatabase) GetProcAddress (m_hmodClusApi, "BackupClusterDatabase");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicBackupClusterDatabase);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (BackupClusterDatabase)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_pfnDynamicOpenCluster           = NULL;
	m_pfnDynamicCloseCluster          = NULL;
	m_pfnDynamicBackupClusterDatabase = NULL;
	m_hmodClusApi                     = NULL;
	}


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesLoadCluster () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesLoadNetwork ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesLoadNetwork");


    try 
	{
	if ((NULL != m_pfnDynamicNetShareAdd) ||
	    (NULL != m_pfnDynamicNetShareDel) ||
	    !HandleInvalid (m_hmodNetApi32))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodNetApi32 = LoadLibraryW (L"NetApi32.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodNetApi32);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (NetApi32.dll)");



	m_pfnDynamicNetShareAdd = (PFnNetShareAdd) GetProcAddress (m_hmodNetApi32, "NetShareAdd");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicNetShareAdd);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (NetShareAdd)");



	m_pfnDynamicNetShareDel = (PFnNetShareDel) GetProcAddress (m_hmodNetApi32, "NetShareDel");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicNetShareDel);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (NetShareDel)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodNetApi32)) FreeLibrary (m_hmodNetApi32);

	m_pfnDynamicNetShareAdd = NULL;
	m_pfnDynamicNetShareDel = NULL;
	m_hmodNetApi32          = NULL;
	}


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesLoadNetwork () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesUnloadAll ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesUnloadAll");


    try 
	{
	if (!HandleInvalid (m_hmodNetApi32)) FreeLibrary (m_hmodNetApi32);

	m_pfnDynamicNetShareAdd = NULL;
	m_pfnDynamicNetShareDel = NULL;
	m_hmodNetApi32          = NULL;



	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_pfnDynamicOpenCluster           = NULL;
	m_pfnDynamicCloseCluster          = NULL;
	m_pfnDynamicBackupClusterDatabase = NULL;
	m_hmodClusApi                     = NULL;
	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesUnloadAll () */

/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DoIdentify ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DoIdentify");

    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;



    try 
	{
	ft.hr = DynamicRoutinesLoadCluster ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	ft.hr = HRESULT_FROM_WIN32 (winStatus);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
 
	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



	if (bClusterRunning)
	    {
	    ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							       NULL,
							       COMPONENT_NAME,
							       COMPONENT_NAME,
							       NULL, // icon
							       0,
							       true,
							       false,
							       false);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");


	    ft.hr= m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");
 	    }
	} VSS_STANDARD_CATCH (ft)


    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterClusterDb::DoIdentify () */


/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterClusterDb::DoPrepareForSnapshot ()
    {
    HRESULT	hrStatus = NOERROR;
    DWORD	winStatus;
    DWORD	dwClusterNodeState;


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = DynamicRoutinesLoadCluster ();
	}


    if (SUCCEEDED (hrStatus))
	{
	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	m_bParticipateInBackup = SUCCEEDED (hrStatus) && (ClusterStateRunning == dwClusterNodeState);


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetNodeClusterState", 
		    L"CShimWriterClusterDb::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	hrStatus = DynamicRoutinesLoadNetwork ();
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	hrStatus = DoClusterDatabaseBackup ();
	}


    DynamicRoutinesUnloadAll ();


    return (hrStatus);
    } /* CShimWriterClusterDb::PrepareForFreeze () */



HRESULT CShimWriterClusterDb::DoClusterDatabaseBackup ()
    {
    HRESULT			hrStatus       = NOERROR;
    HCLUSTER			hCluster       = NULL;
    BOOL			bNetShareAdded = FALSE;
    BOOL			bSucceeded;
    SHARE_INFO_502		ShareInfo;
    UNICODE_STRING		ucsComputerName;
    UNICODE_STRING		ucsBackupPathLocal;
    UNICODE_STRING		ucsBackupPathNetwork;


    BS_ASSERT (MAX_COMPUTERNAME_LENGTH <= ((MAXUSHORT / sizeof (WCHAR)) - sizeof (UNICODE_NULL)));


    StringInitialise (&ucsComputerName);
    StringInitialise (&ucsBackupPathLocal);
    StringInitialise (&ucsBackupPathNetwork);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsBackupPathLocal,
						   m_pwszTargetPath,
						   0);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsComputerName,
				   (MAX_COMPUTERNAME_LENGTH * sizeof (WCHAR)) + sizeof (UNICODE_NULL));
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwNameLength = ucsComputerName.MaximumLength / sizeof (WCHAR);
	BOOL	bSucceeded   = GetComputerNameW (ucsComputerName.Buffer, &dwNameLength);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (SUCCEEDED (hrStatus))
	    {
	    ucsComputerName.Length = (USHORT) (dwNameLength * sizeof (WCHAR));
	    }
	else
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"GetComputerNameW", 
			L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	    }
	}



    if (SUCCEEDED (hrStatus))
	{
	if ((ucsComputerName.Length + ucsShareName.Length) > (MAXUSHORT - (sizeof (UNICODE_NULL) + 3 * sizeof (L'\\'))))
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	    }
	else
	    {
	    hrStatus = StringAllocate (&ucsBackupPathNetwork,
				       (USHORT) (sizeof (L'\\')
						 + sizeof (L'\\')
						 + ucsComputerName.Length
						 + sizeof (L'\\')
						 + ucsShareName.Length
						 + sizeof (UNICODE_NULL)));
	    }
	}



    if (SUCCEEDED (hrStatus))
	{
	NET_API_STATUS	netStatus;

	/*
	** Should we uniquify the directory name at all here
	** to cater for the possiblity that we may be involved
	** in more than one snapshot at a time?
	*/
	StringAppendString (&ucsBackupPathNetwork, L"\\\\");
	StringAppendString (&ucsBackupPathNetwork, &ucsComputerName);
	StringAppendString (&ucsBackupPathNetwork, L"\\");
	StringAppendString (&ucsBackupPathNetwork, &ucsShareName);


	memset (&ShareInfo, 0, sizeof (ShareInfo));

	ShareInfo.shi502_netname     = ucsShareName.Buffer;
	ShareInfo.shi502_type        = STYPE_DISKTREE;
	ShareInfo.shi502_permissions = ACCESS_READ | ACCESS_WRITE | ACCESS_CREATE;
	ShareInfo.shi502_max_uses    = 1;
	ShareInfo.shi502_path        = ucsBackupPathLocal.Buffer;

        /*
        ** Make sure to try to delete the share first in case for some reason it exists.  This
        ** could happen if the previous shim instance was killed right after creating the
        ** share. Ignore the return code. Bug #280746.
        */
        m_pfnDynamicNetShareDel (NULL, ucsShareName.Buffer, 0);

	/*
	** Create the backup directory and share it out. Note that we
	** don't care if the CreateDirectoryW() fails: it could fail
	** for a number of legitimate reasons (eg already exists). If
	** the failure was significant then we won't be able to add
	** the share and we'll detect a problem at that point.
	*/
	netStatus = m_pfnDynamicNetShareAdd (NULL, 502, (LPBYTE)(&ShareInfo), NULL);
	hrStatus  = HRESULT_FROM_WIN32 (netStatus);

	bNetShareAdded = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"NetShareAdd", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    if (SUCCEEDED (hrStatus))
	{
	hCluster = m_pfnDynamicOpenCluster (NULL);

	hrStatus = GET_STATUS_FROM_HANDLE (hCluster);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"OpenCluster", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	winStatus = m_pfnDynamicBackupClusterDatabase (hCluster, ucsBackupPathNetwork.Buffer);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"BackupClusterDatabase", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    /*
    ** All the cleanup code.
    */
    if (!HandleInvalid (hCluster)) m_pfnDynamicCloseCluster (hCluster);
    if (bNetShareAdded)            m_pfnDynamicNetShareDel (NULL, ucsShareName.Buffer, 0);

    StringFree (&ucsComputerName);
    StringFree (&ucsBackupPathLocal);
    StringFree (&ucsBackupPathNetwork);

    return (hrStatus);
    } /* DoClusterDatabaseBackup () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrci.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrci.cpp

Abstract:

    Writer shim module for Ci

Author:

    Stefan R. Steiner   [ssteiner]        02-08-2000

Revision History:

	X-8	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-7	MCJ		Michael C. Johnson		18-Jul-2000
		143435: Change name of target path

	X-6	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Add an exclude list which covers the CI indices.

	X-5	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-2	MCJ		Michael C. Johnson		 7-Mar-2000
		Instead of stopping the CI service, just pause it. This will
		allow queries to continue but stop updates until we continue
		it.

--*/

#include "stdafx.h"

#include "wrtrdefs.h"
#include "common.h"
#include <winsvc.h>

#pragma warning(disable:4100)

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCIC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING		L"ContentIndexingService"
#define COMPONENT_NAME			L"Content Indexing Service"

#define	CI_CATALOG_LIST_KEY		L"SYSTEM\\CurrentControlset\\Control\\ContentIndex\\Catalogs"
#define CI_CATALOG_VALUENAME_LOCATION	L"Location"

#define CATALOG_BUFFER_SIZE		(4096)

DeclareStaticUnicodeString (ucsIndexSubDirectoryName, L"\\catalog.wci");


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterCI : public CShimWriter
    {
public:
    CShimWriterCI (LPCWSTR pwszWriterName) : 
		CShimWriter (pwszWriterName), 
		m_dwPreviousServiceState(0),
		m_bStateChangeOutstanding(FALSE) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    HRESULT DoThaw (VOID);
    HRESULT DoShutdown (VOID);

    DWORD m_dwPreviousServiceState;
    BOOL  m_bStateChangeOutstanding;
    };


static CShimWriterCI ShimWriterCI (APPLICATION_STRING);

PCShimWriter pShimWriterCI = &ShimWriterCI;



/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterCI::DoIdentify ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    DWORD		dwIndex                    = 0;
    HKEY		hkeyCatalogList            = NULL;
    BOOL		bCatalogListKeyOpened      = FALSE;
    BOOL		bContinueCatalogListSearch = TRUE;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;


    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, CATALOG_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, CATALOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							      NULL,
							      COMPONENT_NAME,
							      COMPONENT_NAME,
							      NULL, // icon
							      0,
							      true,
							      false,
							      false);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddComponent", 
		    L"CShimWriterCI::DoIdentify");
	}



    if (SUCCEEDED (hrStatus))
	{
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   CI_CATALOG_LIST_KEY,
				   0L,
				   KEY_READ,
				   &hkeyCatalogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus); 

	bCatalogListKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (catalog list)", 
		    L"CShimWriterCI::DoIdentify");
	}



    while (SUCCEEDED (hrStatus) && bContinueCatalogListSearch)
	{
	HKEY	hkeyCatalogName    = NULL;
 	DWORD	dwSubkeyNameLength = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyCatalogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueCatalogListSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterCI::DoIdentify");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    winStatus = RegOpenKeyExW (hkeyCatalogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyCatalogName);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (catalog value)", 
			L"CShimWriterCI::DoIdentify");


	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;


		StringTruncate (&ucsValueData, 0);

		winStatus = RegQueryValueExW (hkeyCatalogName,
					      CI_CATALOG_VALUENAME_LOCATION,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);

		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterCI::DoIdentify");



		if (SUCCEEDED (hrStatus) && (REG_SZ == dwValueType))
		    {
		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;

		    StringAppendString (&ucsValueData, &ucsIndexSubDirectoryName);


		    hrStatus = m_pIVssCreateWriterMetadata->AddExcludeFiles (ucsValueData.Buffer,
									     L"*",
									     true);

		    LogFailure (NULL, 
				hrStatus, 
				hrStatus, 
				m_pwszWriterName, 
				L"IVssCreateWriterMetadata::AddExcludeFiles", 
				L"CShimWriterCI::DoIdentify");
		    }

		RegCloseKey (hkeyCatalogName);
		}




	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}



    if (bCatalogListKeyOpened)
	{
	RegCloseKey (hkeyCatalogList);
	}



    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);

    return (hrStatus);
    } /* CShimWriterCI::DoIdentify () */


/*++

Routine Description:

    The CI writer PrepareForSnapshot function.  Currently all of the
    real work for this writer happens here. Pause the service if we can.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoPrepareForSnapshot ()
    {
    HRESULT hrStatus = VsServiceChangeState (L"cisvc",
					     SERVICE_PAUSED,
					     &m_dwPreviousServiceState,
					     &m_bStateChangeOutstanding);

    m_bParticipateInBackup = m_bStateChangeOutstanding;

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"VsServiceChangeState", 
		L"CShimWriterCI::DoPrepareForSnapshot");


    return (hrStatus);
    } /* CShimWriterCI::DoPrepareForSnapshot () */



/*++

Routine Description:

    The CI writer Thaw function.  Return the service to 
    state in which we found it.

Arguments:

    Same arguments as those passed in the Thaw event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoThaw ()
    {
    HRESULT hrStatus = NOERROR;

    if (m_bStateChangeOutstanding)
	{
	hrStatus = VsServiceChangeState (L"cisvc",
					 m_dwPreviousServiceState,
					 NULL,
					 NULL);

	m_bStateChangeOutstanding = FAILED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"VsServiceChangeState", 
		    L"CShimWriterCI::DoThaw/DoAbort");

	}


    return (hrStatus);
    } /* CShimWriterCI::DoThaw () */



/*++

Routine Description:

    The CI writer Shutdown function.  Return the service to state in
    which we found it. We do our level best to put things back the way
    they were even if this writer has previously failed but only if we
    originally changed the state.

Arguments:

    None.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoShutdown ()
    {
    HRESULT hrStatus = NOERROR;

    if (m_bStateChangeOutstanding)
	{
	hrStatus = VsServiceChangeState (L"cisvc",
					 m_dwPreviousServiceState,
					 NULL,
					 NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"VsServiceChangeState", 
		    L"CShimWriterCI::DoShutdown");

	}


    return (hrStatus);
    } /* CShimWriterCI::DoShutdown () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrcomdb.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrcomdb.cpp | Implementation of SnapshotWriter for COM+ Registration Database



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-14	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-13	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-12	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Really remove trailing '\' from Include/Exclude lists.

	X-11	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.


	X-10	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-9	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-8	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-7	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-6	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.


	X-5	MCJ		Michael C. Johnson		22-Feb-2000
		Add SYSTEM_STATE_SUBDIR to COM+ database save path.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Ensure wide chars are used for saving the COM+ Db rather
		than the 'CHAR' type used by NtBackup (CHAR == WCHAR in
		NtBackup just to fool folk)
		Fix broken assert in shutdown code.
		Fix path length checks and calculations.

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.

--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCMDBC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING	L"ComRegistrationDatabase"
#define COMPONENT_NAME		L"COM+ Registration Database"
#define TARGET_PATH		ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

DeclareStaticUnicodeString (ucsBackupFilename, L"\\ComRegDb.bak");


HRESULT (WINAPI *RegDbBackup)(PWCHAR);

typedef HRESULT (WINAPI *PF_REG_DB_API)(PWCHAR);





/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterComDb : public CShimWriter
    {
public:
    CShimWriterComDb (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState) : 
		CShimWriter (pwszWriterName, pwszTargetPath, bParticipateInBootableState) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterComDb ShimWriterComDb (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterComPlusRegDb = &ShimWriterComDb;



/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterComDb::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterComDb::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");



	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (L"%SystemRoot%\\registration",
							      L"*.clb",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.clb)");




	/*
	** Exclude all *.crmlog files from the root down.
	*/
	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (DIR_SEP_STRING,
							      L"*.crmlog",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.crmlog)");

	} VSS_STANDARD_CATCH (ft)
								 


    return (ft.hr);
    } /* CShimWriterComDb::DoIdentify () */


/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer PrepareForSnapshot function.
**	Currently all of the real work for this writer happens here.
**
**
** Arguments:
**
**	Same arguments as those passed in the PrepareForSnapshot event.
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterComDb::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    HINSTANCE		hRegDbDll = NULL;
    UNICODE_STRING	ucsBackupPath;


    StringInitialise (&ucsBackupPath);


    hrStatus = StringCreateFromExpandedString (&ucsBackupPath,
					       m_pwszTargetPath,
					       ucsBackupFilename.Length / sizeof (WCHAR));



    if (SUCCEEDED (hrStatus))
	{
	hRegDbDll = LoadLibraryW (L"catsrvut.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hRegDbDll);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (catsrvut.dll)", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	RegDbBackup = (PF_REG_DB_API) GetProcAddress (hRegDbDll, "RegDBBackup");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != RegDbBackup);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (RegDbBackup)", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsBackupPath, &ucsBackupFilename);

	hrStatus = RegDbBackup (ucsBackupPath.Buffer);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegDbBackup", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}



    if (!HandleInvalid (hRegDbDll))
	{
	FreeLibrary (hRegDbDll);
	}



    StringFree (&ucsBackupPath);

    return (hrStatus);
    } /* DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrconfig.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrconfig.cpp | Implementation of SnapshotWriter for Config directory



Author:

    Michael C. Johnson [mikejohn] 18-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-20	MCJ		Michael C. Johnson		13-Sep-2000
		178282: Writer should only generate backup file if source 
			path is in volume list.

	X-19	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-18	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-17	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine. Also this is
		not a bootable state writer.

	X-16	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-15	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		 3-Mar-2000
		Determine correct errors (if any) during copy file scan loop
		in PrepareToSync and fail the operation if appropriate.

	X-3	MCJ		Michael C. Johnson		 2-Mar-2000
		Do a preparatory cleanup of the target save directory to make
		sure we don't have to deal with any junk left from a previous
		invokcation.
		Also be smarter about what we copy. In particular, there is
		no need to copy the registry related files or the event logs.

	X-2	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-1	MCJ		Michael C. Johnson		18-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCONFC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"ConfigDirectory"
#define COMPONENT_NAME				L"Config Directory"

#define TARGET_PATH				ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING
#define CONFIGDIR_SOURCE_PATH			L"%SystemRoot%\\system32\\config"


#define REGISTRY_SUBKEY_HIVELIST		L"SYSTEM\\CurrentControlSet\\Control\\hivelist"

#define EVENTLOG_SUBKEY_EVENTLOG		L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define EVENTLOG_VALUENAME_FILE			L"File"


#define REGISTRY_BUFFER_SIZE			(4096)
#define EVENTLOG_BUFFER_SIZE			(4096)

DeclareStaticUnicodeString (ucsHiveRecognitionPrefix, L"\\Device\\");


typedef struct _VertexRecord
    {
    UNICODE_STRING	ucsVertexName;
    } VERTEXRECORD, *PVERTEXRECORD, **PPVERTEXRECORD;


static PVOID NTAPI VertexAllocateNode (PRTL_GENERIC_TABLE pTable,
				       CLONG              clByteSize);

static VOID NTAPI VertexFreeNode (PRTL_GENERIC_TABLE pTable,
				  PVOID              pvBuffer);

static RTL_GENERIC_COMPARE_RESULTS NTAPI VertexCompareNode (PRTL_GENERIC_TABLE pTable,
							    PVOID              pvNode1,
							    PVOID              pvNode2);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterConfigDir : public CShimWriter
    {
public:
    CShimWriterConfigDir (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) 
	{
	PVOID	pvTableContext = NULL;

	RtlInitializeGenericTable (&m_StopList,
				   VertexCompareNode,
				   VertexAllocateNode,
				   VertexFreeNode,
				   pvTableContext);
	};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT CopyConfigDirFiles       (VOID);
    HRESULT PopulateStopList         (VOID);
    HRESULT PopulateStopListEventlog (VOID);
    HRESULT PopulateStopListRegistry (VOID);
    HRESULT CleanupStopList          (VOID);
    BOOL    FileInStopList           (PWCHAR pwszFilename);
    HRESULT VertexAdd                (PUNICODE_STRING pucsVertexName);

    RTL_GENERIC_TABLE	m_StopList;
    };


static CShimWriterConfigDir ShimWriterConfigDir (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterConfigDir = &ShimWriterConfigDir;



static PVOID NTAPI VertexAllocateNode (PRTL_GENERIC_TABLE pTable,
				       CLONG              clByteSize)
    {
    PVOID	pvBuffer;

    pvBuffer = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, clByteSize);

    return (pvBuffer);
    }



static VOID NTAPI VertexFreeNode (PRTL_GENERIC_TABLE pTable,
				  PVOID              pvBuffer)
    {
    HeapFree (GetProcessHeap (), 0, pvBuffer);

    return;
    }



/*
** In this usage of the package I don't actually care about ordering,
** just so long as I can re-find vertex information. To this end we
** need to specify the search 'key'. So, the 'key' is defined to be
** the file name and is expected to be unique to a vertex. If this
** changes then we'll need to re-visit this.
*/

static RTL_GENERIC_COMPARE_RESULTS NTAPI VertexCompareNode (PRTL_GENERIC_TABLE pTable,
							    PVOID              pvNode1,
							    PVOID              pvNode2)
    {
    PVERTEXRECORD		pVertex1   = (PVERTEXRECORD) pvNode1;
    PVERTEXRECORD		pVertex2   = (PVERTEXRECORD) pvNode2;
    RTL_GENERIC_COMPARE_RESULTS	Result;
    INT				iStringCompareResult;


    iStringCompareResult = RtlCompareUnicodeString (&pVertex1->ucsVertexName,
						    &pVertex2->ucsVertexName,
						    TRUE);

    if (iStringCompareResult < 0)
	{
	Result = GenericLessThan;
	}

    else if (iStringCompareResult > 0)
	{
	Result = GenericGreaterThan;
	}

    else
	{
	Result = GenericEqual;
	}


    return (Result);
    }



HRESULT CShimWriterConfigDir::VertexAdd (PUNICODE_STRING pucsVertexName)
    {
    HRESULT		Status = NOERROR;
    PVERTEXRECORD	pVertexRecord;
    PVERTEXRECORD	pNewVertexRecord;
    BOOLEAN		bNewElement;
    ULONG		ulVertexNodeSize = sizeof (VERTEXRECORD) +
					   sizeof (UNICODE_NULL) +
					   pucsVertexName->Length;


    pVertexRecord = (PVERTEXRECORD) HeapAlloc (GetProcessHeap(),
					       HEAP_ZERO_MEMORY,
					       ulVertexNodeSize);

    Status = GET_STATUS_FROM_POINTER (pVertexRecord);



    if (SUCCEEDED (Status))
	{
	/*
	** Fill in enough of the node to allow it to be inserted into
	** the table. We will need to fix up the unicode string buffer
	** address after insertion.
	*/
	pVertexRecord->ucsVertexName.Buffer        = (PWCHAR)((PBYTE)pVertexRecord + sizeof (VERTEXRECORD));
	pVertexRecord->ucsVertexName.Length        = 0;
	pVertexRecord->ucsVertexName.MaximumLength = (USHORT)(sizeof (UNICODE_NULL) + pucsVertexName->Length);

	RtlCopyUnicodeString (&pVertexRecord->ucsVertexName, pucsVertexName);


	pNewVertexRecord = (PVERTEXRECORD) RtlInsertElementGenericTable (&m_StopList,
									 pVertexRecord,
									 ulVertexNodeSize,
									 &bNewElement);


	if (NULL == pNewVertexRecord)
	    {
	    /*
	    ** An allocation attempt failed. Setup an appropriate return
	    ** status
	    */
	    Status = E_OUTOFMEMORY;
	    }

	else if (!bNewElement)
	    {
	    /*
	    ** Oh oh, this is a duplicate. Setup an appropriate return
	    ** status.
	    */
	    Status = HRESULT_FROM_WIN32 (ERROR_DUP_NAME);
	    }

	else
	    {
	    /*
	    ** If we have a record and it's a new record then we need to
	    ** fix up the address of the unicode string to make it point
	    ** to the string in the newly inserted node rather than the
	    ** record we constructed to do the insertion.
	    */
	    pNewVertexRecord->ucsVertexName.Buffer = (PWCHAR)((PBYTE)pNewVertexRecord + sizeof (VERTEXRECORD));
	    }
	}


    if (NULL != pVertexRecord)
	{
	HeapFree (GetProcessHeap(), 0, pVertexRecord);
	}


    return (Status);
    } /* VertexAdd () */


/*
**++
**
** Routine Description:
**
**	The configuration directory snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterConfigDir::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterConfigDir::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (CONFIGDIR_SOURCE_PATH,
							      L"*",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CShimWriterConfigDir::DoIdentify () */



/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterConfigDir::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    UNICODE_STRING	ucsSourcePath;


    StringInitialise (&ucsSourcePath);

    hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
					       CONFIGDIR_SOURCE_PATH);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = IsPathInVolumeArray (ucsSourcePath.Buffer,
					m_ulVolumeCount,
					m_ppwszVolumeNamesArray,
					&m_bParticipateInBackup);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = PopulateStopList ();
	}


    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = CopyConfigDirFiles ();
	}


    CleanupStopList ();
    StringFree (&ucsSourcePath);

    return (hrStatus);
    } /* CShimWriterConfigDir::DoPrepareForSnapshot () */



HRESULT CShimWriterConfigDir::PopulateStopList ()
    {
    HRESULT	hrStatus;


    /*
    ** We have a table (initialized in the constructor. Now we need to
    ** get the names of the files to add to the StopList. This will
    ** prevent the copy from attempting to copy these files. First we
    ** populate with registry files we don't want to copy, then with
    ** event log files that we don't want either.
    */
    hrStatus = PopulateStopListRegistry ();

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = PopulateStopListEventlog ();
	}


    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopList () */



HRESULT CShimWriterConfigDir::PopulateStopListEventlog ()
    {
    HRESULT		hrStatus                    = NOERROR;
    DWORD		winStatus;
    DWORD		dwIndex                     = 0;
    HKEY		hkeyEventLogList            = NULL;
    BOOL		bSucceeded                  = FALSE;
    BOOL		bEventLogListKeyOpened      = FALSE;
    BOOL		bEventLogValueFileKeyOpened = FALSE;
    BOOL		bContinueEventLogSearch     = TRUE;
    UNICODE_STRING	ucsConfigDirSourcePath;
    UNICODE_STRING	ucsEventLogSourcePath;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;


    StringInitialise (&ucsConfigDirSourcePath);
    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsConfigDirSourcePath,
						   CONFIGDIR_SOURCE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsConfigDirSourcePath, DIR_SEP_STRING);


	/*
	** We now have all the pieces in place so go search the eventlog list
	** for the logs to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   EVENTLOG_SUBKEY_EVENTLOG,
				   0L,
				   KEY_READ,
				   &hkeyEventLogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bEventLogListKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (eventlog list)", 
		    L"CShimWriterConfigDir::PopulateStopListEventlog");
	}



    while (SUCCEEDED (hrStatus) && bContinueEventLogSearch)
	{
	HKEY	hkeyEventLogValueFile       = NULL;
 	DWORD	dwSubkeyNameLength          = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyEventLogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueEventLogSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;



	    winStatus = RegOpenKeyExW (hkeyEventLogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyEventLogValueFile);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    bEventLogValueFileKeyOpened = SUCCEEDED (hrStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (eventlog name)", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");



	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;


		StringTruncate (&ucsValueData, 0);

		winStatus = RegQueryValueExW (hkeyEventLogValueFile,
					      EVENTLOG_VALUENAME_FILE,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);

		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterConfigDir::PopulateStopListEventlog");



		if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
		    {
		    HANDLE	hEventLog    = NULL;
		    PWCHAR	pwszFilename;


		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;



		    StringInitialise (&ucsEventLogSourcePath);

		    hrStatus = StringCreateFromExpandedString (&ucsEventLogSourcePath,
							       ucsValueData.Buffer,
							       0);



		    if (SUCCEEDED (hrStatus))
			{
			BOOL	bInConfigDir = RtlPrefixUnicodeString (&ucsConfigDirSourcePath,
								       &ucsEventLogSourcePath,
								       TRUE);

			if (bInConfigDir)
			    {
			    pwszFilename = wcsrchr (ucsEventLogSourcePath.Buffer, DIR_SEP_CHAR);

			    pwszFilename = (NULL == pwszFilename)
						? ucsEventLogSourcePath.Buffer
						: pwszFilename + 1;

			    StringTruncate (&ucsValueData, 0);
			    StringAppendString (&ucsValueData, pwszFilename);

			    hrStatus = VertexAdd (&ucsValueData);
			    }
			}


		    StringFree (&ucsEventLogSourcePath);
		    }
		}


	    if (bEventLogValueFileKeyOpened)
		{
		RegCloseKey (hkeyEventLogValueFile);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}




    if (bEventLogListKeyOpened)
	{
	RegCloseKey (hkeyEventLogList);
	}


    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);
    StringFree (&ucsConfigDirSourcePath);


    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopListEventlog () */


HRESULT CShimWriterConfigDir::PopulateStopListRegistry ()
    {
    HRESULT		hrStatus            = NOERROR;
    HKEY		hkeyHivelist        = NULL;
    INT			iIndex              = 0;
    BOOL		bHivelistKeyOpened  = FALSE;
    BOOL		bContinueHiveSearch = TRUE;
    DWORD		winStatus;
    PWCHAR		pwchLastSlash;
    PWCHAR		pwszFilename;
    USHORT		usRegistryHivePathOriginalLength;
    UNICODE_STRING	ucsRegistryHivePath;
    UNICODE_STRING	ucsHiveRecognitionPostfix;
    UNICODE_STRING	ucsValueName;
    UNICODE_STRING	ucsValueData;


    StringInitialise (&ucsRegistryHivePath);
    StringInitialise (&ucsHiveRecognitionPostfix);
    StringInitialise (&ucsValueName);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueName, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistryHivePath,
						   CONFIGDIR_SOURCE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwCharIndex;


	StringAppendString (&ucsRegistryHivePath, DIR_SEP_STRING);

	usRegistryHivePathOriginalLength = ucsRegistryHivePath.Length / sizeof (WCHAR);



	/*
	** Now we know the location of the hive files, determine the
	** postfix we are going to use to recognise hives when we
	** search the active hivelist key. To do this we just need to
	** lose the drive letter and the colon in the path, or to put
	** it another way, lose everthing before the first '\'. When
	** we are done, if everything works ucsRegistryHivePath will
	** look something like '\Windows\system32\config\'
	*/
	for (dwCharIndex = 0;
	     (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)))
		 && (DIR_SEP_CHAR != ucsRegistryHivePath.Buffer [dwCharIndex]);
	     dwCharIndex++)
	    {
	    /*
	    ** Empty loop body
	    */
	    }

	BS_ASSERT (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)));

	hrStatus = StringCreateFromString (&ucsHiveRecognitionPostfix, 
					   &ucsRegistryHivePath.Buffer [dwCharIndex]);
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** We now have all the pieces in place so go search the
	** hivelist for the hives to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (hive list)", 
		    L"CShimWriterConfigDir::PopulateStopListRegistry");
	}



    while (SUCCEEDED (hrStatus) && bContinueHiveSearch)
	{
	DWORD	dwValueNameLength = ucsValueName.MaximumLength / sizeof (WCHAR);
	DWORD	dwValueDataLength = ucsValueData.MaximumLength;
	DWORD	dwValueType       = REG_NONE;
	BOOL	bMatchPrefix;
	BOOL	bMatchPostfix;


	StringTruncate (&ucsValueName, 0);
	StringTruncate (&ucsValueData, 0);


	/*
	** should be of type REG_SZ
	*/
	winStatus = RegEnumValueW (hkeyHivelist,
				   iIndex,
				   ucsValueName.Buffer,
				   &dwValueNameLength,
				   NULL,
				   &dwValueType,
				   (PBYTE)ucsValueData.Buffer,
				   &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueHiveSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumValueW", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");
	    }

	else
	    {
	    UNICODE_STRING	ucsPostFix;

	    BS_ASSERT ((REG_SZ == dwValueType) && L"Not REG_SZ string as expected");

	    ucsValueName.Length = (USHORT)(dwValueNameLength * sizeof (WCHAR));
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueName.Buffer [ucsValueName.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    /*
	    ** If it's to be considered part of system state the hive
	    ** file itself must live in %SystemRoot%\system32\config
	    ** so we attempt to find something in the returned value
	    ** name which looks like it might match. The format of the
	    ** name we are expecting is something like
	    **
	    **	\Device\<Volume>\Windows\system32\config\filename
	    **
	    ** for a system which has system32 in the 'Windows'
	    ** directory.  
	    **
	    ** Now, we have a known prefix, '\Device\', and the
	    ** postfix before and including the last '\', something
	    ** like '\Windows\system32\config\' as we determined
	    ** earlier. So we should be in a position to identify the
	    ** hives files we are interested in. Remember, we don't
	    ** know the piece representing the actual volume which is
	    ** why we are doing all this matching of pre and
	    ** post-fixs.
	    */
	    bMatchPrefix = RtlPrefixUnicodeString (&ucsHiveRecognitionPrefix,
						   &ucsValueData,
						   TRUE);


	    /*
	    ** Locate the last '\' in the value data. After this will
	    ** be the filename (eg 'SAM') which we will want later and
	    ** before that should be the postfix (eg
	    ** '\Windows\system32\config\') by which we will recognise
	    ** this as a registry hive.
	    */
	    pwchLastSlash = wcsrchr (ucsValueData.Buffer, DIR_SEP_CHAR);

	    if ((NULL == pwchLastSlash) ||
		(ucsValueData.Length < (ucsHiveRecognitionPrefix.Length + ucsHiveRecognitionPostfix.Length)))
		{
		/*
		** We coundn't find a '\' or the value data wasn't
		** long enough.
		*/
		bMatchPostfix = FALSE;
		}
	    else
		{
		/*
		** Determine the name of the give file.
		*/
		pwszFilename = pwchLastSlash + 1;


		/*
		** Determine the postfix we are going to try to match
		** against. This should look something like
		** '\Windows\system32\config\SAM'.
		*/
		StringInitialise (&ucsPostFix,
				  pwszFilename - (ucsHiveRecognitionPostfix.Length / sizeof (WCHAR)));


		/*
		** See if the recognition string (eg
		** '\Windows\system32\config\') is a prefix of the
		** location of this hive file (eg
		** '\Windows\system32\config\SAM')
		*/
		bMatchPostfix = RtlPrefixUnicodeString (&ucsHiveRecognitionPostfix,
							&ucsPostFix,
							TRUE);
		}


	    if (bMatchPrefix && bMatchPostfix)
		{
		USHORT	usOriginalFilenameLength;


		/*
		** We got ourselves a real live registry hive! The
		** means we add the filename itself along with the
		** same name with .sav, .alt and .log extensions.
		*/
		StringTruncate (&ucsRegistryHivePath, 0);
		StringAppendString (&ucsRegistryHivePath, pwszFilename);

		usOriginalFilenameLength = ucsRegistryHivePath.Length / sizeof (WCHAR);


		hrStatus = VertexAdd (&ucsRegistryHivePath);

		if (SUCCEEDED (hrStatus))
		    {
		    StringAppendString (&ucsRegistryHivePath, L".alt");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }

		if (SUCCEEDED (hrStatus))
		    {
		    StringTruncate     (&ucsRegistryHivePath, usOriginalFilenameLength);
		    StringAppendString (&ucsRegistryHivePath, L".sav");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }

		if (SUCCEEDED (hrStatus))
		    {
		    StringTruncate     (&ucsRegistryHivePath, usOriginalFilenameLength);
		    StringAppendString (&ucsRegistryHivePath, L".log");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    iIndex++;
	    }
	}




    if (bHivelistKeyOpened)
	{
	RegCloseKey (hkeyHivelist);
	}

    StringFree (&ucsHiveRecognitionPostfix);
    StringFree (&ucsRegistryHivePath);
    StringFree (&ucsValueData);
    StringFree (&ucsValueName);



    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopListRegistry () */



HRESULT CShimWriterConfigDir::CleanupStopList ()
    {
    HRESULT		hrStatus          = NOERROR;
    ULONG		ulNumberOfEntries = RtlNumberGenericTableElements (&m_StopList);
    BOOL		bSucceeded        = FALSE;
    PVERTEXRECORD	pSearchRecord     = NULL;
    PVERTEXRECORD	pStopListEntry;


    pSearchRecord = (PVERTEXRECORD) HeapAlloc (GetProcessHeap (),
					       HEAP_ZERO_MEMORY,
					       sizeof (VERTEXRECORD) + (MAX_PATH * sizeof (WCHAR)));

    hrStatus = GET_STATUS_FROM_POINTER (pSearchRecord);



    if (SUCCEEDED (hrStatus))
	{
	StringInitialise (&pSearchRecord->ucsVertexName);

	pSearchRecord->ucsVertexName.Buffer = (PWCHAR)((PBYTE)pSearchRecord + sizeof (VERTEXRECORD));
	}



    while (SUCCEEDED (hrStatus) && ulNumberOfEntries--)
	{
	pStopListEntry = (PVERTEXRECORD) RtlGetElementGenericTable (&m_StopList, ulNumberOfEntries);

	StringCreateFromString (&pSearchRecord->ucsVertexName, &pStopListEntry->ucsVertexName);

	bSucceeded = RtlDeleteElementGenericTable (&m_StopList, pSearchRecord);
	}



    BS_ASSERT (RtlIsGenericTableEmpty (&m_StopList));


    if (NULL != pSearchRecord)
	{
	HeapFree (GetProcessHeap (), 0, pSearchRecord);
	}


    return (hrStatus);
    } /* CShimWriterConfigDir::CleanupStopList () */


BOOL CShimWriterConfigDir::FileInStopList (PWCHAR pwszFilename)
    {
    BOOL		bFoundInStoplist;
    VERTEXRECORD	SearchRecord;
    PVERTEXRECORD	pVertexRecord;



    bFoundInStoplist = NameIsDotOrDotDot (pwszFilename);

    if (!bFoundInStoplist)
	{
	StringCreateFromString (&SearchRecord.ucsVertexName, pwszFilename);

	pVertexRecord = (PVERTEXRECORD) RtlLookupElementGenericTable (&m_StopList, (PVOID) &SearchRecord);

	bFoundInStoplist = (NULL != pVertexRecord);

	StringFree (&SearchRecord.ucsVertexName);
	}


    return (bFoundInStoplist);
    } /* CShimWriterConfigDir::FileInStopList () */


HRESULT CShimWriterConfigDir::CopyConfigDirFiles ()
    {
    CVssFunctionTracer ft( VSSDBG_SHIM, L"CShimWriterConfigDir::CopyConfigDirFiles" );        
    HRESULT		hrStatus   = NOERROR;
    BOOL		bMoreFiles = FALSE;
    BOOL		bSucceeded;
    HANDLE		hFileScan;
    WIN32_FIND_DATA	sFileInformation;
    UNICODE_STRING	ucsFileSourcePath;
    UNICODE_STRING	ucsFileTargetPath;
    USHORT		usFileSourcePathOriginalLength;
    USHORT		usFileTargetPathOriginalLength;

    
    StringInitialise (&ucsFileSourcePath);
    StringInitialise (&ucsFileTargetPath);


    hrStatus = StringCreateFromExpandedString (&ucsFileSourcePath,
					       CONFIGDIR_SOURCE_PATH,
					       MAX_PATH);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsFileTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsFileSourcePath, DIR_SEP_STRING);
	StringAppendString (&ucsFileTargetPath, DIR_SEP_STRING);


	usFileSourcePathOriginalLength = ucsFileSourcePath.Length / sizeof (WCHAR);
	usFileTargetPathOriginalLength = ucsFileTargetPath.Length / sizeof (WCHAR);


	StringAppendString (&ucsFileSourcePath, L"*");


	hFileScan = FindFirstFileW (ucsFileSourcePath.Buffer,
				    &sFileInformation);

	hrStatus = GET_STATUS_FROM_HANDLE (hFileScan);

	LogFailure (&ft, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"FindFirstFileW", 
		    L"CShimWriterConfigDir::CopyConfigDirFiles");
	}


    if (SUCCEEDED (hrStatus))
	{
	do
	    {
	    if (!FileInStopList (sFileInformation.cFileName))
		{
		StringTruncate (&ucsFileSourcePath, usFileSourcePathOriginalLength);
		StringTruncate (&ucsFileTargetPath, usFileTargetPathOriginalLength);

		StringAppendString (&ucsFileSourcePath, sFileInformation.cFileName);
		StringAppendString (&ucsFileTargetPath, sFileInformation.cFileName);


		bSucceeded = CopyFileExW (ucsFileSourcePath.Buffer,
					  ucsFileTargetPath.Buffer,
					  NULL,
					  NULL,
					  FALSE,
					  0);

		hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

                if ( FAILED( hrStatus ) )
                    {
                    ft.Trace( VSSDBG_SHIM, L"CopyFileExW( '%s', '%s', ... ) failed with rc: %d", 
                            ucsFileSourcePath.Buffer, ucsFileTargetPath.Buffer, ::GetLastError() );
                    hrStatus = S_OK;   // Make sure to clear out the error
                    }                    
                }


	    bMoreFiles = FindNextFileW (hFileScan, &sFileInformation);
	    } while ( bMoreFiles );


	bSucceeded = FindClose (hFileScan);
	}



    StringFree (&ucsFileTargetPath);
    StringFree (&ucsFileSourcePath);

    return (hrStatus);
    } /* CShimWriterConfigDir::CopyConfigDirFiles () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrdefs.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrdefs.h

Abstract:

    Definitions for snapshot shim writers

Author:

    Stefan R. Steiner   [ssteiner]        01-31-2000

Revision History:

	X-10	MCJ		Michael C. Johnson		21-Sep-2000
		185047: Need to distinguish Thaw event from Abort events.

	X-9	MCJ		Michael C. Johnson		 8-Aug-2000
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree() (not in CShimWriter class).

	X-8	MCJ		Michael C. Johnson		12-Jun-2000
		Have the shim writers reposnd to OnIdentify events from the 
		snapshot coordinator. This requies splitting the shim writers 
		into two groups (selected by BootableState)

	X-7	MCJ		Michael C. Johnson		 6-Jun-2000
		Add method CShimWriter::CreateTargetPath() to aid in moving
		common target directory processing to method 
		CShimWriter::PrepareForSnapshot()

	X-6	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		18-Feb-2000
		Added ConfigDir writer to the writers function table.

	X-3	MCJ		Michael C. Johnson		09-Feb-2000
		Added Registry and Event log writers to the writers
		function table.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Added IIS Metabase writer to the writers function
		table.

--*/

#ifndef __H_WRTRDEFS_
#define __H_WRTRDEFS_

#pragma once

#ifdef  __cplusplus
extern "C" {
#endif


/*
** Possible state to put a shim writer into. If this is changed you
** MUST change the state table manipulated by CShimWriter::SetState()
*/
typedef enum _ShimWriterState
    {
     stateUnknown = 0
    ,stateStarting
    ,stateStarted
    ,statePreparingForSnapshot
    ,statePreparedForSnapshot
    ,stateFreezing
    ,stateFrozen
    ,stateThawing
    ,stateAborting
    ,stateThawed
    ,stateFinishing
    ,stateFinished
    ,stateMaximumValue
    } SHIMWRITERSTATE;



class CShimWriter
    {
public:
    CShimWriter (LPCWSTR pwszApplicationString);
    CShimWriter (LPCWSTR pwszApplicationString, BOOL bParticipateInBootableState);
    CShimWriter (LPCWSTR pwszApplicationString, LPCWSTR pwszTargetPath);
    CShimWriter (LPCWSTR pwszApplicationString, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState);

    virtual ~CShimWriter (VOID);

    HRESULT Startup  (void);
    HRESULT Shutdown (void);

    HRESULT Identify (IN IVssCreateWriterMetadata *pIVssCreateWriterMetadata);

    HRESULT PrepareForSnapshot (
				IN BOOL     bBootableStateBackup,
				IN ULONG    ulVolumeCount,
				IN LPCWSTR *ppwszVolumeNamesList);

    HRESULT Freeze ();
    HRESULT Thaw   ();
    HRESULT Abort  ();

private:
    HRESULT SetState (SHIMWRITERSTATE ssNewWriterState, HRESULT hrNewStatus);
    LPCWSTR GetStringFromStateCode (SHIMWRITERSTATE ssStateCode);


    /*
    ** These DoXxxx() are the routines that an individual writer may
    ** choose to over-ride.
    */
    virtual HRESULT DoStartup            (void);
    virtual HRESULT DoIdentify           (void);
    virtual HRESULT DoPrepareForBackup   (void);
    virtual HRESULT DoPrepareForSnapshot (void);
    virtual HRESULT DoFreeze             (void);
    virtual HRESULT DoThaw               (void);
    virtual HRESULT DoAbort              (void);
    virtual HRESULT DoBackupComplete     (void);
    virtual HRESULT DoShutdown           (void);


public:
    const BOOL			 m_bBootableStateWriter;
    const LPCWSTR		 m_pwszWriterName;

protected:
    const LPCWSTR		 m_pwszTargetPath;
    SHIMWRITERSTATE		 m_ssCurrentState;
    HRESULT			 m_hrStatus;
    BOOL			 m_bParticipateInBackup;
    ULONG			 m_ulVolumeCount;
    LPCWSTR			*m_ppwszVolumeNamesArray;
    IVssCreateWriterMetadata	*m_pIVssCreateWriterMetadata;
    IVssWriterComponents	*m_pIVssWriterComponents;
    };


typedef CShimWriter *PCShimWriter;



} // extern "C"

#endif // __H_WRTRDEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtreventlog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtreventlog.cpp | Implementation of SnapshotWriter for Event logs



Author:

    Michael C. Johnson [mikejohn] 14-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-10	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-9	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.


	X-8	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-7	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-6	MCJ		Michael C. Johnson		02-Jun-2000
		Make event log writer sensitive to which volumes are being 
		backed up/snapshotted.

	X-5	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-4	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-3	MCJ		Michael C. Johnson		 3-Mar-2000
		Remove inner registry search loop, instead use a direct
		lookup.
		Do a preparatory cleanup of the target save directory to make
		sure we don't have to deal with any junk left from a previous
		invokcation.
		

	X-2	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-1	MCJ		Michael C. Johnson		14-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHEVLGC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"EventLogs"
#define COMPONENT_NAME				L"Event Logs"
#define TARGET_PATH				ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define EVENTLOG_SUBKEY_EVENTLOG		L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define EVENTLOG_VALUENAME_FILE			L"File"

#define EVENTLOG_BUFFER_SIZE			(4096)

DeclareStaticUnicodeString (ucsValueRecognitionFile, EVENTLOG_VALUENAME_FILE);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterEventLog : public CShimWriter
    {
public:
    CShimWriterEventLog (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterEventLog ShimWriterEventLog (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterEventLog = &ShimWriterEventLog;




/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterEventLog::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterEventLog::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (L"%SystemRoot%\\system32\\config",
								 L"*.evt",
								 false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CShimWriterEventLog::DoIdentify () */


/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT from HapeAlloc(), RegXxxx() or event log operations

--*/

HRESULT CShimWriterEventLog::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    DWORD		dwIndex                     = 0;
    HKEY		hkeyEventLogList            = NULL;
    BOOL		bSucceeded                  = FALSE;
    BOOL		bEventLogListKeyOpened      = FALSE;
    BOOL		bEventLogValueFileKeyOpened = FALSE;
    BOOL		bContinueEventLogSearch     = TRUE;
    UNICODE_STRING	ucsEventLogSourcePath;
    UNICODE_STRING	ucsEventLogTargetPath;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;
    USHORT		usEventLogTargetPathRootLength;



    StringInitialise (&ucsEventLogTargetPath);
    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsEventLogTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsEventLogTargetPath, DIR_SEP_STRING);

	usEventLogTargetPathRootLength = ucsEventLogTargetPath.Length / sizeof (WCHAR);



	/*
	** We now have all the pieces in place so go search the eventlog list
	** for the logs to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   EVENTLOG_SUBKEY_EVENTLOG,
				   0L,
				   KEY_READ,
				   &hkeyEventLogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bEventLogListKeyOpened = SUCCEEDED (hrStatus);


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (eventlog list)", 
		    L"CShimWriterEventLog::DoPrepareForSnapshot");
	}



    while (SUCCEEDED (hrStatus) && bContinueEventLogSearch)
	{
	HKEY	hkeyEventLogValueFile       = NULL;
 	DWORD	dwSubkeyNameLength          = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyEventLogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);



	if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus))
	    {
	    hrStatus = NOERROR;

	    bContinueEventLogSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterEventLog::DoPrepareForSnapshot");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;



	    winStatus = RegOpenKeyExW (hkeyEventLogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyEventLogValueFile);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    bEventLogValueFileKeyOpened = SUCCEEDED (hrStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (eventlog name)", 
			L"CShimWriterEventLog::DoPrepareForSnapshot");


	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;

		StringTruncate (&ucsValueData, 0);
		StringTruncate (&ucsEventLogTargetPath, usEventLogTargetPathRootLength);		


		winStatus = RegQueryValueExW (hkeyEventLogValueFile,
					      EVENTLOG_VALUENAME_FILE,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);


		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterEventLog::DoPrepareForSnapshot");



		if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
		    {
		    HANDLE	hEventLog          = NULL;
		    BOOL	bIncludeInSnapshot = FALSE;
		    PWCHAR	pwszFilename;


		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;



		    StringInitialise (&ucsEventLogSourcePath);

		    hrStatus = StringCreateFromExpandedString (&ucsEventLogSourcePath,
							       ucsValueData.Buffer,
							       0);


		    if (SUCCEEDED (hrStatus))
			{
			hrStatus = IsPathInVolumeArray (ucsEventLogSourcePath.Buffer,
							m_ulVolumeCount,
							m_ppwszVolumeNamesArray,
							&bIncludeInSnapshot);
			}



		    if (SUCCEEDED (hrStatus) && bIncludeInSnapshot)
			{
			pwszFilename = wcsrchr (ucsEventLogSourcePath.Buffer, DIR_SEP_CHAR);

			pwszFilename = (NULL == pwszFilename)
						? ucsEventLogSourcePath.Buffer
						: pwszFilename + 1;

			StringAppendString (&ucsEventLogTargetPath, pwszFilename);



			hEventLog = OpenEventLogW (NULL,
						   ucsSubkeyName.Buffer);

			hrStatus = GET_STATUS_FROM_BOOL (NULL != hEventLog);

			LogFailure (NULL, 
				    hrStatus, 
				    hrStatus, 
				    m_pwszWriterName, 
				    L"OpenEventLogW", 
				    L"CShimWriterEventLog::DoPrepareForSnapshot");
			}


		    if (SUCCEEDED (hrStatus) && bIncludeInSnapshot)
			{
			bSucceeded = BackupEventLogW (hEventLog,
						      ucsEventLogTargetPath.Buffer);

			hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

			LogFailure (NULL, 
				    hrStatus, 
				    hrStatus, 
				    m_pwszWriterName, 
				    L"BackupEventLogW", 
				    L"CShimWriterEventLog::DoPrepareForSnapshot");


			bSucceeded = CloseEventLog (hEventLog);
			}


		    StringFree (&ucsEventLogSourcePath);
		    }
		}


	    if (bEventLogValueFileKeyOpened)
		{
		RegCloseKey (hkeyEventLogValueFile);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}



    if (bEventLogListKeyOpened)
	{
	RegCloseKey (hkeyEventLogList);
	}


    StringFree (&ucsEventLogTargetPath);
    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);

    return (hrStatus);
    } /* DoEventLogFreeze () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrmetabase.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrmetabase.cpp | Implementation of SnapshotWriter for IIS MetaBase.bin file

    NOTE: This module is not used/compiled anymore since IIS has its own snapshot writer.

Author:

    Michael C. Johnson [mikejohn] 06-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-9	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Remove trailing '\' from Include/Exclude lists.

	X-8	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		23-Mar-2000
		Fix bug where we didn't allow for the possibility that IIS
		may not be running on the machine.

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-3	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-2	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-1	MCJ		Michael C. Johnson		06-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"



#define APPLICATION_STRING	L"IisMetaBase"
#define COMPONENT_NAME		L"IIS Metabase"
#define METABASE_DIRECTORY	L"%SystemRoot%\\system32\\inetsrv"
#define METABASE_FILENAME	L"Metabase.bin"
#define METABASE_PATH		METABASE_DIRECTORY DIR_SEP_STRING METABASE_FILENAME




/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterMetabase : public CShimWriter
    {
public:
    CShimWriterMetabase(LPCWSTR pwszWriterName, BOOL bParticipateInBootableState) : 
		CShimWriter (pwszWriterName, bParticipateInBootableState), 
		m_hMetabaseFile(INVALID_HANDLE_VALUE) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoFreeze   (VOID);
    HRESULT DoThaw     (VOID);

    HANDLE  m_hMetabaseFile;
    };


static CShimWriterMetabase ShimWriterMetabase (APPLICATION_STRING, TRUE);

PCShimWriter pShimWriterIisMetabase = &ShimWriterMetabase;



/*
**++
**
** Routine Description:
**
**	The IIS metabase snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterMetabase::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     METABASE_DIRECTORY,
								     METABASE_FILENAME,
								     false,
								     NULL);
	}



    return (hrStatus);
    } /* CShimWriterMetabase::DoIdentify () */



HRESULT CShimWriterMetabase::DoFreeze ()
    {
    UNICODE_STRING	ucsMetabasePath;
    HRESULT		hrStatus;


    StringInitialise (&ucsMetabasePath);

    hrStatus = StringCreateFromExpandedString (&ucsMetabasePath,
					       METABASE_PATH,
					       0);


    /*
    ** Attempt to acquire read access to the file. This will stop
    ** anyone else opening it for updates until we release the open
    ** during the Thaw call.
    */
    if (SUCCEEDED (hrStatus))
	{
	m_hMetabaseFile = CreateFileW (ucsMetabasePath.Buffer,
				       GENERIC_READ,
				       FILE_SHARE_READ,
				       NULL,
				       OPEN_EXISTING,
				       FILE_FLAG_BACKUP_SEMANTICS,
				       NULL);

	hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != m_hMetabaseFile);

	if ((HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus) ||
	    (HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND) == hrStatus))
	    {
	    /*
	    ** Failure to find the file just means that IIS is not
	    ** running here and so there is no file to prevent writes
	    ** to.
	    */
	    hrStatus = NOERROR;
	    }
	}
	

    StringFree (&ucsMetabasePath);

    return (hrStatus);
    } /* CShimWriterMetabase::DoFreeze () */



HRESULT CShimWriterMetabase::DoThaw ()
    {
    HRESULT	hrStatus;


    /*
    ** Note that the handle may be invalid if we did not open the
    ** metabase file, but CommonCloseHandle() can cope with that case.
    */
    hrStatus = CommonCloseHandle (&m_hMetabaseFile);


    return (hrStatus);
    } /* CShimWriterMetabase::DoThaw () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrrsm.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrrsm.cpp

Abstract:

    Writer shim module for RSM

Author:

    Stefan R. Steiner   [ssteiner]        01-31-2000

Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

 	X-10	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path
		Also remove trailing '\' on export sibdurectory reported in 
		metadata.

	X-9	MCJ		Michael C. Johnson		18-Jul-2000
		145021: Load the Ntms dll dynamically to reduce footprint.

	X-8	MCJ		Michael C. Johnson		27-Jun-2000
		Add an alternative location mapping for the restore of the
		RSM spit files.
		Handle change in RSM startup behaviour which means calls to 
		OpenNtmsSession() may fail until service has started.

	X-7	MCJ		Michael C. Johnson		21-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-6	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-5	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		21-Mar-2000
		Get writer to use same context mechanism as most of the other
		writers.
		Check registry for presence of export path definition and use
		it if present.
		Also ensure it cleans up after itself.

	X-2	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

--*/

#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <ntmsapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHRSMC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING		L"RemovableStorageManager"
#define COMPONENT_NAME			L"Removable Storage Manager"

#define TARGET_PATH			ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define EXPORT_SUBDIRECTORY		L"\\Export"

#define SUBKEY_SOURCE_PATH_ROOT		L"SYSTEM\\CurrentControlSet\\Control\\NTMS\\NtmsData"
#define DEFAULT_SOURCE_PATH_ROOT	L"%SystemRoot%\\system32\\NtmsData"


#define NTMS_OPEN_SESSION_RETRY_PERIOD		(20)		// in seconds
#define NTMS_OPEN_SESSION_POLLING_INTERVAL	(100)		// in milli-seconds
#define NTMS_OPEN_SESSION_ATTEMPTS		((NTMS_OPEN_SESSION_RETRY_PERIOD * 1000) / NTMS_OPEN_SESSION_POLLING_INTERVAL)


typedef HANDLE (WINAPI *PFnOpenNtmsSessionW)   (LPCWSTR, LPCWSTR, DWORD);
typedef DWORD  (WINAPI *PFnCloseNtmsSession)   (HANDLE);
typedef DWORD  (WINAPI *PFnExportNtmsDatabase) (HANDLE);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterRSM : public CShimWriter
    {
public:
    CShimWriterRSM (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT DetermineDatabaseLocation (PUNICODE_STRING pucsDatabasePath);
    };


static CShimWriterRSM ShimWriterRSM (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterRSM = &ShimWriterRSM;


/*
**++
**
** Routine Description:
**
**	DetermineDatabaseLocation() attempts to locate the RSM (aka
**	NTMS) database location following the same rules as RSM uses.
**
**
** Arguments:
**
**	pucsDatabasePath	initliased unicode string
**
**
** Return Value:
**
**	HRESULTS from memory allocation failures and registry operations 
**
**-- 
*/

HRESULT CShimWriterRSM::DetermineDatabaseLocation (PUNICODE_STRING pucsDatabasePath)
    {
    HRESULT		hrStatus = NOERROR;
    DWORD		dwStatus;
    DWORD		dwValueDataLength;
    DWORD		dwValueType;
    UNICODE_STRING	ucsValueData;


    StringInitialise (&ucsValueData);

    StringFree (pucsDatabasePath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, 
				   REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Everything is setup, so first check to see if there is a
	** registry key present which will tell us where the Ntms
	** database is supposed to live. If it's got environment
	** variables in it make sure they get expanded.
	**
	** If there is no key we fall back to the default location.
	*/
	dwValueDataLength = ucsValueData.MaximumLength;
	dwValueType       = REG_NONE;

	dwStatus = RegQueryValueExW (HKEY_LOCAL_MACHINE,
				     SUBKEY_SOURCE_PATH_ROOT,
				     NULL,
				     &dwValueType,
				     (PBYTE) ucsValueData.Buffer,
				     &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) != hrStatus))
	    {
	    /*
	    ** This may be a real failure so log it just in case
	    ** things stop working later on.
	    */
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegQueryValueExW", 
			L"CShimWriterRSM::DetermineDatabaseLocation");
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    }



	if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
	    {
	    hrStatus = StringCreateFromExpandedString (pucsDatabasePath,
						       ucsValueData.Buffer,
						       MAX_PATH);
	    }

	else if (SUCCEEDED (hrStatus) && (REG_SZ == dwValueType))
	    {
	    hrStatus = StringAllocate (pucsDatabasePath,
				       MAX_PATH * sizeof (WCHAR));


	    if (SUCCEEDED (hrStatus))
		{
		StringAppendString (pucsDatabasePath, &ucsValueData);
		}
	    }

	else
	    {
	    /*
	    ** Ok we either failed to find the registry key or what we did
	    ** get wasn't suitable for us to use so fall back to the
	    ** 'standard default' location and just pray that's where the
	    ** ExportNtmsDatabase() call actually dumps it's data.
	    */
	    hrStatus = StringCreateFromExpandedString (pucsDatabasePath,
						       DEFAULT_SOURCE_PATH_ROOT,
						       MAX_PATH);
	    }
	}



    StringFree (&ucsValueData);


    return (hrStatus);
    } /* CShimWriterRSM::DetermineDatabaseLocation () */

/*
**++
**
** Routine Description:
**
**	The Removable Storage Manager database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRSM::DoIdentify ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRSM::DoIdentify");
    UNICODE_STRING	ucsDatabaseLocation;


    StringInitialise (&ucsDatabaseLocation);



    try
	{
	ft.hr = DetermineDatabaseLocation (&ucsDatabaseLocation);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRSM::DetermineDatabaseLocation");




	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (ucsDatabaseLocation.Buffer,
							      L"*",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");

	} 
    VSS_STANDARD_CATCH (ft)




    StringFree (&ucsDatabaseLocation);

    return (ft.hr);
    } /* CShimWriterRSM::DoIdentify () */

/*++

Routine Description:

    The RSM writer PrepareForFreeze function.  Currently all of the
    real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForFreeze event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterRSM::DoPrepareForSnapshot ()
    {
    HRESULT			hrStatus = NOERROR;
    HANDLE			hRsm     = INVALID_HANDLE_VALUE;
    HMODULE			hNtmsDll = NULL;
    DWORD			dwStatus;
    UNICODE_STRING		ucsTargetPath;
    UNICODE_STRING		ucsSourcePath;
    PFnOpenNtmsSessionW		DynamicOpenNtmsSessionW;
    PFnExportNtmsDatabase	DynamicExportNtmsDatabase;
    PFnCloseNtmsSession		DynamicCloseNtmsSession;


    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsSourcePath);


    hNtmsDll = LoadLibraryW (L"ntmsapi.dll");

    hrStatus = GET_STATUS_FROM_HANDLE (hNtmsDll);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"LoadLibraryW (ntmsapi.dll)", 
		L"CShimWriterRSM::DoPrepareForSnapshot");



    if (SUCCEEDED (hrStatus))
	{
	DynamicOpenNtmsSessionW = (PFnOpenNtmsSessionW) GetProcAddress (hNtmsDll, "OpenNtmsSessionW");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicOpenNtmsSessionW);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (OpenNtmsSessionW)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	DynamicExportNtmsDatabase = (PFnExportNtmsDatabase) GetProcAddress (hNtmsDll, "ExportNtmsDatabase");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicExportNtmsDatabase);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (ExportNtmsDatabase)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	DynamicCloseNtmsSession = (PFnCloseNtmsSession) GetProcAddress (hNtmsDll, "CloseNtmsSession");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicCloseNtmsSession);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (CloseNtmsSession)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** Get ourselves a copy of the target path we can play with
	*/
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Find the location of the database. The export files are
	** stored in a subdirectory off this.
	*/
	hrStatus = DetermineDatabaseLocation (&ucsSourcePath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"DetermineDatabaseLocation", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	ULONG	ulOpenSessionRetryAttempts = NTMS_OPEN_SESSION_ATTEMPTS;
	BOOL	bRetryNtmsOpenSession;


	/*
	** Add the necessary trailing bits and pieces to the source
	** and target paths. Note that we know that there is enough
	** space already so this cannot fail.
	*/
	StringAppendString (&ucsSourcePath, EXPORT_SUBDIRECTORY);


	/*
	** Now connect to RSM and tell it to copy the database
	**
	** As far as we know the RSM should dump the database in the
	** location we've already determined. If not then we are
	** sunk. Not much we can do about that.
	**
	** 
	*/
	do 
	    {	
	    hRsm = DynamicOpenNtmsSessionW (NULL, L"RSM Snapshot Writer", 0);

	    hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != hRsm);

	    bRetryNtmsOpenSession = (HRESULT_FROM_WIN32 (ERROR_NOT_READY) == hrStatus);

	    if (bRetryNtmsOpenSession)
		{
		Sleep (NTMS_OPEN_SESSION_POLLING_INTERVAL);
		}
	    } while (bRetryNtmsOpenSession && (--ulOpenSessionRetryAttempts > 0));


	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::DoPrepareForSnapshot: OpenNtmsSession() took %u retries",
			     NTMS_OPEN_SESSION_ATTEMPTS - ulOpenSessionRetryAttempts));


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"OpenNtmsSessionW", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	dwStatus = DynamicExportNtmsDatabase (hRsm);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"ExportNtmsDatabase", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");


	dwStatus = DynamicCloseNtmsSession (hRsm);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = MoveFilesInDirectory (&ucsSourcePath, &ucsTargetPath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (!HandleInvalid (hNtmsDll))
	{
	FreeLibrary (hNtmsDll);
	}

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);

    return (hrStatus);
    } /* CShimWriterRSM::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrregistry.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrregistry.cpp | Implementation of SnapshotWriter for Registry hives



Author:

    Michael C. Johnson [mikejohn] 08-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-14	MCJ		Michael C. Johnson		22-Oct-2000
		209095: Dynamically load the cluster library to reduce the 
		foot print for the unclustered.

	X-13	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-12	MCJ		Michael C. Johnson		25-Sep-2000
		185047: Leave copies of registry files in repair directory
			for compatibility with Win2k behaviour.
		182895: Need to collect cluster registry hive too.

	X-11	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-10	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-9	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-8	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()
 
	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-5	MCJ		Michael C. Johnson		 2-Mar-2000
		Do not copy the extra registry files as it turns out we have
		no need for them after all.
		Also do a preparatory cleanup of the save location to remove
		any old stuff left around from a previous run.

	X-4	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-3	MCJ		Michael C. Johnson		22-Feb-2000
		Add SYSTEM_STATE_SUBDIR to registry save path.

	X-2	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-1	MCJ		Michael C. Johnson		08-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <aclapi.h>
#include <clusapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHREGC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"Registry"
#define COMPONENT_NAME				APPLICATION_STRING

#define TARGET_PATH				ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING
#define REGISTRY_HIVE_PATH			L"%SystemRoot%\\system32\\config"

#define REGISTRY_SUBKEY_HIVELIST		L"SYSTEM\\CurrentControlSet\\Control\\hivelist"

#define REGISTRY_BUFFER_SIZE			(4096)

#define REPAIR_PATH				L"%SystemRoot%\\Repair\\"

#define	CLUSTER_HIVE_PATH			L"%SystemRoot%\\Cluster"
#define	CLUSTER_SUBKEY_HIVE_NAME		L"Cluster"


DeclareStaticUnicodeString (ucsHiveRecognitionPrefix,    L"\\Device\\");
DeclareStaticUnicodeString (ucsValueNameMachinePrefix,   L"\\REGISTRY\\MACHINE\\");
DeclareStaticUnicodeString (ucsValueNameUserPrefix,      L"\\REGISTRY\\USER\\");

DeclareStaticUnicodeString (ucsValuenameClusterHivefile, L"\\REGISTRY\\MACHINE\\Cluster");
DeclareStaticUnicodeString (ucsClusterHiveFilename,      L"ClusDb");



typedef DWORD	(WINAPI *PFnGetNodeClusterState)(LPCWSTR, PDWORD);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterRegistry : public CShimWriter
    {
public:
    CShimWriterRegistry (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState) :
		CShimWriter (pwszWriterName, pwszTargetPath, bParticipateInBootableState),
		m_pfnDynamicGetNodeClusterState (NULL),
		m_hmodClusApi                   (NULL) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    HRESULT DoThaw (VOID);
    HRESULT DoAbort (VOID);

    HRESULT BackupRegistryHives (VOID);
    HRESULT BackupClusterHives (VOID);

    HRESULT DynamicRoutinesLoadCluster (VOID);
    HRESULT DynamicRoutinesUnloadAll   (VOID);


    PFnGetNodeClusterState	m_pfnDynamicGetNodeClusterState;
    HMODULE			m_hmodClusApi;
    };


static CShimWriterRegistry ShimWriterRegistry (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterRegistry = &ShimWriterRegistry;



/*
**++
**
** Routine Description:
**
**	This routine loads the required Cluster DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DynamicRoutinesLoadCluster ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRegistry::DynamicRoutinesLoadCluster");


    try 
	{
	if ((NULL != m_pfnDynamicGetNodeClusterState)   ||
	    !HandleInvalid (m_hmodClusApi))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodClusApi = LoadLibraryW (L"ClusApi.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodClusApi);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (ClusApi.dll)");



	m_pfnDynamicGetNodeClusterState = (PFnGetNodeClusterState) GetProcAddress (m_hmodClusApi, "GetNodeClusterState");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicGetNodeClusterState);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (GetNodeClusterState)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_hmodClusApi                     = NULL;
	}


    return (ft.hr);
    } /* CShimWriterRegistry::DynamicRoutinesLoadCluster () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DynamicRoutinesUnloadAll ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRegistry::DynamicRoutinesUnloadAll");


    try 
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_hmodClusApi                     = NULL;
	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CShimWriterRegistry::DynamicRoutinesUnloadAll () */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterRegistry::DoIdentify");

    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;



    try
	{
	ft.hr = DynamicRoutinesLoadCluster ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	ft.hr = HRESULT_FROM_WIN32 (winStatus);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
 
	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");



	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (REGISTRY_HIVE_PATH,
							      L"*.log",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.log)");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (REGISTRY_HIVE_PATH,
							      L"*.sav",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.sav)");



	if (bClusterRunning)
	    {
	    ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (CLUSTER_HIVE_PATH,
								  ucsClusterHiveFilename.Buffer,
								  false);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");
	    }

	} VSS_STANDARD_CATCH (ft)


    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterRegistry::DoIdentify () */

/*
**++
**
**  Routine Description:
**
**	This routine invokes all the necessary functions to save all 
**	of the interesting 'system' hives.
**
**
**  Arguments:
**
**	Implicit through class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DoPrepareForSnapshot ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CShimWriterRegistry::DoPrepareForSnapshot");
    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;



    try
	{
	ft.hr = DynamicRoutinesLoadCluster ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	ft.hr = HRESULT_FROM_WIN32 (winStatus);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
 
	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



	ft.hr = BackupRegistryHives ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRegistry::BackupRegistryHives");



	if (bClusterRunning)
	    {
	    ft.hr = BackupClusterHives ();

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRegistry::BackupClusterHives");
	    }
	} VSS_STANDARD_CATCH (ft)


    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterRegistry::DoPrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Captures the standard registry hives.
**
**
**  Arguments:
**
**	Implicit through the class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::BackupRegistryHives ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    HKEY		hkeyHivelist        = NULL;
    HKEY		hkeyRoot            = NULL;
    HKEY		hkeyBackup          = NULL;
    INT			iIndex              = 0;
    BOOL		bSucceeded          = FALSE;
    BOOL		bHivelistKeyOpened  = FALSE;
    BOOL		bContinueHiveSearch = TRUE;
    PWCHAR		pwchLastSlash;
    PWCHAR		pwszFilename;
    PWCHAR		pwszKeyName;
    UNICODE_STRING	ucsRegistrySavePath;
    UNICODE_STRING	ucsRegistryHivePath;
    UNICODE_STRING	ucsHiveRecognitionPostfix;
    UNICODE_STRING	ucsValueName;
    UNICODE_STRING	ucsValueData;
    USHORT		usRegistrySavePathRootLength = 0;


    StringInitialise (&ucsRegistrySavePath);
    StringInitialise (&ucsRegistryHivePath);
    StringInitialise (&ucsHiveRecognitionPostfix);
    StringInitialise (&ucsValueName);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueName, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistryHivePath,
						   REGISTRY_HIVE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistrySavePath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwCharIndex;


	StringAppendString (&ucsRegistryHivePath, DIR_SEP_STRING);
	StringAppendString (&ucsRegistrySavePath, DIR_SEP_STRING);

	usRegistrySavePathRootLength = ucsRegistrySavePath.Length / sizeof (WCHAR);


	/*
	** Now we know the location of the hive files, determine the
	** postfix we are going to use to recognise hives when we
	** search the active hivelist key. To do this we just need to
	** lose the drive letter and the colon in the path, or to put
	** it another way, lose everthing before the first '\'. When
	** we are done, if everything works ucsRegistryHivePath will
	** look something like '\Windows\system32\config\'
	*/
	for (dwCharIndex = 0;
	     (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)))
		 && (DIR_SEP_CHAR != ucsRegistryHivePath.Buffer [dwCharIndex]);
	     dwCharIndex++)
	    {
	    /*
	    ** Empty loop body
	    */
	    }

	BS_ASSERT(dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)));

	hrStatus = StringCreateFromString (&ucsHiveRecognitionPostfix, &ucsRegistryHivePath.Buffer [dwCharIndex]);
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** We now have all the pieces in place so go search the
	** hivelist for the hives to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (hive list)", 
		    L"CShimWriterRegistry::BackupRegistryHives");
	}



    while (SUCCEEDED (hrStatus) && bContinueHiveSearch)
	{
	DWORD	dwValueNameLength = ucsValueName.MaximumLength / sizeof (WCHAR);
	DWORD	dwValueDataLength = ucsValueData.MaximumLength;
	DWORD	dwValueType       = REG_NONE;
	BOOL	bMatchPrefix;
	BOOL	bMatchPostfix;


	StringTruncate (&ucsValueName, 0);
	StringTruncate (&ucsValueData, 0);


	/*
	** should be of type REG_SZ
	*/
	winStatus = RegEnumValueW (hkeyHivelist,
				   iIndex,
				   ucsValueName.Buffer,
				   &dwValueNameLength,
				   NULL,
				   &dwValueType,
				   (PBYTE)ucsValueData.Buffer,
				   &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueHiveSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumValueW", 
			L"CShimWriterRegistry::BackupRegistryHives");
	    }

	else
	    {
	    UNICODE_STRING	ucsPostFix;

	    BS_ASSERT ((REG_SZ == dwValueType) && L"Not REG_SZ string as expected");

	    ucsValueName.Length = (USHORT)(dwValueNameLength * sizeof (WCHAR));
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueName.Buffer [ucsValueName.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    /*
	    ** If it's to be considered part of system state the hive
	    ** file itself must live in %SystemRoot%\system32\config
	    ** so we attempt to find something in the returned value
	    ** name which looks like it might match. The format of the
	    ** name we are expecting is something like
	    **
	    **	\Device\<Volume>\Windows\system32\config\filename
	    **
	    ** for a system which has system32 in the 'Windows'
	    ** directory.  
	    **
	    ** Now, we have the known prefix, '\Device\', and the
	    ** postfix before and including the last '\', something
	    ** like '\Windows\system32\config\' as we determined
	    ** earlier. So we should be in a position to identify the
	    ** hives files we are interested in. Remember, we don't
	    ** know the piece representing the actual volume which is
	    ** why we are doing all this matching of pre and
	    ** post-fixs.
	    */
	    bMatchPrefix = RtlPrefixUnicodeString (&ucsHiveRecognitionPrefix,
						   &ucsValueData,
						   TRUE);


	    /*
	    ** Locate the last '\' in the value data. After this will
	    ** be the filename (eg 'SAM') which we will want later and
	    ** before that should be the postfix (eg
	    ** '\Windows\system32\config\') by which we will recognise
	    ** this as a registry hive.
	    */
	    pwchLastSlash = wcsrchr (ucsValueData.Buffer, DIR_SEP_CHAR);

	    if ((NULL == pwchLastSlash) ||
		(ucsValueData.Length < (ucsHiveRecognitionPrefix.Length + ucsHiveRecognitionPostfix.Length)))
		{
		/*
		** We coundn't find a '\' or the value data wasn't
		** long enough.
		*/
		bMatchPostfix = FALSE;
		}
	    else
		{
		/*
		** Determine the name of the give file.
		*/
		pwszFilename = pwchLastSlash + 1;


		/*
		** Determine the postfix we are going to try to match
		** against. This should look something like
		** '\Windows\system32\config\SAM'.
		*/
		StringInitialise (&ucsPostFix,
				  pwszFilename - (ucsHiveRecognitionPostfix.Length / sizeof (WCHAR)));



		/*
		** See if the recognition string (eg
		** '\Windows\system32\config\') is a prefix of the
		** location of this hive file (eg
		** '\Windows\system32\config\SAM')
		*/
		bMatchPostfix = RtlPrefixUnicodeString (&ucsHiveRecognitionPostfix,
							&ucsPostFix,
							TRUE);
		}


	    if (bMatchPrefix && bMatchPostfix)
		{
		/*
		** We got ourselves a real live registry hive!
		*/
		/*
		** generate savename from hive name.
		*/
		StringAppendString (&ucsRegistrySavePath, pwszFilename);


		/*
		** Decide which registry root this is under by
		** comparing the value name we retrieved earlier (eg
		** '\REGISTRY\MACHINE\SAM') against the
		** '\REGISTRY\MACHINE' prefix.
		**
		** Note that we only expect either HKLM or HKLU so we
		** assume if it's not HKLM it must be HKLU. If that
		** changes this test must be re-visited.
		*/
		hkeyRoot = RtlPrefixUnicodeString (&ucsValueNameMachinePrefix,
						   &ucsValueName,
						   TRUE)
				? HKEY_LOCAL_MACHINE
				: HKEY_USERS;


		BS_ASSERT ((HKEY_LOCAL_MACHINE == hkeyRoot) ||
			   (RtlPrefixUnicodeString (&ucsValueNameUserPrefix,
						    &ucsValueName,
						    TRUE)));
						    

		/*
		** Need to find what name to use for the key we are
		** going to do the registry save from. In most cases
		** this is going to be the same as the filename, eg
		** the 'HKLM\SAM' for the 'SAM' hive file, but in some
		** (e.g. for the default user stuff) it's going to
		** have a '.' prefix, eg 'HKLU\.DEFAULT' for the
		** 'default' hive file. So we do the generic thing and
		** use whatever is after the last '\' in the value
		** name.
		*/
		pwszKeyName = wcsrchr (ucsValueName.Buffer, DIR_SEP_CHAR) + 1;

		winStatus = RegCreateKeyEx (hkeyRoot,
					    pwszKeyName,
					    0,
					    NULL,
					    REG_OPTION_BACKUP_RESTORE,
					    MAXIMUM_ALLOWED,
					    NULL,
					    &hkeyBackup,
					    NULL);
	
		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegCreateKeyEx", 
			    L"CShimWriterRegistry::BackupRegistryHives");


		if (SUCCEEDED (hrStatus))
		    {
		    //
		    //  Use the new RegSaveKeyExW with REG_NO_COMPRESSION option to 
		    //  quickly spit out the hives.
		    //
		    winStatus = RegSaveKeyExW (hkeyBackup, ucsRegistrySavePath.Buffer, NULL, REG_NO_COMPRESSION);

		    hrStatus = HRESULT_FROM_WIN32 (winStatus);

		    LogFailure (NULL, 
				hrStatus, 
				hrStatus, 
				m_pwszWriterName, 
				L"RegSaveKey", 
				L"CShimWriterRegistry::BackupRegistryHives");


		    RegCloseKey (hkeyBackup);
		    }


		StringTruncate (&ucsRegistrySavePath, usRegistrySavePathRootLength);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    iIndex++;
	    }
	}



    if (bHivelistKeyOpened)
	{
	RegCloseKey (hkeyHivelist);
	}

    StringFree (&ucsHiveRecognitionPostfix);
    StringFree (&ucsRegistryHivePath);
    StringFree (&ucsRegistrySavePath);
    StringFree (&ucsValueData);
    StringFree (&ucsValueName);

    return (hrStatus);
    } /* CShimWriterRegistry::BackupRegistryHives () */

/*
**++
**
**  Routine Description:
**
**	Captures the cluster registry hive.
**
**
**  Arguments:
**
**	Implicit through the class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/


HRESULT CShimWriterRegistry::BackupClusterHives ()
    {
    HRESULT		hrStatus           = NOERROR;
    DWORD		winStatus;
    DWORD		dwValueType        = REG_NONE;
    DWORD		dwValueDataLength;
    HCLUSTER		hCluster           = NULL;
    HKEY		hkeyHivelist       = NULL;
    HKEY		hkeyBackup         = NULL;
    BOOL		bHivelistKeyOpened = FALSE;
    BOOL		bClusterPresent    = FALSE;
    BOOL		bSucceeded;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsBackupPath;
    UNICODE_STRING	ucsBackupHiveFilename;



    StringInitialise (&ucsValueData);
    StringInitialise (&ucsBackupPath);
    StringInitialise (&ucsBackupHiveFilename);


    hrStatus = StringCreateFromExpandedString (&ucsBackupPath,
					       m_pwszTargetPath,
					       0);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsBackupHiveFilename, ucsBackupPath.Length
								+ sizeof (DIR_SEP_CHAR)
								+ ucsClusterHiveFilename.Length
								+ sizeof (UNICODE_NULL));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, &ucsBackupPath);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, DIR_SEP_STRING);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, &ucsClusterHiveFilename);
	}



    /*
    ** Check for presence of cluster hive in hivelist. That should be
    ** there (error out if missing) and have the value we expect. Then
    ** do a RegSaveKey() to collect a copy of the hive.
    */
    if (SUCCEEDED (hrStatus))
	{
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (cluster hive)", 
		    L"CShimWriterRegistry::BackupClusterHives");
	}



    if (SUCCEEDED (hrStatus))
	{
	dwValueDataLength = ucsValueData.MaximumLength;

	winStatus = RegQueryValueExW (hkeyHivelist,
				      ucsValuenameClusterHivefile.Buffer,
				      NULL,
				      &dwValueType,
				      (PBYTE)ucsValueData.Buffer,
				      &dwValueDataLength);

	hrStatus = (REG_SZ == dwValueType) 
			? HRESULT_FROM_WIN32 (winStatus)
			: HRESULT_FROM_WIN32 (ERROR_CLUSTER_INVALID_NODE);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegQueryValueExW", 
		    L"CShimWriterRegistry::BackupClusterHives");
	}



    if (SUCCEEDED (hrStatus))
	{
	ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	/*
	** Looks like the cluster hive exists. Try to back it up to
	** the spit directory.
	*/
	winStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
				    CLUSTER_SUBKEY_HIVE_NAME,
				    0,
				    NULL,
				    REG_OPTION_BACKUP_RESTORE,
				    MAXIMUM_ALLOWED,
				    NULL,
				    &hkeyBackup,
				    NULL);
	
	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegCreateKeyEx", 
		    L"CShimWriterRegistry::BackupClusterHives");

	if (SUCCEEDED (hrStatus))
	    {
	    winStatus = RegSaveKey (hkeyBackup, 
				    ucsBackupHiveFilename.Buffer, 
				    NULL);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegSaveKey", 
			L"CShimWriterRegistry::BackupClusterHives");

	    RegCloseKey (hkeyBackup);
	    }
	}



    /*
    ** All the cleanup code.
    */
    if (bHivelistKeyOpened)        RegCloseKey (hkeyHivelist);

    StringFree (&ucsBackupHiveFilename);
    StringFree (&ucsBackupPath);
    StringFree (&ucsValueData);

    return (hrStatus);
    } /* CShimWriterRegistry::BackupClusterHives () */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoThaw() function. This will
**	place a copy of all the generated registry hives in the repair
**	directory to maintain backwards compatibility with Win2k and
**	so keep PSS happy.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- 
*/

HRESULT CShimWriterRegistry::DoThaw ()
    {
    HRESULT		hrStatus;
    UNICODE_STRING	ucsWriterResultPath;
    UNICODE_STRING	ucsRepairDirectory;


    StringInitialise (&ucsWriterResultPath);
    StringInitialise (&ucsRepairDirectory);


    hrStatus = StringCreateFromExpandedString (&ucsWriterResultPath, m_pwszTargetPath, MAX_PATH);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRepairDirectory, REPAIR_PATH, MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = MoveFilesInDirectory (&ucsWriterResultPath, &ucsRepairDirectory);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterRegistry::DoThaw");
	}


    StringFree (&ucsWriterResultPath);
    StringFree (&ucsRepairDirectory);

    return (hrStatus);
    } /* CShimWriterRegistry::DoThaw() */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoAbort() function. Since the
**	default action for DoAbort() is to call DoThaw() and we don't
**	want to copy the possibly incomplete set of registry files to
**	the repair directory..
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- 
*/

HRESULT CShimWriterRegistry::DoAbort ()
    {
    /*
    ** We don't actually need to do anything here as the cleanup will
    ** happen automatically in the calling code. We just need to
    ** prevent the default DoAbort() method call.
    */

    return (NOERROR);
    } /* CShimWriterRegistry::DoAbort() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrshim.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrshim.cpp

Abstract:

    Contains the exported DLL functions for VssAPI.dll.
    BUGBUG: Uses code that currently sets the SE handler.  Since the SEH is process
        wide, this can/will effect the user of this DLL.  Need to fix.

Author:

    SSteiner    1/27/2000

Revision History:

	Name		Date		Comments
    SSteiner    2/10/2000   Added single instance support to the shim dll
    MikeJohn    2/17/2000   Added test entry point TestShimWriter()
    MikeJohn    2/23/2000   Stop phaseAll invoking freeze levels 2 and 1
                            Add new entry points to allow triggering shim
                            without snapshots.
    mikejohn	03/09/2000  Move to using CVssWriter class
    mikejohn	03/24/2000  Fix minor problem in TestShimWriters() causing
                            freeze to be skipped
    mikejohn    04/28/2000  Rename vswrshim.dll to VssAPI.dll
    mikejohn	05/15/2000  107129: Ensure that all the writers receive all
			            the events even in the presence of
				    earlier failures.
			    108586: Check the privs of the callers of all the
			            public entry points. Also remove the
				    TestShimWriters() entry point.
			    108543: Ensure that SimulateXxxx() calls work once
				    the shim has had a successful invocation
				    of RegisterSnapshotSubscriptions()
    mikejohn	05/26/2000  120443: Make shim listen to all OnAbort events
			    120445: Ensure shim never quits on first error
				    when delivering events
			    108580: SimulateSnapshotFreeze can be called
				    asynchronously
			    123097: Allow selection of bootable state
			    General clean up and removal of boiler-plate code,
			    correct state engine and ensure shim can undo
			    everything it did.
    mikejohn	06/02/2000  Make shim sensitive to volume list
    mikejohn	06/06/2000  Move common target directory cleanup and creation
			    into CShimWriter::PrepareForSnapshot()
    mikejohn	06/14/2000  Change the return code from async freeze to be
			    compatible with the snapshot coordinator
    mikejohn	06/15/2000  Temporarily remove the debug trace statement for
			    thread creation/deletion in the vssapi dll to see
			    if ameliorates effects of the rapid thread
			    creation/deletion problem.
    mikejohn	06/16/2000  Have the shim writers respond to OnIdentify events
			    from the snapshot coordinator. This requies
			    splitting the shim writers into two groups
			    (selected by BootableState)
    mikejohn	06/19/2000  Apply code review comments.
			    128883: Add shim writer for WMI database
    mikejohn	07/05/2000  143367: Do all shim writer processing in a worker
			    thread to allow the acquisition of a mutex that can
			    be held over the Prepare to Thaw/Abort codepath.
			    Also remove the spit directory cleanup calls for paths
			    not protected by the mutex.
			    141305: Ensure Writers call SetWriterFailure() if they
			    are about to fail in response to an OnXxxx() event.
    mikejohn	08/08/2000  94487:  Add an ACL to the spit directory tree to limit
			            access to members of the Administrators group
				    or those holding the Backup privilege.
			    153807: Replace CleanDirectory() and EmptyDirectory()
				    with a more comprehensive directory tree
				    cleanup routine RemoveDirectoryTree() (not in
				    CShimWriter class).
    mikejohn	09/12/2000  177925: Check option flags argument unused bits are
				    all set to zero (ie MBZ bits)
			    180192: Fix PREFIX bug in DllMain()
    mikejohn	10/04/2000  177624: Apply error scrub changes and log errors to
				    event log
    mikejohn	10/21/2000  209047: Remove the metabase shim writer now that
				    there is a real one.
    mikejohn	10/23/2000  210070: Test for NULL ptr in SimulatesnapshotFreeze() rather
				    than taking AV exception
			    210264: Prevent SimulateXxxx() calls from returning
				    Win32 errors.
			    210305: Check SnapshotSetId on SimulateSnapshotXxxx() calls
			    210393: Return appropriate error message for an invalid arg.
    ssteiner	11/10/2000  143810 Move SimulateSnapshotXxxx() calls to be hosted by VsSvc.
    mikejohn	11/30/2000  245587: Return the correct error codes for access denied.
			    245896: Build security descriptors correctly
    ssteiner   	03/09/2001  289822, 321150, 323786 Removed mutexes, changed state table, changed
                shutdown.

--*/


#include "stdafx.h"

#include <aclapi.h>
#include <comadmin.h>

/*
** ATL
*/
CComModule _Module;
#include <atlcom.h>

#include "comadmin.hxx"

#include "vssmsg.h"
#include "wrtrdefs.h"
#include "common.h"
#include "vs_sec.hxx"


/*
** We just need the following to obtain the definition of UnregisterSnapshotSubscriptions()
*/
#include "vscoordint.h"
#include "vsevent.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"


BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHWSHMC"

/*
** External definitions to allow us to link in the various shim writer
** instances. No need to place these in a header file as this is the
** only place they are or should be used
*/

extern PCShimWriter pShimWriterCI;		// in wrtrci.cpp
extern PCShimWriter pShimWriterClusterDb;	// in wrtrclus.cpp
extern PCShimWriter pShimWriterComPlusRegDb;	// in wrtrcomdb.cpp
extern PCShimWriter pShimWriterConfigDir;	// in wrtrconfig.cpp
extern PCShimWriter pShimWriterEventLog;	// in wrtreventlog.cpp
extern PCShimWriter pShimWriterRegistry;	// in wrtrregistry.cpp
extern PCShimWriter pShimWriterRSM;		// in wrtrrsm.cpp
extern PCShimWriter pShimWriterTLS;		// in wrtrtls.cpp
extern PCShimWriter pShimWriterWMI;		// in wrtrwmi.cpp


#define SHIM_APPLICATION_NAME_BOOTABLE_STATE	L"Microsoft Writer (Bootable State)"
#define SHIM_APPLICATION_NAME_SERVICE_STATE	L"Microsoft Writer (Service State)"


#define WORKER_THREAD_SHUTDOWN_TIMEOUT	(2 * 1000)
#define WORKER_THREAD_REQUEST_TIMEOUT	(5 * 60 * 1000)

// the name of the Volume Snapshot Service
const LPCWSTR wszVssvcServiceName = L"VSS";


typedef enum _SecurityAttributeType
    {
    esatUndefined = 0,
    esatMutex,
    esatFile
    } SecurityAttributeType;


typedef enum _WriterType
    {
    eWriterTypeUndefined = 0,
    eBootableStateOnly,
    eNonBootableStateOnly,
    eAllWriters
    } WriterType;


typedef enum _RequestOpCode
    {
    eOpUndefined = 0,
    eOpDeliverEventStartup,
    eOpDeliverEventIdentify,
    eOpDeliverEventPrepareForBackup,
    eOpDeliverEventPrepareForSnapshot,
    eOpDeliverEventFreeze,
    eOpDeliverEventThaw,
    eOpDeliverEventAbort,
    eOpWorkerThreadShutdown
    } RequestOpCode;


typedef enum _ThreadStatus
    {
    eStatusUndefined = 0,
    eStatusWaitingForOpRequest,
    eStatusProcessingOpRequest,
    eStatusNotRunning
    } ThreadStatus;


typedef struct _ArgsIdentify
    {
    IVssCreateWriterMetadata *pIVssCreateWriterMetadata;
    } ArgsIdentify;


typedef struct _ArgsPrepareForSnapshot
    {
    GUID     guidSnapshotSetId;
    BOOL     bBootableStateBackup;
    ULONG    ulVolumeCount;
    LPCWSTR *ppwszVolumeNamesArray;
    volatile bool *pbCancelAsync;
    } ArgsPrepareForSnapshot;


typedef struct _ArgsFreeze
    {
    GUID     guidSnapshotSetId;
    volatile bool *pbCancelAsync;
    } ArgsFreeze;


typedef struct _ArgsThaw
    {
    GUID     guidSnapshotSetId;
    } ArgsThaw;


typedef struct _ArgsAbort
    {
    GUID     guidSnapshotSetId;
    } ArgsAbort;


typedef union _ThreadArgs
    {
    ArgsIdentify		wtArgsIdentify;
    ArgsPrepareForSnapshot	wtArgsPrepareForSnapshot;
    ArgsFreeze			wtArgsFreeze;
    ArgsThaw			wtArgsThaw;
    ArgsAbort			wtArgsAbort;
    } ThreadArgs, *PThreadArgs;

class CVssWriterShim : public CVssWriter
    {
public:
 	CVssWriterShim ();
	CVssWriterShim (LPCWSTR       pwszWriterName,
			LPCWSTR       pwszWriterSpitDirectoryRoot,
			VSS_ID        idWriter,
			BOOL	      bBootableState,
			ULONG         ulWriterCount,
			PCShimWriter *prpCShimWriterArray);

	~CVssWriterShim ();

	HRESULT	RegisterWriterShim (VOID);
	HRESULT	UnRegisterWriterShim (VOID);

	HRESULT WorkerThreadStartup (void);
	HRESULT WorkerThreadRequestOperation (RequestOpCode eOperation,
					      PThreadArgs   pwtArgs);

	virtual bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	virtual bool STDMETHODCALLTYPE OnFreeze ();
	virtual bool STDMETHODCALLTYPE OnThaw ();
	virtual bool STDMETHODCALLTYPE OnAbort ();


private:
	static DWORD WINAPI RegisterWriterShimThreadFunc (void *pv);
	void	DoRegistration (void);


	static DWORD WINAPI WorkerThreadJacket (void *pvThisPtr);

	HRESULT WorkerThread (void);
	HRESULT WorkerThreadRequestProcessor (void);


	HRESULT	DeliverEventStartup  (void);
	HRESULT	DeliverEventShutdown (void);

	HRESULT	DeliverEventIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);

	HRESULT	DeliverEventPrepareForSnapshot (BOOL     bBootableStateBackup,
						GUID     guidSnapshotSetId,
						ULONG    ulVolumeCount,
						LPCWSTR *ppwszVolumeNamesArray,
                                                volatile bool *pbCancelAsync );

	HRESULT	DeliverEventFreeze (GUID guidSnapshotSetId, volatile bool *pbCancelAsync );	
	HRESULT	DeliverEventThaw   (GUID guidSnapshotSetId);
	HRESULT	DeliverEventAbort  (GUID guidSnapshotSetId);

	const LPCWSTR		 m_pwszWriterName;
	const VSS_ID		 m_idWriter;
	const BOOL		 m_bBootableState;
	const LPCWSTR		 m_pwszWriterSpitDirectoryRoot;
	const ULONG		 m_ulWriterCount;
	const PCShimWriter	*m_prpCShimWriterArray;


	HRESULT		m_hrInitialize;
	BOOL		m_bSubscribed;

	BOOL		m_bRegisteredInThisProcess;
	BOOL		m_bDirectStartupCalled;

	RequestOpCode	m_eRequestedOperation;
	HRESULT		m_hrStatusRequestedOperation;
	HANDLE		m_hEventOperationRequest;
	HANDLE		m_hEventOperationCompleted;

	HANDLE		m_hWorkerThread;
	HRESULT		m_hrWorkerThreadCompletionStatus;
	ThreadStatus	m_eThreadStatus;
	ThreadArgs	m_wtArgs;
	
	CBsCritSec	m_cCriticalSection;

};

typedef CVssWriterShim *PCVssWriterShim;


// VssApi shim exports
typedef HRESULT ( APIENTRY *PFunc_SimulateSnapshotFreezeInternal ) (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR  *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync
    );

typedef HRESULT ( APIENTRY *PFunc_SimulateSnapshotThawInternal ) (
    IN GUID guidSnapshotSetId
    );

HRESULT APIENTRY SimulateSnapshotFreezeInternal (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync
    );

HRESULT APIENTRY SimulateSnapshotThawInternal (
    IN GUID guidSnapshotSetId );

static HRESULT NormaliseVolumeArray (ULONG   ulVolumeCount,
				     LPWSTR pwszVolumeNameArray[],
				     PPWCHAR ppwszReturnedVolumeNameArray[]);

static VOID CleanupVolumeArray (PPWCHAR prpwszNormalisedVolumeNameArray[]);


static HRESULT InitialiseGlobalState ();
static HRESULT CleanupGlobalState (void);


static VOID    CleanupSecurityAttributes   (PSECURITY_ATTRIBUTES  psaSecurityAttributes);
static HRESULT ConstructSecurityAttributes (PSECURITY_ATTRIBUTES  psaSecurityAttributes,
					    SecurityAttributeType eSaType,
					    BOOL                  bIncludeBackupOperator);

static HRESULT CleanupTargetPath (LPCWSTR pwszTargetPath);
static HRESULT CreateTargetPath  (LPCWSTR pwszTargetPath);




static PCShimWriter g_rpShimWritersArrayBootableState[] = {
							   pShimWriterComPlusRegDb,	// The COM+ registration Db writer
							   pShimWriterRegistry};	// The Registry writer

static PCShimWriter g_rpShimWritersArrayServiceState[] = {
							  pShimWriterRSM,		// The Remote Storage Manager writer
							  pShimWriterCI,		// The Content Indexing writer
							  pShimWriterTLS,		// The TermServer Licencing service writer
							  pShimWriterConfigDir,		// The Configuration directory writer
							  pShimWriterEventLog};		// The Event Log writer

#define COUNT_SHIM_WRITERS_BOOTABLE_STATE	(SIZEOF_ARRAY (g_rpShimWritersArrayBootableState))
#define COUNT_SHIM_WRITERS_SERVICE_STATE	(SIZEOF_ARRAY (g_rpShimWritersArrayServiceState))


static PCVssWriterShim	g_pCVssWriterShimBootableState = NULL;
static PCVssWriterShim	g_pCVssWriterShimServiceState  = NULL;
static ULONG		g_ulThreadAttaches             = 0;
static ULONG		g_ulThreadDetaches             = 0;
static BOOL		g_bGlobalStateInitialised      = FALSE;
static CBsCritSec	g_cCritSec;
static HRESULT          g_hrSimulateFreezeStatus       = NOERROR;

static GUID		g_guidSnapshotInProgress       = GUID_NULL;

static IVssShim         *g_pIShim = NULL;  //  Used by the simulate functions.  Note it is NOT used in the
                                            //  simulateInternal functions.

/*
**++
**
**  Routine Description:
**
**	The DllMain entry point for this DLL.  Note that this must be called by the
**	CRT DLL Start function since the CRT must be initialized.
**
**
**  Arguments:
**	hInstance
**	dwReason
**	lpReserved
**
**
**  Return Value:
**
**	TRUE - Successful function execution
**	FALSE - Error when executing the function
**
**--
*/

BOOL APIENTRY DllMain (IN HINSTANCE hInstance,
		       IN DWORD     dwReason,
		       IN LPVOID    lpReserved)
    {
    BOOL bSuccessful = TRUE;

    UNREFERENCED_PARAMETER (hInstance);
    UNREFERENCED_PARAMETER (lpReserved);



    if (DLL_PROCESS_ATTACH == dwReason)
	{
	try
	    {
	    /*
	    **  Set the correct tracing context. This is an inproc DLL		
	    */
	    g_cDbgTrace.SetContextNum (VSS_CONTEXT_DELAYED_DLL);
	    }

	catch (...)
	    {
	    /*
	    ** Can't trace from here so just ASSERT() (checked builds only)
	    */
	    bSuccessful = FALSE;


	    BS_ASSERT (bSuccessful && "FAILED to initialise tracing sub-system");
	    }
	}


    if (bSuccessful)
	{
	try
	    {
	    switch (dwReason)
		{
		case DLL_PROCESS_ATTACH:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSS_SHIM,
				  (L"VssAPI: DllMain - DLL_PROCESS_ATTACH called, %s",
				   lpReserved ? L"Static load" : L"Dynamic load"));


		    /*
		    **  Don't need to know when threads start and stop - Wrong
		    **
		    ** DisableThreadLibraryCalls (hInstance);
		    */
		    _Module.Init (ObjectMap, hInstance);

		    break;
    		
	
		case DLL_PROCESS_DETACH:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSS_SHIM,
				  (L"VssAPI: DllMain - DLL_PROCESS_DETACH called %s",
				   lpReserved ? L"during process termination" : L"by FreeLibrary"));

			{
			CVssFunctionTracer ft (VSSDBG_SHIM, L"DllMain::ProcessDetach");

			try
			    {
			    CleanupGlobalState ();
			    } VSS_STANDARD_CATCH (ft);
			}

		    _Module.Term();

		    break;


		case DLL_THREAD_ATTACH:
		    g_ulThreadAttaches++;

		    if (0 == (g_ulThreadAttaches % 1000))
			{
			BsDebugTrace (0,
				      DEBUG_TRACE_VSS_SHIM,
				      (L"VssAPI: DllMain thread attaches = %u, detaches = %u, outstanding = %u",
				       g_ulThreadAttaches,
				       g_ulThreadDetaches,
				       g_ulThreadAttaches - g_ulThreadDetaches));
			}
		    break;


		case DLL_THREAD_DETACH:
		    g_ulThreadDetaches++;

		    if (0 == (g_ulThreadDetaches % 1000))
			{
			BsDebugTrace (0,
				      DEBUG_TRACE_VSS_SHIM,
				      (L"VssAPI: DllMain thread attaches = %u, detaches = %u, outstanding = %u",
				       g_ulThreadAttaches,
				       g_ulThreadDetaches,
				       g_ulThreadAttaches - g_ulThreadDetaches));
			}
		    break;


		default:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSS_SHIM,
				  (L"VssAPI: DllMain got unexpected reason code, lpReserved: %sNULL",
				   dwReason,
				   lpReserved ? L"non-" : L""));
		    break;
		}
	    }


	catch (...)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"VssAPI: DllMain - Error, unknown exception caught"));

	    bSuccessful = FALSE;
	    }
	}



    return (bSuccessful);
    } /* DllMain () */

/*
**++
**
**  Routine Description:
**
**	Converts the supplied array of volume names into something we
**	trust. Once the array is finished with a call must be made to
**	CleanupVolumeArray().
**
**
**  Arguments:
**
**	ulVolumeCount                Number of volumes in the supplied array
**	pwszVolumeNameArray          supplied array of volume names
**	ppwszReturnedVolumeNameArray returned array of volume names
**	
**
**  Return Value:
**
**	Any HRESULT from memory allocation, or volume name conversions.
**
**--
*/

static HRESULT NormaliseVolumeArray (ULONG   ulVolumeCount,
				     LPWSTR pwszVolumeNamesArray[],
				     PPWCHAR ppwszReturnedVolumeNamesArray[])
    {
    HRESULT	hrStatus                       = NOERROR;
    PPWCHAR	pwszNormalisedVolumeNamesArray = NULL;
    BOOL	bSucceeded;



    if ((0 < ulVolumeCount) && (NULL != pwszVolumeNamesArray))
	{
	pwszNormalisedVolumeNamesArray = (PPWCHAR) HeapAlloc (GetProcessHeap (),
							      HEAP_ZERO_MEMORY,
							      (ulVolumeCount * (MAX_VOLUMENAME_SIZE + sizeof (PWCHAR))));

	hrStatus = GET_STATUS_FROM_POINTER (pwszNormalisedVolumeNamesArray);


	for (ULONG ulIndex = 0; SUCCEEDED (hrStatus) && (ulIndex < ulVolumeCount); ulIndex++)
	    {
	    pwszNormalisedVolumeNamesArray [ulIndex] = (PWCHAR)((PBYTE)pwszNormalisedVolumeNamesArray
								+ (ulVolumeCount * sizeof (PWCHAR))
								+ (ulIndex * MAX_VOLUMENAME_SIZE));

	    bSucceeded = GetVolumeNameForVolumeMountPointW (pwszVolumeNamesArray [ulIndex],
							    pwszNormalisedVolumeNamesArray [ulIndex],
							    MAX_VOLUMENAME_SIZE);

            if ( !bSucceeded )
                {
                //
                //  See if this is one of the object not found errors.  Bug #223058.
                //
                DWORD dwErr = ::GetLastError();
                if ( dwErr == ERROR_FILE_NOT_FOUND || dwErr == ERROR_DEVICE_NOT_CONNECTED
                     || dwErr == ERROR_NOT_READY )
                    {
                    hrStatus = VSS_E_OBJECT_NOT_FOUND;
                    }
                else
                    {
                    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
                    }

	        LogFailure (NULL,
		    	    hrStatus,
			    hrStatus,
			    NULL,
			    L"GetVolumeNameForVolumeMountPointW",
			    L"NormaliseVolumeArray");
	        }
	    }
        }

    if (SUCCEEDED (hrStatus))
	{
	*ppwszReturnedVolumeNamesArray = pwszNormalisedVolumeNamesArray;
	}

    else
	{
	*ppwszReturnedVolumeNamesArray = NULL;

	if (NULL != pwszNormalisedVolumeNamesArray)
	    {
	    HeapFree (GetProcessHeap (), 0, pwszNormalisedVolumeNamesArray);
	    }
	}


    return (hrStatus);
    } /* NormaliseVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	Cleans up whatever was allocated by NormaliseVolumeArray.
**
**
**  Arguments:
**
**	prpwszNormalisedVolumeNameArray	array of volume names
**	
**
**  Return Value:
**
**	None
**
**--
*/

static VOID CleanupVolumeArray (PPWCHAR prpwszNormalisedVolumeNameArray[])
    {
    if (NULL != *prpwszNormalisedVolumeNameArray)
	{
	HeapFree (GetProcessHeap (), 0, *prpwszNormalisedVolumeNameArray);
	*prpwszNormalisedVolumeNameArray = NULL;
	}
    } /* CleanupVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to register the COM event
**	subscriptions for Snapshot event notifications and to prepare
**	the shim writers to be invoked either via the snapshot event
**	delivery mechanisim or via a call to the SimulateSnapshotXxxx()
**	routines.
**
**
**  Arguments:
**
**      ppFuncFreeze - Returns a pointer to the internal simulate freeze
**          function.
**      ppFuncThaw - Returns a pointer to the internal simulate thaw
**          function.
**
**	None
**
**  Return Value:
**
**	Any HRESULT from COM Event subscription functions or from the Snapshot writer
**	Init functions.
**
**--
*/
__declspec(dllexport) HRESULT APIENTRY RegisterSnapshotSubscriptions (
    OUT PFunc_SimulateSnapshotFreezeInternal *ppFuncFreeze,
    OUT PFunc_SimulateSnapshotThawInternal *ppFuncThaw
    )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::RegisterSnapshotSubscriptions");

    BOOL		bPrivilegesSufficient = FALSE;


    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as insuficient privileges to call shim");

	ft.ThrowIf ( ( ppFuncFreeze == NULL ) || ( ppFuncThaw == NULL ),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED internal function pointers are NULL");

        *ppFuncFreeze = NULL;
  	*ppFuncThaw = NULL;

	ft.hr = InitialiseGlobalState ();

        //
        //  Set up pointers to the internal snapshot freeze and thaw
        //
        *ppFuncFreeze = &SimulateSnapshotFreezeInternal;
  	*ppFuncThaw = &SimulateSnapshotThawInternal;
	}
    VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* RegisterSnapshotSubscriptions () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to unregister the COM event subscriptions
**	for Snapshot event notifications and to cleanup any outstanding shim writer state.
**
**  Arguments:
**
**	None
**
**  Return Value:
**
**	Any HRESULT from COM Event unregister subscription functions or from the Snapshot
**	writer Finished functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY UnregisterSnapshotSubscriptions (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VssAPI::UnregisterSnapshotSubscriptions");

    BOOL		bPrivilegesSufficient;


    try
	{
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as inssuficient privileges to call shim");


	CBsAutoLock cAutoLock (g_cCritSec);

	g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpWorkerThreadShutdown, NULL);
	g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpWorkerThreadShutdown, NULL);


	CleanupGlobalState ();
	} VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* UnregisterSnapshotSubscriptions () */

/*
**++
**
**  Routine Description:
**
**	Initializes the shim global state in preparation for
**	responding to either writer requests or calls to
**	SimulateSnapshotFreeze and SimulateSnapshotThaw.
**
**
**
**  Arguments:
**
**      NONE
**
**  Return Value:
**
**	Any HRESULT from COM Event register subscription functions, Snapshot
**	writer startup functions, thread, event or mutex creation.
**	
**
**--
*/

static HRESULT InitialiseGlobalState ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::InitialiseGlobalState");

    PCVssWriterShim	pCVssWriterShimBootableStateLocal = NULL;
    PCVssWriterShim	pCVssWriterShimServiceStateLocal  = NULL;

    try
	{
	if ((g_bGlobalStateInitialised)              ||
	    (NULL != g_pCVssWriterShimBootableState) ||
	    (NULL != g_pCVssWriterShimServiceState))
	    {
	    /*
	    ** The following condition should never occur on a user system
	    ** but may well be seen by application developers.
	    */
	    ft.LogError (VSS_ERROR_SHIM_ALREADY_INITIALISED,
			 VSSDBG_SHIM);

	    BS_ASSERT (FALSE && "Illegal second attempt to initialise global state");

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED as writer instances already exist");
	    }


	/*
	** Create the writer shim instances.
	*/
	pCVssWriterShimBootableStateLocal = new CVssWriterShim (SHIM_APPLICATION_NAME_BOOTABLE_STATE,
								ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR,
								idWriterBootableState,
								TRUE,
								COUNT_SHIM_WRITERS_BOOTABLE_STATE,
								g_rpShimWritersArrayBootableState);

	if (NULL == pCVssWriterShimBootableStateLocal)
	    {
	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_ALLOCATE_WRITER_INSTANCE,
			 VSSDBG_SHIM << SHIM_APPLICATION_NAME_BOOTABLE_STATE);

	    ft.Throw (VSSDBG_SHIM,
		      E_OUTOFMEMORY,
		      L"FAILED to allocate CvssWriterShim object for BootableState");
	    }



	pCVssWriterShimServiceStateLocal  = new CVssWriterShim (SHIM_APPLICATION_NAME_SERVICE_STATE,
								ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR,
								idWriterServiceState,
								FALSE,
								COUNT_SHIM_WRITERS_SERVICE_STATE,
								g_rpShimWritersArrayServiceState);

	if (NULL == pCVssWriterShimServiceStateLocal)
	    {
	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_ALLOCATE_WRITER_INSTANCE,
			 VSSDBG_SHIM << SHIM_APPLICATION_NAME_SERVICE_STATE);

	    ft.Throw (VSSDBG_SHIM,
		      E_OUTOFMEMORY,
		      L"FAILED to allocate CvssWriterShim object for ServiceState.");
	    }



	ft.hr = pCVssWriterShimBootableStateLocal->WorkerThreadStartup ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to start the BootableState shim writer worker thread");



	ft.hr = pCVssWriterShimServiceStateLocal->WorkerThreadStartup ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to start the ServiceState shim writer worker thread");


	/*
	** Do the startup work.
	*/
	ft.hr = pCVssWriterShimBootableStateLocal->RegisterWriterShim ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to register the BootableState shim writer class");



	ft.hr = pCVssWriterShimServiceStateLocal->RegisterWriterShim ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to register the ServiceState shim writer class");

	/*
	** Now that everything is ok, transfer ownership of the
	** instances of the shim writer class to the final locations
	*/
	g_pCVssWriterShimBootableState = pCVssWriterShimBootableStateLocal;
	g_pCVssWriterShimServiceState  = pCVssWriterShimServiceStateLocal;

	pCVssWriterShimBootableStateLocal = NULL;
	pCVssWriterShimServiceStateLocal  = NULL;

	g_bGlobalStateInitialised = TRUE;
	} VSS_STANDARD_CATCH (ft);



    delete pCVssWriterShimBootableStateLocal;
    delete pCVssWriterShimServiceStateLocal;

    return (ft.hr);
    } /* InitialiseGlobalState () */


/*
**++
**
**  Routine Description:
**
**	Cleans up the shim global state in preparation for a dll
**	unload/process shutdown.
**
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT thrown by CVssWriterShim object destruction.
**	
**
**--
*/

static HRESULT CleanupGlobalState (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VssAPI::CleanupGlobalState");

    PCVssWriterShim	pCVssWriterShimBootableStateLocal;
    PCVssWriterShim	pCVssWriterShimServiceStateLocal;


    try
	{
	if ( g_bGlobalStateInitialised )
	        {
        	g_bGlobalStateInitialised = FALSE;
        	
        	pCVssWriterShimBootableStateLocal = g_pCVssWriterShimBootableState;
        	pCVssWriterShimServiceStateLocal  = g_pCVssWriterShimServiceState;

        	g_pCVssWriterShimBootableState = NULL;
        	g_pCVssWriterShimServiceState  = NULL;


        	delete pCVssWriterShimBootableStateLocal;
        	delete pCVssWriterShimServiceStateLocal;
        	}
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* CleanupGlobalState () */

/*
**++
**
**  Routine Description:
**
**	Routines to construct and cleanup a security descriptor which
**	can be applied to limit access to an object to member of
**	either the Administrators or Backup Operators group.
**
**
**  Arguments:
**
**	psaSecurityAttributes	Pointer to a SecurityAttributes
**				structure which has already been
**				setup to point to a blank
**				security descriptor
**
**	eSaType			What we are building the SA for
**
**	bIncludeBackupOperator	Whether or not to include an ACE to
**				grant BackupOperator access
**
**
**  Return Value:
**
**	Any HRESULT from
**		InitializeSecurityDescriptor()
**		AllocateAndInitializeSid()
**		SetEntriesInAcl()
**		SetSecurityDescriptorDacl()
**
**--
*/

static HRESULT ConstructSecurityAttributes (PSECURITY_ATTRIBUTES  psaSecurityAttributes,
					    SecurityAttributeType eSaType,
					    BOOL                  bIncludeBackupOperator)
    {
    HRESULT			hrStatus             = NOERROR;
    DWORD			dwStatus;
    DWORD			dwAccessMask         = 0;
    BOOL			bSucceeded;
    PSID			psidBackupOperators  = NULL;
    PSID			psidAdministrators   = NULL;
    PACL			paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY	sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS		eaExplicitAccess [2];



    switch (eSaType)
	{
	case esatMutex: dwAccessMask = MUTEX_ALL_ACCESS; break;
	case esatFile:  dwAccessMask = FILE_ALL_ACCESS;  break;

	default:
	    BS_ASSERT (FALSE && "Improper access mask requested");

	    hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
	    break;
	}



    /*
    ** Initialise the security descriptor.
    */
    if (SUCCEEDED (hrStatus))
	{
	bSucceeded = InitializeSecurityDescriptor (psaSecurityAttributes->lpSecurityDescriptor,
						   SECURITY_DESCRIPTOR_REVISION);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"GetVolumeNameForVolumeMountPointW", L"NormaliseVolumeArray");
	}



    if (SUCCEEDED (hrStatus) && bIncludeBackupOperator)
	{
	/*
	** Create a SID for the Backup Operators group.
	*/
        bSucceeded = AllocateAndInitializeSid (&sidNtAuthority,
					       2,
					       SECURITY_BUILTIN_DOMAIN_RID,
					       DOMAIN_ALIAS_RID_BACKUP_OPS,
					       0, 0, 0, 0, 0, 0,
					       &psidBackupOperators);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"AllocateAndInitializeSid", L"NormaliseVolumeArray");
	}



    if (SUCCEEDED (hrStatus))
	{
        /*
	** Create a SID for the Administrators group.
	*/
	bSucceeded = AllocateAndInitializeSid (&sidNtAuthority,
					       2,
					       SECURITY_BUILTIN_DOMAIN_RID,
					       DOMAIN_ALIAS_RID_ADMINS,
					       0, 0, 0, 0, 0, 0,
					       &psidAdministrators);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"AllocateAndInitializeSid", L"NormaliseVolumeArray");
	}



    if (SUCCEEDED (hrStatus))
	{
        /*
	** Initialize the array of EXPLICIT_ACCESS structures for an
	** ACEs we are setting.
	**
        ** The first ACE allows the Backup Operators group full access
        ** and the second, allowa the Administrators group full
        ** access.
	*/
        eaExplicitAccess[0].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[0].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[0].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	eaExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
	eaExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
        eaExplicitAccess[0].Trustee.ptstrName                = (LPTSTR) psidAdministrators;


	if (bIncludeBackupOperator)
	    {
	    eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
	    eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
	    eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	    eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
	    eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
	    eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
	    eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
	    eaExplicitAccess[1].Trustee.ptstrName                = (LPTSTR) psidBackupOperators;
	    }


        /*
	** Create a new ACL that contains the new ACEs.
	*/
        dwStatus = SetEntriesInAcl (bIncludeBackupOperator ? 2 : 1,
				    eaExplicitAccess,
				    NULL,
				    &paclDiscretionaryAcl);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"SetEntriesInAcl", L"NormaliseVolumeArray");
	}


    if (SUCCEEDED (hrStatus))
	{
        /*
	** Add the ACL to the security descriptor.
	*/
        bSucceeded = SetSecurityDescriptorDacl (psaSecurityAttributes->lpSecurityDescriptor,
						TRUE,
						paclDiscretionaryAcl,
						FALSE);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"SetSecurityDescriptorDacl", L"NormaliseVolumeArray");
	}


    if (SUCCEEDED (hrStatus))
	{
	paclDiscretionaryAcl = NULL;
	}



    /*
    ** Clean up any left over junk.
    */
    if (NULL != psidAdministrators)    FreeSid (psidAdministrators);
    if (NULL != psidBackupOperators)   FreeSid (psidBackupOperators);
    if (NULL != paclDiscretionaryAcl)  LocalFree (paclDiscretionaryAcl);


    return (hrStatus);
    } /* ConstructSecurityAttributes () */


static VOID CleanupSecurityAttributes (PSECURITY_ATTRIBUTES psaSecurityAttributes)
    {
    BOOL	bSucceeded;
    BOOL	bDaclPresent         = FALSE;
    BOOL	bDaclDefaulted       = TRUE;
    PACL	paclDiscretionaryAcl = NULL;


    bSucceeded = GetSecurityDescriptorDacl (psaSecurityAttributes->lpSecurityDescriptor,
					    &bDaclPresent,
					    &paclDiscretionaryAcl,
					    &bDaclDefaulted);


    if (bSucceeded && bDaclPresent && !bDaclDefaulted && (NULL != paclDiscretionaryAcl))
	{
	LocalFree (paclDiscretionaryAcl);
	}

    } /* CleanupSecurityAttributes () */

/*
**++
**
**  Routine Description:
**
**	Creates a new target directory specified by the target path
**	member variable if not NULL. It will create any necessary
**	parent directories too.
**
**	NOTE: already exists type errors are ignored.
**
**
**  Arguments:
**
**	pwszTargetPath	directory to create and apply security attributes
**
**
**  Return Value:
**
**	Any HRESULT resulting from memory allocation or directory creation attempts.
**--
*/

HRESULT CreateTargetPath (LPCWSTR pwszTargetPath)
    {
    HRESULT		hrStatus = NOERROR;
    UNICODE_STRING	ucsTargetPath;
    ACL			DiscretionaryAcl;
    SECURITY_ATTRIBUTES	saSecurityAttributes;
    SECURITY_DESCRIPTOR	sdSecurityDescriptor;
    BOOL		bSucceeded;
    BOOL		bSecurityAttributesConstructed = FALSE;
    DWORD		dwFileAttributes               = 0;
    const DWORD		dwExtraAttributes              = FILE_ATTRIBUTE_ARCHIVE |
							 FILE_ATTRIBUTE_HIDDEN  |
							 FILE_ATTRIBUTE_SYSTEM  |
							 FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;


    if (NULL != pwszTargetPath)
	{
	StringInitialise (&ucsTargetPath);

	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   pwszTargetPath,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    ** We really want a no access acl on this directory but
	    ** because of various problems with the EventLog and
	    ** ConfigDir writers we will settle for admin or backup
	    ** operator access only. The only possible accessor is
	    ** Backup which is supposed to have the SE_BACKUP_NAME
	    ** priv which will effectively bypass the ACL. No one else
	    ** needs to see this stuff.
	    */
	    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
	    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
	    saSecurityAttributes.bInheritHandle       = FALSE;

	    hrStatus = ConstructSecurityAttributes (&saSecurityAttributes, esatFile, FALSE);

	    bSecurityAttributesConstructed = SUCCEEDED (hrStatus);
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    bSucceeded = VsCreateDirectories (ucsTargetPath.Buffer,
					      &saSecurityAttributes,
					      dwExtraAttributes);


	    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) == hrStatus))
		{
		hrStatus = NOERROR;
		}


	    CleanupSecurityAttributes (&saSecurityAttributes);
	    }


	StringFree (&ucsTargetPath);
	}

    return (hrStatus);
    } /* CreateTargetPath () */

/*
**++
**
**  Routine Description:
**
**	Deletes all the files present in the directory pointed at by the target
**	path member variable if not NULL. It will also remove the target directory
**	itself, eg for a target path of c:\dir1\dir2 all files under dir2 will be
**	removed and then dir2 itself will be deleted.
**
**
**  Arguments:
**
**	pwszTargetPath
**
**
**  Return Value:
**
**	Any HRESULT resulting from memory allocation or file and
**	directory deletion attempts.
**--
*/

HRESULT CleanupTargetPath (LPCWSTR pwszTargetPath)
    {
    HRESULT		hrStatus         = NOERROR;
    DWORD		dwFileAttributes = 0;
    BOOL		bSucceeded;
    WCHAR		wszTempBuffer [50];
    UNICODE_STRING	ucsTargetPath;
    UNICODE_STRING	ucsTargetPathAlternateName;



    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsTargetPathAlternateName);


    if (NULL != pwszTargetPath)
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   pwszTargetPath,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    hrStatus = StringCreateFromString (&ucsTargetPathAlternateName,
					       &ucsTargetPath,
					       MAX_PATH);
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    dwFileAttributes = GetFileAttributesW (ucsTargetPath.Buffer);


	    hrStatus = GET_STATUS_FROM_BOOL ( -1 != dwFileAttributes);


	    if ((HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus) ||
		(HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND) == hrStatus))
		{
		hrStatus         = NOERROR;
		dwFileAttributes = 0;
		}

	    else if (SUCCEEDED (hrStatus))
		{
		/*
		** If there is a file there then blow it away, or if it's
		** a directory, blow it and all it's contents away. This
		** is our directory and no one but us gets to play there.
		*/
		hrStatus = RemoveDirectoryTree (&ucsTargetPath);

		if (FAILED (hrStatus))
		    {
		    srand ((unsigned) time (NULL));

		    _itow (rand (), wszTempBuffer, 16);

		    StringAppendString (&ucsTargetPathAlternateName, wszTempBuffer);

		    bSucceeded = MoveFileW (ucsTargetPath.Buffer,
					    ucsTargetPathAlternateName.Buffer);

		    if (bSucceeded)
			{
			BsDebugTraceAlways (0,
					    DEBUG_TRACE_VSS_SHIM,
					    (L"VSSAPI::CleanupTargetPath: "
					     L"FAILED to delete %s with status 0x%08X so renamed to %s",
					     ucsTargetPath.Buffer,
					     hrStatus,
					     ucsTargetPathAlternateName.Buffer));
			}
		    else
			{
			BsDebugTraceAlways (0,
					    DEBUG_TRACE_VSS_SHIM,
					    (L"VSSAPI::CleanupTargetPath: "
					     L"FAILED to delete %s with status 0x%08X and "
					     L"FAILED to rename to %s with status 0x%08X",
					     ucsTargetPath.Buffer,
					     hrStatus,
					     ucsTargetPathAlternateName.Buffer,
					     GET_STATUS_FROM_BOOL (bSucceeded)));
			}
		    }
		}
	    }
	}


    StringFree (&ucsTargetPathAlternateName);
    StringFree (&ucsTargetPath);

    return (hrStatus);
    } /* CleanupTargetPath () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to simulate a snapshot creation to allow
**	backup to drive the shim writers rather than having the snapshot co-ordinator
**	do so.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**	hCompletionEvent	Handle to an event which will be set when the asynchronous freeze completes
**	phrCompletionStatus	Pointer to an HRESULT which will receive the completion status when the
**				asynchronous freeze completes
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer PrepareForFreeze or Freeze functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY SimulateSnapshotFreeze (
    IN GUID         guidSnapshotSetId,
    IN ULONG        ulOptionFlags,	
    IN ULONG        ulVolumeCount,	
    IN LPWSTR     *ppwszVolumeNamesArray,
    OUT IVssAsync **ppAsync )							
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotFreeze");
    BOOL		bSucceeded;

    try
	{
	/*
	** WARNING: If SimulateSnapshotFreeze can ever be called from inside the VsSvc process,
	** the following critical section entry can cause a deadlock.  The assumption is that
	** g_cCritSec is different from the one acquired in SimulateSnapshotFreezeInternal().
	*/
	CBsAutoLock cAutoLock (g_cCritSec);
	
        BOOL  bPrivilegesSufficient = FALSE;
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as insufficient privileges to call shim");

        //
        //  Most parameter checks should be done here in the VssApi DLL and not in the
        //  IVssCoordinator::SimulateSnapshotFreeze method since the shim DLL can be
        //  changed independently from the service.  The service is just a forwarding
        //  agent to get SimulateSnapshotFreezeInternal called within one of the
        //  service's threads.
        //

	ft.ThrowIf ((ulOptionFlags & ~VSS_SW_BOOTABLE_STATE) != 0,
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as illegal option flags set");


	ft.ThrowIf (!((ulOptionFlags & VSS_SW_BOOTABLE_STATE) || (ulVolumeCount > 0)),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as need either BootableState or a volume list");


	ft.ThrowIf ((ulVolumeCount > 0) && (NULL == ppwszVolumeNamesArray),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as need at least a one volume in the list if not bootable state");


	ft.ThrowIf ((GUID_NULL == guidSnapshotSetId),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as supplied SnapshotSetId should not be GUID_NULL");

	ft.ThrowIf ((NULL == ppAsync),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as supplied ppAsync parameter is NULL");

        *ppAsync = NULL;

	/*
	** Try to scan all the volume names in an attempt to trigger
	** an access violation to catch it here rather than in an
	** unfortunate spot later on. It also gives us the
	** opportinutiy to do some very basic validity checks.
	*/
	for (ULONG ulIndex = 0; ulIndex < ulVolumeCount; ulIndex++)
	    {
	    ft.ThrowIf (NULL == ppwszVolumeNamesArray [ulIndex],
			VSSDBG_SHIM,
			E_INVALIDARG,
			L"FAILED as NULL value in volume array");

	    ft.ThrowIf (wcslen (L"C:") > wcslen (ppwszVolumeNamesArray [ulIndex]),
			VSSDBG_SHIM,
			E_INVALIDARG,
			L"FAILED as volume name too short");
	    }

	/*
	** Now we need to connect to the VssSvc service's IVssCoordinator object
	** and make the simulate freeze happen.
	*/
	ft.ThrowIf ( g_pIShim != NULL,
	             VSSDBG_SHIM,
	             VSS_E_SNAPSHOT_SET_IN_PROGRESS,
                     L"SimulateSnapshotThaw() must first be called by this process before calling SimulateSnapshotFreeze() again." );

    ft.LogVssStartupAttempt();
	ft.hr = CoCreateInstance(
	                        CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssShim,
				(void **) &g_pIShim
				);
    LogAndThrowOnFailure (ft, NULL, L"CoCreateInstance( CLSID_VSSCoordinator, IID_IVssShim)");

	BS_ASSERT( g_pIShim != NULL );
	
    g_guidSnapshotInProgress = guidSnapshotSetId;

    /*
    ** Now call the simulate freeze method in the coordinator
    */
    ft.hr = g_pIShim->SimulateSnapshotFreeze(
            guidSnapshotSetId,
            ulOptionFlags,	
            ulVolumeCount,	
            ppwszVolumeNamesArray,
            ppAsync );
    LogAndThrowOnFailure (ft, NULL, L"IVssShim::SimulateSnapshotFreeze()");

	/*
	** The simulate freeze operation is now running in a thread in VssSvc.
	*/
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotFreeze () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to simulate a snapshot thaw to allow
**	backup to drive the shim writers rather than having the snapshot co-ordinator
**	do so.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer Thaw functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY SimulateSnapshotThaw (
    IN GUID guidSnapshotSetId )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotThaw");
    BOOL        bPrivilegesSufficient = FALSE;
    HRESULT	hrBootableState       = NOERROR;
    HRESULT	hrServiceState        = NOERROR;
    ThreadArgs  wtArgs;

    try
	{
	/*
	** WARNING: If SimulateSnapshotThaw can ever be called from inside the VsSvc process,
	** the following critical section entry can cause a deadlock.  The assumption is that
	** g_cCritSec is different from the one acquired in SimulateSnapshotThawInternal().
	*/
	CBsAutoLock cAutoLock (g_cCritSec);
	
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as inssuficient privileges to call shim");

	/*
	** We need to make sure a prior SimulateSnapshotFreeze happened.
	*/
	ft.ThrowIf ( g_pIShim == NULL,
	             VSSDBG_SHIM,
	             VSS_E_BAD_STATE,
                     L"Called SimulateSnapshotThaw() without first calling SimulateSnapshotFreeze()" );

	ft.ThrowIf ( g_guidSnapshotInProgress != guidSnapshotSetId,
	             VSSDBG_SHIM,
	             VSS_E_BAD_STATE,
                     L"Mismatch between guidSnapshotSetId and the one passed into SimulateSnapshotFreeze()" );
	
        /*
        ** Now call the simulate thaw method in the coordinator
        */
        ft.hr = g_pIShim->SimulateSnapshotThaw( guidSnapshotSetId );

        /*
        ** Regardless of the outcome of the SimulateSnapshotThaw, get rid of the shim interface.
        */
        g_pIShim->Release();
        g_pIShim = NULL;
        g_guidSnapshotInProgress = GUID_NULL;

        LogAndThrowOnFailure (ft, NULL, L"IVssShim::SimulateSnapshotThaw()");
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotThaw () */

/*
**++
**
**  Routine Description:
**
**	Internal routine to package up the calls to deliver the
**	PrepareForSnapshot and Freeze events.
**
**  NOTE: This function is called outside the DLL by a thread in the VsSvc process.  Its
**  entry point is returned from RegisterSnapshotSubscriptions and is NOT exported by
**  the DLL.
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**      pbCancelAsync           Pointer to a bool that may become set to true while the freeze
**                              operation is underway.  When it becomes true, the freeze operation
**                              should stop.
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer PrepareForFreeze or Freeze functions.
**
**--
*/

HRESULT APIENTRY SimulateSnapshotFreezeInternal (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR  *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotFreezeInternal");

    HRESULT		hrBootableState = NOERROR;
    HRESULT		hrServiceState  = NOERROR;
    ThreadArgs		wtArgs;
    PPWCHAR		rpwszNormalisedVolumeNameArray = NULL;

    g_hrSimulateFreezeStatus = NOERROR;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

        ft.ThrowIf ( pbCancelAsync == NULL,
                     VSSDBG_SHIM,
                     E_INVALIDARG,
                     L"pbCancelAsync is NULL" );

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 1" );

	if (!g_bGlobalStateInitialised)
	    {
	    // This should be impossible since the only way an external caller of this
	    // DLL can call this function is by getting the address of this function
	    // by calling RegisterSnapshotSubscriptions first.
	    ft.Throw ( VSSDBG_SHIM,
		       VSS_E_BAD_STATE,
			L"SimulateSnapshotFreezeInternal called before RegisterSnapshotSubscriptions was called or after UnregisterSnapshotSubscriptions was called");
	    }
	
	BS_ASSERT ((g_bGlobalStateInitialised)              &&
		   (NULL != g_pCVssWriterShimBootableState) &&
		   (NULL != g_pCVssWriterShimServiceState));

	ft.hr = NormaliseVolumeArray (ulVolumeCount,
				      ppwszVolumeNamesArray,
				      &rpwszNormalisedVolumeNameArray);

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED as unable to normalise volume array");

	ft.ThrowIf (g_guidSnapshotInProgress != GUID_NULL,
		    VSSDBG_SHIM,
		    VSS_E_SNAPSHOT_SET_IN_PROGRESS,
		    L"FAILED due to unmatched SimulateSnapshotFreeze()");

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 2" );

	g_guidSnapshotInProgress = guidSnapshotSetId;

	wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup  = ((ulOptionFlags & VSS_SW_BOOTABLE_STATE) != 0);
	wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId     = guidSnapshotSetId;
	wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount         = ulVolumeCount;
	wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray = (LPCWSTR *)rpwszNormalisedVolumeNameArray;
	wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync         = pbCancelAsync;

	hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventPrepareForSnapshot,
											&wtArgs);

	hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventPrepareForSnapshot,
											&wtArgs);

	ft.ThrowIf (FAILED (hrServiceState),
		    VSSDBG_SHIM,
		    hrServiceState,
		    L"FAILED sending PrepareForSnapshot events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending PrepareForSnapshot events to Bootable state writers");

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 3" );
	
	wtArgs.wtArgsFreeze.guidSnapshotSetId = guidSnapshotSetId;
	wtArgs.wtArgsFreeze.pbCancelAsync     = pbCancelAsync;

	hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventFreeze, &wtArgs);
	hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventFreeze, &wtArgs);

	ft.ThrowIf (FAILED (hrServiceState),
		    VSSDBG_SHIM,
		    hrServiceState,
		    L"FAILED sending Freeze events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending Freeze events to Bootable state writers");

	}
    VSS_STANDARD_CATCH (ft);

    CleanupVolumeArray (&rpwszNormalisedVolumeNameArray);

    // Store away the freeze status
    g_hrSimulateFreezeStatus = ft.hr;

    return (ft.hr);
    } /* SimulateSnapshotFreezeInternal () */

/*
**++
**
**  Routine Description:
**
**  NOTE: This function is called outside the DLL by a thread in the VsSvc process.  Its
**  entry point is returned from RegisterSnapshotSubscriptions and is NOT exported by
**  the DLL.
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer Thaw functions.
**
**--
*/

HRESULT APIENTRY SimulateSnapshotThawInternal (
    IN GUID guidSnapshotSetId )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotThawInternal");
    HRESULT		hrBootableState       = NOERROR;
    HRESULT		hrServiceState        = NOERROR;
    ThreadArgs		wtArgs;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	if (!g_bGlobalStateInitialised)
	    {
	    // This should be impossible since the only way an external caller of this
	    // DLL can call this function is by getting the address of this function
	    // by calling RegisterSnapshotSubscriptions first.
	    ft.Throw ( VSSDBG_SHIM,
		       VSS_E_BAD_STATE,
			L"SimulateSnapshotThawInternal called before RegisterSnapshotSubscriptions was called or after UnregisterSnapshotSubscriptions was called");
	    }
	
	ft.ThrowIf (g_guidSnapshotInProgress == GUID_NULL && SUCCEEDED( g_hrSimulateFreezeStatus ),
		    VSSDBG_SHIM,
		    VSS_E_BAD_STATE,
		    L"FAILED as SimulateSnapshotFreezeInternal() has not been called");

	ft.ThrowIf (g_guidSnapshotInProgress != guidSnapshotSetId,
		    VSSDBG_SHIM,
		    VSS_E_BAD_STATE,
		    L"FAILED due to incorrect SnapshotSetId");

	BS_ASSERT ((g_bGlobalStateInitialised)              &&
		   (NULL != g_pCVssWriterShimBootableState) &&
		   (NULL != g_pCVssWriterShimServiceState));

        // If the simulate snapshot freeze was successful, send thaw events to the mini-writers otherwise send
        // abort events.  Bug # 286927.
        if ( SUCCEEDED( g_hrSimulateFreezeStatus ) )
            {
            wtArgs.wtArgsThaw.guidSnapshotSetId = guidSnapshotSetId;
	    hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventThaw, &wtArgs);
	    hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventThaw, &wtArgs);
            }
        else
            {
            wtArgs.wtArgsAbort.guidSnapshotSetId = guidSnapshotSetId;
	    hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventAbort, &wtArgs);
	    hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventAbort, &wtArgs);
            }

	ft.ThrowIf (FAILED (hrServiceState),
		    VSSDBG_SHIM,
		    hrServiceState,
		    L"FAILED sending Thaw events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending Thaw events to Bootable state writers");

	g_guidSnapshotInProgress = GUID_NULL;
	g_hrSimulateFreezeStatus = NOERROR;
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotThawInternal () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to check if a volume is snapshotted
**
**
**  Arguments:
**
**      IN VSS_PWSZ pwszVolumeName      - The volume to be checked.
**      OUT BOOL * pbSnapshotsPresent   - Returns TRUE if the volume is snapshotted.
**
**
**  Return Value:
**
**	Any HRESULT from the IVssCoordinator::IsVolumeSnapshotted.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY IsVolumeSnapshotted (
        IN VSS_PWSZ pwszVolumeName,
        OUT BOOL *  pbSnapshotsPresent,
    	OUT LONG *  plSnapshotCompatibility
        )
{
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::IsVolumeSnapshotted");
    BOOL		bPrivilegesSufficient = FALSE;
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;
    DWORD		dwOldState  = 0;

    try
	{
	    // Zero out the out parameter
	    ::VssZeroOut(pbSnapshotsPresent);
	    ::VssZeroOut(plSnapshotCompatibility);
	
    	bPrivilegesSufficient = IsProcessAdministrator ();
    	ft.ThrowIf (!bPrivilegesSufficient,
    		    VSSDBG_SHIM,
    		    E_ACCESSDENIED,
    		    L"FAILED as insufficient privileges to call shim");

    	ft.ThrowIf ( (pwszVolumeName == NULL) || (pbSnapshotsPresent == NULL),
    		    VSSDBG_SHIM,
    		    E_INVALIDARG,
    		    L"FAILED as invalid parameters");

    	CBsAutoLock cAutoLock (g_cCritSec);

        //
        //  Check to see if VSSVC is running. If not ,we are supposing that no snapshots are present on the system.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager)
            ft.TranslateGenericError(VSSDBG_SHIM, HRESULT_FROM_WIN32(GetLastError()),
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService)
            ft.TranslateGenericError(VSSDBG_SHIM, HRESULT_FROM_WIN32(GetLastError()),
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            ft.TranslateGenericError(VSSDBG_SHIM, HRESULT_FROM_WIN32(GetLastError()),
                L"QueryServiceStatus (shSCService, &sSStat)");

        // BUG 250943: Only if the service is running then check to see if there are any snapsnots
        if (sSStat.dwCurrentState == SERVICE_RUNNING) {

            // Create the coordinator interface
        	CComPtr<IVssCoordinator> pCoord;

            // The service is already started, but...
            // We still log here in order to make our code more robust.
            ft.LogVssStartupAttempt();

            // Create the instance.
        	ft.hr = pCoord.CoCreateInstance(CLSID_VSSCoordinator);
        	if (ft.HrFailed())
                ft.TranslateGenericError(VSSDBG_SHIM, ft.hr, L"CoCreateInstance(CLSID_VSSCoordinator)");
            BS_ASSERT(pCoord);

            // Call IsVolumeSnapshotted on the coordinator
            ft.hr = pCoord->IsVolumeSnapshotted(
                        GUID_NULL,
                        pwszVolumeName,
                        pbSnapshotsPresent,
                        plSnapshotCompatibility);
        }
	} VSS_STANDARD_CATCH (ft);

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);

    return (ft.hr);
} /* IsVolumeSnapshotted () */


/*
**++
**
**  Routine Description:
**
**	This routine is used to free the contents of hte VSS_SNASPHOT_PROP structure
**
**
**  Arguments:
**
**      IN VSS_SNAPSHOT_PROP*  pProp
**
**--
*/

__declspec(dllexport) void APIENTRY VssFreeSnapshotProperties (
        IN VSS_SNAPSHOT_PROP*  pProp
        )
{
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::VssFreeSnapshotProperties");

    if (pProp) {
        ::CoTaskMemFree(pProp->m_pwszSnapshotDeviceObject);
        ::CoTaskMemFree(pProp->m_pwszOriginalVolumeName);
        ::CoTaskMemFree(pProp->m_pwszOriginatingMachine);
        ::CoTaskMemFree(pProp->m_pwszServiceMachine);
        ::CoTaskMemFree(pProp->m_pwszExposedName);
        ::CoTaskMemFree(pProp->m_pwszExposedPath);
    }
} /* VssFreeSnapshotProperties () */


/*
**************************************************************
**************************************************************
**
** CShimWriter implementation
**
**
**************************************************************
**************************************************************
*/

/*
**++
**
**  Routine Description:
**
**	Set of constructors for the CShimWriter class which
**	iniatialise all of the data member of the class, either to
**	default values or to some supplied parameters.
**
**	This class is used to manage instance of a single sub or
**	mini-writer which does basic backup of a single service or
**	entity.
**
**	A collection of these mini-writers is managed by the
**	CVssWriterShim class which connects this group of mini-writers
**	to the main snapshot coordination engine.
**
**	Effectively the CShimWriter class looks down to the
**	mini-writer and the CVssWriterShim class looks up up to the
**	coordinator.
**
**
**  Arguments:
**
**	swtWriterType                             Does this writer need to be invoked
**						  for bootable (aka System) state backups
**	pwszWriterName	                          Name of the shim writer
**	pwszTargetPath	(optional, default NULL)  Path used to save any 'spit' files
**
**
**  Return Value:
**
**	None
**--
*/

CShimWriter::CShimWriter(LPCWSTR pwszWriterName) :
	m_bBootableStateWriter(FALSE),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(NULL),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) :
	m_bBootableStateWriter(FALSE),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(pwszTargetPath),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, BOOL bBootableStateWriter) :
	m_bBootableStateWriter(bBootableStateWriter),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(NULL),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bBootableStateWriter) :
	m_bBootableStateWriter(bBootableStateWriter),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(pwszTargetPath),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }



/*
**++
**
**  Routine Description:
**
**	Destructor for the CShimWriter class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	None
**--
*/

CShimWriter::~CShimWriter()
    {
    }

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoStartup() method and to set the writer state
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoStartup() method.
**--
*/

HRESULT CShimWriter::Startup ()
    {
    HRESULT hrStatus = SetState (stateStarting, NOERROR);

    if (SUCCEEDED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Startup: Sending Startup to %s", m_pwszWriterName));

	hrStatus = SetState (stateStarted, DoStartup ());

	LogFailure (NULL, hrStatus, hrStatus, m_pwszWriterName, L"CShimWriter::DoStartup", L"CShimWriter::Startup");
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Startup: FAILURE (0x%08X) in state %s sending Startup to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Startup () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoIdentify() method and to update the writer metadata
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Identify (IN IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    HRESULT	hrStatus = NOERROR;

    BsDebugTraceAlways (0,
			DEBUG_TRACE_VSS_SHIM,
			(L"CShimWriter::Identify: Sending Identify to %s", m_pwszWriterName));

    m_pIVssCreateWriterMetadata = pIVssCreateWriterMetadata;


    hrStatus = DoIdentify ();

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Identify: FAILURE (0x%08X) in state %s sending Identify to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    m_pIVssCreateWriterMetadata = NULL;

    return (hrStatus);
    } /* CShimWriter::Identify () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoPrepareForSnapshot() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoPrepareForSnapshot() method.
**--
*/

HRESULT CShimWriter::PrepareForSnapshot (
					 IN BOOL     bBootableStateBackup,
					 IN ULONG    ulVolumeCount,
					 IN LPCWSTR *ppwszVolumeNamesArray)
    {
    HRESULT	hrStatus = SetState (statePreparingForSnapshot, NOERROR);


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Ensure no garbage left over from a previous run
	*/
	hrStatus = CleanupTargetPath (m_pwszTargetPath);

        if ( FAILED( hrStatus ) )
            {
            LogFailure (NULL, hrStatus, hrStatus, m_pwszWriterName, L"CleanupTargetPath", L"CShimWriter::PrepareForSnapshot");
            }
        }

    if (SUCCEEDED( hrStatus ) )
        {
	m_ulVolumeCount         = ulVolumeCount;
	m_ppwszVolumeNamesArray = ppwszVolumeNamesArray;
	m_bParticipateInBackup  = TRUE;


	if (( m_bBootableStateWriter && bBootableStateBackup) ||
	    (!m_bBootableStateWriter && (ulVolumeCount > 0)))
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::PrepareForSnapshot: Sending PrepareForSnapshot to %s",
				 m_pwszWriterName));


	    hrStatus = CreateTargetPath (m_pwszTargetPath);

	    if (SUCCEEDED (hrStatus))
		{
		hrStatus = DoPrepareForSnapshot ();
		}

	    if (!m_bParticipateInBackup)
		{
		/*
		** The writer has chosen to exclude itself so we should
		** clean up the target path to prevent confusing the
		** backup app.
		*/
		BsDebugTraceAlways (0,
				    DEBUG_TRACE_VSS_SHIM,
				    (L"CShimWriter::PrepareForSnapshot: Self-exclusion from further participation by %s",
				     m_pwszWriterName));

		CleanupTargetPath (m_pwszTargetPath);
		}
	    }

	else
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::PrepareForSnapshot: Wrong WriterType/BackupType/VolumeCount combination - "
				 L"no further participation from %s",
				 m_pwszWriterName));

	    m_bParticipateInBackup = FALSE;
	    }


	hrStatus = SetState (statePreparedForSnapshot, hrStatus);
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::PrepareForSnapshot: FAILURE (0x%08X) in state %s sending PrepareForSnapshot to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::PrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoFreeze() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoFreeze() method.
**--
*/

HRESULT CShimWriter::Freeze ()
    {
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateFreezing, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Freeze: Sending Freeze to %s", m_pwszWriterName));

	    hrStatus = DoFreeze ();
	    }

	hrStatus = SetState (stateFrozen, hrStatus);
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Freeze: FAILURE (0x%08X) in state %s sending Freeze to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Freeze () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoThaw() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Thaw ()
    {
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateThawing, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Thaw: Sending Thaw to %s", m_pwszWriterName));

	    hrStatus = DoThaw ();
	    }

	hrStatus = SetState (stateThawed, hrStatus);
	}

    //  Clean up
    CleanupTargetPath (m_pwszTargetPath);

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Thaw: FAILURE (0x%08X) in state %s sending Thaw to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Thaw () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoAbort() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Abort ()
    {
    //  The global snapshot set id may be NULL in certain cases.  Bug #289822.
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateAborting, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Abort: Sending Abort to %s", m_pwszWriterName));

	    hrStatus = DoAbort ();
	    }

	hrStatus = SetState (stateThawed, hrStatus);
	}

    //  Clean up
    CleanupTargetPath (m_pwszTargetPath);

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Abort: FAILURE (0x%08X) in state %s sending Abort to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Abort () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoShutdown() method and to set the writer state
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoShutdown() method.
**--
*/

HRESULT CShimWriter::Shutdown ()
    {
    HRESULT hrStatus = SetState (stateFinishing, NOERROR);

    if (SUCCEEDED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Shutdown: Sending Shutdown to %s", m_pwszWriterName));

	hrStatus = SetState (stateFinished, DoShutdown ());
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Shutdown: FAILURE (0x%08X) in state %s sending Shutdown to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Shutdown () */

/*
**++
**
**  Routine Description:
**
**	Routine (and associated table) describing the states the shim
**	writers can get in to. Shim writer always follow this table and
**	if they fail, can deposit the failure code in the status member
**	variable under the control of this routine.
**
**	Note that entering the Thawing or Finishing states are kind of
**	like a reset on the status as one of the requirements on the
**	shim is that a Thaw event or unload need to make sure that the
**	writers have cleaned up.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Success
**	HRESULT for ERROR_INVALID_STATE for an illegal transition attempt
**	failure code from a previous (failed) operation
**--
*/


/*
** This table describes the set of legal state transitions that a shim
** writer should follow. That is, for a given current state
** ('CurState'), which new states ('NewState') are legal. For example,
** going from 'Started' to 'Preparing' is leagal but from Started' to
** 'Freezing' is no.
**
** Each externally visible state is actually a combination of an
** 'step-in-progress' state and a 'step-completed state eg 'starting'
** and 'started'.
**
** The normal sequence of states for a writer is expected to be :-
**
**	   Unknown
**	to Started
**	to Prepared
**	to Frozen
**	to Thawed
**	to Finished or Prepared
**
** There are a couple of exceptions. For example, since for the shim
** writers a 'Thaw' request is equivalent to 'Abort' the 'Thawing'
** state can be reached from 'Prepared', 'Frozen' or 'Thawed'
*/
static BOOL StateTransitionTable [stateMaximumValue][stateMaximumValue] = {
    /*      NewState   Unknown Starting Started Preparing Prepared Freezing Frozen Thawing Aborting Thawed Finishing Finished */
    /* CurState                                                                                                      */
    /*    Unknown   */ {FALSE, TRUE,    FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,    FALSE },
    /*    Starting  */ {FALSE, FALSE,   TRUE,   FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,    FALSE },
    /*    Started   */ {FALSE, TRUE,    FALSE,  TRUE,     FALSE,   FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Preparing */ {FALSE, FALSE,   FALSE,  FALSE,    TRUE,    FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,    FALSE },
    /*    Prepared  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   TRUE,    FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Freezing  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   TRUE,  FALSE,  TRUE,    FALSE, TRUE,    FALSE },
    /*    Frozen    */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, TRUE,   TRUE,    FALSE, TRUE,     FALSE },
    /*    Thawing   */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   TRUE,  TRUE,    FALSE },
    /*    Aborting  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   TRUE,  TRUE,    FALSE },
    /*    Thawed    */ {FALSE, TRUE,    FALSE,  TRUE,     FALSE,   FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Finishing */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, FALSE,    TRUE  },
    /*    Finished  */ {FALSE, TRUE,    FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,     TRUE  }};

LPCWSTR CShimWriter::GetStringFromStateCode (SHIMWRITERSTATE ssStateCode)
    {
    LPCWSTR pwszReturnedString = L"";

    switch (ssStateCode)
	{
	case stateUnknown:              pwszReturnedString = L"Unknown";              break;
	case stateStarting:             pwszReturnedString = L"Starting";             break;
	case stateStarted:              pwszReturnedString = L"Started";              break;
	case statePreparingForSnapshot: pwszReturnedString = L"PreparingForSnapshot"; break;
	case statePreparedForSnapshot:  pwszReturnedString = L"PreparedForSnapshot";  break;
	case stateFreezing:             pwszReturnedString = L"Freezing";             break;
	case stateFrozen:               pwszReturnedString = L"Frozen";               break;
	case stateThawing:              pwszReturnedString = L"Thawing";              break;
	case stateThawed:               pwszReturnedString = L"Thawed";               break;
	case stateAborting:             pwszReturnedString = L"Aborting";             break;	
	case stateFinishing:            pwszReturnedString = L"Finishing";            break;
	case stateFinished:             pwszReturnedString = L"Finished";             break;
	default:                        pwszReturnedString = L"UNDEFINED STATE";      break;
	}

    return (pwszReturnedString);
    }


HRESULT CShimWriter::SetState (SHIMWRITERSTATE	ssNewState,
			       HRESULT		hrWriterStatus)
    {
    HRESULT hrStatus = S_OK;

    if (!StateTransitionTable [m_ssCurrentState][ssNewState])
	{
	//  Bad transition.  Only print out function tracer enter/exit stuff in this error case, otherwise
	//  we'll have too many trace messages.
        CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriter::SetState - INVALID STATE" );
	ft.Trace(VSSDBG_SHIM, L"MiniWriter: %s, OldState: %s, NewState: %s, hrWriterStatus: 0x%08x",
                m_pwszWriterName, GetStringFromStateCode( m_ssCurrentState ), GetStringFromStateCode( ssNewState ),
       	        hrWriterStatus);
	hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
	ft.hr = hrStatus;       //  Will print out in function exit trace.
	}
    else
	{
	/*
	** The status maintained by the shim writer class is the last
	** status returned by the writer where any failure status
	** 'latches' and cannot be overriden until we are entering
	** either a 'Aborting' or 'Finishing' state. In those cases
	** the maintained status is updated (effectively reset) with
	** whatever has been specified.
	*/
	if (SUCCEEDED (m_hrStatus)         ||
	    (stateAborting  == ssNewState) ||
	    (stateFinishing == ssNewState))
	    {
	    m_hrStatus = hrWriterStatus;
	    }

	m_ssCurrentState = ssNewState;

	hrStatus = m_hrStatus;
	}


    return (hrStatus);
    } /* CShimWriter::SetState () */

/*
**++
**
**  Routine Description:
**
**	Default implementations of the shim writer event routines that an
**	individual shim writer can choose to implement (over-ride) or not
**	as it sees fit.
**
**
**  Arguments (implicit):
**
**	None except m_pwszTargetPath for DoThaw() and DoShutdown()
**
**
**  Return Value:
**
**	NOERROR for the default routines
**	Any HRESULT from the shim writer overridden functions.
**--
*/

HRESULT CShimWriter::DoStartup ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoIdentify ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoPrepareForBackup ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoPrepareForSnapshot ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoFreeze ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoThaw ()
    {
    CleanupTargetPath (m_pwszTargetPath);

    return (NOERROR);
    }


HRESULT CShimWriter::DoAbort ()
    {
    return (DoThaw ());
    }


HRESULT CShimWriter::DoBackupComplete ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoShutdown ()
    {
    return (NOERROR);
    }




/*
**************************************************************
**************************************************************
**
** CVssWriterShim implementation
**
**
**************************************************************
**************************************************************
*/

/*
**++
**
**  Routine Description:
**
**	Constructor for the CVssWriterShim class which iniatialise all
**	of the data member of the class, either to default values or
**	to some supplied parameters.
**
**	This class is used to respond to events from the snapshot
**	coordinator and to distribute those events to a collection of
**	sub or mini-writers, a single instance of which is managed by
**	the CShimWriter class.
**
**	Effectively the CShimWriter class looks down to the
**	mini-writer and the CVssWriterShim lookup up to the
**	coordinator.
**
**
**  Arguments:
**
**	pwszWriterName		Name of the shim writer
**	idWriter		Id of the writer
**	bBootableState		Set for a bootable state writer
**	ulWriterCount		How many sub or mini-writers are managed
**	prpCShimWriterArray	Array of function pointer tables for mini-writers
**
**
**  Return Value:
**
**	None
**--
*/

CVssWriterShim::CVssWriterShim (LPCWSTR       pwszWriterName,
				LPCWSTR       pwszWriterSpitDirectoryRoot,
				VSS_ID        idWriter,
				BOOL          bBootableState,
				ULONG         ulWriterCount,
				PCShimWriter *prpCShimWriterArray) :
	m_pwszWriterName(pwszWriterName),
	m_pwszWriterSpitDirectoryRoot(pwszWriterSpitDirectoryRoot),
	m_idWriter(idWriter),
	m_bBootableState(bBootableState),
	m_hrInitialize(HRESULT_FROM_WIN32 (ERROR_NOT_READY)),
	m_bSubscribed(FALSE),
	m_ulWriterCount(ulWriterCount),
	m_prpCShimWriterArray(prpCShimWriterArray),
	m_bRegisteredInThisProcess(FALSE),
	m_bDirectStartupCalled(FALSE),
	m_eRequestedOperation(eOpUndefined),
	m_hrStatusRequestedOperation(HRESULT_FROM_WIN32 (ERROR_NOT_READY)),
	m_hEventOperationRequest(INVALID_HANDLE_VALUE),
	m_hEventOperationCompleted(INVALID_HANDLE_VALUE),
	m_hWorkerThread(INVALID_HANDLE_VALUE),
	m_eThreadStatus(eStatusNotRunning),
	m_hrWorkerThreadCompletionStatus(NOERROR)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::CVssWriterShim");

    memset (&m_wtArgs, 0x00, sizeof (m_wtArgs));
    } /* CVssWriterShim::CVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Destructor for the CVssWriterShim class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	None
**--
*/

CVssWriterShim::~CVssWriterShim ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::~CVssWriterShim");

    UnRegisterWriterShim ();

    DeliverEventShutdown ();

    CommonCloseHandle (&m_hEventOperationCompleted);
    CommonCloseHandle (&m_hEventOperationRequest);
    CommonCloseHandle (&m_hWorkerThread);
    } /* CVssWriterShim::~CVssWriterShim () */

/*
**++
**
**  Routine Description:
**
**	Registers all of the COM Event subscriptions by creating a
**	thread to call the event subscription routines. A thread is
**	used to ensure that there are no thread dependencies on any of
**	the shims thread when the COM event system delivers events.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

HRESULT CVssWriterShim::RegisterWriterShim (VOID)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"RegisterCVssWriterShim");

    try
	{
	/*
	** Do the subscriptions in a multithreaded apartment so
	** that callbacks come in on a separate thread.
	*/
	DWORD tid;
	DWORD dwStatusWait;
	HANDLE hThread = CreateThread (NULL,
				       256 * 1024,
				       CVssWriterShim::RegisterWriterShimThreadFunc,
				       this,
				       0,
				       &tid);


	ft.hr = GET_STATUS_FROM_HANDLE (hThread);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CreateThread");



	/*
	** wait for thread to complete
	*/
	dwStatusWait = WaitForSingleObject (hThread, INFINITE);

	if (WAIT_FAILED == dwStatusWait)
	    {
	    ft.hr = GET_STATUS_FROM_BOOL (FALSE);
	    }


	CloseHandle (hThread);


	LogAndThrowOnFailure (ft,
			      m_pwszWriterName,
			      L"WaitForSingleObject");


	ft.hr = m_hrInitialize;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::RegisterCVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Wrapper routine to get from a thread start point into the
**	class based CVssWriterShim::DoRegistration()
**
**
**  Arguments:
**
**	pv	Address of an argument block
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

DWORD WINAPI CVssWriterShim::RegisterWriterShimThreadFunc (void *pv)
	{
	CVssWriterShim *pShim = (CVssWriterShim *) pv;

	pShim->DoRegistration ();
	return 0;
	} /* CVssWriterShim::RegisterWriterShimThreadFunc () */

/*
**++
**
**  Routine Description:
**
**	Registers all of the COM Event subscriptions. The actual
**	writer initialisation and subscription happens here.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

void CVssWriterShim::DoRegistration (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::DoRegistration");

    BOOL fCoinitializeSucceeded = false;

    try
	{
	ft.Trace (VSSDBG_SHIM, L"Registering Subscriptions");

	if (m_bSubscribed)
	    {
	    /*
	    ** Shouldn't be seen by an end user but might be seen by a developer
	    */
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    BS_ASSERT (false && L"FAILED as already initialized/subscribed CVssWriterShim class");

	    LogAndThrowOnFailure (ft, m_pwszWriterName, NULL);
	    }



	/*
	** Set ourselves up in a multi-threaded apartment
	*/
	ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CoInitializeEx");


	fCoinitializeSucceeded = true;


	/*
	** Try enabling SE_BACKUP_NAME privilege
	*/
	ft.hr = TurnOnSecurityPrivilegeBackup();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"TurnOnSecurityPrivilegeBackup");



	/*
	** Initialize the writer class
	*/
	ft.hr = Initialize (m_idWriter,
			    m_pwszWriterName,
			    m_bBootableState ? VSS_UT_BOOTABLESYSTEMSTATE : VSS_UT_SYSTEMSERVICE,
			    VSS_ST_OTHER,
			    VSS_APP_SYSTEM);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::Initialize");



	/*
	** Get all the mini-writers ready to receive events
	*/
	ft.hr = DeliverEventStartup ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::DeliverEventStartup");


	/*
	** Connect the writer to the COM event system
	*/
	ft.hr = Subscribe ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::Subscribe");



	/*
	** We are officially subscribed and ready to do work.
	*/
	m_bSubscribed = TRUE;

	} VSS_STANDARD_CATCH(ft);


    if (fCoinitializeSucceeded)
	{
	CoUninitialize();
	}

    m_hrInitialize = ft.hr;
    } /* CVssWriterShim::DoRegistration () */

/*
**++
**
**  Routine Description:
**
**	Disconnect the writer from the COM Event subscriptions.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM UnSubscription methods.
**	S_OK if no errors.
**
**--
*/

HRESULT CVssWriterShim::UnRegisterWriterShim (VOID)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"UnRegisterCVssWriterShim");


    if (m_bSubscribed)
	{
	/*
	** First remove all the subscriptions and when that is safely
	** done call all Finished functions in function table and then
	** close the mutex handle.
	**
	** Note that we have to persevere in the case of errors as we
	** cannot assume that the caller will ever re-attempt the
	** unregister following a failure and we need to make sure
	** that we limit the damage as much as possible (ie we restart
	** paused services etc). The best we can do is trace/log the
	** problem.
	*/
	ft.hr = Unsubscribe ();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_pwszWriterName,
		    L"CVssWriterShim::Unsubscribe",
		    L"CVssWriterShim::UnRegisterWriterShim");

	m_bSubscribed = FALSE;
	}


    return (ft.hr);
    } /* UnRegisterCVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Event handling routines to take the OnXxxx() method calls
**	invoked by the COM event delivery mechanism and request the
**	internal worker thread to spread the word to the individual
**	mini-writers being managed by this class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM UnSubscription methods.
**	S_OK if no errors.
**
**--
*/


bool STDMETHODCALLTYPE CVssWriterShim::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnIdentify");
    ThreadArgs	wtArgs;


    try
	{
	wtArgs.wtArgsIdentify.pIVssCreateWriterMetadata = pIVssCreateWriterMetadata;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnIdentify for %s", m_pwszWriterName);


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventIdentify, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ft.hr);
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnIdentify () */



bool STDMETHODCALLTYPE CVssWriterShim::OnPrepareSnapshot ()
    {
    CVssFunctionTracer   ft (VSSDBG_SHIM, L"CVssWriterShim::OnPrepareSnapshot");
    ThreadArgs		 wtArgs;


    try
	{
	wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup  = IsBootableSystemStateBackedUp ();
	wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId     = GetCurrentSnapshotSetId ();
	wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount         = GetCurrentVolumeCount ();
	wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray = GetCurrentVolumeArray ();
	wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync         = NULL;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnPrepareSnapshot for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"    BootableState = %s", wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup ? L"yes" : L"no");
	ft.Trace (VSSDBG_SHIM, L"    SnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId));
	ft.Trace (VSSDBG_SHIM, L"    VolumeCount   = %d", wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount);


	for (UINT iVolumeCount = 0;
	     iVolumeCount < wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount;
	     iVolumeCount++)
	    {
	    ft.Trace (VSSDBG_SHIM,
		      L"        VolumeNamesList [%d] = %s",
		      iVolumeCount,
		      wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray [iVolumeCount]);
	    }



	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventPrepareForSnapshot, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ft.hr);
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnPrepare () */



bool STDMETHODCALLTYPE CVssWriterShim::OnFreeze ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnFreeze");
    ThreadArgs		wtArgs;


    try
	{
	wtArgs.wtArgsFreeze.guidSnapshotSetId = GetCurrentSnapshotSetId ();
	wtArgs.wtArgsFreeze.pbCancelAsync     = NULL;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnFreeze for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsFreeze.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventFreeze, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnFreeze () */



bool STDMETHODCALLTYPE CVssWriterShim::OnThaw ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnThaw");
    ThreadArgs		wtArgs;


    try
	{
	wtArgs.wtArgsThaw.guidSnapshotSetId = GetCurrentSnapshotSetId ();

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnThaw for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsThaw.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventThaw, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnThaw () */



bool STDMETHODCALLTYPE CVssWriterShim::OnAbort ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnAbort");
    ThreadArgs		wtArgs;
    const GUID		guidSnapshotSetId = GetCurrentSnapshotSetId ();


    try
	{
	wtArgs.wtArgsAbort.guidSnapshotSetId = GetCurrentSnapshotSetId ();

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnAbort for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsAbort.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventAbort, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnAbort () */


/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver an 'Identify' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Identify() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventIdentify");
    HRESULT		hrLastFailure = NOERROR;
    BOOL		bCallWriter;

    /*
    ** First setup the Restore Method.  Specify a custom restore method.
    */
    ft.hr = pIVssCreateWriterMetadata->SetRestoreMethod (VSS_RME_CUSTOM,
                                                         NULL,
                                                         NULL,
                                                         VSS_WRE_NEVER,
                                                         true);
    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::DeliverEventIdentify");
	
    /*
    ** Send Identify to selected group of writer in function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone should get to hear about the Identify.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Identify)(pIVssCreateWriterMetadata);

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Identify",
		    L"CVssWriterShim::DeliverEventIdentify");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventIdentify () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'PrepareForSnapshot' event
**	by processing each of the class instances in the rgpShimWriters[] array and calling
**	the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer PrepareForSnapshot() functions.
**
**
**--
*/

HRESULT CVssWriterShim::DeliverEventPrepareForSnapshot (BOOL     bBootableStateBackup,
							GUID     guidSnapshotSetId,
							ULONG    ulVolumeCount,
							LPCWSTR *ppwszVolumeNamesArray,
                                                        volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventPrepareForSnapshot");
    HRESULT		hrLastFailure = NOERROR;
    LPCWSTR		pwszTraceStringWriterType;
    UNICODE_STRING	ucsWriterRootDirectory;


    try
	{
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"    BootableState = %s",   bBootableStateBackup ? L"yes" : L"no");
	ft.Trace (VSSDBG_SHIM, L"    SnapshotSetID = "      WSTR_GUID_FMT, GUID_PRINTF_ARG (guidSnapshotSetId));
	ft.Trace (VSSDBG_SHIM, L"    VolumeCount   = %d",   ulVolumeCount);

	for (UINT iVolumeCount = 0; iVolumeCount < ulVolumeCount; iVolumeCount++)
	    {
	    ft.Trace (VSSDBG_SHIM,
		      L"        VolumeNamesList [%d] = %s",
		      iVolumeCount,
		      ppwszVolumeNamesArray [iVolumeCount]);
	    }


	/*
	** Send PrepareForSnapshot to selected group of writers in
	** function table. We are going to do all of the writers in
	** the group even if one of them fails partway
	** through. However we will skip sending the freeze event if a
	** writer fails the prepare.
	*/
	for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->PrepareForSnapshot) (bBootableStateBackup,
									   ulVolumeCount,
									   ppwszVolumeNamesArray);

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::PrepareForSnapshot",
			L"CVssWriterShim::DeliverEventPrepareForSnapshot");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}

            ft.ThrowIf ( pbCancelAsync != NULL && *pbCancelAsync,
                         VSSDBG_SHIM,
                         VSS_S_ASYNC_CANCELLED,
                         L"User cancelled async operation" );	
	    }


	ft.hr = hrLastFailure;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::DeliverEventPrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Freeze' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Freeze() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventFreeze (GUID guidSnapshotSetId,
                                            volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventFreeze");
    HRESULT		hrLastFailure = NOERROR;


    try
	{
	/*
	** Send Freeze to a selected group of writers in function
	** table. Note that all writers in the group get called and
	** for freezing at level2
	*/
	for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Freeze)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Freeze",
			L"CVssWriterShim::DeliverEventFreeze");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	
            ft.ThrowIf ( pbCancelAsync != NULL && *pbCancelAsync,
                         VSSDBG_SHIM,
                         VSS_S_ASYNC_CANCELLED,
                         L"User cancelled async operation - 2" );	
	    }

	ft.hr = hrLastFailure;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::DeliverEventFreeze () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Thaw' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Thaw() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventThaw (GUID guidSnapshotSetId)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventThaw");

    UNICODE_STRING	ucsWriterRootDirectory;
    HRESULT		hrStatus;
    HRESULT		hrLastFailure = NOERROR;
    ULONG		ulIndex       = m_ulWriterCount;


    try
	{
	/*
	** Send Thaw to selected group of writers in the function
	** table. Keep going for all the writers in the group even if
	** one of them fails. Everyone MUST get to hear about the
	** Thaw.
	*/
	while (ulIndex--)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Thaw)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Thaw",
			L"CVssWriterShim::DeliverEventThaw");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	    }



	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CVssWriterShim::DeliverEventThaw () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver an 'Abort' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Abort() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventAbort (GUID guidSnapshotSetId)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventAbort");


    UNICODE_STRING	ucsWriterRootDirectory;
    HRESULT		hrStatus;
    HRESULT		hrLastFailure = NOERROR;
    ULONG		ulIndex       = m_ulWriterCount;


    try
	{
	/*
	** Send Abort to selected group of writers in the function
	** table. Keep going for all the writers in the group even if
	** one of them fails. Everyone MUST get to hear about the
	** Abort.
	*/
	while (ulIndex--)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Abort)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Abort",
			L"CVssWriterShim::DeliverEventAbort");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	    }



	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CVssWriterShim::DeliverEventAbort () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Startup' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point. This gives the shim writer the
**	chance to set up some initial state. This is called once in response to
**	a registration of the shim writer. It is NOT called for each individual
**	Prepare/Freeze/Thaw sequence.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Startup() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventStartup ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventStartup");
    HRESULT		hrLastFailure = NOERROR;


    /*
    ** Send Startup to selected group of writers in the function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone MUST get to hear about the Startup.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Startup)();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Startup",
		    L"CVssWriterShim::DeliverEventStartup");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventStartup () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Shutdown' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point. This gives the shim writer the
**	chance to cleanup any oustanding state. It is expected that Shutdown might
**	be called at any time as a reponse to an unload of the DLL housing this
**	code. A call to the shutdown routines may be follwed by either a call to
**	the destructor for the class instance or the startup function. This
**	routine is NOT called for each individual Prepare/Freeze/Thaw sequence.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**      This method is NOT called by the worker thread, it is only called in the CVssWriterShim
**      destructor.
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Shutdown() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventShutdown ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventShutdown");
    HRESULT		hrLastFailure = NOERROR;


    /*
    ** Send Shutdown to selected group of writers in the function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone MUST get to hear about the Shutdown.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Shutdown)();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Shutdown",
		    L"CVssWriterShim::DeliverEventShutdown");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventShutdown () */


/*
**++
**
**  Routine Description:
**
**	Routines to operate a worker thread which is used to provide a
**	stable context under which to call the mini-writers.
**
**	The prime need for this statble context is the mutex (which
**	must belong to a thread) which is used to protect the
**	PrepareForSnapshot, Freeze, Thaw/Abort event sequence as
**	executed by the writer from that executed by direct calls to
**	the SimulateSnapshotXxxx() routines.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from
**		CreateEventW()
**		CreateThread()
**		ConstructSecurityAttributes()
**
**--
*/

HRESULT CVssWriterShim::WorkerThreadStartup (void)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::WorkerThreadStartup");

    HRESULT		hrStatusClassified = NOERROR;

    SECURITY_DESCRIPTOR	sdSecurityDescriptor;


    try
	{
	if (!HandleInvalid (m_hWorkerThread)          ||
	    !HandleInvalid (m_hEventOperationRequest) ||
	    !HandleInvalid (m_hEventOperationCompleted))
	    {
	    ft.LogError (VSS_ERROR_SHIM_WORKER_THREAD_ALREADY_RUNNING,
			 VSSDBG_SHIM << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED with invalid handle for worker thread, mutex or events");
	    }


	m_hEventOperationRequest = CreateEventW (NULL, FALSE, FALSE, NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hEventOperationRequest);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_REQUEST_EVENT,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED to create OperationRequest event for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified);
	    }


	m_hEventOperationCompleted = CreateEventW (NULL, FALSE, FALSE, NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hEventOperationCompleted);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_COMPLETION_EVENT,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED to create OperationCompleted event for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified );
	    }


	m_hWorkerThread = CreateThread (NULL,
					0,
					CVssWriterShim::WorkerThreadJacket,
					this,
					0,
					NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hWorkerThread);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_THREAD,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED creating worker thread for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified );
	    }



	ft.Trace (VSSDBG_SHIM, L"Created worker thread for writer %s", m_pwszWriterName);

	} VSS_STANDARD_CATCH (ft);



    if (ft.HrFailed ())
	{
	CommonCloseHandle (&m_hEventOperationCompleted);
	CommonCloseHandle (&m_hEventOperationRequest);

	m_eThreadStatus = eStatusNotRunning;
	m_hWorkerThread = INVALID_HANDLE_VALUE;
	}

    return (ft.hr);
    } /* CVssWriterShim::WorkerThreadStartup () */

/*
**++
**
**  Routine Description:
**
**	Wrapper routine to get from a thread start point into the
**	class based CVssWriterShim::WorkerThread()
**
**
**  Arguments:
**
**	pvThisPtr	Address of an class 'this' pointer
**
**
**  Return Value:
**
**	None
**
**--
*/

DWORD WINAPI CVssWriterShim::WorkerThreadJacket (void *pvThisPtr)
    {
    PCVssWriterShim pCVssWriterShim = (PCVssWriterShim) pvThisPtr;

    pCVssWriterShim->WorkerThread ();

    return (0);
    } /* CVssWriterShim::WorkerThreadJacket () */

/*
**++
**
**  Routine Description:
**
**	Worker thread to deliver requested events to mini-writers.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT generated by the mini-writers.
**
**--
*/

HRESULT CVssWriterShim::WorkerThread (void)
    {
    HRESULT	hrStatus  = NOERROR;
    BOOL	bContinue = TRUE;
    BOOL	bSucceeded;
    DWORD	dwStatusWait;


    while (bContinue)
	{
	m_eThreadStatus = eStatusWaitingForOpRequest;

	dwStatusWait = WaitForSingleObject (m_hEventOperationRequest, INFINITE);


	m_eThreadStatus = eStatusProcessingOpRequest;

	switch (dwStatusWait)
	    {
	    case WAIT_OBJECT_0:
		hrStatus = NOERROR;
		break;


	    case WAIT_FAILED:
		hrStatus = GET_STATUS_FROM_BOOL (FALSE);
		break;


	    default:
		hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
		break;
	    }



	if (FAILED (hrStatus))
	    {
	    /*
	    ** If we have had any failures operating the thread then
	    ** it's time to leave.
	    */
	    LogFailure (NULL,
			hrStatus,
			m_hrStatusRequestedOperation,
			m_pwszWriterName,
			L"WaitForSingleObject",
			L"CVssWriterShim::WorkerThread");

	    m_hrStatusRequestedOperation = hrStatus;

	    bContinue = FALSE;
	    }
	else
	    {
	    /*
	    ** We've been asked to do something. find out what and go do it.
	    */
	    switch (m_eRequestedOperation)
		{
		case eOpDeliverEventStartup:
		    m_hrStatusRequestedOperation = DeliverEventStartup ();
		    break;

		case eOpDeliverEventIdentify:
		    m_hrStatusRequestedOperation = DeliverEventIdentify (m_wtArgs.wtArgsIdentify.pIVssCreateWriterMetadata);
		    break;
			
		case eOpDeliverEventPrepareForBackup:
		    m_hrStatusRequestedOperation = NOERROR;
		    break;

		case eOpDeliverEventPrepareForSnapshot:
		    m_hrStatusRequestedOperation = DeliverEventPrepareForSnapshot (m_wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup,
										   m_wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId,
										   m_wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount,
										   m_wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray,
										   m_wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync);
		    break;
		
		case eOpDeliverEventFreeze:
		    m_hrStatusRequestedOperation = DeliverEventFreeze (m_wtArgs.wtArgsFreeze.guidSnapshotSetId,
							                 m_wtArgs.wtArgsFreeze.pbCancelAsync);
		    break;

		case eOpDeliverEventThaw:
		    m_hrStatusRequestedOperation = DeliverEventThaw (m_wtArgs.wtArgsThaw.guidSnapshotSetId);
		    break;

		case eOpDeliverEventAbort:
		    m_hrStatusRequestedOperation = DeliverEventAbort (m_wtArgs.wtArgsAbort.guidSnapshotSetId);
		    break;

		case eOpWorkerThreadShutdown:
		    m_hrStatusRequestedOperation = NOERROR;
		    hrStatus                     = NOERROR;

		    bContinue = FALSE;
		    break;

		default:
		    LogFailure (NULL,
				HRESULT_FROM_WIN32 (ERROR_INVALID_OPERATION),
				m_hrStatusRequestedOperation,
				m_pwszWriterName,
				L"CVssWriterShim::DeliverEventUnknown",
				L"CVssWriterShim::WorkerThread");

		    break;
		}
	    }



	if (!bContinue)
	    {
	    m_eThreadStatus                  = eStatusNotRunning;
	    m_hWorkerThread                  = INVALID_HANDLE_VALUE;
	    m_hrWorkerThreadCompletionStatus = hrStatus;
	    }



	/*
	** The SetEvent() must be the last call on a shutdown to touch
	** the class as by the very next instruction it may no longer
	** be there.
	*/
	bSucceeded = SetEvent (m_hEventOperationCompleted);

	LogFailure (NULL,
		    GET_STATUS_FROM_BOOL (bSucceeded),
		    hrStatus,
		    L"(UNKNOWN)",
		    L"SetEvent",
		    L"CVssWriterShim::WorkerThread");


	bContinue &= bSucceeded;
	}


    return (hrStatus);
    } /* CVssWriterShim::WorkerThread () */

/*
**++
**
**  Routine Description:
**
**	Routine to request an operation of the worker thread for this
**	class. Uses a critical section to ensure only on operation can
**	be outstanding at any one time.
**
**
**  Arguments:
**
**	eOperation	Code to selct the required operation
**	pThreadArgs	Pointer to a block of args specific to the operation
**
**
**  Return Value:
**
**	Any HRESULT generated by the operation.
**
**--
*/

HRESULT CVssWriterShim::WorkerThreadRequestOperation (RequestOpCode eOperation, PThreadArgs pThreadArgs)
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::RequestOperation");

    DWORD	dwStatusWait;
    BOOL	bSucceeded;


    try
	{
        CBsAutoLock cAutoLock (m_cCriticalSection);


	if (HandleInvalid (m_hWorkerThread))
	    {
	    ft.LogError (VSS_ERROR_SHIM_WRITER_NO_WORKER_THREAD,
			 VSSDBG_SHIM << m_pwszWriterName << eOperation);

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED requesting operation 0x%02X in %s due to missing worker thread",
		      eOperation,
		      m_pwszWriterName);
	    }


	if (NULL != pThreadArgs)
	    {
	    m_wtArgs = *pThreadArgs;
	    }

	m_eRequestedOperation = eOperation;

	bSucceeded = SetEvent (m_hEventOperationRequest);

	ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"SetEvent");




	dwStatusWait = WaitForSingleObject (m_hEventOperationCompleted, INFINITE);

	switch (dwStatusWait)
	    {
	    case WAIT_OBJECT_0:

		ft.hr = m_hrStatusRequestedOperation;

		ft.ThrowIf (ft.HrFailed (),
			    VSSDBG_SHIM,
			    ft.hr,
			    L"FAILED whilst processing requested operation 0x%02X", eOperation);

		break;


	    case WAIT_FAILED:
		ft.hr = GET_STATUS_FROM_BOOL (FALSE);
		break;


	    default:
		ft.hr = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
		break;
	    }


	if (ft.HrFailed ())
	    {
	    HRESULT hrStatusClassified = ClassifyWriterFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_WRITER_FAILED_OPERATION,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified<< m_pwszWriterName << eOperation );

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED with 0x%08lX (converted to 0x%08lX) waiting for completion of requested operation 0x%02X in writer %s",
		      ft.hr,
		      hrStatusClassified,
		      eOperation,
		      m_pwszWriterName);
	    }
	} VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* CVssWriterShim::RequestOperation () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\inc\build.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    build.h

Abstract:

    Declaration of the build number for VSS modules

Remark: 

    DO NOT edit this file!
    This file was generated by buildgen.pl. 
    Rerun buildgen for a new build version!

--*/

#define VSS_BUILD_NO 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrtls.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrtls.cpp

Abstract:

    Writer shim module for Terminal Server Licensing

Author:

    Stefan R. Steiner   [ssteiner]        02-13-2000

Revision History:

	X-9	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-8	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path
		141365: Workaround problem in loading tls236.dll by 
		        pre-loading user32

	X-7	MCJ		Michael C. Johnson		21-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-6	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-5	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		23-Mar-2000
		Get writer to use same context mechanism as most of the other
		writers.

	X-2	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

--*/

#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHTLSC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING	L"TerminalServicesLicensingServer"
#define COMPONENT_NAME		L"Terminal Services Licensing Server"

#define TARGET_PATH		ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


#define	EXPORTPATH_SUBKEY	L"System\\CurrentControlSet\\services\\TermServLicensing\\Parameters"
#define	EXPORTPATH_VALUENAME	L"DBPath"
#define EXPORTPATH_DIRECTORY	L"\\Export\\"


/*
**  Terminal service licensing DLL function prototype
*/
typedef DWORD (WINAPI *PFUNC_ExportTlsDatabaseC)(VOID);



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterTLS : public CShimWriter
    {
public:
    CShimWriterTLS (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterTLS ShimWriterTLS (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterTLS = &ShimWriterTLS;




/*
**++
**
** Routine Description:
**
**	The Terminal Services Licensing Server database snapshot
**	writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- */

HRESULT CShimWriterTLS::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"IVssCreateWriterMetadata::AddComponent", 
		L"CShimWriterTLS::DoIdentify");


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddFilesToFileGroup", 
		    L"CShimWriterTLS::DoIdentify");
	}


    return (hrStatus);
    } /* CShimWriterTLS::DoIdentify () */


/*
**++
**
**  Routine Description:
**
**	The TLS writer PrepareForFreeze function.  Currently all of the
**	real work for this writer happens here.
**
**  Arguments:
**
**	Same arguments as those passed in the PrepareForFreeze event.
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterTLS::DoPrepareForSnapshot ()
    {
    HRESULT			hrStatus;
    DWORD			dwStatus;
    DWORD			dwValueDataLength;
    DWORD			dwValueType;
    BOOL			bSucceeded;
    BOOL			bExportPathKeyOpened = FALSE;
    UNICODE_STRING		ucsTargetPath;
    UNICODE_STRING		ucsSourcePath;
    UNICODE_STRING		ucsValueData;
    PFUNC_ExportTlsDatabaseC	ExportTlsDatabaseC   = NULL;
    HMODULE			hLibraryTermServ     = NULL;
    HMODULE			hLibraryUser32       = NULL;
    HKEY			hkeyExportPath       = NULL;



    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsSourcePath);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueData,
			       REGISTRY_BUFFER_SIZE * sizeof (WCHAR));


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsTargetPath, DIR_SEP_STRING);


	dwStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				  EXPORTPATH_SUBKEY,
				  0,
				  KEY_QUERY_VALUE,
				  &hkeyExportPath);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	bExportPathKeyOpened = SUCCEEDED (hrStatus);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no exportpath subkey entry"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	
	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	** Everything is setup, so first check to see if there is a
	** registry key present which will tell us where the
	** ExportTlsDatabaseC() call is going to dump it's file. Also,
	** if it's got environment variables in it make sure they get
	** expanded.
	*/
	dwValueDataLength = ucsValueData.MaximumLength;
	dwValueType       = REG_NONE;

	dwStatus = RegQueryValueExW (hkeyExportPath,
				     EXPORTPATH_VALUENAME,
				     NULL,
				     &dwValueType,
				     (PBYTE) ucsValueData.Buffer,
				     &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no DBPath entry"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	
	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegQueryValueExW", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
	{
	ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
						   ucsValueData.Buffer,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    **  That gets us the root, now append the actual directory
	    */
	    StringAppendString (&ucsSourcePath, EXPORTPATH_DIRECTORY);
	    }
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	** As a workaround to a problem with unloading - reloading
	** user32 pre-load things so we can guarantee at least one
	** reference on it and stop it going away over the critical
	** point.
	*/
	hLibraryUser32 = LoadLibraryW (L"user32.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hLibraryUser32);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (user32.dll)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
        /*
	**  Now tell TLS to export the database
        **
	**
        **  First load the TLS backup DLL
	*/
        hLibraryTermServ = LoadLibraryW (L"tls236.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hLibraryTermServ);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    /*
	    **  Terminal Server Licensing service probably not installed
	    */
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no tls236.dll found"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (tls236.dll)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
        /*
	** Now setup the function pointer to the export function
	*/
	ExportTlsDatabaseC = (PFUNC_ExportTlsDatabaseC) GetProcAddress (hLibraryTermServ, 
									"ExportTlsDatabaseC");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != ExportTlsDatabaseC);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (ExportTlsDatabaseC)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	try
	    {
	    /*
	    ** Perform the export
	    */
	    dwStatus = ExportTlsDatabaseC();

	    hrStatus = HRESULT_FROM_WIN32 (dwStatus);
	    }

	catch (DWORD dwStatus)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (dwStatus);
	    }

	catch (...)
	    {
	    hrStatus = E_UNEXPECTED;
	    }



	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    /*
	    **  Terminal Server Licensing service probably not running
	    */
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not running, "
				 L"perhaps not a DomainController?"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"ExportTlsDatabaseC", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	**  Now move the files in the export directory to the TLS backup directory
	*/
	hrStatus = MoveFilesInDirectory (&ucsSourcePath, &ucsTargetPath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}





    /*
    ** Release the libraries
    */
    if (bExportPathKeyOpened)              RegCloseKey (hkeyExportPath);
    if (!HandleInvalid (hLibraryTermServ)) FreeLibrary (hLibraryTermServ);
    if (!HandleInvalid (hLibraryUser32))   FreeLibrary (hLibraryUser32);

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);
    StringFree (&ucsValueData);

    return (hrStatus);
    } /* CShimWriterTLS::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\inc\ijetwriter.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ijetwriter.h

Abstract:

    Definition of CVssIJetWriter class

	Brian Berkowitz  [brianb]  3/17/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/17/2000  Created
    mikejohn    04/03/2000  Added extra methods for OnIdentify()
    mikejohn	08/21/2000  165913: Deallocate memory on class destruction
			    161899: Add methods for matching paths in exclude list
    mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCIJWRH"
//
////////////////////////////////////////////////////////////////////////

class CVssIJetWriter;

typedef CVssIJetWriter *PVSSIJETWRITER;


// actual writer class
class CVssIJetWriter : public CVssWriter
	{

// Constructors and destructors
public:
	virtual STDMETHODCALLTYPE ~CVssIJetWriter();

	STDMETHODCALLTYPE CVssIJetWriter() :
		m_wszWriterName(NULL),
		m_wszFilesToInclude(NULL),
		m_wszFilesToExclude(NULL)
		{
		InitializeListHead (&m_leFilesToIncludeEntries);
		InitializeListHead (&m_leFilesToExcludeEntries);
		}
	
	static HRESULT STDMETHODCALLTYPE Initialize
		(
		IN VSS_ID idWriter,
		IN LPCWSTR wszWriterName,
		IN bool bSystemService,
		IN bool bBootableSystemState,
		LPCWSTR wszFilesToInclude,
		LPCWSTR wszFilesToExclude,
		IN CVssJetWriter *pWriter,
		OUT void **ppInstanceCreated
		);

	static void STDMETHODCALLTYPE Uninitialize(IN PVSSIJETWRITER pInstance);

	// callback for identify event
	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// callback for prepare backup event
	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	// called at Prepare to freeze
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	// called at freeze
	virtual bool STDMETHODCALLTYPE OnFreeze();

	// called at thaw
	virtual bool STDMETHODCALLTYPE OnThaw();

	// called at post snapshot
	virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pComponent);

	// called when timeout occurs
	virtual bool STDMETHODCALLTYPE OnAbort();

	// callback on backup complete event
	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	// callback on prerestore event
	virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);


	// callback on postrestore event
	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);

private:

	HRESULT InternalInitialize
		(
		IN VSS_ID idWriter,
		IN LPCWSTR wszWriterName,
		IN bool bSystemService,
		IN bool bBootableSystemState,
		IN LPCWSTR wszFilesToInclude,
		IN LPCWSTR wszFilesToExclude
		);

	bool PreProcessIncludeExcludeLists  (bool bProcessingIncludeList);
	bool ProcessIncludeExcludeLists     (bool bProcessingIncludeList);
	void PostProcessIncludeExcludeLists (bool bProcessingIncludeList);

	bool ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo);

	BOOL CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
					    LPCWSTR pwszDatabaseFileSpec);

	bool FCheckInstanceVolumeDependencies
		(
		IN const JET_INSTANCE_INFO * pInstanceInfo
		) const;

	bool FCheckVolumeDependencies
		(
		IN unsigned long cInstanceInfo,
		IN JET_INSTANCE_INFO *aInstanceInfo
		) const;

	bool FCheckPathVolumeDependencies(IN const char * szPath) const;

	LPCWSTR GetApplicationName() const { return m_wszWriterName; }

	VSS_ID				 m_idWriter;
	LPWSTR				 m_wszWriterName;
	JET_OSSNAPID			 m_idJet;
	CVssJetWriter			*m_pwrapper;
	LPWSTR				 m_wszFilesToInclude;
	LPWSTR				 m_wszFilesToExclude;
	bool				 m_bSystemService;
	bool				 m_bBootableSystemState;
	IVssCreateWriterMetadata	*m_pIMetadata;
	LIST_ENTRY			 m_leFilesToIncludeEntries;
	LIST_ENTRY			 m_leFilesToExcludeEntries;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\inc\sqlsnap.h ===
//
// sqlsnap.h  Define the interface to the nt/sql snapshot handler.
//
//	The idea here is for a pure interface, making it easy to keep the
// abstraction maximized (can move to COM later, if we like).
//
//  No C++ exceptions will be thrown across the interfaces.
//
//  To use this interface, the calling process must invoke:
//	InitSQLEnvironment - once to setup the environment, establishing
//		the error and trace loggers.
//		The trace logger is optional, but an error logger must be provided.
//      The loggers are created by deriving from CLogFacility and implementing
//		a "WriteImplementation" method.
//
//	Thereafter,	calls to "CreateSqlSnapshot" are used to create snapshot objects
//  which encapsulate the operations needed to support storage snapshots.
//
//  *****************************************
//     LIMITATIONS
//
//	- only SIMPLE databases can be snapshot (trunc on checkpoint = 'true')
//  - there is no serialization of services starting or adding/changing file lists during the snapshot
//  - servers which are not started when the snapshot starts are skipped (non-torn databases will be
//      backed up fine, torn databases won't be detected).
//  - sql7.0 databases which are "un"-useable will prevent snapshots (the list of files can't be obtained).
//
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCSQLSH"
//
////////////////////////////////////////////////////////////////////////

HRESULT InitSQLEnvironment();

// Caller must provide a path checker interface.
//
class CCheckPath
{
public:
	virtual bool IsPathInSnapshot (const WCHAR* path) throw () = 0;
};

//-------------------------------------------------------------
// A handler for snapshots.
//
class CSqlSnapshot
{
public:
	virtual ~CSqlSnapshot () throw () {};

	virtual HRESULT Prepare (
		CCheckPath*			checker) throw () = 0;

	virtual HRESULT Freeze () throw () = 0;

	virtual HRESULT Thaw () throw () = 0;

};

extern "C" CSqlSnapshot* CreateSqlSnapshot () throw ();

//-------------------------------------------------------------
// An enumerator for SQL objects.
//
// An object of this class can have only one active query at
// a time.  Requesting a new enumeration will close any previous
// partially fetched result.
//
#define MAX_SERVERNAME	128
#define MAX_DBNAME	128
struct ServerInfo
{
	bool	isOnline;				// true if the server is ready for connections
	WCHAR	name [MAX_SERVERNAME];	// null terminated name of server
};
struct DatabaseInfo
{
	bool	supportsFreeze;			// true if a freeze operation is supported
	WCHAR	name [MAX_DBNAME];		// null terminated name of database
};
struct DatabaseFileInfo
{
	bool	isLogFile;				// true if this is a log file
	WCHAR	name [MAX_PATH];
};


class CSqlEnumerator
{
public:
	virtual ~CSqlEnumerator () throw () {};

	virtual HRESULT FirstServer (
		ServerInfo*			pServer) throw () = 0;

	virtual HRESULT NextServer (
		ServerInfo*			pServer) throw () = 0;

	virtual HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw () = 0;

	virtual HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw () = 0;

	virtual HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pFileInfo) throw () = 0;

	virtual HRESULT NextFile (
		DatabaseFileInfo*	pFileInfo) throw () = 0;
};

extern "C" CSqlEnumerator* CreateSqlEnumerator () throw ();


//------------------------------------------------------
// HRESULTS returned by the interface.
//
// WARNING: I used facility = x78 arbitrarily!
//
#define SQLLIB_ERROR(code) MAKE_HRESULT(SEVERITY_ERROR, 0x78, code)
#define SQLLIB_STATUS(code) MAKE_HRESULT(SEVERITY_SUCCESS, 0x78, code)

// Status codes
//
#define S_SQLLIB_NOSERVERS	SQLLIB_STATUS(1)	// no SQLServers of interest (from Prepare)

// Error codes
//
#define E_SQLLIB_GENERIC	SQLLIB_ERROR(1)		// something bad, check the errorlog

#define E_SQLLIB_TORN_DB	SQLLIB_ERROR(2)		// database would be torn by the snapshot

#define E_SQLLIB_NO_SUPPORT SQLLIB_ERROR(3)		// 6.5 doesn't support snapshots

#define E_SQLLIB_PROTO		SQLLIB_ERROR(4)		// protocol error (ex: freeze before prepare)

#define E_SQLLIB_NONSIMPLE	SQLLIB_ERROR(5)		// only simple databases are supported
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\inc\sqlwriter.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module sqlwriter.h | Declaration of the sql wrier
    @end

Author:

    Brian Berkowitz  [brianb]  04/17/2000

TBD:
	
	Add comments.

Revision History:

	Name		Date	    Comments
	brianb		04/17/2000  created
	brianb		05/05/2000  added OnIdentify support
	mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCSQLWH"
//
////////////////////////////////////////////////////////////////////////

#ifndef __SQLWRITER_H_
#define __SQLWRITER_H_

class CSqlWriter :
	public CVssWriter,
	public CCheckPath
	{
public:
	STDMETHODCALLTYPE CSqlWriter() :
				m_pSqlSnapshot(NULL),
				m_fFrozen(false)
	    {
	    }

	STDMETHODCALLTYPE ~CSqlWriter()
	    {
	    delete m_pSqlSnapshot;
	    }

	bool STDMETHODCALLTYPE OnIdentify(IVssCreateWriterMetadata *pMetadata);

	bool STDMETHODCALLTYPE OnPrepareSnapshot();

	bool STDMETHODCALLTYPE OnFreeze();

	bool STDMETHODCALLTYPE OnThaw();

	bool STDMETHODCALLTYPE OnAbort();

	bool IsPathInSnapshot(const WCHAR *path) throw();

	HRESULT STDMETHODCALLTYPE Initialize();

	HRESULT STDMETHODCALLTYPE Uninitialize();
private:
	CSqlSnapshot *m_pSqlSnapshot;

	void TranslateWriterError(HRESULT hr);

	bool m_fFrozen;
	};

// wrapper class used to create and destroy the writer
// used by coordinator
class CVssSqlWriterWrapper
	{
public:
	__declspec(dllexport)
	CVssSqlWriterWrapper();
	
	__declspec(dllexport)
	~CVssSqlWriterWrapper();

	__declspec(dllexport)
	HRESULT CreateSqlWriter();

	__declspec(dllexport)
	void DestroySqlWriter();
private:
	// initialization function
	static DWORD InitializeThreadFunc(VOID *pv);

	CSqlWriter *m_pSqlWriter;

	// result of initialization
	HRESULT m_hrInitialize;
	};


	
	
#endif // _SQLWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\inc\version.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    version.h

Abstract:

    Declaration of the version numbers for VSS modules
	Used by version.rc2

Revision History:

    Name        Date        Comments
    aoltean     03/12/99    Created with version 0.1.1, build number 1
    aoltean     09/09/1999  dss -> vss
	aoltean		03/09/2000  Uniform versioning

--*/

// general purpose macros
#define EVAL_MACRO(X) X
#define STRINGIZE_ARG(X) #X
#define STRINGIZE(X) EVAL_MACRO(STRINGIZE_ARG(X))


// Version and build number defines
#define VSS_MAJOR_VERSION  1
#define VSS_MINOR_VERSION  0
#define VSS_FIX_VERSION    0

// Definition for VSS_BUILD_NO
#include "build.h"

// Macros used in resource files
#define VSS_FILEVERSION            VSS_MAJOR_VERSION, VSS_MINOR_VERSION, VSS_FIX_VERSION, VSS_BUILD_NO
#define VSS_PRODUCTVERSION         VSS_MAJOR_VERSION, VSS_MINOR_VERSION, VSS_FIX_VERSION, VSS_BUILD_NO

#define VSS_FILE_VERSION_STR           \
    STRINGIZE(VSS_MAJOR_VERSION) ", "  \
    STRINGIZE(VSS_MINOR_VERSION) ", "  \
    STRINGIZE(VSS_FIX_VERSION) ", "    \
    STRINGIZE(VSS_BUILD_NO)            \
	"\0"

#define VSS_PRODUCT_VERSION_STR        \
    STRINGIZE(VSS_MAJOR_VERSION) ", "  \
    STRINGIZE(VSS_MINOR_VERSION) ", "  \
    STRINGIZE(VSS_FIX_VERSION) ", "    \
    STRINGIZE(VSS_BUILD_NO)            \
	"\0"

#define VSS_COMPANY_NAME		"Microsoft Corporation\0"
#define VSS_LEGAL_COPYRIGHT		"Copyright  2000 by Microsoft Corporation\0"
#define VSS_LEGAL_TRADEMARKS	"Microsoft is a registered trademark of Microsoft Corporation. \0"
#define VSS_PRODUCT_NAME		"Microsoft Windows 2000 Operating System\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\samples\requestor\util.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	util.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"



///////////////////////////////////////////////////////////////////////////////
// Print usage


void CVssSampleRequestor::PrintUsage()
{
    wprintf(
        L"\nUsage:\n"
        L"      vsreq [-b] [-s] [-x <file.xml>] [<volumes>]\n"
        L"\nOptions:\n"
        L"      -b              Backup includes bootable & system state.\n"
        L"      -s              Enable component selection.\n"
        L"      -x <file.xml>   Generate an XML file containing the backup metadata\n"
        L"      <volumes>       Specifies the volumes to be part of the snapshot set\n"
        L"                      The volumes in the list must be distinct and \n"
        L"                      must be separated by space. A volume must be \n"
        L"                      terminated with a trailing backslask (for example C:\\).\n"
        L"\n"
        L"\nExample:\n"
        L"      The following command will create a snapshot set\n"
        L"      on the volumes mounted under c:\\ and d:\\\n"
        L"\n"
        L"              vsreq c:\\ d:\\ \n"
        L"\n"
        L"      The following command will create a snapshot set on the volumes \n"
        L"      that contain selected components and also the volume c:\\\n"
        L"      Also, the backup will contain bootable and system state.\n"
        L"      The XML results will be stored in file.xml\n"
        L"\n"
        L"              vsreq -b -s -x file.xml c:\\ \n"
        );
    throw(2);
}


void CVssSampleRequestor::ParseCommandLine(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        )
{
    if (nArgsCount == 0)
        PrintUsage();
    
    // For each argument in the command line
    bool bParsingVolumes = false;
    INT nCurrentArg = nArgsCount;
    WCHAR ** ppwszCurrentArg = ppwszArgsArray;
    for(; nCurrentArg--; ppwszCurrentArg++)
    {
        if (!bParsingVolumes) {
            // Check for Bootable & system state option
            if (!m_bBootableSystemState && !wcscmp(*ppwszCurrentArg, L"-b")) {
                m_bBootableSystemState = true;
                continue;
            }

            // Check for Selected components option
            if (!m_bComponentSelectionEnabled && !wcscmp(*ppwszCurrentArg, L"-s")) {
                m_bComponentSelectionEnabled = true;
                continue;
            }

            // Check for Xml file option
            if (!m_pwszXmlFile && !wcscmp(*ppwszCurrentArg, L"-x")) {
                if (nCurrentArg-- == 0)
                    return PrintUsage();
                ppwszCurrentArg++;
                m_pwszXmlFile = *ppwszCurrentArg;
                continue;
            }
        }

        // We suppose that the next arguments are the volumes
        bParsingVolumes = true;
        
        // Add the volume to the list of snapshotting volumes
        // Make sure that the volume name is valid
        bool bAdded = false;
        if (!AddVolume(*ppwszCurrentArg, bAdded)) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\t%s is not a valid option or a mount point [0x%08lx]\n\n", 
                *ppwszCurrentArg, GetLastError() );
            PrintUsage();
        }

        // Check if the same volume is added twice
        if (!bAdded) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\tThe volume %s is specified twice\n\n", *ppwszCurrentArg );
            PrintUsage();
        }
    }        

    // Check if we added at least one volume
    if ((m_nVolumesCount == 0) && !m_bComponentSelectionEnabled) {
        wprintf(L"\nError while parsing the command line:\n"
            L"\t- You should specify at least one volume or enable component selection\n\n");
        PrintUsage();
    }

}


// Add the given volume by the contained path
void CVssSampleRequestor::AddVolumeForComponent( 
    IN IVssWMFiledesc* pFileDesc 
    )
{
    // Get the component path
	CComBSTR bstrPath;
	CHECK_SUCCESS(pFileDesc->GetPath(&bstrPath));
	
	// Trying to find the volume that will contain the path. 
	WCHAR wszExpandedPath[MAX_TEXT_BUFFER];
    if (!ExpandEnvironmentStringsW(bstrPath, wszExpandedPath, MAX_TEXT_BUFFER))
        Error( 1, L"\nExpandEnvironmentStringsW(%s, wszExpandedPath, MAX_TEXT_BUFFER) failed with [0x%08lx]\n",
            bstrPath, GetLastError());

	// Eliminate one by one the terminating folder names, until we reach an existing path.
	// Then get the volume name for that path
	WCHAR wszMountPoint[MAX_TEXT_BUFFER];
	while(true) {
        if (GetVolumePathNameW(wszExpandedPath, wszMountPoint, MAX_TEXT_BUFFER)) 
            break;
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
            Error( 1, L"\nGetVolumePathNameW(%s, wszMountPoint, MAX_TEXT_BUFFER) failed with [0x%08lx]\n",
                wszExpandedPath, GetLastError());
        WCHAR* pwszLastBackslashIndex = wcsrchr(wszExpandedPath, L'\\');
        if (!pwszLastBackslashIndex)
            Error( 1, L"\nCannot find anymore a backslash in path %s. \n"
                L"The original path %s seems invalid.\n", wszExpandedPath, bstrPath);
        // Eliminate the last folder name
        pwszLastBackslashIndex[0] = L'\0';
    }

    // Add the volume, if possible
    bool bAdded = false;
    if (!AddVolume( wszMountPoint, bAdded ))
            Error( 1, L"\nUnexpected error: cannot add volume %s to the snapshot set.\n", wszMountPoint);
   	wprintf (L"          [Volume %s (that contains the file) %s marked as a candidate for snapshot]\n",
   	    wszMountPoint, bAdded? L"is": L"is already");
}


// Add the given volume in the list of potential candidates for snapshots
// - Returns "false" if the volume does not correspond to a real mount point 
//   (and GetLastError() will contain the correct Win32 error code)
// - Sets "true" in the bAdded parameter if the volume is actually added
bool CVssSampleRequestor::AddVolume( 
    IN WCHAR* pwszVolume,
    OUT bool & bAdded
    )
{
    // Initialize [out] parameters
    bAdded = false;
    
    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolume, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    // Check if the volume is already added.
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
        if (!wcscmp(wszVolumeName, m_ppwszVolumeNamesList[nIndex])) 
            return true; // Volume already added. Stop here.

    // Check if we exceeded the maximum number of volumes
    if (m_nVolumesCount == MAX_VOLUMES)
        Error( 1, L"Maximum number of volumes exceeded");

    // Create a copy of the volume
    WCHAR* pwszNewVolume = _wcsdup(pwszVolume);
    if (pwszNewVolume == NULL)
        Error( 1, L"Memory allocation error");
    
    // Create a copy of the volume name
    WCHAR* pwszNewVolumeName = _wcsdup(wszVolumeName);
    if (pwszNewVolumeName == NULL) {
        free(pwszNewVolume);
        Error( 1, L"Memory allocation error");
    }
    
    // Add the volume in our internal list of snapshotted volumes
    m_ppwszVolumesList[m_nVolumesCount] = pwszNewVolume;
    m_ppwszVolumeNamesList[m_nVolumesCount] = pwszNewVolumeName;
    m_nVolumesCount++;
    bAdded = true;
    
    return true;
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void CVssSampleRequestor::Error( 
    IN  INT nReturnCode, 
    IN  const WCHAR* pwszMsgFormat, 
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

    // throw that return code.
    throw(nReturnCode);
}


///////////////////////////////////////////////////////////////////////////////
// Utility functions


// Print a file description object
void CVssSampleRequestor::PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
{
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));

    wprintf (L"%s\n"
        L"          Path = %s\n"
        L"          Filespec = %s\n"
        L"          Recursive = %s\n",
        wszDescription,
        bstrPath,
        bstrFilespec,
        bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
    	wprintf(L"          Alternate Location = %s\n", bstrAlternate);
}


// Convert a usage type into a string
LPCWSTR CVssSampleRequestor::GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a source type into a string
LPCWSTR CVssSampleRequestor::GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a restore method into a string
LPCWSTR CVssSampleRequestor::GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a writer restore method into a string
LPCWSTR CVssSampleRequestor::GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a component type into a string
LPCWSTR CVssSampleRequestor::GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a failure type into a string
LPCWSTR CVssSampleRequestor::GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{ 
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// Convert a writer status into a string
LPCWSTR CVssSampleRequestor::GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterStatus)
	{
	case VSS_WS_STABLE:                    pwszRetString = L"STABLE";                  break;
	case VSS_WS_WAITING_FOR_FREEZE:        pwszRetString = L"WAITING_FOR_FREEZE";      break;
	case VSS_WS_WAITING_FOR_THAW:          pwszRetString = L"WAITING_FOR_THAW";        break;
	case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:pwszRetString = L"VSS_WS_WAITING_FOR_BACKUP_COMPLETE";  break;
	case VSS_WS_FAILED_AT_IDENTIFY:        pwszRetString = L"FAILED_AT_IDENTIFY";      break;
	case VSS_WS_FAILED_AT_PREPARE_BACKUP:  pwszRetString = L"FAILED_AT_PREPARE_BACKUP";break;
	case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:    pwszRetString = L"VSS_WS_FAILED_AT_PREPARE_SNAPSHOT";  break;
	case VSS_WS_FAILED_AT_FREEZE:          pwszRetString = L"FAILED_AT_FREEZE";        break;
	case VSS_WS_FAILED_AT_THAW:			   pwszRetString = L"FAILED_AT_THAW";          break;
	default:
	    break;
	}

    return (pwszRetString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\samples\requestor\vsreq.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	vsreq.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"


///////////////////////////////////////////////////////////////////////////////
// Processing functions

CVssSampleRequestor::CVssSampleRequestor()
{
    // Initialize data members
    m_bCoInitializeSucceeded = false;
    m_bBootableSystemState = false;
    m_bComponentSelectionEnabled = false;
    m_pBackupComponents = NULL;
    m_nVolumesCount = 0;
    m_hr = S_OK;
    m_pwszXmlFile = NULL;
    m_pXmlFile = NULL;

    // For safety
    for (int nIndex=0; nIndex<MAX_VOLUMES; nIndex++) {
        m_ppwszVolumesList[nIndex] = NULL;
        m_ppwszVolumeNamesList[nIndex] = NULL;
    }

    // Print display header
    wprintf(L"\nVSS Requestor Sample application, version 1.0\n");
}


CVssSampleRequestor::~CVssSampleRequestor()
{
    // Deallocate some internal strings
    delete m_pwszXmlFile;
    
    // delete the allocated volumes
    for (int nIndex=0; nIndex<m_nVolumesCount; nIndex++) {
        free(m_ppwszVolumesList[nIndex]);
        free(m_ppwszVolumeNamesList[nIndex]);
    }

    // Close the Xml file
    if (m_pXmlFile)
        fclose(m_pXmlFile);
    
    // Releasing backup components prior to the CoUninitialize call 
    m_pBackupComponents = NULL;

    // Unloading the COM library
    if (m_bCoInitializeSucceeded)
        CoUninitialize();
}


void CVssSampleRequestor::Initialize()
{
    wprintf (L"\n----------------- Initializing ---------------------\n");

    // Initialize COM library
    CHECK_NOFAIL(CoInitializeEx (NULL, COINIT_MULTITHREADED));
	m_bCoInitializeSucceeded = true;
    wprintf (L"COM library initialized.\n");

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);
    wprintf (L"COM security initialized.\n");

    // Open the Xml file
    if (m_pwszXmlFile) {
        m_pXmlFile = _wfopen( m_pwszXmlFile, L"w");
        if (!m_pXmlFile)
            Error(1, L"\nError creating/opening the file %s\n", m_pwszXmlFile);
        wprintf (L"XML results file created: %s\n", m_pwszXmlFile);
    }

    // Create the Backup components object
	CHECK_NOFAIL(CreateVssBackupComponents(&m_pBackupComponents));
    wprintf (L"Backup components object created.\n");

    // Initialize the backup components object for backup
	CHECK_NOFAIL(m_pBackupComponents->InitializeForBackup());
	CHECK_SUCCESS(m_pBackupComponents->SetBackupState(
        m_bComponentSelectionEnabled, m_bBootableSystemState, VSS_BT_FULL));
    wprintf (L"Backup components object initialized for backup operations.\n");
}
    

void CVssSampleRequestor::CreateSnapshotSet()
{
	CComPtr<IVssAsync> pAsync;
	VSS_ID SnapshotsArray[MAX_VOLUMES];
	VSS_ID SnapshotSetId = GUID_NULL;
	
    wprintf (L"\n---------- Starting backup/snapshot ----------------\n");

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	    
    CHECK_SUCCESS(m_pBackupComponents->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++) 
    {
		// Get the volume containing the path
        wprintf(L"\t- Adding volume containing %s ... ", m_ppwszVolumesList[nIndex] );

		// Add the volume to the snapshot set
        CHECK_SUCCESS(m_pBackupComponents->AddToSnapshotSet(m_ppwszVolumesList[nIndex],
            GUID_NULL, &(SnapshotsArray[nIndex])));
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    // Prepare for backup
    wprintf(L"Starting asynchronous PrepareForBackup. Please wait...\n");	    
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->PrepareForBackup(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous PrepareForBackup finished.\n");	    
    pAsync = NULL;

    // Gather writer status
    GatherWriterStatus(L"after PrepareForBackup");

    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	    
    hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->DoSnapshotSet(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	    
    pAsync = NULL;

    // Gather writer status
    GatherWriterStatus(L"after DoSnapshotSet");

    wprintf(L"Snapshot set created\n");
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++) 
    {
        VSS_SNAPSHOT_PROP prop;
        CHECK_SUCCESS(m_pBackupComponents->GetSnapshotProperties(SnapshotsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n", 
            m_ppwszVolumesList[nIndex], prop.m_pwszSnapshotDeviceObject);
        VssFreeSnapshotProperties(&prop);
    }
}


void CVssSampleRequestor::BackupComplete()
{
	unsigned cWriterComponents;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\n------------ Completing backup phase ---------------\n");

	CHECK_SUCCESS(m_pBackupComponents->GetWriterComponentsCount(&cWriterComponents));

    // If component selection enabled,
    if (m_bComponentSelectionEnabled)
    {
		wprintf(L"Setting the succeeded state for the following components:\n");
        // For each component, mark the completion state as succeeded
    	for(unsigned iWriter = 0; iWriter < cWriterComponents; iWriter++)
        {
    	    CComPtr<IVssWriterComponentsExt> pWriter;
    	    CHECK_SUCCESS(m_pBackupComponents->GetWriterComponents(iWriter, &pWriter));

    	    unsigned cComponents;
    	    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
    	    VSS_ID idWriter, idInstance;
    	    CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
    	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
    		{
        		CComPtr<IVssComponent> pComponent;
        		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
        				
        		VSS_COMPONENT_TYPE ct;
        		CComBSTR bstrLogicalPath;
        		CComBSTR bstrComponentName;

        		CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        		wprintf(L"\t- %s\n", (LPWSTR)bstrComponentName);
        		    
        		CHECK_SUCCESS(m_pBackupComponents->SetBackupSucceeded (idInstance,
        							idWriter,
        							ct,
        							bstrLogicalPath,
        							bstrComponentName,
        							true));
    		}
        }
		wprintf(L"\n");
    }

    // Save the XML file, if needed
    // The contents will be needed at restore, in the InitializeForRestore method.
    if (m_pXmlFile) {
    	CComBSTR bstrXML;
    	CHECK_SUCCESS(m_pBackupComponents->SaveAsXML(&bstrXML));
    	fwprintf( m_pXmlFile, L"%s", (WCHAR*)bstrXML);
        wprintf(L"XML results written in %s\n", m_pwszXmlFile);	    
    }

	// Send the BackupComplete event
    wprintf(L"\nStarting asynchronous BackupComplete. Please wait...\n");	    
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->BackupComplete(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous BackupComplete finished.\n");	    
    pAsync = NULL;

    // Gather writer status
    GatherWriterStatus(L"after BackupComplete");
}


// Gather writera metadata and select components for backup, if needed
void CVssSampleRequestor::GatherWriterMetadata()
{
	unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	
    wprintf (L"\n---------- Gathering writer metadata ---------------\n");
	
    wprintf(L"Starting asynchronous GatherWriterMetadata. Please wait...\n");	    
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterMetadata(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous GatherWriterMetadata finished.\n");	    
    pAsync = NULL;
	
	CHECK_NOFAIL  (m_pBackupComponents->GetWriterMetadataCount (&cWriters));
    wprintf(L"Number of writers that responded: %u\n", cWriters);	    
	
	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
		CComPtr<IVssExamineWriterMetadata> pMetadata;
		
		VSS_ID          idInstance;
		VSS_ID          idInstanceT;
		VSS_ID          idWriter;
		CComBSTR        bstrWriterName;
		VSS_USAGE_TYPE  usage;
		VSS_SOURCE_TYPE source;
		unsigned        cIncludeFiles, cExcludeFiles, cComponents;
		CComBSTR        bstrPath;
		CComBSTR        bstrFilespec;
		CComBSTR        bstrAlternate;
		CComBSTR        bstrDestination;
		
		CHECK_SUCCESS (m_pBackupComponents->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
		
		CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
			&idWriter,
			&bstrWriterName,
			&usage,
			&source));
		
		wprintf (L"\n*** WriterName = %s\n\n"
			L"    WriterId   = "WSTR_GUID_FMT L"\n"
			L"    InstanceId = "WSTR_GUID_FMT L"\n"
			L"    UsageType  = %d (%s)\n"
			L"    SourceType = %d (%s)\n",
			bstrWriterName,
			GUID_PRINTF_ARG(idWriter),
			GUID_PRINTF_ARG(idInstance),
			usage,
			GetStringFromUsageType (usage),
			source,
			GetStringFromSourceType (source));
		
		CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
			&cExcludeFiles,
			&cComponents));
		
		for(unsigned i = 0; i < cIncludeFiles; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));
			PrintFiledesc(pFiledesc, L"\n    Include File");
		}
		
		
		for(i = 0; i < cExcludeFiles; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));
			PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}
		
		
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
			CComPtr<IVssWMComponent> pComponent;
			PVSSCOMPONENTINFO pInfo;
			
			CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
			CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));
			
			wprintf (L"\n"
				L"    Component %d, type = %d (%s)\n"
				L"        LogicalPath = %s\n"
				L"        Name        = %s\n"
				L"        Caption     = %s\n",
				iComponent,
				pInfo->type,
				GetStringFromComponentType (pInfo->type),
				pInfo->bstrLogicalPath,
				pInfo->bstrComponentName,
				pInfo->bstrCaption);
			
			wprintf (L"        RestoreMetadata        = %s\n"
				L"        NotifyOnBackupComplete = %s\n"
				L"        Selectable             = %s\n",
				pInfo->bRestoreMetadata        ? L"yes" : L"no",
				pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
				pInfo->bSelectable             ? L"yes" : L"no");
			
            // If specified, add this component to the backup
            // Remark: A real backup app will first get from the user the list of components to be added
			if (m_bComponentSelectionEnabled) {
        		CHECK_SUCCESS(m_pBackupComponents->AddComponent(idInstance,
    						  idWriter,
    						  pInfo->type,
    						  pInfo->bstrLogicalPath,
    						  pInfo->bstrComponentName));
        		
    			wprintf (L"        [Component %d was added to the backup]\n", iComponent);
			}
			
			for(i = 0; i < pInfo->cFileCount; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        FileGroupFile");

                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
                    AddVolumeForComponent(pFiledesc);
			}
			
			for(i = 0; i < pInfo->cDatabases; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        DatabaseFile");
				
                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
                    AddVolumeForComponent(pFiledesc);
				
			}
			
			
			for(i = 0; i < pInfo->cLogFiles; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        DatabaseLogFile");

                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
                    AddVolumeForComponent(pFiledesc);
			}
			
			pComponent->FreeComponentInfo (pInfo);
		}
		
		VSS_RESTOREMETHOD_ENUM method;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		VSS_WRITERRESTORE_ENUM writerRestore;
		unsigned cMappings;
		bool bRebootRequired;
		
		CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
			&bstrService,
			&bstrUserProcedure,
			&writerRestore,
			&bRebootRequired,
			&cMappings));
		
		wprintf (L"\n"
			L"    Restore method = %d (%s)\n"
			L"    Service        = %d\n"
			L"    User Procedure = %s\n"
			L"    WriterRestore  = %d (%s)\n"
			L"    RebootRequired = %s\n",
			method,
			GetStringFromRestoreMethod (method),
			bstrService,
			bstrUserProcedure,
			writerRestore,
			GetStringFromWriterRestoreMethod (writerRestore),
			bRebootRequired ? L"yes" : L"no");
		
		for(i = 0; i < cMappings; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));
			PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	}
		
    // Gather writer status
    GatherWriterStatus(L"after GatherWriterMetadata");

	CHECK_SUCCESS (m_pBackupComponents->FreeWriterMetadata());
}


void CVssSampleRequestor::GatherWriterStatus(
    IN  LPCWSTR wszWhen
    )
{
    unsigned cWriters;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\nGathering writer status %s... ", wszWhen);
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterStatus(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
	CHECK_NOFAIL(m_pBackupComponents->GetWriterStatusCount(&cWriters));
    wprintf (L"%d writers responded\n", cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
    	VSS_ID idInstance;
    	VSS_ID idWriter;
    	VSS_WRITER_STATE eWriterStatus;
    	CComBSTR bstrWriter;
    	HRESULT hrWriterFailure;

    	CHECK_SUCCESS(m_pBackupComponents->GetWriterStatus (iWriter,
    					     &idInstance,
    					     &idWriter,
    					     &bstrWriter,
    					     &eWriterStatus,
    					     &hrWriterFailure));

        WCHAR wszWriterFailure[MAX_TEXT_BUFFER];
        if (hrWriterFailure)
            swprintf(wszWriterFailure, L" Writer error code: %s [0x%08lx]", 
                GetStringFromFailureType(hrWriterFailure), hrWriterFailure);
        else
            wszWriterFailure[0] = L'\0';
            
    	wprintf (L"\t- %s status for writer '%s'. %s\n",
    		 GetStringFromWriterStatus(eWriterStatus), bstrWriter, wszWriterFailure);
    }
    
    m_pBackupComponents->FreeWriterStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\samples\requestor\main.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	main.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"


///////////////////////////////////////////////////////////////////////////////
// Main functions


extern "C" __cdecl wmain(int argc, WCHAR **argv)
{
    INT     nReturnCode = 0;

    try
	{
        CVssSampleRequestor requestor;

        // Parsing the command line
        // Eliminate the first argument (program name)
        requestor.ParseCommandLine( argc-1, argv+1 );

        // Initialize internal objects
        requestor.Initialize();

        // Gather writer status
        requestor.GatherWriterMetadata();

        // Create snapshot set, if needed
        requestor.CreateSnapshotSet();

        // Wait for user input
        wprintf(L"\nPress <Enter> to continue...\n");
        getwchar();

        // Complete the backup
        requestor.BackupComplete();
	}
    catch(INT nCatchedReturnCode)
	{
    	nReturnCode = nCatchedReturnCode;
	}

    return (nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\modules\wrtrshim\src\wrtrwmi.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrwmi.cpp

Abstract:

    Writer shim module for WMI Database
    
    NOTE: This module is not used/compiled anymore since WMI has its own snapshot writer.
    
Author:

    Michael C. Johnson [mikejohn]	22-Jun--2000

Revision History:

	X-7	MCJ		Michael C. Johnson		 7-Dec-2000
		235991: Remove workaround for the now re-instated WMI backup API

	X-6	MCJ		Michael C. Johnson		17-Nov-2000
		235987: Add workaround for broken WMI backup API

	X-5	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-4	MCJ		Michael C. Johnson		13-Sep-2000
		178282: Writer should only generate backup file if source 
			path is in volume list.

	X-3	MCJ		Michael C. Johnson		22-Aug-2000
		167335: Pull workaround for broken WMI backup API.
		169412: Add repository to the exclude list.

	X-2	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-1	MCJ		Michael C. Johnson		 9-Mar-2000
		Initial version based upon code originally in NtBackup.

--*/

#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <wbemcli.h>



#define APPLICATION_STRING	L"WmiDatabase"
#define COMPONENT_NAME		L"WMI Database"

#define TARGET_PATH		ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define REPOSITORY_PATH		L"%SystemRoot%\\system32\\wbem\\Repository"

DeclareStaticUnicodeString (ucsBackupFilename, L"\\WBEM.bak");



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterWMI : public CShimWriter
    {
public:
    CShimWriterWMI (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterWMI ShimWriterWMI (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterWMI = &ShimWriterWMI;




/*
**++
**
**  Routine Description:
**
**	The Terminal Services Licensing Server database snapshot
**	writer DoIdentify() function.
**
**
**  Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
**  Return Value:
**
**	Any HRESULT from adding items to backup metadata document.
**
**-- 
*/

HRESULT CShimWriterWMI::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"IVssCreateWriterMetadata::AddComponent", 
		L"CShimWriterWMI::DoIdentify");



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddFilesToFileGroup", 
		    L"CShimWriterWMI::DoIdentify");
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddExcludeFiles (REPOSITORY_PATH,
								 L"*",
								 true);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddExcludeFiles", 
		    L"CShimWriterWMI::DoIdentify");
	}


    return (hrStatus);
    } /* CShimWriterWMI::DoIdentify () */


/*
**++
**
**  Routine Description:
**
**	The WMI writer PrepareForFreeze function.  Currently all of the
**	real work for this writer happens here.
**
**
**  Arguments:
**
**	Same arguments as those passed in the PrepareForFreeze event.
**
**
**  Return Value:
**
**	Any HRESULT from string allocation or Wbem calls to create an
**	interface pointer or calls to backup through that interface.
**
**--
*/

HRESULT CShimWriterWMI::DoPrepareForSnapshot ()
    {
    HRESULT		 hrStatus            = NOERROR;
    BOOL		 bInstanceCreated    = FALSE;
    IWbemBackupRestore	*pIWbemBackupRestore = NULL ;
    UNICODE_STRING	 ucsTargetPath;
    UNICODE_STRING	 ucsSourcePath;



    StringInitialise (&ucsSourcePath);
    StringInitialise (&ucsTargetPath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
						   REPOSITORY_PATH);
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = IsPathInVolumeArray (ucsSourcePath.Buffer,
					m_ulVolumeCount,
					m_ppwszVolumeNamesArray,
					&m_bParticipateInBackup);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   ucsBackupFilename.Length);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	StringAppendString (&ucsTargetPath, &ucsBackupFilename);


	/*
	** We can be certain that we've already had a call to
	** CoInitialzeEx() in this thread, so we can just go ahead and
	** make our COM calls.
	*/
	hrStatus = CoCreateInstance (CLSID_WbemBackupRestore, 
				     NULL, 
				     CLSCTX_LOCAL_SERVER, 
				     IID_IWbemBackupRestore, 
				     (LPVOID*)&pIWbemBackupRestore);

	bInstanceCreated = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"CoCreateInstance", 
		    L"CShimWriterWMI::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = pIWbemBackupRestore->Backup (ucsTargetPath.Buffer, 
						WBEM_FLAG_BACKUP_RESTORE_DEFAULT);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IWbemBackupRestore::Backup", 
		    L"CShimWriterWMI::DoPrepareForSnapshot");
	}




    if (bInstanceCreated) pIWbemBackupRestore->Release ();

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);


    return (hrStatus);
    } /* CShimWriterWMI::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\inc\vswrtimp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Writer.h | Declaration of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

	Name		Date        Comments
	aoltean		08/18/1999  Created
	brianb		05/03/2000  Changed for new security model
	brianb		05/09/2000  fix problem with autolocks
	mikejohn	06/23/2000  Add connection for SetWriterFailure()
--*/


#ifndef __CVSS_WRITER_IMPL_H_
#define __CVSS_WRITER_IMPL_H_


// forward declarations
class CVssWriterImplStateMachine;
class CVssCreateWriterMetadata;
class CVssWriterComponents;
class IVssWriterComponentsInt;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCWRMPH"
//
////////////////////////////////////////////////////////////////////////


// implementation class for writers
class IVssWriterImpl : public IVssWriter
	{
public:
	// initialize writer
	virtual void Initialize
		(
		VSS_ID writerId,
		LPCWSTR wszWriterName,
		VSS_USAGE_TYPE ut,
		VSS_SOURCE_TYPE st,
		VSS_APPLICATION_LEVEL nLevel,
		DWORD dwTimeout
		) = 0;

    // subscribe to events
	virtual void Subscribe
		(
		) = 0;

    // unsubscribe from events
	virtual void Unsubscribe
		(
		) = 0;

    // get array of volume names
	virtual LPCWSTR *GetCurrentVolumeArray() const = 0;

	// get # of volumes in volume array
	virtual UINT GetCurrentVolumeCount() const = 0;

	// get id of snapshot set
	virtual VSS_ID GetCurrentSnapshotSetId() const = 0;

	// determine which Freeze event writer responds to
	virtual VSS_APPLICATION_LEVEL GetCurrentLevel() const = 0;

	// determine if path is included in the snapshot
	virtual bool IsPathAffected(IN LPCWSTR wszPath) const = 0;

	// determine if bootable state is backed up
	virtual bool IsBootableSystemStateBackedUp() const = 0;

	// determine if the backup application is selecting components
	virtual bool AreComponentsSelected() const = 0;

	// determine the backup type for the backup
	virtual VSS_BACKUP_TYPE GetBackupType() const = 0;

	// let writer pass back indication of reason for failure
    virtual HRESULT SetWriterFailure(HRESULT hr) = 0;

	// determine if requestor support partial file backups
	virtual bool IsPartialFileSupportEnabled() const = 0;
	};

typedef enum VSS_OPERATION
	{
	VSS_IN_IDENTIFY,
	VSS_IN_PREPAREBACKUP,
	VSS_IN_PREPARESNAPSHOT,
	VSS_IN_FREEZE,
	VSS_IN_THAW,
	VSS_IN_POSTSNAPSHOT,
	VSS_IN_BACKUPCOMPLETE,
	VSS_IN_PRERESTORE,
	VSS_IN_POSTRESTORE
	};


// writer state structure.  encapsulates state of this writer for a
// specific snapshot set
typedef struct _VSWRITER_STATE
	{
	// snapshot id
	VSS_ID m_idSnapshotSet;

	// writer state
	VSS_WRITER_STATE m_state;

	// reason for writer failure
	HRESULT m_hrWriterFailure;

	// are we currently in an operation
	bool m_bInOperation;

	// current operation
	VSS_OPERATION m_currentOperation;

	} VSWRITER_STATE;



// writer state class.  encapsulates all aspects of a writer's state
class CVssWriterState
	{
public:
	// constructors and destructors
	CVssWriterState();

	// initialization function
	void Initialize()
		{
		m_cs.Init();
		}


	// get state for a snapshot set
    void GetStateForSnapshot
		(
		IN const VSS_ID &idSnapshot,
		OUT VSWRITER_STATE &state,
		OUT bool &bFailedAtIdentify
		);

	// initialize a snapshot
    void InitializeCurrentState(IN const VSS_ID &idSnapshot);

	// indicate we are in an operation
	void SetInOperation(VSS_OPERATION operation)
		{
		m_cs.Lock();
		m_currentState.m_bInOperation = true;
		m_currentState.m_currentOperation = operation;
		m_cs.Unlock();
		}

    // are we in a restore operation
    bool IsInRestore()
        {
        m_cs.Lock();
        bool bInRestore = m_currentState.m_currentOperation == VSS_IN_PRERESTORE ||
                     m_currentState.m_currentOperation == VSS_IN_POSTRESTORE;

        m_cs.Unlock();
        return bInRestore;
        }

	// indicate that we are leaving an operation
	void ExitOperation()
		{
		m_cs.Lock();
		m_currentState.m_bInOperation = false;
		m_cs.Unlock();
		}

	// push the current state onto the recent snapshot set stack
	void PushCurrentState();

	// set the current state
	void SetCurrentState(IN VSS_WRITER_STATE state)
		{
		m_cs.Lock();
		m_currentState.m_state = state;
		m_cs.Unlock();
		}

	// get current state
	VSS_WRITER_STATE GetCurrentState()
		{
		VSS_WRITER_STATE state;

		m_cs.Lock();
		state = m_currentState.m_state;
		m_cs.Unlock();
		return state;
		}

	// set current failure
	void SetCurrentFailure(IN HRESULT hrWriterFailure)
		{
		m_cs.Lock();
		m_currentState.m_hrWriterFailure = hrWriterFailure;
		m_cs.Unlock();
		}

	// obtain the current failure
	HRESULT GetCurrentFailure()
		{
		HRESULT hrFailure;

		m_cs.Lock();
		hrFailure = m_currentState.m_hrWriterFailure;
		m_cs.Unlock();
		return hrFailure;
		}


	// indicate that the writer failed during its last Identify operation
	void SetFailedAtIdentify(bool bFailedAtIdentify)
		{
		m_cs.Lock();
		m_bFailedAtIdentify = bFailedAtIdentify;
		m_cs.Unlock();
		}

	// determine if writer failed during its last identify operation
	bool GetFailedAtIdentify()
		{
		m_cs.Lock();
		bool bFailedAtIdentify = m_bFailedAtIdentify;
		m_cs.Unlock();

		return bFailedAtIdentify;
		}

	// handle backup complete state transition to being stable
	void FinishBackupComplete(const VSS_ID &id);

	// indicate that backup complete failed
	void SetBackupCompleteStatus(const VSS_ID &id, HRESULT hr);


	// determine if a snapshot set id is in the cache of previous
	// snapshot sets
	bool CVssWriterState::IsSnapshotSetIdValid(VSS_ID &id)
		{
		m_cs.Lock();
		INT nPrevious = SearchForPreviousSequence(id);
		m_cs.Unlock();
		
		return nPrevious != INVALID_SEQUENCE_INDEX;
		}

	// set a failure in the case where a writer is returning a
	// no response error.  It first checks to see if we are still
	// in the operation.  If not, then we need to retry obtaining
	// the writer's state
	bool SetNoResponseFailure(const VSWRITER_STATE &state);


private:
	// search for a previous state
    INT SearchForPreviousSequence(IN const VSS_ID& idSnapshotSet) const;

	// critical section protecting class
	CVssSafeCriticalSection m_cs;

	// current state
	VSWRITER_STATE m_currentState;

	// structures to keep track of writer status from previous snapshots
	enum
		{
		MAX_PREVIOUS_SNAPSHOTS = 8,
		INVALID_SEQUENCE_INDEX = -1
		};

	// previous states
    VSWRITER_STATE m_rgPreviousStates[MAX_PREVIOUS_SNAPSHOTS];

	// current slot for dumping a previous snapshots result
	UINT m_iPreviousSnapshots;

	// FALSE if an previous OnIdentify failed
	// TRUE if OnIdentify succeeded or was not called at all
	bool m_bFailedAtIdentify;

	// are we currently in a sequence
	bool m_bSequenceInProgress;
	};





/////////////////////////////////////////////////////////////////////////////
// CVssWriterImpl


class ATL_NO_VTABLE CVssWriterImpl :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IVssWriterImpl
	{

public:
	friend class CVssWriterImplLock;

	// Constructors & Destructors
	CVssWriterImpl();

	~CVssWriterImpl();

// Exposed operations
public:
	// create a writer implementation for a specific writer
	static void CreateWriter
		(
		CVssWriter *pWriter,
		IVssWriterImpl **ppImpl
		);

	// set external writer object
    void SetWriter(CVssWriter *pWriter)
		{
		BS_ASSERT(pWriter);
		m_pWriter = pWriter;
		}

	// initialize class
	void Initialize
		(
		IN VSS_ID WriterID,
		IN LPCWSTR wszWriterName,
		IN VSS_USAGE_TYPE ut,
		IN VSS_SOURCE_TYPE st,
		IN VSS_APPLICATION_LEVEL nLevel,
		IN DWORD dwTimeoutFreeze
		);

    // subscribe to writer events
	void Subscribe
		(
		);

	// unsubscribe from writer events
	void Unsubscribe
		(
		);

    // get array of volume names
	LPCWSTR* GetCurrentVolumeArray() const { return (LPCWSTR *) m_ppwszVolumesArray; };

	// get count of volumes in array
	UINT GetCurrentVolumeCount() const { return m_nVolumesCount; };

	// get id of snapshot
	VSS_ID GetCurrentSnapshotSetId() const { return m_CurrentSnapshotSetId; };

	// get level at which freeze takes place
	VSS_APPLICATION_LEVEL GetCurrentLevel() const { return m_nLevel; };

	// determine if path is included in the snapshot
	bool IsPathAffected(IN	LPCWSTR wszPath) const;

	// determine if the backup is including bootable system state
	bool IsBootableSystemStateBackedUp() const
		{ return m_bBootableSystemStateBackup ? true : false; }

    // determine if the backup selects components
	bool AreComponentsSelected() const
		{ return m_bComponentsSelected ? true : false; }

	// return the type of backup
	VSS_BACKUP_TYPE GetBackupType() const { return m_backupType; }

	// indicate why the writer failed
	HRESULT SetWriterFailure(HRESULT hr);

	// does requestor support partial file backups and restores
	bool IsPartialFileSupportEnabled() const
		{
		return m_bPartialFileSupport ? true : false;
		}

// IVssWriter ovverides
public:

BEGIN_COM_MAP(CVssWriterImpl)
	COM_INTERFACE_ENTRY(IVssWriter)
END_COM_MAP()

	// request WRITER_METADATA or writer state
    STDMETHOD(RequestWriterInfo)(
        IN  	BSTR bstrSnapshotSetId,
		IN  	BOOL bWriterMetadata,
		IN  	BOOL bWriterState,
		IN  	IDispatch* pWriterCallback		
        );

    // prepare for backup event
    STDMETHOD(PrepareForBackup)(
        IN  	BSTR bstrSnapshotSetId,					
		IN  	IDispatch* pWriterCallback
        );

	// prepare for snapshot event
    STDMETHOD(PrepareForSnapshot)(
        IN  	BSTR bstrSnapshotSetId,					
        IN  	BSTR VolumeNamesList
        );

    // freeze event
    STDMETHOD(Freeze)(
        IN      BSTR bstrSnapshotSetId,
        IN      INT nApplicationLevel
        );

    // thaw event
    STDMETHOD(Thaw)(
        IN      BSTR bstrSnapshotSetId
        );

    STDMETHOD(PostSnapshot)(
		IN		BSTR bstrSnapshotSetId,
		IN		IDispatch *pWriterCallback
		);

    // backup complete event
    STDMETHOD(BackupComplete)(
        IN      BSTR bstrSnapshotSetId,
		IN  	IDispatch* pWriterCallback
        );

    // abort event
    STDMETHOD(Abort)(
        IN      BSTR bstrSnapshotSetId
        );

    STDMETHOD(PreRestore)(
		IN  	IDispatch* pWriterCallback
        );

    STDMETHOD(PostRestore)(
		IN  	IDispatch* pWriterCallback
        );



// Implementation - methods
private:
	enum VSS_EVENT_MASK
		{
		VSS_EVENT_PREPAREBACKUP		= 0x00000001,
		VSS_EVENT_PREPARESNAPSHOT	= 0x00000002,
		VSS_EVENT_FREEZE			= 0x00000004,
		VSS_EVENT_THAW				= 0x00000008,
		VSS_EVENT_POST_SNAPSHOT		= 0x00000010,
		VSS_EVENT_ABORT				= 0x00000020,
		VSS_EVENT_BACKUPCOMPLETE	= 0x00000040,
		VSS_EVENT_REQUESTINFO		= 0x00000080,
		VSS_EVENT_PRERESTORE		= 0x00000100,
		VSS_EVENT_POSTRESTORE		= 0x00000200,
		VSS_EVENT_ALL				= 0x3ff,
		};

    // get WRITER callback from IDispatch
	void GetCallback
		(
		IN IDispatch *pWriterCallback,
		OUT IVssWriterCallback **ppCallback,
    	IN BOOL bAllowImpersonate = FALSE	
		);

    // reset state machine
	void ResetSequence
		(
		IN bool bCalledFromTimerThread
		);

    // abort the current snapshot sequence
	void DoAbort
		(
		IN bool bCalledFromTimerThread
		);

    // obtain components for this writer
    void InternalGetWriterComponents
		(
		IN IVssWriterCallback *pCallback,
		OUT IVssWriterComponentsInt **ppWriter,
		IN bool bWriteable
		);

    void SaveChangedComponents
		(
		IN IVssWriterCallback *pCallback,
		IN IVssWriterComponentsInt *pComponents
		);

    // create WRITER_METADATA XML document
	CVssCreateWriterMetadata *CreateBasicWriterMetadata();

	// startup routine for timer thread
    static DWORD StartTimerThread(void *pv);

	// function to run in timer thread
	void TimerFunc(VSS_ID id);

	// enter a state
	bool EnterState
		(
		IN const CVssWriterImplStateMachine &vwsm,
		IN BSTR bstrSnapshotSetId
		) throw(HRESULT);

	// leave a state
	void LeaveState
		(
		IN const CVssWriterImplStateMachine &vwsm,
		IN bool fSuccessful
		);

    // create a Handle to an event
    void SetupEvent
		(
		IN HANDLE *phevt
		) throw(HRESULT);

    // begin a sequence to create a snapshot
    void BeginSequence
		(
		IN CVssID &SnapshotSetId
		) throw(HRESULT);


    // terminate timer thread
	void TerminateTimerThread();

	// lock critical section
	inline void Lock()
		{
		m_cs.Lock();
		m_bLocked = true;
		}

	// unlock critical section
	inline void Unlock()
		{
		m_bLocked = false;
		m_cs.Unlock();
		}

	// assert that critical section is locked
	inline void AssertLocked()
		{
		BS_ASSERT(m_bLocked);
		}

// Implementation - members
private:
    enum VSS_TIMER_COMMAND
        {
        VSS_TC_UNDEFINED,
		VSS_TC_ABORT_CURRENT_SEQUENCE,
        VSS_TC_TERMINATE_THREAD,
		VSS_TIMEOUT_FREEZE = 60*1000,			// 30 seconds
		VSS_STACK_SIZE = 256 * 1024			// 256K
        };

    enum
		{
		x_MAX_SUBSCRIPTIONS = 32
		};



	// data related to writer

	// writer class id
	VSS_ID m_WriterID;

	// writer instance id
	VSS_ID m_InstanceID;

	// usage type for writer
	VSS_USAGE_TYPE m_usage;

	// data source type for writer
	VSS_SOURCE_TYPE m_source;

	// writer name
	LPWSTR m_wszWriterName;

	// Data related to the current sequence

	// snapshot set id
	VSS_ID m_CurrentSnapshotSetId;

	// volume array list passed in as a string
	LPWSTR m_pwszLocalVolumeNameList;

	// # of volumes in volume array
	INT m_nVolumesCount;

	// volume array
	LPWSTR* m_ppwszVolumesArray;

	// pointer to writer callback
	CComPtr<IVssWriterCallback> m_pWriterCallback;

	// Subscription-related data
	CComBSTR m_bstrSubscriptionName;

	// actual subscription ids
	CComBSTR m_rgbstrSubscriptionId[x_MAX_SUBSCRIPTIONS];

	// number of allocated subscription ids
	UINT m_cbstrSubscriptionId;
	
	// Data related with the Writer object

	// which freeze event is handled
	VSS_APPLICATION_LEVEL m_nLevel;

	// what events are subscribed to
	DWORD m_dwEventMask;

	// count of subscriptions
	INT m_nSubscriptionsCount;

	// Critical section or avoiding race between tasks
	CVssSafeCriticalSection				m_cs;

	// was critical section initialized
	bool m_bLockCreated;

	// flag indicating if critical section is locked
	bool m_bLocked;

    // timeout and queuing mechanisms
    HANDLE m_hevtTimerThread;       // event used to signal timer thread if timer is aborted
    HANDLE m_hmtxTimerThread;  		// mutex used to guarantee only one timer thread exists at a time
	HANDLE m_hThreadTimerThread;	// handle to timer thread
	VSS_TIMER_COMMAND m_command;	// timer command when it exits the wait
	DWORD m_dwTimeoutFreeze;		// timeout for freeze

	// actual writer implementation
	CVssWriter *m_pWriter;


	// state of backup components
	BOOL m_bBootableSystemStateBackup;
	BOOL m_bComponentsSelected;
	VSS_BACKUP_TYPE m_backupType;
	BOOL m_bPartialFileSupport;


	// state of writer
	CVssWriterState m_writerstate;

    // TRUE if an OnPrepareForBackup/Freeze/Thaw
    // was sent and without a corresponding OnAbort
	bool m_bOnAbortPermitted;

	// is a sequence in progress
	bool m_bSequenceInProgress;
	};


// auto class for locks
class CVssWriterImplLock
	{
public:
	CVssWriterImplLock(CVssWriterImpl *pImpl) :
		m_pImpl(pImpl)
		{
		m_pImpl->Lock();
		}

	~CVssWriterImplLock()
		{
		m_pImpl->Unlock();
		}

private:
	CVssWriterImpl *m_pImpl;
	};




#endif //__CVSS_WRITER_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\samples\requestor\vsreq.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    vsreq.h
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>


///////////////////////////////////////////////////////////////////////////////
// Useful macros 

#define WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]


// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        m_hr = Call;                                                                                    \
        if (m_hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, m_hr, GetStringFromFailureType(m_hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        m_hr = Call;                                                                                    \
        if (FAILED(m_hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, m_hr, GetStringFromFailureType(m_hr));                       \
    }


///////////////////////////////////////////////////////////////////////////////
// Constants

const MAX_VOLUMES       = 64;
const MAX_TEXT_BUFFER   = 512;


///////////////////////////////////////////////////////////////////////////////
// Main class


class CVssSampleRequestor
{
// Constructors& destructors
public:
    CVssSampleRequestor();
    ~CVssSampleRequestor();

// Attributes
public:

// Operations
public:

    // Initialize internal members
    void Initialize();

    // Parse command line arguments 
    void ParseCommandLine(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        );

    // Creates a snapshot set
    void CreateSnapshotSet();

    // Completes the backup
    void BackupComplete();

    void GatherWriterMetadata();

    void GatherWriterStatus(
        IN  LPCWSTR wszWhen
        );

// Private methods:
private:
    LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType);
    LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType);
    LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod);
    LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod);
    LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType);
    LPCWSTR GetStringFromFailureType (HRESULT hrStatus);
    LPCWSTR GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus);

    void PrintUsage();
    void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
    void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription);

    void AddVolumeForComponent( IN IVssWMFiledesc* pFileDesc );
    bool AddVolume( IN WCHAR* pwszVolume, OUT bool & bAdded );

// Implementation
private:
    CComPtr<IVssBackupComponents>   m_pBackupComponents;
    bool        m_bCoInitializeSucceeded;
    bool        m_bBootableSystemState;
    bool        m_bComponentSelectionEnabled;
    INT         m_nVolumesCount;
    WCHAR*      m_ppwszVolumesList[MAX_VOLUMES];
    WCHAR*      m_ppwszVolumeNamesList[MAX_VOLUMES];
    HRESULT     m_hr;
    bool        m_bMetadataGathered;
    WCHAR*      m_pwszXmlFile;
    FILE*       m_pXmlFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\cmxml.c ===
WCHAR g_ComponentMetadataXML[] = 
{L'<', L'r', L'o', L'o', L't', L'>', L'\n', L'<', L'S', L'c', 
L'h', L'e', L'm', L'a', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'V', L's', L's', L'C', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'M', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'"', L' ', L'x', L'm', L'l', L'n', L's', L'=', L'"', 
L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', 
L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', 
L't', L'-', L'c', L'o', L'm', L':', L'x', L'm', L'l', L'-', 
L'd', L'a', L't', L'a', L'"', L' ', L'x', L'm', L'l', L'n', 
L's', L':', L'd', L't', L'=', L'"', L'u', L'r', L'n', L':', 
L's', L'c', L'h', L'e', L'm', L'a', L's', L'-', L'm', L'i', 
L'c', L'r', L'o', L's', L'o', L'f', L't', L'-', L'c', L'o', 
L'm', L':', L'd', L'a', L't', L'a', L't', L'y', L'p', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'F', L'i', L'l', L'e', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'C', L'a', L'n', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'e', L' ', L'w', L'i', L'l', L'd', L'c', L'a', 
L'r', L'd', L' ', L'c', L'h', L'a', L'r', L'a', L'c', L't', 
L'e', L'r', L's', L' ', L'?', L' ', L'a', L'n', L'd', L' ', 
L'*', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'p', L'a', L't', L'h', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'P', L'a', L't', L'h', L' ', L't', L'o', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L'.', L' ', L' ', 
L'T', L'h', L'e', L' ', L'p', L'a', L't', L'h', L' ', L'c', 
L'a', L'n', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', 
L' ', L'e', L'n', L'v', L'i', L'r', L'o', L'n', L'm', L'e', 
L'n', L't', L' ', L'v', L'a', L'r', L'i', L'a', L'b', L'l', 
L'e', L's', L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', 
L'v', L'a', L'l', L'u', L'e', L's', L' ', L'e', L'x', L't', 
L'r', L'a', L'c', L't', L'e', L'd', L' ', L'f', L'r', L'o', 
L'm', L' ', L'r', L'e', L'g', L'i', L's', L't', L'r', L'y', 
L' ', L'k', L'e', L'y', L's', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', 
L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'I', L's', L' ', L'p', L'a', 
L't', L'h', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L' ', L'r', L'e', L'c', L'u', L'r', L's', L'i', 
L'v', L'e', L' ', L'o', L'r', L' ', L'l', L'i', L'm', L'i', 
L't', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L' ', L'd', L'i', L'r', L'e', L'c', L't', L'o', L'r', L'y', 
L' ', L't', L'h', L'a', L't', L' ', L'i', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'e', L'd', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', 
L'P', L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'A', 
L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'p', 
L'a', L't', L'h', L' ', L'i', L'n', L' ', L'w', L'h', L'i', 
L'c', L'h', L' ', L't', L'o', L' ', L'f', L'i', L'n', L'd', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L'.', 
L' ', L' ', L'F', L'i', L'l', L'e', L's', L' ', L'i', L'n', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L' ', L'm', L'a', L'y', L'\r', L'\n', L' ', 
L' ', L' ', L'h', L'a', L'v', L'e', L' ', L'b', L'e', L'e', 
L'n', L' ', L'c', L'o', L'p', L'i', L'e', L'd', L' ', L't', 
L'o', L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'i', L'v', L'e', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L'b', L'y', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'.', 
L' ', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L'\r', L'\n', L' ', L' ', L' ', 
L'p', L'i', L'c', L'k', L' ', L'u', L'p', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'f', L'r', 
L'o', L'm', L' ', L't', L'h', L'e', L' ', L'a', L'l', L't', 
L'e', L'r', L'n', L'a', L't', L'i', L'v', L'e', L' ', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'i', L'n', 
L's', L't', L'e', L'a', L'd', L' ', L'o', L'f', L' ', L't', 
L'h', L'e', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L' ', L'b', L'u', L't', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L'i', L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', 
L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'L', L'o', 
L'g', L'i', L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', 
L' ', L'f', L'o', L'r', L' ', L'a', L' ', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', 
L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', L'p', L'.', 
L' ', L' ', L'T', L'h', L'i', L's', L' ', L'l', L'o', L'g', 
L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', L' ', 
L'u', L's', L'e', L's', L' ', L'b', L'a', L'c', L'k', L's', 
L'l', L'a', L's', L'h', L'\r', L'\n', L' ', L' ', L' ', L'a', 
L's', L' ', L's', L'e', L'p', L'a', L'r', L'a', L't', L'o', 
L'r', L's', L' ', L't', L'o', L' ', L'f', L'o', L'r', L'm', 
L' ', L'a', L' ', L'l', L'o', L'g', L'i', L'c', L'a', L'l', 
L' ', L'n', L'a', L'm', L'e', L's', L'p', L'a', L'c', L'e', 
L' ', L'h', L'i', L'e', L'r', L'a', L'r', L'c', L'h', L'y', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L'N', L'a', L'm', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'N', L'a', L'm', L'e', L' ', L'u', L's', L'e', L'd', 
L' ', L't', L'o', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'y', L' ', L'a', L' ', L'd', L'a', L't', L'a', L'b', 
L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L'.', L' ', L' ', 
L'M', L'a', L'y', L' ', L'b', L'e', L' ', L'q', L'u', L'a', 
L'l', L'i', L'f', L'i', L'e', L'd', L' ', L'b', L'y', L' ', 
L'a', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'1', L'.', L'0', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'V', L'e', L'r', L's', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'a', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'd', L'o', L'c', 
L'u', L'm', L'e', L'n', L't', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'w', L'r', L'i', 
L't', L'e', L'r', L'I', L'd', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'U', 
L'n', L'i', L'q', L'u', L'e', L' ', L'i', L'd', L' ', L't', 
L'o', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L'.', L' ', L' ', L'N', L'o', L't', L'e', L' ', L't', 
L'h', L'a', L't', L' ', L't', L'h', L'i', L's', L' ', L'i', 
L'd', L'e', L'n', L't', L'i', L'f', L'i', L'e', L's', L' ', 
L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'c', L'l', L'a', L's', L's', 
L' ', L'r', L'a', L't', L'h', L'e', L'r', L' ', L't', L'h', 
L'a', L'n', L' ', L'a', L' ', L's', L'p', L'e', L'c', L'i', 
L'f', L'i', L'c', L' ', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'i', 
L'n', L's', L't', L'a', L'n', L'c', L'e', L'I', L'd', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L'u', L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'U', L'n', L'i', L'q', L'u', L'e', L' ', L'i', 
L'd', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', 
L'i', L'n', L'g', L' ', L't', L'h', L'e', L' ', L'i', L'n', 
L's', L't', L'a', L'n', L'c', L'e', L' ', L'o', L'f', L' ', 
L'a', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'd', 
L'u', L'r', L'i', L'n', L'g', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L'.', L' ', L' ', L'I', L't', L'\r', L'\n', L' ', 
L' ', L' ', L'h', L'a', L's', L' ', L'n', L'o', L' ', L'm', 
L'e', L'a', L'n', L'i', L'n', L'g', L' ', L'd', L'u', L'r', 
L'i', L'n', L'g', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'C', 
L'O', L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'S', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', 
L'e', L'd', L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', 
L'"', L'm', L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'C', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', L' ', 
L't', L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', L'b', 
L'a', L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L'o', 
L'r', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L'U', L's', L'e', L'd', 
L' ', L't', L'o', L' ', L'c', L'o', L'm', L'm', L'u', L'n', 
L'i', L'c', L'a', L't', L'e', L' ', L'b', L'e', L't', L'w', 
L'e', L'e', L'n', L' ', L't', L'h', L'e', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'a', L'n', L'd', L' ', L't', 
L'h', L'e', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L'\r', L'\n', 
L' ', L' ', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'n', L'd', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'C', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L's', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', 
L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'D', L'o', L'e', L's', L' ', L't', 
L'h', L'e', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L's', L'e', L'l', L'e', L'c', L't', L' ', L'i', 
L'n', L'd', L'i', L'v', L'i', L'd', L'u', L'a', L'l', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', 
L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'd', L'o', L'e', L's', L' ', L'i', L't', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'e', L'n', L't', L'i', 
L'r', L'e', L' ', L'v', L'o', L'l', L'u', L'm', L'e', L's', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', L'o', L'o', 
L't', L'a', L'b', L'l', L'e', L'S', L'y', L's', L't', L'e', 
L'm', L'S', L't', L'a', L't', L'e', L'B', L'a', L'c', L'k', 
L'u', L'p', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', 
L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'I', L's', L' ', L'b', L'a', L'c', 
L'k', L'u', L'p', L' ', L's', L'a', L'v', L'i', L'n', L'g', 
L' ', L't', L'h', L'e', L' ', L'b', L'o', L'o', L't', L'a', 
L'b', L'l', L'e', L' ', L's', L't', L'a', L't', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L's', L'y', L's', 
L't', L'e', L'm', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'b', L'a', L'c', L'k', L'u', L'p', L'T', L'y', L'p', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'f', L'u', L'l', L'l', 
L' ', L'd', L'i', L'f', L'f', L'e', L'r', L'e', L'n', L't', 
L'i', L'a', L'l', L' ', L'i', L'n', L'c', L'r', L'e', L'm', 
L'e', L'n', L't', L'a', L'l', L' ', L'l', L'o', L'g', L' ', 
L'o', L't', L'h', L'e', L'r', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'T', L'y', 
L'p', L'e', L' ', L'o', L'f', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L' ', L'b', L'e', L'i', L'n', L'g', L' ', L'p', 
L'e', L'r', L'f', L'o', L'r', L'm', L'e', L'd', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'a', L'r', L't', 
L'i', L'a', L'l', L'F', L'i', L'l', L'e', L'S', L'u', L'p', 
L'p', L'o', L'r', L't', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', 
L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', 
L'e', L's', L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', 
L'a', L'u', L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'I', L'n', L'd', 
L'i', L'c', L'a', L't', L'e', L's', L' ', L'w', L'h', L'e', 
L't', L'h', L'e', L'r', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L'q', L'u', L'e', L's', L't', L'o', L'r', L' ', L'i', 
L's', L' ', L'c', L'a', L'p', L'a', L'b', L'l', L'e', L' ', 
L'o', L'f', L' ', L'b', L'a', L'c', L'k', L'i', L'n', L'g', 
L' ', L'u', L'p', L' ', L'a', L'n', L'd', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'i', L'n', L'g', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'p', L'o', L'r', L't', 
L'i', L'o', L'n', L's', L' ', L'o', L'f', L' ', L'f', L'i', 
L'l', L'e', L's', L'.', L' ', L' ', L'I', L'f', L' ', L'n', 
L'o', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', 
L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'n', L'e', L'v', L'e', 
L'r', L' ', L'g', L'e', L'n', L'e', L'r', L'a', L't', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'P', 
L'A', L'R', L'T', L'I', L'A', L'L', L'_', L'F', L'I', L'L', 
L'E', L' ', L'o', L'r', L' ', L'D', L'I', L'R', L'E', L'C', 
L'T', L'E', L'D', L'_', L'R', L'E', L'S', L'T', L'O', L'R', 
L'E', L' ', L'e', L'l', L'e', L'm', L'e', L'n', L't', L's', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'O', L'n', L'l', L'y', L' ', L'e', L'n', L't', L'i', L'r', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'c', L'a', 
L'n', L' ', L'b', L'e', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L'o', L'r', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'd', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', L'C', L'o', 
L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'b', L'o', L'o', L't', L'a', L'b', L'l', L'e', 
L'S', L'y', L's', L't', L'e', L'm', L'S', L't', L'a', L't', 
L'e', L'B', L'a', L'c', L'k', L'u', L'p', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'b', L'a', L'c', L'k', L'u', L'p', L'T', L'y', L'p', 
L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'p', L'a', L'r', L't', L'i', 
L'a', L'l', L'F', L'i', L'l', L'e', L'S', L'u', L'p', L'p', 
L'o', L'r', L't', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'W', L'R', L'I', L'T', L'E', 
L'R', L'_', L'C', L'O', L'M', L'P', L'O', L'N', L'E', L'N', 
L'T', L'S', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'S', L'N', L'A', L'P', L'S', L'H', 
L'O', L'T', L'_', L'S', L'E', L'T', L'_', L'D', L'E', L'S', 
L'C', L'R', L'I', L'P', L'T', L'I', L'O', L'N', L'"', L' ', 
L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', 
L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'W', L'R', 
L'I', L'T', L'E', L'R', L'_', L'C', L'O', L'M', L'P', L'O', 
L'N', L'E', L'N', L'T', L'S', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'C', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L's', L' ', L't', L'h', L'a', L't', 
L' ', L'a', L'r', L'e', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L'a', L'n', L'd', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', L'h', 
L'a', L't', L' ', L'a', L'r', L'e', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L'a', L'\r', L'\n', L' ', L' ', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'i', L'n', L's', L't', L'a', 
L'n', L'c', L'e', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', 
L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', 
L'n', L'c', L'e', L'I', L'd', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'C', L'O', L'M', 
L'P', L'O', L'N', L'E', L'N', L'T', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'C', L'O', 
L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'"', L' ', L'c', 
L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', 
L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', 
L'e', L'l', L'=', L'"', L'o', L'p', L'e', L'n', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', L'a', 
L'c', L'k', L'u', L'p', L'S', L'u', L'c', L'c', L'e', L'e', 
L'd', L'e', L'd', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', 
L's', L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', 
L'u', L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L'I', L'n', L'd', L'i', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'w', 
L'h', L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', L'e', 
L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', 
L' ', L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L's', L'u', L'c', L'c', L'e', 
L's', L's', L'f', L'u', L'l', L'l', L'y', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L'o', L'r', L' ', L'n', L'o', 
L't', L'.', L' ', L' ', L'T', L'h', L'i', L's', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L's', 
L'e', L't', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L' ', 
L't', L'h', L'e', L' ', L'B', L'a', L'c', L'k', L'u', L'p', 
L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', L' ', L'n', 
L'o', L't', L'i', L'f', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'c', L'o', 
L'm', L'p', L'o', L'n', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'd', L'a', L't', L'a', 
L'b', L'a', L's', L'e', L' ', L'f', L'i', L'l', L'e', L'g', 
L'r', L'o', L'u', L'p', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'I', L'n', L'd', L'i', L'c', L'a', L't', 
L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'w', L'h', L'e', 
L't', L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L' ', L'i', L's', L' ', L'd', L'a', 
L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', L' ', 
L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', L'p', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', L'a', 
L'c', L'k', L'u', L'p', L'S', L't', L'a', L'm', L'p', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', 
L'h', L'i', L's', L' ', L's', L't', L'r', L'i', L'n', L'g', 
L' ', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L'c', L'o', L'n', L't', L'a', L'i', L'n', L's', L' ', 
L't', L'h', L'e', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'i', L'e', L'r', L' ', L'a', L's', L's', L'i', L'g', 
L'n', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'b', L'y', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'.', 
L' ', L' ', L'T', L'h', L'e', L' ', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L'i', L's', L' ', L's', 
L'e', L't', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L' ', L'e', L'i', L't', 
L'h', L'e', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L' ', L't', 
L'h', L'e', L' ', L'P', L'r', L'e', L'p', L'a', L'r', L'e', 
L'B', L'a', L'c', L'k', L'u', L'p', L' ', L'o', L'r', L' ', 
L'P', L'o', L's', L't', L'S', L'n', L'a', L'p', L's', L'h', 
L'o', L't', L' ', L'e', L'v', L'e', L'n', L't', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'r', L'e', 
L'v', L'i', L'o', L'u', L's', L'B', L'a', L'c', L'k', L'u', 
L'p', L'S', L't', L'a', L'm', L'p', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', 
L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'I', L'n', L' ', L't', 
L'h', L'e', L' ', L'c', L'a', L's', L'e', L' ', L'o', L'f', 
L' ', L'a', L'n', L' ', L'i', L'n', L'c', L'r', L'e', L'm', 
L'e', L'n', L't', L'a', L'l', L' ', L'o', L'r', L' ', L'd', 
L'i', L'f', L'f', L'e', L'r', L'e', L'n', L't', L'i', L'a', 
L'l', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L',', L' ', 
L't', L'h', L'i', L's', L' ', L'i', L'd', L'e', L'n', L't', 
L'i', L'f', L'i', L'e', L's', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L't', L'h', L'e', L' ', L'b', L'a', 
L'c', L'k', L'u', L'p', L' ', L'f', L'r', L'o', L'm', L' ', 
L'w', L'h', L'i', L'c', L'h', L' ', L'd', L'i', L'f', L'f', 
L'e', L'r', L'e', L'n', L'c', L'e', L's', L' ', L'a', L'r', 
L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'u', L't', L'e', 
L'd', L'.', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'i', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L's', L'e', L't', L' ', L'b', L'y', L' ', L't', L'h', L'e', 
L' ', L'r', L'e', L'q', L'u', L'e', L's', L't', L'o', L'r', 
L' ', L'p', L'r', L'i', L'o', L'r', L' ', L't', L'o', L' ', 
L't', L'h', L'e', L' ', L'P', L'r', L'e', L'p', L'a', L'r', 
L'e', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L'e', L'v', 
L'e', L'n', L't', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', L'e', L'd', 
L'F', L'o', L'r', L'R', L'e', L's', L't', L'o', L'r', L'e', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'y', L'e', 
L's', L'/', L'n', L'o', L' ', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L'i', L's', L' ', L's', L'e', 
L't', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L'q', L'u', L'e', L's', L't', L' ', L'p', L'r', L'i', 
L'o', L'r', L' ', L't', L'o', L' ', L'c', L'a', L'l', L'l', 
L'i', L'n', L'g', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'P', L'r', L'e', L'R', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L'a', L'n', L'd', L' ', L'i', L'n', L'd', 
L'i', L'c', L'a', L't', L'e', L's', L' ', L'w', L'h', L'e', 
L't', L'h', L'e', L'r', L' ', L't', L'h', L'e', L' ', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', L'i', 
L's', L' ', L'b', L'e', L'i', L'n', L'g', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'd', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'o', L'r', L' ', L'n', L'o', 
L't', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'a', L'd', L'd', L'i', L't', L'i', L'o', L'n', L'a', L'l', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L's', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', 
L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'T', L'h', L'i', L's', L' ', L'y', L'e', L's', L'/', 
L'n', L'o', L' ', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L'i', L's', L' ', L's', L'e', L't', L' ', 
L'b', L'y', L' ', L't', L'h', L'e', L' ', L'r', L'e', L'q', 
L'u', L'e', L's', L't', L'o', L'r', L' ', L'p', L'r', L'i', 
L'o', L'r', L' ', L't', L'o', L' ', L'c', L'a', L'l', L'l', 
L'i', L'n', L'g', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'P', L'r', L'e', L'R', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L'a', L'n', L'd', L' ', L'i', L'n', L'd', 
L'i', L'c', L'a', L't', L'e', L's', L' ', L'w', L'h', L'e', 
L't', L'h', L'e', L'r', L' ', L'a', L'd', L'd', L'i', L't', 
L'i', L'o', L'n', L'a', L'l', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L's', L' ', L'o', L'f', L' ', L't', L'h', 
L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', 
L'w', L'i', L'l', L'l', L' ', L'f', L'o', L'l', L'l', L'o', 
L'w', L' ', L'(', L'i', L'.', L'e', L'.', L',', L' ', L'u', 
L'l', L'l', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'f', L'o', L'l', L'l', L'o', L'w', L'e', L'd', L' ', 
L'b', L'y', L' ', L'l', L'o', L'g', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L's', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'T', L'a', L'r', L'g', L'e', L't', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', 
L'"', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', 
L'n', L'e', L'w', L' ', L'd', L'i', L'r', L'e', L'c', L't', 
L'e', L'd', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'e', L'd', L' ', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L'i', L's', L' ', L's', 
L'e', L't', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L' ', L'd', L'u', L'r', 
L'i', L'n', L'g', L' ', L'P', L'r', L'e', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'a', L'n', L'd', L' ', L'i', L'n', L'd', 
L'i', L'c', L'a', L't', L'e', L's', L' ', L'w', L'h', L'e', 
L't', L'h', L'e', L'r', L' ', L't', L'h', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L'f', L'o', L'r', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'b', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L't', L'o', L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', 
L'r', L'i', L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', 
L'c', L'a', L't', L'i', L'o', L'n', L',', L' ', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'l', L'o', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'(', L'a', L's', 
L' ', L'e', L'x', L'p', L'r', L'e', L's', L's', L'e', L'd', 
L' ', L'b', L'y', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', 
L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', 
L'_', L'M', L'A', L'P', L'P', L'I', L'N', L'G', L' ', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L's', L' ', L'i', L'n', 
L' ', L't', L'h', L'e', L' ', L'm', L'e', L't', L'a', L'd', 
L'a', L't', L'a', L')', L',', L' ', L'n', L'e', L'w', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'(', L'a', L's', 
L' ', L'e', L'x', L'p', L'r', L'e', L's', L's', L'e', L'd', 
L' ', L'b', L'y', L' ', L'R', L'E', L'S', L'T', L'O', L'R', 
L'E', L'_', L'T', L'A', L'R', L'G', L'E', L'T', L' ', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L's', L' ', L'c', L'r', 
L'e', L'a', L't', L'e', L'd', L' ', L'b', L'y', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L')', 
L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', 
L'e', L' ', L'p', L'a', L'r', L't', L'i', L'a', L'l', L'l', 
L'y', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', 
L' ', L'(', L'a', L's', L' ', L'e', L'x', L'p', L'r', L'e', 
L's', L's', L'e', L'd', L' ', L'b', L'y', L' ', L't', L'h', 
L'e', L' ', L'D', L'I', L'R', L'E', L'C', L'T', L'E', L'D', 
L'_', L'T', L'A', L'R', L'G', L'E', L'T', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L'c', L'r', L'e', L'a', L't', L'e', 
L'd', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'p', L'r', L'e', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'F', L'a', L'i', L'l', L'u', L'r', 
L'e', L'M', L's', L'g', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'a', 
L't', L't', L'i', L'r', L'b', L'u', L't', L'e', L' ', L'i', 
L's', L' ', L's', L'e', L't', L' ', L'b', L'y', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', 
L'd', L'u', L'r', L'i', L'n', L'g', L' ', L't', L'h', L'e', 
L' ', L'P', L'r', L'e', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'e', L'v', L'e', L'n', L't', L' ', L'i', L'f', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L't', 
L'h', L'e', L' ', L'p', L'r', L'e', L'R', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'o', L'p', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L' ', L'f', L'a', L'i', L'l', L'e', L'd', 
L' ', L'f', L'o', L'r', L' ', L's', L'o', L'm', L'e', L' ', 
L'r', L'e', L'a', L's', L'o', L'n', L'.', L' ', L' ', L'I', 
L't', L' ', L'g', L'i', L'v', L'e', L's', L' ', L'a', L' ', 
L't', L'e', L'x', L't', L'u', L'a', L'l', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'w', L'h', L'y', L' ', L't', L'h', L'e', L' ', L'p', 
L'r', L'e', L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', 
L'f', L'a', L'i', L'l', L'e', L'd', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L'd', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'n', L'o', L'n', L'e', L' ', L'a', L'l', 
L'l', L' ', L'f', L'a', L'i', L'l', L'e', L'd', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'a', 
L'l', L'l', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'T', L'h', L'i', L's', L' ', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L'i', L's', L' ', L's', 
L'e', L't', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', 
L'r', L'e', L'q', L'u', L'e', L's', L't', L'o', L'r', L' ', 
L'a', L'f', L't', L'e', L'r', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'i', L'n', L'g', L' ', L'f', L'i', L'l', L'e', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'f', L'o', L'r', L' ', L't', L'h', L'e', L' ', L'c', L'o', 
L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', L'(', L'i', 
L'.', L'e', L'.', L',', L' ', L'b', L'e', L't', L'w', L'e', 
L'e', L'n', L' ', L't', L'h', L'e', L' ', L'P', L'r', L'e', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'a', L'n', 
L'd', L' ', L'P', L'o', L's', L't', L'R', L'e', L's', L't', 
L'o', L'r', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'e', L'v', L'e', L'n', L't', L's', L')', L'.', 
L' ', L' ', L'Y', L'e', L's', L' ', L'i', L'n', L'd', L'i', 
L'c', L'a', L't', L'e', L's', L' ', L't', L'h', L'a', L't', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'w', L'e', L'r', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L' ', L's', L'u', L'c', L'c', L'e', 
L's', L's', L'f', L'u', L'l', L'l', L'y', L';', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'n', L'o', L' ', 
L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', L's', L' ', 
L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L'w', L'e', L'r', L'e', L' ', 
L'n', L'o', L't', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'd', L' ', L'a', L'n', L'd', L' ', L't', L'h', L'e', 
L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'f', L'i', L'l', L'e', L's', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'a', L'r', L'e', L' ', L'i', L'n', 
L't', L'a', L'c', L't', L';', L' ', L'f', L'a', L'i', L'l', 
L'e', L'd', L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', 
L'e', L's', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', 
L'e', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', 
L' ', L'f', L'i', L'l', L'e', L's', L' ', L'w', L'e', L'r', 
L'e', L' ', L'p', L'a', L'r', L't', L'i', L'a', L'l', L'l', 
L'y', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'o', L'v', L'e', L'r', L'w', L'r', L'i', L't', L't', L'e', 
L'n', L' ', L'a', L'n', L'd', L' ', L'a', L'r', L'e', L' ', 
L't', L'h', L'e', L'r', L'e', L'f', L'o', L'r', L'e', L' ', 
L'c', L'o', L'r', L'r', L'u', L'p', L't', L'.', L' ', L' ', 
L'N', L'o', L't', L'e', L' ', L't', L'h', L'a', L't', L' ', 
L't', L'h', L'e', L' ', L'f', L'a', L'i', L'l', L'e', L'd', 
L' ', L's', L't', L'a', L't', L'u', L's', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'c', L'a', L'n', L' ', 
L'o', L'n', L'l', L'y', L' ', L'o', L'c', L'c', L'u', L'r', 
L' ', L'i', L'n', L' ', L't', L'h', L'e', L' ', L's', L'i', 
L't', L'u', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'o', L'f', L' ', L'a', L' ', L'f', L'i', L'l', L'e', 
L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'o', L'n', L'l', 
L'y', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'p', L'a', L'r', L't', L' ', L'o', L'f', L' ', L't', L'h', 
L'e', L' ', L'd', L'a', L't', L'a', L' ', L'i', L's', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L'(', 
L'D', L'I', L'R', L'E', L'C', L'T', L'E', L'D', L'_', L'R', 
L'E', L'S', L'T', L'O', L'R', L'E', L')', L' ', L'o', L'r', 
L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'o', L'n', L'l', 
L'y', L' ', L'p', L'a', L'r', L't', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'o', L'f', L' ', L'a', L' ', 
L'f', L'i', L'l', L'e', L' ', L'i', L's', L' ', L'b', L'a', 
L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L'a', L'n', 
L'd', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', 
L' ', L'(', L'e', L'.', L'g', L'.', L',', L' ', L'a', L's', 
L' ', L'p', L'a', L'r', L't', L' ', L'o', L'f', L' ', L'a', 
L' ', L'd', L'i', L'f', L'f', L'e', L'r', L'e', L'n', L't', 
L'i', L'a', L'l', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L')', L'.', 
L' ', L' ', L'I', L'n', L' ', L't', L'h', L'e', L's', L'e', 
L' ', L'c', L'a', L's', L'e', L's', L' ', L'a', L' ', L'f', 
L'a', L'i', L'l', L'e', L'd', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'o', L'c', L'c', L'u', L'r', L's', 
L' ', L'i', L'f', L' ', L's', L'o', L'm', L'e', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'd', L'a', L't', L'a', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L't', 
L'o', L' ', L'b', L'e', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L'd', L' ', L'i', L's', L' ', L'w', L'r', L'i', 
L't', L't', L'e', L'n', L' ', L't', L'o', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L' ', L'b', L'u', L't', 
L' ', L'n', L'o', L't', L' ', L'a', L'l', L'l', L'.', L' ', 
L' ', L'I', L'n', L' ', L't', L'h', L'i', L's', L' ', L'c', 
L'a', L's', L'e', L',', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L't', L'h', L'e', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'c', L'o', L'p', L'y', 
L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', 
L'l', L'e', L' ', L'n', L'o', L' ', L'l', L'o', L'n', L'g', 
L' ', L'e', L'x', L'i', L's', L't', L's', L' ', L'a', L'n', 
L'd', L' ', L't', L'h', L'e', L' ', L'c', L'o', L'p', L'y', 
L' ', L'o', L'n', L' ', L't', L'a', L'p', L'e', L' ', L'i', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'n', L'o', L't', L' ', L'c', L'o', L'm', L'p', L'l', L'e', 
L't', L'e', L' ', L'a', L'n', L'd', L' ', L't', L'h', L'e', 
L'r', L'e', L'f', L'o', L'r', L'e', L' ', L'c', L'a', L'n', 
L'n', L'o', L't', L' ', L'b', L'e', L' ', L'u', L's', L'e', 
L'd', L' ', L't', L'o', L' ', L'c', L'r', L'e', L'a', L't', 
L'e', L' ', L'a', L' ', L'c', L'o', L'n', L's', L'i', L's', 
L't', L'e', L'n', L't', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'c', L'o', L'p', L'y', L'.', L' ', L' ', 
L'T', L'h', L'e', L' ', L'o', L'n', L'l', L'y', L' ', L'o', 
L'p', L't', L'i', L'o', L'n', L' ', L'i', L's', L' ', L't', 
L'o', L' ', L'u', L's', L'e', L' ', L'a', L' ', L'p', L'r', 
L'e', L'v', L'i', L'o', L'u', L's', L' ', L'f', L'u', L'l', 
L'l', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', L't', 
L'o', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L't', L'h', 
L'e', L' ', L'd', L'a', L't', L'a', L'.', L' ', L' ', L'N', 
L'o', L't', L'e', L' ', L't', L'h', L'a', L't', L' ', L't', 
L'h', L'e', L' ', L'"', L'f', L'a', L'i', L'l', L'e', L'd', 
L'"', L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'c', L'a', L'n', L' ', L'b', L'e', L' ', 
L'u', L's', L'e', L'd', L' ', L't', L'o', L' ', L'i', L'n', 
L'd', L'i', L'c', L'a', L't', L'e', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L't', L'h', L'a', L't', L' ', 
L's', L'o', L'm', L'e', L',', L' ', L'b', L'u', L't', L' ', 
L'n', L'o', L' ', L'a', L'l', L'l', L' ', L'o', L'f', L' ', 
L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', 
L'o', L'f', L' ', L'a', L' ', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L' ', L'w', L'e', L'r', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L'.', L' ', 
L' ', L'T', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'r', L'e', L'q', L'u', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'i', L's', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L' ', L't', L'o', L' ', L'e', 
L'i', L't', L'h', L'e', L'r', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'a', L'l', L'l', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'o', L'f', 
L' ', L'a', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'o', L'r', L' ', L'n', L'o', L'n', L'e', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L'.', L' ', L' ', L'H', L'o', L'w', L'e', L'v', L'e', 
L'r', L',', L' ', L't', L'h', L'e', L'r', L'e', L' ', L'a', 
L'r', L'e', L' ', L's', L'i', L't', L'u', L'a', L't', L'i', 
L'o', L'n', L's', L' ', L'w', L'h', L'e', L'r', L'e', L' ', 
L't', L'h', L'i', L's', L' ', L'i', L's', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'n', L'o', L't', L' ', 
L'p', L'o', L's', L's', L'i', L'b', L'l', L'e', L',', L' ', 
L'a', L'n', L'd', L' ', L't', L'h', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'a', L't', L'i', L'o', L'n', L' ', 
L'o', L'f', L' ', L'a', L' ', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L' ', L'h', L'a', L's', L' ', L'f', 
L'a', L'i', L'l', L'e', L'd', L',', L' ', L'b', L'u', L't', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'c', 
L'a', L'n', L'n', L'o', L't', L' ', L'b', L'e', L' ', L'c', 
L'o', L'm', L'p', L'l', L'e', L't', L'e', L'l', L'y', L' ', 
L'u', L'n', L'd', L'o', L'n', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'p', L'o', L's', L't', L'R', 
L'e', L's', L't', L'o', L'r', L'e', L'F', L'a', L'i', L'l', 
L'u', L'r', L'e', L'M', L's', L'g', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', 
L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'T', L'h', L'i', L's', 
L' ', L's', L't', L'r', L'i', L'n', L'g', L' ', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'i', L's', 
L' ', L's', L'e', L't', L' ', L'b', L'y', L' ', L't', L'h', 
L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'd', 
L'u', L'r', L'i', L'n', L'g', L' ', L't', L'h', L'e', L' ', 
L'P', L'o', L's', L't', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'e', L'v', L'e', L'n', L't', L'.', L' ', L' ', L'I', L't', 
L' ', L'i', L's', L' ', L'a', L' ', L't', L'e', L'x', L't', 
L' ', L'm', L'e', L's', L's', L'a', L'g', L'e', L' ', L'i', 
L'n', L'd', L'i', L'c', L'a', L't', L'i', L'n', L'g', L' ', 
L'w', L'h', L'y', L' ', L't', L'h', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'f', L'a', L'i', L'l', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'b', L'a', L'c', L'k', L'u', L'p', L'O', L'p', L't', 
L'i', L'o', L'n', L's', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'i', 
L's', L' ', L'a', L' ', L'p', L'r', L'i', L'v', L'a', L't', 
L'e', L' ', L's', L't', L'r', L'i', L'n', L'g', L' ', L'p', 
L'a', L's', L's', L'e', L'd', L' ', L'b', L'e', L't', L'w', 
L'e', L'e', L'n', L' ', L't', L'h', L'e', L' ', L'r', L'e', 
L'q', L'u', L'e', L's', L't', L'o', L'r', L' ', L'a', L'n', 
L'd', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', 
L'e', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L't', L'o', L' ', L'c', L'o', L'n', L't', L'r', L'o', 
L'l', L' ', L't', L'h', L'e', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L'.', 
L' ', L' ', L'I', L't', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L's', L'e', L't', L' ', L'b', 
L'y', L' ', L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'r', L'e', L'q', L'u', L'e', L's', 
L't', L'o', L'r', L' ', L'p', L'r', L'i', L'o', L'r', L' ', 
L't', L'o', L' ', L't', L'h', L'e', L' ', L'P', L'r', L'e', 
L'p', L'a', L'r', L'e', L'B', L'a', L'c', L'k', L'u', L'p', 
L' ', L'e', L'v', L'e', L'n', L't', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L'O', L'p', L't', L'i', L'o', L'n', L's', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', 
L'h', L'i', L's', L' ', L'i', L's', L' ', L'a', L' ', L'p', 
L'r', L'i', L'v', L'a', L't', L'e', L' ', L's', L't', L'r', 
L'i', L'n', L'g', L' ', L'p', L'a', L's', L's', L's', L'e', 
L'd', L' ', L'b', L'e', L't', L'w', L'e', L'e', L'n', L' ', 
L't', L'o', L' ', L'r', L'e', L'q', L'u', L'e', L's', L't', 
L'o', L'r', L' ', L'a', L'n', L'd', L' ', L't', L'h', L'e', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L't', L'o', L' ', L'c', 
L'o', L'n', L't', L'r', L'o', L'l', L' ', L't', L'h', L'e', 
L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'o', 
L'f', L' ', L'a', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'.', L' ', L' ', L'I', L't', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L's', 
L'e', L't', L' ', L'b', L'y', L' ', L't', L'h', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'r', L'e', 
L'q', L'u', L'e', L's', L't', L'o', L'r', L' ', L'p', L'r', 
L'i', L'o', L'r', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L' ', L'P', L'r', L'e', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'e', L'v', L'e', L'n', L't', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'l', 
L'o', L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', L'h', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'b', L'a', L'c', L'k', L'u', L'p', L'S', L'u', L'c', 
L'c', L'e', L'e', L'd', L'e', L'd', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'b', L'a', L'c', L'k', L'u', L'p', L'O', L'p', L't', L'i', 
L'o', L'n', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'O', L'p', L't', L'i', L'o', L'n', 
L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'b', L'a', L'c', L'k', L'u', 
L'p', L'S', L't', L'a', L'm', L'p', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'r', L'e', L'v', L'i', L'o', L'u', L's', L'B', L'a', 
L'c', L'k', L'u', L'p', L'S', L't', L'a', L'm', L'p', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', L'e', 
L'd', L'F', L'o', L'r', L'R', L'e', L's', L't', L'o', L'r', 
L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'a', L'd', L'd', L'i', L't', 
L'i', L'o', L'n', L'a', L'l', L'R', L'e', L's', L't', L'o', 
L'r', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'T', L'a', L'r', L'g', L'e', L't', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'p', L'r', L'e', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'F', L'a', L'i', L'l', L'u', L'r', 
L'e', L'M', L's', L'g', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', 
L'l', L'e', L's', L'R', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'p', L'o', L's', L't', L'R', 
L'e', L's', L't', L'o', L'r', L'e', L'F', L'a', L'i', L'l', 
L'u', L'r', L'e', L'M', L's', L'g', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'A', L'L', 
L'T', L'E', L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', 
L'C', L'A', L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', 
L'P', L'I', L'N', L'G', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L' ', 
L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', 
L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', 
L'_', L'M', L'E', L'T', L'A', L'D', L'A', L'T', L'A', L'"', 
L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', L'c', 
L'c', L'u', L'r', L's', L'=', L'"', L'1', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', 
L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'R', 
L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'M', L'E', L'T', 
L'A', L'D', L'A', L'T', L'A', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'1', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'T', L'A', L'R', L'G', L'E', L'T', L'"', 
L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', L'c', 
L'c', L'u', L'r', L's', L'=', L'"', L'*', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', 
L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', 
L'I', L'R', L'E', L'C', L'T', L'E', L'D', L'_', L'T', L'A', 
L'R', L'G', L'E', L'T', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L' ', 
L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', 
L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'P', L'A', L'R', L'T', L'I', L'A', 
L'L', L'_', L'F', L'I', L'L', L'E', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'R', L'E', L'S', L'T', 
L'O', L'R', L'E', L'_', L'S', L'U', L'B', L'C', L'O', L'M', 
L'P', L'O', L'N', L'E', L'N', L'T', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', L'A', 
L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', L'I', 
L'N', L'G', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'M', 
L'a', L'p', L'p', L'i', L'n', L'g', L' ', L'f', L'r', L'o', 
L'm', L' ', L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L't', L'h', L'a', L't', L' ', L'w', L'a', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L' ', L't', L'o', L' ', L'a', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L't', L'o', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'o', L'.', 
L'\r', L'\n', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', 
L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'B', L'A', L'C', 
L'K', L'U', L'P', L'_', L'M', L'E', L'T', L'A', L'D', L'A', 
L'T', L'A', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'D', L'e', L'f', 
L'a', L'u', L'l', L't', L' ', L'm', L'e', L't', L'a', L'd', 
L'a', L't', L'a', L' ', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L'f', L'o', L'r', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L'.', L' ', L' ', L'C', L'o', L'n', L't', L'e', 
L'n', L't', L' ', L'i', L's', L' ', L'a', L' ', L'b', L'i', 
L'n', L'a', L'r', L'y', L' ', L'h', L'e', L'x', L' ', L's', 
L't', L'r', L'i', L'n', L'g', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'N', L'o', L't', L'e', L' ', L't', L'h', L'a', L't', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L' ', L'c', L'a', L'n', L' ', L's', L't', L'o', L'r', 
L'e', L' ', L'w', L'h', L'a', L't', L'e', L'v', L'e', L'r', 
L' ', L'h', L'e', L' ', L'w', L'a', L'n', L't', L's', L' ', 
L'i', L'n', L' ', L't', L'h', L'e', L' ', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L'.', L' ', L' ', L'T', 
L'h', L'i', L's', L'\r', L'\n', L' ', L' ', L' ', L'i', L's', 
L' ', L'j', L'u', L's', L't', L' ', L'a', L' ', L's', L'i', 
L'm', L'p', L'l', L'e', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L' ', L'm', L'e', L'c', L'h', L'a', L'n', L'i', 
L's', L'm', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'm', L'e', L't', 
L'a', L'd', L'a', L't', L'a', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L'M', L'e', L't', L'a', L'd', 
L'a', L't', L'a', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'p', L'a', L's', L's', L'e', L'd', L' ', L'o', L'n', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'M', L'E', 
L'T', L'A', L'D', L'A', L'T', L'A', L'"', L' ', L'c', L'o', 
L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', 
L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', 
L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'D', L'e', L'f', L'a', L'u', L'l', L't', L' ', L'm', 
L'e', L't', L'a', L'd', L'a', L't', L'a', L' ', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L'f', L'o', L'r', L' ', 
L'p', L'a', L's', L's', L'i', L'n', L'g', L' ', L'i', L'n', 
L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', L' ', 
L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L'\'', L's', L'\r', L'\n', L' ', 
L' ', L' ', L'P', L'r', L'e', L'R', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L'e', L'v', L'e', L'n', L't', L' ', L't', 
L'o', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', 
L'e', L'r', L'\'', L's', L' ', L'P', L'o', L's', L't', L'R', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L'e', L'v', L'e', 
L'n', L't', L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'd', 
L'a', L't', L'a', L' ', L'i', L's', L'\r', L'\n', L' ', L' ', 
L' ', L'o', L'p', L'a', L'q', L'u', L'e', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L' ', L'r', L'e', L'q', L'u', L'e', 
L's', L't', L'o', L'r', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'm', 
L'e', L't', L'a', L'd', L'a', L't', L'a', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'M', L'e', L't', 
L'a', L'd', L'a', L't', L'a', L' ', L't', L'o', L' ', L'b', 
L'e', L' ', L'p', L'a', L's', L's', L'e', L'd', L' ', L'f', 
L'r', L'o', L'm', L' ', L'P', L'r', L'e', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L' ', L't', L'o', L' ', L'P', L'o', 
L's', L't', L'R', L'e', L's', L't', L'o', L'r', L'e', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'm', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'R', L'E', L'S', L'T', L'O', L'R', L'E', 
L'_', L'T', L'A', L'R', L'G', L'E', L'T', L'"', L' ', L'c', 
L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', 
L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'T', L'h', L'i', L's', L' ', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L' ', L'i', L'n', L' ', L'a', L' ', 
L'C', L'O', L'M', L'P', L'O', L'N', L'E', L'N', L'T', L' ', 
L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', 
L's', L'u', L'p', L'p', L'l', L'i', L'e', L'd', L' ', L'i', 
L'f', L' ', L't', L'h', L'e', L' ', L'v', L'a', L'l', L'u', 
L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'T', L'a', L'r', L'g', L'e', L't', L' ', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L'o', L'f', L' ', 
L't', L'h', L'e', L' ', L'C', L'O', L'M', L'P', L'O', L'N', 
L'E', L'N', L'T', L' ', L'i', L's', L' ', L'"', L'n', L'e', 
L'w', L'"', L'.', L' ', L' ', L'I', L't', L' ', L's', L'u', 
L'p', L'p', L'l', L'i', L'e', L's', L' ', L'a', L'\r', L'\n', 
L' ', L' ', L' ', L'm', L'a', L'p', L'p', L'i', L'n', L'g', 
L' ', L'f', L'r', L'o', L'm', L' ', L'a', L' ', L't', L'h', 
L'e', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L' ', L't', L'o', L' ', L't', L'h', L'e', L' ', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'w', L'h', 
L'e', L'r', L'e', L'\r', L'\n', L' ', L' ', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L' ', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'e', L'd', L'.', L' ', L' ', L'T', L'h', 
L'e', L'r', L'e', L' ', L'm', L'a', L'y', L' ', L'b', L'e', 
L' ', L'm', L'u', L'l', L't', L'i', L'p', L'l', L'e', L' ', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'T', L'A', 
L'R', L'G', L'E', L'T', L'\r', L'\n', L' ', L' ', L' ', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L's', L' ', L'w', L'i', 
L't', L'h', L'i', L'n', L' ', L'a', L' ', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'D', L'I', L'R', L'E', L'C', 
L'T', L'E', L'D', L'_', L'T', L'A', L'R', L'G', L'E', L'T', 
L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', 
L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L'i', L'n', 
L' ', L'a', L' ', L'C', L'O', L'M', L'P', L'O', L'N', L'E', 
L'N', L'T', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'b', L'e', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'b', L'e', L' ', L's', L'u', L'p', L'p', L'l', L'i', L'e', 
L'd', L' ', L'i', L'f', L' ', L't', L'h', L'e', L' ', L'v', 
L'a', L'l', L'u', L'e', L'\r', L'\n', L' ', L' ', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'T', L'a', L'r', L'g', L'e', L't', L' ', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'C', L'O', L'M', 
L'P', L'O', L'N', L'E', L'N', L'T', L' ', L'i', L's', L' ', 
L'"', L'd', L'i', L'r', L'e', L'c', L't', L'e', L'd', L'"', 
L'.', L' ', L' ', L'I', L't', L'\r', L'\n', L' ', L' ', L' ', 
L'i', L's', L' ', L'i', L'n', L't', L'e', L'n', L'd', L'e', 
L'd', L' ', L't', L'o', L' ', L's', L'u', L'p', L'p', L'o', 
L'r', L't', L' ', L'p', L'a', L'r', L't', L'i', L'a', L'l', 
L' ', L'r', L'e', L's', L't', L'o', L'r', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'o', L'r', L' ', L'p', L'o', L't', L'e', L'n', 
L't', L'i', L'a', L'l', L'l', L'y', L'\r', L'\n', L' ', L' ', 
L' ', L'h', L'o', L'w', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', 
L' ', L'r', L'e', L'o', L'r', L'g', L'a', L'n', L'i', L'z', 
L'e', L'd', L' ', L'u', L'p', L'o', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'.', L' ', L' ', L'T', L'h', 
L'e', L'r', L'e', L' ', L'm', L'a', L'y', L' ', L'b', L'e', 
L' ', L'm', L'u', L'l', L't', L'i', L'p', L'l', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L'D', L'I', L'R', L'E', L'C', L'T', 
L'E', L'D', L'_', L'T', L'A', L'R', L'G', L'E', L'T', L' ', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L's', L' ', L'w', 
L'i', L't', L'h', L'i', L'n', L' ', L'a', L' ', L'c', L'o', 
L'm', L'p', L'o', L'n', L'e', L'n', L't', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L't', L'a', L'r', L'g', L'e', L't', L'P', L'a', 
L't', L'h', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'T', L'h', L'i', L's', L' ', L'i', L's', L' ', 
L't', L'h', L'e', L' ', L't', L'a', L'r', L'g', L'e', L't', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L' ', L't', L'h', L'a', L't', L' ', L'i', L's', L' ', 
L't', L'o', L' ', L'b', L'e', L' ', L'w', L'r', L'i', L't', 
L't', L'e', L'n', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L'q', L'u', L'e', L's', L't', L'o', L'r', L'.', L' ', 
L' ', L'I', L'f', L' ', L't', L'h', L'i', L's', L' ', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'i', 
L's', L' ', L'n', L'o', L't', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L' ', L't', L'h', L'e', L'n', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L't', 
L'h', L'e', L' ', L't', L'a', L'r', L'g', L'e', L't', L'P', 
L'a', L't', L'h', L' ', L'i', L's', L' ', L'a', L's', L's', 
L'u', L'm', L'e', L'd', L' ', L't', L'o', L' ', L'b', L'e', 
L' ', L't', L'h', L'e', L' ', L's', L'a', L'm', L'e', L' ', 
L'a', L's', L' ', L't', L'h', L'e', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'p', L'a', L't', L'h', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L't', 
L'a', L'r', L'g', L'e', L't', L'F', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'i', L's', 
L' ', L't', L'h', L'e', L' ', L'n', L'a', L'm', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L' ', L't', L'h', L'a', L't', L' ', L'i', L's', L' ', 
L't', L'o', L' ', L'b', L'e', L' ', L'w', L'r', L'i', L't', 
L't', L'e', L'n', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L'q', L'u', L'e', L's', L't', L'o', L'r', L'.', L' ', 
L' ', L'I', L'f', L' ', L't', L'h', L'i', L's', L' ', L'i', 
L's', L' ', L'n', L'o', L't', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L' ', L't', L'h', L'e', L'n', 
L' ', L't', L'h', L'e', L' ', L't', L'a', L'r', L'g', L'e', 
L't', L' ', L'f', L'i', L'l', L'e', L'n', L'a', L'm', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'i', 
L's', L' ', L'a', L's', L's', L'u', L'm', L'e', L'd', L' ', 
L't', L'o', L' ', L'b', L'e', L' ', L't', L'h', L'e', L' ', 
L's', L'a', L'm', L'e', L' ', L'a', L's', L' ', L't', L'h', 
L'e', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', 
L' ', L'f', L'i', L'l', L'e', L' ', L'n', L'a', L'm', L'e', 
L'.', L' ', L' ', L'N', L'o', L't', L'e', L' ', L't', L'h', 
L'a', L't', L' ', L'i', L'f', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'b', L'o', L't', L'h', L' ', L't', 
L'h', L'e', L' ', L't', L'a', L'r', L'g', L'e', L't', L'P', 
L'a', L't', L'h', L' ', L'a', L'n', L'd', L' ', L't', L'a', 
L'r', L'g', L'e', L't', L'F', L'i', L'l', L'e', L's', L'p', 
L'e', L'c', L' ', L'a', L'r', L'e', L' ', L'n', L'o', L't', 
L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'e', L'd', 
L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'o', L'r', 
L'i', L'g', L'i', L'n', L'a', L'l', L' ', L'f', L'i', L'l', 
L'e', L' ', L'i', L's', L' ', L'o', L'v', L'e', L'r', L'w', 
L'r', L'i', L't', L't', L'e', L'n', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L's', L'o', L'u', L'r', L'c', 
L'e', L'R', L'a', L'n', L'g', L'e', L's', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', L'h', 
L'i', L's', L' ', L'i', L's', L' ', L'a', L' ', L's', L't', 
L'r', L'i', L'n', L'g', L' ', L'o', L'f', L' ', L't', L'h', 
L'e', L' ', L'f', L'o', L'r', L'm', L' ', L'(', L'o', L'f', 
L'f', L's', L'e', L't', L':', L'c', L'b', L' ', L'.', L'.', 
L'.', L')', L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'e', 
L'a', L'c', L'h', L' ', L'o', L'f', L'f', L's', L'e', L't', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'i', 
L's', L' ', L't', L'h', L'e', L' ', L'b', L'y', L't', L'e', 
L' ', L'o', L'f', L'f', L's', L'e', L't', L' ', L't', L'o', 
L' ', L's', L't', L'a', L'r', L't', L' ', L'r', L'e', L'a', 
L'd', L'i', L'n', L'g', L' ', L'd', L'a', L't', L'a', L' ', 
L'a', L'n', L'd', L' ', L'c', L'b', L' ', L'i', L's', L' ', 
L't', L'h', L'e', L' ', L'l', L'e', L'n', L'g', L't', L'h', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'd', L'a', L't', L'a', 
L' ', L't', L'o', L' ', L'b', L'e', L' ', L'r', L'e', L'a', 
L'd', L' ', L'(', L'e', L'a', L'c', L'h', L' ', L'i', L's', 
L' ', L'a', L' ', L'6', L'4', L' ', L'b', L'i', L't', L' ', 
L'i', L'n', L't', L'e', L'g', L'e', L'r', L')', L'.', L' ', 
L' ', L'T', L'h', L'e', L' ', L'r', L'a', L'n', L'g', L'e', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'm', L'a', L'y', L' ', L'n', L'o', L't', L' ', L'o', L'v', 
L'e', L'r', L'l', L'a', L'p', L' ', L'a', L'n', L'd', L' ', 
L'm', L'u', L's', L't', L' ', L'b', L'e', L' ', L'm', L'o', 
L'n', L'o', L't', L'o', L'n', L'i', L'c', L'a', L'l', L'l', 
L'y', L' ', L'i', L'n', L'c', L'r', L'e', L'a', L's', L'i', 
L'n', L'g', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L't', L'a', L'r', L'g', L'e', L't', L'R', L'a', L'n', 
L'g', L'e', L's', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'i', 
L's', L' ', L'a', L' ', L's', L't', L'r', L'i', L'n', L'g', 
L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'o', 
L'r', L'm', L' ', L'(', L'o', L'f', L'f', L's', L'e', L't', 
L':', L'c', L'b', L' ', L'.', L'.', L'.', L')', L' ', L'w', 
L'h', L'e', L'r', L'e', L' ', L'e', L'a', L'c', L'h', L' ', 
L'o', L'f', L'f', L's', L'e', L't', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'i', L's', L' ', L't', L'h', 
L'e', L' ', L'b', L'y', L't', L'e', L' ', L'o', L'f', L'f', 
L's', L'e', L't', L' ', L't', L'o', L' ', L's', L't', L'a', 
L'r', L't', L' ', L'w', L'r', L't', L'i', L'n', L'g', L' ', 
L'd', L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L'c', 
L'b', L' ', L'i', L's', L' ', L't', L'h', L'e', L' ', L'l', 
L'e', L'n', L'g', L't', L'h', L' ', L'o', L'f', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L't', L'h', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L't', L'o', L' ', L'b', 
L'e', L' ', L'w', L'r', L'i', L't', L't', L'e', L'n', L' ', 
L'(', L'e', L'a', L'c', L'h', L' ', L'i', L's', L' ', L'a', 
L' ', L'6', L'4', L' ', L'b', L'i', L't', L' ', L'i', L'n', 
L't', L'e', L'g', L'e', L'r', L')', L'.', L' ', L' ', L'T', 
L'h', L'e', L' ', L'r', L'a', L'n', L'g', L'e', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'm', L'a', 
L'y', L' ', L'n', L'o', L't', L' ', L'o', L'v', L'e', L'r', 
L'l', L'a', L'p', L' ', L'a', L'n', L'd', L' ', L'm', L'u', 
L's', L't', L' ', L'b', L'e', L' ', L'm', L'o', L'n', L'o', 
L't', L'o', L'n', L'i', L'c', L'a', L'l', L'l', L'y', L' ', 
L'i', L'n', L'c', L'r', L'e', L'a', L's', L'i', L'n', L'g', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', L'h', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', 
L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L't', L'a', L'r', L'g', L'e', 
L't', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L't', 
L'a', L'r', L'g', L'e', L't', L'F', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', L'o', L'u', 
L'r', L'c', L'e', L'R', L'a', L'n', L'g', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L't', L'a', L'r', L'g', L'e', L't', L'R', 
L'a', L'n', L'g', L'e', L's', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'P', L'A', L'R', 
L'T', L'I', L'A', L'L', L'_', L'F', L'I', L'L', L'E', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', 
L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L' ', L'i', L'n', L' ', 
L'a', L' ', L'C', L'O', L'M', L'P', L'O', L'N', L'E', L'N', 
L'T', L' ', L'i', L's', L' ', L's', L'u', L'p', L'p', L'l', 
L'i', L'e', L'd', L' ', L'b', L'y', L' ', L't', L'h', L'e', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'd', L'u', 
L'r', L'i', L'n', L'g', L' ', L't', L'h', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'P', L'o', L's', L't', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L' ', L'e', L'v', L'e', L'n', L't', 
L'.', L' ', L' ', L'I', L't', L' ', L'i', L'n', L'd', L'i', 
L'c', L'a', L't', L'e', L's', L' ', L't', L'h', L'a', L't', 
L' ', L'o', L'n', L'l', L'y', L' ', L'a', L' ', L'p', L'o', 
L'r', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L't', 
L'h', L'e', L' ', L'f', L'i', L'l', L'e', L'\r', L'\n', L' ', 
L' ', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', 
L'e', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L' ', L' ', L'T', L'h', L'e', L'r', L'e', L' ', 
L'm', L'a', L'y', L' ', L'b', L'e', L' ', L'm', L'u', L'l', 
L't', L'i', L'p', L'l', L'e', L' ', L'P', L'A', L'R', L'T', 
L'I', L'A', L'L', L'_', L'F', L'I', L'L', L'E', L' ', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L's', L'\r', L'\n', L' ', 
L' ', L' ', L'w', L'i', L't', L'h', L'i', L'n', L' ', L'a', 
L' ', L's', L'i', L'n', L'g', L'l', L'e', L' ', L'C', L'O', 
L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'r', L'a', L'n', L'g', L'e', L's', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', L'h', 
L'i', L's', L' ', L'r', L'a', L'n', L'g', L'e', L' ', L'l', 
L'i', L's', L't', L' ', L'h', L'a', L's', L' ', L't', L'h', 
L'e', L' ', L'f', L'o', L'r', L'm', L' ', L'(', L'o', L'f', 
L'f', L's', L'e', L't', L':', L'l', L'e', L'n', L'g', L't', 
L'h', L' ', L'.', L'.', L'.', L')', L' ', L'w', L'h', L'e', 
L'r', L'e', L' ', L'o', L'f', L'f', L's', L'e', L't', L' ', 
L'i', L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L't', L'h', L'e', L' ', L'b', L'y', L't', L'e', L' ', 
L'o', L'f', L'f', L's', L'e', L't', L' ', L'i', L'n', L' ', 
L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L' ', L't', 
L'o', L' ', L'b', L'e', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L'a', L'n', L'd', L' ', L'l', 
L'e', L'n', L'g', L't', L'h', L' ', L'i', L's', L' ', L't', 
L'h', L'e', L' ', L'l', L'e', L'n', L'g', L't', L'h', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'd', L'a', L't', L'a', L' ', 
L't', L'o', L' ', L'b', L'e', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L'.', L' ', L' ', L'B', L'o', 
L't', L'h', L' ', L'a', L'r', L'e', L' ', L'6', L'4', L' ', 
L'b', L'i', L't', L' ', L'i', L'n', L't', L'e', L'g', L'e', 
L'r', L's', L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'r', 
L'a', L'n', L'g', L'e', L's', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'm', L'u', L's', L't', L' ', L'b', 
L'e', L' ', L'm', L'o', L'n', L'o', L't', L'o', L'n', L'i', 
L'c', L'a', L'l', L'l', L'y', L' ', L'i', L'n', L'c', L'r', 
L'e', L'a', L's', L'i', L'n', L'g', L' ', L'a', L'n', L'd', 
L' ', L'm', L'u', L's', L't', L' ', L'n', L'o', L't', L' ', 
L'o', L'v', L'e', L'r', L'l', L'a', L'p', L'.', L' ', L' ', 
L'I', L'f', L' ', L't', L'h', L'e', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'r', L'a', L'n', L'g', L'e', 
L'l', L'i', L's', L't', L' ', L'i', L's', L' ', L'n', L'o', 
L't', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'e', 
L'd', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', L'e', 
L' ', L'e', L'n', L't', L'i', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'b', L'e', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', 
L'u', L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', 
L'h', L'i', L's', L' ', L'i', L's', L' ', L'm', L'e', L't', 
L'a', L'd', L'a', L't', L'a', L' ', L'u', L's', L'e', L'd', 
L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'f', L'o', L'r', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'i', L'n', L'g', L' ', L't', 
L'h', L'e', L' ', L'p', L'a', L'r', L't', L'i', L'a', L'l', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L'.', L' ', L' ', L'I', L't', 
L' ', L'm', L'i', L'g', L'h', L't', L' ', L'f', L'o', L'r', 
L' ', L'e', L'x', L'a', L'm', L'p', L'l', L'e', L',', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L't', L'h', 
L'e', L' ', L't', L'o', L't', L'a', L'l', L' ', L's', L'i', 
L'z', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'f', L'i', 
L'l', L'e', L' ', L't', L'o', L' ', L'b', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'p', L'a', L't', L'h', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'f', L'i', L'l', L'e', L's', L'p', L'e', L'c', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'r', L'a', L'n', L'g', L'e', L's', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', 
L'S', L'U', L'B', L'C', L'O', L'M', L'P', L'O', L'N', L'E', 
L'N', L'T', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'T', L'h', L'i', 
L's', L' ', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L'i', L'n', L' ', L'a', L' ', L'C', L'O', L'M', L'P', L'O', 
L'N', L'E', L'N', L'T', L' ', L'i', L's', L' ', L'a', L'd', 
L'd', L'e', L'd', L' ', L'b', L'y', L' ', L't', L'h', L'e', 
L' ', L'r', L'e', L'q', L'u', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'p', L'r', L'i', L'o', L'r', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'P', 
L'r', L'e', L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', 
L'e', L'v', L'e', L'n', L't', L'.', L' ', L' ', L'I', L't', 
L' ', L'a', L'l', L'l', L'o', L'w', L's', L' ', L'a', L' ', 
L's', L'u', L'b', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L' ', L'o', L'f', L' ', L'a', L' ', L'b', L'a', 
L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L'c', L'o', 
L'm', L'p', L'o', L'n', L'e', L'n', L't', L' ', L't', L'o', 
L'\r', L'\n', L' ', L' ', L' ', L'b', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'd', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'r', L'e', L'p', L'a', L'i', L'r', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'i', L'n', L'd', L'i', L'c', 
L'a', L't', L'e', L's', L' ', L't', L'h', L'a', L't', L' ', 
L't', L'h', L'e', L' ', L'p', L'u', L'r', L'p', L'o', L's', 
L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L'i', L's', L' ', 
L't', L'o', L' ', L'r', L'e', L'p', L'a', L'i', L'r', L' ', 
L'o', L'n', L'e', L' ', L'o', L'r', L' ', L'm', L'o', L'r', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'o', L'f', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L' ', L'i', L's', L' ', L'r', 
L'e', L's', L'p', L'o', L'n', L's', L'i', L'b', L'l', L'e', 
L' ', L'f', L'o', L'r', L' ', L'i', L'd', L'e', L'n', L't', 
L'i', L'f', L'y', L'i', L'n', L'g', L' ', L'w', L'h', L'a', 
L't', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'i', L's', L' ', L't', L'o', L' ', L'b', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L'u', L's', 
L'i', L'n', L'g', L' ', L'a', L' ', L'D', L'I', L'R', L'E', 
L'C', L'T', L'E', L'D', L'_', L'T', L'A', L'R', L'G', L'E', 
L'T', L' ', L'e', L'l', L'e', L'm', L'e', L'n', L't', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', 
L'l', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L'N', L'a', 
L'm', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'p', L'a', 
L'i', L'r', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'S', L'N', L'A', L'P', L'S', L'H', 
L'O', L'T', L'_', L'S', L'E', L'T', L'_', L'D', L'E', L'S', 
L'C', L'R', L'I', L'P', L'T', L'I', L'O', L'N', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', 
L'd', L'e', L's', L'c', L'r', L'i', L'b', L'e', L's', L' ', 
L'a', L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', 
L',', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'i', L'n', 
L'g', L' ', L't', L'h', L'e', L' ', L's', L'n', L'a', L'p', 
L's', L'h', L'o', L't', L' ', L's', L'e', L't', L' ', L'i', 
L'd', L' ', L'a', L's', L' ', L'w', L'e', L'l', L'l', L' ', 
L'a', L's', L'\r', L'\n', L' ', L' ', L' ', L't', L'h', L'e', 
L' ', L'v', L'o', L'l', L'u', L'm', L'e', L' ', L'i', L'n', 
L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', L' ', 
L'f', L'o', L'r', L' ', L't', L'h', L'e', L' ', L's', L'n', 
L'a', L'p', L's', L'h', L'o', L't', L't', L'e', L'd', L' ', 
L'v', L'o', L'l', L'u', L'm', L'e', L's', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L'S', 
L'e', L't', L'I', L'd', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L't', L'h', L'i', L's', L' ', L'i', L's', 
L' ', L't', L'h', L'e', L' ', L'u', L'n', L'i', L'q', L'u', 
L'e', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'i', 
L'e', L'r', L' ', L'f', L'o', L'r', L' ', L't', L'h', L'e', 
L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'c', L'o', L'n', 
L't', L'e', L'x', L't', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'u', L'i', L'4', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L't', L'h', L'i', L's', L' ', L'i', L's', L' ', 
L't', L'h', L'e', L' ', L'c', L'o', L'n', L't', L'e', L'x', 
L't', L' ', L'u', L's', L'e', L'd', L' ', L't', L'o', L' ', 
L'c', L'r', L'e', L'a', L't', L'e', L' ', L't', L'h', L'e', 
L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'm', L'e', L't', 
L'a', L'd', L'a', L't', L'a', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L't', L'h', L'i', L's', L' ', 
L'i', L's', L' ', L'p', L'r', L'i', L'v', L'a', L't', L'e', 
L' ', L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L' ', 
L'a', L'b', L'o', L'u', L't', L' ', L't', L'h', L'e', L' ', 
L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L' ', L's', 
L'e', L't', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L't', L'h', L'i', L's', L' ', L'i', L's', L' ', L'a', 
L' ', L'u', L's', L'e', L'r', L' ', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L's', L'n', L'a', L'p', L's', 
L'h', L'o', L't', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', L'n', L'a', 
L'p', L's', L'h', L'o', L't', L'S', L'e', L't', L'I', L'd', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'c', L'o', L'n', L't', L'e', L'x', 
L't', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'S', L'N', L'A', L'P', L'S', L'H', L'O', L'T', L'_', L'D', 
L'E', L'S', L'C', L'R', L'I', L'P', L'T', L'I', L'O', L'N', 
L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'*', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'S', L'N', L'A', L'P', L'S', L'H', L'O', L'T', L'_', L'D', 
L'E', L'S', L'C', L'R', L'I', L'P', L'T', L'I', L'O', L'N', 
L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', 
L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'T', L'h', L'i', 
L's', L' ', L'i', L's', L' ', L't', L'h', L'e', L' ', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L' ', L'o', L'f', L' ', L'a', L' ', L's', L'n', L'a', L'p', 
L's', L'h', L'o', L't', L't', L'e', L'd', L' ', L'v', L'o', 
L'l', L'u', L'm', L'e', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'n', 
L'a', L'p', L's', L'h', L'o', L't', L'I', L'd', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'u', 
L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', L'h', L'i', 
L's', L' ', L'i', L's', L' ', L't', L'h', L'e', L' ', L'u', 
L'n', L'i', L'q', L'u', L'e', L' ', L'i', L'd', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L's', L'n', L'a', L'p', 
L's', L'h', L'o', L't', L't', L'e', L'd', L' ', L'v', L'o', 
L'l', L'u', L'm', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L't', 
L'i', L'n', L'g', L'M', L'a', L'c', L'h', L'i', L'n', L'e', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', 
L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'T', L'h', L'i', L's', L' ', L'i', L's', L' ', L't', 
L'h', L'e', L' ', L'm', L'a', L'c', L'h', L'i', L'n', L'e', 
L' ', L'w', L'h', L'e', L'r', L'e', L' ', L't', L'h', L'e', 
L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'v', L'o', L'l', L'u', L'm', L'e', L' ', L'w', L'a', L's', 
L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L't', 
L'e', L'd', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L's', L'e', L'r', L'v', L'i', L'c', L'e', L'M', L'a', L'c', 
L'h', L'i', L'n', L'e', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', 
L'i', L's', L' ', L't', L'h', L'e', L' ', L'A', L'p', L'p', 
L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'S', 
L'e', L'r', L'v', L'e', L'r', L' ', L'm', L'a', L'c', L'h', 
L'i', L'n', L'e', L' ', L'(', L'i', L'.', L'e', L'.', L' ', 
L'w', L'h', L'e', L'r', L'e', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L's', L' ', L'w', L'e', 
L'r', L'e', L' ', L'n', L'o', L't', L'i', L'f', L'i', L'e', 
L'd', L')', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L'V', L'o', 
L'l', L'u', L'm', L'e', L'N', L'a', L'm', L'e', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', 
L'h', L'i', L's', L' ', L'i', L's', L' ', L't', L'h', L'e', 
L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'n', L'a', L'm', L'e', L' ', L'o', L'f', L' ', L't', L'h', 
L'e', L' ', L'v', L'o', L'l', L'u', L'm', L'e', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'n', L'a', 
L'p', L's', L'h', L'o', L't', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L's', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'i', L'4', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L't', L'h', L'i', L's', L' ', L'd', L'e', 
L's', L'c', L'r', L'i', L'b', L'e', L's', L' ', L't', L'h', 
L'e', L' ', L'a', L'c', L't', L'u', L'a', L'l', L' ', L's', 
L'n', L'a', L'p', L's', L'h', L'o', L't', L' ', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L's', L' ', L'(', 
L'a', L's', L' ', L'd', L'e', L'f', L'i', L'n', L'e', L'd', 
L' ', L'i', L'n', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'V', L'S', L'S', L'_', L'V', L'O', L'L', L'U', 
L'M', L'E', L'_', L'S', L'N', L'A', L'P', L'S', L'H', L'O', 
L'T', L'_', L'A', L'T', L'T', L'R', L'I', L'B', L'U', L'T', 
L'E', L'S', L')', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'd', L'e', L'v', L'i', L'c', L'e', L'N', L'a', L'm', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'T', L'h', L'i', L's', L' ', 
L'i', L's', L' ', L't', L'h', L'e', L' ', L'i', L'n', L't', 
L'e', L'r', L'n', L'a', L'l', L' ', L'd', L'e', L'v', L'i', 
L'c', L'e', L' ', L'n', L'a', L'm', L'e', L' ', L'f', L'o', 
L'r', L' ', L't', L'h', L'e', L' ', L's', L'n', L'a', L'p', 
L's', L'h', L'o', L't', L't', L'e', L'd', L' ', L'v', L'o', 
L'l', L'u', L'm', L'e', L'.', L' ', L' ', L'T', L'h', L'i', 
L's', L'\r', L'\n', L'\t', L'c', L'a', L'n', L' ', L'b', L'e', 
L' ', L'u', L's', L'e', L'd', L' ', L'i', L'f', L' ', L't', 
L'h', L'e', L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', 
L't', L' ', L'i', L's', L' ', L'n', L'o', L't', L' ', L'e', 
L'x', L'p', L'o', L's', L'e', L'd', L'.', L'\r', L'\n', L'\t', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'e', 
L'x', L'p', L'o', L's', L'e', L'd', L'N', L'a', L'm', L'e', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'i', L's', L' ', L't', L'h', 
L'e', L' ', L'e', L'x', L'p', L'o', L's', L'e', L'd', L' ', 
L'n', L'a', L'm', L'e', L' ', L'o', L'f', L' ', L't', L'h', 
L'e', L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', 
L' ', L'v', L'o', L'l', L'u', L'm', L'e', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'e', L'x', L'p', L'o', L's', 
L'e', L'd', L'P', L'a', L't', L'h', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', 
L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'I', L'f', L' ', L'o', 
L'n', L'l', L'y', L' ', L'a', L' ', L's', L'u', L'b', L'd', 
L'i', L'r', L'e', L'c', L't', L'o', L'r', L'y', L' ', L'i', 
L's', L' ', L'e', L'x', L'p', L'o', L's', L'e', L'd', L',', 
L' ', L't', L'h', L'i', L's', L' ', L'i', L's', L' ', L't', 
L'h', L'e', L' ', L'p', L'a', L't', L'h', L' ', L't', L'o', 
L' ', L't', L'h', L'a', L't', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L's', L'u', L'b', L'd', L'i', L'r', 
L'e', L'c', L't', L'o', L'r', L'y', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'p', L'r', L'o', L'v', L'i', 
L'd', L'e', L'r', L'I', L'd', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'T', L'h', L'i', L's', L' ', L'i', 
L's', L' ', L't', L'h', L'e', L' ', L'p', L'r', L'o', L'v', 
L'i', L'd', L'e', L'r', L' ', L't', L'h', L'a', L't', L' ', 
L's', L'u', L'r', L'f', L'a', L'c', L'e', L'd', L' ', L't', 
L'h', L'e', L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', 
L't', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L't', 
L'i', L'm', L'e', L's', L't', L'a', L'm', L'p', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'u', 
L'i', L'8', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L't', L'h', L'i', L's', 
L' ', L'i', L's', L' ', L'w', L'h', L'e', L'n', L' ', L't', 
L'h', L'e', L' ', L's', L'n', L'a', L'p', L's', L'h', L'o', 
L't', L' ', L's', L'e', L't', L' ', L'w', L'a', L's', L' ', 
L'c', L'r', L'e', L'a', L't', L'e', L'd', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L'n', L'a', L'p', L's', L'h', L'o', L't', 
L'I', L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'p', L'r', L'o', L'v', 
L'i', L'd', L'e', L'r', L'I', L'd', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L's', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L't', 
L'i', L'n', L'g', L'M', L'a', L'c', L'h', L'i', L'n', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L'M', L'a', L'c', L'h', L'i', L'n', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'o', L'r', L'i', L'g', L'i', L'n', L'a', L'l', 
L'V', L'o', L'l', L'u', L'm', L'e', L'N', L'a', L'm', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L't', L'i', L'm', L'e', L's', L't', 
L'a', L'm', L'p', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'd', L'e', L'v', 
L'i', L'c', L'e', L'N', L'a', L'm', L'e', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'x', L'p', L'o', L's', L'e', L'd', L'P', L'a', 
L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'e', L'x', L'p', L'o', 
L's', L'e', L'd', L'N', L'a', L'm', L'e', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', 
L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'L', 
L'U', L'N', L'_', L'M', L'A', L'P', L'P', L'I', L'N', L'G', 
L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'0', L'"', L' ', L'm', L'a', L'x', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'*', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'L', L'U', L'N', L'_', L'M', L'A', L'P', L'P', L'I', L'N', 
L'G', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', 
L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', 
L'o', L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L'A', 
L'c', L't', L'u', L'a', L'l', L' ', L'm', L'a', L'p', L'p', 
L'i', L'n', L'g', L' ', L'o', L'f', L' ', L's', L'o', L'u', 
L'r', L'c', L'e', L' ', L'l', L'u', L'n', L' ', L't', L'o', 
L' ', L'a', L' ', L'd', L'e', L's', L't', L'i', L'n', L'a', 
L't', L'i', L'o', L'n', L' ', L'l', L'u', L'n', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'S', L'O', L'U', 
L'R', L'C', L'E', L'_', L'L', L'U', L'N', L'"', L' ', L'm', 
L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', 
L'1', L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', 
L'r', L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'E', L'S', 
L'T', L'I', L'N', L'A', L'T', L'I', L'O', L'N', L'_', L'L', 
L'U', L'N', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'1', L'"', L' ', L'm', L'a', 
L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'1', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'D', L'I', L'S', L'K', L'_', L'E', L'X', L'T', 
L'E', L'N', L'T', L'"', L' ', L'm', L'i', L'n', L'O', L'c', 
L'c', L'u', L'r', L's', L'=', L'"', L'1', L'"', L' ', L'm', 
L'a', L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', 
L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'D', L'I', L'S', L'K', L'_', L'E', L'X', 
L'T', L'E', L'N', L'T', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', 
L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L'A', L' ', L'p', L'a', L'r', L't', L'i', L'c', L'u', L'l', 
L'a', L'r', L' ', L'd', L'i', L's', L'k', L' ', L'e', L'x', 
L't', L'e', L'n', L't', L' ', L'o', L'n', L' ', L'a', L' ', 
L'L', L'U', L'N', L'\r', L'\n', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L't', 
L'a', L'r', L't', L'i', L'n', L'g', L'O', L'f', L'f', L's', 
L'e', L't', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'u', L'i', L'8', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L's', L't', L'a', L'r', L't', L'i', L'n', L'g', L' ', 
L'o', L'f', L'f', L's', L'e', L't', L' ', L'o', L'f', L' ', 
L't', L'h', L'e', L' ', L'e', L'x', L't', L'e', L'n', L't', 
L' ', L'i', L'n', L' ', L's', L'e', L'c', L't', L'o', L'r', 
L's', L'\r', L'\n', L'\t', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'e', L'x', L't', L'e', L'n', L't', L'L', 
L'e', L'n', L'g', L't', L'h', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'i', L'8', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'l', L'e', L'n', 
L'g', L't', L'h', L' ', L'o', L'f', L' ', L't', L'h', L'e', 
L' ', L'e', L'x', L't', L'e', L'n', L't', L' ', L'i', L'n', 
L' ', L's', L'e', L'c', L't', L'o', L'r', L's', L'\r', L'\n', 
L'\t', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'a', L'r', 
L't', L'i', L'n', L'g', L'O', L'f', L'f', L's', L'e', L't', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'x', L't', L'e', L'n', L't', 
L'L', L'e', L'n', L'g', L't', L'h', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'S', L'O', 
L'U', L'R', L'C', L'E', L'_', L'L', L'U', L'N', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'T', L'h', L'e', L' ', L'i', 
L'n', L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', 
L' ', L'f', L'o', L'r', L' ', L't', L'h', L'e', L' ', L'l', 
L'u', L'n', L' ', L'o', L'n', L' ', L't', L'h', L'e', L' ', 
L'o', L'r', L'i', L'g', L'i', L'n', L'a', L't', L'i', L'n', 
L'g', L' ', L'v', L'o', L'l', L'u', L'm', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'L', L'U', L'N', L'_', 
L'I', L'N', L'F', L'O', L'R', L'M', L'A', L'T', L'I', L'O', 
L'N', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'D', L'E', L'S', L'T', L'I', L'N', L'A', 
L'T', L'I', L'O', L'N', L'_', L'L', L'U', L'N', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'T', L'h', L'e', L' ', L'i', 
L'n', L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', 
L' ', L'f', L'o', L'r', L' ', L't', L'h', L'e', L' ', L'l', 
L'u', L'n', L' ', L'o', L'n', L' ', L't', L'h', L'e', L' ', 
L's', L'n', L'a', L'p', L's', L'h', L'o', L't', L't', L'e', 
L'd', L' ', L'v', L'o', L'l', L'u', L'm', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'L', L'U', L'N', L'_', 
L'I', L'N', L'F', L'O', L'R', L'M', L'A', L'T', L'I', L'O', 
L'N', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'I', L'N', L'T', L'E', L'R', L'C', L'O', 
L'N', L'N', L'E', L'C', L'T', L'_', L'D', L'E', L'S', L'C', 
L'R', L'I', L'P', L'T', L'I', L'O', L'N', L'"', L' ', L'c', 
L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', 
L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'A', L'n', L' ', L'i', L'n', L't', L'e', L'r', 
L'c', L'o', L'n', L'n', L'e', L'c', L't', L' ', L'a', L'd', 
L'd', L'r', L'e', L's', L's', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'i', L'n', L'g', L' ', L't', L'h', L'e', L' ', 
L'a', L'd', L'd', L'r', L'e', L's', L's', L' ', L't', L'y', 
L'p', L'e', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'i', L'n', L't', L'e', 
L'r', L'c', L'o', L'n', L'n', L'e', L'c', L't', L'A', L'd', 
L'd', L'r', L'e', L's', L's', L'T', L'y', L'p', L'e', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', 
L'e', L's', L'=', L'"', L'F', L'C', L'F', L'S', L' ', L'F', 
L'C', L'P', L'H', L' ', L'F', L'C', L'P', L'H', L'3', L' ', 
L'M', L'A', L'C', L'"', L' ', L'r', L'e', L'q', L'u', L'i', 
L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'i', L'n', L't', 
L'e', L'r', L'c', L'o', L'n', L'n', L'e', L'c', L't', L' ', 
L'a', L'd', L'd', L'r', L'e', L's', L's', L' ', L't', L'y', 
L'p', L'e', L'.', L' ', L' ', L'D', L'e', L's', L'c', L'r', 
L'i', L'b', L'e', L's', L' ', L't', L'y', L'p', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'i', L'n', L't', 
L'e', L'r', L'c', L'o', L'n', L'n', L'e', L'c', L't', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'a', L'd', 
L'd', L'r', L'e', L's', L's', L' ', L's', L't', L'o', L'r', 
L'e', L'd', L' ', L'i', L'n', L' ', L't', L'h', L'e', L' ', 
L'i', L'n', L't', L'e', L'r', L'c', L'o', L'n', L'n', L'e', 
L'c', L't', L'A', L'd', L'd', L'r', L'e', L's', L's', L' ', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'o', L'r', 
L't', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'P', L'o', L'r', L't', L' ', L't', L'h', L'r', L'o', L'u', 
L'g', L'h', L' ', L'w', L'h', L'i', L'c', L'h', L' ', L't', 
L'h', L'e', L' ', L'i', L'n', L't', L'e', L'r', L'c', L'o', 
L'n', L'n', L'e', L'c', L't', L' ', L'a', L'd', L'd', L'r', 
L'e', L's', L's', L' ', L'i', L's', L' ', L'r', L'e', L'f', 
L'e', L'r', L'r', L'e', L'd', L' ', L't', L'o', L'.', L' ', 
L' ', L'N', L'o', L't', L'e', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', 
L'e', L' ', L's', L'a', L'm', L'e', L' ', L'd', L'e', L'v', 
L'i', L'c', L'e', L' ', L'm', L'a', L'y', L' ', L'h', L'a', 
L'v', L'e', L' ', L'd', L'i', L'f', L'f', L'e', L'r', L'e', 
L'n', L't', L' ', L'i', L'n', L't', L'e', L'r', L'c', L'o', 
L'n', L'n', L'e', L'c', L't', L' ', L'a', L'd', L'd', L'r', 
L'e', L's', L's', L'e', L's', L' ', L't', L'h', L'r', L'o', 
L'u', L'g', L'h', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'd', L'i', L'f', L'f', L'e', L'r', L'e', L'n', L't', 
L' ', L'p', L'o', L'r', L't', L's', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'i', L'n', L't', L'e', L'r', L'c', 
L'o', L'n', L'n', L'e', L'c', L't', L'A', L'd', L'd', L'r', 
L'e', L's', L's', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'W', L'o', L'r', L'l', L'd', L' ', 
L'W', L'i', L'd', L'e', L' ', L'n', L'a', L'm', L'e', L' ', 
L'o', L'r', L' ', L'o', L't', L'h', L'e', L'r', L' ', L'i', 
L'n', L't', L'e', L'r', L'c', L'o', L'n', L'n', L'e', L'c', 
L't', L' ', L'a', L'd', L'd', L'r', L'e', L's', L's', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'd', L'e', L'v', 
L'i', L'c', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'i', L'n', L't', 
L'e', L'r', L'c', L'o', L'n', L'n', L'e', L'c', L't', L'A', 
L'd', L'd', L'r', L'e', L's', L's', L'T', L'y', L'p', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'p', L'o', L'r', L't', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'i', L'n', L't', L'e', L'r', L'c', L'o', L'n', 
L'n', L'e', L'c', L't', L'A', L'd', L'd', L'r', L'e', L's', 
L's', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'L', L'U', L'N', L'_', L'I', L'N', L'F', 
L'O', L'R', L'M', L'A', L'T', L'I', L'O', L'N', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L'e', L'n', L'o', L'u', 
L'g', L'h', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'a', 
L'n', L'd', L' ', L'n', L'a', L'm', L'e', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'l', L'u', L'n', L' ', L't', 
L'o', L' ', L't', L'r', L'a', L'n', L's', L'p', L'o', L'r', 
L't', L' ', L'i', L't', L'.', L' ', L'T', L'B', L'D', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'b', L'u', L's', L'T', L'y', L'p', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'S', L'c', L's', L'i', 
L' ', L'A', L't', L'a', L'p', L'i', L' ', L'A', L't', L'a', 
L' ', L'1', L'3', L'9', L'4', L' ', L'S', L's', L'a', L' ', 
L'F', L'i', L'b', L'r', L'e', L' ', L'U', L's', L'b', L' ', 
L'R', L'A', L'I', L'D', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'T', L'y', 
L'p', L'e', L' ', L'o', L'f', L' ', L'b', L'u', L's', L' ', 
L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', L'L', 
L'U', L'N', L' ', L'i', L's', L' ', L'a', L't', L't', L'a', 
L'c', L'h', L'e', L'd', L' ', L't', L'o', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'd', L'e', L'v', L'i', L'c', 
L'e', L'T', L'y', L'p', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'i', L'1', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'S', L'C', L'S', L'I', L'-', L'2', L' ', 
L'd', L'e', L'v', L'i', L'c', L'e', L' ', L't', L'y', L'p', 
L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'd', 
L'e', L'v', L'i', L'c', L'e', L'T', L'y', L'p', L'e', L'M', 
L'o', L'd', L'i', L'f', L'i', L'e', L'r', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'u', L'i', 
L'1', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'S', L'C', L'S', L'I', L'-', 
L'2', L' ', L'd', L'e', L'v', L'i', L'c', L'e', L' ', L't', 
L'y', L'p', L'e', L' ', L'm', L'o', L'd', L'i', L'f', L'i', 
L'e', L'r', L' ', L'(', L'i', L'f', L' ', L'a', L'n', L'y', 
L')', L' ', L'-', L' ', L't', L'h', L'i', L's', L' ', L'm', 
L'a', L'y', L' ', L'b', L'e', L' ', L'0', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'c', L'o', L'm', L'm', L'a', 
L'n', L'd', L'Q', L'u', L'e', L'u', L'e', L'i', L'n', L'g', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L'F', L'l', L'a', L'g', L' ', L'i', L'n', 
L'd', L'i', L'c', L'a', L't', L'i', L'n', L'g', L' ', L'w', 
L'h', L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', L'e', 
L' ', L'd', L'e', L'v', L'i', L'c', L'e', L' ', L'c', L'a', 
L'n', L' ', L's', L'u', L'p', L'p', L'o', L'r', L't', L' ', 
L'm', L'u', L'l', L'i', L't', L'p', L'l', L'e', L' ', L'o', 
L'u', L't', L's', L't', L'a', L'n', L'd', L'i', L'n', L'g', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'c', 
L'o', L'm', L'm', L'a', L'n', L'd', L's', L'.', L' ', L' ', 
L'T', L'h', L'e', L' ', L'a', L'c', L't', L'u', L'a', L'l', 
L' ', L's', L'y', L'n', L'c', L'h', L'r', L'o', L'n', L'i', 
L'z', L'a', L't', L'i', L'o', L'n', L' ', L'i', L'n', L' ', 
L't', L'h', L'i', L's', L' ', L'c', L'a', L's', L'e', L' ', 
L'i', L's', L' ', L't', L'h', L'e', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'r', L'e', L's', L'p', L'o', 
L'n', L's', L'i', L'b', L'i', L'l', L'i', L't', L'y', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'p', L'o', L'r', 
L't', L' ', L'd', L'r', L'i', L'v', L'e', L'r', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'v', L'e', L'n', 
L'd', L'o', L'r', L'I', L'd', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'O', L'p', L't', L'i', L'o', 
L'n', L'a', L'l', L' ', L's', L't', L'r', L'i', L'n', L'g', 
L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', L'i', 
L'n', L'g', L' ', L't', L'h', L'e', L' ', L'v', L'e', L'n', 
L'd', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'p', L'r', L'o', L'd', L'u', L'c', L't', L'I', L'd', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'O', L'p', L't', L'i', L'o', L'n', L'a', L'l', L' ', L's', 
L't', L'r', L'i', L'n', L'g', L' ', L'i', L'd', L'e', L'n', 
L't', L'i', L'f', L'y', L'i', L'n', L'g', L' ', L't', L'h', 
L'e', L' ', L'p', L'r', L'o', L'd', L'u', L'c', L't', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'r', L'o', 
L'd', L'u', L'c', L't', L'R', L'e', L'v', L'i', L's', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'O', L'p', L't', L'i', L'o', L'n', L'a', L'l', 
L' ', L'p', L'r', L'o', L'd', L'u', L'c', L't', L' ', L'r', 
L'e', L'v', L'i', L's', L'i', L'o', L'n', L' ', L'i', L'n', 
L'f', L'o', L'r', L'm', L'a', L't', L'i', L'o', L'n', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'r', 
L'i', L'a', L'l', L'N', L'u', L'm', L'b', L'e', L'r', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'O', 
L'p', L't', L'i', L'o', L'n', L'a', L'l', L' ', L's', L'e', 
L'r', L'i', L'a', L'l', L' ', L'n', L'u', L'm', L'b', L'e', 
L'r', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', L'd', 
L'e', L'v', L'i', L'c', L'e', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'd', L'i', L's', L'k', L'S', L'i', L'g', 
L'n', L'a', L't', L'u', L'r', L'e', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', 
L'd', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'D', L'i', L's', L'k', L' ', 
L's', L'i', L'g', L'n', L'a', L't', L'u', L'r', L'e', L' ', 
L'o', L'r', L' ', L'G', L'U', L'I', L'D', L'.', L' ', L' ', 
L'I', L'f', L' ', L'a', L' ', L's', L'i', L'g', L'n', L'a', 
L't', L'u', L'r', L'e', L' ', L't', L'h', L'a', L'n', L' ', 
L'a', L'l', L'l', L' ', L'b', L'u', L't', L' ', L't', L'h', 
L'e', L' ', L'l', L'o', L'w', L'e', L'r', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'3', L'2', L' ', L'b', 
L'i', L't', L's', L' ', L'o', L'f', L' ', L't', L'h', L'e', 
L' ', L'G', L'U', L'I', L'D', L' ', L'a', L'r', L'e', L' ', 
L'0', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'd', L'e', L'v', L'i', L'c', L'e', L'I', L'd', L'e', L'n', 
L't', L'i', L'f', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', 
L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', 
L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'U', L'U', L'E', L'N', L'C', L'O', L'D', L'E', L'D', 
L' ', L'b', L'i', L'n', L'a', L'r', L'y', L' ', L'f', L'o', 
L'r', L' ', L't', L'h', L'e', L' ', L'd', L'e', L'v', L'i', 
L'c', L'e', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', 
L'i', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'p', L'a', 
L'g', L'e', L' ', L'a', L's', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'd', L'e', L'f', L'i', L'n', L'e', 
L'd', L' ', L'b', L'y', L' ', L't', L'h', L'e', L' ', L'S', 
L'T', L'O', L'R', L'A', L'G', L'E', L'_', L'D', L'E', L'V', 
L'I', L'C', L'E', L'_', L'I', L'D', L'_', L'D', L'E', L'S', 
L'C', L'R', L'I', L'P', L'T', L'O', L'R', L' ', L's', L't', 
L'r', L'u', L'c', L't', L'u', L'r', L'e', L'.', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'c', L'o', L'n', L't', L'a', 
L'i', L'n', L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L't', L'h', L'e', L' ', L'v', L'e', L'n', L'd', 
L'o', L'r', L' ', L'i', L'd', L',', L' ', L'E', L'U', L'I', 
L'-', L'6', L'4', L' ', L'i', L'd', L',', L' ', L'F', L'C', 
L'-', L'P', L'H', L' ', L'n', L'a', L'm', L'e', L',', L' ', 
L'a', L'n', L'd', L' ', L'v', L'e', L'n', L'd', L'o', L'r', 
L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', 
L'd', L'a', L't', L'a', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'I', L'N', L'T', 
L'E', L'R', L'C', L'O', L'N', L'N', L'E', L'C', L'T', L'_', 
L'D', L'E', L'S', L'C', L'R', L'I', L'P', L'T', L'I', L'O', 
L'N', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', 
L'r', L's', L'=', L'"', L'0', L'"', L' ', L'm', L'a', L'x', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'*', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'd', L'e', L'v', L'i', L'c', L'e', L'T', 
L'y', L'p', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'd', L'e', L'v', 
L'i', L'c', L'e', L'T', L'y', L'p', L'e', L'M', L'o', L'd', 
L'i', L'f', L'i', L'e', L'r', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'c', 
L'o', L'm', L'm', L'a', L'n', L'd', L'Q', L'u', L'e', L'u', 
L'e', L'i', L'n', L'g', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'b', L'u', 
L's', L'T', L'y', L'p', L'e', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'v', 
L'e', L'n', L'd', L'o', L'r', L'I', L'd', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'p', L'r', L'o', L'd', L'u', L'c', L't', L'I', L'd', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'p', L'r', L'o', L'd', L'u', L'c', 
L't', L'R', L'e', L'v', L'i', L's', L'i', L'o', L'n', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L's', L'e', L'r', L'i', L'a', L'l', L'N', 
L'u', L'm', L'b', L'e', L'r', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'd', 
L'i', L's', L'k', L'S', L'i', L'g', L'n', L'a', L't', L'u', 
L'r', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'd', L'e', L'v', L'i', 
L'c', L'e', L'I', L'd', L'e', L'n', L't', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'<', L'/', 
L'S', L'c', L'h', L'e', L'm', L'a', L'>', L'\r', L'\n', 
L'\n', L'<', L'/', L'r', L'o', L'o', L't', L'>', L'\n', L'\0'
};
unsigned g_cwcComponentMetadataXML = 26448;


unsigned g_iwcComponentMetadataXMLBegin = 7;


unsigned g_iwcComponentMetadataXMLEnd = 26439;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\base64coder.h ===
// Base64Coder.h: interface for the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
#define AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEB64CH"
//
////////////////////////////////////////////////////////////////////////

class Base64Coder
	{
	// Internal bucket class.
	class TempBucket
	{
	public:
		BYTE		nData[4];
		BYTE		nSize;
		void		Clear()
			{
			::ZeroMemory(nData, sizeof(nData));
			nSize = 0;
			}
	};

	PBYTE					m_pDBuffer;
	LPWSTR					m_pEBuffer;
	UINT					m_nDBufLen;
	UINT					m_nEBufLen;
	UINT					m_nDDataLen;
	UINT					m_nEDataLen;

public:
	Base64Coder();
	virtual ~Base64Coder();

public:
	virtual void		Encode(const BYTE *, UINT);
	virtual void		Decode(LPCWSTR);

	virtual BYTE *		DecodedMessage() const;
	virtual LPCWSTR		EncodedMessage() const;

	virtual void		AllocEncode(UINT);
	virtual void		AllocDecode(UINT);
	virtual void		SetEncodeBuffer(LPCWSTR pBuffer, UINT nBufLen);
	virtual void		SetDecodeBuffer(const BYTE *pBuffer, UINT nBufLen);

protected:
	virtual void		_EncodeToBuffer(const TempBucket &Decode, LPWSTR pBuffer);
	virtual UINT		_DecodeToBuffer(const TempBucket &Decode, BYTE *pBuffer);
	virtual void		_EncodeRaw(TempBucket &, const TempBucket &);
	virtual void		_DecodeRaw(TempBucket &, const TempBucket &);
	virtual BOOL		_IsBadMimeChar(WCHAR);

	static  char		m_DecodeTable[256];
	static  BOOL		m_Init;
	void				_Init();
	};

#endif // !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\base64coder.cpp ===
// Base64Coder.cpp: implementation of the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#include <stdafx.hxx>
#include "Base64Coder.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEB64CC"
//
////////////////////////////////////////////////////////////////////////

// Digits...
static char	Base64Digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";


BOOL Base64Coder::m_Init		= FALSE;
char Base64Coder::m_DecodeTable[256];

#ifndef PAGESIZE
#define PAGESIZE					4096
#endif

#ifndef ROUNDTOPAGE
#define ROUNDTOPAGE(a)			(((a/4096)+1)*4096)
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Base64Coder::Base64Coder() :
	m_pDBuffer(NULL),
	m_pEBuffer(NULL),
	m_nDBufLen(0),
	m_nEBufLen(0)
	{
	}

Base64Coder::~Base64Coder()
	{
	if(m_pDBuffer != NULL)
		delete [] m_pDBuffer;

	if(m_pEBuffer != NULL)
		delete [] m_pEBuffer;
	}

BYTE *Base64Coder::DecodedMessage() const
	{
	return m_pDBuffer;
	}

LPCWSTR Base64Coder::EncodedMessage() const
	{
	return m_pEBuffer;
	}

void Base64Coder::AllocEncode(UINT nSize)
	{
	if(m_nEBufLen < nSize)
		{
		if(m_pEBuffer != NULL)
			delete [] m_pEBuffer;

		m_nEBufLen = ROUNDTOPAGE(nSize);
		m_pEBuffer = new WCHAR[m_nEBufLen];
		if (m_pEBuffer == NULL)
			{
			// reset allocated size to 0
			m_nEBufLen = 0;
			throw(E_OUTOFMEMORY);
			}
		}

	::ZeroMemory(m_pEBuffer, m_nEBufLen*sizeof(WCHAR));
	m_nEDataLen = 0;
	}

void Base64Coder::AllocDecode(UINT nSize)
	{
	if(m_nDBufLen < nSize)
		{
		if(m_pDBuffer != NULL)
			delete [] m_pDBuffer;

		m_nDBufLen = ROUNDTOPAGE(nSize);
		m_pDBuffer = new BYTE[m_nDBufLen];
		if (m_pDBuffer == NULL)
			{
			// reset allocated size to 0
			m_nDBufLen = 0;
			throw(E_OUTOFMEMORY);
			}
		}

	::ZeroMemory(m_pDBuffer, m_nDBufLen);

	m_nDDataLen = 0;
	}

void Base64Coder::SetEncodeBuffer(const LPCWSTR pBuffer, UINT nBufLen)
	{
	UINT	i = 0;

	AllocEncode(nBufLen);
	while(i < nBufLen)
		{
		if(!_IsBadMimeChar(pBuffer[i]))
			{
			m_pEBuffer[m_nEDataLen] = pBuffer[i];
			m_nEDataLen++;
			}

		i++;
		}
	}

void Base64Coder::SetDecodeBuffer(const BYTE *pBuffer, UINT nBufLen)
	{
	AllocDecode(nBufLen + sizeof(nBufLen));
    ::CopyMemory(m_pDBuffer, &nBufLen, sizeof(nBufLen));
	::CopyMemory(m_pDBuffer + sizeof(nBufLen), pBuffer, nBufLen);
	m_nDDataLen = nBufLen + sizeof(nBufLen);
	}

void Base64Coder::Encode(const BYTE *pBuffer, UINT nBufLen)
	{
	SetDecodeBuffer(pBuffer, nBufLen);
    // include length
    nBufLen += sizeof(nBufLen);
	AllocEncode(nBufLen * 2);

	TempBucket			Raw;
	UINT					nIndex	= 0;

	while((nIndex + 3) <= nBufLen)
		{
		Raw.Clear();
		::CopyMemory(&Raw, m_pDBuffer + nIndex, 3);
		Raw.nSize = 3;
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		nIndex		+= 3;
		m_nEDataLen	+= 4;
		}

	if(nBufLen > nIndex)
		{
		Raw.Clear();
		Raw.nSize = (BYTE) (nBufLen - nIndex);
		::CopyMemory(&Raw, m_pDBuffer + nIndex, nBufLen - nIndex);
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		m_nEDataLen += 4;
		}
	}
	
void Base64Coder::Decode(const LPCWSTR pBuffer)
	{
	UINT dwBufLen = (UINT) wcslen(pBuffer);

	if(!Base64Coder::m_Init)
		_Init();

	SetEncodeBuffer(pBuffer, dwBufLen);

	AllocDecode(dwBufLen);

	TempBucket			Raw;

	UINT		nIndex = 0;

	while((nIndex + 4) <= m_nEDataLen)
		{
		Raw.Clear();
		Raw.nData[0] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex]];
		Raw.nData[1] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 1]];
		Raw.nData[2] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 2]];
		Raw.nData[3] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 3]];

		if(Raw.nData[2] == 255)
			Raw.nData[2] = 0;
		if(Raw.nData[3] == 255)
			Raw.nData[3] = 0;
		
		Raw.nSize = 4;
		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		nIndex += 4;
		m_nDDataLen += 3;
		}
	
   // If nIndex < m_nEDataLen, then we got a decode message without padding.
   // We may want to throw some kind of warning here, but we are still required
   // to handle the decoding as if it was properly padded.
	if(nIndex < m_nEDataLen)
		{
		Raw.Clear();
		for(UINT i = nIndex; i < m_nEDataLen; i++)
			{
			Raw.nData[i - nIndex] = Base64Coder::m_DecodeTable[m_pEBuffer[i]];
			Raw.nSize++;
			if(Raw.nData[i - nIndex] == 255)
				Raw.nData[i - nIndex] = 0;
			}

		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		m_nDDataLen += (m_nEDataLen - nIndex);
		}
	}

UINT Base64Coder::_DecodeToBuffer(const TempBucket &Decode, BYTE *pBuffer)
	{
	TempBucket	Data;
	UINT			nCount = 0;

	_DecodeRaw(Data, Decode);

	for(int i = 0; i < 3; i++)
		{
		pBuffer[i] = Data.nData[i];
		if(pBuffer[i] != 255)
			nCount++;
		}

	return nCount;
	}


void Base64Coder::_EncodeToBuffer(const TempBucket &Decode, LPWSTR pBuffer)
	{
	TempBucket	Data;

	_EncodeRaw(Data, Decode);

	for(int i = 0; i < 4; i++)
		pBuffer[i] = Base64Digits[Data.nData[i]];

	switch(Decode.nSize)
		{
		case 1:
			pBuffer[2] = '=';
		case 2:
			pBuffer[3] = '=';
			}
		}

void Base64Coder::_DecodeRaw(TempBucket &Data, const TempBucket &Decode)
	{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] <<= 2;

	nTemp = Decode.nData[1];
	nTemp >>= 4;
	nTemp &= 0x03;
	Data.nData[0] |= nTemp;

	Data.nData[1] = Decode.nData[1];
	Data.nData[1] <<= 4;

	nTemp = Decode.nData[2];
	nTemp >>= 2;
	nTemp &= 0x0F;
	Data.nData[1] |= nTemp;

	Data.nData[2] = Decode.nData[2];
	Data.nData[2] <<= 6;
	nTemp = Decode.nData[3];
	nTemp &= 0x3F;
	Data.nData[2] |= nTemp;
	}

void Base64Coder::_EncodeRaw(TempBucket &Data, const TempBucket &Decode)
	{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] >>= 2;
	
	Data.nData[1] = Decode.nData[0];
	Data.nData[1] <<= 4;
	nTemp = Decode.nData[1];
	nTemp >>= 4;
	Data.nData[1] |= nTemp;
	Data.nData[1] &= 0x3F;

	Data.nData[2] = Decode.nData[1];
	Data.nData[2] <<= 2;

	nTemp = Decode.nData[2];
	nTemp >>= 6;

	Data.nData[2] |= nTemp;
	Data.nData[2] &= 0x3F;

	Data.nData[3] = Decode.nData[2];
	Data.nData[3] &= 0x3F;
	}

BOOL Base64Coder::_IsBadMimeChar(WCHAR nData)
	{
	switch(nData)
		{
		case L'\r': case L'\n': case L'\t': case L' ' :
		case L'\b': case L'\a': case L'\f': case L'\v':
			return TRUE;
		default:
			return FALSE;
		}
	}

void Base64Coder::_Init()
	{
	// Initialize Decoding table.
	int	i;

	for(i = 0; i < 256; i++)
		Base64Coder::m_DecodeTable[i] = -2;

	for(i = 0; i < 64; i++)
		{
		Base64Coder::m_DecodeTable[Base64Digits[i]]			= (char) i;
		Base64Coder::m_DecodeTable[Base64Digits[i]|0x80]	= (char) i;
		}

	Base64Coder::m_DecodeTable['=']				= -1;
	Base64Coder::m_DecodeTable['='|0x80]		= -1;

	Base64Coder::m_Init = TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\mkschema\main.cpp ===
#include "stdafx.hxx"
#include "vs_inc.hxx"

static unsigned s_iwcDocBegin;
static unsigned s_iwcDocEnd;


unsigned PrintStringToFile(FILE *file, LPCWSTR wsz, bool bPrintRootElement)
	{
	const WCHAR *pwc = wsz;
	fputc('{', file);
	unsigned ich = 0;

	if (bPrintRootElement)
		{
		fputs("L'<', L'r', L'o', L'o', L't', L'>', L'\\n', ", file);
		ich = 7;
		}

	s_iwcDocBegin = ich;


	while(*pwc != L'\0')
		{
		if ((ich++ % 10) == 0)
			fputc('\n', file);

		fprintf(file, "L'");

		if (*pwc == L'\\')
			{
			fputc('\\', file);
			fputc('\\', file);
			}
		else if (*pwc == L'\n')
			{
			fputc('\\', file);
			fputc('n', file);
			}
		else if (*pwc == L'\r')
			{
			fputc('\\', file);
			fputc('r', file);
			}
		else if (*pwc == L'\t')
			{
			fputc('\\', file);
			fputc('t', file);
			}
		else if (*pwc == L'\'')
			{
			fputc('\\', file);
			fputc('\'', file);
			}
		else
			fputc((char) *pwc, file);

		fprintf(file, "', ");
		pwc++;
		}

	s_iwcDocEnd = ich;

	if (bPrintRootElement)
		{
		fputc('\n', file);
		fputs("L'\\n', L'<', L'/', L'r', L'o', L'o', L't', L'>', L'\\n', ", file);
		ich += 9;
		}


	fprintf(file, "L'\\0'\n};");

	return ich;
	}

extern "C" __cdecl wmain(int, WCHAR **)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"main");

	CXMLDocument doc;

	try
		{
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"CoInitialize failed.  hr = 0x%08lx",
				ft.hr
				);

		if (!doc.LoadFromFile(L"writermetadata.xml"))
			{
			printf("Cannot load writermetadata.xml\n");
			exit(-1);
			}

		CComBSTR bstr = doc.SaveAsXML();
		FILE *f = fopen("wmxml.c", "w");
		if (f == NULL)
			{
			printf("create of wmxml.c failed\n");
			exit(-1);
			}

		fprintf(f, "WCHAR g_WriterMetadataXML[] = \n");
		unsigned cwc = PrintStringToFile(f, bstr, false);
		fprintf
			(
			f,
			"\nunsigned g_cwcWriterMetadataXML = %d;\n\n",
			cwc
			);

		bstr.Empty();
		fclose(f);

		if (!doc.LoadFromFile(L"componentmetadata.xml"))
			{
			printf("Cannot load componentmetadata.xml\n");
			exit(-1);
			}

		bstr = doc.SaveAsXML();
		f = fopen("cmxml.c", "w");
		if (f == NULL)
			{
			printf("create of cmxml.c failed\n");
			exit(-1);
			}

		fprintf(f, "WCHAR g_ComponentMetadataXML[] = \n");
		cwc = PrintStringToFile(f, bstr, true);
		fprintf
			(
			f,
			"\nunsigned g_cwcComponentMetadataXML = %d;\n\n",
			cwc
			);

		fprintf
			(
			f,
			"\nunsigned g_iwcComponentMetadataXMLBegin = %d;\n\n",
			s_iwcDocBegin
			);

		fprintf
			(
			f,
			"\nunsigned g_iwcComponentMetadataXMLEnd = %d;\n\n",
			s_iwcDocEnd
			);

		fclose(f);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{
		printf("Unexpected exception, hr = 0x%08lx", ft.hr);
		exit(-1);
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\wmxml.c ===
WCHAR g_WriterMetadataXML[] = 
{
L'<', L'S', L'c', L'h', L'e', L'm', L'a', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'V', L's', L's', L'W', L'r', L'i', 
L't', L'e', L'r', L'M', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'I', L'n', L'f', L'o', L'"', L' ', L'x', L'm', L'l', 
L'n', L's', L'=', L'"', L'u', L'r', L'n', L':', L's', L'c', 
L'h', L'e', L'm', L'a', L's', L'-', L'm', L'i', L'c', L'r', 
L'o', L's', L'o', L'f', L't', L'-', L'c', L'o', L'm', L':', 
L'x', L'm', L'l', L'-', L'd', L'a', L't', L'a', L'"', L' ', 
L'x', L'm', L'l', L'n', L's', L':', L'd', L't', L'=', L'"', 
L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', 
L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', 
L't', L'-', L'c', L'o', L'm', L':', L'd', L'a', L't', L'a', 
L't', L'y', L'p', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', L'c', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'F', L'i', L'l', L'e', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', 
L'i', L'o', L'n', L'.', L' ', L' ', L'C', L'a', L'n', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', L'i', 
L'l', L'd', L'c', L'a', L'r', L'd', L' ', L'c', L'h', L'a', 
L'r', L'a', L'c', L't', L'e', L'r', L's', L' ', L'?', L' ', 
L'a', L'n', L'd', L' ', L'*', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'P', L'a', L't', 
L'h', L' ', L't', L'o', L' ', L'a', L' ', L'f', L'i', L'l', 
L'e', L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'p', L'a', 
L't', L'h', L' ', L'c', L'a', L'n', L' ', L'i', L'n', L'c', 
L'l', L'u', L'd', L'e', L' ', L'e', L'n', L'v', L'i', L'r', 
L'o', L'n', L'm', L'e', L'n', L't', L' ', L'v', L'a', L'r', 
L'i', L'a', L'b', L'l', L'e', L's', L' ', L'o', L'r', L'\r', 
L'\n', L' ', L' ', L' ', L'v', L'a', L'l', L'u', L'e', L's', 
L' ', L'e', L'x', L't', L'r', L'a', L'c', L't', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L'r', L'e', L'g', L'i', 
L's', L't', L'r', L'y', L' ', L'k', L'e', L'y', L's', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', 
L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'I', 
L's', L' ', L'p', L'a', L't', L'h', L' ', L's', L'p', L'e', 
L'c', L'i', L'f', L'i', L'e', L'd', L' ', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L' ', L'o', L'r', L' ', 
L'l', L'i', L'm', L'i', L't', L'e', L'd', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L' ', L'd', L'i', L'r', L'e', L'c', 
L't', L'o', L'r', L'y', L' ', L't', L'h', L'a', L't', L' ', 
L'i', L's', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'A', L'l', L't', L'e', L'r', L'n', L'a', 
L't', L'e', L' ', L'p', L'a', L't', L'h', L' ', L'i', L'n', 
L' ', L'w', L'h', L'i', L'c', L'h', L' ', L't', L'o', L' ', 
L'f', L'i', L'n', L'd', L' ', L't', L'h', L'e', L' ', L'f', 
L'i', L'l', L'e', L'.', L' ', L' ', L'F', L'i', L'l', L'e', 
L's', L' ', L'i', L'n', L' ', L'a', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L' ', L'm', L'a', 
L'y', L'\r', L'\n', L' ', L' ', L' ', L'h', L'a', L'v', L'e', 
L' ', L'b', L'e', L'e', L'n', L' ', L'c', L'o', L'p', L'i', 
L'e', L'd', L' ', L't', L'o', L' ', L'a', L'n', L' ', L'a', 
L'l', L't', L'e', L'r', L'n', L'a', L't', L'i', L'v', L'e', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'b', L'y', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L'.', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L' ', L's', L'h', L'o', L'u', L'l', L'd', L'\r', 
L'\n', L' ', L' ', L' ', L'p', L'i', L'c', L'k', L' ', L'u', 
L'p', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', 
L' ', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'i', 
L'v', L'e', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'i', L'n', L's', L't', L'e', L'a', L'd', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L'\r', L'\n', L' ', L' ', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'b', 
L'u', L't', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L'P', L'a', L't', L'h', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'L', L'o', L'g', L'i', L'c', L'a', L'l', L' ', 
L'p', L'a', L't', L'h', L' ', L'f', L'o', L'r', L' ', L'a', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L'.', L' ', L' ', L'T', L'h', L'i', L's', 
L' ', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L' ', L'n', 
L'a', L'm', L'e', L' ', L'u', L's', L'e', L's', L' ', L'b', 
L'a', L'c', L'k', L's', L'l', L'a', L's', L'h', L'\r', L'\n', 
L' ', L' ', L' ', L'a', L's', L' ', L's', L'e', L'p', L'a', 
L'r', L'a', L't', L'o', L'r', L's', L' ', L't', L'o', L' ', 
L'f', L'o', L'r', L'm', L' ', L'a', L' ', L'l', L'o', L'g', 
L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', L's', 
L'p', L'a', L'c', L'e', L' ', L'h', L'i', L'e', L'r', L'a', 
L'r', L'c', L'h', L'y', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'N', L'a', L'm', L'e', L' ', 
L'u', L's', L'e', L'd', L' ', L't', L'o', L' ', L'i', L'd', 
L'e', L'n', L't', L'i', L'f', L'y', L' ', L'a', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'.', L' ', L' ', L'M', L'a', L'y', L' ', L'b', L'e', 
L' ', L'q', L'u', L'a', L'l', L'i', L'f', L'i', L'e', L'd', 
L' ', L'b', L'y', L' ', L'a', L'\r', L'\n', L' ', L' ', L' ', 
L'l', L'o', L'g', L'i', L'c', L'a', L'l', L' ', L'p', L'a', 
L't', L'h', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L'M', L'e', L't', L'a', L'd', L'a', L't', L'a', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'R', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L' ', L'e', L'x', L'i', L's', L't', 
L's', L' ', L'f', L'o', L'r', L' ', L't', L'h', L'i', L's', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L'.', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', L'a', L'p', L'p', 
L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'c', L'a', L'p', L't', 
L'u', L'r', L'e', L' ', L't', L'h', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L'p', 
L'a', L's', L's', L' ', L'i', L't', L' ', L't', L'o', L' ', 
L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'o', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'n', L'o', 
L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', L'c', L'k', 
L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'W', L'r', 
L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L'n', L'o', L't', L'i', L'f', 
L'i', L'e', L'd', L' ', L'w', L'h', L'e', L'n', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'i', L's', L' ', L'c', 
L'o', L'm', L'p', L'l', L'e', L't', L'e', L' ', L'w', L'h', 
L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', L'i', L's', 
L'\r', L'\n', L' ', L' ', L' ', L'd', L'a', L't', L'a', L'b', 
L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L' ', L'w', L'a', 
L's', L' ', L's', L'u', L'c', L'c', L'e', L's', L's', L'f', 
L'u', L'l', L'l', L'y', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L'o', L'r', L' ', L'n', L'o', 
L't', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'c', L'a', L'p', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'T', L'e', L'x', L't', 
L'u', L'a', L'l', L' ', L'D', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'i', L'c', L'o', L'n', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'I', L'c', L'o', L'n', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', 
L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', 
L'g', L'r', L'o', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', 
L'e', L'c', L't', L'a', L'b', L'l', L'e', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'y', 
L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'I', L's', L' ', L't', 
L'h', L'i', L's', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L' ', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L' ', L'f', L'o', L'r', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'o', L'r', L' ', L'i', 
L's', L' ', L'i', L't', L' ', L'a', L'l', L'w', L'a', L'y', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L'I', L'f', L' ', 
L'n', L'o', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L' ', L'i', L's', L' ', L'a', L'l', L'w', L'a', 
L'y', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', 
L'u', L'p', L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', 
L'o', L't', L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L's', L' ', L'o', L'f', L'\r', 
L'\n', L' ', L' ', L' ', L't', L'h', L'e', L' ', L'a', L'p', 
L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L'/', 
L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', L'r', 
L'e', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L' ', L' ', L'I', L'f', L' ', L'y', L'e', L's', 
L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L' ', L'm', L'a', L'y', L' ', L'b', 
L'e', L' ', L's', L'e', L'l', L'e', L'c', L't', L'i', L'v', 
L'e', L'l', L'y', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'v', L'e', L'r', L's', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'1', L'.', 
L'0', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L'V', L'e', L'r', L's', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'c', L' ', L'd', L'o', L'c', L'u', L'm', L'e', L'n', L't', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', L'd', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'u', L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L'U', L'n', L'i', L'q', L'u', L'e', 
L' ', L'i', L'd', L' ', L't', L'o', L' ', L'i', L'd', L'e', 
L'n', L't', L'i', L'f', L'y', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L' ', L' ', L'N', 
L'o', L't', L'e', L' ', L't', L'h', L'a', L't', L' ', L't', 
L'h', L'i', L's', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'i', L'e', L's', L' ', L't', L'h', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', 
L'c', L'l', L'a', L's', L's', L' ', L'r', L'a', L't', L'h', 
L'e', L'r', L' ', L't', L'h', L'a', L'n', L' ', L'a', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'i', 
L'n', L's', L't', L'a', L'n', L'c', L'e', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L'I', L'd', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'U', L'n', L'i', 
L'q', L'u', L'e', L' ', L'i', L'd', L' ', L'i', L'd', L'e', 
L'n', L't', L'i', L'f', L'y', L'i', L'n', L'g', L' ', L't', 
L'h', L'e', L' ', L'i', L'n', L's', L't', L'a', L'n', L'c', 
L'e', L' ', L'o', L'f', L' ', L'a', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'd', L'u', L'r', L'i', L'n', L'g', 
L' ', L'b', L'a', L'c', L'k', L'u', L'p', L'.', L' ', L' ', 
L'I', L't', L'\r', L'\n', L' ', L' ', L' ', L'h', L'a', L's', 
L' ', L'n', L'o', L' ', L'm', L'e', L'a', L'n', L'i', L'n', 
L'g', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'W', L'R', L'I', 
L'T', L'E', L'R', L'_', L'M', L'E', L'T', L'A', L'D', L'A', 
L'T', L'A', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'o', 
L'p', L'e', L'n', L'"', L' ', L'o', L'r', L'd', L'e', L'r', 
L'=', L'"', L'o', L'n', L'e', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'I', L'n', L'f', L'o', L'r', L'm', L'a', L't', 
L'i', L'o', L'n', L' ', L'u', L's', L'e', L'd', L' ', L'b', 
L'y', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L'a', 
L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L't', L'o', L' ', L'b', L'a', L'c', L'k', L'u', L'p', 
L'/', L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'd', 
L'a', L't', L'a', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'I', L'D', L'E', L'N', L'T', L'I', L'F', L'I', 
L'C', L'A', L'T', L'I', L'O', L'N', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'B', L'A', 
L'C', L'K', L'U', L'P', L'_', L'L', L'O', L'C', L'A', L'T', 
L'I', L'O', L'N', L'S', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'M', L'E', 
L'T', L'H', L'O', L'D', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'I', L'D', L'E', L'N', L'T', L'I', L'F', L'I', L'C', L'A', 
L'T', L'I', L'O', L'N', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', 
L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'I', L'd', L'e', L'n', L't', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', 
L'a', L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L'/', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'b', L'a', L'c', L'k', L'i', L'n', L'g', L' ', 
L'u', L'p', L' ', L'd', L'a', L't', L'a', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'f', L'r', L'i', L'e', L'n', L'd', L'l', L'y', L'N', 
L'a', L'm', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'F', L'r', L'i', L'e', L'n', L'd', L'l', 
L'y', L' ', L'n', L'a', L'm', L'e', L' ', L'u', L's', L'e', 
L'd', L' ', L't', L'o', L' ', L'd', L'e', L's', L'c', L'r', 
L'i', L'b', L'e', L' ', L't', L'h', L'e', L' ', L's', L'e', 
L'r', L'v', L'i', L'c', L'e', L' ', L'o', L'r', L' ', L'a', 
L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'u', L's', 
L'a', L'g', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'U', L'S', 
L'E', L'R', L'_', L'D', L'A', L'T', L'A', L' ', L'B', L'O', 
L'O', L'T', L'A', L'B', L'L', L'E', L'_', L'S', L'Y', L'S', 
L'T', L'E', L'M', L'_', L'S', L'T', L'A', L'T', L'E', L' ', 
L'S', L'Y', L'S', L'T', L'E', L'M', L'_', L'S', L'E', L'R', 
L'V', L'I', L'C', L'E', L' ', L'O', L'T', L'H', L'E', L'R', 
L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', 
L'"', L'O', L'T', L'H', L'E', L'R', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'H', L'o', L'w', L' ', L't', L'h', 
L'e', L' ', L'd', L'a', L't', L'a', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'i', L's', L' ', L'u', L's', L'e', 
L'd', L'.', L' ', L' ', L'F', L'o', L'r', L' ', L'n', L'o', 
L'w', L' ', L'w', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'd', L'i', L's', L't', L'i', L'n', L'g', L'u', 
L'i', L's', L'h', L' ', L'u', L's', L'e', L'r', L' ', L'd', 
L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L's', L'y', 
L's', L't', L'e', L'm', L' ', L's', L't', L'a', L't', L'e', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'd', L'a', 
L't', L'a', L'S', L'o', L'u', L'r', L'c', L'e', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'T', L'R', L'A', L'N', L'S', L'A', L'C', 
L'T', L'I', L'O', L'N', L'_', L'D', L'B', L' ', L'N', L'O', 
L'N', L'T', L'R', L'A', L'N', L'S', L'A', L'C', L'T', L'I', 
L'O', L'N', L'A', L'L', L'_', L'D', L'B', L' ', L'O', L'T', 
L'H', L'E', L'R', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'O', L'T', L'H', L'E', L'R', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'D', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'n', L'a', L't', L'u', 
L'r', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'd', L'a', L't', L'a', L' ', L'm', L'a', L'n', L'a', L'g', 
L'e', L'r', L'.', L' ', L' ', L'C', L'u', L'r', L'r', L'e', 
L'n', L't', L'l', L'y', L' ', L'o', L'n', L'l', L'y', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L's', L' ', L'a', L'r', L'e', 
L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'i', L'e', 
L'd', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L'I', L'd', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', 
L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'r', L'i', L'e', L'n', 
L'd', L'l', L'y', L'N', L'a', L'm', L'e', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'u', L's', L'a', L'g', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'd', L'a', L't', L'a', L'S', L'o', L'u', L'r', L'c', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'L', 
L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'S', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', 
L'm', L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'F', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'a', L'n', 
L'd', L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L' ', 
L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'I', L'N', L'C', L'L', L'U', L'D', L'E', 
L'_', L'F', L'I', L'L', L'E', L'S', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'E', L'X', L'C', L'L', L'U', L'D', L'E', L'_', 
L'F', L'I', L'L', L'E', L'S', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'D', L'A', L'T', L'A', L'B', L'A', L'S', L'E', L'"', 
L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'0', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'F', L'I', L'L', L'E', L'_', 
L'G', L'R', L'O', L'U', L'P', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'I', L'N', L'C', L'L', L'U', L'D', L'E', L'_', L'F', 
L'I', L'L', L'E', L'S', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'F', L'i', L'l', 
L'e', L's', L' ', L't', L'o', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'e', L' ', L'i', L'n', L' ', L't', L'h', L'e', 
L' ', L'b', L'a', L'c', L'k', L'u', L'p', L',', L' ', L'e', 
L's', L's', L'e', L'n', L't', L'i', L'a', L'l', L'l', L'y', 
L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'i', L'f', L' ', 
L'y', L'o', L'u', L' ', L'w', L'a', L'n', L't', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L't', L'o', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L't', L'h', L'i', L's', 
L' ', L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L'/', L's', L'e', L'r', L'v', L'i', L'c', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', 
L'l', L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', 
L't', L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'E', L'X', 
L'C', L'L', L'U', L'D', L'E', L'_', L'F', L'I', L'L', L'E', 
L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'F', L'i', L'l', L'e', L's', L' ', 
L't', L'h', L'a', L't', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'a', L'l', L'w', L'a', L'y', L's', L' ', L'b', 
L'e', L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', L'h', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', 
L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', L'u', 
L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', 
L'A', L'B', L'A', L'S', L'E', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'L', L'i', 
L's', L't', L' ', L'o', L'f', L' ', L'd', L'a', L't', L'a', 
L'b', L'a', L's', L'e', L's', L' ', L'o', L'f', L' ', L'i', 
L'n', L't', L'e', L'r', L'e', L's', L't', L'.', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'i', L's', L' ', L'u', L's', 
L'e', L'd', L' ', L't', L'o', L' ', L'a', L'l', L'l', L'o', 
L'w', L' ', L's', L'e', L'l', L'e', L'c', L't', L'i', L'v', 
L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'a', L'n', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'o', L'f', 
L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L's', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'c', L'a', L'p', L't', L'i', L'o', L'n', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'i', L'c', L'o', L'n', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'r', L'e', L's', L't', L'o', L'r', L'e', L'M', L'e', 
L't', L'a', L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'n', L'o', L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', 
L'c', L'k', L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', 
L't', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'a', L'b', L'l', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'A', 
L'T', L'A', L'B', L'A', L'S', L'E', L'_', L'F', L'I', L'L', 
L'E', L'S', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'A', 
L'T', L'A', L'B', L'A', L'S', L'E', L'_', L'L', L'O', L'G', 
L'F', L'I', L'L', L'E', L'S', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', 
L'A', L'B', L'A', L'S', L'E', L'_', L'F', L'I', L'L', L'E', 
L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', 
L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'L', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L's', L'e', L't', L' ', L'o', L'f', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L'.', L' ', L' ', L'F', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L' ', L'c', L'a', L'n', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', L'i', 
L'l', L'd', L'c', L'a', L'r', L'd', L's', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', L'A', L'B', 
L'A', L'S', L'E', L'_', L'L', L'O', L'G', L'F', L'I', L'L', 
L'E', L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'L', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L'a', L' ', L's', L'e', L't', L' ', L'o', L'f', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'l', L'o', L'g', L' ', L'f', L'i', L'l', L'e', L's', L'.', 
L' ', L' ', L'F', L'i', L'l', L'e', L's', L'p', L'e', L'c', 
L' ', L'c', L'a', L'n', L' ', L'i', L'n', L'c', L'l', L'u', 
L'd', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'w', L'i', L'l', L'd', L'c', L'a', L'r', L'd', L's', L'.', 
L' ', L' ', L'I', L'n', L'd', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'w', L'h', L'e', L't', 
L'h', L'e', L'r', L' ', L'd', L'a', L't', L'a', L'b', L'a', 
L's', L'e', L' ', L'l', L'o', L'g', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'a', L'r', L'e', L' ', L't', L'r', L'u', 
L'n', L'c', L'a', L't', L'e', L'd', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'F', L'I', L'L', L'E', L'_', 
L'G', L'R', L'O', L'U', L'P', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'A', L' ', 
L'n', L'a', L'm', L'e', L'd', L' ', L'g', L'r', L'o', L'u', 
L'p', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L'.', L' ', L' ', L'U', L's', L'e', L'd', L' ', L't', L'o', 
L' ', L'g', L'r', L'o', L'u', L'p', L' ', L's', L'e', L't', 
L's', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L't', L'o', L' ', L'a', L' ', L'g', L'r', 
L'o', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L't', L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', 
L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', 
L't', L'o', L'g', L'e', L't', L'h', L'e', L'r', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'l', L'o', 
L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', L'h', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'c', L'a', L'p', L't', L'i', L'o', L'n', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'i', L'c', L'o', L'n', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'M', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'n', L'o', 
L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', L'c', L'k', 
L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'F', L'I', L'L', L'E', 
L'_', L'L', L'I', L'S', L'T', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'F', L'I', L'L', 
L'E', L'_', L'L', L'I', L'S', L'T', L'"', L' ', L'c', L'o', 
L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', 
L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', 
L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'L', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'a', L' ', L's', L'e', 
L't', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L' ', L'a', L' ', L'F', L'I', L'L', L'E', 
L'_', L'G', L'R', L'O', L'U', L'P', L'.', L' ', L' ', L'F', 
L'i', L'l', L'e', L's', L'p', L'e', L'c', L' ', L'c', L'a', 
L'n', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'w', L'i', L'l', 
L'd', L'c', L'a', L'r', L'd', L's', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'M', L'E', L'T', L'H', L'O', L'D', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'o', L'p', L'e', L'n', 
L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', 
L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L'H', L'o', L'w', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L's', L'h', 
L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'p', L'e', 
L'r', L'f', L'o', L'r', L'm', L'e', L'd', L'.', L' ', L' ', 
L'I', L'n', L'c', L'l', L'u', L'd', L'e', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'h', L'o', L'w', L' ', 
L'f', L'i', L'l', L'e', L's', L'\r', L'\n', L' ', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L'a', L's', 
L' ', L'w', L'e', L'l', L'l', L' ', L'a', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'a', L'l', L' ', L's', L't', L'e', 
L'p', L's', L' ', L't', L'h', L'a', L't', L' ', L's', L'h', 
L'o', L'u', L'l', L'd', L' ', L'o', L'c', L'c', L'u', L'r', 
L' ', L'i', L'n', L' ', L'o', L'r', L'd', L'e', L'r', L'\r', 
L'\n', L' ', L' ', L't', L'o', L' ', L'c', L'o', L'm', L'p', 
L'l', L'e', L't', L'e', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'm', L'e', L't', L'h', L'o', L'd', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'R', L'E', L'S', L'T', 
L'O', L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', 
L'E', L'_', L'T', L'H', L'E', L'R', L'E', L'\r', L'\n', L'\t', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'I', L'F', 
L'_', L'C', L'A', L'N', L'_', L'B', L'E', L'_', L'R', L'E', 
L'P', L'L', L'A', L'C', L'E', L'D', L'\r', L'\n', L'\t', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'S', 
L'T', L'O', L'P', L'_', L'R', L'E', L'S', L'T', L'A', L'R', 
L'T', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', 
L'T', L'O', L'_', L'A', L'L', L'T', L'E', L'R', L'N', L'A', 
L'T', L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', 
L'N', L'\r', L'\n', L'\t', L'\t', L'\t', L' ', L' ', L' ', L' ', 
L'C', L'U', L'S', L'T', L'O', L'M', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', L'E', 
L'_', L'T', L'H', L'E', L'R', L'E', L':', L' ', L'i', L'.', 
L'e', L'.', L',', L' ', L'c', L'a', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'd', L'a', L't', L'a', 
L' ', L'i', L'f', L' ', L'i', L't', L' ', L'i', L's', L' ', 
L'n', L'o', L't', L' ', L'a', L't', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'i', L't', L' ', 
L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L' ', L'f', L'r', L'o', L'm', L'.', L' ', 
L' ', L'T', L'h', L'i', L's', L' ', L'e', L's', L's', L'e', 
L'n', L't', L'i', L'a', L'l', L'l', L'y', L' ', L'a', L'l', 
L'l', L'o', L'w', L's', L'\r', L'\n', L'\t', L' ', L' ', L'd', 
L'a', L't', L'a', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'o', L' ', L'a', L' ', L'c', L'l', L'e', L'a', L'n', L' ', 
L's', L'y', L's', L't', L'e', L'm', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'I', L'F', L'_', L'C', L'A', L'N', L'_', 
L'B', L'E', L'_', L'R', L'E', L'P', L'L', L'A', L'C', L'E', 
L'D', L':', L' ', L'R', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L'i', L'f', L' ', L'a', 
L'l', L'l', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'f', L'i', L'l', L'e', L's', L' ', L'c', L'a', L'n', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', 
L'e', L'd', L' ', L'i', L'n', L' ', L't', L'h', L'e', L' ', 
L'o', L'r', L'g', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L' ', L' ', L'F', L'a', 
L'i', L'l', L's', L' ', L'i', L'f', L' ', L'a', L'n', L'y', 
L' ', L'o', L'f', L'\r', L'\n', L'\t', L' ', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L'r', 
L'e', L' ', L'o', L'p', L'e', L'n', L'.', L' ', L' ', L'I', 
L'f', L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L' ', L'l', L'o', L'c', L'a', L't', 
L'i', L'o', L'n', L' ', L'i', L's', L' ', L'p', L'r', L'o', 
L'v', L'i', L'd', L'e', L'd', L',', L' ', L'f', L'i', L'l', 
L'e', L's', L'\r', L'\n', L'\t', L' ', L' ', L'w', L'i', L'l', 
L'l', L' ', L'b', L'e', L' ', L'p', L'l', L'a', L'c', L'e', 
L'd', L' ', L't', L'h', L'e', L'r', L'e', L' ', L'i', L'f', 
L' ', L't', L'h', L'e', L'y', L' ', L'c', L'a', L'n', L'n', 
L'o', L't', L' ', L'b', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', 
L'e', L'i', L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', 
L'a', L'l', L'\r', L'\n', L'\t', L' ', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'S', L'T', L'O', L'P', L'_', 
L'R', L'E', L'S', L'T', L'A', L'R', L'T', L'_', L'S', L'E', 
L'R', L'V', L'I', L'C', L'E', L':', L' ', L's', L't', L'o', 
L'p', L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', 
L'(', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'm', 
L'u', L's', L't', L' ', L'b', L'e', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L')', L'.', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L'.', L'\r', L'\n', L'\t', L' ', L' ', L'R', L'e', L's', 
L't', L'a', L'r', L't', L' ', L's', L'e', L'r', L'v', L'i', 
L'c', L'e', L'.', L' ', L' ', L'F', L'a', L'i', L'l', L's', 
L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'a', L'r', L'e', L' ', L'o', L'p', L'e', L'n', L' ', 
L'a', L'f', L't', L'e', L'r', L' ', L't', L'h', L'e', L'\r', 
L'\n', L'\t', L' ', L' ', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L' ', L'i', L's', L' ', L's', L't', L'o', L'p', L'p', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L':', 
L' ', L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', L'a', L' ', 
L't', L'e', L'm', L'p', L'o', L'r', L'a', L'r', L'y', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', L' ', 
L' ', L'U', L's', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'M', L'o', L'v', L'e', 
L'F', L'i', L'l', L'e', L'E', L'x', L' ', L't', L'o', L' ', 
L'r', L'e', L'p', L'l', L'a', L'c', L'e', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L't', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', 
L'T', L'O', L'R', L'E', L'_', L'T', L'O', L'_', L'A', L'L', 
L'T', L'E', L'R', L'N', L'A', L'T', L'I', L'V', L'E', L'_', 
L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', L':', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'a', L'n', L' ', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'T', L'y', L'p', L'i', L'c', L'a', L'l', L'l', 
L'y', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'w', L'i', L'l', L'l', 
L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', L' ', 
L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L'\t', L' ', L' ', 
L'w', L'i', L'l', L'l', L' ', L'p', L'a', L'r', L't', L'i', 
L'c', L'i', L'p', L'a', L't', L'e', L' ', L'i', L'n', L' ', 
L't', L'h', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'p', L'r', L'o', L'c', L'e', L's', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'C', L'U', 
L'S', L'T', L'O', L'M', L':', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'p', L'r', L'o', L'c', L'e', L's', 
L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', L'b', 
L'e', L' ', L'e', L'x', L'p', L'r', L'e', L's', L's', L'e', 
L'd', L' ', L'u', L's', L'i', L'n', L'g', L' ', L't', L'h', 
L'i', L's', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'M', L'u', L's', L't', L' ', L'b', L'e', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L' ', L'i', L'f', 
L' ', L'm', L'e', L't', L'h', L'o', L'd', L'=', L'"', L'S', 
L'T', L'O', L'P', L'_', L'R', L'E', L'S', L'T', L'A', L'R', 
L'T', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', L'"', 
L',', L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L's', 
L'e', L'r', L'v', L'i', L'c', L'e', L' ', L't', L'o', L' ', 
L'b', L'e', L' ', L's', L't', L'o', L'p', L'p', L'e', L'd', 
L' ', L'b', L'e', L'f', L'o', L'r', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'i', L'n', L'g', L' ', L'f', L'i', 
L'l', L'e', L's', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', 
L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'a', 
L'l', L'w', L'a', L'y', L's', L' ', L'n', L'e', L'v', L'e', 
L'r', L' ', L'i', L'f', L'R', L'e', L'p', L'l', L'a', L'c', 
L'e', L'F', L'a', L'i', L'l', L's', L'"', L' ', L'd', L'e', 
L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', L'e', L'v', 
L'e', L'r', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'W', L'h', L'e', L't', L'h', L'e', L'r', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L'i', L'n', L'v', L'o', L'k', 
L'e', L'd', L' ', L'a', L'f', L't', L'e', L'r', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', L'o', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'i', 
L's', L'k', L'.', L' ', L' ', L'O', L'p', L't', L'i', L'o', 
L'n', L's', L' ', L'a', L'r', L'e', L' ', L'a', L'l', L'w', 
L'a', L'y', L's', L',', L' ', L'n', L'e', L'v', L'e', L'r', 
L',', L' ', L'a', L'n', L'd', L' ', L'i', L'f', L'R', L'e', 
L'p', L'l', L'a', L'c', L'e', L'F', L'a', L'i', L'l', L's', 
L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'l', L'a', L't', 
L't', L'e', L'r', L' ', L'm', L'e', L'a', L'n', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L't', L'h', L'a', 
L't', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'w', L'i', L'l', L'l', L' ', L'b', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'o', L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', 
L'i', L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L' ', L' ', L'I', L'f', 
L' ', L'o', L'n', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'o', L'r', L' ', L'm', L'o', L'r', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', 
L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', L'e', 
L'd', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'w', L'i', 
L'l', L'l', L' ', L'b', L'e', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L't', L'o', L' ', L'a', L'n', L' ', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'l', L'o', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'(', L'm', L'u', 
L's', L't', L' ', L'b', L'e', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L' ', L'v', L'i', L'a', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'A', L'L', L'T', 
L'E', L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', 
L'A', L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', 
L'I', L'N', L'G', L'.', L' ', L' ', L'A', L'f', L't', L'e', 
L'r', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'a', L'r', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L',', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'i', L's', L' ', L'i', L'n', L'v', 
L'o', L'k', L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'u', L's', L'e', L'r', L'P', L'r', L'o', L'c', 
L'e', L'd', L'u', L'r', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'r', L'i', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L'D', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L' ', L'o', L'f', L' ', L'a', L'c', L't', L'i', L'o', 
L'n', L's', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', 
L'e', L' ', L'u', L's', L'e', L'r', L' ', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'p', L'e', L'r', L'f', L'o', L'r', 
L'm', L' ', L't', L'o', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L'T', L'h', L'e', L' ', L'f', L'o', L'r', L'm', L'a', L't', 
L' ', L'o', L'f', L' ', L't', L'h', L'i', L's', L' ', L's', 
L't', L'r', L'i', L'n', L'g', L' ', L'h', L'a', L's', L' ', 
L'y', L'e', L't', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'd', L'e', L't', L'e', L'r', L'm', L'i', L'n', L'e', L'd', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', L'b', 
L'o', L'o', L't', L'R', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', 
L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L'S', L'h', L'o', L'u', L'l', L'd', L' ', L'a', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L' ', L'b', L'e', 
L' ', L'p', L'e', L'r', L'f', L'o', L'r', L'm', L'e', L'd', 
L' ', L'a', L'f', L't', L'e', L'r', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'i', L'n', L'g', L' ', L't', L'h', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L'f', L'o', L'r', L' ', 
L't', L'h', L'i', L's', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'm', 
L'e', L't', L'h', L'o', L'd', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L'e', L'r', L'v', L'i', L'c', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', L's', L't', 
L'o', L'r', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'u', L's', L'e', 
L'r', L'P', L'r', L'o', L'c', L'e', L'd', L'u', L'r', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'r', L'e', L'b', L'o', L'o', L't', 
L'R', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', L'E', L'_', 
L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'_', L'M', 
L'A', L'P', L'P', L'I', L'N', L'G', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', L'A', 
L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', L'I', 
L'N', L'G', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'M', 
L'a', L'p', L'p', L'i', L'n', L'g', L' ', L'f', L'r', L'o', 
L'm', L' ', L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L't', L'h', L'a', L't', L' ', L'w', L'a', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L' ', L't', L'o', L' ', L'a', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L't', L'o', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'o', L'.', 
L'\r', L'\n', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', 
L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'<', L'/', L'S', 
L'c', L'h', L'e', L'm', L'a', L'>', L'\r', L'\n', L'\0'
};
unsigned g_cwcWriterMetadataXML = 11978;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\async.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async.cxx | Implementation of CVssAsyncBackup object
    @end

Author:

    brian berkowitz  [brianb]  04/10/2000

Revision History:

    Name        Date        Comments
    brianb      04/10/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_sec.hxx"


// Generated file from Coord.IDL
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEASYNC"
//
////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//  CVssAsyncBackup


// constructor
CVssAsyncBackup::CVssAsyncBackup():
	m_hrState(S_OK),
	m_state(VSS_AS_UNDEFINED),
	m_pBackupComponents(NULL),
	m_bOwned(NULL)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::CVssAsyncBackup");

	m_bcsInitialized = false;
	try
		{
		// Initialize the critical section
		m_cs.Init();
		m_bcsInitialized = true;
		}
	VSS_STANDARD_CATCH(ft)
	}


// destructor
CVssAsyncBackup::~CVssAsyncBackup()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::~CVssAsyncBackup");

	try
		{
		// Wait for the worker thread to finish, if running.
		// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
		// Virtual methods in classes derived from CVssAsync are now inaccessible!
		FinalReleaseWorkerThreadObject();
		}
	VSS_STANDARD_CATCH(ft)
	}


// do operation by creating a thread to do it and return an IVssAsync object
// for backup to use
IVssAsync* CVssAsyncBackup::CreateInstanceAndStartJob
	(
	IN	CVssBackupComponents *	pBackupComponents,
	VSS_ASYNC_STATE				state
	)
	{
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    try
		{
		BS_ASSERT(state == VSS_AS_PREPARE_FOR_BACKUP ||
				  state == VSS_AS_BACKUP_COMPLETE ||
				  state == VSS_AS_PRERESTORE ||
				  state == VSS_AS_POSTRESTORE ||
				  state == VSS_AS_GATHER_WRITER_METADATA ||
				  state == VSS_AS_GATHER_WRITER_STATUS);

		BS_ASSERT(pBackupComponents);

        // Allocate the COM object.
        CComObject<CVssAsyncBackup>* pObject;
        ft.hr = CComObject<CVssAsyncBackup>::CreateInstance(&pObject);
        if (ft.HrFailed())
            ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr
				);

        if (!pObject->m_bcsInitialized)
            ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Error initializing critical section"
				);


        BS_ASSERT(pObject);

		// Setting async object internal data
        pObject->m_pBackupComponents = pBackupComponents;
		pObject->m_pvbcReference = pBackupComponents;
		pObject->m_state = state;

        // Querying the IVssSnapshot interface. Now the ref count becomes 1.
        CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
        BS_ASSERT(pUnknown);
        ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
        if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IVSSASYNC_FAILED, VSSDBG_XML << ft.hr);
            ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"Error querying the IVssAsync interface. hr = 0x%08lx",
				ft.hr
				);
            }

		BS_ASSERT(pAsync);

		// Prepare job (thread created in resume state)
		ft.hr = pObject->PrepareJob();
        if (ft.HrFailed())
            ft.Throw
				(
				VSSDBG_XML,
				ft.hr,
				L"CVssAsyncBackup::PrepareJob failed.  hr = 0x%08lx.",
				ft.hr
				);

		// increment reference count so that it lives throughout lifetime
		// of async thread
		pObject->GetUnknown()->AddRef();
		pObject->SetOwned();

		// Start job
		ft.hr = pObject->StartJob();
        if (ft.HrFailed())
			{
			// release reference held for thread
			pObject->ClearOwned();
			pObject->GetUnknown()->Release();
            ft.Throw
				(
				VSSDBG_XML,
				ft.hr,
				L"Error starting the job. hr = 0x%08lx",
				ft.hr
				);
			}

		// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
		}
    VSS_STANDARD_CATCH(ft)

	return pAsync.Detach();	  // The ref count remains 1.
	}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


// do basic initialization
bool CVssAsyncBackup::OnInit()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnInit");

    try
		{
		if (m_pBackupComponents != NULL)
			{
			BS_ASSERT(m_hrState == S_OK);
			m_hrState = VSS_S_ASYNC_PENDING;
			}
		}
    VSS_STANDARD_CATCH(ft)

	return m_pBackupComponents != NULL;
	}


// execute PrepareForBackup or BackupComplete
void CVssAsyncBackup::OnRun()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnRun");

	bool bCoInitializeSucceeded = false;

	try
		{
		// Check if the backup components object is created.
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw(VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		ft.CheckForError(VSSDBG_XML, L"CoInitializeEx");

        bCoInitializeSucceeded = true;
		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// save timestamp for operation
		m_timestamp = m_pBackupComponents->m_timestampOperation + 1;

		if (m_state == VSS_AS_PREPARE_FOR_BACKUP)
			{
			ft.hr = m_pBackupComponents->InternalPrepareForBackup();
			if (ft.HrFailed())
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal PrepareBackup failed. 0x%08lx",
					ft.hr
					);
            }
		else if (m_state == VSS_AS_BACKUP_COMPLETE)
			{
			ft.hr = m_pBackupComponents->InternalBackupComplete();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
			}
		else if (m_state == VSS_AS_PRERESTORE)
			{
			ft.hr = m_pBackupComponents->InternalPreRestore();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
            }
		else if (m_state == VSS_AS_POSTRESTORE)
			{
			ft.hr = m_pBackupComponents->InternalPostRestore();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
            }

		else if (m_state == VSS_AS_GATHER_WRITER_METADATA)
			{
			m_statePrevious = m_pBackupComponents->m_state;
			ft.hr = m_pBackupComponents->InternalGatherWriterMetadata();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal GatherWriterMetadata failed. 0x%08lx",
					ft.hr
					);
            }
		else
			{
			BS_ASSERT(m_state == VSS_AS_GATHER_WRITER_STATUS);
			m_statePrevious = m_pBackupComponents->m_state;
			ft.hr = m_pBackupComponents->InternalGatherWriterStatus();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal GatherWriterStatus failed. 0x%08lx",
					ft.hr
					);
            }

		if (ft.hr != S_OK)
			// Put the error code into the
			m_hrState = ft.hr;
		}
	VSS_STANDARD_CATCH(ft)

	if (bCoInitializeSucceeded)
		CoUninitialize();
	}


void CVssAsyncBackup::OnFinish()	
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnFinish");

    try
		{
		if (m_hrState == VSS_S_ASYNC_PENDING)
			m_hrState = VSS_S_ASYNC_FINISHED;

        // Mark the thread as finished, as the last operation
		MarkAsFinished();
		}
	VSS_STANDARD_CATCH(ft)

	// release interface pointer owned by the thread
	BS_ASSERT(m_bOwned);
	m_bOwned = false;
	Release();
	}


void CVssAsyncBackup::OnTerminate()
    {
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsyncBackup::OnTerminate" );
    }



/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssAsyncBackup::Cancel()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::Cancel");

	try
		{
		// The critical section will be left automatically at the end of scope.
		CVssSafeAutomaticLock lock(m_cs);

		// Safety check
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw(VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL");
			}

		// If thread is already finished, return correct code.
		if (m_hrState == VSS_S_ASYNC_FINISHED ||
			m_hrState == VSS_S_ASYNC_CANCELLED)
			ft.hr = m_hrState;
		else
			{
			m_hrState = VSS_S_ASYNC_CANCELLED;

			switch(m_state)
				{
				default:
					BS_ASSERT(FALSE);
					break;

				case VSS_AS_PREPARE_FOR_BACKUP:
					ft.hr = m_pBackupComponents->PostPrepareForBackup(m_timestamp);
					if (ft.HrFailed())
						m_hrState = ft.hr;

					break;

				case VSS_AS_BACKUP_COMPLETE:
					m_pBackupComponents->PostBackupComplete(m_timestamp);
					break;

				case VSS_AS_PRERESTORE:
					ft.hr = m_pBackupComponents->PostPreRestore(m_timestamp);
					if (ft.HrFailed())
						m_hrState = ft.hr;

					break;

				case VSS_AS_POSTRESTORE:
					ft.hr = m_pBackupComponents->PostPostRestore(m_timestamp);
					if (ft.HrFailed())
						m_hrState = ft.hr;

					break;


				case VSS_AS_GATHER_WRITER_STATUS:
					m_pBackupComponents->PostGatherWriterStatus
						(
						m_timestamp,
						m_statePrevious
						);

					break;

				case VSS_AS_GATHER_WRITER_METADATA:
					ft.hr = m_pBackupComponents->PostGatherWriterMetadata
						(
						m_timestamp,
						m_statePrevious
						);

					if (ft.HrFailed())
						m_hrState = ft.hr;

					break;
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


STDMETHODIMP CVssAsyncBackup::Wait()
{
	CVssFunctionTracer ft( VSSDBG_XML, L"CVssAsyncBackup::Wait" );

	try
		{
		// Safety check
		if (m_pBackupComponents == NULL)
			{
			BS_ASSERT(false);
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		// wait for thread to terminate
		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			{
			ft.LogError(VSS_ERROR_THREADHANDLE_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"invalid hThread");
			}

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
			{
			ft.LogError(VSS_ERROR_WAITFORSINGLEOBJECT, VSSDBG_XML << HRESULT_FROM_WIN32(GetLastError()));
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


STDMETHODIMP CVssAsyncBackup::QueryStatus
	(
	OUT     HRESULT* pHrResult,
	OUT     INT* pnReserved
	)
	{
	CVssFunctionTracer ft( VSSDBG_XML, L"CVssAsyncBackup::QueryStatus" );

	try
		{
		VssZeroOut(pHrResult);
		VssZeroOut(pnReserved);
		// Argument check
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL.");

		// The critical section will be left automatically at the end of scope.
		CVssSafeAutomaticLock lock(m_cs);

		// Safety check
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_XML, L"Returning *pHrResult: 0x%08x", *pHrResult );		
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



/////////////////////////////////////////////////////////////////////////////
//  IVssAsync Cover implementation


void CVssAsyncCover::CreateInstance(
    IN  CVssBackupComponents* pBackupComponents,
    IN  IVssAsync* pAsyncInternal,
    OUT IVssAsync** ppAsync
    ) throw(HRESULT)

/*++

Description:

    Creates a cover for a given IVssAsync and a backup components object.

Comments:

    This object is used to intercept all calls to the internal async QueryStatus

--*/

{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::CreateInstance");

    BS_ASSERT(pBackupComponents);
    BS_ASSERT(pAsyncInternal);
    BS_ASSERT(ppAsync && (*ppAsync == NULL));
	
	// create cover async object
	CComObject<CVssAsyncCover>* pObject;
	ft.hr = CComObject<CVssAsyncCover>::CreateInstance(&pObject);
	if (ft.HrFailed())
		ft.Throw
		(
		VSSDBG_XML,
		E_OUTOFMEMORY,
		L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr
		);

    // Fill out the data members (the ref counts are incremented)
	pObject->m_pvbc = pBackupComponents;
	pObject->m_pvbcReference = pBackupComponents;
	pObject->m_pAsync = pAsyncInternal;

	// Get the IVssAsync interface
	CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
	BS_ASSERT(pUnknown);
	CComPtr<IVssAsync> ptrAsync;
	ft.hr = pUnknown->SafeQI(IVssAsync, &ptrAsync);
	if (ft.HrFailed())
		{
		BS_ASSERT(FALSE && "QI shouldn't fail");
		ft.LogError(VSS_ERROR_QI_IVSSASYNC_FAILED, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"Error querying the IVssAsync interface. hr = 0x%08lx",
			ft.hr
			);
		}

    // Copy the interface to the out parameter
    ptrAsync.CopyTo(ppAsync);
}


STDMETHODIMP CVssAsyncCover::Cancel()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::Cancel");

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	ft.hr = m_pAsync->Cancel();
	if (ft.hr == VSS_S_ASYNC_FINISHED)
		{
		if (!m_bComponentsRebuilt)
			{
			try
				{
				m_pvbc->RebuildComponentData(ft);
				}
			VSS_STANDARD_CATCH(ft)

			m_pvbc->FreeWriterComponents();

			// indicate that rebuild components has been called
			m_bComponentsRebuilt = true;

			if (ft.HrFailed())
				{
				m_pvbc->m_state = x_StateDoSnapshotFailed;
				m_hrFailure = ft.hr;
				}
			}
		else if (m_pvbc->m_state == x_StateDoSnapshotFailed)
			ft.hr = m_hrFailure;
		else
			m_pvbc->m_state = x_StateDoSnapshotSucceeded;
		}
	else
		{
		if (!m_bComponentsRebuilt)
			{
			m_pvbc->FreeWriterComponents();
			m_bComponentsRebuilt = true;
			}

		m_pvbc->m_state = x_StateDoSnapshotFailed;
		}

	return ft.hr;
	}


STDMETHODIMP CVssAsyncCover::Wait()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::Wait");

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	ft.hr = m_pAsync->Wait();

	return ft.hr;
	}


STDMETHODIMP CVssAsyncCover::QueryStatus
	(
	OUT     HRESULT* pHrResult,
	OUT     INT* pnPercentDone
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::QueryStatus");

	if (pHrResult == NULL)
		return E_INVALIDARG;

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	try
		{
		ft.hr = m_pAsync->QueryStatus(pHrResult, pnPercentDone);
		if (*pHrResult == VSS_E_BAD_STATE)
			m_pvbc->m_state = x_StateDoSnapshotFailedWithoutSendingAbort;
		else if (FAILED(ft.hr) ||
			FAILED(*pHrResult) ||
			*pHrResult == VSS_S_ASYNC_CANCELLED)
			{
			if (!m_bComponentsRebuilt)
				{
				m_pvbc->FreeWriterComponents();
				m_bComponentsRebuilt = true;
				}

			m_pvbc->m_state = x_StateDoSnapshotFailed;
			}
		else if (*pHrResult == VSS_S_ASYNC_FINISHED)
			{
			if (m_pvbc->m_state == x_StateDoSnapshotFailed)
				// cancel was called previously and had a failure
				// rebuilding components
				*pHrResult = m_hrFailure;
			else
				{
				if (!m_bComponentsRebuilt)
					{
					try
						{
						m_pvbc->RebuildComponentData(ft);
						}
					VSS_STANDARD_CATCH(ft)

                    m_pvbc->FreeWriterComponents();
					

					m_bComponentsRebuilt = true;

					if (ft.HrFailed())
						{
						*pHrResult = ft.hr;
						m_hrFailure = ft.hr;
						m_pvbc->m_state = x_StateDoSnapshotFailed;
						}
					else
						m_pvbc->m_state = x_StateDoSnapshotSucceeded;
                    }
				else
					m_pvbc->m_state = x_StateDoSnapshotSucceeded;
				}
			}
		}
	 VSS_STANDARD_CATCH(ft)

	 return ft.hr;
	 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\inc\resource.h ===
// Used by svc.rc
//

#ifndef __VSS_RESOURCE_H__
#define __VSS_RESOURCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#define IDS_SERVICENAME                 100

#define IDR_VSSVC                       201
#define IDR_COORD                       202
#define IDR_MGMT                        203

#endif // __VSS_RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\vs_wmxml.cxx ===
/*++
Module Name:

    vs_wmxml.cxx

Abstract:

    Implementation of Writer Metadata XML wrapper classes

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/13/2000  Created
    brianb      03/22/2000  Added support CVssGatherWriterMetadata
    brianb	04/04/2000  Removed debug printf
    mikejohn	04/11/2000  Fix some loop iteration problems
    brianb      04/21/2000  code cleanup
    mikejohn	06/13/2000  minor tracing changes

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "vs_idl.hxx"
 #include "vssmsg.h"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"



#include "rpcdce.h"

#include "wmxml.c"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEWXMLC"
//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementWriterMetadata = L"WRITER_METADATA";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssWriterMetadataInfo";
static LPCWSTR x_wszDocProlog = L"<root>";
static LPCWSTR x_wszDocEpilog = L"</root>";

// identification element and its attributes
static LPCWSTR x_wszElementIdentification = L"IDENTIFICATION";
static LPCWSTR x_wszAttrWriterId = L"writerId";
static LPCWSTR x_wszAttrInstanceId = L"instanceId";
static LPCWSTR x_wszAttrFriendlyName = L"friendlyName";
static LPCWSTR x_wszAttrUsage = L"usage";
static LPCWSTR x_wszAttrDataSource = L"dataSource";

// backup location elements
static LPCWSTR x_wszElementBackupLocations = L"BACKUP_LOCATIONS";
static LPCWSTR x_wszElementIncludeFiles = L"INCLUDE_FILES";
static LPCWSTR x_wszElementExcludeFiles = L"EXCLUDE_FILES";
static LPCWSTR x_wszElementDatabase = L"DATABASE";
static LPCWSTR x_wszElementFilegroup = L"FILE_GROUP";

// RESTORE_METHOD element and it's attributes
static LPCWSTR x_wszElementRestoreMethod = L"RESTORE_METHOD";
static LPCWSTR x_wszAttrMethod = L"method";
static LPCWSTR x_wszAttrService = L"service";
static LPCWSTR x_wszAttrUserProcedure = L"userProcedure";
static LPCWSTR x_wszAttrWriterRestore = L"writerRestore";
static LPCWSTR x_wszAttrRebootRequired = L"rebootRequired";
static LPCWSTR x_wszElementAlternateMapping = L"ALTERNATE_LOCATION_MAPPING";

// attributes and elements associated with DATABASE and FILE_GROUP components
static LPCWSTR x_wszAttrLogicalPath = L"logicalPath";
static LPCWSTR x_wszAttrComponentName = L"componentName";
static LPCWSTR x_wszAttrCaption = L"caption";
static LPCWSTR x_wszAttrRestoreMetadata = L"restoreMetadata";
static LPCWSTR x_wszAttrNotifyOnBackupComplete = L"notifyOnBackupComplete";
static LPCWSTR x_wszAttrIcon = L"icon";
static LPCWSTR x_wszAttrSelectable = L"selectable";
static LPCWSTR x_wszElementDatabaseFiles = L"DATABASE_FILES";
static LPCWSTR x_wszElementDatabaseLogfiles = L"DATABASE_LOGFILES";
static LPCWSTR x_wszElementFilelist = L"FILE_LIST";

// attributes for a FILE_LIST, INCLUDE_FILES, EXCLUDE_FILES,
// or ALTERNATE_DESTINATION_MAPPING elements

static LPCWSTR x_wszAttrPath = L"path";
static LPCWSTR x_wszAttrFilespec = L"filespec";
static LPCWSTR x_wszAttrRecursive = L"recursive";
static LPCWSTR x_wszAttrAlternatePath = L"alternatePath";

// various attributes and values associated with toplevel WRITER_METADATA
// element
static LPCWSTR x_wszAttrVersion = L"version";
static LPCWSTR x_wszVersionNo = L"1.0";

bool CVssExamineWriterMetadata::LoadDocument(BSTR bstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::LoadDocument");

	BSTR bstr = NULL;

	try
		{
		// compute length of supplied XML document
		UINT cwcXML = (UINT) wcslen(bstrXML);

		// compute length of constructed document consisting of
		// a root node, schema, and supplied document
		UINT cwcDoc = cwcXML +
						  (UINT) g_cwcWriterMetadataXML +
                          (UINT) wcslen(x_wszDocProlog) +
                          (UINT) wcslen(x_wszDocEpilog);

        // allocate string
        bstr = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root>
	    wcscpy(pwc, x_wszDocProlog);
		pwc += wcslen(x_wszDocProlog);

		// copy in schema
		memcpy(pwc, g_WriterMetadataXML, g_cwcWriterMetadataXML* sizeof(WCHAR));
		pwc += g_cwcWriterMetadataXML;

		// copy in supplied WRITER_METADATA element
		memcpy(pwc, bstrXML, cwcXML * sizeof(WCHAR));
		pwc += cwcXML;

		// copy in </root>
		wcscpy(pwc, x_wszDocEpilog);

		// load document from string
		bool bLoaded = m_doc.LoadFromXML(bstr);

		// free allocated string
		SysFreeString(bstr);
		bstr = NULL;

		// check load success
		if (!bLoaded)
			return false;

		// find root element
		if (!m_doc.FindElement(x_wszElementRoot, TRUE))
			return false;

		// find WRITER_METADATA element
		if (!m_doc.FindElement(x_wszElementWriterMetadata, TRUE))
			return false;

		// set toplevel node to WRITER_METADATA element
		m_doc.SetToplevel();
		return true;
		}
	catch(...)
		{
		// free allocated string
		if (bstr != NULL)
			SysFreeString(bstr);

		throw;
		}
	}




// initialize metadata document from an XML string.  Return S_FALSE if
// the document is not correctly formed.
bool CVssExamineWriterMetadata::Initialize
	(
	IN BSTR bstrXML					// WRITER_METADATA element
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::Initialize");

	// temporary string containing XML document including schema
	InitializeHelper(ft);
	return LoadDocument(bstrXML);
	}

// obtain information from the IDENTIFICATION element
// implements IVssExamineWriterMetadata::GetIdentity
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either pidInstance, pidWriter, pbstrWriterName, pUsage,
//			or pSource is NULL
//		VSS_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetIdentity
	(
	OUT VSS_ID *pidInstance,		// instance id
	OUT VSS_ID *pidWriter,			// id of writer class
	OUT BSTR *pbstrWriterName,		// name of writer
	OUT VSS_USAGE_TYPE *pUsage,		// usage type for writer
	OUT VSS_SOURCE_TYPE *pSource    // type of data source for writer
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetIdentity"
		);

	try
		{
        // null output parameters
		if (pUsage)
			*pUsage = VSS_UT_UNDEFINED;

		if (pSource)
			*pSource = VSS_ST_UNDEFINED;

		VssZeroOut(pidInstance);
        VssZeroOut(pidWriter);
        VssZeroOut(pbstrWriterName);

		// check arguments
		if (pidInstance == NULL ||
			pidWriter == NULL ||
			pbstrWriterName == NULL ||
			pUsage == NULL ||
			pSource == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"NULL output parameter."
				);


		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
        m_doc.ResetToDocument();

		// look for child IDENTIFICATION element
		if (!m_doc.FindElement(x_wszElementIdentification, TRUE))
			MissingElement(ft, x_wszElementIdentification);

        VSS_ID idInstance;
		VSS_ID idWriter;
		CComBSTR bstrWriterName;
		VSS_USAGE_TYPE usage;
		VSS_SOURCE_TYPE source;


        // obtain instanceId attribute value
        get_VSS_IDValue(ft, x_wszAttrInstanceId, &idInstance);

		// obtain writerId attribute value
        get_VSS_IDValue(ft, x_wszAttrWriterId, &idWriter);

		// obtain friendlyName attribute value
		get_stringValue(x_wszAttrFriendlyName, &bstrWriterName);

        CComBSTR bstrVal;

		// extract usage Attribute value
        if (!m_doc.FindAttribute(x_wszAttrUsage, &bstrVal))
			MissingAttribute(ft, x_wszAttrUsage);

        // convert string value to VSS_USAGE_TYPE
		usage = ConvertToUsageType(ft, bstrVal);
		bstrVal.Empty();

		// extract source attribute value
		if (!m_doc.FindAttribute(x_wszAttrDataSource, &bstrVal))
			MissingAttribute(ft, x_wszAttrDataSource);

        // convert string to VSS_SOURCE_TYPE
		source = ConvertToSourceType(ft, bstrVal);

        // assign output parameters
        *pUsage = usage;
        *pSource = source;
        *pidInstance = idInstance;
        *pidWriter = idWriter;
        *pbstrWriterName = bstrWriterName.Detach();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}




// get count of components, files to include and files to exclude.
// implements IVssExamineWriterMetadata::GetFileCounts
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcIncludeFiles, pcExcludeFiles, or pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetFileCounts
	(
	OUT UINT *pcIncludeFiles,		// count of INCLUDE_FILES elements
	OUT UINT *pcExcludeFiles,		// count of EXCLUDE_FILES elements
	OUT UINT *pcComponents			// count of DATABASE and FILE_GROUP elements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetFileCounts"
		);

	try
		{
		VssZeroOut(pcExcludeFiles);
		VssZeroOut(pcComponents);

        // check output parametrs
		if (pcIncludeFiles == NULL ||
			pcExcludeFiles == NULL ||
			pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initalize output parameters
		*pcIncludeFiles = 0;

		CVssSafeAutomaticLock lock(m_csDOM);
        // reposition to top of document
		m_doc.ResetToDocument();
        // position on first BACKUP_LOCATIONS child element
		if (m_doc.FindElement(x_wszElementBackupLocations, TRUE) &&
			m_doc.Next())
			{
			UINT cIncludeFiles = 0;
			UINT cExcludeFiles = 0;
			UINT cComponents = 0;
			do
				{
				// get current node
				CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

				DOMNodeType dnt;

				// get node type
				ft.hr = pNode->get_nodeType(&dnt);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

				// if node type is not element, then skip it
				if (dnt != NODE_ELEMENT)
					continue;

				// get node name
				CComBSTR bstrName;
				ft.hr = pNode->get_nodeName(&bstrName);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

				// update counts based on element type
				if (wcscmp(bstrName, x_wszElementIncludeFiles) == 0)
					cIncludeFiles += 1;
				else if (wcscmp(bstrName, x_wszElementExcludeFiles) == 0)
					cExcludeFiles += 1;
				else if (wcscmp(bstrName, x_wszElementDatabase) == 0 ||
						 wcscmp(bstrName, x_wszElementFilegroup) == 0)
					cComponents += 1;
				} while(m_doc.Next(FALSE, FALSE));

			*pcIncludeFiles = cIncludeFiles;
			*pcExcludeFiles = cExcludeFiles;
			*pcComponents = cComponents;
			}
		}
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}

// obtain a specific kind of file INCLUDE_FILES or EXCLUDE_FILES
HRESULT CVssExamineWriterMetadata::GetFileType
	(
	CVssFunctionTracer &ft,
	IN UINT iFile,							// which element to extract
	IN LPCWSTR wszFileType,					// which elements to filter
	OUT IVssWMFiledesc **ppFiledesc			// file descriptor
	)
	{
	CVssWMFiledesc *pFiledesc = NULL;
	try
		{
        // check output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // null output parameter
        *ppFiledesc = NULL;
		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find BACKUP_LOCATIONS element
		if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"BACKUP_LOCATIONS element was not found."
				);

        // find element type within BACKUP_LOCATIONS
		if (!m_doc.FindElement(wszFileType, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"%s element was not found",
				wszFileType
				);

        // skip to selected element
		for(UINT i = 0; i < iFile; i++)
			{
			if (!m_doc.FindElement(wszFileType, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"%s element was not found"
					);
			}

        // construct Filedesc for selected element
		pFiledesc = new CVssWMFiledesc(m_doc.GetCurrentNode());

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Can't create CVssWMFiledesc due to allocation failure."
				);

        // 2nd phase of construction
        pFiledesc->Initialize(ft);

		// transfer ownership of pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
		((IVssWMFiledesc *) pFiledesc)->AddRef();

		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// return an INCLUDE_FILES element
// implements IVssExamineWriterMetadata::GetIncludeFile
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified exclude file doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetIncludeFile
	(
	IN UINT iFile,						// which element to select
	OUT IVssWMFiledesc **ppFiledesc		// output constructed Filedesc
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetIncludeFile"
		);

    // call helper routine
	return GetFileType(ft, iFile, x_wszElementIncludeFiles, ppFiledesc);
	}


// return an EXCLUDE_FILES element
// implements IVssExamineWriterMetadata::GetExcludeFile
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified exclude file doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetExcludeFile
	(
	IN UINT iFile,
	OUT IVssWMFiledesc **ppFiledesc
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetExcludeFile"
		);

	return GetFileType(ft, iFile, x_wszElementExcludeFiles, ppFiledesc);
	}

// obtain a component (DATABASE or FILE_GROUP)
// implements IVssExamineWriterMetadata::GetComponent
// caller is responsible for calling IVssWMComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified component is not found
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is corrupt
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetComponent
	(
	IN UINT iComponent,						// which component to select
	OUT IVssWMComponent **ppComponent		// returned component
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetComponent"
		);


	CVssWMComponent *pComponent = NULL;

    try
		{
        // check output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // set output parameter to NULL
        *ppComponent = NULL;


		CVssSafeAutomaticLock lock(m_csDOM);

        // reset position to top of document
		m_doc.ResetToDocument();

        // position on BACKUP_LOCATIONS element
		if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"BACKUP_LOCATIONS element was not found"
				);

        // position on first child element of BACKUP_LOCATIONS
        if (!m_doc.Next(TRUE, FALSE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Component was not found"
				);

        // current node
		CComPtr<IXMLDOMNode> pNode = NULL;
		for(UINT i = 0; i <= iComponent; )
			{
			DOMNodeType dnt;

            // obtain current node
            pNode = m_doc.GetCurrentNode();

            // obtain node type
            ft.hr = pNode->get_nodeType(&dnt);
			ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

            // skip node if not an ELEMENT
			if (dnt == NODE_ELEMENT)
				{
                // get element name
				CComBSTR bstrName;
				ft.hr = pNode->get_nodeName(&bstrName);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

                // check that element is a copmonent (either DATABASE
				// or FILE_GROUP)
				if (wcscmp(bstrName, x_wszElementDatabase) == 0 ||
					wcscmp(bstrName, x_wszElementFilegroup) == 0)
					{
                    // increment count of components found and determine
                    // it this is the selected component
					i++;
					if (i > iComponent)
						break;
					}
				}

            // position on next element
			if(!m_doc.Next(FALSE, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Component %d was not found",
                    iComponent
					);
            }


		pComponent = new CVssWMComponent((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pComponent == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot allocate CVssWMComponent due to allocation failure."
				);

        // 2nd phase of initialization
        pComponent->Initialize(ft);

		// move pointer to output parameter
        *ppComponent = (IVssWMComponent *) pComponent;

		// set reference count to 1.
        ((IVssWMComponent *) pComponent)->AddRef();
		pComponent = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pComponent;

	return ft.hr;
	}


// get RESTORE_METHOD element info.  Return S_FALSE if not found
// implements IVssExamineWriterMetadata::GetRestoreMethod
// caller is responsible for calling SysFreeString on pbstrService
// and pbstrUserProcedure
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no restore method
//		E_INVALIDARG if any of the output parameters are NULL.
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetRestoreMethod
	(
	OUT VSS_RESTOREMETHOD_ENUM *pMethod,		// method enumeration
	OUT BSTR *pbstrService,						// service name (valid for VSS_RME_STOP_RESTORE_RESTART
	OUT BSTR *pbstrUserProcedure,				// URL/URI to a user procedure to be performed manually
	OUT VSS_WRITERRESTORE_ENUM *pWriterRestore,	// whether writer particpates in the restore
	OUT bool *pbRebootRequired,					// is a reboot after restore required
    OUT UINT *pcMappings						// # of ALTERNATE_LOCATION_MAPPING elements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetRestoreMethod"
		);

	try
		{

        // initialize output parameters
		if (pWriterRestore)
			*pWriterRestore = VSS_WRE_UNDEFINED;

		if (pbRebootRequired)
			*pbRebootRequired = false;

		VssZeroOut(pbstrUserProcedure);
		VssZeroOut(pbstrService);
        VssZeroOut(pcMappings);

        // check output parameters
		if (pMethod == NULL ||
			pbstrService == NULL ||
			pbstrUserProcedure == NULL ||
			pWriterRestore == NULL ||
			pbRebootRequired == NULL ||
            pcMappings == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*pMethod = VSS_RME_UNDEFINED;


		VSS_RESTOREMETHOD_ENUM method;
		VSS_WRITERRESTORE_ENUM writerRestore;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		unsigned cMappings = 0;
		bool bRebootRequired;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition at top of the document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element, return S_FALSE if not found
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.hr = S_FALSE;
		else
			{
			// get "method" attribute
			CComBSTR bstrVal = NULL;
			if (!m_doc.FindAttribute(x_wszAttrMethod, &bstrVal))
				MissingAttribute(ft, x_wszAttrMethod);

			// convert string to VSS_RESTOREMETHOD_ENUM
			method = ConvertToRestoreMethod(ft, bstrVal);
			bstrVal.Empty();

			// extract service attribute value
			get_stringValue(x_wszAttrService, &bstrService);

			// extract userProcedure attribute value
			get_stringValue(x_wszAttrUserProcedure, &bstrUserProcedure);

			// extract writerRestore attribute value as a string
			get_stringValue(x_wszAttrWriterRestore, &bstrVal);

			// convert string to VSS_WRITERRESTORE_ENUM
			writerRestore = ConvertToWriterRestore(ft, bstrVal);

			// extract rebootRequired attribute
			get_boolValue(ft, x_wszAttrRebootRequired, &bRebootRequired);

			// get first ALTERNATE_LOCATION_MAPPING elemnent
			if (m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
				{
				// count number of elements
				do
					{
					// increment count of mappings
					cMappings += 1;
					} while(m_doc.FindElement(x_wszElementAlternateMapping, FALSE));
                }

			// assign output parameters
			*pMethod = method;
			*pWriterRestore = writerRestore;
			*pbstrUserProcedure = bstrUserProcedure.Detach();
			*pbstrService = bstrService.Detach();
			*pcMappings = cMappings;
			*pbRebootRequired = bRebootRequired;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get a specific alternative location mapping
// implements IVssExamineWriterMetadata::GetAlternateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified alternate location mapping
//			is not found.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetAlternateLocationMapping
	(
	IN UINT iMapping,					// which mapping to extract
	OUT IVssWMFiledesc **ppFiledesc		// file descriptor for mapping
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetAlternateLocationMapping"
		);

	CVssWMFiledesc *pFiledesc = NULL;

    try
		{
        // check output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // set output parameter to NULL
		*ppFiledesc = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find RESTORE_METHOD element"
				);

        // find first ALTERNATIVE_LOCATION_MAPPING element
        if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find ALTERNATE_LOCATION_MAPPING element"
				);

        // search for selected element
		for(UINT i = 0; i < iMapping; i++)
			{
			if (!m_doc.FindElement(x_wszElementAlternateMapping, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find ALTERNATE_LOCATION_MAPPING element"
					);
            }

		// obtain current node
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

        // return mapping as a CVssWMFiledesc
		pFiledesc = new CVssWMFiledesc((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssAlternateLocationMapping due to allocation failure."
				);

		// call 2nd phase of construction
		pFiledesc->Initialize(ft);

		// transfer pointer to output parameter
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
        ((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// obtain the XML document itself
// implements IVssExamineWriterMetadata::GetDocument
// caller is responsible for calling IXMLDOMDocument::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALDARG if ppDoc is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetDocument(IXMLDOMDocument **ppDoc)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::GetDocument");

	try
		{
		// validate output parameter
		if (ppDoc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// set output parameter
		*ppDoc = m_doc.GetInterface();

		BS_ASSERT(*ppDoc);

		// increment reference count on output parameter
		m_doc.GetInterface()->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// save writer metadata as XML string
// implements IVssExamineWriterMetadata::SaveAsXML
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::SaveAsXML"
		);

    try
		{
        // validate output parametr
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // set output parameter to NULL
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

		// construct XML string
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// load document from XLM string
// implements IVssExamineWriterMetadata::LoadFromXML
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the document failed to load.
//		E_INVALIDARG if bstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::LoadFromXML(BSTR bstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::LoadFromXML"
		);

    try
		{
		if (bstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input parameter is NULL.");

		CVssSafeAutomaticLock lock(m_csDOM);
		bool f = LoadDocument(bstrXML);

		ft.hr = f ? S_OK : S_FALSE;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// IUnknown::QueryInterface
STDMETHODIMP CVssExamineWriterMetadata::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssExamineWriterMetadata::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssExamineWriterMetadata::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}



// return basic information about the component
// implements IVssWMComponent::GetComponentInfo
// caller must call IVssWMComponent::FreeComponentInfo on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppInfo is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetComponentInfo(PVSSCOMPONENTINFO *ppInfo)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetComponentInfo"
		);

	// constructed component info
    VSS_COMPONENTINFO *pInfo = NULL;

    try
		{
        // validate output parameter
		if (ppInfo == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // set output parameter to NULL
        *ppInfo = NULL;

        // allocate structure
		pInfo = (VSS_COMPONENTINFO *) CoTaskMemAlloc(sizeof(VSS_COMPONENTINFO));

        // check for allocation failure
		if (pInfo == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Failed to create VSS_COMPONENTINFO"
				);

        // initialize structure
        memset(pInfo, 0, sizeof(*pInfo));

		CVssSafeAutomaticLock lock(m_csDOM);

        // obtain current node
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

        // get node name
		CComBSTR bstrName = NULL;
		ft.hr = pNode->get_nodeName(&bstrName);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

        // convert string to VSS_COMPONENT_TYPE
        pInfo->type = ConvertToComponentType(ft, bstrName, false);

        // obtain logical path
		get_stringValue(x_wszAttrLogicalPath, &pInfo->bstrLogicalPath);

        // obtain component name
        get_stringValue(x_wszAttrComponentName, &pInfo->bstrComponentName);

        // obtain component description
		get_stringValue(x_wszAttrCaption, &pInfo->bstrCaption);

		// get icon if it exists
		pInfo->pbIcon = get_byteArrayValue(ft, x_wszAttrIcon, false, pInfo->cbIcon);

        // get boolean restoreMetadata attribute value
		get_boolValue(ft, x_wszAttrRestoreMetadata, &pInfo->bRestoreMetadata);

		// get boolean notifyOnBackupComplete attribute value
		get_boolValue(ft, x_wszAttrNotifyOnBackupComplete, &pInfo->bNotifyOnBackupComplete);

		// get boolean selectable attribute value
		get_boolValue(ft, x_wszAttrSelectable, &pInfo->bSelectable);

        // count subElements DATABASE_FILES, DATABASE_LOGFILES, and FILE_LIST

        // descend to first child element

		CXMLDocument doc(m_doc.GetCurrentNode(), m_doc.GetInterface());
		if (doc.Next(TRUE, FALSE))
			{
			do
				{
                // get current node
				CComPtr<IXMLDOMNode> pNode = doc.GetCurrentNode();
				DOMNodeType dnt;

                // determine node type
				ft.hr = pNode->get_nodeType(&dnt);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

                // skip node if not an element
				if (dnt == NODE_ELEMENT)
					{
					CComBSTR bstrName = NULL;

					ft.hr = pNode->get_nodeName(&bstrName);
					ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

                    // update counters based on element type
					if(wcscmp(bstrName, x_wszElementDatabaseFiles) == 0)
						pInfo->cDatabases += 1;
					else if (wcscmp(bstrName, x_wszElementDatabaseLogfiles) == 0)
						pInfo->cLogFiles += 1;
					else if (wcscmp(bstrName, x_wszElementFilelist) == 0)
						pInfo->cFileCount += 1;
					}
				} while (doc.Next(FALSE, FALSE));
            }

        // set output parameter
		*ppInfo = pInfo;
		}
	VSS_STANDARD_CATCH(ft);

    // free structure if there is any failure
	if (FAILED(ft.hr) && pInfo != NULL)
		FreeComponentInfo(pInfo);

	return ft.hr;
	}

// free up component info structure
// implements IVssWMComponent::FreeComponentInfo
// frees information returned by IVssWMComponent::GetComponentInfo
//
// Returns:
//		S_OK if the operation is successful

STDMETHODIMP CVssWMComponent::FreeComponentInfo(PVSSCOMPONENTINFO pInfoC)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWMComponent::FreeComponentInfo");

	VSS_COMPONENTINFO *pInfo = (VSS_COMPONENTINFO *) pInfoC;

	if (pInfo != NULL)
		{
		try
			{
			if (pInfo->bstrLogicalPath)
				{
				SysFreeString(pInfo->bstrLogicalPath);
				pInfo->bstrLogicalPath = NULL;
				}

			if (pInfo->bstrComponentName)
				{
				SysFreeString(pInfo->bstrComponentName);
				pInfo->bstrComponentName = NULL;
				}

			if (pInfo->bstrCaption)
				{
				SysFreeString(pInfo->bstrCaption);
				pInfo->bstrCaption = NULL;
				}

			if (pInfo->pbIcon)
				{
				CoTaskMemFree(pInfo->pbIcon);
				pInfo->pbIcon = NULL;
				}

			CoTaskMemFree(pInfo);
			}
		VSS_STANDARD_CATCH(ft)
		}

	return ft.hr;
	}

// obtain a FILE_LIST element
// implements IVssWMComponent::GetFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetFile
	(
	IN UINT iFile,						// selected file in file group
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetFile"
		);

	return GetComponentFile(ft, x_wszElementFilelist, iFile, ppFiledesc);
	}

// obtain a DATABASE_FILES element
// implements IVssWMComponent::GetDatabaseFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetDatabaseFile
	(
	IN UINT iDBFile,					// selected DATABASE_FILE element in DATABASE
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetDatabaseFile"
		);

	return GetComponentFile(ft, x_wszElementDatabaseFiles, iDBFile, ppFiledesc);
	}

// obtain a DATABASE_LOGFILES element
// implements IVssWMComponent::GetDatabaseLogFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetDatabaseLogFile
	(
	IN UINT iDbLogFile,					// selected DATABASE_LOG_FILE element in DATABASE
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetDatabaseLogFile"
		);

	return GetComponentFile(ft, x_wszElementDatabaseLogfiles, iDbLogFile, ppFiledesc);
	}

// obtain a DATABASE_FILES, DATABASE_LOGFILES or FILE_LIST element
// internal function used by GetDatabaseFile, GetDatabaseLogFile, and GetFile
HRESULT CVssWMComponent::GetComponentFile
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElementName,			// element to retrieve DATABASE_FILE, DATABASE_LOG_FILE, or FILE_LIST
	IN UINT iFile,						// which element to retrieve
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{

	CVssWMFiledesc *pFiledesc = NULL;

	try
		{
        // validate output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initialize output parameter
		*ppFiledesc = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of component
		m_doc.ResetToDocument();

        // find first child element
		if (!m_doc.FindElement(wszElementName, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find %s element",
				wszElementName
				);

        // skip to selected element
        for(UINT i = 0; i < iFile; i++)
			{
			if (!m_doc.FindElement(wszElementName, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find element %s.",
					wszElementName
					);
            }

        // get selected element
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

	
        // create CVssWMFiledesc from selected element
		pFiledesc = new CVssWMFiledesc((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssWMFiledesc due to allocation failure."
				);

		// 2nd phase of construction
		pFiledesc->Initialize(ft);

		// transfer pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
        ((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// IUnknown::QueryInterface
STDMETHODIMP CVssWMComponent::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWMComponent::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssWMComponent::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);
	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return cRef;
	}


// obtain path attribute
// implements IVssWMFiledesc::GetPath
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetPath(OUT BSTR *pbstrPath)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetPath"
		);

    return GetStringAttributeValue(ft, x_wszAttrPath, false, pbstrPath);
	}

// obtain filespec attribute
// implements IVssWMFiledesc::GetFilespec
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrFilespec is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetFilespec(OUT BSTR *pbstrFilespec)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetFilespec"
		);

    return GetStringAttributeValue(ft, x_wszAttrFilespec, true, pbstrFilespec);
	}

// obtain recursive attribute
// implements IVssWMFiledesc::GetRecursive
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbRecursive is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetRecursive(OUT bool *pbRecursive)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetRecursive"
		);

    return GetBooleanAttributeValue(ft, x_wszAttrRecursive, false, pbRecursive);
	}

// obtain alternatePath attribute
// implements IVssWMFiledesc::GetAlternateLocation
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrAlternateLocation is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetAlternateLocation(OUT BSTR *pbstrAlternateLocation)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetAlternateLocation"
		);


	return GetStringAttributeValue(ft, x_wszAttrAlternatePath, false, pbstrAlternateLocation);
	}

// IUnknown::QueryInterface
STDMETHODIMP CVssWMFiledesc::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWMFiledesc::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssWMFiledesc::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// initialize the document by creating a toplevel WRITER_METADATA and
// child IDENTIFICATION element
// implemetns IVssCreateWriterMetadata::Initialize
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if usage or source are invalid or if wszFriendlyName is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

HRESULT CVssCreateWriterMetadata::Initialize
	(
	IN VSS_ID idInstance,				// GUID of instance
	IN VSS_ID idWriter,					// GUID of writer class
	IN LPCWSTR wszFriendlyName,			// friendly name of writer
	IN VSS_USAGE_TYPE usage,			// usage attribute
	IN VSS_SOURCE_TYPE source			// source attribute
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::Initialize"
		);

    try
		{
		LPCWSTR wszUsage;
		LPCWSTR wszSource;

        // validate input argument
		if (wszFriendlyName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL string input parameter");

        wszUsage = WszFromUsageType(ft, usage);
        wszSource = WszFromSourceType(ft, source);
		CXMLDocument doc;

		InitializeHelper(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.Initialize();
		CXMLNode nodeDoc(m_doc.GetInterface(), m_doc.GetInterface());

        // create toplevel WRITER_METADATA node
		CXMLNode nodeTop = m_doc.CreateNode
							(
							x_wszElementWriterMetadata,
							NODE_ELEMENT
							);

		// setup schema attribute
		nodeTop.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);

        // setup version attribute
		nodeTop.SetAttribute(x_wszAttrVersion, x_wszVersionNo);

        // create IDENTIFICATION node
		CXMLNode nodeId = m_doc.CreateNode
							(
							x_wszElementIdentification,
							NODE_ELEMENT
							);

        // set writerId attribute
		nodeId.SetAttribute(x_wszAttrWriterId, idWriter);

        // set instanceId attribue
		nodeId.SetAttribute(x_wszAttrInstanceId, idInstance);

        // set friendlyName attribute
		nodeId.SetAttribute(x_wszAttrFriendlyName, wszFriendlyName);

        // set usage attribute
		nodeId.SetAttribute(x_wszAttrUsage, wszUsage);

        // set dataSource attribute
		nodeId.SetAttribute(x_wszAttrDataSource, wszSource);

		// insert identification node in toplevel node
		nodeTop.InsertNode(nodeId);

		// insert toplevel node in document and set it as
		// the toplevel node for navigation purposes
		CXMLNode nodeToplevel = nodeDoc.InsertNode(nodeTop);
        m_doc.SetToplevelNode(nodeToplevel);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add an INCLUDE_FILES element
// implements IVssCreateWriterMetadata::AddIncludeFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszPath or wszFilespec is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddIncludeFiles
	(
	IN LPCWSTR wszPath,						// path to root directory
	IN LPCWSTR wszFilespec,					// file specification
	IN bool bRecursive,						// is entire subtree or just directory included
	IN LPCWSTR wszAlternateLocation			// alternate location
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddIncludeFiles"
		);

    try
		{
        // validate input parameters
		if (wszPath == NULL || wszFilespec == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		CVssSafeAutomaticLock lock(m_csDOM);

        // create/obtain BACKUP_LOCATIONS element
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();

        // create child INCLUDE_FILES element
		CXMLNode nodeInclude = m_doc.CreateNode
								(
								x_wszElementIncludeFiles,
								NODE_ELEMENT
								);

        // set path attribute
		nodeInclude.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
		nodeInclude.SetAttribute(x_wszAttrFilespec, wszFilespec);

		// set recursive attribute
		nodeInclude.SetAttribute
			(
			x_wszAttrRecursive,
			WszFromBoolean(bRecursive)
			);

        // set alternatePath attribute if specified
		if (wszAlternateLocation)
			nodeInclude.SetAttribute(x_wszAttrAlternatePath, wszAlternateLocation);

		// insert INCLUDE_FILES node in BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(nodeInclude);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add an EXCLUDE_FILES element
// implements IVssCreateWriterMetadata::AddExcludeFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszPath or wszFilespec is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddExcludeFiles
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilespec,
	IN bool bRecursive
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddExcludeFiles"
		);

    try
		{
        // validate input parameters
		if (wszPath == NULL || wszFilespec == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");


		CVssSafeAutomaticLock lock(m_csDOM);

        // create/obtain the BACKUP_LOCATIONS eleement
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();

        // add an EXCLUDE_FILES element
		CXMLNode nodeExclude = m_doc.CreateNode
								(
								x_wszElementExcludeFiles,
								NODE_ELEMENT
								);

		// set path attribute
		nodeExclude.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
		nodeExclude.SetAttribute(x_wszAttrFilespec, wszFilespec);

		// set recursive attribute
		nodeExclude.SetAttribute
			(
			x_wszAttrRecursive,
			WszFromBoolean(bRecursive)
			);

		// insert EXCLUDE_FILES node in BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(nodeExclude);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// internal routine to find or create the BACKUP_LOCATIONS element
// caller should have helper DOM locked
CXMLNode CVssCreateWriterMetadata::GetBackupLocationsNode()
	{
    // reposition to top of document
	m_doc.ResetToDocument();

	CXMLNode nodeTop(m_doc.GetCurrentNode(), NULL);

    // find BACKUP_LOCATIONS element.  If it exists return it
	if (m_doc.FindElement(x_wszElementBackupLocations, TRUE))
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

    // create BACKUP_LOCATIONS element under WRITER_METADATA element
	CXMLNode node = m_doc.CreateNode
						(
						x_wszElementBackupLocations,
						NODE_ELEMENT
						);

	return nodeTop.InsertNode(node);
	}

// create a component
// implements IVssCreateWriterMetadata::AddComponent
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszComponentName is NULL or the specified component type is invalid.
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddComponent
	(
	IN VSS_COMPONENT_TYPE ct,			// either VSS_CT_DATABASE or VSS_CT_FILEGROUP
	IN LPCWSTR wszLogicalPath,			// logical path to component
	IN LPCWSTR wszComponentName,		// component name
	IN LPCWSTR wszCaption,				// description of component
	IN const BYTE * pbIcon,				// icon
	IN UINT cbIcon,						// size of icon
	IN bool bRestoreMetadata,			// is restore metadata supplied
	IN bool bNotifyOnBackupComplete,	// does writer expect to be notified on BackupComplete
	IN bool bSelectable					// is component selectable
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddComponent"
		);

    try
		{
        // validate required input parameter
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        // determine element name from the component type
		LPCWSTR wszElement;
        wszElement = WszFromComponentType(ft, ct, false);

		CVssSafeAutomaticLock lock(m_csDOM);

        // obtain BACKUP_LOCATIONS node, creating it if necessary.
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();
        CXMLDocument doc(nodeBackupLocations);

		// find element type (either DATABASE or FILE_GROUP)
        if (doc.FindElement(wszElement, TRUE))
            {
            do
                {
                CComBSTR bstrLogicalPath;
				CComBSTR bstrComponentName;

				// extract logicalPath attribute
                bool bLogicalPath = doc.FindAttribute(x_wszAttrLogicalPath, &bstrLogicalPath);

				// extract componentName attribute
                if (!doc.FindAttribute(x_wszAttrComponentName, &bstrComponentName))
					MissingAttribute(ft, x_wszAttrComponentName);

                // if duplicate comonent is found then throw an error
                if (wcscmp(wszComponentName, bstrComponentName) == 0 &&
                    ((bLogicalPath &&
                      wszLogicalPath &&
                      wcscmp(wszLogicalPath, bstrLogicalPath) == 0) ||
                     (!bstrLogicalPath &&
                      (wszLogicalPath == NULL || wcslen(wszLogicalPath) == 0))))
                    ft.Throw
                        (
                        VSSDBG_XML,
						VSS_E_OBJECT_ALREADY_EXISTS,
                        L"Component %s already exists",
                        wszComponentName
                        );
                } while(doc.FindElement(wszElement, FALSE));
            }


        // create component node
		CXMLNode node = m_doc.CreateNode
								(
								wszElement,
								NODE_ELEMENT
								);


        // set logicalPath attribute if exists
        if (wszLogicalPath)
			node.SetAttribute(x_wszAttrLogicalPath, wszLogicalPath);

        // set componetName attribute
		node.SetAttribute(x_wszAttrComponentName, wszComponentName);

        // set caption element if it exists
		if (wszCaption)
			node.SetAttribute(x_wszAttrCaption, wszCaption);

        // set icon attribute if it exists
		if (pbIcon != NULL && cbIcon > 0)
			node.SetAttribute(x_wszAttrIcon, pbIcon, cbIcon);

        // set restoreMetadata flags
		node.SetAttribute
			(
			x_wszAttrRestoreMetadata,
			WszFromBoolean(bRestoreMetadata)
			);

        // set notifyOnBackupComplete flag
		node.SetAttribute
			(
			x_wszAttrNotifyOnBackupComplete,
			WszFromBoolean(bNotifyOnBackupComplete)
			);

        // set selectable attribute
		node.SetAttribute
			(
			x_wszAttrSelectable,
			WszFromBoolean(bSelectable)
			);

		// insert component node under BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// create DATABASE_FILES element
// implements IVssCreateWriterMetadata::AddDatabaseFile
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszDatabaseName, wszPath, or wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddDatabaseFiles
	(
	IN LPCWSTR wszLogicalPath,			// logical path name of component
	IN LPCWSTR wszDatabaseName,			// add database name
	IN LPCWSTR wszPath,					// add path name
	IN LPCWSTR wszFilespec				// add file specification
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddDatabaseFiles"
		);

    // call internal routine to do the work
	return CreateComponentFiles
			(
			ft,
			x_wszElementDatabase,
			wszLogicalPath,
			wszDatabaseName,
			x_wszElementDatabaseFiles,
			wszPath,
			wszFilespec,
			false,
			NULL
			);
	}


// create a DATABASE_FILES, DATABASE_LOGFILES or FILE_LIST element under
// a component
// internal routine used by AddDatabaseFiles, AddFiles, and AddDatabaseLogFiles
HRESULT CVssCreateWriterMetadata::CreateComponentFiles
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElement,			// element name (DATABASE or FILE_GROUP)
	IN LPCWSTR wszLogicalPath,		// logical path of component
	IN LPCWSTR wszComponentName,	// component name	
	IN LPCWSTR wszElementFile,		// element name (DATABASE_FILES, DATABASE_LOGFILES, FILELIST)
	IN LPCWSTR wszPath,				// path to root directory containing files
	IN LPCWSTR wszFilespec,			// file specification
	IN bool bRecursive,				// include subtree or just root directory
	IN LPCWSTR wszAlternateLocation	// alternate location for files
	)
	{
    try
        {
		// validate input parameters
        if (wszElement == NULL ||
            wszComponentName == NULL ||
            wszPath == NULL ||
            wszElementFile == NULL ||
            wszFilespec == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");


		// validate element consistency
        if ((wcscmp(wszElement, x_wszElementDatabase) == 0 &&
             wcscmp(wszElementFile, x_wszElementDatabaseFiles) != 0 &&
             wcscmp(wszElementFile, x_wszElementDatabaseLogfiles) != 0) ||
            (wcscmp(wszElement, x_wszElementFilegroup) == 0 &&
             wcscmp(wszElementFile, x_wszElementFilelist) != 0))
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid element type");

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
        m_doc.ResetToDocument();

        // find BACKUP_LOCATIONS element
        if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"BackupLocations element is missing"
                );

        // find first component of the right type
        if (!m_doc.FindElement(wszElement, TRUE))
            ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"Component %s::%s was not created",
                wszElement,
                wszComponentName
                );

        // look for matching component
        bool bFound = false;
        do
            {
            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

			// extract logical path
            bool fLogicalPath = m_doc.FindAttribute(x_wszAttrLogicalPath, &bstrLogicalPath);

			// extract component name
            if (!m_doc.FindAttribute(x_wszAttrComponentName, &bstrComponentName))
				MissingAttribute(ft, x_wszAttrComponentName);

            // compare logical path if it exists
            if (wszLogicalPath != NULL && fLogicalPath)
                {
				// compare logical path
                if (wcscmp(wszLogicalPath, bstrLogicalPath) != 0)
                    continue;
                }
            else if (wszLogicalPath == NULL &&
                     fLogicalPath &&
                     wcslen(bstrLogicalPath) > 0)
                // logical path in document but component we are searching
				// for has no logical path, skip this one
			    continue;
            else if (wszLogicalPath != NULL && wcslen(wszLogicalPath) > 0)
				// logical path we are searching for is specified but
				// there is no logical path in the document
                continue;

            // if component name matches then we found target component,
			// otherwise move to next component
            if (wcscmp(bstrComponentName, wszComponentName) == 0)
                {
                bFound = true;
                break;
                }
            } while(m_doc.FindElement(wszElement, FALSE));

        // return error if component is not found
        if (!bFound)
            ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"Component %s::%s was not created",
                wszElement,
                wszComponentName
                );


        // use component node as parent node
        CXMLNode nodeComponent(m_doc.GetCurrentNode(), m_doc.GetInterface());

        // create child node of the component
        CXMLNode node = m_doc.CreateNode
						(
						wszElementFile,
						NODE_ELEMENT
						);

        // set path attribute
        node.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
        node.SetAttribute(x_wszAttrFilespec, wszFilespec);
		
		// set recursive attribute if it is Yes
		if (bRecursive)
			node.SetAttribute
				(
				x_wszAttrRecursive,
				WszFromBoolean(bRecursive)
				);

        if (wszAlternateLocation)
			node.SetAttribute(x_wszAttrAlternatePath, wszAlternateLocation);

		// insert file element under component node
		nodeComponent.InsertNode(node);
        }	
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add a log file specification to a database component
// implements IVssCreateWriterMetadata::AddDatabaseLogFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszDatabaseName is NULL, wszPath is NULL, or wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddDatabaseLogFiles
	(
	IN LPCWSTR wszLogicalPath,			// logical path of database
	IN LPCWSTR wszDatabaseName,			// database name
	IN LPCWSTR wszPath,					// path to directory containing log files
	IN LPCWSTR wszFilespec				// file specification of log files
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddDatabaseLogFiles"
		);

    // call internal routine to do the work
    return CreateComponentFiles
			(
			ft,
			x_wszElementDatabase,
			wszLogicalPath,
			wszDatabaseName,
			x_wszElementDatabaseLogfiles,
			wszPath,
			wszFilespec,
			false,
			NULL
			);
	}


// add files to a file group
// implements IVssCreateWriterMetadata::AddFilesToFileGroup
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszGroupName is NULL, wszPath is NULL, wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddFilesToFileGroup
	(
	IN LPCWSTR wszLogicalPath,		// logical path of file group
	IN LPCWSTR wszGroupName,		// group name	
	IN LPCWSTR wszPath,				// path to root directory containing the files
	IN LPCWSTR wszFilespec,			// file specification of the files included in the file group
	IN bool bRecursive,				// are files in the subtree included or just in the directory
	IN LPCWSTR wszAlternateLocation	// alternate location for files in the file group
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddFilesToFileGroup"
		);

    // call internal routine to do the work
	return CreateComponentFiles
			(
			ft,
			x_wszElementFilegroup,
			wszLogicalPath,
			wszGroupName,
			x_wszElementFilelist,
			wszPath,
			wszFilespec,
			bRecursive,
			wszAlternateLocation
			);
	}

// create restore method
// implements IVssCreateWriterMetadata::SetRestoreMethod
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if method is invalid, writerRestore is invalid,
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::SetRestoreMethod
	(
	IN VSS_RESTOREMETHOD_ENUM method,		// method
	IN LPCWSTR wszService,					// service name, if method is VSS_RME_STOP_RESTORE_RESTART
	IN LPCWSTR wszUserProcedure,			// uri/url of manual instructions for user to follow to do the restore
	IN VSS_WRITERRESTORE_ENUM writerRestore, // is writer involved in the restore process
	IN bool bRebootRequired
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::SetRestoreMethod"
		);

    try
		{
		// convert VSS_RESTORMETHOD_ENUM to string
		// validate it as well
		LPCWSTR wszMethod = WszFromRestoreMethod(ft, method);

		// convert VSS_WRITERRESTORE_ENUM to string
		// validate it as well
		LPCWSTR wszWriterRestore = WszFromWriterRestore(ft, writerRestore);

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
        m_doc.ResetToDocument();

		// set parent node as WRITER_METADATA node
		CXMLNode nodeTop(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// if RESTORE_METHOD element exists, then return an error
		if (m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_ALREADY_EXISTS,
				L"RESTORE_METHOD element already exists."
				);

        // create RESTORE_METHOD node as child of WRITER_METADATA node
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementRestoreMethod,
							NODE_ELEMENT
							);

        // set method attribute
        node.SetAttribute(x_wszAttrMethod, wszMethod);

		// set service attribute if supplied
		if (wszService)
			node.SetAttribute(x_wszAttrService, wszService);

		// set userProcedure attribute if supplied
		if (wszUserProcedure)
			node.SetAttribute(x_wszAttrUserProcedure, wszUserProcedure);

		// set writerRestore attribute
		node.SetAttribute(x_wszAttrWriterRestore, wszWriterRestore);

		// set rebootRequired attribute
		node.SetAttribute(x_wszAttrRebootRequired, WszFromBoolean(bRebootRequired));

		// insert RESTORE_METHOD node under toplevel node
		nodeTop.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add alternate location mapping
// implements IVssCreateWriterMetadata::AddAlternateLocationMapping
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszSourcePath, wszSourceFiledesc, or wszDestination is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddAlternateLocationMapping
	(
	IN LPCWSTR wszSourcePath,			// path to source root directory
	IN LPCWSTR wszSourceFilespec,		// file specification
	IN bool bRecursive,					// are files in the subtree relocated or just files in the directory	
	IN LPCWSTR wszDestination			// new location of root directory
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddAlternateLocationMapping"
		);
    try
        {
        // validate input parameters
		if (wszSourcePath == NULL ||
			wszSourceFilespec == NULL ||
			wszDestination == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"RESTORE_METHOD element is not defined."
				);

        // set parent node as RESTORE_METHOD element
        CXMLNode nodeRM(m_doc.GetCurrentNode(), m_doc.GetInterface());

        // create ALTERNATE_LOCATION_MAPPING element to
		// RESTORE_METHOD element
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementAlternateMapping,
							NODE_ELEMENT
							);

		// set path attribute					
        node.SetAttribute(x_wszAttrPath, wszSourcePath);

		// add filespec attributte
		node.SetAttribute(x_wszAttrFilespec, wszSourceFilespec);

		// set alternatePath attribute
		node.SetAttribute(x_wszAttrAlternatePath, wszDestination);

		// set recursive attribute
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));

		// insert ALTERNATE_LOCATION_MAPPING node under RESTORE_METHOD node
		nodeRM.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the XML document itself
// implements IVssCreateWriterMetadata::GetDocument
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppDoc is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::GetDocument(IXMLDOMDocument **ppDoc)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssCreateWriterMetadata::GetDocument");

	try
		{
		// validate output parameter
		if (ppDoc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// get IXMLDOMDocument interface
		*ppDoc = m_doc.GetInterface();

		// increment reference count on interface
		m_doc.GetInterface()->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// save WRITER_METADATA document as XML string
// implements IVssCreateWriterMetadata::SaveAsXML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::SaveAsXML"
		);

    try
		{
        // validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // initialize output paramter
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

		// construct string from document
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft);

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\comadmin\comadmin.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module COMAdmin.cxx | Simple wrapper around COM Admin classes
    @end

Author:

    Adi Oltean  [aoltean]  08/15/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/15/1999  Created.
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999	Fixing VSSDBG_GEN.

--*/


/////////////////////////////////////////////////////////////////////////////
// Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)

// C4127: conditional expression is constant
#pragma warning( disable: 4127 )


#define STRICT

/////////////////////////////////////////////////////////////////////////////
// Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>

#include "vs_assert.hxx"

#include <atlconv.h>
#include <atlbase.h>
#include <comadmin.h>
#include <vs_sec.hxx>

#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CADCADMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Globals


// Collection attributes - TBD: Verify if Keys are OK!!
struct _VsCOMCollectionAttr g_VsCOMCollectionsArray[] =
{
    { L"",                       L"",            L"",          },   // VSS_COM_UNKNOWN = 0,
    { L"ApplicationCluster",     L"Name",        L"Name",      },   // VSS_COM_APPLICATION_CLUSTER,
    { L"Applications",           L"ID",          L"Name",      },   // VSS_COM_APPLICATIONS,
    { L"Components",             L"CLSID",       L"ProgID",    },   // VSS_COM_COMPONENTS,
    { L"ComputerList",           L"Name",        L"Name",      },   // VSS_COM_COMPUTERLIST,
    { L"DCOMProtocols",          L"Name",        L"Name",      },   // VSS_COM_DCOM_PROTOCOLS,
    { L"ErrorInfo",              L"MajorRef",    L"MajorRef",  },   // VSS_COM_ERRORINFO,
    { L"IMDBDataSources",        L"DataSource",  L"DataSource",},   // VSS_COM_IMDB_DATA_SOURCES,
    { L"IMDBDataSourceTables",   L"TableName",   L"TableName", },   // VSS_COM_IMDB_DATA_SOURCE_TABLES,
    { L"InprocServers",          L"CLSID",       L"ProgID",    },   // VSS_COM_INPROC_SERVERS,
    { L"InterfacesForComponent", L"IID"          L"Name"       },   // VSS_COM_INTERFACES_FOR_COMPONENT,
    { L"LocalComputer",          L"Name",        L"Name",      },   // VSS_COM_LOCAL_COMPUTER,
    { L"MethodsForInterface",    L"Index",       L"Name",      },   // VSS_COM_METHODS_FOR_INTERFACE,
    { L"PropertyInfo",           L"Name",        L"Name",      },   // VSS_COM_PROPERTY_INFO,
    { L"PublisherProperties",    L"Name",        L"Name",      },   // VSS_COM_PUBLISHER_PROPERTIES,
    { L"RelatedCollectionInfo",  L"Name",        L"Name",      },   // VSS_COM_RELATED_COLLECTION_INFO,
    { L"Roles",                  L"Name",        L"Name",      },   // VSS_COM_ROLES,
    { L"RolesForComponent",      L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_COMPONENT,
    { L"RolesForInterface",      L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_INTERFACE,
    { L"RolesForMethod",         L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_METHOD,
    { L"Root",                   L"",            L"",          },   // VSS_COM_ROOT,
    { L"SubscriberProperties",   L"Name",        L"Name",      },   // VSS_COM_SUBSCRIBER_PROPERTIES,
    { L"Subscriptions",          L"ID",          L"Name",      },   // VSS_COM_SUBSCRIPTIONS,
    { L"TransientSubscriptions", L"ID",          L"Name",      },   // VSS_COM_TRANSIENT_SUBSCRIPTIONS,
    { L"UsersInRole",            L"User",        L"User",      }    // VSS_COM_USERS_IN_ROLE,
};


/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMAdminCatalog


HRESULT CVssCOMAdminCatalog::Attach(
    IN  const WCHAR* pwszAppName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::Attach" );

    try
    {
        // Testing argument
        if (pwszAppName == NULL || pwszAppName[0] == L'\0') {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL or empty application name");
        }

        // Begin initializing
        m_bInitialized = false;
        m_pICatalog = NULL;

        // Creating the COMAdminCatalog instance
        ft.hr = m_pICatalog.CoCreateInstance(__uuidof(COMAdminCatalog));
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_CREATING_COMPLUS_ADMIN_CATALOG, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Error creating the COMAdminCatalog instance hr = 0x%08lx", ft.hr);
        }

        // Getting the application name
        m_bstrAppName = pwszAppName;
        if (!m_bstrAppName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        // End initializing
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}




HRESULT CVssCOMAdminCatalog::InstallComponent(
    IN  const WCHAR* pwszDllName,
    IN  const WCHAR* pwszTlbName,
    IN  const WCHAR* pwszProxyStubName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::InstallComponent" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        // Testing arguments
        if (pwszDllName == NULL || pwszDllName[0] == L'\0')
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL or empty paths");

        CComBSTR bstrAppName = (LPWSTR)m_bstrAppName;
        if ((LPWSTR)bstrAppName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrDllName = pwszDllName;
        if ((LPWSTR)bstrDllName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrTlbName = pwszTlbName? pwszTlbName: L"";
        if ((LPWSTR)bstrTlbName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrProxyStubName = pwszProxyStubName? pwszProxyStubName: L"";
        if ((LPWSTR)bstrProxyStubName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");


        // Install event class for this application
        ft.hr = m_pICatalog->InstallComponent(
            bstrAppName,
            bstrDllName,
            bstrTlbName,
            bstrProxyStubName
            );
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.LogError( VSS_ERROR_INSTALL_COMPONENT, VSSDBG_GEN << bstrDllName << bstrAppName << ft.hr );
            ft.Throw(VSSDBG_GEN, ft.hr, L"Installing the component failed");
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMAdminCatalog::CreateServiceForApplication(
    IN  const WCHAR* pwszServiceName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::CreateServiceForApplication" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        CComBSTR bstrAppName = (LPWSTR)m_bstrAppName;
        if ((LPWSTR)bstrAppName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrSvcName = pwszServiceName;
        if ((LPWSTR)bstrSvcName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrStartType = L"SERVICE_DEMAND_START";
        if ((LPWSTR)bstrStartType == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrErrorControl = L"SERVICE_ERROR_IGNORE";
        if ((LPWSTR)bstrErrorControl == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrRunAs = L"LocalSystem";
        if ((LPWSTR)bstrRunAs == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrPassword = L"";
        if ((LPWSTR)bstrRunAs == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

#ifdef _DEBUG
        VARIANT_BOOL vboolDesktopOK = VARIANT_TRUE;
#else
        VARIANT_BOOL vboolDesktopOK = VARIANT_FALSE;
#endif

        ft.Trace(VSSDBG_GEN,
            L"Calling CreateServiceForApplicationStrings(%s, %s, %s, %s, %s, %s, %s, %s)",
            bstrAppName,
            bstrSvcName,
            bstrStartType,
            bstrErrorControl,
            NULL,
            bstrRunAs,
            bstrPassword,
            vboolDesktopOK == VARIANT_TRUE? L"TRUE": L"FALSE"
            );

        // Install event class for this application
        ft.hr = m_pICatalog->CreateServiceForApplication(
            m_bstrAppName,
            bstrSvcName,
            bstrStartType,
            bstrErrorControl,
            NULL,
            bstrRunAs,
            bstrPassword,
            vboolDesktopOK
            );
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.LogError( VSS_ERROR_CREATE_SERVICE_FOR_APPLICATION, VSSDBG_GEN << bstrSvcName << m_bstrAppName << ft.hr );
            ft.Throw(VSSDBG_GEN, ft.hr, L"Installing the component failed");
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}





/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMCatalogCollection


HRESULT CVssCOMCatalogCollection::Attach(
    IN  CVssCOMAdminCatalog& catalog
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::Attach_ToCatalog" );

    try
    {
        // Begin intializing
        m_bInitialized = false;
        m_pICollection = NULL;

        // Check if Collection type is valid
        if ((m_eType <= 0) || (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Invalid collection type");

        // Converting collection name into BSTR
        CComBSTR bstrCollectionName = g_VsCOMCollectionsArray[m_eType].wszName;
        if (!bstrCollectionName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        // Get the catalog interface
        CComPtr<ICOMAdminCatalog2> pICatalog = catalog.GetInterface();
        if (pICatalog == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog object not initialized.");
        }

        // Get the collection object
        CComPtr<IDispatch> pIDisp;
        ft.hr = pICatalog->GetCollection(bstrCollectionName, &pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GETTING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting the collection. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogCollection
        CComPtr<ICatalogCollection> pICollection;
        ft.hr = pIDisp->SafeQI(ICatalogCollection, &pICollection);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogCollection. hr = 0x%08lx", ft.hr);

        // Populate the collection
        ft.hr = pICollection->Populate();
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_POPULATING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in populating the collection object. hr = 0x%08lx", ft.hr);
        }

        // End intializing
        m_pICollection = pICollection;
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMCatalogCollection::Attach(
    IN  CVssCOMCatalogObject& parentObject
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::Attach_ToParentCollection" );

    try
    {
        // Begin intializing
        m_bInitialized = false;
        m_pICollection = NULL;

        // Check if Collection type is valid
        if ((m_eType <= 0) || (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"Invalid collection type");

        // Converting collection name into BSTR
        CComBSTR bstrCollectionName = g_VsCOMCollectionsArray[m_eType].wszName;
        if (!bstrCollectionName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

       // Get the parent object interface
        CComPtr<ICatalogObject> pIParentObject = parentObject.GetInterface();
        if (pIParentObject == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Parent object not initialized yet.");
        }

        // Get the Key that uniquely identifies the parent object in the grand parent collection
        CComVariant variant;
        // Beware to not leave variant resources before get_Key call!
        ft.hr = pIParentObject->get_Key(&variant);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GET_COLLECTION_KEY, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting object key. hr = 0x%08lx", ft.hr);
        }

        // Get the grand parent collection interface
        CComPtr<ICatalogCollection> pIGrandParentCollection = parentObject.GetParentInterface();
        if (pIGrandParentCollection == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Parent object not initialized.");
        }

        // Get the collection object
        CComPtr<IDispatch> pIDisp;
        ft.hr = pIGrandParentCollection->GetCollection(bstrCollectionName, variant, &pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GET_COLLECTION_FROM_PARENT, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting collection. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogCollection
        ICatalogCollection* pICollection;
        ft.hr = pIDisp->SafeQI(ICatalogCollection, &pICollection);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogCollection. hr = 0x%08lx", ft.hr);
        BS_ASSERT(pICollection);
        m_pICollection.Attach(pICollection);

        // Populate the collection
        ft.hr = m_pICollection->Populate();
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_POPULATING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in populating the collection object. hr = 0x%08lx", ft.hr);
        }

        // End intializing
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMCatalogCollection::SaveChanges()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::SaveChanges" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        // Save changes
        LONG lRet = 0;
        ft.hr = m_pICollection->SaveChanges(&lRet);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_SAVING_CHANGES, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in saving the changes. hr = 0x%08lx", ft.hr);
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMCatalogCollection


HRESULT CVssCOMCatalogObject::InsertInto(
    IN  CVssCOMCatalogCollection& collection
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogObject::InsertInto" );

    try
    {
        // Begin initialization
        m_bInitialized = false;
        m_pIObject = NULL;
        m_pIParentCollection = NULL;
        m_lIndex = -1;

        // Get the collection object
        CComPtr<ICatalogCollection> pIParentCollection = collection.GetInterface();
        if (pIParentCollection == NULL)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Collection object not initialized");

        // Get the instance of the new object
        CComPtr<IDispatch>      pIDisp;
        ft.hr = pIParentCollection->Add(&pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_INSERT_INTO, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in adding the catalog object. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogObject
        BS_ASSERT(m_pIObject == NULL);
        ft.hr = pIDisp->SafeQI(ICatalogObject, &m_pIObject);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogObject. hr = 0x%08lx", ft.hr);

        // End initialization
        m_pIParentCollection = pIParentCollection;
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

//
//  Disclaimer: this method assumes that the collection is already populated
//
//  S_FALSE means object not found
//
HRESULT CVssCOMCatalogObject::AttachByName(
    IN  CVssCOMCatalogCollection& collection,
    IN  const WCHAR wszName[],
    IN  const WCHAR wszPropertyName[] /* = NULL */
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogObject::AttachByName" );

    try
    {
        // Begin initialization
        m_bInitialized = false;
        m_pIObject = NULL;
        m_pIParentCollection = NULL;
        m_lIndex = -1;

        // Check if Object type is valid
        if ((m_eType <= 0) && (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Invalid object type");
        if (m_eType != collection.GetType())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Object type doesn't match with collection type");

        // Get the collection object
        CComPtr<ICatalogCollection> pIParentCollection = collection.GetInterface();
        if (pIParentCollection == NULL)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Collection object not initialized.");

        // Get the name of the property used as a key
        CComBSTR bstrPropertyName;
        if (wszPropertyName == NULL)
            bstrPropertyName = g_VsCOMCollectionsArray[m_eType].wszDefaultKey;
        else
            bstrPropertyName = wszPropertyName;

        // Get the number of objects in the collection
        LONG lCount = -1;
        ft.hr = pIParentCollection->get_Count(&lCount);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying the number of elements. hr = 0x%08lx", ft.hr);
        if (lCount == 0)
            ft.Trace(VSSDBG_GEN, L"Empty collection");

        CComVariant varObjectName = wszName;

        CComVariant variant;
        CComPtr<IDispatch> pIDisp;
        CComPtr<ICatalogObject> pIObject;
        for(LONG lIndex = 0; lIndex < lCount; lIndex++)
        {
            // Release previous references
            pIDisp = pIObject = NULL;

            // Get next item
            ft.hr = pIParentCollection->get_Item(lIndex, &pIDisp);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED,
                    L"Failure in getting object with index %ld. hr = 0x%08lx", lIndex, ft.hr);

            // Convert it to ICatalogObject
            ft.hr = pIDisp->SafeQI(ICatalogObject, &pIObject);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogObject. hr = 0x%08lx", ft.hr);

            variant.Clear(); // do not forget to release resources before get_XXX !
            ft.hr = pIObject->get_Value(bstrPropertyName, &variant);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED,
                    L"Failure in getting value for the object key with index %ld. hr = 0x%08lx", lIndex, ft.hr);

            if (varObjectName == variant)
            {
                m_bInitialized = TRUE;
                m_lIndex = lIndex;
                m_pIParentCollection = pIParentCollection;
                m_pIObject = pIObject;
                break;
            }
        }
        if (!m_bInitialized)
            ft.hr = S_FALSE;    // Object not found!
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\snapshot.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    snapshot.cxx

Abstract:

    Implementation of CVssSnapshotSetDescriptor, CVssSnashotDescriptor,
    and CVssLunMapping classes

    Brian Berkowitz  [brianb]  4/02/2001

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      04/02/2001  Created

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_sec.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"

#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"
#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"
#include "vs_filter.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUESNAPC"

//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszElementSnapshotSetDescription = L"SNAPSHOT_SET_DESCRIPTION";
static LPCWSTR x_wszElementSnapshotDescription = L"SNAPSHOT_DESCRIPTION";
static LPCWSTR x_wszElementLunMapping = L"LUN_MAPPING";
static LPCWSTR x_wszElementLunInformation = L"LUN_INFORMATION";
static LPCWSTR x_wszElementSourceLun = L"SOURCE_LUN";
static LPCWSTR x_wszElementDestinationLun = L"DESTINATION_LUN";
static LPCWSTR x_wszElementInterconnectDescription = L"INTERCONNECT_DESCRIPTION";
static LPCWSTR x_wszElementDiskExtent = L"DISK_EXTENT";
static LPCWSTR x_wszElementRoot = L"root";

static LPCWSTR x_wszAttrSnapshotSetId = L"snapshotSetId";
static LPCWSTR x_wszAttrContext = L"context";
static LPCWSTR x_wszAttrDescription = L"description";
static LPCWSTR x_wszAttrMetadata = L"metadata";
static LPCWSTR x_wszAttrSnapshotId = L"snapshotId";
static LPCWSTR x_wszAttrProviderId = L"providerId";
static LPCWSTR x_wszAttrSnapshotAttributes = L"snapshotAttributes";
static LPCWSTR x_wszAttrOriginatingMachine = L"originatingMachine";
static LPCWSTR x_wszAttrServiceMachine = L"serviceMachine";
static LPCWSTR x_wszAttrOriginalVolumeName = L"originalVolumeName";
static LPCWSTR x_wszAttrTimestamp = L"timestamp";
static LPCWSTR x_wszAttrDeviceName = L"deviceName";
static LPCWSTR x_wszAttrExposedState = L"exposedState";
static LPCWSTR x_wszAttrExposedPath = L"exposedPath";
static LPCWSTR x_wszAttrExposedName = L"exposedName";
static LPCWSTR x_wszAttrStartingOffset = L"startingOffset";
static LPCWSTR x_wszAttrExtentLength = L"extentLength";
static LPCWSTR x_wszAttrDeviceType = L"deviceType";
static LPCWSTR x_wszAttrDeviceTypeModifier = L"deviceTypeModifier";
static LPCWSTR x_wszAttrCommandQueueing = L"commandQueueing";
static LPCWSTR x_wszAttrBusType = L"busType";
static LPCWSTR x_wszAttrVendorId = L"vendorId";
static LPCWSTR x_wszAttrProductId = L"productId";
static LPCWSTR x_wszAttrProductRevision = L"productRevision";
static LPCWSTR x_wszAttrSerialNumber = L"serialNumber";
static LPCWSTR x_wszAttrDiskSignature = L"diskSignature";
static LPCWSTR x_wszAttrInterconnectAddressType = L"interconnectAddressType";
static LPCWSTR x_wszAttrInterconnectPort = L"port";
static LPCWSTR x_wszAttrInterconnectAddress = L"interconnectAddress";
static LPCWSTR x_wszAttrStorageDeviceIdDescriptor = L"deviceIdentification";

// schema string
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssComponentMetadata";

extern WCHAR g_ComponentMetadataXML[];
extern unsigned g_cwcComponentMetadataXML;
extern unsigned g_iwcComponentMetadataXMLEnd;



// load document from xml
void CVssSnapshotSetDescription::LoadFromXML(LPCWSTR bstrXML)
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::LoadFromXML");

    // acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lockDOM(m_csDOM);

    // compute length of constructed document consisting of
    // a root node, schema, and supplied document
    UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXML);

    // allocate string
    CComBSTR bstr;
    bstr.Attach(SysAllocStringLen(NULL, cwcDoc));

    // check for allocation failure
    if (!bstr)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

    // setup pointer to beginning of string
    WCHAR *pwc = bstr;

    // copy in <root> <schema>
    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
    pwc += g_iwcComponentMetadataXMLEnd;

    // copy in document
    wcscpy(pwc, bstrXML);
    pwc += wcslen(bstrXML);

    // copy in </root>
    wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);

    // intialize document with <root><schema></root>
    if (!m_doc.LoadFromXML(bstr))
        {
        // reinitialize document
        m_doc.Initialize();
        ft.Throw
            (
            VSSDBG_XML,
            VSS_E_INVALID_XML_DOCUMENT,
            L"Load of snapshot set description document failed"
            );
        }

    // find toplevel <root> element
    if (!m_doc.FindElement(x_wszElementRoot, true))
        MissingElement(ft, x_wszElementRoot);


    // find SNAPSHOT_SET_DESCRIPTION element
    if (!m_doc.FindElement(x_wszElementSnapshotSetDescription, true))
        MissingElement(ft, x_wszElementSnapshotSetDescription);

    // set SNAPSHOT_SET_DESCRIPTION as toplevel element
    m_doc.SetToplevel();
    }


STDMETHODIMP CVssSnapshotSetDescription::SaveAsXML
    (
    OUT BSTR *pbstrXML
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::SaveAsXML");

    try
        {
        // validate output parameter
        if (pbstrXML == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initialize output parameter
        *pbstrXML = NULL;

        CVssSafeAutomaticLock lock(m_csDOM);
        *pbstrXML = m_doc.SaveAsXML();
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CVssSnapshotSetDescription::GetToplevelNode
    (
    OUT IXMLDOMNode **ppNode,
    OUT IXMLDOMDocument **ppDoc
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetToplevelNode");

    try
        {
        VssZeroOut(ppNode);
        VssZeroOut(ppDoc);

        if (ppNode == NULL || ppDoc == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);

        m_doc.ResetToDocument();

        *ppNode = m_doc.GetCurrentNode();
        (*ppNode)->AddRef();
        *ppDoc = m_doc.GetInterface();
        (*ppDoc)->AddRef();
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }


// obtain the snapshot set id
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotSetDescription::GetSnapshotSetId
    (
    OUT VSS_ID *pidSnapshotSet
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetSnapshotSetId");

    ft.hr = GetVSS_IDAttributeValue(ft, x_wszAttrSnapshotSetId, true, pidSnapshotSet);

    return ft.hr;
    }

// obtain the snapshot set description
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pbstrDescription is NULL
//      E_UNEXPECTED for an unexpected error
//

STDMETHODIMP CVssSnapshotSetDescription::GetDescription
    (
    OUT BSTR *pbstrDescription
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetDescription");

    ft.hr = GetStringAttributeValue(ft, x_wszAttrDescription, false, pbstrDescription);

    return ft.hr;
    }

// set the snapshot set description
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if bstrDescription is NULL
//      E_UNEXPECTED for an unexpected error
//

STDMETHODIMP CVssSnapshotSetDescription::SetDescription
    (
    IN LPCWSTR wszDescription
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::SetDescription");

    try
        {
        if (wszDescription == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input parameter is NULL.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrDescription, wszDescription);
        }
    VSS_STANDARD_CATCH(ft);

    return ft.hr;
    }

// obtain the snapshot set metadata
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if wszMetadata is NULL
//      E_UNEXPECTED for an unexpected error
//
STDMETHODIMP CVssSnapshotSetDescription::GetMetadata
    (
    OUT BSTR *pbstrMetadata
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetMetadata");

    ft.hr = GetStringAttributeValue(ft, x_wszAttrMetadata, false, pbstrMetadata);
    return ft.hr;
    }

// change the snapshot set description
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if wszMetadata is NULL
//      E_UNEXPECTED for an unexpected error
//

STDMETHODIMP CVssSnapshotSetDescription::SetMetadata
    (
    IN LPCWSTR wszMetadata
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::SetMetadata");

    try
        {
        if (wszMetadata == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrMetadata, wszMetadata);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// obtain the snapshot set id
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if plContext is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotSetDescription::GetContext
    (
    OUT LONG *plContext
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetContext");

    try
        {
        if (plContext == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        *plContext = 0;
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        CComBSTR bstrContext;

        if (!m_doc.FindAttribute(x_wszAttrContext, &bstrContext))
            MissingAttribute(ft, x_wszAttrContext);

        *plContext = _wtoi(bstrContext);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// get count of snapshots in the snapshot set
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pcSnapshots is NULL
//      E_UNEXPECTED for an unexpected error
//
STDMETHODIMP CVssSnapshotSetDescription::GetSnapshotCount
    (
    OUT UINT *pcSnapshots
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetSnapshotCount");

    ft.hr = GetElementCount(x_wszElementSnapshotDescription, pcSnapshots);

    return ft.hr;
    }

// get a specific snapshot description
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pcSnapshots is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_OBJECT_NOT_FOUND if iSnapshot >= count of snapshots.
//

STDMETHODIMP CVssSnapshotSetDescription::GetSnapshotDescription
    (
    IN UINT iSnapshot,
    OUT IVssSnapshotDescription **ppSnapshot
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetSnapshotDescription");

    CVssSnapshotDescription *pSnapshotDescription = NULL;

    try
        {
        if (ppSnapshot == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

        *ppSnapshot = NULL;

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        if (!m_doc.FindElement(x_wszElementSnapshotDescription, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the %d snaphot description.",
                iSnapshot
                );

        for (UINT i = 0; i < iSnapshot; i++)
            {
            if (!m_doc.FindElement(x_wszElementSnapshotDescription, FALSE))
                ft.Throw
                    (
                    VSSDBG_XML,
                    VSS_E_OBJECT_NOT_FOUND,
                    L"Cannot find the %d snaphot description.",
                    iSnapshot
                    );
            }

        pSnapshotDescription = new CVssSnapshotDescription
                                    (
                                    m_doc.GetCurrentNode(),
                                    m_doc.GetInterface()
                                    );

        if (pSnapshotDescription == NULL)
            ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate snapshot description.");

        pSnapshotDescription->Initialize(ft);
        *ppSnapshot = (IVssSnapshotDescription *) pSnapshotDescription;
        ((IVssSnapshotDescription *) pSnapshotDescription)->AddRef();
        pSnapshotDescription = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    delete pSnapshotDescription;

    return ft.hr;
    }


// delete a specific snapshot description
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pcSnapshots is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_OBJECT_NOT_FOUND if iSnapshot >= count of snapshots.
//

STDMETHODIMP CVssSnapshotSetDescription::DeleteSnapshotDescription
    (
    IN VSS_ID snapshotId
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetSnapshotDescription");

    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        CComPtr<IXMLDOMNode> pNodeSnapshotSet = m_doc.GetCurrentNode();

        if (!m_doc.FindElement(x_wszElementSnapshotDescription, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the snaphot description for snapshot." WSTR_GUID_FMT,
                GUID_PRINTF_ARG(snapshotId)
                );

        while(TRUE)
            {
            CComBSTR bstrVal;
            VSS_ID idCur;

            if (!m_doc.FindAttribute(x_wszAttrSnapshotId, &bstrVal))
                MissingAttribute(ft, x_wszAttrSnapshotId);

            ConvertToVSS_ID(ft, bstrVal, &idCur);
            if (idCur == snapshotId)
                {
                CComPtr<IXMLDOMNode> pNodeRemoved;
                ft.hr = pNodeSnapshotSet->removeChild(m_doc.GetCurrentNode(), &pNodeRemoved);
                ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::removeChild");
                break;
                }

            if (!m_doc.FindElement(x_wszElementSnapshotDescription, FALSE))
                ft.Throw
                    (
                    VSSDBG_XML,
                    VSS_E_OBJECT_NOT_FOUND,
                    L"Cannot find the %d snaphot description." WSTR_GUID_FMT,
                    GUID_PRINTF_ARG(snapshotId)
                    );

            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }


// get a specific snapshot description based on the snapshot id
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pcSnapshots is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_OBJECT_NOT_FOUND if iSnapshot >= count of snapshots.
//

STDMETHODIMP CVssSnapshotSetDescription::FindSnapshotDescription
    (
    IN VSS_ID SnapshotId,
    OUT IVssSnapshotDescription **ppSnapshot
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::GetSnapshotDescription");

    CVssSnapshotDescription *pSnapshotDescription = NULL;

    try
        {
        if (ppSnapshot == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

        *ppSnapshot = NULL;

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        if (!m_doc.FindElement(x_wszElementSnapshotDescription, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the snaphot description for snapshot" WSTR_GUID_FMT L".",
                GUID_PRINTF_ARG(SnapshotId)
                );

        while(TRUE)
            {
            VSS_ID id;

            get_VSS_IDValue(ft, x_wszAttrSnapshotId, &id);
            if (id == SnapshotId)
                break;

            if (!m_doc.FindElement(x_wszElementSnapshotDescription, FALSE))
                ft.Throw
                    (
                    VSSDBG_XML,
                    VSS_E_OBJECT_NOT_FOUND,
                    L"Cannot find the snaphot description for snapshot" WSTR_GUID_FMT L".",
                    GUID_PRINTF_ARG(SnapshotId)
                    );
            }

        pSnapshotDescription = new CVssSnapshotDescription
                                    (
                                    m_doc.GetCurrentNode(),
                                    m_doc.GetInterface()
                                    );

        if (pSnapshotDescription == NULL)
            ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate snapshot description.");

        pSnapshotDescription->Initialize(ft);
        *ppSnapshot = (IVssSnapshotDescription *) pSnapshotDescription;
        ((IVssSnapshotDescription *) pSnapshotDescription)->AddRef();
        pSnapshotDescription = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    delete pSnapshotDescription;

    return ft.hr;
    }


// add a snapshot description to the snapshot set description
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pcSnapshots is NULL
//      E_UNEXPECTED for an unexpected error
//      E_OUTOFMEMORY if an out of resources condition is encountered.
//
STDMETHODIMP CVssSnapshotSetDescription::AddSnapshotDescription
    (
    IN VSS_ID idSnapshot,
    IN VSS_ID idProvider
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotSetDescription::AddSnapshotDescription");

    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();

        CXMLNode node = m_doc.CreateNode
                            (
                            x_wszElementSnapshotDescription,
                            NODE_ELEMENT
                            );

        node.SetAttribute(x_wszAttrSnapshotId, idSnapshot);
        node.SetAttribute(x_wszAttrProviderId, idProvider);
        m_doc.InsertNode(node);
        }
    VSS_STANDARD_CATCH(ft);

    return ft.hr;
    }

STDMETHODIMP CVssSnapshotSetDescription::QueryInterface(REFIID, void **)
    {
    return E_NOTIMPL;
    }

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssSnapshotSetDescription::AddRef()
    {
    LONG cRef = InterlockedIncrement(&m_cRef);

    return (ULONG) cRef;
    }

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssSnapshotSetDescription::Release()
    {
    LONG cRef = InterlockedDecrement(&m_cRef);
    BS_ASSERT(cRef >= 0);
    if (cRef == 0)
        {
        // reference count is 0, delete the object
        delete this;
        return 0;
        }
    else
        return (ULONG) cRef;
    }


// obtain the snapshot id
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetSnapshotId
    (
    OUT VSS_ID *pidSnapshot
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetSnapshotId");

    ft.hr = GetVSS_IDAttributeValue(ft, x_wszAttrSnapshotId, true, pidSnapshot);

    return ft.hr;
    }


// obtain the provider id
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetProviderId
    (
    OUT VSS_ID *pidProvider
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetProviderId");

    ft.hr = GetVSS_IDAttributeValue(ft, x_wszAttrProviderId, true, pidProvider);

    return ft.hr;
    }

// obtain the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetTimestamp
    (
    OUT VSS_TIMESTAMP *pTimestamp
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetTimestamp");

    try
        {
        if (pTimestamp == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        *pTimestamp = 0;
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        CComBSTR bstrTimestamp;

        if (!m_doc.FindAttribute(x_wszAttrTimestamp, &bstrTimestamp))
            MissingAttribute(ft, x_wszAttrTimestamp);

        *pTimestamp = _wtoi64(bstrTimestamp);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }


// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::SetTimestamp
    (
    IN VSS_TIMESTAMP timestamp
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::SetTimestamp");

    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrTimestamp, timestamp);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetAttributes
    (
    OUT LONG *plAttributes
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetAttributes");

    try
        {
        if (plAttributes == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        *plAttributes = 0;
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        CComBSTR bstrAttributes;

        if (!m_doc.FindAttribute(x_wszAttrSnapshotAttributes, &bstrAttributes))
            MissingAttribute(ft, x_wszAttrSnapshotAttributes);

        *plAttributes = _wtoi(bstrAttributes);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::SetAttributes
    (
    IN LONG lAttributes
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::SetAttributes");
    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrSnapshotAttributes, lAttributes);
        }
    VSS_STANDARD_CATCH(ft);

    return ft.hr;
    }

// Get the snapshot original volume and machine name
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pbstrOriginatingMachine/pbstrOriginalVolume is NULL
//      E_UNEXPECTED for an unexpected error
//      E_OUTOFMEMORY if out of resources
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetOrigin
    (
    OUT BSTR *pbstrOriginatingMachine,
    OUT BSTR *pbstrOriginalVolume
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetOrigin");

    try
        {
        VssZeroOut(pbstrOriginatingMachine);
        if (pbstrOriginalVolume == NULL || pbstrOriginatingMachine == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        *pbstrOriginalVolume = NULL;

        ft.hr = GetStringAttributeValue(ft, x_wszAttrOriginatingMachine, true, pbstrOriginatingMachine);
        if (!ft.HrFailed())
            ft.hr = GetStringAttributeValue(ft, x_wszAttrOriginalVolumeName, true, pbstrOriginalVolume);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the snapshot original volume and machine name
//
// Returns:
//      S_OK if operation is successful
//      E_OUTOFMEMORY if out of resources
//      E_INVALIDARG if wszOriginatingMachine/wszOriginalVolume is NULL
//      E_UNEXPECTED for an unexpected error
//

STDMETHODIMP CVssSnapshotDescription::SetOrigin
    (
    IN LPCWSTR wszOriginatingMachine,
    IN LPCWSTR wszOriginalVolume
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::SetOrigin");
    try
        {
        if (wszOriginatingMachine == NULL || wszOriginalVolume == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrOriginatingMachine, wszOriginatingMachine);
        m_doc.SetAttribute(x_wszAttrOriginalVolumeName, wszOriginalVolume);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// Get the snapshot service machine name
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pbstrServiceMachine is NULL
//      E_UNEXPECTED for an unexpected error
//      E_OUTOFMEMORY if out of resources
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetServiceMachine
    (
    OUT BSTR *pbstrServiceMachine
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetServiceMachine");

    try
        {
        VssZeroOut(pbstrServiceMachine);
        if (pbstrServiceMachine == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        *pbstrServiceMachine = NULL;

        ft.hr = GetStringAttributeValue(ft, x_wszAttrServiceMachine, true, pbstrServiceMachine);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the snapshot service machine name
//
// Returns:
//      S_OK if operation is successful
//      E_OUTOFMEMORY if out of resources
//      E_INVALIDARG if wszServiceMachine is NULL
//      E_UNEXPECTED for an unexpected error
//

STDMETHODIMP CVssSnapshotDescription::SetServiceMachine
    (
    IN LPCWSTR wszServiceMachine
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::SetServiceMachine");
    try
        {
        if (wszServiceMachine == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrServiceMachine, wszServiceMachine);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// get the device name of the snapshot device.  May not be present if the
// snapshot is transportable.
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_OUTOFMEMORY if out of resources
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetDeviceName
    (
    OUT BSTR *pbstrDeviceName
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetDeviceName");

    ft.hr = GetStringAttributeValue(ft, x_wszAttrDeviceName, false, pbstrDeviceName);
    return ft.hr;
    }


// set the device name
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_OUTOFMEMORY if out of resources
//      E_UNEXPECTED for an unexpected error
//

STDMETHODIMP CVssSnapshotDescription::SetDeviceName
    (
    IN LPCWSTR wszDeviceName
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::SetDeviceName");
    try
        {
        if (wszDeviceName == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrDeviceName, wszDeviceName);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// obtain the path and exposed name of the snapshot
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetExposure
    (
    OUT BSTR *pbstrExposedName,
    OUT BSTR *pbstrExposedPath
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetExposure");
    try
        {
        VssZeroOut(pbstrExposedPath);
        if (pbstrExposedName == NULL || pbstrExposedPath == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        ft.hr = GetStringAttributeValue(ft, x_wszAttrExposedPath, false, pbstrExposedPath);
        if (!ft.HrFailed())
            ft.hr = GetStringAttributeValue(ft, x_wszAttrExposedName, false, pbstrExposedName);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the path and exposed name of the snapshot
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      E_OUTOFMEMORY if out of resources
//

STDMETHODIMP CVssSnapshotDescription::SetExposure
    (
    IN LPCWSTR wszExposedName,
    IN LPCWSTR wszExposedPath
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::SetExposure");
    try
        {
        if (wszExposedName == NULL || wszExposedPath == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrExposedName, wszExposedName);
        m_doc.SetAttribute(x_wszAttrExposedPath, wszExposedPath);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetLunCount
    (
    OUT UINT *pcLuns
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetLunCount");

    ft.hr = GetElementCount(x_wszElementLunMapping, pcLuns);
    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::AddLunMapping()
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::AddLunMapping");

    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();

        CXMLNode node = m_doc.CreateNode
                            (
                            x_wszElementLunMapping,
                            NODE_ELEMENT
                            );

        CXMLNode nodeSource = m_doc.CreateNode
                                (
                                x_wszElementSourceLun,
                                NODE_ELEMENT
                                );

        CXMLNode nodeSourceLunInfo = m_doc.CreateNode
                                (
                                x_wszElementLunInformation,
                                NODE_ELEMENT
                                );


        CXMLNode nodeDestLunInfo = m_doc.CreateNode
                                (
                                x_wszElementLunInformation,
                                NODE_ELEMENT
                                );


        CXMLNode nodeDest = m_doc.CreateNode
                                (
                                x_wszElementDestinationLun,
                                NODE_ELEMENT
                                );

        nodeSource.InsertNode(nodeSourceLunInfo);
        nodeDest.InsertNode(nodeDestLunInfo);
        node.InsertNode(nodeSource);
        node.InsertNode(nodeDest);
        m_doc.InsertNode(node);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssSnapshotDescription::GetLunMapping
    (
    UINT iMapping,
    OUT IVssLunMapping **ppLunMapping
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssSnapshotDescription::GetLunMapping");

    CVssLunMapping *pLunMapping = NULL;

    try
        {
        if (ppLunMapping == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

        *ppLunMapping = NULL;

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        if (!m_doc.FindElement(x_wszElementLunMapping, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the %d lun mapping.",
                iMapping
                );

        for (UINT i = 0; i < iMapping; i++)
            {
            if (!m_doc.FindElement(x_wszElementLunMapping, FALSE))
                ft.Throw
                    (
                    VSSDBG_XML,
                    VSS_E_OBJECT_NOT_FOUND,
                    L"Cannot find the %d lun mapping.",
                    iMapping
                    );
            }

        pLunMapping = new CVssLunMapping
                                    (
                                    m_doc.GetCurrentNode(),
                                    m_doc.GetInterface()
                                    );

        if (pLunMapping == NULL)
            ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate lun mapping.");

        pLunMapping->Initialize(ft);
        *ppLunMapping = (IVssLunMapping *) pLunMapping;
        ((IVssLunMapping *) pLunMapping)->AddRef();
        pLunMapping = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    delete pLunMapping;
    return ft.hr;
    }

STDMETHODIMP CVssSnapshotDescription::QueryInterface(REFIID, void **)
    {
    return E_NOTIMPL;
    }

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssSnapshotDescription::AddRef()
    {
    LONG cRef = InterlockedIncrement(&m_cRef);

    return (ULONG) cRef;
    }

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssSnapshotDescription::Release()
    {
    LONG cRef = InterlockedDecrement(&m_cRef);
    BS_ASSERT(cRef >= 0);
    if (cRef == 0)
        {
        // reference count is 0, delete the object
        delete this;
        return 0;
        }
    else
        return (ULONG) cRef;
    }

// add a disk extent to the lun mapping
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      E_OUTOFMEMORY if out of resources
//

STDMETHODIMP CVssLunMapping::AddDiskExtent
    (
    IN ULONGLONG startingOffset,
    IN ULONGLONG length
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunMapping::AddDiskExtent");
    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();

        CXMLNode node = m_doc.CreateNode
                            (
                            x_wszElementDiskExtent,
                            NODE_ELEMENT
                            );

        node.SetAttribute(x_wszAttrStartingOffset, (LONGLONG) startingOffset);
        node.SetAttribute(x_wszAttrExtentLength, (LONGLONG) length);
        m_doc.InsertNode(node);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// obtain count of disk extents
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunMapping::GetDiskExtentCount
    (
    OUT UINT *pcExtents
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunMapping::GetDiskExtentCount");

    ft.hr = GetElementCount(x_wszElementDiskExtent, pcExtents);

    return ft.hr;
    }

// obtain a specific disk extent
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunMapping::GetDiskExtent
    (
    IN UINT iExtent,
    OUT ULONGLONG *pllStartingOffset,
    OUT ULONGLONG *pllLength
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunMapping::GetDiskExtent");
    try
        {
        VssZeroOut(pllStartingOffset);
        VssZeroOut(pllLength);
        if (pllStartingOffset == NULL || pllLength == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        if (!m_doc.FindElement(x_wszElementDiskExtent, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the %d disk extent.",
                iExtent
                );

        for (UINT i = 0; i < iExtent; i++)
            {
            if (!m_doc.FindElement(x_wszElementDiskExtent, FALSE))
                ft.Throw
                    (
                    VSSDBG_XML,
                    VSS_E_OBJECT_NOT_FOUND,
                    L"Cannot find the %d disk extent.",
                    iExtent
                    );
            }

        CComBSTR bstrStartingOffset;
        CComBSTR bstrLength;
        if (!m_doc.FindAttribute(x_wszAttrStartingOffset, &bstrStartingOffset))
            MissingAttribute(ft, x_wszAttrStartingOffset);

        if (!m_doc.FindAttribute(x_wszAttrExtentLength, &bstrLength))
            MissingAttribute(ft, x_wszAttrExtentLength);

        *pllStartingOffset = _wtoi64(bstrStartingOffset);
        *pllLength = _wtoi64(bstrLength);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

HRESULT CVssLunMapping::GetLunInformation
    (
    IN LPCWSTR wszElement,
    OUT IVssLunInformation **ppLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunMapping::GetLunInformation");

    CVssLunInformation *pLun = NULL;
    try
        {
        if (ppLun == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        *ppLun = NULL;

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        if (!m_doc.FindElement(wszElement, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the %s.",
                wszElement
                );


        if (!m_doc.FindElement(x_wszElementLunInformation, TRUE))
            MissingElement(ft, x_wszElementLunInformation);

        pLun = new CVssLunInformation
                        (
                        m_doc.GetCurrentNode(),
                        m_doc.GetInterface()
                        );

        if (pLun == NULL)
            ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate lun information.");

        pLun->Initialize(ft);
        *ppLun = (IVssLunInformation *) pLun;
        ((IVssLunInformation *) pLun)->AddRef();
        pLun = NULL;
        }
    VSS_STANDARD_CATCH(ft);

    delete pLun;
    return ft.hr;
    }


// obtains the source lun from a lun mapping.
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunMapping::GetSourceLun
    (
    OUT IVssLunInformation **ppLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunMapping::GetSourceLun");

    ft.hr = GetLunInformation(x_wszElementSourceLun, ppLun);
    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunMapping::GetDestinationLun
    (
    OUT IVssLunInformation **ppLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunMapping::GetTargetLun");

    ft.hr = GetLunInformation(x_wszElementDestinationLun, ppLun);
    return ft.hr;
    }

STDMETHODIMP CVssLunMapping::QueryInterface(REFIID, void **)
    {
    return E_NOTIMPL;
    }

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssLunMapping::AddRef()
    {
    LONG cRef = InterlockedIncrement(&m_cRef);

    return (ULONG) cRef;
    }

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssLunMapping::Release()
    {
    LONG cRef = InterlockedDecrement(&m_cRef);
    BS_ASSERT(cRef >= 0);
    if (cRef == 0)
        {
        // reference count is 0, delete the object
        delete this;
        return 0;
        }
    else
        return (ULONG) cRef;
    }


// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::SetLunBasicType
    (
    IN UCHAR DeviceType,
    IN UCHAR DeviceTypeModifier,
    IN BOOL bCommandQueueing,
    IN LPCSTR szVendorId,
    IN LPCSTR szProductId,
    IN LPCSTR szProductRevision,
    IN LPCSTR szSerialNumber,
    IN VDS_STORAGE_BUS_TYPE busType
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::SetLunBasicType");
    try
        {
        LPCWSTR wszBusType = WszFromBusType(ft, busType);
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();

        m_doc.SetAttribute(x_wszAttrDeviceType, (INT) DeviceType);
        m_doc.SetAttribute(x_wszAttrDeviceTypeModifier, (INT) DeviceTypeModifier);
        m_doc.SetAttribute(x_wszAttrCommandQueueing, WszFromBoolean(bCommandQueueing ? true : false));
        if (szVendorId)
            m_doc.SetAttribute(x_wszAttrVendorId, szVendorId);

        if (szProductId)
            m_doc.SetAttribute(x_wszAttrProductId, szProductId);

        if (szProductRevision)
            m_doc.SetAttribute(x_wszAttrProductRevision, szProductRevision);

        if (szSerialNumber)
            m_doc.SetAttribute(x_wszAttrSerialNumber, szSerialNumber);

        m_doc.SetAttribute(x_wszAttrBusType, wszBusType);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// obtain basic information about the lun
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      E_OUTOFMEMORY if out of resources
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::GetLunBasicType
    (
    OUT UCHAR *pDeviceType,
    OUT UCHAR *pDeviceTypeModifier,
    OUT BOOL *pbCommandQueueing,
    OUT LPSTR *pstrVendorId,
    OUT LPSTR *pstrProductId,
    OUT LPSTR *pstrProductRevision,
    OUT LPSTR *pstrSerialNumber,
    OUT VDS_STORAGE_BUS_TYPE *pbusType
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::GetLunBasicType");

    try
        {
        VssZeroOut(pDeviceType);
        VssZeroOut(pDeviceTypeModifier);
        VssZeroOut(pbCommandQueueing);
        VssZeroOut(pstrVendorId);
        VssZeroOut(pstrProductId);
        VssZeroOut(pstrProductRevision);
        VssZeroOut(pstrSerialNumber);
        VssZeroOut(pbusType);

        if (pDeviceType == NULL ||
            pDeviceTypeModifier == NULL ||
            pbCommandQueueing == NULL ||
            pstrVendorId == NULL ||
            pstrProductId == NULL ||
            pstrProductRevision == NULL ||
            pstrSerialNumber == NULL ||
            pbusType == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");


        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();

        CComBSTR bstrVal;

        if (!m_doc.FindAttribute(x_wszAttrDeviceType, &bstrVal))
            MissingAttribute(ft, x_wszAttrDeviceType);

        INT val = _wtoi(bstrVal);
        bstrVal.Empty();
        if (val > 256)
            ft.Throw(VSSDBG_XML, VSS_E_INVALID_XML_DOCUMENT, L"Bad Device type.");

        *pDeviceType = (BYTE) val;

        if (!m_doc.FindAttribute(x_wszAttrDeviceTypeModifier, &bstrVal))
            MissingAttribute(ft, x_wszAttrDeviceTypeModifier);

        val = _wtoi(bstrVal);
        bstrVal.Empty();
        if (val > 256)
            ft.Throw(VSSDBG_XML, VSS_E_INVALID_XML_DOCUMENT, L"Bad Device type modifier.");

        *pDeviceTypeModifier = (BYTE) val;

        bool bCommandQueueing;
        get_boolValue(ft, x_wszAttrCommandQueueing, &bCommandQueueing);
        *pbCommandQueueing = (BOOL) bCommandQueueing;

        get_ansi_stringValue(ft, x_wszAttrVendorId, pstrVendorId);
        get_ansi_stringValue(ft, x_wszAttrProductId, pstrProductId);
        get_ansi_stringValue(ft, x_wszAttrProductRevision, pstrProductRevision);
        get_ansi_stringValue(ft, x_wszAttrSerialNumber, pstrSerialNumber);

        if (!m_doc.FindAttribute(x_wszAttrBusType, &bstrVal))
            MissingAttribute(ft, x_wszAttrBusType);

        *pbusType = ConvertToStorageBusType(ft, bstrVal);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// obtain the disk signature
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::GetDiskSignature
    (
    OUT VSS_ID *pidSignature
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::GetDiskSignature");

    ft.hr = GetVSS_IDAttributeValue(ft, x_wszAttrDiskSignature, true, pidSignature);
    return ft.hr;
    }

// set the disk signature
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::SetDiskSignature
    (
    IN VSS_ID idSignature
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::SetDiskSignature");

    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        m_doc.SetAttribute(x_wszAttrDiskSignature, idSignature);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::AddInterconnectAddress
    (
    IN VDS_INTERCONNECT_ADDRESS_TYPE type,
    IN ULONG cbPort,
    IN const BYTE *pbPort,
    IN ULONG cbAddress,
    IN const BYTE *pbInterconnectAddress
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::AddInterconnectAddress");
    try
        {
        LPCWSTR wszType = WszFromInterconnectAddressType(ft, type);

        if (pbInterconnectAddress == NULL || cbAddress == 0)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Required input parameter.");

        CXMLNode node = m_doc.CreateNode
                            (
                            x_wszElementInterconnectDescription,
                            NODE_ELEMENT
                            );

        node.SetAttribute(x_wszAttrInterconnectAddressType, wszType);
        if (pbPort)
            node.SetAttribute(x_wszAttrInterconnectPort, pbPort, cbPort);

        node.SetAttribute(x_wszAttrInterconnectAddress, pbInterconnectAddress, cbAddress);
        m_doc.InsertNode(node);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::GetInterconnectAddressCount
    (
    OUT UINT *pcAddresses
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::GetInterconnectAddressCount");

    ft.hr = GetElementCount(x_wszElementInterconnectDescription, pcAddresses);
    return ft.hr;
    }

// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//
STDMETHODIMP CVssLunInformation::GetInterconnectAddress
    (
    IN UINT iAddress,
    OUT VDS_INTERCONNECT_ADDRESS_TYPE *pType,
    OUT ULONG *pcbPort,
    OUT LPBYTE *ppbPort,
    OUT ULONG *pcbAddress,
    OUT LPBYTE *ppbInterconnectAddress
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::GetInterconnectAddress");

    BYTE *pbInterconnectAddress = NULL;
    BYTE *pbPort = NULL;
    try
        {
        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();
        if (!m_doc.FindElement(x_wszElementInterconnectDescription, TRUE))
            ft.Throw
                (
                VSSDBG_XML,
                VSS_E_OBJECT_NOT_FOUND,
                L"Cannot find the %d interconnect address.",
                iAddress
                );

        for (UINT i = 0; i < iAddress; i++)
            {
            if (!m_doc.FindElement(x_wszElementInterconnectDescription, FALSE))
                ft.Throw
                    (
                    VSSDBG_XML,
                    VSS_E_OBJECT_NOT_FOUND,
                    L"Cannot find the %d interconnect address.",
                    iAddress
                    );
            }

        CComBSTR bstrAddressType;
        if (!m_doc.FindAttribute(x_wszAttrInterconnectAddressType, &bstrAddressType))
            MissingAttribute(ft, x_wszAttrInterconnectAddressType);

        *pType = ConvertToInterconnectAddressType(ft, bstrAddressType);
        UINT cbAddress, cbPort;

        pbInterconnectAddress = get_byteArrayValue(ft, x_wszAttrInterconnectAddress, true, cbAddress);
        pbPort = get_byteArrayValue(ft, x_wszAttrInterconnectPort, false, cbPort);
        *pcbAddress = (ULONG) cbAddress;
        *pcbPort = (ULONG) cbPort;
        *ppbInterconnectAddress = pbInterconnectAddress;
        pbInterconnectAddress = NULL;
        *ppbPort = pbPort;
        pbPort = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    if (pbPort)
        CoTaskMemFree(pbPort);

    if (pbInterconnectAddress)
        CoTaskMemFree(pbInterconnectAddress);

    return ft.hr;
    }


// set the storage descriptor for the lun
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_OUTOFMEMORY if out of resources
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::SetStorageDeviceIdDescriptor
    (
    IN STORAGE_DEVICE_ID_DESCRIPTOR *pDescriptor
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::SetStorageDeviceIdDescriptor");

    try
        {
        if (pDescriptor == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

        CVssSafeAutomaticLock lock(m_csDOM);
        m_doc.ResetToDocument();

        m_doc.SetAttribute
            (
            x_wszAttrStorageDeviceIdDescriptor,
            (const BYTE *) pDescriptor,
            pDescriptor->Size
            );
        }
    VSS_STANDARD_CATCH(ft)


    return ft.hr;
    }


// set the time that the snapshot was taken
//
// Returns:
//      S_OK if operation is successful
//      E_INVALIDARG if pidSnapshotSet is NULL
//      E_UNEXPECTED for an unexpected error
//      VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//

STDMETHODIMP CVssLunInformation::GetStorageDeviceIdDescriptor
    (
    OUT STORAGE_DEVICE_ID_DESCRIPTOR **ppDescriptor
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssLunInformation::GetStorageDeviceIdDescriptor");

    UINT cbDescriptor;

    ft.hr = GetByteArrayAttributeValue
        (
        ft,
        x_wszAttrStorageDeviceIdDescriptor,
        true,
        (BYTE **) ppDescriptor,
        &cbDescriptor
        );

    return ft.hr;
    }



STDMETHODIMP CVssLunInformation::QueryInterface(REFIID, void **)
    {
    return E_NOTIMPL;
    }

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssLunInformation::AddRef()
    {
    LONG cRef = InterlockedIncrement(&m_cRef);

    return (ULONG) cRef;
    }

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssLunInformation::Release()
    {
    LONG cRef = InterlockedDecrement(&m_cRef);
    BS_ASSERT(cRef >= 0);
    if (cRef == 0)
        {
        // reference count is 0, delete the object
        delete this;
        return 0;
        }
    else
        return (ULONG) cRef;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\helper.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vs_wmxml.cxx

Abstract:

    Implementation of CVssMetadataHelper class

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/30/2000  Created

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "vs_idl.hxx"
 
#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vssmsg.h"


#include "rpcdce.h"
#include "base64coder.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEHELPC"
//
////////////////////////////////////////////////////////////////////////

// boolean type string values
static LPCWSTR x_wszYes = L"yes";
static LPCWSTR x_wszNo = L"no";

// usage type string values
static LPCWSTR x_wszBOOTABLESYSTEMSTATE = L"BOOTABLE_SYSTEM_STATE";
static LPCWSTR x_wszSYSTEMSERVICE = L"SYSTEM_SERVICE";
static LPCWSTR x_wszUSERDATA = L"USER_DATA";
static LPCWSTR x_wszOTHER = L"OTHER";

// source type string values
static LPCWSTR x_wszTRANSACTEDDB = L"TRANSACTION_DB";
static LPCWSTR x_wszNONTRANSACTEDDB = L"NONTRANSACTIONAL_DB";

// component ELEMENT type strings
static LPCWSTR x_wszElementDatabase = L"DATABASE";
static LPCWSTR x_wszElementFilegroup = L"FILE_GROUP";

// component value type strings
static LPCWSTR x_wszValueDatabase = L"database";
static LPCWSTR x_wszValueFilegroup = L"filegroup";

// writerRestore value type strings
static LPCWSTR x_wszNever = L"never";
static LPCWSTR x_wszAlways = L"always";
static LPCWSTR x_wszIfReplaceFails = L"ifReplaceFails";

// string restore methods
static LPCWSTR x_wszRESTOREIFNOTTHERE = L"RESTORE_IF_NONE_THERE";
static LPCWSTR x_wszRESTOREIFCANREPLACE = L"RESTORE_IF_CAN_BE_REPLACED";
static LPCWSTR x_wszSTOPRESTORESTART = L"STOP_RESTART_SERVICE";
static LPCWSTR x_wszRESTORETOALTERNATE = L"RESTORE_TO_ALTERNATE_LOCATION";
static LPCWSTR x_wszRESTOREATREBOOT = L"REPLACE_AT_REBOOT";
static LPCWSTR x_wszCUSTOM = L"CUSTOM";

// string backup types
static LPCWSTR x_wszValueFull = L"full";
static LPCWSTR x_wszValueDifferential = L"differential";
static LPCWSTR x_wszValueIncremental = L"incremental";
static LPCWSTR x_wszValueOther = L"other";
static LPCWSTR x_wszValueLog = L"Log";

// files restored status
static LPCWSTR x_wszNone = L"none";
static LPCWSTR x_wszAll = L"all";
static LPCWSTR x_wszFailed = L"failed";

// restore target status
static LPCWSTR x_wszOriginal = L"original";
static LPCWSTR x_wszAlternate = L"alternate";
static LPCWSTR x_wszNew = L"new";
static LPCWSTR x_wszDirected = L"directed";

// bus types
static LPCWSTR x_wszValueScsi = L"Scsi";
static LPCWSTR x_wszValueAtapi = L"Atapi";
static LPCWSTR x_wszValueAta = L"Ata";
static LPCWSTR x_wszValue1394 = L"1394";
static LPCWSTR x_wszValueSsa = L"Ssa";
static LPCWSTR x_wszValueFibre = L"Fibre";
static LPCWSTR x_wszValueUsb = L"Usb";
static LPCWSTR x_wszValueRAID = L"RAID";

// interconnect address types
static LPCWSTR x_wszValueUNKNOWN = L"UNKNOWN";
static LPCWSTR x_wszValueFCFS = L"FCFS";
static LPCWSTR x_wszValueFCPH = L"FCPH";
static LPCWSTR x_wszValueFCPH3 = L"FCPH3";
static LPCWSTR x_wszValueMAC = L"MAC";



// convert boolean value to "yes" or "no"
LPCWSTR CVssMetadataHelper::WszFromBoolean(IN bool b)
    {
    return b ? x_wszYes : x_wszNo;
    }

// convert from "yes", "no" to a boolean value
bool CVssMetadataHelper::ConvertToBoolean
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	) throw(HRESULT)
	{
	if (wcscmp(bstr, x_wszYes) == 0)
		return true;
	else if (wcscmp(bstr, x_wszNo) == 0)
		return false;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"Value %s is neither yes nor no.",
			bstr
			);

    return false;
	}

// convert a string to a VSS_ID value
void CVssMetadataHelper::ConvertToVSS_ID
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr,
	OUT VSS_ID *pId
	) throw(HRESULT)
	{
	RPC_STATUS status = UuidFromString(bstr, pId);
	if (status != RPC_S_OK)
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"Value %s is not a valid guid.",
			bstr
			);
	}

// convert from VSS_USAGE_TYPE to string value
LPCWSTR CVssMetadataHelper::WszFromUsageType
    (
    IN CVssFunctionTracer &ft,
    IN VSS_USAGE_TYPE usage
    ) throw(HRESULT)
    {
    switch(usage)
        {
        default:
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid usage type");

        case VSS_UT_OTHER:
            return(x_wszOTHER);

        case VSS_UT_BOOTABLESYSTEMSTATE:
            return(x_wszBOOTABLESYSTEMSTATE);

        case VSS_UT_SYSTEMSERVICE:
			return(x_wszSYSTEMSERVICE);

        case VSS_UT_USERDATA:
			return(x_wszUSERDATA);
		}
    }


// convert from string to VSS_USAGE_TYPE
VSS_USAGE_TYPE CVssMetadataHelper::ConvertToUsageType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	) throw(HRESULT)
	{
	if (wcscmp(bstr, x_wszBOOTABLESYSTEMSTATE) == 0)
        return(VSS_UT_BOOTABLESYSTEMSTATE);
	else if (wcscmp(bstr, x_wszSYSTEMSERVICE) == 0)
		return(VSS_UT_SYSTEMSERVICE);
	else if (wcscmp(bstr, x_wszUSERDATA) == 0)
		return(VSS_UT_USERDATA);
	else if (wcscmp(bstr, x_wszOTHER) == 0)
		return(VSS_UT_OTHER);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid usage type",
			bstr
			);

    return VSS_UT_UNDEFINED;
	}

// convert from a VSS_SOURCE_TYPE value to a string
LPCWSTR CVssMetadataHelper::WszFromSourceType
    (
    IN CVssFunctionTracer &ft,
    IN VSS_SOURCE_TYPE source
    ) throw(HRESULT)
    {
	switch(source)
		{
		default:
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid data source type");

		case VSS_ST_OTHER:
			return(x_wszOTHER);

        case VSS_ST_TRANSACTEDDB:
			return(x_wszTRANSACTEDDB);

        case VSS_ST_NONTRANSACTEDDB:
            return(x_wszNONTRANSACTEDDB);
        }
    }

// convert from a string to a VSS_SOURCE_TYPE value
VSS_SOURCE_TYPE CVssMetadataHelper::ConvertToSourceType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszTRANSACTEDDB) == 0)
		return(VSS_ST_TRANSACTEDDB);
	else if (wcscmp(bstr, x_wszNONTRANSACTEDDB) == 0)
		return(VSS_ST_NONTRANSACTEDDB);
	else if (wcscmp(bstr, x_wszOTHER) == 0)
		return(VSS_ST_OTHER);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid source type.",
			bstr
			);

    return VSS_ST_UNDEFINED;
	}


// convert from VSS_COMPONENT_TYPE to string value
LPCWSTR CVssMetadataHelper::WszFromComponentType
    (
    IN CVssFunctionTracer &ft,
    VSS_COMPONENT_TYPE ct,
	bool bValue
    ) throw(HRESULT)
    {
    switch(ct)
        {
        default:
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid component type");

        case VSS_CT_DATABASE:
            return (bValue ? x_wszValueDatabase : x_wszElementDatabase);

        case VSS_CT_FILEGROUP:
            return(bValue ? x_wszValueDatabase : x_wszElementFilegroup);
        }
    }

// convert from string value to VSS_COMPONENT_TYPE
VSS_COMPONENT_TYPE CVssMetadataHelper::ConvertToComponentType
    (
    IN CVssFunctionTracer &ft,
    IN BSTR bstrName,
	bool bValue
    )
    {
	LPCWSTR wszDatabase = bValue ? x_wszValueDatabase : x_wszElementDatabase;
	LPCWSTR wszFilegroup = bValue ? x_wszValueFilegroup : x_wszElementFilegroup;
    if (wcscmp(bstrName, wszDatabase) == 0)
        return VSS_CT_DATABASE;
    else if (wcscmp(bstrName, wszFilegroup) == 0)
        return VSS_CT_FILEGROUP;
    else
        ft.Throw
            (
            VSSDBG_XML,
            E_INVALIDARG,
            L"The string %s is not a valid component type",
            bstrName
            );

    return VSS_CT_UNDEFINED;
    }


// convert from restore method to string
LPCWSTR CVssMetadataHelper::WszFromRestoreMethod
    (
    IN CVssFunctionTracer &ft,
    IN VSS_RESTOREMETHOD_ENUM method
    )
    {
    switch(method)
        {
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid method type %d",
                method
                );

        case VSS_RME_RESTORE_IF_NOT_THERE:
			return (x_wszRESTOREIFNOTTHERE);

		case VSS_RME_RESTORE_IF_CAN_REPLACE:
            return(x_wszRESTOREIFCANREPLACE);

		case VSS_RME_STOP_RESTORE_START:
            return(x_wszSTOPRESTORESTART);

        case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION:
			return(x_wszRESTORETOALTERNATE);

		case VSS_RME_RESTORE_AT_REBOOT:
            return(x_wszRESTOREATREBOOT);

		case VSS_RME_CUSTOM:
            return(x_wszCUSTOM);
        }
    }


// convert from string to VSS_RESTOREMETHOD_ENUM
VSS_RESTOREMETHOD_ENUM CVssMetadataHelper::ConvertToRestoreMethod
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszRESTOREIFNOTTHERE) == 0)
		return(VSS_RME_RESTORE_IF_NOT_THERE);
	else if (wcscmp(bstr, x_wszRESTOREIFCANREPLACE) == 0)
		return(VSS_RME_RESTORE_IF_CAN_REPLACE);
	else if (wcscmp(bstr, x_wszSTOPRESTORESTART) == 0)
		return(VSS_RME_STOP_RESTORE_START);
	else if (wcscmp(bstr, x_wszRESTORETOALTERNATE) == 0)
		return(VSS_RME_RESTORE_TO_ALTERNATE_LOCATION);
	else if (wcscmp(bstr, x_wszRESTOREATREBOOT) == 0)
		return(VSS_RME_RESTORE_AT_REBOOT);
	else if (wcscmp(bstr, x_wszCUSTOM) == 0)
		return(VSS_RME_CUSTOM);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restore method.",
			bstr
			);

    return VSS_RME_UNDEFINED;
	}

// convert from restore method to string
LPCWSTR CVssMetadataHelper::WszFromWriterRestore
    (
    IN CVssFunctionTracer &ft,
    IN VSS_WRITERRESTORE_ENUM method
    )
    {
    switch(method)
        {
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid writerRestore type %d",
                method
                );

        case VSS_WRE_NEVER:
			return x_wszNever;

		case VSS_WRE_IF_REPLACE_FAILS:
            return x_wszIfReplaceFails;

		case VSS_WRE_ALWAYS:
            return x_wszAlways;
        }
    }


	
// convert from string to VSS_RESTOREMETHOD_ENUM
VSS_WRITERRESTORE_ENUM CVssMetadataHelper::ConvertToWriterRestore
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszNever) == 0)
		return VSS_WRE_NEVER;
	else if (wcscmp(bstr, x_wszIfReplaceFails) == 0)
		return VSS_WRE_IF_REPLACE_FAILS;
	else if (wcscmp(bstr, x_wszAlways) == 0)
		return VSS_WRE_ALWAYS;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restore method.",
			bstr
			);

    return VSS_WRE_UNDEFINED;
	}


// convert VSS_BACKUP_TYPE to string
LPCWSTR CVssMetadataHelper::WszFromBackupType
	(
	IN CVssFunctionTracer &ft,
	IN VSS_BACKUP_TYPE bt
	)
	{
	switch(bt)
		{
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid backupType %d",
                bt
                );

        case VSS_BT_INCREMENTAL:
			return x_wszValueIncremental;

		case VSS_BT_DIFFERENTIAL:
            return x_wszValueDifferential;

		case VSS_BT_FULL:
            return x_wszValueFull;

        case VSS_BT_LOG:
			return x_wszValueLog;

        case VSS_BT_OTHER:
			return x_wszValueOther;
        }
	}

// convert from string to backup type
VSS_BACKUP_TYPE CVssMetadataHelper::ConvertToBackupType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszValueIncremental) == 0)
		return VSS_BT_INCREMENTAL;
	else if (wcscmp(bstr, x_wszValueDifferential) == 0)
		return VSS_BT_DIFFERENTIAL;
	else if (wcscmp(bstr, x_wszValueFull) == 0)
		return VSS_BT_FULL;
	else if (wcscmp(bstr, x_wszValueOther) == 0)
		return VSS_BT_OTHER;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid backup type.",
			bstr
			);

    return VSS_BT_UNDEFINED;
    }


// convert VSS_RESTORE_TARGET to string
LPCWSTR CVssMetadataHelper::WszFromRestoreTarget
	(
	IN CVssFunctionTracer &ft,
	IN VSS_RESTORE_TARGET rt
	)
	{
	switch(rt)
		{
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid restoreTarget %d",
                rt
                );

        case VSS_RT_ORIGINAL:
			return x_wszOriginal;

		case VSS_RT_ALTERNATE:
            return x_wszAlternate;

		case VSS_RT_NEW:
            return x_wszNew;

        case VSS_RT_DIRECTED:
			return x_wszDirected;
        }
	}

// convert from string to restore target
VSS_RESTORE_TARGET CVssMetadataHelper::ConvertToRestoreTarget
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszOriginal) == 0)
		return VSS_RT_ORIGINAL;
	else if (wcscmp(bstr, x_wszAlternate) == 0)
		return VSS_RT_ALTERNATE;
	else if (wcscmp(bstr, x_wszNew) == 0)
		return VSS_RT_NEW;
	else if (wcscmp(bstr, x_wszDirected) == 0)
		return VSS_RT_DIRECTED;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restoreTarget.",
			bstr
			);

    return VSS_RT_UNDEFINED;
    }


// convert VSS_FILE_RESTORE_STATUS to string
LPCWSTR CVssMetadataHelper::WszFromFileRestoreStatus
	(
	IN CVssFunctionTracer &ft,
	IN VSS_FILE_RESTORE_STATUS rs
	)
	{
	switch(rs)
		{
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid restoreTarget %d",
                rs
                );

        case VSS_RS_NONE:
			return x_wszNone;

		case VSS_RS_ALL:
            return x_wszAll;

		case VSS_RS_FAILED:
            return x_wszFailed;
        }
	}

// convert from string to File restore status
VSS_FILE_RESTORE_STATUS CVssMetadataHelper::ConvertToFileRestoreStatus
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszNone) == 0)
		return VSS_RS_NONE;
	else if (wcscmp(bstr, x_wszAll) == 0)
		return VSS_RS_ALL;
	else if (wcscmp(bstr, x_wszFailed) == 0)
		return VSS_RS_FAILED;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid file restore status.",
			bstr
			);

    return VSS_RS_UNDEFINED;
    }

LPCWSTR CVssMetadataHelper::WszFromBusType
	(
	IN CVssFunctionTracer &ft,
	IN VDS_STORAGE_BUS_TYPE type
	)
	{
	switch(type)
		{
		default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid bus type %d",
                type
                );

         case VDSBusTypeScsi:
			 return x_wszValueScsi;

		 case VDSBusTypeAtapi:
			 return x_wszValueAtapi;

		 case VDSBusTypeAta:
			 return x_wszValueAta;

		 case VDSBusType1394:
			 return x_wszValue1394;

         case VDSBusTypeSsa:
			 return x_wszValueSsa;

         case VDSBusTypeFibre:
			 return x_wszValueFibre;

         case VDSBusTypeUsb:
			 return x_wszValueUsb;

         case VDSBusTypeRAID:
			 return x_wszValueRAID;
         }
	 }


VDS_STORAGE_BUS_TYPE CVssMetadataHelper::ConvertToStorageBusType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstrBusType
	)
	{
	if (wcscmp(bstrBusType, x_wszValueScsi) == 0)
		return VDSBusTypeScsi;
	else if (wcscmp(bstrBusType, x_wszValueAtapi) == 0)
		return VDSBusTypeAtapi;
	else if (wcscmp(bstrBusType, x_wszValueAta) == 0)
		return VDSBusTypeAta;
	else if (wcscmp(bstrBusType, x_wszValue1394) == 0)
		return VDSBusType1394;
	else if (wcscmp(bstrBusType, x_wszValueSsa) == 0)
		return VDSBusTypeSsa;
	else if (wcscmp(bstrBusType, x_wszValueFibre) == 0)
		return VDSBusTypeFibre;
	else if (wcscmp(bstrBusType, x_wszValueUsb) == 0)
        return VDSBusTypeUsb;
	else if (wcscmp(bstrBusType, x_wszValueRAID) == 0)
		return VDSBusTypeRAID;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid storage bus type.",
			bstrBusType
			);

    return VDSBusTypeUnknown;
	}

LPCWSTR CVssMetadataHelper::WszFromInterconnectAddressType
	(
	IN CVssFunctionTracer &ft,
	IN VDS_INTERCONNECT_ADDRESS_TYPE type
	)
	{
	switch(type)
		{
		default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid interconnect address type %d",
                type
                );

         case VDS_IA_FCFS:
			 return x_wszValueFCFS;

		 case VDS_IA_FCPH:
			 return x_wszValueFCPH;

		 case VDS_IA_FCPH3:
			 return x_wszValueFCPH3;

		 case VDS_IA_MAC:
			 return x_wszValueMAC;

         case VDS_IA_SCSI:
			 return x_wszValueScsi;
         }
	 }


VDS_INTERCONNECT_ADDRESS_TYPE CVssMetadataHelper::ConvertToInterconnectAddressType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstrType
	)
	{
	if (wcscmp(bstrType, x_wszValueScsi) == 0)
		return VDS_IA_SCSI;
	else if (wcscmp(bstrType, x_wszValueMAC) == 0)
		return VDS_IA_MAC;
	else if (wcscmp(bstrType, x_wszValueFCPH3) == 0)
		return VDS_IA_FCPH3;
	else if (wcscmp(bstrType, x_wszValueFCPH) == 0)
		return VDS_IA_FCPH;
	else if (wcscmp(bstrType, x_wszValueFCFS) == 0)
		return VDS_IA_FCFS;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid interconnect address type.",
			bstrType
			);

    return VDS_IA_UNKNOWN;
	}




// obtain the value of a string valued attribute.  Returns S_FALSE if
// attribute doesn't exist
HRESULT CVssMetadataHelper::GetStringAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT BSTR *pbstrValue
	)
	{
	try
		{
		// check output parameter
		if (pbstrValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// null output parameter
		*pbstrValue = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		// find attribute value
		if (m_doc.FindAttribute(wszAttrName, pbstrValue))
			ft.hr = S_OK;
		else
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				ft.hr = S_FALSE;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the value of a byte array valued attribute.  Returns S_FALSE if
// attribute doesn't exist
HRESULT CVssMetadataHelper::GetByteArrayAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT BYTE **ppbValue,
	OUT UINT *pcbValue
	)
	{
	try
		{
		VssZeroOut(pcbValue);

		// check output parameter
		if (ppbValue == NULL || pcbValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// null output parameter
		*ppbValue = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		*ppbValue = get_byteArrayValue(ft, wszAttrName, bRequired, *pcbValue);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// attribute doesn't exist
HRESULT CVssMetadataHelper::GetVSS_IDAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT VSS_ID *pidValue
	)
	{
	try
		{
		// check output parameter
		if (pidValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// null output parameter
		*pidValue = GUID_NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		CComBSTR bstrVal;

		// find attribute value
		if (m_doc.FindAttribute(wszAttrName, &bstrVal))
			{
			ConvertToVSS_ID(ft, bstrVal, pidValue);
			ft.hr = S_OK;
			}
		else
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				ft.hr = S_FALSE;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain the value of a boolean ("yes", "no") attribute.  Return S_FALSE if
// attribute is not assigned a value.
HRESULT CVssMetadataHelper::GetBooleanAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT bool *pbValue
	)
	{
	try
		{
		// check output parameter
		if (pbValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// initialize output paramter
		*pbValue = false;

		CComBSTR bstrVal = NULL;
		// obtain string value of attribute

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		if (!m_doc.FindAttribute(wszAttrName, &bstrVal))
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				return S_FALSE;
			}

		// convert attribute to a boolean value
        *pbValue = ConvertToBoolean(ft, bstrVal);
		return S_OK;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

bool CVssMetadataHelper::get_stringValue
	(
	IN LPCWSTR wszAttrName,
	OUT BSTR *pbstrValue
	)
	{
	// iniitialize value to null
	*pbstrValue = NULL;

	// obtain string value if exists
	return m_doc.FindAttribute(wszAttrName, pbstrValue);
	}

// obtain the value of an ASCII string
bool CVssMetadataHelper::get_ansi_stringValue
	(
	CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT LPSTR *pstrValue
	)
	{
	// iniitialize value to null
	*pstrValue = NULL;

	CComBSTR bstr;
	DWORD cb;

	bool bFound = m_doc.FindAttribute(wszAttrName, &bstr);
	if (!bFound)
		return false;

	cb = WideCharToMultiByte
			(
			CP_ACP,
			0,
			bstr,
			-1,
			NULL,
			0,
			NULL,
			NULL
			);

    if (cb == 0)
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_XML, L"LCMapStringA");
		}

	LPSTR sz = (LPSTR) CoTaskMemAlloc(cb);
	if (sz == NULL)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate ANSI string");

	if (WideCharToMultiByte
			(
			CP_ACP,
			0,
			bstr,
			-1,
			sz,
			cb,
			NULL,
			NULL
			) == 0)
		{
		CoTaskMemFree(sz);
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_XML, L"LCMapStringA");
		}

	*pstrValue = sz;
	return true;
	}



// get a byte array value.  The value is UUENCODED in the xml document.
BYTE *CVssMetadataHelper::get_byteArrayValue
	(
	CVssFunctionTracer &ft,
	LPCWSTR wszAttrName,
	bool bRequired,
	UINT &cb
	)
	{
	CComBSTR bstrVal;
	cb = 0;
	if (get_stringValue(wszAttrName, &bstrVal))
		{
		Base64Coder coder;
		coder.Decode(bstrVal);
		BYTE *pbVal = coder.DecodedMessage();
		cb = *(UINT *) pbVal;
		BYTE *pbRet = (BYTE *) CoTaskMemAlloc(cb);
		if (pbRet == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate byte array.");

		memcpy(pbRet, pbVal + sizeof(UINT), cb);
		return pbRet;
		}
	else if (bRequired)
		MissingAttribute(ft, wszAttrName);

	return NULL;
	}


// obtain a GUID value
void CVssMetadataHelper::get_VSS_IDValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT VSS_ID *pidValue
	) throw(HRESULT)
	{
	// initialize id value to GUID_NULL
	*pidValue = GUID_NULL;

	CComBSTR bstrVal = NULL;

	// obtain string value if it exists and convert it to GUID
	if (m_doc.FindAttribute(wszAttrName, &bstrVal))
		ConvertToVSS_ID(ft, bstrVal, pidValue);
	else
		MissingAttribute(ft, wszAttrName);
	}

// obtain a boolean value from the XML document ("yes" or "no")
bool CVssMetadataHelper::get_boolValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT bool *pb
	)
	{
	// initialize boolean value
	*pb = FALSE;

	CComBSTR bstrVal = NULL;

	// find attribute if it exists and convert its value to a boolean
	if (!m_doc.FindAttribute( wszAttrName, &bstrVal))
		return false;

	*pb = ConvertToBoolean(ft, bstrVal);
	return true;
	}

// indicate that the XML document is missing a required element
void CVssMetadataHelper::MissingElement
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElement
	)
	{
	ft.LogError(VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ELEMENT, VSSDBG_XML << wszElement);
	ft.Throw
		(
		VSSDBG_XML,
		VSS_E_CORRUPT_XML_DOCUMENT,
		L"The %s element is missing.",
		wszElement
		);
    }

// indicate that the XML document is missing a required attribute
void CVssMetadataHelper::MissingAttribute
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttribute
	)
	{
	ft.LogError(VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ATTRIBUTE, VSSDBG_XML << wszAttribute);
	ft.Throw
		(
		VSSDBG_XML,
		VSS_E_CORRUPT_XML_DOCUMENT,
		L"The %s attribute is missing.",
		wszAttribute
		);
    }

// common routine for finding the number of elements of a given type
// are within a component
HRESULT CVssMetadataHelper::GetElementCount
	(
	IN LPCWSTR wszElement,
	OUT UINT *pcElements
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssMetadataHelper::GetElementCount");

    try
		{
		// validate output parameter
		if (pcElements == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		// initialize output parameter
		*pcElements = 0;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(wszElement, TRUE))
			return S_OK;

        UINT cElements = 0;
		// count elements
		do
			{
			cElements++;
			} while(m_doc.FindElement(wszElement, FALSE));

        // set return value
        *pcElements = cElements;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\admin.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Admin.cxx | Implementation of IVssAdmin
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/03/1999  Moving QueryProviders in Query.cxx
                            Moving private methods in Private.cxx
                            More parameter checking
                            Moving constants in coord.hxx
    aoltean     09/09/1999  Adding the notification interface.
                            Making the code clearer.
                            dss -> vss
	aoltean		09/20/1999	Adding shared "copy" class
	aoltean		09/21/1999  Adding a new header for the "ptr" class.


--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

 #include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"
#include "reg_util.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "vs_sec.hxx"
#include "vs_reg.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORADMNC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  IVssAdmin interface


CVssAdmin::CVssAdmin()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::CVssAdmin" );
}


CVssAdmin::~CVssAdmin()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::~CVssAdmin" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAdmin interface


STDMETHODIMP CVssAdmin::RegisterProvider(
    IN      VSS_ID      ProviderId,
    IN      CLSID       ClassId,
    IN      VSS_PWSZ    pwszProviderName,
	IN		VSS_PROVIDER_TYPE eProviderType,
    IN      VSS_PWSZ    pwszProviderVersion,
    IN      VSS_ID      ProviderVersionId
    )

/*++

Routine Description:

    Register the provider. Add the provider into the internal array if the array is already filled exist.

Arguments:

    VSS_ID      ProviderId,
    CLSID       ClassId,
    VSS_PWSZ    pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
    VSS_PWSZ    pwszProviderVersion,
    VSS_ID      ProviderVersionId

Return values:

    E_OUTOFMEMORY
    E_ACCESSDENIED 
        - The user is not administrator
    E_INVALIDARG 
        - Invalid arguments
    VSS_E_PROVIDER_ALREADY_REGISTERED
        - Provider already registered
    E_UNEXPECTED 
        - Registry errors. An error log entry is added describing the error.

    [CVssProviderManager::AddProviderIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures] or
        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::RegisterProvider" );
    WCHAR   wszProviderKeyName[_MAX_KEYNAME_LEN];
    WCHAR   wszValueBuffer[_MAX_VALUE_LEN];
    HKEY    hRegKeyVSS = NULL;
    HKEY    hRegKeyProviders = NULL;
    HKEY    hRegKeyNewProvider = NULL;
    HKEY    hRegKeyCLSID = NULL;
    LONG    lRes;
    bool    bProviderKeyCreated = false;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
                  L"ProviderId = " WSTR_GUID_FMT L",\n"
                  L"ClassId = "  WSTR_GUID_FMT L",\n"
                  L"pwszProviderName = %s\n"
				  L"eProviderType = %d\n"
                  L"pwszProviderVersion = %s\n"
                  L"ProviderVersionId = "  WSTR_GUID_FMT L",\n",
                  GUID_PRINTF_ARG( ProviderId ),
                  GUID_PRINTF_ARG( ClassId ),
                  pwszProviderName,
				  eProviderType,
                  pwszProviderVersion,
                  GUID_PRINTF_ARG( ProviderVersionId )
                  );

        // Argument validation
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL Provider ID");
        if (pwszProviderName == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL name");
        if (pwszProviderName[0] == L'\0')
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Empty name");
        if (::wcslen(pwszProviderName) > _MAX_VALUE_LEN - 1 )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszProviderName length greater than %d", _MAX_VALUE_LEN - 1);
		switch( eProviderType ) {
		case VSS_PROV_SOFTWARE:
			break;
		case VSS_PROV_HARDWARE:
		    if (CVssSKU::IsClient())
                ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Context not implemented in client SKU");
			break;
		default:
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"invalid provider type %d", eProviderType);
		}
        if (pwszProviderVersion == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL version");
        if (::wcslen(pwszProviderVersion) > _MAX_VALUE_LEN - 1 )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszProviderVersion length greater than %d", _MAX_VALUE_LEN - 1);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Creating the "HKLM\System\CurrentControlSet\Services\VSS" key, if it does not exist yet.
        DWORD dwDisposition;
        lRes = ::RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,         //  IN HKEY hKey,
            wszVSSKey,                  //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyVSS,                //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), L"RegCreateKeyExW(HKLM,%s,...)", 
                wszVSSKey);

        // Creating the "Providers" subkey, if it does not exist yet.
        lRes = ::RegCreateKeyExW(
            hRegKeyVSS,                 //  IN HKEY hKey,
            wszVSSKeyProviders,         //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyProviders,          //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders);

        // Create the subkey for that Provider Id.
        ::wsprintf(wszProviderKeyName, WSTR_GUID_FMT, GUID_PRINTF_ARG( ProviderId ));
        lRes = ::RegCreateKeyExW(
            hRegKeyProviders,           //  IN HKEY hKey,
            wszProviderKeyName,         //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyNewProvider,        //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName);

        switch ( dwDisposition )
        {
        case REG_CREATED_NEW_KEY: // OK. The new provider has a new key. Break on.
            // The cleanup code must delete also the provider key also.
            bProviderKeyCreated = true;
            break;
        case REG_OPENED_EXISTING_KEY:
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_ALREADY_REGISTERED,
                      L"Provider with Id %s already registered ", wszProviderKeyName);
        default:
            BS_ASSERT( false );
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s,%s,...,[%d])", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, dwDisposition);
        }

        // Set provider name
        DWORD dwLength = ::lstrlenW( pwszProviderName );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueName,            // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)pwszProviderName,      // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueName, pwszProviderName, 
                (dwLength + 1) * sizeof(WCHAR));

        // Set provider type
        DWORD dwType = eProviderType;
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueType,            // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_DWORD,                          // IN DWORD dwType,
            (CONST BYTE*)(&dwType),				// IN CONST BYTE* lpData,
            sizeof(DWORD)						// IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_DWORD,%d,%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueType, dwType, sizeof(DWORD));

        // Set provider version
        dwLength = ::lstrlenW( pwszProviderVersion );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueVersion,         // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)pwszProviderVersion,   // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueVersion, pwszProviderVersion, 
                (dwLength + 1) * sizeof(WCHAR));

        // Set provider version Id.
        ::wsprintf(wszValueBuffer, WSTR_GUID_FMT, GUID_PRINTF_ARG( ProviderVersionId ));
        dwLength = ::lstrlenW( wszValueBuffer );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueVersionId,       // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)wszValueBuffer,        // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueVersionId, wszValueBuffer, 
                (dwLength + 1) * sizeof(WCHAR));

        // Create the subkey for the class Id.
        lRes = ::RegCreateKeyExW(
            hRegKeyNewProvider,                 //  IN HKEY hKey,
            wszVSSKeyProviderCLSID,             //  IN LPCWSTR lpSubKey,
            0,                                  //  IN DWORD Reserved,
            REG_NONE,                           //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,            //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,                     //  IN REGSAM samDesired,
            NULL,                               //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyCLSID,                      //  OUT PHKEY phkResult,
            &dwDisposition                      //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSKeyProviderCLSID);
        BS_ASSERT(dwDisposition == REG_CREATED_NEW_KEY );

        // Set the CLSID for the newly created key
        ::wsprintf(wszValueBuffer, WSTR_GUID_FMT, GUID_PRINTF_ARG( ClassId ));
        dwLength = ::lstrlenW( wszValueBuffer );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyCLSID,                       // IN HKEY hKey,
            wszVSSCLSIDValueName,               // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)wszValueBuffer,        // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSKeyProviderCLSID, wszVSSCLSIDValueName, 
                wszValueBuffer, (dwLength + 1) * sizeof(WCHAR));

		// Update m_pProvidersArray by inserting the new provider into the array.
		CVssProviderManager::AddProviderIntoArray(
			ProviderId,
			pwszProviderName,
            eProviderType,
			pwszProviderVersion,
			ProviderVersionId,
			ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    try
    {
        lRes = hRegKeyCLSID? ::RegCloseKey(hRegKeyCLSID): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyCLSID key. [0x%08lx]", GetLastError());

        lRes = hRegKeyNewProvider? ::RegCloseKey(hRegKeyNewProvider): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyNewProvider key. [0x%08lx]", GetLastError());

        lRes = hRegKeyProviders? ::RegCloseKey(hRegKeyProviders): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyProviders key. [0x%08lx]", GetLastError());

        lRes = hRegKeyVSS? ::RegCloseKey(hRegKeyVSS): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyVSS key. [0x%08lx]", GetLastError());

        // Delete all registry keys that correspond to this provider
        if (bProviderKeyCreated && ft.HrFailed()) {
            CVssFunctionTracer ft2(VSSDBG_COORD,  L"CVssAdmin::RegisterProvider_rec_del" );
            WCHAR   wszProviderKeyName[_MAX_KEYNAME_LEN];
            ::wsprintf( wszProviderKeyName, L"%s\\%s\\" WSTR_GUID_FMT,
                    wszVSSKey, wszVSSKeyProviders, GUID_PRINTF_ARG( ProviderId ));
            RecursiveDeleteKey( ft2, HKEY_LOCAL_MACHINE, wszProviderKeyName );
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVssAdmin::UnregisterProvider(
    IN      VSS_ID      ProviderId
    )

/*++

Routine Description:

    Unregister the provider. Remove the provider from the internal array if the array is already filled exist.

Arguments:

    VSS_ID      ProviderId

Return values:


    E_ACCESSDENIED 
        - The user is not administrator
    VSS_E_PROVIDER_IN_USE
        - A snapshot set is in progress.
    VSS_E_PROVIDER_NOT_REGISTERED
        - The provider with the given ID is not registered.

    [lock failures]
        E_OUTOFMEMORY

    [CVssProviderManager::RemoveProviderFromArray() failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::UnregisterProvider" );
    WCHAR   wszKeyBuffer[_MAX_KEYNAME_LEN];

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

        if (ProviderId == VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Attempting to unregister the unique MS Software Snasphot provider");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
                  L"ProviderId = " WSTR_GUID_FMT,
                  GUID_PRINTF_ARG( ProviderId ));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// If a snapshot set is in progress then abort un-registering
		if (CVssProviderManager::AreThereStatefulObjects())
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_IN_USE,
                      L"A snapshot set is in progress");

		// Notify the provider that is being unregistered. Abort unregistering in case of failure.
		// Unload the provider from memory. (forced since unregister was called)
		// Remove provider from m_pProvidersArray.
		if( !CVssProviderManager::RemoveProviderFromArray( ProviderId ))
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED,
                      L"The provider is not registered");

        // Delete all registry keys that correspond to this provider
        ::wsprintf( wszKeyBuffer, L"%s\\%s\\" WSTR_GUID_FMT,
                wszVSSKey, wszVSSKeyProviders, GUID_PRINTF_ARG( ProviderId ));
        RecursiveDeleteKey( ft, HKEY_LOCAL_MACHINE, wszKeyBuffer );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::AbortAllSnapshotsInProgress()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::AbortAllSnapshotsInProgress" );

	try
	{
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		CVssProviderManager::DeactivateAll();
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\vs_xml.cxx ===
/////////////////////////////////////////////////////////////////////////////
// CXMLNode  implementation


#include "stdafx.hxx"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "vs_types.hxx"
#include "vs_str.hxx"
#include "vs_vol.hxx"
#include "vs_hash.hxx"
#include "vs_list.hxx"
#include "msxml2.h" //  #182584 - was msxml.h
#include "vs_xml.hxx"
#include "rpcdce.h"
#include "vssmsg.h"
#include "mbstring.h"
#include "winnls.h"

#include "base64coder.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEXMLC"
//
////////////////////////////////////////////////////////////////////////

// insert a node under the specified node
// The returned interface must be explicitely released.
IXMLDOMNode* CXMLNode::InsertChild
	(
	IN	IXMLDOMNode* pChildNode,	// node to insert
	IN  const CComVariant& vAfter	// node this comes after
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::InsertChild");

	// validate we have a parent node to insert under
	if (m_pNode == NULL || pChildNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	CComPtr<IXMLDOMNode> pInsertedNode;
	// insert node
	ft.hr = m_pNode->insertBefore(pChildNode, vAfter, &pInsertedNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::insertBefore");

    // return inserted node
	return pInsertedNode.Detach();
	}


// append a node as a child node of the node
// The returned interface must be explicitely released.
void CXMLNode::AppendChild
	(
	IN	CXMLNode& childNode,
	OUT	IXMLDOMNode** ppNewChildNode
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::AppendChild");

	// validate input arguments
	if ((m_pNode == NULL) || (childNode.m_pNode == NULL) )
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	if (ppNewChildNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

	// append child node
	ft.hr = m_pNode->appendChild( childNode.m_pNode, ppNewChildNode );
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::appendChild");
	}

// set a guid valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  GUID ValueId
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw( VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	LPWSTR wszUuid;
	// convert GUID to string
	RPC_STATUS status = UuidToString(&ValueId, &wszUuid);
	if (status != RPC_S_OK || wszUuid == NULL)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// convert string to BSTR
	CComBSTR bstrValueId = wszUuid;

	// free up RPC string created by UuidToString
	RpcStringFree(&wszUuid);
	if (!bstrValueId)
        ft.Throw( VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValueId;
	
	CComPtr<IXMLDOMElement> pElement;
    ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMElement to the node. 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set a string valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  LPCWSTR wszValue
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");
	if (m_pNode == NULL || wszAttributeName == NULL || wszValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrValue = wszValue;
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
        ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMNode to IXMLDOMElement. 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set an integer valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  INT nValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	// set attribute name as BSTR
	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw( VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = nValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying from IXMLDOMNode to IXMLDOMElement. hr = 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set a DWORDLONG valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  LONGLONG llValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	const nTimestampBufferSize = 0x20;

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrValue(nTimestampBufferSize + 1);
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// Print the LONGLONG value
	::_snwprintf(bstrValue, nTimestampBufferSize, L"%I64d", llValue);

	CComVariant varValue = bstrValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
        ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMElement from the IXMLDOMNode. hr = 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
    }

// set value of a byte array attribute by UUENCODING the data
void CXMLNode::SetAttribute
	(
	LPCWSTR wszAttr,
	const BYTE *pbVal,
	UINT cbVal
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute(BYTE_ARRAY)");
	Base64Coder coder;
	coder.Encode(pbVal, cbVal);
	SetAttribute(wszAttr, coder.EncodedMessage());
	}

// set the value of an attribute to an ASCII string
void CXMLNode::SetAttribute
	(
	IN LPCWSTR wszAttrName,
	IN LPCSTR szValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute(ANSI)");
	DWORD cwc;

	cwc = MultiByteToWideChar
			(
			CP_ACP,
			0,
			szValue,
			-1,
			NULL,
			0
			);

    if (cwc == 0)
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_XML, L"LCMapStringA");
		}

	CComBSTR bstrValue(cwc);

	if (!bstrValue)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate string");

	if (MultiByteToWideChar
			(
			CP_ACP,
			0,
			szValue,
			-1,
			bstrValue,
			cwc
			) == 0)
        {
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_XML, L"LCMapStringA");
		}

	SetAttribute(wszAttrName, bstrValue);
	}


// add text to a node
void CXMLNode::AddText
	(
	IN  LPCWSTR wszText
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::AddText");

	if (m_pNode == NULL || m_pDoc == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument.");

	CXMLDocument doc(m_pDoc);
	CComPtr<IXMLDOMNode> pTextNode;
	CXMLNode textNode = doc.CreateNode(NULL, NODE_TEXT);
	textNode.SetValue(wszText);
	InsertNode(textNode);
    }


void CXMLNode::SetValue
	(
	IN  LPCWSTR wszValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetValue");

	if (m_pNode == NULL || wszValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument.");

	CComBSTR bstrValue = wszValue;
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValue;
	
	// Set the attribute
	ft.hr = m_pNode->put_nodeValue(varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::put_nodeValue");
    }


/////////////////////////////////////////////////////////////////////////////
// CXMLDocument  implementation


void CXMLDocument::Initialize
	(
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::Initialize");

	m_pDoc = NULL;

	ft.hr = m_pDoc.CoCreateInstance(CLSID_DOMDocument30);  //  #182584 - Was CLSID_DOMDocument26
	ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

	m_pNode = static_cast<IXMLDOMNode*>(m_pDoc);
	m_pNodeCur = m_pNode;
	m_level = 0;
	}


// create a node
CXMLNode CXMLDocument::CreateNode
	(
	IN  LPCWSTR wszName,
	IN  DOMNodeType nType
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::CreateNode");

	// Check if the document is properly initialized
	if (m_pDoc == NULL)
        ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL document");

    CComPtr<IXMLDOMNode> pNode;
    CComVariant vType = (INT)nType;
	CComBSTR bstrName = wszName;		// Duplicating the string.

	// Check if no errors when preparing the arguments
	if (!bstrName && wszName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// Create the node
    ft.hr = m_pDoc->createNode(vType, bstrName, NULL, &pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::createNode");

	BS_ASSERT(pNode != NULL);

	return CXMLNode(pNode, m_pDoc);
    }

// insert a node below the current one
CXMLNode CXMLNode::InsertNode
	(
	CXMLNode &node
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::InsertNode");

	CComPtr<IXMLDOMNode> pInsertedNode;
	pInsertedNode.Attach(InsertChild(node.GetNodeInterface()));

	return CXMLNode(pInsertedNode, m_pDoc);
	}



// position on next node
bool CXMLDocument::Next
	(
	IN bool fDescend,					// descend to child if one exists
	IN bool fAscendAllowed				// can ascend to parent?
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::Next");

	CComPtr<IXMLDOMNode> pNodeNext = NULL;
	m_pAttributeMap = NULL;

	while(TRUE)
		{
		// at end?
		if (m_pNodeCur == NULL)
			return FALSE;

		if (fDescend)
			{
			// get first child
			ft.hr = m_pNodeCur->get_firstChild(&pNodeNext);
			ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_firstChild");

			if (ft.hr == S_OK)
				{
				// child was found
				BS_ASSERT(pNodeNext != NULL);
				m_pNodeCur.Attach(pNodeNext.Detach());

				// decended a level
				m_level++;
				return TRUE;
				}
            }

		// move to sibling node
		ft.hr = m_pNodeCur->get_nextSibling(&pNodeNext);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nextSibling");

		if (ft.hr == S_OK)
			{
			// sibling was found
			BS_ASSERT(pNodeNext != NULL);
			m_pNodeCur.Attach(pNodeNext.Detach());
			return TRUE;
			}

		// check if ascend is allowed and that we are not at the toplevel of
		// the document
		if (!fAscendAllowed || m_level == 0)
			return FALSE;

		// get parent node
		ft.hr = m_pNodeCur->get_parentNode(&pNodeNext);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_parentNode");

	    m_pNodeCur.Attach(pNodeNext.Detach());
		// don't descend to back where we came from
		fDescend = FALSE;

		// move up one level
		m_level--;
		}
	}

// find a specific child attribute of the current node
bool CXMLDocument::FindAttribute
	(
	IN LPCWSTR wszAttrName,			// attriburte name
	OUT BSTR *pbstrAttrValue		// string value of attribute
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::FindAttribute");

	if (m_pNodeCur == NULL || wszAttrName == NULL || pbstrAttrValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL argument.");

	// create attribute map if one doesn't exist
	if (m_pAttributeMap == NULL)
		{
		ft.hr = m_pNodeCur->get_attributes(&m_pAttributeMap);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_attributes");
        }

	if (m_pAttributeMap == NULL)
		return FALSE;

	CComPtr<IXMLDOMNode> pNode = NULL;

	// get attribute
	ft.hr = m_pAttributeMap->getNamedItem((LPWSTR) wszAttrName, &pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNamedNodeMap::getNamedItem");

	if (ft.hr == S_FALSE)
		return false;

	ft.hr = pNode->get_text(pbstrAttrValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_text");

	return TRUE;
	}

// move to next attribute
IXMLDOMNode *CXMLDocument::NextAttribute()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::NextAttribute");

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Node.");

	if (m_pAttributeMap == NULL)
		{
		ft.hr = m_pNodeCur->get_attributes(&m_pAttributeMap);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_attributes");
        }

	if (m_pAttributeMap == NULL)
		return FALSE;

	IXMLDOMNode *pNode = NULL;
	// position at next attribute
	ft.hr = m_pAttributeMap->nextNode(&pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNamedNode::nextNode");

	if (ft.hr == S_FALSE)
		return NULL;

	return pNode;
	}


// reset to top node in document
void CXMLDocument::ResetToDocument()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::ResetToDocument");

	m_pNodeCur = m_pNode;
	m_pAttributeMap = NULL;
	m_level = 0;
	}

// reset to parent node in the document
void CXMLDocument::ResetToParent() throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::ResetToParent");

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	// check to see that we are not at the top level of the document
	if (m_pNodeCur == m_pNode || m_level == 0)
		return;

	CComPtr<IXMLDOMNode> pNodeParent;
	// get parent node
	ft.hr = m_pNodeCur->get_parentNode(&pNodeParent);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_parentNode");

    BS_ASSERT(pNodeParent);
    m_pNodeCur.Attach(pNodeParent.Detach());
	m_pAttributeMap = NULL;

	// move up one level
	m_level--;
	}

// does current node match the specific atttribute type.
bool CXMLDocument::IsNodeMatch
	(
	LPCWSTR wszElementType
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::IsNodeMatch");
	DOMNodeType dnt;

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	ft.hr = m_pNodeCur->get_nodeType(&dnt);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_NodeType");

	 // check that node type is an element
     if (dnt == NODE_ELEMENT)
		{
		CComBSTR bstrName;

		// get node name
		ft.hr = m_pNodeCur->get_nodeName(&bstrName);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_NodeName");

        // check for match
		if (wcscmp(bstrName, wszElementType) == 0)
			return TRUE;
		}

	return false;
	}

// find a specific child or sibling node
bool CXMLDocument::FindElement
	(
	IN LPCWSTR wszElementType,		// element type to loo for
	IN bool bGotoChild = TRUE		// whether to look for a child node
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::FindElement");

	bool bDescend = bGotoChild;

	// save current level so that we don't ascend above this
	unsigned levelStart = m_level;

	// look for node
	while(Next(bDescend, TRUE))
		{
		bDescend = FALSE;
		if (IsNodeMatch(wszElementType))
			return true;
		}

	// if we descended to the child level, reset to parent level
	if (bGotoChild && m_level > levelStart)
		ResetToParent();

	return FALSE;
	}

// save document as an XML string
BSTR CXMLNode::SaveAsXML
	(
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::saveAsXML");
	BSTR bstrOut;

	if (m_pNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL document.");

	ft.hr = m_pNode->get_xml(&bstrOut);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_xml");

    return bstrOut;
	}

// load document from an XML string
bool CXMLDocument::LoadFromXML
	(
	IN BSTR bstrXML
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::LoadFromXML");

	m_pDoc = NULL;
	Initialize();
	BS_ASSERT(m_pDoc != NULL);
	VARIANT_BOOL bSuccessful;
	ft.hr = m_pDoc->loadXML(bstrXML, &bSuccessful);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::loadXML");
		
	return bSuccessful ? TRUE : FALSE;
	}

// load document from a file
bool CXMLDocument::LoadFromFile
	(
	IN LPCWSTR wszFile
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::LoadFromFile");

	// reinitialize the document
	m_pDoc = NULL;
	Initialize();
	BS_ASSERT(m_pDoc != NULL);

	// setup arguments for the Load call
	VARIANT_BOOL bSuccessful;
	VARIANT varFile;
	VariantInit(&varFile);
	varFile.bstrVal = SysAllocString(wszFile);
	varFile.vt = VT_BSTR;

	ft.hr = m_pDoc->load(varFile, &bSuccessful);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::load");

    // return whether load was successful or not
	return bSuccessful ? TRUE : FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\backupext\vsxml\vs_cmxml.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vs_cmxml.cxx

Abstract:

    Implementation of Backup Components Metadata XML wrapper classes

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb		03/16/2000  Created
    brianb		03/22/2000  Added support for PrepareForBackup and BackupComplete
    brianb		04/04/2000  Added security checks for backup operator
    brianb		04/06/2000  Comment pass, remove callbacks from writer
    brianb		04/10/2000  add async support
    mikejohn	04/11/2000  Fix some loop iteration problems
	brianb  	04/21/2000  retool for passing WRITER_COMPONENTS as strings
	brianb		04/25/2000  added critical section support
	brianb		05/03/2000	new security model
	brianb		05/05/2000  fix bug in CVssWriterComponents::GetComponent
    brianb      05/16/2000  code review comments, remove Cancel stuff
	brianb		05/19/2000  code review comments

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_sec.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "cmxml.c"
#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"
#include "vs_filter.hxx"

#include <sddl.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUECXMLC"
//
////////////////////////////////////////////////////////////////////////


// schema information
static LPCWSTR x_wszVersionNo = L"1.0";

// element strings
static LPCWSTR x_wszElementBackupComponents = L"BACKUP_COMPONENTS";
static LPCWSTR x_wszElementWriterComponents = L"WRITER_COMPONENTS";
static LPCWSTR x_wszElementBackupMetadata = L"BACKUP_METADATA";
static LPCWSTR x_wszElementRestoreMetadata = L"RESTORE_METADATA";
static LPCWSTR x_wszElementPartialFile = L"PARTIAL_FILE";
static LPCWSTR x_wszElementDirectedTarget = L"DIRECTED_TARGET";
static LPCWSTR x_wszElementRestoreTarget = L"RESTORE_TARGET";
static LPCWSTR x_wszElementRestoreSubcomponent = L"RESTORE_SUBCOMPONENT";
static LPCWSTR x_wszElementAlternateMapping = L"ALTERNATE_LOCATION_MAPPING";
static LPCWSTR x_wszElementComponent = L"COMPONENT";
static LPCWSTR x_wszElementRoot = L"root";

// attribute strings
static LPCWSTR x_wszAttrVersion = L"version";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszAttrBootableSystemStateBackup = L"bootableSystemStateBackup";
static LPCWSTR x_wszAttrWriterId = L"writerId";
static LPCWSTR x_wszAttrInstanceId = L"instanceId";
static LPCWSTR x_wszAttrComponentType = L"componentType";
static LPCWSTR x_wszAttrLogicalPath = L"logicalPath";
static LPCWSTR x_wszAttrComponentName = L"componentName";
static LPCWSTR x_wszAttrBackupSucceeded = L"backupSucceeded";
static LPCWSTR x_wszAttrPath = L"path";
static LPCWSTR x_wszAttrFilespec = L"filespec";
static LPCWSTR x_wszAttrRecursive = L"recursive";
static LPCWSTR x_wszAttrAlternatePath = L"alternatePath";
static LPCWSTR x_wszAttrMetadata = L"metadata";
static LPCWSTR x_wszAttrRanges = L"ranges";
static LPCWSTR x_wszAttrSelectComponents = L"selectComponents";
static LPCWSTR x_wszAttrBackupType = L"backupType";
static LPCWSTR x_wszAttrPartialFileSupport = L"partialFileSupport";
static LPCWSTR x_wszAttrBackupOptions = L"backupOptions";
static LPCWSTR x_wszAttrRestoreOptions = L"restoreOptions";
static LPCWSTR x_wszAttrBackupStamp =  L"backupStamp";
static LPCWSTR x_wszAttrPreviousBackupStamp = L"previousBackupStamp";
static LPCWSTR x_wszAttrSelectedForRestore = L"selectedForRestore";
static LPCWSTR x_wszAttrAdditionalRestores = L"additionalRestores";
static LPCWSTR x_wszAttrRestoreTarget = L"restoreTarget";
static LPCWSTR x_wszAttrPreRestoreFailureMsg = L"preRestoreFailureMsg";
static LPCWSTR x_wszAttrPostRestoreFailureMsg = L"postRestoreFailureMsg";
static LPCWSTR x_wszAttrFilesRestored = L"filesRestored";
static LPCWSTR x_wszAttrRepair = L"repair";
static LPCWSTR x_wszAttrTargetPath = L"targetPath";
static LPCWSTR x_wszAttrTargetFilespec = L"targetFilespec";
static LPCWSTR x_wszAttrSourceRanges = L"sourceRanges";
static LPCWSTR x_wszAttrTargetRanges = L"targetRanges";


// value strings
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssComponentMetadata";



// return the logical path for a component
// implements IVssComponent::GetLogicalPath
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//      S_FALSE if there is no logical path for the component
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetLogicalPath(OUT BSTR *pbstrPath)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetLogicalPath"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrLogicalPath, false, pbstrPath);
	}

// return the type of a component
// implements IVssComponent::GetComponentType
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pct is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetComponentType(VSS_COMPONENT_TYPE *pct)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetComponentType"
		);

	try
		{
		// validate output argument
		if (pct == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output argument
		*pct = VSS_CT_UNDEFINED;
		CComBSTR bstrComponentType;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		// get component type as a string
		if (!get_stringValue(x_wszAttrComponentType, &bstrComponentType))
			MissingAttribute(ft, x_wszAttrComponentType);

		// convert it to VSS_COMPONENT_TYPE value
		*pct = ConvertToComponentType(ft, bstrComponentType, true);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the componentName attribute
// implements IVssComponent::GetComponentName
// caller responsible for calling SysFreeString on the output parameter
//
// Returns:
//    S_OK if the operation is successful
//    E_INVALIDARG if pbstrName == NULL
//	  VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//    E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetComponentName(OUT BSTR *pbstrName)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetComponentName"
		);

    // call internal implementation
    return GetStringAttributeValue(ft, x_wszAttrComponentName, true, pbstrName);
	}


// obtain the backupSucceeded attribute
// implements IVssComponent::GetBackupSucceeded
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the value of the attribute is not defined.
//		E_INVALIDARG if pbSucceeded == NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetBackupSucceeded(OUT bool *pbSucceeded)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupSucceeded"
		);


    // call internal implementation
    return GetBooleanAttributeValue(ft, x_wszAttrBackupSucceeded, false, pbSucceeded);
	}


// obtain the count of ALTERNATE_LOCATION_MAPPING elements
// implements IVssComponent::GetAlternateLocationMappingCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAlternateLocationMappingCount
	(
	OUT UINT *pcMappings
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAlternateLocationMappingCount"
		);

    ft.hr = GetElementCount(x_wszElementAlternateMapping, pcMappings);
	return ft.hr;
	}

// obtain the count of PARTIAL_FILE elements
// implements IVssComponent::GetPartialFileCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetPartialFileCount
	(
	OUT UINT *pcElements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPartialFileCount"
		);

    ft.hr = GetElementCount(x_wszElementPartialFile, pcElements);
	return ft.hr;
	}

// obtain the count of RESTORE_TARGET elements
// implements IVssComponent::GetNewTargetCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetNewTargetCount
	(
	OUT UINT *pcElements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetNewTargetCount"
		);

    ft.hr = GetElementCount(x_wszElementRestoreTarget, pcElements);
	return ft.hr;
	}

// obtain the count of DIRECTED_TARGET elements
// implements IVssComponent::GetNewTargetCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetDirectedTargetCount
	(
	OUT UINT *pcElements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetDirectedTargetCount"
		);

    ft.hr = GetElementCount(x_wszElementDirectedTarget, pcElements);
	return ft.hr;
	}

// obtain the count of RESTORE_SUBCOMPONENTS elements
// implements IVssComponent::GetRestoreSubcomponentsCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetRestoreSubcomponentCount
	(
	OUT UINT *pcElements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetRestoreSubcomponentCount"
		);

    ft.hr = GetElementCount(x_wszElementRestoreSubcomponent, pcElements);
	return ft.hr;
	}


// common routine to get an IVssWMFiledesc element for either
// ALTERNATE_LOCATION_MAPPINGS or RESTORE_TARGETS
HRESULT CVssComponent::GetFiledescElement
	(
	IN LPCWSTR wszElement,
	IN UINT iMapping,					// which mapping to select
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetFiledescElement"
		);

    CVssWMFiledesc *pFiledesc = NULL;
    try
		{
		// validate output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// initailize output parameter
		*ppFiledesc = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(wszElement, TRUE))
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find %s element.", wszElement);

		// skip to selected element
		for(UINT i = 0; i < iMapping; i++)
			{
			if (!m_doc.FindElement(wszElement, FALSE))
				ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find %s element.", wszElement);
			}

		// create filedesc object
		pFiledesc = new CVssWMFiledesc(m_doc.GetCurrentNode());

		// validate that allocation succeeded
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Couldn't create CVssWMFiledesc due to allocation failure."
				);


		// 2nd phase of initialization
		pFiledesc->Initialize(ft);

		// transfer ownership of pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

    return ft.hr;
	}





// obtain a specific ALTERNATE_LOCATION_MAPPING element
// implements IVssComponent::GetAlterateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the ouptut parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAlternateLocationMapping
	(
	IN UINT iMapping,					// which mapping to select
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAlternativeLocationMapping"
		);

    ft.hr = GetFiledescElement(x_wszElementAlternateMapping, iMapping, ppFiledesc);
	return ft.hr;
	}


// obtain a specific RESTORE_TARGET element
// implements IVssComponent::GetAlterateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the ouptut parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetNewTarget
	(
	IN UINT iMapping,					// which mapping to select
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetNewTarget"
		);

    ft.hr = GetFiledescElement(x_wszElementRestoreTarget, iMapping, ppFiledesc);
	return ft.hr;
	}

// obtain the contents of a specific PARTIAL_FILE element
// implements IVssComponent::GetPartialFile
// caller is responsible for calling SysFreeString on each of the
// strings returned
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetPartialFile
	(
	IN UINT iPartialFile,
	OUT BSTR *pbstrPath,
	OUT BSTR *pbstrFilename,
	OUT BSTR *pbstrRanges,
	OUT BSTR *pbstrMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPartialFile"
		);

    try
		{
		VssZeroOut(pbstrFilename);
		VssZeroOut(pbstrPath);
		VssZeroOut(pbstrRanges);
		VssZeroOut(pbstrMetadata);

		// validate output parameter
		if (pbstrPath == NULL ||
			pbstrFilename == NULL ||
			pbstrRanges == NULL ||
			pbstrMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(x_wszElementPartialFile, TRUE))
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find PARTIAL_FILE element.");

		// skip to selected element
		for(UINT i = 0; i < iPartialFile; i++)
			{
			if (!m_doc.FindElement(x_wszElementPartialFile, FALSE))
				ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find PARTIAL_FILE element.");
			}

		if (!m_doc.FindAttribute(x_wszAttrPath, pbstrPath))
			MissingAttribute(ft, x_wszAttrPath);

		if (!m_doc.FindAttribute(x_wszAttrFilespec, pbstrFilename))
			MissingAttribute(ft, x_wszAttrFilespec);

		m_doc.FindAttribute(x_wszAttrRanges, pbstrRanges);
		m_doc.FindAttribute(x_wszAttrMetadata, pbstrMetadata);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// obtain the contents of a specific DIRECTED_TARGET element
// implements IVssComponent::GetDirectedTarget
// caller is responsible for calling SysFreeString on each of the
// strings returned
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetDirectedTarget
	(
	IN UINT iTarget,
	OUT BSTR *pbstrSourcePath,
	OUT BSTR *pbstrSourceFilename,
	OUT BSTR *pbstrSourceRanges,
	OUT BSTR *pbstrTargetPath,
	OUT BSTR *pbstrTargetFilename,
	OUT BSTR *pbstrTargetRanges
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPartialFile"
		);

    try
		{
		VssZeroOut(pbstrSourcePath);
		VssZeroOut(pbstrSourceFilename);
		VssZeroOut(pbstrSourceRanges);
		VssZeroOut(pbstrTargetPath);
		VssZeroOut(pbstrTargetFilename);
		VssZeroOut(pbstrTargetRanges);

		// validate output parameter
		if (pbstrSourcePath == NULL ||
			pbstrSourceFilename == NULL ||
			pbstrSourceRanges == NULL ||
			pbstrTargetPath == NULL ||
			pbstrTargetFilename == NULL ||
			pbstrTargetRanges == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find first DIRECTED_TARGET element
		if (!m_doc.FindElement(x_wszElementDirectedTarget, TRUE))
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find DIRECTED_TARGET element.");

		// skip to selected element
		for(UINT i = 0; i < iTarget; i++)
			{
			if (!m_doc.FindElement(x_wszElementDirectedTarget, FALSE))
				ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find DIRECTED_TARGET element.");
			}

		if (!m_doc.FindAttribute(x_wszAttrPath, pbstrSourcePath))
			MissingAttribute(ft, x_wszAttrPath);

		if (!m_doc.FindAttribute(x_wszAttrFilespec, pbstrSourceFilename))
			MissingAttribute(ft, x_wszAttrFilespec);

		if (!m_doc.FindAttribute(x_wszAttrSourceRanges, pbstrSourceRanges))
			MissingAttribute(ft, x_wszAttrSourceRanges);

		if (!m_doc.FindAttribute(x_wszAttrTargetRanges, pbstrTargetRanges))
			MissingAttribute(ft, x_wszAttrTargetRanges);

		m_doc.FindAttribute(x_wszAttrTargetPath, pbstrTargetPath);
		m_doc.FindAttribute(x_wszAttrTargetFilespec, pbstrTargetFilename);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain the contents of a specific RESTORE_SUBCOMPONENT element
// implements IVssComponent::GetRestoreSubcomponent
// caller is responsible for calling SysFreeString on each of the
// strings returned
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetRestoreSubcomponent
	(
	IN UINT iTarget,
	OUT BSTR *pbstrLogicalPath,
	OUT BSTR *pbstrComponentName,
	OUT bool *pbRepair
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPartialFile"
		);

    try
		{
		VssZeroOut(pbstrLogicalPath);
		VssZeroOut(pbstrComponentName);
		if (pbRepair)
			*pbRepair = false;

		// validate output parameter
		if (pbstrLogicalPath == NULL ||
			pbstrComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");


		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find first RESTORE_SUBCOMPONENT element
		if (!m_doc.FindElement(x_wszElementRestoreSubcomponent, TRUE))
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find RESTORE_SUBCOMPONENT element.");

		// skip to selected element
		for(UINT i = 0; i < iTarget; i++)
			{
			if (!m_doc.FindElement(x_wszElementRestoreSubcomponent, FALSE))
				ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find RESTORE_SUBCOMPONENT element.");
			}

		if (!m_doc.FindAttribute(x_wszAttrLogicalPath, pbstrLogicalPath))
			MissingAttribute(ft, x_wszAttrLogicalPath);

		if (!m_doc.FindAttribute(x_wszAttrComponentName, pbstrComponentName))
			MissingAttribute(ft, x_wszAttrComponentName);

		get_boolValue(ft, x_wszAttrRepair, pbRepair);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}




// common routine to set and get backup and restore metadata
HRESULT CVssComponent::SetMetadata
	(
	IN bool bRestoreMetadata,
	IN LPCWSTR wszData
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::SetMetadata"
		);

	LPCWSTR wszElement = bRestoreMetadata
					   ? x_wszElementRestoreMetadata :
					     x_wszElementBackupMetadata;

    try
		{
		if (wszData == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input paramter is NULL.");

		if (m_pWriterComponents == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Components document is not writeable"
				);

		// acquire lock to ensure single threaded access through DOM
        CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();
		if (m_doc.FindElement(wszElement, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_ALREADY_EXISTS,
				L"BackupMetadata already exists on the component"
				);

		// create BACKUP_METADATA node as child of COMPONENT node
		CXMLNode node = m_doc.CreateNode(wszElement, NODE_ELEMENT);

        // set metadata attribute
        node.SetAttribute(x_wszAttrMetadata, wszData);
		m_pWriterComponents->SetChanged();

		// insert BACKUP_METADATA node under component node
		m_doc.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

	

// set BACKUP_METADATA element within the component
// implements IVssComponent::SetBackupMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called outside of
//			the context of OnPrepareBackup
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::SetBackupMetadata(IN LPCWSTR wszData)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetBackupMetadata");

	ft.hr = SetMetadata(false, wszData);
	return ft.hr;
	}


// set RESTORE_METADATA element within the component
// implements IVssComponent::SetRestoreMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called outside of
//			the context of OnPrepareBackup
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::SetRestoreMetadata(IN LPCWSTR wszData)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetRestoreMetadata");

	ft.hr = SetMetadata(true, wszData);
	return ft.hr;
	}


// internal routine to get backup and restore metadata
HRESULT CVssComponent::GetMetadata
	(
	IN bool bRestoreMetadata,
	OUT BSTR *pbstrData
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetMetadata"
		);

	LPCWSTR wszElement = bRestoreMetadata
					   ? x_wszElementRestoreMetadata :
					     x_wszElementBackupMetadata;

    try
		{
		// validate output parameters
		if (pbstrData == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pbstrData = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find BACKUP_METADATA element
		if (!m_doc.FindElement(wszElement, TRUE))
			return S_FALSE;

		CComBSTR bstr;

		// extract string value
		if (!get_stringValue(x_wszAttrMetadata, &bstr))
			MissingAttribute(ft, x_wszAttrMetadata);

        *pbstrData = bstr.Detach();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// obtain value of BACKUP_METADATA element
// implements IVssComponent::GetBackupMetadata
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no backup metadata associated with the component
//		E_INVALIDARG if pbstrData is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssComponent::GetBackupMetadata
	(
	OUT BSTR *pbstrData
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupMetadata"
		);

    ft.hr = GetMetadata(false, pbstrData);
	return ft.hr;
	}


// obtain value of RESTORE_METADATA element
// implements IVssComponent::GetBackupMetadata
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no backup metadata associated with the component
//		E_INVALIDARG if pbstrData is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssComponent::GetRestoreMetadata
	(
	OUT BSTR *pbstrData
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetRestoreMetadata"
		);

    ft.hr = GetMetadata(true, pbstrData);
	return ft.hr;
	}



// return the failure message for a failure during PreRestore
// implements IVssComponent::GetPreRestoreFailureMsg
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//      S_FALSE if there is no logical path for the component
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetPreRestoreFailureMsg(OUT BSTR *pbstrMsg)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPreRestoreFailureMsg"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrPreRestoreFailureMsg, false, pbstrMsg);
	}

// return the failure message for a failure during PostRestore
// implements IVssComponent::GetPostRestoreFailureMsg
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//      S_FALSE if there is no failure message
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetPostRestoreFailureMsg(OUT BSTR *pbstrMsg)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPostRestoreFailureMsg"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrPostRestoreFailureMsg, false, pbstrMsg);
	}

// return the options passed to the writer during backup
// implements IVssComponent::GetBackupOptions
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//		S_FALSE if backup options are not set
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetBackupOptions(OUT BSTR *pbstrOptions)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupOptions"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrBackupOptions, false, pbstrOptions);
	}

// return the options passed to the writer during restore
// implements IVssComponent::GetRestoreOptions
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//		S_FALSE if restore options are not set
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetRestoreOptions(OUT BSTR *pbstrOptions)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetRestoreOptions"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrRestoreOptions, false, pbstrOptions);
	}


// return the backup stamp produced by the writer to identify the backup
// implements IVssComponent::GetBackupStamp
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//		S_FALSE if no backup stamp is set
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetBackupStamp(OUT BSTR *pbstrOptions)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupStamp"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrBackupStamp, false, pbstrOptions);
	}

// return the previous backup stamp passed to the writer to determine from
// which backup the differential or incremental backup is to be produced
// implements IVssComponent::GetPreviousBackupStamp
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//		S_FALSE if no previous backup stamp is set
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetPreviousBackupStamp(OUT BSTR *pbstrStamp)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetPreviousBackupStamp"
		);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrPreviousBackupStamp, false, pbstrStamp);
	}

// return whether the component is selected to be restored
// implements IVssComponent::IsSelectedForRestore
//
// Returns:
//		S_OK if there are no errors
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::IsSelectedForRestore(OUT bool *pbSelectedForRestore)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::IsSelectedForRestore"
		);

    // call internal function
    ft.hr = GetBooleanAttributeValue(ft, x_wszAttrSelectedForRestore, false, pbSelectedForRestore);
	if (ft.hr == S_FALSE)
		{
		*pbSelectedForRestore = false;
		ft.hr = S_OK;
		}

	return ft.hr;
	}

// return whether the additional restores will be performed on the component
// e.g., incremental restore after a full restore
// implements IVssComponent::GetAdditionalRestores
//
// Returns:
//		S_OK if there are no errors
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAdditionalRestores(OUT bool *pbAdditionalRestores)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAdditionalRestores"
		);

    // call internal function
    return GetBooleanAttributeValue(ft, x_wszAttrAdditionalRestores, false, pbAdditionalRestores);
	}


// add a partial file element to a component
// implements IVssComponent::AddPartialFile
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if not called by a writer during backup
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::AddPartialFile
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilename,
	IN LPCWSTR wszRanges,
	IN LPCWSTR wszMetadata
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddPartialFile");

	try
		{
		if (wszPath == NULL || wszFilename == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot be called during restore");

		if (!m_pWriterComponents)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called by writer");


		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		// create PARTIAL_FILE element
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementPartialFile,
							NODE_ELEMENT
							);

        // set attributes
        node.SetAttribute(x_wszAttrPath, wszPath);
		node.SetAttribute(x_wszAttrFilespec, wszFilename);
		if (wszRanges)
			node.SetAttribute(x_wszAttrRanges, wszRanges);

		if (wszMetadata)
			node.SetAttribute(x_wszAttrMetadata, wszMetadata);

		m_pWriterComponents->SetChanged();

		// insert PARTIAL_FILE node under COMPONENT node
		m_doc.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// add a new location target for a file to be restored
// implements IVssComponent::AddNewTarget
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if not called by a writer during backup or if the
//			restore target is not new.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::AddNewTarget
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFileName,
	IN bool bRecursive,
	IN LPCWSTR wszAlternatePath
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddNewTarget");

	try
		{
		if (wszPath == NULL || wszFileName == NULL || wszAlternatePath == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot be called during restore");

		if (!m_pWriterComponents)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called by writer.");

		VSS_RESTORE_TARGET rt;
		ft.hr = GetRestoreTarget(&rt);
		ft.CheckForError(VSSDBG_XML, L"IVssComponent::GetRestoreTarget");

		if (rt != VSS_RT_NEW)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Restore target must be New.");

		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		// create RESTORE_TARGET element
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementRestoreTarget,
							NODE_ELEMENT
							);

        // set attributes
        node.SetAttribute(x_wszAttrPath, wszPath);
		node.SetAttribute(x_wszAttrFilespec, wszFileName);
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));
		node.SetAttribute(x_wszAttrAlternatePath, wszAlternatePath);

		m_pWriterComponents->SetChanged();

		// insert RESTORE_TARGET node under COMPONENT node
		m_doc.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
	

	

// add a directed target specification
// implements IVssComponent::AddDirectedTarget
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if not called by a writer during backup or if
//			the restore target is not directed.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::AddDirectedTarget
	(
	IN LPCWSTR wszSourcePath,
	IN LPCWSTR wszSourceFilename,
	IN LPCWSTR wszSourceRangeList,
	IN LPCWSTR wszDestinationPath,
	IN LPCWSTR wszDestinationFilename,
	IN LPCWSTR wszDestinationRangeList
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddDirectedTarget");

	try
		{
		if (wszSourcePath == NULL || wszSourceFilename == NULL ||
			wszSourceRangeList == NULL || wszDestinationRangeList == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot be called during restore");

		if (!m_pWriterComponents)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called by writer.");

		VSS_RESTORE_TARGET rt;
		ft.hr = GetRestoreTarget(&rt);
		ft.CheckForError(VSSDBG_XML, L"IVssComponent::GetRestoreTarget");

		if (rt != VSS_RT_DIRECTED)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Restore target must be Directed.");


		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		// create DIRECTED_TARGET element
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementDirectedTarget,
							NODE_ELEMENT
							);

        // set attributes
        node.SetAttribute(x_wszAttrPath, wszSourcePath);
		node.SetAttribute(x_wszAttrFilespec, wszSourceFilename);
		node.SetAttribute(x_wszAttrSourceRanges, wszSourceRangeList);

		if (wszDestinationPath)
			node.SetAttribute(x_wszAttrTargetPath, wszDestinationPath);

		if (wszDestinationFilename)
			node.SetAttribute(x_wszAttrTargetFilespec, wszDestinationFilename);

		node.SetAttribute(x_wszAttrTargetRanges, wszDestinationRangeList);

		m_pWriterComponents->SetChanged();

		// insert DIRECTED_TARGET node under COMPONENT node
		m_doc.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// set the restore target
// implements CVssComponent::SetRestoreTarget
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by a writer or during
//			backup	
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs


STDMETHODIMP CVssComponent::SetRestoreTarget
	(
	IN VSS_RESTORE_TARGET target
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetRestoreTarget");

	try
		{
		LPCWSTR wszTarget = WszFromRestoreTarget(ft, target);

		if (m_bInRequestor)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only call this function from the requestor");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during restore");

		BS_ASSERT(m_pWriterComponents);

		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		m_doc.SetAttribute(x_wszAttrRestoreTarget, wszTarget);
		m_pWriterComponents->SetChanged();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
	

// obtain the restore target
// implements CVssComponent::GetRestoreTarget
//
// Returns:
//		S_OK if there are no errors
//		VSS_E_BAD_STATE if not called during restore
//		VSS_E_CORRUPT_XML_DOCUMENT if restoreTarget attribute is missing
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetRestoreTarget
	(
	OUT VSS_RESTORE_TARGET *pTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponents::GetRestoreTarget");

	try
		{
		if (pTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called during restore.");

		*pTarget = VSS_RT_UNDEFINED;

		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		CComBSTR bstrRestoreTarget;

		if (!m_doc.FindAttribute(x_wszAttrRestoreTarget, &bstrRestoreTarget))
			*pTarget = VSS_RT_ORIGINAL;
		else
			*pTarget = ConvertToRestoreTarget(ft, bstrRestoreTarget);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



// set failure message during pre restore event
// implements IVssComponent::SetPreRestoreFailureMsg
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by a requestor
//			or during backup.
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::SetPreRestoreFailureMsg
	(
	IN LPCWSTR wszPreRestoreFailureMsg
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetPreRestoreFailureMsg");

	try
		{
		if (wszPreRestoreFailureMsg == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (m_bInRequestor)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call this function in the requestor.");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called during restore.");

		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		BS_ASSERT(m_pWriterComponents != NULL);

		m_doc.SetAttribute(x_wszAttrPreRestoreFailureMsg, wszPreRestoreFailureMsg);
		m_pWriterComponents->SetChanged();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set the failure message during the post restore event
// implements IVssComponent::SetPostRestoreFailureMsg
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by a requestor
//			or during backup.
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs


STDMETHODIMP CVssComponent::SetPostRestoreFailureMsg
	(
	IN LPCWSTR wszPostRestoreFailureMsg
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetPostRestoreFailureMsg");

	try
		{
		if (wszPostRestoreFailureMsg == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (m_bInRequestor)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call this function in the requestor.");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called during restore.");

		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		BS_ASSERT(m_pWriterComponents != NULL);

		m_doc.SetAttribute(x_wszAttrPostRestoreFailureMsg, wszPostRestoreFailureMsg);
		m_pWriterComponents->SetChanged();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set the backup stamp of the backup
// implements IVssComponent::SetBackupStamp
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by the writer or
//			during restore
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::SetBackupStamp
	(
	IN LPCWSTR wszBackupStamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetBackupStamp");

	try
		{
		if (wszBackupStamp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (m_bInRequestor)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only call this function from the writer.");

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during backup.");

		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		m_doc.SetAttribute(x_wszAttrBackupStamp, wszBackupStamp);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



// obtain whether files were successfully restored
// implements IVssComponent::GetFileRestoreStatus
//
// Returns:
//		S_OK if there are no errors
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs
//		VSS_E_BAD_STATE if not called during restore
//		VSS_E_CORRUPT_XML_DOCUMENT if filesRestored attribute is missing

STDMETHODIMP CVssComponent::GetFileRestoreStatus
	(
	OUT VSS_FILE_RESTORE_STATUS *pStatus
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponents::GetFileRestoreStatus");

	try
		{
		if (pStatus == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Must be called during restore.");

		*pStatus = VSS_RS_UNDEFINED;

		CComBSTR bstrFilesRestored;

		if (!m_doc.FindAttribute(x_wszAttrFilesRestored, &bstrFilesRestored))
			*pStatus = VSS_RS_ALL;
		else
			*pStatus = ConvertToFileRestoreStatus(ft, bstrFilesRestored);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



// IUnknown::QueryInterface method
// this method should never be callsed
STDMETHODIMP CVssComponent::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssComponent::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssComponent::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);
	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}

// initilize document to make toplevel node WRITER_COMPONENTS node
// implements IVssWriterComponentsExt::Initialize
// fFindToplevel is called with FALSE if m_doc is already pointing at the
// WRITER_COMPONENTS element as in CVssBackupComponents::GetWriterComponents
// It is called with true if the writer components is buried a child of
// the root document as is the case when a Writer gets the WRITER_COMPONENTS
// node from the document returned by IVssWriterCallback::GetContent.
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::Initialize(bool fFindToplevel)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::Initialize");

	try
		{
		InitializeHelper(ft);

		if (fFindToplevel)
			{
			if (!m_doc.FindElement(x_wszElementWriterComponents, true))
				MissingElement(ft, x_wszElementWriterComponents);

			m_doc.SetToplevel();
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get information about the writer of a compnent
// implements IVssWriterComponents::GetWriterInfo
// NOTE: pidInstance may be NULL (i.e., is optional)
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either parameters is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetWriterInfo
	(
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetWriterInfo"
		);

    try
		{
		VssZeroOut(pidInstance);

		// validate output parameters
		if (pidWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pidWriter = GUID_NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of WRITER_COMPONENTS document
		m_doc.ResetToDocument();
		if (pidInstance)
			// get instanceId attribute value
			get_VSS_IDValue(ft, x_wszAttrInstanceId, pidInstance);

        // get writerId attribute value
		get_VSS_IDValue(ft, x_wszAttrWriterId, pidWriter);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of components associated with the writer
// implements IVssWriterComponents::GetComponentCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetComponentCount(OUT UINT *pcComponents)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetComponentCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		// find first COMPONENT element
		if (!m_doc.FindElement(x_wszElementComponent, TRUE))
			return S_OK;

        UINT cComponents = 0;
        // count COMPONENT elements
		do
			{
			// increment component count
			cComponents++;
			} while(m_doc.FindElement(x_wszElementComponent, FALSE));

        *pcComponents = cComponents;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain a specific component
// implements IVssWriterComponents::GetComponent
// caller is responsible for calling IVssComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is sucessful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if iComponent does not refer to a valid component
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetComponent
	(
	IN UINT iComponent,					// specify component to select
	OUT IVssComponent **ppComponent
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetComponent"
		);

    CVssComponent *pComponent = NULL;
    try
		{
		// validate output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output paramter
		*ppComponent = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reset to top of document
		m_doc.ResetToDocument();

		// find first COMPONENT element
		if (!m_doc.FindElement(x_wszElementComponent, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find %d COMPONENT.",
				iComponent
				);


        // skip to selected component
		for(UINT i = 0; i < iComponent; i++)
			{
			if (!m_doc.FindElement(x_wszElementComponent, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find %d COMPONENT.",
					iComponent
					);
			}

        // return the element as a CVssComponent object
		pComponent = new CVssComponent
						(
						m_doc.GetCurrentNode(),
						m_doc.GetInterface(),
						m_bWriteable ? this : NULL,
						m_bInRequestor,
						m_bRestore
						);

		// check for memory allocation failure
		if (pComponent == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssComponent due to allocation failure"
				);

		// 2nd phase of initialization
		pComponent->Initialize(ft);

		// transfer ownership of pointer
		*ppComponent = (IVssComponent *) pComponent;
		((IVssComponent *) pComponent)->AddRef();
		pComponent = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pComponent;

    return ft.hr;
	}

// return whether any child component was modified
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbChanged is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::IsChanged(OUT bool *pbChanged)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::IsChanged");

	try
		{
		if (pbChanged == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		BS_ASSERT(!m_bChanged || m_bWriteable);
		*pbChanged = m_bChanged;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// save components as XML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::SaveAsXML(OUT BSTR *pbstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::SaveAsXML");

	try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// implements IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWriterComponents::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// implements IUnknown::Release
STDMETHODIMP_(ULONG) CVssWriterComponents::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// get information about the writer of a compnent
// implements IVssWriterComponents::GetWriterInfo
// NOTE: pidInstance may be NULL (i.e., is optional)
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either parameters is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::GetWriterInfo
	(
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetWriterInfo"
		);

    try
		{
		VssZeroOut(pidInstance);

		// validate output parameters
		if (pidWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pidWriter = m_idWriter;
		*pidInstance = m_idInstance;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of components associated with the writer
// implements IVssWriterComponents::GetComponentCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::GetComponentCount
	(
	OUT UINT *pcComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetComponentCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain a specific component
// implements IVssWriterComponents::GetComponent
// caller is responsible for calling IVssComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is sucessful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if no other error is returned

STDMETHODIMP CVssNULLWriterComponents::GetComponent
	(
	IN UINT iComponent,					// specify component to select
	OUT IVssComponent **ppComponent
	)
	{
	UNREFERENCED_PARAMETER(iComponent);
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetComponent"
		);

    try
		{
		// validate output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output paramter
		*ppComponent = NULL;

		ft.hr = VSS_E_OBJECT_NOT_FOUND;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// return whether any child component was modified
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbChanged is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::IsChanged(OUT bool *pbChanged)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssNULLWriterComponents::IsChanged");

	try
		{
		if (pbChanged == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*pbChanged = false;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// save components as XML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::SaveAsXML(OUT BSTR *pbstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssNULLWriterComponents::SaveAsXML");

	try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// implements IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssNULLWriterComponents::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// implements IUnknown::Release
STDMETHODIMP_(ULONG) CVssNULLWriterComponents::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// constructor
CVssBackupComponents::CVssBackupComponents() :
	m_state(x_StateUndefined),
	m_cWriters(0),
	m_cWriterInstances(0),
	m_cWriterClasses(0),
	m_pDataFirst(NULL),
	m_rgWriterProp(NULL),
	m_bInitialized(false),
	m_bGatherWriterStatusComplete(false),
	m_bGatherWriterMetadataComplete(false),
	m_bSetBackupStateCalled(false),
	m_rgWriterInstances(NULL),
	m_rgWriterClasses(NULL),
	m_bIncludeWriterClasses(false),
	m_timestampOperation(0)
	{
	}

// destructor
CVssBackupComponents::~CVssBackupComponents()
	{
	if (m_bInitialized)
		{
		// abort backup in case caller failed to do so
		AbortBackup();

		// free any metadata that is hanging around
		FreeAllWriters();

		// free status associated with writers
		FreeWriterStatus();
		}

	delete m_rgWriterInstances;
	delete m_rgWriterClasses;
	}

// basic initialization
void CVssBackupComponents::BasicInit
	(
	IN CVssFunctionTracer &ft
	)
	{
	// note that there is a potenential race condition if someone tries
	// calling InitializeForBackup and/or InitializeForRestore from
	// multiple threads, but this is not a valid way to use this class and
	// the likelihood of this happening and not being caught is really
	// very slim.
	if (m_state != x_StateUndefined &&
		m_state != x_StateAborted)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_BAD_STATE,
			L"CVssBackupComponents already initialized"
			);

    m_state = x_StateUndefined;

	m_bstrSnapshotSetId = GUID_NULL;
	if (m_bstrSnapshotSetId.Length() == 0)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate BSTR.");

	m_csWriters.Init();
	m_csState.Init();

	// initialize XML document helper
	InitializeHelper(ft);
	}

// validate that object has been initialized
void CVssBackupComponents::ValidateInitialized(CVssFunctionTracer &ft)
	{
	if (!m_bInitialized)
		ft.Throw
			(
			VSSDBG_XML,
		    VSS_E_BAD_STATE,
			L"Initialization function was not called"
			);
    }



// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::Initialize
// Returns:
//		S_OK if the operation is succesfsful
//		VSS_E_CORRUPTXMLDOCUMENT if the initial XML document is corrupt
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::InitializeForBackup(IN BSTR bstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InitializeForBackup"
		);

	try
		{
		if (!IsProcessBackupOperator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Access denied");

		BasicInit(ft);

		// protect state variable throughout this function
		CVssSafeAutomaticLock lock(m_csState);

		BS_ASSERT(m_state == x_StateUndefined);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

		// intialize document with <root><schema></root>
		m_doc.LoadFromXML(g_ComponentMetadataXML);

		// find toplevel <root> element
		if (!m_doc.FindElement(x_wszElementRoot, true))
			MissingElement(ft, x_wszElementRoot);

		// create BACKUP_COMPONENTS element under <root> element
		CXMLNode nodeRoot(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// save root node.  It is modified in PrepareForBackup
		m_pNodeRoot = m_doc.GetCurrentNode();

		CXMLNode nodeBackup = m_doc.CreateNode	
				(
				x_wszElementBackupComponents,
				NODE_ELEMENT
				);

        // set schema and version attributes
		nodeBackup.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);
		nodeBackup.SetAttribute(x_wszAttrVersion, x_wszVersionNo);
		CXMLNode nodeToplevel = nodeRoot.InsertNode(nodeBackup);
		m_doc.SetToplevelNode(nodeToplevel);

		// indicate that CVssBackupComponents object is initialized
		m_state = x_StateInitialized;
		m_bRestore = false;
		m_bInitialized = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	UNREFERENCED_PARAMETER(bstrXML);
	}

// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::SetBackupState
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupState
	(
	IN bool bSelectComponents,			// does backup allow selective backup of components
	IN bool bBootableSystemStateBackup,	// is bootable system state being backed up
	IN VSS_BACKUP_TYPE backupType,		// backup type
	IN bool bPartialFileSupport			// is partial file backup and restore supported
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBacupComponents::SetBackupState"
		);

	try
		{
		LPCWSTR wszBackupType = WszFromBackupType(ft, backupType);

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();
		CXMLNode nodeBackup(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// set bootableSystemStateBackup flag
		nodeBackup.SetAttribute
			(
			x_wszAttrBootableSystemStateBackup,
			WszFromBoolean(bBootableSystemStateBackup)
			);

		// set indication of whether backup is selecting drives or
		// components
		nodeBackup.SetAttribute
			(
			x_wszAttrSelectComponents,
			WszFromBoolean(bSelectComponents)
			);

		// set backup type
		nodeBackup.SetAttribute(x_wszAttrBackupType, wszBackupType);

		// indicate whether requestor supports partial file backup and
		// restore
		nodeBackup.SetAttribute
			(
			x_wszAttrPartialFileSupport,
			WszFromBoolean(bPartialFileSupport)
			);

		m_bSetBackupStateCalled = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::Initialize
//
// Returns:
//		S_OK if the operation is successful
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::InitializeForRestore
	(
	IN BSTR bstrXML		 // components document
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBacupComponents::Initialize"
		);

	try
		{
		if (!IsProcessRestoreOperator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Access denied");

		BasicInit(ft);

		// protect m_state member variable throughout this function
		CVssSafeAutomaticLock lock(m_csState);

		// state should indicate we are not initialized
		BS_ASSERT(m_state == x_StateUndefined);
        LoadComponentsDocument(bstrXML);

		// indicate that CVssBackupComponents object is initialized
		m_state = x_StateInitialized;
		m_bRestore = true;
		m_bInitialized = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// load the backup components document from a string
void CVssBackupComponents::LoadComponentsDocument(BSTR bstrXML)
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::LoadComponentsDocument");

    // acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lockDOM(m_csDOM);

    // compute length of constructed document consisting of
    // a root node, schema, and supplied document
    UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXML);

    // allocate string
    CComBSTR bstr;
    bstr.Attach(SysAllocStringLen(NULL, cwcDoc));

    // check for allocation failure
    if (!bstr)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

    // setup pointer to beginning of string
    WCHAR *pwc = bstr;

    // copy in <root> <schema>
    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
    pwc += g_iwcComponentMetadataXMLEnd;

    // copy in document
    wcscpy(pwc, bstrXML);
    pwc += wcslen(bstrXML);

    // copy in </root>
    wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);

    // intialize document with <root><schema></root>
    if (!m_doc.LoadFromXML(bstr))
        {
        // reinitialize document
        m_doc.Initialize();
        ft.Throw
            (
            VSSDBG_XML,
            VSS_E_INVALID_XML_DOCUMENT,
            L"Load of Backup components document failed"
            );
        }

	// find toplevel <root> element
	if (!m_doc.FindElement(x_wszElementRoot, true))
		MissingElement(ft, x_wszElementRoot);

	// save root node.  It is modified in PreRestore and PostRestore
	m_pNodeRoot = m_doc.GetCurrentNode();


    // find BACKUP_COMPONENTS element
    if (!m_doc.FindElement(x_wszElementBackupComponents, true))
        MissingElement(ft, x_wszElementBackupComponents);

    // set BACKUP_COMPONENTS as toplevel element
    m_doc.SetToplevel();
    }




// add a specific component to the document
// implements IVssBackupComponents::AddComponent
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_ALREADY_EXISTS if a component with the same type, path
//			and name already exists
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddComponent
	(
	IN VSS_ID instanceId,
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AddComponent"
		);

    try
		{
		// validate input parameters
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		// validate state
		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateInitialized &&
			m_state != x_StateSnapshotSetCreated)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"CVssBackupComponents::AddComponent called at the wrong time"
				);

		// obtain component type as string
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		CComPtr<IXMLDOMNode> pNode;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

		// create the COMPONENT
		FindComponent
			(
			ft,
			&instanceId,
			writerId,
			wszComponentType,
			wszLogicalPath,
			wszComponentName,
            true
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// routine to obtain flags from the a BACKUP_COMPONENTS XML document
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetBackupState
	(
	OUT BOOL *pbSelectComponents,			// does backup allow selection of components
	OUT BOOL *pbBootableSystemStateBackup,	// is bootable system state being backed up
	OUT VSS_BACKUP_TYPE *pBackupType,		// backup type
	OUT BOOL *pbPartialFileSupport
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssBackupComponents::GetBackupState");

	try
		{
		if (pbBootableSystemStateBackup)
			*pbBootableSystemStateBackup = FALSE;

		if (pBackupType)
			*pBackupType = VSS_BT_UNDEFINED;

		if (pbPartialFileSupport)
			*pbPartialFileSupport = FALSE;

		// validate output parameters
		if (pbSelectComponents == NULL ||
			pbBootableSystemStateBackup == NULL ||
			pBackupType == NULL ||
			pbPartialFileSupport == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pbSelectComponents = FALSE;

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		// position to top of BACKUP_COMPONENTS document
		m_doc.ResetToDocument();

		// get bootableSystemState attribute value
		bool bBootableSystemStateBackup, bSelectComponents, bPartialFileSupport;
		if (!get_boolValue(ft, x_wszAttrBootableSystemStateBackup, &bBootableSystemStateBackup))
			MissingAttribute(ft, x_wszAttrBootableSystemStateBackup);

		// get selectComponents attribute value
		if (!get_boolValue(ft, x_wszAttrSelectComponents, &bSelectComponents))
			MissingAttribute(ft, x_wszAttrSelectComponents);

		// get partialFileSupport attribute value
		if (!get_boolValue(ft, x_wszAttrPartialFileSupport, &bPartialFileSupport))
			MissingAttribute(ft, x_wszAttrPartialFileSupport);

		CComBSTR bstrBackupType;

		if (!get_stringValue(x_wszAttrBackupType, &bstrBackupType))
			MissingAttribute(ft, x_wszAttrBackupType);


		*pBackupType = ConvertToBackupType(ft, bstrBackupType);
		*pbBootableSystemStateBackup = bBootableSystemStateBackup;
		*pbSelectComponents = bSelectComponents;
		*pbPartialFileSupport = bPartialFileSupport;
		}
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}

// internal routine to find or create a specific WRITER_COMPONENTS element
CXMLNode CVssBackupComponents::PositionOnWriterComponents
	(
	IN CVssFunctionTracer &ft,
	IN VSS_ID *pinstanceId,		// NULL indicates that it is not specified
	IN VSS_ID writerId,			// writer class id
	IN bool bCreateIfNotThere,	// create WRITER_COMPONENTS element if it isn't there
	OUT bool &bCreated			// whether component was created or not
	) throw(HRESULT)
	{
	// initialize output parameter
	bCreated = false;

	// position to top of BACKUP_COMPONENTS document
	m_doc.ResetToDocument();

	// set parent node to be BACKUP_COMPONENTS element
	CXMLNode nodeBackupComponents(m_doc.GetCurrentNode(), m_doc.GetInterface());
	bool bFound = false;

	// look for first WRITER_COMPONENTS element
	if (m_doc.FindElement(x_wszElementWriterComponents, TRUE))
		{
		do
			{
			VSS_ID writerIdFound;
			VSS_ID instanceIdFound;
			CComBSTR bstrVal;

			// get writerId attribute
			get_VSS_IDValue(ft, x_wszAttrWriterId, &writerIdFound);

			if (pinstanceId)
				{
				get_VSS_IDValue(ft, x_wszAttrInstanceId, &instanceIdFound);

				// if instanceId doesn't match, then skip this element
				if (*pinstanceId != instanceIdFound)
					continue;
				}

			// if writerId attribute matches, then we have found the target element
			if (writerId == writerIdFound)
				{
				bFound = true;
				break;
				}
			} while (m_doc.FindElement(x_wszElementWriterComponents, FALSE));
        }

	// if element is found, then return it
	if (bFound)
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

	if (!bCreateIfNotThere)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_NOT_FOUND,
			L"WRITER_COMPONENTS element was not found."
			);

	// create element if requested
    CXMLNode node = m_doc.CreateNode
		(
		x_wszElementWriterComponents,
		NODE_ELEMENT
		);

    // assign instanceId if supplied
    if (pinstanceId)
		node.SetAttribute(x_wszAttrInstanceId, *pinstanceId);

	// assign writerId
	node.SetAttribute(x_wszAttrWriterId, writerId);

	// insert WRITER_COMPONENTS element under BACKUP_COMPONENTS node
	CXMLNode nodeRet = nodeBackupComponents.InsertNode(node);

	// element was created
	bCreated = true;

	// return node
	return nodeRet;
	}

// internal routine to return/create a specific COMPONENT
// assumes caller has already locked m_csDOM
CXMLNode CVssBackupComponents::FindComponent
	(
	IN CVssFunctionTracer &ft,
	IN VSS_ID *pinstanceId,			// NULL means instanceId is not specified(RESTORE)
	IN VSS_ID writerId,				// writer class id
	IN LPCWSTR wszComponentType,	// component type (DATABASE or FILE_GROUP)		
	IN LPCWSTR wszLogicalPath,		// logical path to component
	IN LPCWSTR wszComponentName,	// component name
	IN bool bCreate					// whether creation of element is allowed
	)
	{
	// both componentType and componentName should be specified
	BS_ASSERT(wszComponentType != NULL);
	BS_ASSERT(wszComponentName != NULL);

	// initialize state variables
	bool bFound = false;
	bool bCreated = false;

	// get WRITER_COMPONENTS node
	CXMLNode nodeWriter = PositionOnWriterComponents(ft, pinstanceId, writerId, true, bCreated);

	// find first child COMPONENT element under WRITER_COMPONENTS if
	// WRITER_COMPONENTS was found
	if (!bCreated && m_doc.FindElement(x_wszElementComponent, TRUE))
		{
		do
			{
			CComBSTR bstrComponentType;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			// get component type
			if (!get_stringValue(x_wszAttrComponentType, &bstrComponentType))
				MissingAttribute(ft, x_wszAttrComponentType);

            // if componentName doesn't match, then skip component
            if (wcscmp(wszComponentType, bstrComponentType) != 0)
				continue;

			bool fLogicalPath = get_stringValue(x_wszAttrLogicalPath, &bstrLogicalPath);
			if (wszLogicalPath != NULL && wcslen(wszLogicalPath) > 0)
				{
				// logical path doesn't exist, skip component
				if (!fLogicalPath)
					continue;
				else
					{
					// if logical path doesn't match, then skip component
					if (wcscmp(bstrLogicalPath, wszLogicalPath) != 0)
						continue;
					}
				}
			else
				{
				// if logical path exists, then skip component
				if (fLogicalPath)
					continue;
				}

			// get component name
			if (!get_stringValue(x_wszAttrComponentName, &bstrComponentName))
				MissingAttribute(ft, x_wszAttrComponentName);

            // if component name matches, then we are done
            if (wcscmp(wszComponentName, bstrComponentName) == 0)
				{
				bFound = true;
				break;
				}
			} while(m_doc.FindElement(x_wszElementComponent, FALSE));
        }

	if (bFound && bCreate)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_ALREADY_EXISTS,
			L"Attempt to create a duplicate component."
			);


    // return node if found
	if (bFound && !bCreate)
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

	// if node not found and if we cannot create the node, then return an error
	if (!bCreate)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_NOT_FOUND,
			L"Component was not found. %s\\%s",
			wszLogicalPath,
			wszComponentName
			);

	// create node if requested to
	CXMLNode node = m_doc.CreateNode
			(
			x_wszElementComponent,
			NODE_ELEMENT
			);

     // assign logicalPath attribute if supplied
    if (wszLogicalPath && wcslen(wszLogicalPath) > 0)
		node.SetAttribute(x_wszAttrLogicalPath, wszLogicalPath);

	// assign componentName attribute
	node.SetAttribute(x_wszAttrComponentName, wszComponentName);

	// assign componentType attribute
	node.SetAttribute(x_wszAttrComponentType, wszComponentType);

	// insert COMPONENT node under WRITER_COMPONENTS node
	return nodeWriter.InsertNode(node);
	}

// get a callback interface
void CVssBackupComponents::GetCallbackInterface
	(
	CVssFunctionTracer &ft,
	IDispatch **ppDispatch
	)
	{
	CComPtr<IUnknown> pUnknown = GetUnknown();
	CComPtr<IDispatch> pDispatch;
	ft.hr = pUnknown->SafeQI(IDispatch, &pDispatch);
	BS_ASSERT(!ft.HrFailed());
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
            E_UNEXPECTED,
			L"Error querying for the IDispatch interface.  hr = 0x%08x",
			ft.hr
			);
        }

    *ppDispatch = pDispatch.Detach();
	}

// set up IVssWriters interface
void CVssBackupComponents::SetupWriter
	(
	CVssFunctionTracer &ft,
	IVssWriter **ppWriter,
	bool bMetadataFire
	)
	{
	CComPtr<IVssWriter> pWriter;
	ft.hr = pWriter.CoCreateInstance(CLSID_VssEvent);
	ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

	BS_ASSERT(pWriter);
	if (bMetadataFire)
		SetupPublisherFilter
			(
			pWriter,
			m_rgWriterClasses,
			m_cWriterClasses,
			NULL,
			0,
			true,
			m_bIncludeWriterClasses
			);
    else
		SetupPublisherFilter
			(
			pWriter,
			NULL,
			0,
			m_rgWriterInstances,
			m_cWriterInstances,
			false,
			m_bIncludeWriterClasses
			);

	*ppWriter = pWriter.Detach();
	}

// signal PrepareForBackup event to writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PrepareForBackup
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PrepareForBackup"
		);

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateSnapshotSetCreated ||
			!m_bSetBackupStateCalled)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_PREPARE_FOR_BACKUP
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// internal PrepareForBackup call called from CVssAsyncBackup class
HRESULT CVssBackupComponents::InternalPrepareForBackup()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPrepareForBackup"
		);

	// get lock serializing state changes
	m_csState.Lock();
	LONG timestamp = InterlockedIncrement(&m_timestampOperation);

	try
		{
		if (m_state != x_StateSnapshotSetCreated)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);
	
        m_state = x_StatePrepareForBackup;

        // save and reload XML document in order to get proper schema
        // validation to take place
            {
            CComBSTR bstrXML;
            ft.hr = SaveAsXML(&bstrXML);
            ft.CheckForError(VSSDBG_XML, L"CVssBackupComponents::SaveAsXML");
            LoadComponentsDocument(bstrXML);
            }

		TrimWriters();

		// get IVssWriter event class
		CComPtr<IVssWriter> pWriter;

		SetupWriter(ft, &pWriter, false);
		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);


		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalPrepareForBackup1");
		ft1.hr = pWriter->PrepareForBackup(m_bstrSnapshotSetId, pDispatch);
		ft.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::PrepareForBackup (%s)", m_bstrSnapshotSetId);

		if (ValidateTimestamp(timestamp))
			{
			RebuildComponentData(ft);
			m_state = x_StatePrepareForBackupSucceeded;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (ValidateTimestamp(timestamp))
		{
		if (ft.HrFailed())
			m_state = x_StatePrepareForBackupFailed;

		FreeWriterComponents();
		m_csState.Unlock();
		}

	return ft.hr;
	}
																
// called by IVssAsync::Cancel to cancel a PrepareForBackup operation
HRESULT CVssBackupComponents::PostPrepareForBackup
	(
	IN LONG timestamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPrepareForBackup");

	if (ValidateTimestamp(timestamp))
		{
		try
			{
			RebuildComponentData(ft);
			}
		VSS_STANDARD_CATCH(ft)

		if (ft.HrFailed())
            m_state = x_StatePrepareForBackupFailed;
		else
			m_state = x_StatePrepareForBackupSucceeded;

		FreeWriterComponents();
		m_csState.Unlock();
		}

	return ft.hr;
	}


// rebuild component metadata from data gotten from writers during
// prepare for backup
void CVssBackupComponents::RebuildComponentData
	(
	IN CVssFunctionTracer &ft
	)
	{
	CVssSafeAutomaticLock lock(m_csDOM);

	m_doc.ResetToDocument();
	CComPtr<IXMLDOMNode> pNodeParent = m_doc.GetCurrentNode();

	CComPtr<IXMLDOMNode> pNodeCloned;

	if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
		return;

    ft.hr = pNodeParent->cloneNode(VARIANT_TRUE, &pNodeCloned);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode:cloneNode");

	CXMLDocument docCloned(pNodeCloned, m_doc.GetInterface());

	if (!docCloned.FindElement(x_wszElementWriterComponents, TRUE))
		{
		ft.LogError(VSS_ERROR_CLONE_MISSING_CHILDREN, VSSDBG_XML);
		ft.Throw
			(
            VSSDBG_XML,
			VSS_E_CORRUPT_XML_DOCUMENT,
			L"Cloned node has no children"
			);
        }			

	do
		{
		VSS_ID idInstance;

		CComBSTR bstrVal;

		if (!docCloned.FindAttribute(x_wszAttrInstanceId, &bstrVal))
			MissingAttribute(ft, x_wszAttrInstanceId);

        CVssMetadataHelper::ConvertToVSS_ID(ft, bstrVal, &idInstance);

		for
			(
			CInternalWriterData *pData = m_pDataFirst;
			pData != NULL;
			pData = pData->m_pDataNext
			)
			{
			if (pData->m_idInstance == idInstance)
				break;
			}

		if (pData != NULL && pData->m_bstrWriterComponents)
			{
			CXMLDocument doc;
			BSTR bstrXMLDocContent = pData->m_bstrWriterComponents;

			// build string containing schema
			// a root node, schema, and supplied document
			UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXMLDocContent);

			// allocate string
			CComBSTR bstr;

			bstr.Attach(SysAllocStringLen(NULL, cwcDoc));

			// check for allocation failure
			if (!bstr)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

			// setup pointer to beginning of string
			WCHAR *pwc = bstr;

			// copy in <root> <schema>
			memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
			pwc += g_iwcComponentMetadataXMLEnd;

			// copy in document
			wcscpy(pwc, bstrXMLDocContent);
			pwc += wcslen(bstrXMLDocContent);

			// copy in </root>
			wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);

			if (!doc.LoadFromXML(bstr) ||
			    !doc.FindElement(x_wszElementRoot, true))
				{
				ft.LogError(VSS_ERROR_INVALID_XML_DOCUMENT_FROM_WRITER, VSSDBG_XML << pData->m_idInstance);
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_CORRUPT_XML_DOCUMENT,
					L"XML data from writer is not valid:" WSTR_GUID_FMT,
					GUID_PRINTF_ARG(pData->m_idInstance)
					);
                }

            doc.SetToplevel();

            if (!doc.FindElement(x_wszElementWriterComponents, TRUE))
				MissingElement(ft, x_wszElementWriterComponents);

	        ft.hr = pNodeCloned->replaceChild
				(
				doc.GetCurrentNode(),
				docCloned.GetCurrentNode(),
				NULL
				);
            ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::replaceChild");
			docCloned.SetCurrentNode(doc.GetCurrentNode());
			}

		} while(docCloned.FindElement(x_wszElementWriterComponents, FALSE));

	ft.hr = m_pNodeRoot->replaceChild
		(
		pNodeCloned,
		pNodeParent,
		NULL
		);

    ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::replaceChild");

    CXMLNode newToplevelNode(pNodeCloned, m_doc.GetInterface());
    m_doc.SetToplevelNode(newToplevelNode);
	}


// indicate that backup was aborted
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AbortBackup()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AbortBackup"
		);

    try
		{
		// validate that object has been initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);


		if (m_state == x_StatePrepareForBackup ||
			m_state == x_StatePrepareForBackupFailed ||
			m_state == x_StatePrepareForBackupSucceeded ||
			m_state == x_StateDoSnapshotFailedWithoutSendingAbort)
			{
			m_state = x_StateAborting;

			// setup pointer to writer event class
			CComPtr <IVssWriter> pWriter;
			SetupWriter(ft, &pWriter, false);

			CComPtr<IDispatch> pDispatch;
			GetCallbackInterface(ft, &pDispatch);
			ft.hr = pWriter->Abort(m_bstrSnapshotSetId);
			ClearPublisherFilter(pWriter);
			}

		// release coordinator if we have a pointer to cause
		// it to abort anything in progress
		if (m_pCoordinator)
			m_pCoordinator = NULL;

		m_state = x_StateAborted;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}




// gather status of the writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GatherWriterStatus
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GatherWriterStatus"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

	    *ppAsync = NULL;

		// validate that object has been initialized
		ValidateInitialized(ft);

		m_bGatherWriterStatusComplete = false;

		*ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_GATHER_WRITER_STATUS
			);

		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



// gather status of the writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//		VSS_E_WRITER_INFRASTRUCTURE: either the service state or bootable
//      	state writer failed to respond
//

HRESULT CVssBackupComponents::InternalGatherWriterStatus()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalGatherWriterStatus"
		);

	LONG timestamp = 0;
	VSS_BACKUPCALL_STATE stateSaved = x_StateUndefined;
    bool bInitialized = false;
	bool bLocked = false;

    try
		{
		// validate that object has been initialized
		ValidateInitialized(ft);

		m_csState.Lock();
		bLocked = true;
        timestamp = InterlockedIncrement(&m_timestampOperation);
        stateSaved = m_state;

		FreeWriterStatus();

		m_rgWriterProp = new VSS_WRITER_PROP[m_cWriters];
		if (m_rgWriterProp == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Unable to allocate writer property array");


		CInternalWriterData *pData = m_pDataFirst;
		UINT iWriterInstance = 0;

		// initialize array with writers assuming that they didn't respond
		// unless they are filtered out in which case the response is assumed
		// to be successful
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			m_rgWriterProp[iWriter].m_InstanceId = pData->m_idInstance;
			m_rgWriterProp[iWriter].m_ClassId = pData->m_idWriter;
			m_rgWriterProp[iWriter].m_pwszName = pData->m_bstrWriterName;
			if (pData->m_idInstance != m_rgWriterInstances[iWriterInstance] ||
				iWriterInstance >= m_cWriterInstances)
				{
				// writer is not in list of writers that will receive events
				// save last failure and last state.
				m_rgWriterProp[iWriter].m_hrWriterFailure = pData->m_hrWriterFailure;
				m_rgWriterProp[iWriter].m_nState = pData->m_nState;
				m_rgWriterProp[iWriter].m_bResponseReceived = true;
				}
			else
				{
				// assume that writer will fail to respond.
				m_rgWriterProp[iWriter].m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;
				m_rgWriterProp[iWriter].m_bResponseReceived = false;
				iWriterInstance++;
				}

			pData = pData->m_pDataNext;
			}

		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter, false);
		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);

		bInitialized = true;

		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalGatherWriterStatus1");

		// invoke writers
		ft1.hr = pWriter->RequestWriterInfo
			(
			m_bstrSnapshotSetId,
			false,
			true,
			pDispatch
			);

        ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::RequestWriterInfo, Request Writer Status");
		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

    CInternalWriterData *pData = m_pDataFirst;
	if (bInitialized && ValidateTimestamp(timestamp))
		{
		// look for writers that failed to respond
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			if (!m_rgWriterProp[iWriter].m_bResponseReceived)
				{
				// check to see if either bootable state or service state writers
				// are missing and are not disabled
				if ((m_rgWriterProp[iWriter].m_ClassId == idWriterBootableState &&
					 !IsWriterClassDisabled(idWriterBootableState) &&
					 !IsWriterInstanceDisabled(m_rgWriterProp[iWriter].m_InstanceId)) ||
					(m_rgWriterProp[iWriter].m_ClassId == idWriterServiceState &&
					 !IsWriterClassDisabled(idWriterServiceState) &&
					 !IsWriterInstanceDisabled(m_rgWriterProp[iWriter].m_InstanceId)))
					{
					// a key writer is missing meaning that the entire
					// infrastructure must be broken
					ft.hr = VSS_E_WRITER_INFRASTRUCTURE;
					ft.LogError(VSS_ERROR_WRITER_INFRASTRUCTURE, VSSDBG_XML);
					m_bGatherWriterStatusComplete = false;
					break;
					}

				// compute writer state based on where we are in the backup
				switch(stateSaved)
					{
					default:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_FREEZE;
						break;

					case x_StatePrepareForBackupSucceeded:
					case x_StatePrepareForBackupFailed:
                    case x_StatePrepareForBackup:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_PREPARE_BACKUP;
						break;

					case x_StateBackupCompleteFailed:
                    case x_StateBackupComplete:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_BACKUP_COMPLETE;
						break;

                    case x_StatePreRestoreFailed:
                    case x_StatePreRestore:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_PRE_RESTORE;
						break;

                    case x_StatePostRestoreFailed:
                    case x_StatePostRestore:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_POST_RESTORE;
						break;

							
					case x_StateBackupCompleteSucceeded:
                    case x_StatePreRestoreSucceeded:
					case x_StatePostRestoreSucceeded:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_STABLE;
						break;
					}

				// disable the writer for future calls

				VSS_ID idInstance = m_rgWriterProp[iWriter].m_InstanceId;
				DisableWriterInstances(&idInstance, 1);

				try
					{
					ft.LogError(VSS_ERROR_WRITER_NOT_RESPONDING, VSSDBG_XML << m_rgWriterProp[iWriter].m_pwszName);
					}
				catch(...)
					{
					}
				}

			// save writer failure and writer state
			pData->m_nState = m_rgWriterProp[iWriter].m_nState;
			pData->m_hrWriterFailure = m_rgWriterProp[iWriter].m_hrWriterFailure;
			pData = pData->m_pDataNext;
			}
		}

	if (bLocked && ValidateTimestamp(timestamp))
		{
		if (ft.HrFailed())
			{
			try
				{
				delete m_rgWriterProp;
				}
			catch(...)
				{
				}

			m_rgWriterProp = NULL;
			}
		else
			m_bGatherWriterStatusComplete = true;

		m_state = stateSaved;
		m_csState.Unlock();
		}

    return ft.hr;
	}

// called by IVssAsync::Cancel to cancel GatherWriterStatus
void CVssBackupComponents::PostGatherWriterStatus
	(
	IN LONG timestamp,
	IN VSS_BACKUPCALL_STATE stateSaved
	)
	{
	if (ValidateTimestamp(timestamp))
		{
		m_bGatherWriterStatusComplete = true;
		m_state = stateSaved;
		m_csState.Unlock();
		}
	}


// get count of writers with status
//
// Returns:
//		S_OK if the operation is successful
//      E_INVALIDARG if pcWriters is NULL
//		VSS_E_BAD_STATE if GatherWriterStatusAsync was not called or is not complete
//
STDMETHODIMP CVssBackupComponents::GetWriterStatusCount
	(
	OUT UINT *pcWriters
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::GetWriterStatusCount");

	try
		{
		if (pcWriters == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer.");

		*pcWriters = NULL;

		if (!m_bGatherWriterStatusComplete)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"GatherWriterStatusAsync was not called or is not complete.");

		*pcWriters = m_cWriters;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}




// get status for a particular writer
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pStatus, pidWriter, pbstrWriter, or pidInstance is NULL
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_NOT_FOUND if iWriter specifies a non-existent writer
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterStatus
	(
	IN UINT iWriter,
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter,
	OUT BSTR *pbstrWriter,
	OUT VSS_WRITER_STATE *pStatus,
	OUT HRESULT *phrWriterFailure
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterStatus"
		);

    try
		{
		VssZeroOut(pidInstance);
		VssZeroOut(pbstrWriter);
		if (pStatus != NULL)
			*pStatus = VSS_WS_UNKNOWN;

		if (pidInstance == NULL ||
			pidWriter == NULL ||
			pbstrWriter == NULL ||
			pStatus == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		*pidWriter = GUID_NULL;

		// validate that object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);
		if (iWriter >= m_cWriters)
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Invalid writer selection");

		CComBSTR bstrWriter = m_rgWriterProp[iWriter].m_pwszName;
		if (!bstrWriter)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failure to allocate Writer name");

		*pidInstance = m_rgWriterProp[iWriter].m_InstanceId;
		*pidWriter = m_rgWriterProp[iWriter].m_ClassId;

		*pStatus = m_rgWriterProp[iWriter].m_nState;
		if (phrWriterFailure)
			*phrWriterFailure = m_rgWriterProp[iWriter].m_hrWriterFailure;

		*pbstrWriter = bstrWriter.Detach();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// free all writer status information
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::FreeWriterStatus()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterStatus");

	try
		{
		// validate that object is initialized
		ValidateInitialized(ft);
		CVssSafeAutomaticLock lock(m_csWriters);
		try
			{
			delete m_rgWriterProp;
			}
		catch(...)
			{
			}

		m_rgWriterProp = NULL;
        m_bGatherWriterStatusComplete = false;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// indicate that backupSucceded on a component
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszComponentName is NULL or if the componentType is
//			not valid
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupSucceeded
	(
	IN VSS_ID instanceId,
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bSucceeded
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SetBackupSucceeded"
		);

    try
		{
		// validate input parameters
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
        if (wszComponentName == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Required input string parameter is NULL."
				);

        // validate that object initialized
        ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							&instanceId,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

        // set backupSucceeded attribute on COMPONENT
		node.SetAttribute
			(
			x_wszAttrBackupSucceeded,
			WszFromBoolean(bSucceeded)
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// set backup options for the writer
// implements IVssBackupComponents::SetBackupOptions
//
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by the writer or
//			during restore
//		E_INVALIDARG if wszData is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupOptions
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszBackupOptions
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetBackupOptions");

	try
		{
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);

		if (wszBackupOptions == NULL || wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during backup.");

		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		// find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

		node.SetAttribute(x_wszAttrBackupOptions, wszBackupOptions);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// indicate that a given component is selected to be restored
// implements IVssComponent::SetSelectedForRestore
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		VSS_E_BAD_STATE if this operation is called during backup
//		E_OUTOFMEMORY if an allocation failure occurs
//		E_INVALIDARG if the component type is invalid or the
//			component name is null

STDMETHODIMP CVssBackupComponents::SetSelectedForRestore
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bSelectedForRestore
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetSelectedForRestore");

	try
		{
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during backup.");

		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		// find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);


		node.SetAttribute(x_wszAttrSelectedForRestore, WszFromBoolean(bSelectedForRestore));
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
	




// set restore options for the writer
// implements IVssBackupComponents::SetRestoreOptions
//
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		VSS_E_BAD_STATE if this operation is called by the writer or
//			during backup
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetRestoreOptions
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszRestoreOptions
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetRestoreOptions");
	try
		{
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);	
		if (wszRestoreOptions == NULL || wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during restore");

		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

    	// find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

		node.SetAttribute(x_wszAttrRestoreOptions, wszRestoreOptions);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// requestor indicates whether files were successfully restored
// implements IVssBackupComponents::SetFileRestoreStatus
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by a writer or during
//			backup	
//		E_INVALIDARG if wszData is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetFileRestoreStatus
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN VSS_FILE_RESTORE_STATUS status
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetFileRestoreStatus");

	try
		{
		LPCWSTR wszStatus = WszFromFileRestoreStatus(ft, status);
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);

		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");


		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during restore");

		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

		node.SetAttribute(x_wszAttrFilesRestored, wszStatus);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// indicate that additional restores will follow
// implements IVssBackupComponents::SetAdditionalRestores
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called during restore
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs
//		E_INVALIDARG if the component type is invalid

STDMETHODIMP CVssBackupComponents::SetAdditionalRestores
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bAdditionalRestores
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetAdditionalRestores");

	try
		{
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during backup.");

        ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);


		node.SetAttribute(x_wszAttrAdditionalRestores, WszFromBoolean(bAdditionalRestores));
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



// set the backup stamp that the differential or incremental
// backup is based on
// implements IVssBackupComponents:SetPreviousBackupStamp
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called by the writer or
//			during restore
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetPreviousBackupStamp
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszPreviousBackupStamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetPreviousBackupStamp");

	try
		{
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);

		if (wszPreviousBackupStamp == NULL || wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during backup.");

		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		// find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

		node.SetAttribute(x_wszAttrPreviousBackupStamp, wszPreviousBackupStamp);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}





// save document as an XML string
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs


STDMETHODIMP CVssBackupComponents::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SaveAsXML"
		);

    try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// signal BackupComplete event to the writers
HRESULT CVssBackupComponents::InternalBackupComplete()
	{
    CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalBackupComplete"
		);


	// protect state transition
	m_csState.Lock();
	LONG timestamp = InterlockedIncrement(&m_timestampOperation);
    try
		{
		if (m_state != x_StateDoSnapshotSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        m_state = x_StateBackupComplete;

		// setup pointer to Writer event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter, false);

		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"IVssWriter::InternalBackupComplete1");
		ft1.hr = pWriter->BackupComplete(m_bstrSnapshotSetId, pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::BackupComplete(%s)", m_bstrSnapshotSetId);
		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (ValidateTimestamp(timestamp))
		{
		if (ft.HrFailed())
			m_state = x_StateBackupCompleteFailed;
		else
			m_state = x_StateBackupCompleteSucceeded;

		m_csState.Unlock();
		}

    return ft.hr;
	}

// called by IVssAsync::Cancel to cancel the BackupComplete operation
void CVssBackupComponents::PostBackupComplete
	(
	IN LONG timestamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostBackupComplete");

	if (ValidateTimestamp(timestamp))
		{
		m_state = x_StateBackupCompleteSucceeded;
		m_csState.Unlock();
		}
	}

// signal BackupComplete event to the writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if performing a restore or if the backup
//		components document is not initialized or if the stat is not
//		x_StateDoSnapshotSucceeded
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::BackupComplete(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::BackupComplete"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		// validate that the class is initialized
		ValidateInitialized(ft);
		
		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateDoSnapshotSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_BACKUP_COMPLETE
						);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add an ALTERNATE_LOCATION_MAPPING to a component on restore.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddAlternativeLocationMapping
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE componentType,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilespec,
	IN bool bRecursive,
	IN LPCWSTR wszDestination
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AddAlternativeLocationMapping"
		);

    try
		{
		// validate input parameters
		LPCWSTR wszComponentType = WszFromComponentType(ft, componentType, true);
		if (wszComponentName == NULL ||
			wszFilespec == NULL ||
			wszPath == NULL ||
			wszDestination == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Required input string parameter is NULL."
				);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find COMPONENT
		CXMLNode nodeComponent = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

        // create ALTERNATE_LOCATION_MAPPING node
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementAlternateMapping,
							NODE_ELEMENT
							);

        // set attributes
        node.SetAttribute(x_wszAttrPath, wszPath);
		node.SetAttribute(x_wszAttrFilespec, wszFilespec);
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));
		node.SetAttribute(x_wszAttrAlternatePath, wszDestination);

		// insert ALTERNATE_LOCATION_MAPPING node under COMPONENT node
		nodeComponent.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add a subcomponent to be restored
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if the operation is called by a writer or
//			during backup
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddRestoreSubcomponent
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE componentType,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszSubcomponentLogicalPath,
	IN LPCWSTR wszSubcomponentName,
	IN bool bRepair
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddRestoreSubcomponent");

	try
		{
		LPCWSTR wszComponentType = WszFromComponentType(ft, componentType, true);
		if (wszSubcomponentLogicalPath == NULL ||
			wszComponentName == NULL ||
			wszSubcomponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter");

		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can only be called during restore");

		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find COMPONENT
		CXMLNode nodeComponent = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementRestoreSubcomponent,
							NODE_ELEMENT
							);

        // set attributes
		node.SetAttribute(x_wszAttrLogicalPath, wszSubcomponentLogicalPath);
		node.SetAttribute(x_wszAttrComponentName, wszSubcomponentName);
		node.SetAttribute(x_wszAttrRepair, WszFromBoolean(bRepair));

		// insert RESTORE_SUBCOMPONENTS node under COMPONENT NODE
		nodeComponent.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// signal PreRestore event to the writers
HRESULT CVssBackupComponents::InternalPreRestore()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPreRestore"
		);

	// protect state transition
	m_csState.Lock();
	LONG timestamp = InterlockedIncrement(&m_timestampOperation);

    try
		{
		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to PreRestore.",
				m_state
				);

        m_state = x_StatePreRestore;

		// setup pointer to IVssWriter event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter, false);

		CComPtr<IDispatch> pDispatch;

		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalPreRestore1");

		ft1.hr = pWriter->PreRestore(pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::PreRestore");
		if (ValidateTimestamp(timestamp))
			RebuildComponentData(ft);

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (ValidateTimestamp(timestamp))
		{
		if (ft.HrFailed())
			m_state = x_StatePreRestoreFailed;
		else
			m_state = x_StatePreRestoreSucceeded;

		FreeWriterComponents();
		m_csState.Unlock();
		}

    return ft.hr;
	}

// called by IVssAsync::Cancel if PreRestore is cancelled
HRESULT CVssBackupComponents::PostPreRestore
	(
	IN LONG timestamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPreRestore");
	if (ValidateTimestamp(timestamp))
		{
		try
			{
			RebuildComponentData(ft);
			}
		VSS_STANDARD_CATCH(ft)
		if (ft.HrFailed())
			m_state = x_StatePreRestoreFailed;
		else
			m_state = x_StatePreRestoreSucceeded;

		FreeWriterComponents();
		m_csState.Unlock();
		}

	return ft.hr;
	}


// signal PostRestore event to the writers
HRESULT CVssBackupComponents::InternalPostRestore()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPostRestore"
		);

	// protect state transition
	m_csState.Lock();
	LONG timestamp = InterlockedIncrement(&m_timestampOperation);
    try
		{
		if (m_state != x_StatePreRestoreSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to PostRestore.",
				m_state
				);

        m_state = x_StatePostRestore;

		// setup pointer to IVssWriter event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter, false);

		CComPtr<IDispatch> pDispatch;

		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalPostRestore1");

		ft1.hr = pWriter->PostRestore(pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::InternalPostRestore");
		if (ValidateTimestamp(timestamp))
			{
			RebuildComponentData(ft);
			m_state = x_StatePostRestoreSucceeded;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (ValidateTimestamp(timestamp))
		{
		if (ft.HrFailed())
			m_state = x_StatePostRestoreFailed;

		FreeWriterComponents();
		m_csState.Unlock();
		}

    return ft.hr;
	}

// called by IVssAsync::Cancel to cancel the PostRestore operation
HRESULT CVssBackupComponents::PostPostRestore
	(
	IN LONG timestamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPostRestore");

	if (ValidateTimestamp(timestamp))
		{
		try
			{
			RebuildComponentData(ft);
			m_state = x_StatePostRestoreSucceeded;
			}
		VSS_STANDARD_CATCH(ft)

		if (ft.HrFailed())
			m_state = x_StatePostRestoreFailed;

		FreeWriterComponents();
		m_csState.Unlock();
		}

	return ft.hr;
	}


// signal prerestore event to writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PreRestore(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PreRestore"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		ValidateInitialized(ft);
		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for backup");

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to PreRestore.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_PRERESTORE
						);
		}
	VSS_STANDARD_CATCH(ft)


    return ft.hr;
	}

// signal postrestore event to writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PostRestore(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PostRestore"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		ValidateInitialized(ft);
		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for backup");

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StatePreRestoreSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to PostRestore.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_POSTRESTORE
						);
		}
	VSS_STANDARD_CATCH(ft)


    return ft.hr;
	}


void CVssBackupComponents::FindAndValidateWriterData
	(
	IN VSS_ID idInstance,
	OUT UINT *piWriter
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FindAndValidateWriterData");

	// validate writer SID hasn't changed since GatherWriterMetadata
	// was called
	CInternalWriterData *pData = FindWriterData(idInstance, piWriter);
	if (pData == NULL)
		ft.Throw
			(
			VSSDBG_XML,
			E_ACCESSDENIED,
			L"Instance id was not discovered in Identify pass" WSTR_GUID_FMT,
			GUID_PRINTF_ARG(idInstance)
			);

	TOKEN_OWNER *pOwnerToken = GetClientTokenOwner(TRUE);

    if ( g_cDbgTrace.IsTracingEnabled() )
        {
		LPWSTR pwszWriterSid = NULL;
		LPWSTR pwszTokenSid = NULL;
        ::ConvertSidToStringSid( pData->m_pOwnerToken->Owner, &pwszWriterSid );
        ::ConvertSidToStringSid( pOwnerToken->Owner, &pwszTokenSid );
        ft.Trace( VSSDBG_XML, L"WriterSid: %s, TokenOwnerSid: %s",
            pwszWriterSid, pwszTokenSid );
        ::LocalFree( pwszTokenSid );
        ::LocalFree( pwszWriterSid );
        }
    
	if (!EqualSid(pData->m_pOwnerToken->Owner, pOwnerToken->Owner))
		{
		delete pOwnerToken;
        BS_ASSERT( !"Writer and token SIDs don't match" );
        
		ft.Throw
			(
			VSSDBG_XML,
			E_ACCESSDENIED,
			L"SID for instance id does not match" WSTR_GUID_FMT,
			GUID_PRINTF_ARG(idInstance)
			);
		}

	delete pOwnerToken;
	}



// get content for a specific writer
// implements IVssWriterCallback::GetContent
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the object is not found
//		VSS_E_BAD_STATE if the caller is not responding to PrepareForBackup,
//			BackupComplete, or Restore
//		E_ACCESSDENIED if the caller is responding to Restore and is not
//			and administrator or if the writer is not participating in the
//			backup or is trying to impersonate another writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetContent
	(
	IN BSTR WriterInstanceId,
	OUT BSTR *pbstrXMLDocContent
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetContent"
		);

    try
		{
		// validate and initialize output parameter
		if (pbstrXMLDocContent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXMLDocContent = NULL;

		CVssID idInstance;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);

		// test state for validity
		// don't acquire m_csState as it is acquired by the call
		// to RequestWriterData in another thread.
		if (m_state != x_StatePrepareForBackup &&
			m_state != x_StateBackupComplete &&
			m_state != x_StateDoSnapshot &&
			m_state != x_StatePreRestore &&
			m_state != x_StatePostRestore)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d to request BACKUP_COMPONENTS content",
				m_state
				);


		// for now writers that participate in restore processing must
		// have administrative privileges
		if (m_state  == x_StatePreRestore || m_state == x_StatePostRestore)
			if (!IsAdministrator())
				ft.Throw
					(
					VSSDBG_XML,
					E_ACCESSDENIED,
					L"Caller must be Administrator to do a restore."
					);


		FindAndValidateWriterData(idInstance, NULL);
		CVssSafeAutomaticLock lockDOM(m_csDOM);
        m_doc.ResetToDocument();
        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			return S_FALSE;

        // find specific WRITER_COMPONENTS element
		bool bFound = false;
		do
			{
			// get instanceId value
			CComBSTR bstrVal;

			VSS_ID idFound;

			get_VSS_IDValue(ft, x_wszAttrInstanceId, &idFound);
			if (idInstance == idFound)
				{
				bFound = true;
				break;
				}
			} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));

        if (!bFound)
			return S_FALSE;


		CXMLDocument doc(m_doc.GetCurrentNode(), m_doc.GetInterface());
		CComBSTR bstrXMLDocContent = doc.SaveAsXML();

		// a root node, schema, and supplied document
		UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXMLDocContent);

        // allocate string
        BSTR bstr = *pbstrXMLDocContent = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root> <schema>
	    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
		pwc += g_iwcComponentMetadataXMLEnd;

		// copy in document
		wcscpy(pwc, bstrXMLDocContent);
		pwc += wcslen(bstrXMLDocContent);

		// copy in </root>
		wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// replace the contents of the backup components document
// implements IVssWriterCallback::SetContent
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the writer is not reponding to PrepareForBackup
//		E_ACCESSDENIED if the writer is not participating in the current
//			backup or another writer is trying to impersonate this writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetContent
	(
	IN BSTR WriterInstanceId,
	IN BSTR bstrXMLWriterComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SetContent"
		);

    // validate state
	// don't acquire m_csState as it is acquired by the call
	if (m_state != x_StatePrepareForBackup &&
		m_state != x_StateDoSnapshot &&
		m_state != x_StatePreRestore &&
		m_state != x_StatePostRestore)
		ft.hr = VSS_E_BAD_STATE;
	else
		{
		CVssID id;
		try
			{
			id.Initialize(ft, WriterInstanceId, E_INVALIDARG);
			}
		VSS_STANDARD_CATCH(ft)

		if (SUCCEEDED(ft.hr))
			{
			if (id ==  idVolumeSnapshotService)
				ft.hr = SetSnapshotSetDescription(bstrXMLWriterComponents);
			else
				ft.hr = AddWriterData(WriterInstanceId, NULL, NULL, bstrXMLWriterComponents, false);
			}
		}


	return ft.hr;
	}




// expose state of writer in response to RequestWriterMetadata
// implements IVssWriterCallback::ExposeCurrentState
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if WriterClassId, WriterInstanceId, bstrWriterName are
//			NULL or if nCurrentState is not a valid writer state
//		E_ACCESSDENIED if the writer is not participating in the current
//			backup or is trying to impersonate another writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::ExposeCurrentState
	(
	IN BSTR WriterInstanceId,
	IN VSS_WRITER_STATE nCurrentState,
	IN HRESULT hrWriterFailure
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ExposeCurrentState");

	try
		{
		if (WriterInstanceId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (nCurrentState != VSS_WS_STABLE &&
			nCurrentState != VSS_WS_WAITING_FOR_FREEZE &&
			nCurrentState != VSS_WS_WAITING_FOR_THAW &&
			nCurrentState != VSS_WS_WAITING_FOR_BACKUP_COMPLETE &&
			nCurrentState != VSS_WS_FAILED_AT_IDENTIFY &&
			nCurrentState != VSS_WS_FAILED_AT_PREPARE_BACKUP &&
			nCurrentState != VSS_WS_FAILED_AT_PREPARE_SNAPSHOT &&
			nCurrentState != VSS_WS_FAILED_AT_FREEZE &&
			nCurrentState != VSS_WS_FAILED_AT_THAW &&
			nCurrentState != VSS_WS_WAITING_FOR_POST_SNAPSHOT &&
			nCurrentState != VSS_WS_FAILED_AT_POST_SNAPSHOT &&
			nCurrentState != VSS_WS_FAILED_AT_BACKUP_COMPLETE &&
			nCurrentState != VSS_WS_FAILED_AT_PRE_RESTORE &&
			nCurrentState != VSS_WS_FAILED_AT_POST_RESTORE)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid Writer state");


		CVssID idInstance;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);

		UINT iWriter;
		FindAndValidateWriterData(idInstance, &iWriter);
		CVssSafeAutomaticLock lock(m_csWriters);

		BS_ASSERT(iWriter < m_cWriters);
		VSS_WRITER_PROP *pProp = &m_rgWriterProp[iWriter];
		pProp->m_nState = nCurrentState;
		pProp->m_hrWriterFailure = hrWriterFailure;
		pProp->m_bResponseReceived = true;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// Called to set the context for subsequent snapshot-related operations
STDMETHODIMP CVssBackupComponents::SetContext
	(
    IN LONG lContext
    )
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetContext");

	try
		{
        // In Whistler Server we will support only this
        if (lContext != VSS_CTX_BACKUP)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid context 0x%08lx", lContext);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to SetContext in state %d.",
				m_state
				);

		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->SetContext(lContext);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
    }
    

// start snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pSnapshotSetId is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_SNAPSHOT_SET_IN_PROGRESS if a snapshot set is already started.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::StartSnapshotSet
	(
	OUT VSS_ID *pSnapshotSetId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::StartSnapshotSet");

	try
		{
		if (pSnapshotSetId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		*pSnapshotSetId = GUID_NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to StartSnapshotSet in state %d.",
				m_state
				);

		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->StartSnapshotSet(pSnapshotSetId);
		if (!ft.HrFailed())
			{
			m_bstrSnapshotSetId = *pSnapshotSetId;
			if (m_bstrSnapshotSetId.Length() == 0)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate BSTR.");

			m_state = x_StateSnapshotSetCreated;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// internal routine to setup the coordinator
// note that the m_csState critical section should be acquired
// before calling this routine.  Access to this routine must be
// single threaded
void CVssBackupComponents::SetupCoordinator(IN CVssFunctionTracer &ft)
	{
	if (m_pCoordinator)
		return;

    ft.LogVssStartupAttempt();
	ft.hr = CoCreateInstance
				(
				CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssCoordinator,
				(void **) &m_pCoordinator
			    );

    ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");
    }

// add a volume to a snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//		E_INVALIDARG if ppSnapshot is NULL

STDMETHODIMP CVssBackupComponents::AddToSnapshotSet
	(							
	IN VSS_PWSZ	pwszVolumeName, 			
	IN VSS_ID		ProviderId, 				
	OUT VSS_ID		*pSnapshotId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddToSnapshot");

	try
		{
		if (pSnapshotId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pSnapshotId = GUID_NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateSnapshotSetCreated)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call AddToSnapshotSet at this point");

		BS_ASSERT(m_pCoordinator);
		ft.hr = m_pCoordinator->AddToSnapshotSet
						(
						pwszVolumeName,
						ProviderId,
						pSnapshotId
						);

        }
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
						
// create the snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized,
//			if called during restore, or if not called after PrepareForBackup
//			was successful.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::DoSnapshotSet
	(								
	OUT IVssAsync** ppAsync 					
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DoSnapshotSet");

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Output parameter.");

		*ppAsync = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateSnapshotSetCreated &&
			m_state != x_StatePrepareForBackupSucceeded)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call DoSnapshotSet at this point.");

        // Execute DoSnapshotSet
		m_state = x_StateDoSnapshot;
		BS_ASSERT(m_pCoordinator);
		ft.hr = m_pCoordinator->SetWriterInstances(m_cWriterInstances, m_rgWriterInstances);
		if (SUCCEEDED(ft.hr))
			{
			CComPtr<IDispatch> pDispatch;
			GetCallbackInterface(ft, &pDispatch);

			CComPtr<IVssAsync> ptrAsyncInternal;
			ft.hr = m_pCoordinator->DoSnapshotSet(pDispatch, &ptrAsyncInternal);

			// create cover async object
			CVssAsyncCover::CreateInstance(this, ptrAsyncInternal, ppAsync);
			}
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{
		AbortBackup();
		m_state = x_StateDoSnapshotFailed;
		}


	return ft.hr;
	}


// delete snapshots
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if eSourceObjectType is invalid, plDeletedSnapshots is
//			NULL, or pNonDeletedSnapshotID is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_OBJECT_NOT_FOUND if the specified snapshot doesn't exist.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::DeleteSnapshots
	(							
	IN VSS_ID			SourceObjectId, 		
	IN VSS_OBJECT_TYPE 	eSourceObjectType,		
	IN BOOL				bForceDelete,			
	OUT LONG*			plDeletedSnapshots,		
	OUT VSS_ID*			pNonDeletedSnapshotID	
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DeleteSnapshots");
	try
		{
		VssZeroOut(plDeletedSnapshots);
		VssZeroOut(pNonDeletedSnapshotID);
		if (plDeletedSnapshots == NULL || pNonDeletedSnapshotID == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Null output parameter"
				);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->DeleteSnapshots
			(
			SourceObjectId, 		
			eSourceObjectType,		
			bForceDelete,			
			plDeletedSnapshots,		
			pNonDeletedSnapshotID
			);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// query for either snapshot sets, snapshots, or providers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if eQueriedObjectType is invalid, eReturnedObjectsType
//			is invalid or ppEnum is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_OBJECT_NOT_FOUND if the queried object doesn't exist.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssBackupComponents::Query
	(										
	IN VSS_ID			QueriedObjectId,		
	IN VSS_OBJECT_TYPE eQueriedObjectType, 	
	IN VSS_OBJECT_TYPE eReturnedObjectsType,	
	OUT IVssEnumObject **ppEnum 				
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::Query");
	try
		{
		// validate and clear output parameter
		if (ppEnum == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppEnum = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->Query
			(
			QueriedObjectId,		
			eQueriedObjectType, 	
			eReturnedObjectsType,	
			ppEnum
			);

		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// Remount the snapshot as read-write
STDMETHODIMP CVssBackupComponents::RemountReadWrite
	(
	IN VSS_ID SnapshotId,
	OUT IVssAsync**		pAsync
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::RemountReadWrite");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(pAsync);
}


// Break the snapshot set
STDMETHODIMP CVssBackupComponents::BreakSnapshotSet
	(
	IN VSS_ID			SnapshotSetId
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::BreakSnapshotSet");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotSetId);
}


// Import snapshots
STDMETHODIMP CVssBackupComponents::ImportSnapshots
	(
	OUT IVssAsync**		ppAsync
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ImportSnapshots");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(ppAsync);
}


// get interface to snapshot
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppSnap is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_NOT_FOUND if the snapshot id is invalid
//		E_NOINTERFACE if the SnapshotInterfaceId is not valid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetSnapshotProperties
	(								
	IN VSS_ID		SnapshotId, 			
	OUT VSS_SNAPSHOT_PROP	*pProp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::GetSnapshotProperties");

	try
		{
		if (pProp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		::VssZeroOut(pProp);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->GetSnapshotProperties
					(
					SnapshotId,
					pProp
					);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// gather writer metadata
//
// Returns:
//		S_OK if the operation is successful.
//		E_INVAIDARG if pcWriters is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized,
//			if called during a restore operation or if called while
//			PrepareForBackup is in progress.
//		E_OUTOFMEMORY if an allocation failure occurs.

STDMETHODIMP CVssBackupComponents::GatherWriterMetadata
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GatherWriterMetadata"
		);

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

		*ppAsync = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		*ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_GATHER_WRITER_METADATA
			);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of writers supplying metadata
//
// Returns:
//     VSS_E_BAD_STATE: if called when GatherWriterMetadata was not called or is in progress
//	   E_INVALIDARG: if pcWriters is NULL
//
STDMETHODIMP CVssBackupComponents::GetWriterMetadataCount
	(
	OUT UINT *pcWriters
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterMetadataCount"
		);

	try
		{
		if (pcWriters == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pcWriters = NULL;

		if (!m_bGatherWriterMetadataComplete)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Gather writer metadata is not complete");

		*pcWriters = m_cWriters;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// internal routine to gather writer metadata
// Returns:
//	   S_OK: if there are no errors.
//	   VSS_E_WRITER_INFRASTRUCTURE: either the service state or bootable state
//			writer did not respond.
//	   E_UNEXPECTED: for an unexpected error
//	   E_OUTOFMEMORY: for out of resources
//

HRESULT CVssBackupComponents::InternalGatherWriterMetadata()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalGatherWriterMetadata"
		);

	// acquire critical section to change state
	m_csState.Lock();
	VSS_BACKUPCALL_STATE stateSaved = m_state;
	LONG timestamp = InterlockedIncrement(&m_timestampOperation);
	bool bLocked = true;
	try
		{
		if (m_state == x_StatePrepareForBackup)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can't call this function while PrepareForBackup is in progress");

		m_state = x_StateGatheringWriterMetadata;

		// free existing writer data
		FreeAllWriters();

    	// start VSS service since it contains the MSDE Writer
		CComPtr<IVssCoordinator> pCoordinator;

        ft.LogVssStartupAttempt();
       	ft.hr = CoCreateInstance
				(
				CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssCoordinator,
				(void **) &pCoordinator
			    );

		ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

		CComPtr <IVssShim> pShim;
		// query interface for IVssShim interface
		ft.hr = pCoordinator->QueryInterface(IID_IVssShim, (void **) &pShim);
		if (ft.HrFailed())
			{
			BS_ASSERT(FALSE && "QI shouldn't fail");
			ft.LogError(VSS_ERROR_QI_IVSSSHIM_FAILED, VSSDBG_XML << ft.hr);
			ft.Throw
				(
                VSSDBG_XML,
				E_UNEXPECTED,
				L"QueryInterface failed.  hr = 0x%08lx", ft.hr
				);
			}

		// wait for subscriptions to complete
		ft.hr = pShim->WaitForSubscribingCompletion();
		if (ft.HrFailed())
			throw (HRESULT) (ft.hr);


		CComPtr<IVssWriter>pWriter;
		SetupWriter(ft, &pWriter, true);


        CComPtr<IUnknown> pUnknown = GetUnknown();
		CComPtr<IDispatch> pDispatch;
		ft.hr = pUnknown->SafeQI(IDispatch, &pDispatch);
		BS_ASSERT(!ft.HrFailed());
		if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_XML << ft.hr);
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"Error querying the IDispatch interface.  hr = 0x%08lx",
				ft.hr
				);
            }

		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalGatherWriterMetadata1");
        ft1.hr = pWriter->RequestWriterInfo(NULL, true, false, pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::RequestWriterInfo, GatherWriterMetadata");
		if (!ft.HrFailed())
			{
			ft.hr = PostGatherWriterMetadata(timestamp, stateSaved);
			bLocked = false;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (bLocked && ValidateTimestamp(timestamp))
		{
		// restore state to what it was upon entry to this routine.
		m_state = stateSaved;
		m_csState.Unlock();
		}

	return ft.hr;
	}

// called if InternalGatherWriterMetadata is successful or if
// IVssAsync::Cancel is called to cancel gathering writer metadata
HRESULT CVssBackupComponents::PostGatherWriterMetadata
	(
	IN LONG timestamp,
	IN VSS_BACKUPCALL_STATE stateSaved
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostGatherWriterMetadata");

	if (ValidateTimestamp(timestamp))
		{
		try
			{
			bool fFoundBootableStateWriter = false;
			bool fFoundSystemServiceWriter = false;

			m_rgWriterInstances = new VSS_ID[m_cWriters];
			if (m_rgWriterInstances == NULL)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Can't allocate writer instance array");


			m_cWriterInstances = m_cWriters;
			CInternalWriterData *pData = m_pDataFirst;
			
			for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
				{
				if (pData->m_idWriter == idWriterBootableState)
					fFoundBootableStateWriter = true;

				if (pData->m_idWriter == idWriterServiceState)
					fFoundSystemServiceWriter = true;

				// save instance of writer
				m_rgWriterInstances[iWriter] = pData->m_idInstance;
				pData = pData->m_pDataNext;
				}

			// check that both the service state and bootable state writer
			// responded.  If not there is an error.
			if ((!fFoundBootableStateWriter && !IsWriterClassDisabled(idWriterBootableState)) ||
				(!fFoundSystemServiceWriter && !IsWriterClassDisabled(idWriterServiceState)))
				{
				ft.hr = VSS_E_WRITER_INFRASTRUCTURE;
				ft.LogError(VSS_ERROR_WRITER_INFRASTRUCTURE, VSSDBG_XML);
				}
	
			if (!ft.HrFailed())
				m_bGatherWriterMetadataComplete = true;
			}
		VSS_STANDARD_CATCH(ft)

		m_state = stateSaved;
		m_csState.Unlock();
		}

	return ft.hr;
	}

// internal routine to add data to the writer data queue
HRESULT CVssBackupComponents::AddWriterData
	(
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR bstrWriterXMLDocument,
	IN bool bReinitializing
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddWriterData");

	TOKEN_OWNER *pOwnerToken = GetClientTokenOwner(TRUE);
	try
		{
		CVssID idInstance, idWriter;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);
		if (bReinitializing)
			{
			idWriter.Initialize(ft, WriterClassId, E_INVALIDARG);
			if (bstrWriterName == NULL)
				ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Required input parameter.");
			}

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);

		// caller must be backup operator or
		if (bReinitializing)
			{
			if (FindWriterData(idInstance))
				{
				ft.LogError(VSS_ERROR_DUPLICATE_WRITERS, VSSDBG_XML << idInstance);
				ft.Throw
					(
					VSSDBG_XML,
					E_UNEXPECTED,
					L"Two writers with identical instance ids. %s",
					WriterInstanceId
					);
                }

			CInternalWriterData *pData = new CInternalWriterData();
			if (pData == NULL)
				ft.Throw
					(
					VSSDBG_XML,
					E_OUTOFMEMORY,
					L"Cannot create CInternalWriterMetadata because of allocation failure"
					);

			pData->Initialize
				(
				idInstance,
				idWriter,
			    bstrWriterName,
				bstrWriterXMLDocument,
				pOwnerToken
				);

			pOwnerToken = NULL;
			pData->m_pDataNext = m_pDataFirst;
			m_pDataFirst = pData;
			m_cWriters++;
			}
		else
			{
			CInternalWriterData *pData = FindWriterData(idInstance);
			if (pData == NULL)
				ft.Throw
					(
					VSSDBG_GEN,
					E_ACCESSDENIED,
					L"Didn't find writer with instance id. %s",
					WriterInstanceId
					);

            if (!EqualSid(pData->m_pOwnerToken->Owner, pOwnerToken->Owner))
				ft.Throw
					(
					VSSDBG_XML,
					E_ACCESSDENIED,
					L"SID didn't match initialization sid"
					);

			BS_ASSERT(!pData->m_bstrWriterComponents);
			pData->SetComponents(bstrWriterXMLDocument);
			}
		}
	VSS_STANDARD_CATCH(ft)

	delete pOwnerToken;

	return ft.hr;
	}


// a single writer exposing its data
// implements IVssWriterCallback::ExposeWriterMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the oepration is not in response to
//			a GatherWriterMetadata call (called in OnIdentify)
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::ExposeWriterMetadata
	(
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR bstrWriterXMLMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::ExposeWriterMetadata"
		);

    // note that the state is already locked by another thread holding
	// performing RequestWriterInfo.
	if (m_state != x_StateGatheringWriterMetadata)
		ft.hr = VSS_E_BAD_STATE;
	else
		// add data to writers list
		ft.hr = AddWriterData
			(
			WriterInstanceId,
			WriterClassId,
			bstrWriterName,
			bstrWriterXMLMetadata,
			true
			);

	return ft.hr;
	}
		
// get metadata for a specific writer
// implements IVssBackupComponents::GetWriterMetadata
// caller is responsible for calling IVssExineWriterMetadata::Release on the returned object
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pidInstance or ppMetadata is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//			or this is performed during a RESTORE operation
//		VSS_E_OBJECT_NOT_FOUND if iWriter does not refer to a writer
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document from the writer is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterMetadata
	(
	IN UINT iWriter,
	OUT VSS_ID *pidInstance,
	OUT IVssExamineWriterMetadata **ppMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterMetadata"
		);

	CVssExamineWriterMetadata *pvem = NULL;
    try
		{
		if (pidInstance == NULL || ppMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters to null
		*pidInstance = GUID_NULL;
		*ppMetadata = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		// protect writer information list
		CVssSafeAutomaticLock lock(m_csWriters);

		// check that writer # is within range
		if (iWriter > m_cWriters)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"iWriter %d > # of writers(%d)",
				iWriter,
				m_cWriters
				);

		// find specific element in list
        CInternalWriterData *pMetadata = m_pDataFirst;
		for(UINT i = 0; i < iWriter; i++)
			{
			BS_ASSERT(pMetadata != NULL);
			pMetadata = pMetadata->m_pDataNext;
			}

		BS_ASSERT(pMetadata != NULL);

		// allocate object
		pvem = new CVssExamineWriterMetadata;

		// check for allocation failure
		if (pvem == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssExamineWriterMetadata due to allocation failure."
				);

        // 2nd phases of construction
        if (!pvem->Initialize(pMetadata->m_bstrWriterMetadata))
			{
			ft.LogError(VSS_ERROR_INVALID_XML_DOCUMENT_FROM_WRITER, VSSDBG_XML << pMetadata->m_idInstance);
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_CORRUPT_XML_DOCUMENT,
				L"Metadata supplied by writer {%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x} is invalid.",
				GUID_PRINTF_ARG(pMetadata->m_idInstance)
				);
            }

        // return instanceId
        *pidInstance = pMetadata->m_idInstance;

		// return IVssExamineWriterMetadata interface
		*ppMetadata = (IVssExamineWriterMetadata *) pvem;

		// set reference count to 1
		pvem->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	// delete object if failure after allocation
	if (ft.HrFailed())
		delete pvem;

	return ft.hr;
	}

// free writer metadata
// implements IVssBackupComponents::FreeWriterMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//			or if this is a Restore operation

STDMETHODIMP CVssBackupComponents::FreeWriterMetadata()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterMetadata");

	try
		{
		// validate that the object is initialized
		ValidateInitialized(ft);

		// secure writer list data structure
		CVssSafeAutomaticLock lock(m_csWriters);

		// loop through linked elements deleting each one
		CInternalWriterData *pMetadata;
		UINT iWriter = 0;
		for (pMetadata = m_pDataFirst; iWriter < m_cWriters; iWriter++)
			{
			BS_ASSERT(pMetadata != NULL);

			// free up bstring
			pMetadata->m_bstrWriterMetadata.Empty();
			pMetadata = pMetadata->m_pDataNext;
			}
		}
	VSS_STANDARD_CATCH(ft)

	m_bGatherWriterMetadataComplete = false;
	return ft.hr;
	}


// free component metadata, i.e., writer components associated with
// each writer in the backup
void CVssBackupComponents::FreeWriterComponents()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterMetadata");

	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	try
		{
		// loop through linked elements deleting each one
		CInternalWriterData *pMetadata;
		UINT iWriter = 0;
		for (pMetadata = m_pDataFirst; iWriter < m_cWriters; iWriter++)
			{
			BS_ASSERT(pMetadata != NULL);

			// free up bstring
			pMetadata->m_bstrWriterComponents.Empty();
			pMetadata = pMetadata->m_pDataNext;
			}
		}
	VSS_STANDARD_CATCH(ft)
	}





// free up writer metadata
// internal routine called during GatherWriterMetadata
void CVssBackupComponents::FreeAllWriters()
	{
	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	// loop through linked elements deleting each one
	CInternalWriterData *pMetadata, *pMetadataNext;
	for (pMetadata = m_pDataFirst; m_cWriters > 0; m_cWriters--)
		{
		BS_ASSERT(pMetadata != NULL);
		pMetadataNext = pMetadata->m_pDataNext;
		delete pMetadata;
		pMetadata = pMetadataNext;
		}

	// clear head of list
	m_pDataFirst = NULL;
	}

// find writer data for a writer with a specific instance id
CInternalWriterData *CVssBackupComponents::FindWriterData
	(
	VSS_ID idInstance,
	UINT *piWriter
	)
	{
	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	// loop through linked elements deleting each one
	CInternalWriterData *pMetadata;
	UINT iWriter = 0;
	for (pMetadata = m_pDataFirst; iWriter < m_cWriters ; iWriter++)
		{
		BS_ASSERT(pMetadata != NULL);
		if (pMetadata->m_idInstance == idInstance)
			{
			if (piWriter)
				*piWriter = iWriter;

			return pMetadata;
			}

		pMetadata = pMetadata->m_pDataNext;
		}

	return NULL;
	}



// get count of WRITER_COMPONENTS elements in a BACKUP_COMPONENTS document
// implements IVssBackupComponents::GetWriterComponentsCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		VSS_E_BAD_STATE if the backup components document is not initialized
//	    E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterComponentsCount
	(
	OUT UINT *pcComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetWriterComponentsCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;

		// validate that the object is initialized
		ValidateInitialized(ft);


		CVssSafeAutomaticLock lock(m_csDOM);
		// reposition to top of document
		m_doc.ResetToDocument();

        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			return S_OK;

		UINT cComponents = 0;
        // count WRITER_COMPONENTS elements
		do
			{
			cComponents++;
			} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));

		*pcComponents = cComponents;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain a specific WRITER_COMPONENTS element
// implements IVssBackupComponents::GetWriterComponents
// caller is responsible for calling IVssWriterComponents::Release
// on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppWriter is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified component is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterComponents
	(
	IN UINT iWriter,
	OUT IVssWriterComponentsExt **ppWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponentsDoc::GetWriterComponents"
		);

	// object deleted in case of failure
    CVssWriterComponents *pWriterComponents = NULL;
	try
		{
		// validate output parameter
		if (ppWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*ppWriter = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		// obtain lock to protect access to DOM document
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
		m_doc.ResetToDocument();

        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Couldn't find %d WRITER_COMPONENT.",
				iWriter
				);

        // skip to selected WRITER_COMPONENTS element
        for(UINT i = 0; i < iWriter; i++)
			{
			if (!m_doc.FindElement(x_wszElementWriterComponents, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Couldn't find %d WRITER_COMPONENT.",
					iWriter
					);
            }

		// allocate CVssWriterComponents object
	    pWriterComponents = new CVssWriterComponents
								(
								m_doc.GetCurrentNode(),
								m_doc.GetInterface(),
								false,
								true,
								m_bRestore
								);

		// validate that memory allocation succeeded
		if (pWriterComponents == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssWriterComponents due to allocation failure."
				);

        // 2nd phase of initialization
        pWriterComponents->Initialize(false);

		// transfer ownership of pointer
        *ppWriter = (IVssWriterComponentsExt *) pWriterComponents;

		// set reference count to 1
        ((IVssWriterComponentsExt *) pWriterComponents)->AddRef();

		// transfer ownership to output pointer
		pWriterComponents = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	// delete object if failure after allocation
	delete pWriterComponents;

	return ft.hr;
	}

// Called by the requestor to check if a certain volume is supported.
STDMETHODIMP CVssBackupComponents::IsVolumeSupported
	(										
	IN VSS_ID ProviderId,		
	IN VSS_PWSZ pwszVolumeName,
	IN BOOL * pbSupportedByThisProvider
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::IsVolumeSupported");

	try
		{
		if (pbSupportedByThisProvider == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pbSupportedByThisProvider = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->IsVolumeSupported
			(
			ProviderId,		
			pwszVolumeName, 	
			pbSupportedByThisProvider
			);

        }
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add a writer class to the writer class array
void CVssBackupComponents::AddWriterClass(const VSS_ID &id)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddWriterClass");

	bool fFound = false;

	// see if writer class is already in list
	for(UINT iClass = 0; iClass < m_cWriterClasses; iClass++)
		{
		if (m_rgWriterClasses[iClass] == id)
			{
			fFound = true;
			break;
			}
		}

	// add it to the list if not already there
	if (!fFound)
		{
		// allocate new class array
		VSS_ID *rgWriterClasses = new VSS_ID[1 + m_cWriterClasses];
		if (rgWriterClasses == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Can't allocate writer class array");

		// copy in existing array
		memcpy(rgWriterClasses, m_rgWriterClasses, m_cWriterClasses * sizeof(VSS_ID));

		// add new class
		rgWriterClasses[m_cWriterClasses] = id;

		// delete original array
		delete m_rgWriterClasses;

		// replace original array with new array
		m_rgWriterClasses = rgWriterClasses;
		m_cWriterClasses += 1;
		}
	}

// remove a writer class from the set of writer classes
void CVssBackupComponents::RemoveWriterClass(const VSS_ID &id)
	{
	// search for class and remov it
	for(UINT iClass = 0; iClass < m_cWriterClasses; iClass++)
		{
		if (m_rgWriterClasses[iClass] == id)
			{
			// class is found, remove it.
			memmove
				(
				&m_rgWriterClasses[iClass],
				&m_rgWriterClasses[iClass + 1],
				(m_cWriterClasses - iClass - 1) * sizeof(VSS_ID)
				);

			m_cWriterClasses--;
			break;
			}
		}
	}


// called by the requestor to disable requesting of writer metadata from
// specific writer classes.  Note that this does not effect other writer
// events.
STDMETHODIMP CVssBackupComponents::DisableWriterClasses
	(
	IN const VSS_ID *rgWriterClassId,
	IN UINT cClassId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DisableWriterClass");

	try
		{
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);

		if (m_bIncludeWriterClasses)
			{
			// we are enabling specific writer classes.  Remove class from
			// array.
			for(UINT iClassId = 0; iClassId < cClassId; iClassId++)
				RemoveWriterClass(rgWriterClassId[iClassId]);
			}
		else
			{
			// we ar disabling writer classes.  Add new writer classes to
			// array.
			for(UINT iClassId = 0; iClassId < cClassId; iClassId++)
				AddWriterClass(rgWriterClassId[iClassId]);
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// called by the requestore to enable requesting of writer metadata from
// only specific writer classes.  Note that once this method is called
// only enabled classes are called.
STDMETHODIMP CVssBackupComponents::EnableWriterClasses
	(
	IN const VSS_ID *rgWriterClasses,
	IN UINT cWriterClasses
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::EnableWriterClasses");

	try
		{
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);
		if (m_bIncludeWriterClasses)
			{
			// we are already only enabling specific writers.  Add writers
			// specified in the call
			for(UINT iClass = 0; iClass < cWriterClasses; iClass++)
				AddWriterClass(rgWriterClasses[iClass]);
			}
		else
			{
			// we are switching from disabling writers to enabling writers.
			// delete current array
			delete m_rgWriterClasses;
			m_cWriterClasses = 0;

			m_bIncludeWriterClasses = true;

			// create array if not empty
			if (cWriterClasses > 0)
				{
				m_rgWriterClasses = new VSS_ID[cWriterClasses];
				if (m_rgWriterClasses == NULL)
					ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate writer class array");

				// copy enabled classes into array
				memcpy(m_rgWriterClasses, rgWriterClasses, cWriterClasses * sizeof(VSS_ID));
				}

			// size of writer class array
			m_cWriterClasses = cWriterClasses;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



// disable a specific writer instance, only meaningful after GatherWriterMetadata
// has been issued.
STDMETHODIMP CVssBackupComponents::DisableWriterInstances
	(
	IN const VSS_ID *rgWriterInstanceId,
	IN UINT cInstanceId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DisableWriterInstances");

	try
		{
		ValidateInitialized(ft);

		// lock arrays
		CVssSafeAutomaticLock lock(m_csWriters);

		// remove specified writers from the writer instances array
		for(UINT iInstanceId = 0; iInstanceId < cInstanceId; iInstanceId++)
			{
			VSS_ID WriterInstanceId = rgWriterInstanceId[iInstanceId];

			// search for instance id
			for(UINT iInstance = 0; iInstance < m_cWriterInstances; iInstance++)
				{
				if (m_rgWriterInstances[iInstance] == WriterInstanceId)
					{
					// remove instance
					memmove
						(
						&m_rgWriterInstances[iInstance],
						&m_rgWriterInstances[iInstance + 1],
						(m_cWriterInstances - iInstance - 1) * sizeof(VSS_ID)
						);

					m_cWriterInstances--;
					break;
					}
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// is a writer class disabled
bool CVssBackupComponents::IsWriterClassDisabled(const VSS_ID &id)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::IsWriterClassDisabled");

	CVssSafeAutomaticLock lock(m_csWriters);

	// see if writer class is in writer class array
	for(UINT iClass = 0; iClass < m_cWriterClasses; iClass++)
		{
		if (id == m_rgWriterClasses[iClass])
			// writer is found.  if we are only enabling specific classes then
			// enabled, return false.  If we are disabling specific writer
			// classes then writer is disabled, return true.
			return !m_bIncludeWriterClasses;
		}

	// writer not in array.  If we are enabling specific writer classes then
	// return false.  If disabling specific classes then writer is enabled
	// so return false.
	return m_bIncludeWriterClasses;
	}

// is a writer instance disabled
bool CVssBackupComponents::IsWriterInstanceDisabled(const VSS_ID &id)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::IsWriterInstanceDisabled");

	// see if writer instance is in writer instance array
	CVssSafeAutomaticLock lock(m_csWriters);

	for(UINT iInstance = 0; iInstance < m_cWriterInstances; iInstance++)
		{
		if (m_rgWriterInstances[iInstance] == id)
			return false;
		}

	return true;
	}



// determine the set of writers that appear in the backup components document
// and limit event firing to those writer instances
void CVssBackupComponents::TrimWriters()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::TrimWriters");

		{
		// acquire lock on backup components document
		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();

		bool bSelectComponents;
		// get selectComponents attribute value
		if (!get_boolValue(ft, x_wszAttrSelectComponents, &bSelectComponents))
			MissingAttribute(ft, x_wszAttrSelectComponents);

		// if not selecting components, then all writers should be called
		if (!bSelectComponents)
			return;
		}

	// create array of writer instances found
	UINT cWriterInstancesMax = m_cWriterInstances;
	VSS_ID *rgWriterInstances = new VSS_ID[cWriterInstancesMax];
	UINT cWriterInstances = 0;


		{
		// get lock on document
		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();
	
		// find first WRITER_COMPONENTS element
		if (m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			{
			do
				{
				// get instanceId value
				CComBSTR bstrVal;

				VSS_ID idFound;

				get_VSS_IDValue(ft, x_wszAttrInstanceId, &idFound);
				if (cWriterInstances >= cWriterInstancesMax)
					{
					// grow writer instance array
					VSS_ID *rgWriterInstancesT = new VSS_ID[cWriterInstances + 1];
					memcpy(rgWriterInstancesT, rgWriterInstances, cWriterInstances * sizeof(VSS_ID));
					delete rgWriterInstances;
                    rgWriterInstances = rgWriterInstancesT;
					}
				
				rgWriterInstances[cWriterInstances++] = idFound;
				} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));
			}
		}

	// trim writers not found in writer instance array
	CVssSafeAutomaticLock lock(m_csWriters);

	for(UINT iWriterS = 0, iWriterD = 0; iWriterS < m_cWriterInstances; iWriterS++)
		{
		VSS_ID idInstance = m_rgWriterInstances[iWriterS];

		for(UINT iWriterF = 0; iWriterF < cWriterInstances; iWriterF++)
			{
			if (idInstance == rgWriterInstances[iWriterF])
				{
				m_rgWriterInstances[iWriterD++] = idInstance;
				break;
				}
			}
		}

	m_cWriterInstances = iWriterD;

	// delete temporary writer instance array
	delete rgWriterInstances;
	}



// add a snapshot set description to the backup components document
HRESULT CVssBackupComponents::SetSnapshotSetDescription(LPCWSTR wszXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetSnapshotSetDescription");

	CComPtr<IVssSnapshotSetDescription> pSnapshotSet;

	try
		{
		if (!IsAdministrator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Only Volume snapshot service can set snapshot set description.");


		ft.hr = LoadVssSnapshotSetDescription(wszXML, &pSnapshotSet);
		if (ft.HrFailed())
			ft.Throw(VSSDBG_XML, ft.hr, L"Rethrow");

		CComPtr<IXMLDOMNode> pNode;
		CComPtr<IXMLDOMDocument> pDoc;

		ft.hr = pSnapshotSet->GetToplevelNode(&pNode, &pDoc);
		if (ft.HrFailed())
			ft.Throw(VSSDBG_XML, ft.hr, L"Rethrow");

		CXMLNode nodeSnapshotSet(pNode, pDoc);
		CVssSafeAutomaticLock lock(m_csDOM);
		m_doc.ResetToDocument();
		CXMLNode nodeBackupComponents(m_doc.GetCurrentNode(), m_doc.GetInterface());
		nodeBackupComponents.InsertNode(nodeSnapshotSet);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// called to expose a snapshot 
STDMETHODIMP CVssBackupComponents::ExposeSnapshot
	(
    IN VSS_ID SnapshotId,
    IN VSS_PWSZ wszPathFromRoot,
    IN LONG lAttributes,
    IN VSS_PWSZ wszExpose,
    OUT VSS_PWSZ *pwszExposed
    )
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ExposeSnapshot");

	try
		{
		::VssZeroOut(pwszExposed);
		if (pwszExposed == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->ExposeSnapshot
					(
                    SnapshotId,
                    wszPathFromRoot,
                    lAttributes,
                    wszExpose,
                    pwszExposed
					);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\globals.cpp ===
//
// globals.cpp : define all the stinking global vars :(
//



#pragma warning (disable: 4268)
#include <stdafx.hxx>

#define DBINITCONSTANTS
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\async.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async.cxx | Implementation of CVssAsync object
    @end

Author:

    Adi Oltean  [aoltean]  10/05/1999

Revision History:

    Name        Date        Comments
    aoltean     10/05/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "provmgr.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "async.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORASYNC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssAsync


CVssAsync::CVssAsync():
	m_pSnapshotSet(NULL),
	m_hrState(S_OK)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::CVssAsync" );
}


CVssAsync::~CVssAsync()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::~CVssAsync" );
}


IVssAsync* CVssAsync::CreateInstanceAndStartJob(
	IN	CVssSnapshotSetObject*	pSnapshotSetObject
	)

/*++

Routine Description:

    Static method that creates a new instance of the Async interface and
    starts a background thread that runs the CVssAsync::OnRun.

Arguments:

    CVssSnapshotSetObject*	pSnapshotSetObject, - the snapshot set object given as parameter.

Throw values:

    E_OUTOFMEMORY
        - On CComObject<CVssAsync>::CreateInstance failure
        - On PrepareJob failure
        - On StartJob failure

    E_UNEXPECTED
        - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    // Allocate the COM object.
    CComObject<CVssAsync>* pObject;
    ft.hr = CComObject<CVssAsync>::CreateInstance(&pObject);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr);
    BS_ASSERT(pObject);

	// Setting async object internal data
	BS_ASSERT(pSnapshotSetObject);
	
	// AddRef is called - since the CVssAsync keeps a smart pointer.
    pObject->m_pSnapshotSet = pSnapshotSetObject;

    // Querying the IVssSnapshot interface. Now the ref count becomes 1.
    CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
    BS_ASSERT(pUnknown);
    ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
    if ( ft.HrFailed() ) {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error querying the IVssAsync interface. hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pAsync);

	// Prepare job (thread created in resume state)
	ft.hr = pObject->PrepareJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job. hr = 0x%08lx", ft.hr);

	// Start job (now the background thread will start running).
	ft.hr = pObject->StartJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job. hr = 0x%08lx", ft.hr);

    // The reference count becomes 3 since we keep a reference for the background thread.

    // Right now the background thread is running. This thread will perform a Release when finishes.
    // This will keep the async object alive until the thread finishes.
    // But, we cannot put an AddRef in the OnInit/OnRun on the background thread,
    // (since in this thread we might
    // call all subsequent releases without giving a chance to the other thread to do an AddRef)
    // Also we cannot put an AddRef at creation since we didn't know at that time if the background
    // thread will run.
    // Therefore we must do the AddRef right here.
    // Beware, this AddRef is paired with an Release in the CVssAsync::OnFinish method:
    // Note: we are sure that we cannot reach reference count zero since the thread is surely running,
    //
    IUnknown* pUnknownTmp = pObject->GetUnknown();
    pUnknownTmp->AddRef();

	// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
    // The ref count goes back to 2

	return pAsync.Detach();	  // The ref count remains 2.
}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


bool CVssAsync::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnInit" );

	if (m_pSnapshotSet != NULL)
	{
		// Setting snapshot set internal data
		BS_ASSERT(m_hrState == S_OK);
		m_hrState = VSS_S_ASYNC_PENDING;

		// Setting snapshot set internal data
		BS_ASSERT(!m_pSnapshotSet->m_bCancel);
		m_pSnapshotSet->m_bCancel = false;
    }

	return (m_pSnapshotSet != NULL);
}


void CVssAsync::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnRun" );

	try
	{
		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
				L"Snapshot set object not yet created.");
		}

		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// Call StartSnapshotSet on the given object.
		ft.hr = m_pSnapshotSet->DoSnapshotSet();
		if (ft.hr != S_OK)
		{
			ft.Trace( VSSDBG_COORD,
					  L"Internal DoSnapshotSet failed. 0x%08lx", ft.hr);
			
			// Put the error code into the
			BS_ASSERT(m_hrState == VSS_S_ASYNC_PENDING);
			m_hrState = ft.hr;
		}

		// Now m_hrState may be VSS_S_ASYNC_CANCELLED
	}
	VSS_STANDARD_CATCH(ft)
}


void CVssAsync::OnFinish()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnFinish" );

    try
    {
		if (m_pSnapshotSet)
		{
			if ( m_hrState == VSS_S_ASYNC_PENDING)
				m_hrState = VSS_S_ASYNC_FINISHED;
			// Else keep the m_hrState error code...
			// It may be VSS_S_ASYNC_CANCELLED, if CVssSnapshotSetObject::TestIfCancelNeeded was called.
		}
		else
			BS_ASSERT(false);

        // Release the background thread reference to this object.
		// Note: We kept an reference around for the time when the backgropund thread is running.
        // In this way we avoid the destruction of the async interface while the
        // background thread is running.
        // The paired addref was done after a sucessful StartJob

        // Mark the thread object as "finished"
        MarkAsFinished();

        // We release the interface only if StartJob was returned with success
        IUnknown* pMyself = GetUnknown();
        pMyself->Release();
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssAsync::OnTerminate()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnTerminate" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssAsync::Cancel()

/*++

Routine Description:

    Cancels the current running process, if any.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::Cancel" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pSnapshotSet == NULL) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");
		}

		// If thread is already finished, return correct code.
		if ((m_hrState == VSS_S_ASYNC_FINISHED) || (m_hrState == VSS_S_ASYNC_CANCELLED))
			ft.hr = m_hrState;
		else	// Otherwise, inform the thread that it must cancel. The function returns immediately.
			m_pSnapshotSet->m_bCancel = true;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssAsync::Wait()

/*++

Routine Description:

    Waits until the process gets finished.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.
        - Thread handle is invalid. Code bug, no logging.
        - WaitForSingleObject failed. Code bug, no logging.

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::Wait" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Safety check
		if (m_pSnapshotSet == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");
		}

		// No async lock here!

		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"invalid hThread");

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) {
			ft.LogGenericWarning( VSSDBG_GEN,
			    L"WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx",
			    hThread, GetLastError() );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssAsync::QueryStatus(
				OUT     HRESULT* pHrResult,
				OUT     INT* pnReserved
				)

/*++

Routine Description:

    Query the status for the current running process, if any.

Arguments:

	OUT     HRESULT* pHrResult  - Will be filled with a value reflected by the current status
	OUT     INT* pnReserved     - Reserved today. It will be filled always with zero, if non-NULL

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.
    E_INVALIDARG
        - NULL pHrResult

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::QueryStatus" );

	try
	{
		// Zero the [out] parameters
		::VssZeroOut(pHrResult);
		::VssZeroOut(pnReserved);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Argument check
		BS_ASSERT(pHrResult);
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pHrResult == NULL");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pSnapshotSet == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_COORD, L"Returning *pHrResult: 0x%08x", *pHrResult );
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\mgmt.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Mgmt.cxx | Implementation of CVssSnapshotMgmt
    @end

Author:

    Adi Oltean  [aoltean]  03/05/2001

Revision History:

    Name        Date        Comments
    aoltean     03/05/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_sec.hxx"
#include "provmgr.hxx"

#include "mgmt.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORMGMTC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssSnapshotMgmt


STDMETHODIMP CVssSnapshotMgmt::GetProviderMgmtInterface(							
	IN  	VSS_ID 	    ProviderId,     //  It might be a software or a system provider.
	IN  	REFIID 	    InterfaceId,    //  Might be IID_IVssDifferentialSoftwareSnapshotMgmt
	OUT     IUnknown**  ppItf           
	)
/*++

Routine description:

    Returns an interface to further configure a snapshot provider

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_PROVIDER_NOT_REGISTERED 
        - provider not found
    E_NOINTERFACE
        - the provider does not support the interface with the given ID.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - unexpected error when calling QueryInteface
    
    [CVssProviderManager::GetProviderInterface() failures]
        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.
            
            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::GetProviderMgmtInterface" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppItf );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  InterfaceId = " WSTR_GUID_FMT L"\n"
             L"  ppItf = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             GUID_PRINTF_ARG( InterfaceId ),
             ppItf);

        // Argument validation
		BS_ASSERT(ppItf);
        if (ppItf == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppItf");

        // Right now we support only IVssDifferentialSoftwareSnapshotMgmt. In future version we might support more interfaces.
        // WARNING: with the current implementation the client may still use QueryInterface to reach other provider's custom interfaces.
        // We cannot prevent that unless we decide to create a wrapper object around the returned provider interface, in order to 
        // intercept QueryInterface calls also.
        if ( InterfaceId != IID_IVssDifferentialSoftwareSnapshotMgmt )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid Interface ID");

        if (CVssSKU::IsClient())
            ft.Throw( VSSDBG_COORD, E_NOTIMPL, L"Method not exposed in client SKU");

		// Get the provider interface
        CComPtr<IVssSnapshotProvider> ptrProviderInterface;
        BOOL bResult = CVssProviderManager::GetProviderInterface( ProviderId, VSS_CTX_ALL, ptrProviderInterface );
        if (!bResult)
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, L"We could not found a provider with the given ID");
    	BS_ASSERT(ptrProviderInterface);

    	// Query the IID_IVssDifferentialSoftwareSnapshotMgmt interface.
    	// Last call, so we can directly fill out the OUT parameter
    	CComPtr<IVssSnapshotMgmt> ptrProviderSnapshotMgmt;
    	ft.hr = ptrProviderInterface->QueryInternalInterface(IID_IVssSnapshotMgmt, 
    	            reinterpret_cast<void**>(&ptrProviderSnapshotMgmt));
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryInternalInterface(IID_IVssSnapshotMgmt, ...)");

        // Get the provider interface
    	ft.hr = ptrProviderSnapshotMgmt->GetProviderMgmtInterface( ProviderId, InterfaceId, ppItf);
    }
    VSS_STANDARD_CATCH(ft)

	// The ft.hr may be an VSS_E_OBJECT_NOT_FOUND or not.
    return ft.hr;
}



STDMETHODIMP CVssSnapshotMgmt::QueryVolumesSupportedForSnapshots(
	IN  	VSS_ID 	    ProviderId,     
    IN      LONG        lContext,
	OUT 	IVssEnumMgmtObject **ppEnum
	)
/*++

Routine description:

    Query volumes (on the local machine) that support snapshots.

Parameters:

    ProviderID - the provider on which we should return the supported volumes for snapshot. 
    ppEnum - the returned list of volumes.

Remarks:

    The result of the query is independent by context.

Error codes:

    S_FALSE
        - If returning an empty array
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported
    E_UNEXPECTED
        Error while getting the list of volumes. (for example dismounting a volume in the middle of an enumeration)
        A error log entry contains more information.

    [CVssProviderManager::GetProviderInterface() failures]
        [lockObj failures]
            E_OUTOFMEMORY
        
        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.
            
            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [provider's QueryVolumesSupportedForSnapshots()]
        S_FALSE
            - If returning an empty array
        E_ACCESSDENIED
            - The user is not an administrator
        E_INVALIDARG
            - Invalid argument
        E_OUTOFMEMORY
            - lock failures.
        E_UNEXPECTED
            Error while getting the list of volumes. (for example dismounting a volume in the middle of an enumeration)
            A error log entry contains more information.

        [CVssSoftwareProvider::IsVolumeSupported() failures]
            S_OK
                The function completed with success
            E_ACCESSDENIED
                The user is not an administrator.
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources           
            E_UNEXPECTED
                Unexpected programming error. Logging not done and not needed.
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.

            [CVssSoftwareProvider::GetVolumeInformation]
                E_OUTOFMEMORY
                VSS_E_PROVIDER_VETO
                    An error occured while opening the IOCTL channel. The error is logged.
                E_UNEXPECTED
                    Unexpected programming error. Nothing is logged.
                VSS_E_OBJECT_NOT_FOUND
                    The device does not exist or it is not ready.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::QueryVolumesSupportedForSnapshots" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ProviderID");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Try to find the provider interface
		CComPtr<IVssSnapshotProvider> ptrProviderItf;
        if (!(CVssProviderManager::GetProviderInterface(ProviderId, lContext, ptrProviderItf)))
			ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
			    L"Provider not found");

    	// Query the IID_IVssSnapshotMgmt interface.
    	// Last call, so we can directly fill out the OUT parameter
    	CComPtr<IVssSnapshotMgmt> ptrProviderSnapshotMgmt;
    	ft.hr = ptrProviderItf->QueryInternalInterface(IID_IVssSnapshotMgmt, 
    	            reinterpret_cast<void**>(&ptrProviderSnapshotMgmt));
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryInternalInterface(IID_IVssSnapshotMgmt, ...)");

        // Get the provider interface
    	ft.hr = ptrProviderSnapshotMgmt->QueryVolumesSupportedForSnapshots( ProviderId, lContext, ppEnum);
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryVolumesSupportedForSnapshots(ProviderId,%ld,...)", lContext);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/*++

Routine description:

    Query snapshots on the given volume.

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
--*/
STDMETHODIMP CVssSnapshotMgmt::QuerySnapshotsByVolume(
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_ID 	    ProviderId,     
	OUT 	IVssEnumObject **ppEnum
	)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::QuerySnapshotsByVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
		BS_ASSERT(pwszVolumeName);
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ProviderID");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Calculate the unique volume name, just to make sure that we have the right path
    	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Try to find the provider interface
		CComPtr<IVssSnapshotProvider> ptrProviderItf;
        if (!(CVssProviderManager::GetProviderInterface(ProviderId, VSS_CTX_ALL, ptrProviderItf)))
			ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
			    L"Provider not found");

    	// Query the IID_IVssSnapshotMgmt interface.
    	// Last call, so we can directly fill out the OUT parameter
    	CComPtr<IVssSnapshotMgmt> ptrProviderSnapshotMgmt;
    	ft.hr = ptrProviderItf->QueryInternalInterface(IID_IVssSnapshotMgmt, 
    	            reinterpret_cast<void**>(&ptrProviderSnapshotMgmt));
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QueryInternalInterface(IID_IVssSnapshotMgmt, ...)");

        // Get the provider interface
    	ft.hr = ptrProviderSnapshotMgmt->QuerySnapshotsByVolume( wszVolumeNameInternal, ProviderId, ppEnum);
    	if (ft.HrFailed())
    	    ft.TranslateProviderError(VSSDBG_COORD, ProviderId, 
    	        L"IVssSnapshotProvider::QuerySnapshotsByVolume(%s,...)", wszVolumeNameInternal);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Implementation of CVssCoordinator::DeleteSnapshots
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/10/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "admin.hxx"
#include "provmgr.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORDELEC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssCoordinator


STDMETHODIMP CVssCoordinator::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
    IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )
/*++

Routine description:

    Implements the IVSsCoordinator::Delete

Error codes:

    E_ACCESSDENIED 
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Object identified by SourceObjectId not found.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.
            
            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [DeleteSnapshots failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::DeleteSnapshots" );

    try
    {
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);
		
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

        // Argument validation
		BS_ASSERT(plDeletedSnapshots);
        if (plDeletedSnapshots == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL plDeletedSnapshots");
		BS_ASSERT(pNondeletedSnapshotID);
        if (pNondeletedSnapshotID == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pNondeletedSnapshotID");

        // Freeze context
        FreezeContext();

		// Delegating the call to the providers
		LONG lLocalDeletedSnapshots = 0;
		CComPtr<IVssSnapshotProvider> pProviderItf;
		switch(eSourceObjectType)
		{
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
			{
				// Get the array of interfaces
        		CVssSnapshotProviderItfMap* pItfMap;
        		CVssProviderManager::GetProviderItfArray( GetContextInternal(), &pItfMap );

				// For each provider get all objects tht corresponds to the filter
				bool bObjectFound = false;
				for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
				{
					pProviderItf = pItfMap->GetValueAt(nIndex);
        			if (pProviderItf == NULL)
        			    continue;

					// Query the provider
					ft.hr = pProviderItf->DeleteSnapshots(
						SourceObjectId,
						eSourceObjectType,
						bForceDelete,
						&lLocalDeletedSnapshots,
						pNondeletedSnapshotID
						);

					// Increment the number of deleted snapshots, even in error case.
					// In error case the DeleteSnapshots may fail in the middle of deletion.
					// Some snapshots may get a chance to be deleted.
					(*plDeletedSnapshots) += lLocalDeletedSnapshots;

					// Treat the "object not found" case.
					// The DeleteSnapshots may fail if the object is not found on a certain provider.
					// If the object is not found on ALL providers then this function must return
					// an VSS_E_OBJECT_NOT_FOUND error.
					if (ft.HrSucceeded())
						bObjectFound = true;
					else if (ft.hr == VSS_E_OBJECT_NOT_FOUND) {
					    ft.hr = S_OK;
						continue;
					} else
    					ft.TranslateProviderError( VSSDBG_COORD, pItfMap->GetKeyAt(nIndex), 
    					    L"DeleteSnapshots("WSTR_GUID_FMT L", %d, %d, [%ld],["WSTR_GUID_FMT L"]) failed",
    					    GUID_PRINTF_ARG(SourceObjectId), (INT)eSourceObjectType, (INT)(bForceDelete? 1: 0), 
    					    lLocalDeletedSnapshots, GUID_PRINTF_ARG(*pNondeletedSnapshotID));
				}
				
				// If no object found in all providers...
				if (!bObjectFound)
					ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Object not found in any provider");
			}
			break;

		default:
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid type %d", eSourceObjectType);
		}
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrSucceeded())
    	(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\async_shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async_shim.cxx | Implementation of CVssShimAsync object
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "shim.hxx"
#include "async_shim.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORASYSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssShimAsync


CVssShimAsync::CVssShimAsync():
    m_guidSnapshotSetId(GUID_NULL),
	m_ulOptionFlags(0),	
	m_ulVolumeCount(0),	
	m_ppwszVolumeNamesArray(NULL),
	m_hrState(S_OK)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::CVssShimAsync" );
}


CVssShimAsync::~CVssShimAsync()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::~CVssShimAsync" );

	for (ULONG ulIndex = 0; ulIndex < m_ulVolumeCount; ulIndex++ )
	    ::VssFreeString(m_ppwszVolumeNamesArray[ulIndex]);
	delete[] m_ppwszVolumeNamesArray;
}


IVssAsync* CVssShimAsync::CreateInstanceAndStartJob(
	IN	    CVssShimObject*	pShimObject,
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)

/*++

Routine Description:

    Static method that creates a new instance of the CVssShimAsync interface and
    starts a background thread that runs the CVssShimAsync::OnRun.

Arguments:

    CVssShimObject*	pShimObject,
    VSS_ID          guidSnapshotSetId,
    ULONG           ulOptionFlags,	
    ULONG           ulVolumeCount,	
    VSS_PWSZ*       ppwszVolumeNamesArray

Throw values:

    E_OUTOFMEMORY
        - On CComObject<CVssAsync>::CreateInstance failure
        - On copy the data members for the async object.
        - On PrepareJob failure
        - On StartJob failure

    E_UNEXPECTED
        - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    // Allocate the COM object.
    CComObject<CVssShimAsync>* pObject;
    ft.hr = CComObject<CVssShimAsync>::CreateInstance(&pObject);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssShimAsync instance. hr = 0x%08lx", ft.hr);
    BS_ASSERT(pObject);

    // Querying the IVssSnapshot interface. Now the ref count becomes 1.
    CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
    BS_ASSERT(pUnknown);

	// Setting async object internal data
	BS_ASSERT(pShimObject);

	// Initialize allocated parameters
	pObject->m_guidSnapshotSetId = guidSnapshotSetId;
	pObject->m_ulOptionFlags = ulOptionFlags;
	pObject->m_ulVolumeCount = ulVolumeCount;
	pObject->m_ppwszVolumeNamesArray = new VSS_PWSZ[ulVolumeCount];
	if (pObject->m_ppwszVolumeNamesArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssShimAsync instance. hr = 0x%08lx", ft.hr);

        ::ZeroMemory( reinterpret_cast<PVOID>( pObject->m_ppwszVolumeNamesArray ), sizeof( VSS_PWSZ ) * ulVolumeCount );

	// Copy each volume name
	for( ULONG ulIndex = 0; ulIndex < ulVolumeCount; ulIndex++) {
	    VssSafeDuplicateStr( ft,
	        pObject->m_ppwszVolumeNamesArray[ulIndex],
	        ppwszVolumeNamesArray[ulIndex]);
	}

	// AddRef is called - since the CVssShimAsync keeps a smart pointer.
    pObject->m_pShim = pShimObject;

    ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
    if ( ft.HrFailed() ) {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error querying the IVssAsync interface. hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pAsync);

	// Prepare job (thread created in resume state)
	ft.hr = pObject->PrepareJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job. hr = 0x%08lx", ft.hr);

	// Start job (now the background thread will start running).
	ft.hr = pObject->StartJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job. hr = 0x%08lx", ft.hr);

    // The reference count becomes 3 since we keep a reference for the background thread.

    // Right now the background thread is running. This thread will perform a Release when finishes.
    // This will keep the async object alive until the thread finishes.
    // But, we cannot put an AddRef in the OnInit/OnRun on the background thread,
    // (since in this thread we might
    // call all subsequent releases without giving a chance to the other thread to do an AddRef)
    // Also we cannot put an AddRef at creation since we didn't know at that time if the background
    // thread will run.
    // Therefore we must do the AddRef right here.
    // Beware, this AddRef is paired with an Release in the CVssShimAsync::OnFinish method:
    // Note: we are sure that we cannot reach reference count zero since the thread is surely running,
    //
    IUnknown* pUnknownTmp = pObject->GetUnknown();
    pUnknownTmp->AddRef();

	// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
    // The ref count goes back to 2

	return pAsync.Detach();	  // The ref count remains 2.
}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


bool CVssShimAsync::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnInit" );

	if (m_pShim != NULL)
	{
		// Setting snapshot set internal data
		BS_ASSERT(m_hrState == S_OK);
		m_hrState = VSS_S_ASYNC_PENDING;

		// Setting snapshot set internal data
		BS_ASSERT(!m_pShim->m_bCancel);
		m_pShim->m_bCancel = false;
    }

	return (m_pShim != NULL);
}


void CVssShimAsync::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnRun" );

	try
	{
		// Check if the snapshot object is created.
		if (m_pShim == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
				L"Snapshot set object not yet created.");
		}

		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// Call SimulateSnapshotFreeze on the given object.
		ft.hr = m_pShim->SimulateSnapshotFreeze(
		            m_guidSnapshotSetId,
		            m_ulOptionFlags,
		            m_ulVolumeCount,
		            m_ppwszVolumeNamesArray);
		if (ft.hr != S_OK)
		{
			ft.Trace( VSSDBG_COORD,
					  L"Internal SimulateSnapshotFreeze failed. 0x%08lx", ft.hr);
			
			// Put the error code into the
			BS_ASSERT(m_hrState == VSS_S_ASYNC_PENDING);
			m_hrState = ft.hr;
		}

		// Now m_hrState may be VSS_S_ASYNC_CANCELLED
	}
	VSS_STANDARD_CATCH(ft)
}


void CVssShimAsync::OnFinish()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnFinish" );

    try
    {
		if (m_pShim)
		{
			if ( m_hrState == VSS_S_ASYNC_PENDING)
				m_hrState = VSS_S_ASYNC_FINISHED;
			// Else keep the m_hrState error code...
			// It may be VSS_S_ASYNC_CANCELLED, if CVssShimObject::TestIfCancelNeeded was called.
		}
		else
			BS_ASSERT(false);

        // Release the background thread reference to this object.
		// Note: We kept an reference around for the time when the backgropund thread is running.
        // In this way we avoid the destruction of the async interface while the
        // background thread is running.
        // The paired addref was done after a sucessful StartJob

        // Mark the thread object as "finished"
        MarkAsFinished();

        // We release the interface only if StartJob was returned with success
        IUnknown* pMyself = GetUnknown();
        pMyself->Release();
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssShimAsync::OnTerminate()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnTerminate" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssShimAsync::Cancel()

/*++

Routine Description:

    Cancels the current running process, if any.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::Cancel" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pShim == NULL) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");
		}

		// If thread is already finished, return correct code.
		if ((m_hrState == VSS_S_ASYNC_FINISHED) || (m_hrState == VSS_S_ASYNC_CANCELLED))
			ft.hr = m_hrState;
		else	// Otherwise, inform the thread that it must cancel. The function returns immediately.
			m_pShim->m_bCancel = true;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssShimAsync::Wait()

/*++

Routine Description:

    Waits until the process gets finished.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.
        - Thread handle is invalid. Code bug, no logging.
        - WaitForSingleObject failed. Code bug, no logging.

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::Wait" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Safety check
		if (m_pShim == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");
		}

		// No async lock here!

		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"invalid hThread");

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) {
			ft.LogGenericWarning( VSSDBG_GEN,
			    L"WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx",
			    hThread, GetLastError() );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssShimAsync::QueryStatus(
				OUT     HRESULT* pHrResult,
				OUT     INT* pnReserved
				)

/*++

Routine Description:

    Query the status for the current running process, if any.

Arguments:

	OUT     HRESULT* pHrResult  - Will be filled with a value reflected by the current status
	OUT     INT* pnReserved     - Reserved today. It will be filled always with zero, if non-NULL

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.
    E_INVALIDARG
        - NULL pHrResult

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::QueryStatus" );

	try
	{
		// Zero the [out] parameters
		::VssZeroOut(pHrResult);
		::VssZeroOut(pnReserved);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Argument check
		BS_ASSERT(pHrResult);
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pHrResult == NULL");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pShim == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_COORD, L"Returning *pHrResult: 0x%08x", *pHrResult );
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\hardwrp.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Abstract:

    @doc
    @module hwprvmgr.cxx | Implementation of the CVssHWProviderWrapper methods
    @end

Author:

    Brian Berkowitz  [brianb]  04/16/2001

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      04/16/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "setupapi.h"
#include "rpc.h"
#include "cfgmgr32.h"
#include "devguid.h"
#include "resource.h"
#include "vssmsg.h"
#include <svc.hxx>

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vswriter.h"
#include "vsbackup.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "vs_idl.hxx"
#include "hardwrp.hxx"

#define INITGUID
#include "guiddef.h"
#include "volmgrx.h"
#undef INITGUID

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORHWPMC"
//
////////////////////////////////////////////////////////////////////////

// static data members
// first wrapper in list
CVssHardwareProviderWrapper *CVssHardwareProviderWrapper::s_pHardwareWrapperFirst;

// critical section for wrapper list
CVssSafeCriticalSection CVssHardwareProviderWrapper::s_csHWWrapperList;


// constructor
CVssHardwareProviderWrapper::CVssHardwareProviderWrapper() :
    m_SnapshotSetId(GUID_NULL),
    m_pList(NULL),
    m_wszOriginalVolumeName(NULL),
    m_rgLunInfoProvider(NULL),
    m_cLunInfoProvider(0),
    m_pExtents(NULL),
    m_ProviderId(GUID_NULL),
    m_lRef(0),
    m_eState(VSS_SS_UNKNOWN),
    m_bOnGlobalList(false),
    m_rgwszDisksArrived(NULL),
    m_cDisksArrived(0),
    m_cDisksArrivedMax(0),
    m_chVolumes(0),
    m_rghVolumes(NULL),
    m_wszDeletedVolumes(NULL),
    m_cwcDeletedVolumes(0),
    m_iwcDeletedVolumes(0),
    m_bLoaded(false),
    m_bChanged(false)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CVssHardwareProviderWrapper");
    }

// destructor
CVssHardwareProviderWrapper::~CVssHardwareProviderWrapper()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::~CVssHardwareProviderWrapper");

    TrySaveData();

    // delete any auto release snapshot sets associated with this wrapper
    DeleteAutoReleaseSnapshots();

    // close any volume handles kept open for snapshots in progress
    CloseVolumeHandles();

    // free up original volume name
    delete m_wszOriginalVolumeName;

    // free up array of extents
    delete m_pExtents;

    // free up lun information
    FreeLunInfo(m_rgLunInfoProvider, m_cLunInfoProvider);

    // delete disk arrival list
    ResetDiskArrivalList();

    // free up all created snapshot sets
    while(m_pList)
        {
        m_pList->m_pDescription->Release();
        VSS_SNAPSHOT_SET_LIST *pList = m_pList;
        m_pList = m_pList->m_next;
        delete pList;
        }

    // delete array of volumes deleted when a snapshot or snapshot
    // set is deleted
    delete m_wszDeletedVolumes;

    if (m_bOnGlobalList)
        {
        // remove wrapper fro global wrapper list

        // first acquire critical section
        CVssSafeAutomaticLock lock(s_csHWWrapperList);
        CVssHardwareProviderWrapper *pWrapperCur = s_pHardwareWrapperFirst;
        if (pWrapperCur == this)
            // wrapper is first one on the list
            s_pHardwareWrapperFirst = m_pHardwareWrapperNext;
        else
            {
            // wrapper is not the first one on the list.  Search For it
            while(TRUE)
                {
                // save current as previous
                CVssHardwareProviderWrapper *pWrapperPrev = pWrapperCur;

                // get next wrapper
                pWrapperCur = pWrapperCur->m_pHardwareWrapperNext;

                // shouldn't be null since the wrapper is on the list
                BS_ASSERT(pWrapperCur != NULL);
                if (pWrapperCur == this)
                    {
                    pWrapperPrev->m_pHardwareWrapperNext = pWrapperCur->m_pHardwareWrapperNext;
                    break;
                    }
                }
            }
        }
    }

// append a wrapper to the global list
void CVssHardwareProviderWrapper::AppendToGlobalList()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AppendToGlobalList");

    BS_ASSERT(s_csHWWrapperList.IsInitialized());

    // get lock for global list
    CVssSafeAutomaticLock lock(s_csHWWrapperList);

    // make current object first on global list
    m_pHardwareWrapperNext = s_pHardwareWrapperFirst;
    s_pHardwareWrapperFirst = this;
    m_bOnGlobalList = true;
    }

// eliminate all wrappers in order to terminate the service
void CVssHardwareProviderWrapper::Terminate()
    {
    // get lock
    CVssSafeAutomaticLock lock(s_csHWWrapperList);

    // delete all wrappers on the list
    while(s_pHardwareWrapperFirst)
        delete s_pHardwareWrapperFirst;
    }

// initialize the hardware wrapper
void CVssHardwareProviderWrapper::Initialize()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::Initialize");
    if (!m_csList.IsInitialized())
        {
        try
            {
            m_csList.Init();
            }
        catch(...)
            {
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot initialize critical section");
            }
        }
    }




// create a wrapper of the hardware provider supporting the
// IVssSnapshotProvider interface
// Throws:
//      E_OUTOFMEMORY
//      VSS_E_UNEXPECTED_PROVIDER_ERROR,
//      VSS_ERROR_CREATING_PROVIDER_CLASS

IVssSnapshotProvider* CVssHardwareProviderWrapper::CreateInstance
    (
    IN VSS_ID ProviderId,
    IN CLSID ClassId
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CreateInstance");

    // initialize critical section for list if necessary
    if (!s_csHWWrapperList.IsInitialized())
        s_csHWWrapperList.Init();

    CComPtr<CVssHardwareProviderWrapper> pWrapper;

    bool bCreated = false;

    // if wrapper is created, this is the autoptr used to destroy it if we
    // prematurely exit the routine.

        {
        CVssSafeAutomaticLock lock(s_csHWWrapperList);

        // look for wrapper in list of wrappers already created
        CVssHardwareProviderWrapper *pWrapperSearch = s_pHardwareWrapperFirst;

        while(pWrapperSearch != NULL)
            {
            if (pWrapperSearch->m_ProviderId == ProviderId)
                break;

            pWrapperSearch = pWrapperSearch->m_pHardwareWrapperNext;
            }

        if (pWrapperSearch != NULL)
            // reference count incremented
            pWrapper = pWrapperSearch;
        else
            {
            // Ref count becomes 1
            // create new wrapper
            pWrapper = new CVssHardwareProviderWrapper();
            if (pWrapper == NULL)
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

            pWrapper->m_ProviderId = ProviderId;
            pWrapper->Initialize();
            bCreated = true;
            }
        }

    // Create the IVssSoftwareSnapshotProvider interface

    if (pWrapper->m_pHWItf == NULL)
        {
        // necessary create hardware provider
        ft.hr = pWrapper->m_pHWItf.CoCreateInstance(ClassId, NULL, CLSCTX_LOCAL_SERVER);

        if ( ft.HrFailed() )
            {
            ft.LogError(VSS_ERROR_CREATING_PROVIDER_CLASS, VSSDBG_COORD << ClassId << ft.hr );
            ft.Throw( VSSDBG_COORD, VSS_E_UNEXPECTED_PROVIDER_ERROR, L"CoCreateInstance failed with hr = 0x%08lx", ft.hr);
            }

        BS_ASSERT(pWrapper->m_pHWItf);


        // Query the creation itf.
        ft.hr = pWrapper->m_pHWItf->SafeQI( IVssProviderCreateSnapshotSet, &(pWrapper->m_pCreationItf));
        if (ft.HrFailed())
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderCreateSnapshotSet");

        BS_ASSERT(pWrapper->m_pCreationItf);

        // Query the notification itf.
        // Execute the OnLoad, if needed
        ft.hr = pWrapper->m_pHWItf->SafeQI( IVssProviderNotifications, &(pWrapper->m_pNotificationItf));
        if (ft.HrSucceeded())
            {
            BS_ASSERT(pWrapper->m_pNotificationItf);
            ft.hr = pWrapper->m_pNotificationItf->OnLoad(NULL);
            if (ft.HrFailed())
                ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssProviderNotifications::OnLoad");
            }
        else if (ft.hr != E_NOINTERFACE)
            {
            BS_ASSERT(false);
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderNotifications");
            }
        }

    if (bCreated)
        // append wrapper to the global list
        pWrapper->AppendToGlobalList();

    // return the created interface
    // Ref count is still 1
    return pWrapper.Detach();
    }


/////////////////////////////////////////////////////////////////////////////
// Internal methods

// this method should never be called
STDMETHODIMP CVssHardwareProviderWrapper::QueryInternalInterface
    (
    IN  REFIID iid,
    OUT void** pp
    )
    {
    UNREFERENCED_PARAMETER(iid);

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::QueryInternalInterface");

    BS_ASSERT(pp);
    *pp = NULL;

    BS_ASSERT(FALSE);
    return E_NOINTERFACE;
    }


/////////////////////////////////////////////////////////////////////////////
// IUnknown

// supports coercing the wrapper to IUnknown
STDMETHODIMP CVssHardwareProviderWrapper::QueryInterface(REFIID iid, void** pp)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::QueryInterface");

    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
    return S_OK;
    }

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssHardwareProviderWrapper::AddRef()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AddRef");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper AddRef(%p) %lu --> %lu", this, m_lRef, m_lRef+1);

    return ::InterlockedIncrement(&m_lRef);
    }

// IUnknown::Relese
STDMETHODIMP_(ULONG) CVssHardwareProviderWrapper::Release()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::Release");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper Release(%p) %lu --> %lu", this, m_lRef, m_lRef-1);

    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        {
        if (m_pList == NULL)
            // there are no snapshot sets.  Therefore we can remove the
            // object from the list and delete it.
            delete this; // We suppose that we always allocate this object on the heap!
        else
            {
            // release provider interfaces to allow the provider to be unloaded
            // need to keep this object around since there are snapshots
            // still available

            m_pHWItf = NULL;
            m_pCreationItf = NULL;
            m_pNotificationItf = NULL;
            }
        }

    return l;
    }

// IVssProvider::SetContext
// note that this routine will initialize the wrapper's critical section
// if it wasn't already done.
STDMETHODIMP CVssHardwareProviderWrapper::SetContext
    (
    IN LONG lContext
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::SetContext");

    m_lContext = lContext;
    return ft.hr;
    }

// compare two disk extents, used to sort the extents
int __cdecl CVssHardwareProviderWrapper::cmpDiskExtents(const void *pv1, const void *pv2)
    {
    DISK_EXTENT *pDE1 = (DISK_EXTENT *) pv1;
    DISK_EXTENT *pDE2 = (DISK_EXTENT *) pv2;

    // first compare disk number
    int i = (int) pDE1->DiskNumber - (int) pDE2->DiskNumber;
    if (i != 0)
        return i;

    // compare starting offset on disk
    if (pDE1->StartingOffset.QuadPart > pDE2->StartingOffset.QuadPart)
        return 1;
    else if (pDE1->StartingOffset.QuadPart < pDE2->StartingOffset.QuadPart)
        return -1;

    // two extents starting at the same offset on the same disk had
    // better match exactly
    BS_ASSERT(pDE1->ExtentLength.QuadPart == pDE2->ExtentLength.QuadPart);
    return 0;
    }

// copy a storage device id descriptor to the VDS_LUN_INFORMATION structure.
// note that lun is modified whether an execption occurs or not.  FreeLunInfo
// will free up any data allocated here.
void CVssHardwareProviderWrapper::CopyStorageDeviceIdDescriptorToLun
    (
    IN STORAGE_DEVICE_ID_DESCRIPTOR *pDevId,
    IN VDS_LUN_INFORMATION *pLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CopyStorageDeviceIdDescriptorToLun");

    BS_ASSERT(StorageIdTypeVendorSpecific == VDSStorageIdTypeVendorSpecific);
    BS_ASSERT(StorageIdTypeVendorId == VDSStorageIdTypeVendorId);
    BS_ASSERT(StorageIdTypeEUI64 == VDSStorageIdTypeEUI64);
    BS_ASSERT(StorageIdTypeFCPHName == VDSStorageIdTypeFCPHName);
    BS_ASSERT(StorageIdCodeSetAscii == VDSStorageIdCodeSetAscii);
    BS_ASSERT(StorageIdCodeSetBinary == VDSStorageIdCodeSetBinary);

    // get count of ids
    DWORD cIds = pDevId->NumberOfIdentifiers;

    // copy over version number and count of ids
    pLun->m_deviceIdDescriptor.m_version = pDevId->Version;
    pLun->m_deviceIdDescriptor.m_cIdentifiers = cIds;

    // allocate array of identifiers
    pLun->m_deviceIdDescriptor.m_rgIdentifiers =
        (VDS_STORAGE_IDENTIFIER *) CoTaskMemAlloc(sizeof(VDS_STORAGE_IDENTIFIER) * cIds);

    if (pLun->m_deviceIdDescriptor.m_rgIdentifiers == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate device id descriptors");

    // clear descriptor.  If we throw, we want to make sure that all pointers
    // are null
    memset(pLun->m_deviceIdDescriptor.m_rgIdentifiers, 0, sizeof(VDS_STORAGE_IDENTIFIER) * cIds);

    // get pointer to first identifier in both STORAGE_DEVICE_ID_DESCRIPTOR and
    // VDS_STORAGE_DEVICE_ID_DESCRIPTOR
    STORAGE_IDENTIFIER *pId = (STORAGE_IDENTIFIER *) pDevId->Identifiers;
    VDS_STORAGE_IDENTIFIER *pvsi = (VDS_STORAGE_IDENTIFIER *) pLun->m_deviceIdDescriptor.m_rgIdentifiers;

    for(UINT i = 0; i < cIds; i++)
        {
        // copy over size of identifier
        pvsi->m_cbIdentifier = pId->IdentifierSize;

        // allocate space for identifier
        pvsi->m_rgbIdentifier = (BYTE *) CoTaskMemAlloc(pvsi->m_cbIdentifier);
        if (pvsi->m_rgbIdentifier == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate storage identifier");

        // copy type and code set over
        pvsi->m_Type = (VDS_STORAGE_IDENTIFIER_TYPE) pId->Type;
        pvsi->m_CodeSet = (VDS_STORAGE_IDENTIFIER_CODE_SET) pId->CodeSet;

        // copy identifier
        memcpy(pvsi->m_rgbIdentifier, pId->Identifier, pvsi->m_cbIdentifier);

        // move to next identifier
        pId = (STORAGE_IDENTIFIER *) ((BYTE *) pId + pId->NextOffset);
        pvsi++;
        }
    }


// build a STORAGE_DEVICE_ID_DESCRIPTOR from a VDS_STORAGE_DEVICE_ID_DESCRIPTOR
STORAGE_DEVICE_ID_DESCRIPTOR *
CVssHardwareProviderWrapper::BuildStorageDeviceIdDescriptor
    (
    IN VDS_STORAGE_DEVICE_ID_DESCRIPTOR *pDesc
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildStorageDeviceIdDescriptor");

    BS_ASSERT(StorageIdTypeVendorSpecific == VDSStorageIdTypeVendorSpecific);
    BS_ASSERT(StorageIdTypeVendorId == VDSStorageIdTypeVendorId);
    BS_ASSERT(StorageIdTypeEUI64 == VDSStorageIdTypeEUI64);
    BS_ASSERT(StorageIdTypeFCPHName == VDSStorageIdTypeFCPHName);
    BS_ASSERT(StorageIdCodeSetAscii == VDSStorageIdCodeSetAscii);
    BS_ASSERT(StorageIdCodeSetBinary == VDSStorageIdCodeSetBinary);


    // get array of identifiers
    VDS_STORAGE_IDENTIFIER *pvsi = pDesc->m_rgIdentifiers;

    // offset of first identifier in STORAGE_DEVICE_ID_DESCRIPTOR
    UINT cbDesc = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

    // compute size of identifiers
    for(ULONG iid = 0; iid < pDesc->m_cIdentifiers; iid++, pvsi++)
        {
        cbDesc += FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        cbDesc += (pvsi->m_cbIdentifier + sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1);
        }

    // allocate STORAGE_DEVICE_ID_DESCRIPTOR
    STORAGE_DEVICE_ID_DESCRIPTOR *pDescRet = (STORAGE_DEVICE_ID_DESCRIPTOR *) CoTaskMemAlloc(cbDesc);
    if (pDescRet == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate STORAGE_DEVICE_ID_DESCRIPTOR");
    try
        {
        // copy over version and count of identifiers
        pDescRet->Version = pDesc->m_version;
        pDescRet->NumberOfIdentifiers = pDesc->m_cIdentifiers;
        pDescRet->Size = cbDesc;

        // point to first identifier
        STORAGE_IDENTIFIER *pId = (STORAGE_IDENTIFIER *) pDescRet->Identifiers;
        pvsi = pDesc->m_rgIdentifiers;
        for(ULONG iid = 0; iid < pDesc->m_cIdentifiers; iid++)
            {
            // copy code set and type
            pId->CodeSet = (STORAGE_IDENTIFIER_CODE_SET) pvsi->m_CodeSet;
            pId->Type = (STORAGE_IDENTIFIER_TYPE) pvsi->m_Type;

            // copy identifier size
            pId->IdentifierSize = (USHORT) pvsi->m_cbIdentifier;

            // copy in identifier
            memcpy(pId->Identifier, pvsi->m_rgbIdentifier, pvsi->m_cbIdentifier);

            // compute offset of next identifier.  This is the size of the
            // STORAGE_IDENTIFIER structure rounded up to the next DWORD.
            pId->NextOffset = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier) +
                              ((pId->IdentifierSize + sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

            // move to next identifier
            pId = (STORAGE_IDENTIFIER *) ((BYTE *) pId + pId->NextOffset);
            pvsi++;
            }
        }
    catch(...)
        {
        // delete descriptor if exception occurs
        if (pDescRet)
            CoTaskMemFree(pDescRet);

        throw;
        }

    return pDescRet;
    }

// create a cotaskalloc string copy
void CVssHardwareProviderWrapper::CreateCoTaskString
    (
    IN CVssFunctionTracer &ft,
    IN LPCWSTR wsz,
    OUT LPWSTR &wszCopy
    )
    {
    if (wsz == NULL)
        wszCopy = NULL;
    else
        {
        wszCopy = (WCHAR *) CoTaskMemAlloc((wcslen(wsz) + 1) * sizeof(WCHAR));
        if (wszCopy == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

        wcscpy(wszCopy, wsz);
        }
    }




// copy a string from a STORAGE_DEVICE_DESCRIPTOR.  It is returned as a
// CoTaskAllocated string.
void CVssHardwareProviderWrapper::CopySDString
    (
    LPSTR *ppszNew,
    STORAGE_DEVICE_DESCRIPTOR *pdesc,
    DWORD offset
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CopySDString");

    // point to start of string
    LPSTR szId = (LPSTR)((BYTE *) pdesc + offset);
    UINT cch = (UINT) strlen(szId);
    while(cch > 0 && szId[cch-1] == ' ')
        cch--;

    if (cch == 0)
        *ppszNew = NULL;
    else
        {
        // allocate string
        *ppszNew = (LPSTR) CoTaskMemAlloc(cch + 1);
        if (*ppszNew == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

        // copy value into string
        memcpy(*ppszNew, szId, cch);
        (*ppszNew)[cch] = '\0';
        }
    }

// free all the components of a VDS_LUN_INFO structure
void CVssHardwareProviderWrapper::FreeLunInfo
    (
    IN VDS_LUN_INFORMATION *rgLunInfo,
    UINT cLuns
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::FreeLunInfo");

    // check if pointer is NULL
    if (rgLunInfo == NULL)
        {
        BS_ASSERT(cLuns == 0);
        return;
        }

    // loop through individual luns
    for(DWORD iLun = 0; iLun < cLuns; iLun++)
        {
        // get lun info
        VDS_LUN_INFORMATION *pLun = &rgLunInfo[iLun];

        // free up strings
        if (pLun->m_szVendorId)
            CoTaskMemFree(pLun->m_szVendorId);

        if (pLun->m_szProductId)
            CoTaskMemFree(pLun->m_szProductId);

        if (pLun->m_szProductRevision)
            CoTaskMemFree(pLun->m_szProductRevision);

        if (pLun->m_szSerialNumber)
            CoTaskMemFree(pLun->m_szSerialNumber);


        // point to VDS_STORAGE_DEVICE_ID_DESCRIPTOR
        // get number of VDS_STORAGE_IDENTIFIERs in the descriptor
        ULONG cIds = pLun->m_deviceIdDescriptor.m_cIdentifiers;

        // point to first VDS_STORAGE_IDENTIFIER
        VDS_STORAGE_IDENTIFIER *pvsi = pLun->m_deviceIdDescriptor.m_rgIdentifiers;
        for(ULONG iId = 0; iId < cIds; iId++, pvsi++)
            {
            // free up data for identifier
            if (pvsi->m_rgbIdentifier)
                CoTaskMemFree(pvsi->m_rgbIdentifier);
            }

        // free up array of identifiers
        if (pLun->m_deviceIdDescriptor.m_rgIdentifiers)
            CoTaskMemFree(pLun->m_deviceIdDescriptor.m_rgIdentifiers);

        // point to first VDS_INTERCONNECT
        VDS_INTERCONNECT *pInterconnect = pLun->m_rgInterconnects;

        for(ULONG iInterconnect = 0; iInterconnect < pLun->m_cInterconnects; iInterconnect++, pInterconnect++)
            {
            // free up address if there is one
            if (pInterconnect->m_pbAddress)
                CoTaskMemFree(pInterconnect->m_pbAddress);

            if (pInterconnect->m_pbPort)
                CoTaskMemFree(pInterconnect->m_pbPort);
            }

        // free up array of interconnects
        if (pLun->m_rgInterconnects)
            CoTaskMemFree(pLun->m_rgInterconnects);
        }

    // free up array of lun information
    CoTaskMemFree(rgLunInfo);
    }

bool CVssHardwareProviderWrapper::DoDeviceIoControl
    (
    IN HANDLE hDevice,
    IN DWORD ioctl,
    IN const LPBYTE pbQuery,
    IN DWORD cbQuery,
    OUT LPBYTE *ppbOut,
    OUT DWORD *pcbOut
    )
    {
    bool bSucceeded = false;

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DoDeviceIoControl");

    // loop in case buffer is too small for query result.
    while(TRUE)
        {
        DWORD dwSize;
        if (*ppbOut == NULL)
            {
            // allocate buffer for result of query
            *ppbOut = new BYTE[*pcbOut];
            if (*ppbOut == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Couldn't allocate query results buffer");
            }

        // do query
        if (!DeviceIoControl
                (
                hDevice,
                ioctl,
                pbQuery,
                cbQuery,
                *ppbOut,
                *pcbOut,
                &dwSize,
                NULL
                ))
            {
            // query failed
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_NOT_SUPPORTED)
                break;

            if (dwErr == ERROR_INSUFFICIENT_BUFFER ||
                dwErr == ERROR_MORE_DATA)
                {
                // buffer wasn't big enough allocate a new
                // buffer of the specified return size
                delete *ppbOut;
                *ppbOut = NULL;
                *pcbOut *= 2;
                continue;
                }

            // all other errors are remapped (and potentially logged)
            ft.hr = HRESULT_FROM_WIN32(dwErr);
            ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl %d");
            }

        bSucceeded = true;
        break;
        }

    return bSucceeded;
    }



bool CVssHardwareProviderWrapper::BuildLunInfoFromVolume
    (
    IN LPCWSTR wszVolume,
    OUT LPBYTE &bufExtents,
    OUT UINT &cLuns,
    OUT PLUNINFO &rgLunInfo
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildLunInfoFromVolume");

    // create handle to volume
    CVssAutoWin32Handle hVol =
        CreateFile
            (
            wszVolume,
            GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

    if (hVol == INVALID_HANDLE_VALUE)
        {
        DWORD dwErr = GetLastError();

        // translate not found errors to VSS_E_OBJECT_NOT_FOUND
        if (dwErr == ERROR_FILE_NOT_FOUND ||
            dwErr == ERROR_PATH_NOT_FOUND)
            ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"volume name is invalid");

        // all other errors are remapped (and potentially logged)
        ft.hr = HRESULT_FROM_WIN32(dwErr);
        ft.CheckForError(VSSDBG_COORD, L"CreateFile(Volume)");
        }

    // initial size of buffer for disk extents
    DWORD cbBufExtents = 1024;
    BS_ASSERT(bufExtents == NULL);

    // loop in case buffer is too small and needs to be grown
    if (!DoDeviceIoControl
            (
            hVol,
            IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
            NULL,
            0,
            (LPBYTE *) &bufExtents,
            &cbBufExtents
            ))

       return false;



    VOLUME_DISK_EXTENTS *pDiskExtents = (VOLUME_DISK_EXTENTS *) bufExtents;

    // get number of disk extents
    DWORD cExtents = pDiskExtents->NumberOfDiskExtents;
    BS_ASSERT(cExtents > 0);

    if (cExtents == 0)
        {
        return false;
        }

    // sort extents by disk number and starting offset
    qsort
        (
        pDiskExtents->Extents,
        cExtents,
        sizeof(DISK_EXTENT),
        cmpDiskExtents
        );

    // count unique number of disks
    ULONG PrevDiskNo = pDiskExtents->Extents[0].DiskNumber;
    cLuns = 1;
    for (DWORD iExtent = 1; iExtent < cExtents; iExtent++)
        {
        if (pDiskExtents->Extents[iExtent].DiskNumber != PrevDiskNo)
            {
            PrevDiskNo = pDiskExtents->Extents[iExtent].DiskNumber;
            cLuns++;
            }
        }

    // allocate lun information
    rgLunInfo = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(sizeof(VDS_LUN_INFORMATION) * cLuns);
    if (rgLunInfo == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate LUN information array");

    // clear lun information in case we throw
    memset(rgLunInfo, 0, sizeof(VDS_LUN_INFORMATION) * cLuns);

    // make sure previous disk number is not a valid disk number
    // by making it one more than the highest disk number encountered
    PrevDiskNo++;
    UINT iLun = 0;
    for(UINT iExtent = 0; iExtent < cExtents; iExtent++)
        {
        ULONG DiskNo = pDiskExtents->Extents[iExtent].DiskNumber;
        // check for new disk
        if (DiskNo != PrevDiskNo)
            {
            // set previous disk number to current one so that all
            // other extents with same disk number are ignored.
            PrevDiskNo = DiskNo;
            WCHAR wszBuf[64];
            swprintf(wszBuf, L"\\\\.\\PHYSICALDRIVE%u", DiskNo);
            if (!BuildLunInfoForDrive(wszBuf, &rgLunInfo[iLun]))
                return false;

            iLun++;
            }
        }

    return true;
    }


bool CVssHardwareProviderWrapper::BuildLunInfoForDrive
    (
    LPCWSTR wszDriveName,
    VDS_LUN_INFORMATION *pLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildLunInfoForDrive");
    // open the device
    CVssAutoWin32Handle hDisk = CreateFile
                                    (
                                    wszDriveName,
                                    GENERIC_READ|GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL
                                    );

    if (hDisk == INVALID_HANDLE_VALUE)
        {
        // all errors are remapped (and potentially logged)
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"CreateFile(PhysicalDisk)");
        }


    LPBYTE bufQuery = NULL;
    try
        {
        // query to get STORAGE_DEVICE_OBJECT
        STORAGE_PROPERTY_QUERY query;
        DWORD cbQuery = 1024;

        query.PropertyId = StorageDeviceProperty;
        query.QueryType = PropertyStandardQuery;
        if (!DoDeviceIoControl
                (
                hDisk,
                IOCTL_STORAGE_QUERY_PROPERTY,
                (LPBYTE) &query,
                sizeof(query),
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            return false;

        // coerce to STORAGE_DEVICE_DESCRIPTOR
        STORAGE_DEVICE_DESCRIPTOR *pDesc = (STORAGE_DEVICE_DESCRIPTOR *) bufQuery;

        pLun->m_version = VER_VDS_LUN_INFORMATION;
        pLun->m_DeviceType = pDesc->DeviceType;
        pLun->m_DeviceTypeModifier = pDesc->DeviceTypeModifier;
        pLun->m_bCommandQueueing = pDesc->CommandQueueing;

        // copy bus type
        pLun->m_BusType = (VDS_STORAGE_BUS_TYPE) pDesc->BusType;

        // copy in various strings
        if (pDesc->VendorIdOffset)
            CopySDString(&pLun->m_szVendorId, pDesc, pDesc->VendorIdOffset);

        if (pDesc->ProductIdOffset)
            CopySDString(&pLun->m_szProductId, pDesc, pDesc->ProductIdOffset);

        if (pDesc->ProductRevisionOffset)
            CopySDString(&pLun->m_szProductRevision, pDesc, pDesc->ProductRevisionOffset);

        if (pDesc->SerialNumberOffset)
            CopySDString(&pLun->m_szSerialNumber, pDesc, pDesc->SerialNumberOffset);

        // query for STORAGE_DEVICE_ID_DESCRIPTOR
        query.PropertyId = StorageDeviceIdProperty;
        query.QueryType = PropertyStandardQuery;

        if (!DoDeviceIoControl
                (
                hDisk,
                IOCTL_STORAGE_QUERY_PROPERTY,
                (LPBYTE) &query,
                sizeof(query),
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            {
            pLun->m_deviceIdDescriptor.m_version = 0;
            pLun->m_deviceIdDescriptor.m_cIdentifiers = 0;
            }
        else
            {
            // coerce buffer to STORAGE_DEVICE_ID_DESCRIPTOR
            STORAGE_DEVICE_ID_DESCRIPTOR *pDevId = (STORAGE_DEVICE_ID_DESCRIPTOR *) bufQuery;
            CopyStorageDeviceIdDescriptorToLun(pDevId, pLun);
            }

        if (DoDeviceIoControl
                (
                hDisk,
                IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                NULL,
                0,
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            {
            DRIVE_LAYOUT_INFORMATION_EX *pLayout = (DRIVE_LAYOUT_INFORMATION_EX *) bufQuery;
            VSS_ID signature = GUID_NULL;

            switch(pLayout->PartitionStyle)
                {
                default:
                    BS_ASSERT(FALSE);
                    break;

                case PARTITION_STYLE_RAW:
                    break;

                case PARTITION_STYLE_GPT:
                    // use GPT DiskId as signature
                    signature = pLayout->Gpt.DiskId;
                    break;

                case PARTITION_STYLE_MBR:
                    // use 32 bit Mbr signature as high part of guid.  Remainder
                    // of guid is 0.
                    signature.Data1 = pLayout->Mbr.Signature;
                    break;
                }

            // save disk signature
            pLun->m_diskSignature = signature;
            }
        }
    catch(...)
        {
        delete bufQuery;
        throw;
        }

    delete bufQuery;
    return true;
    }




// determine if all the luns composing a volume are supported by this
// provider.
STDMETHODIMP CVssHardwareProviderWrapper::IsVolumeSupported
    (
    IN VSS_PWSZ wszVolumeName,
    OUT BOOL *pbIsSupported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsVolumeSupported");

    BS_ASSERT(BusTypeUnknown == VDSBusTypeUnknown);
    BS_ASSERT(BusTypeScsi == VDSBusTypeScsi);
    BS_ASSERT(BusTypeAtapi == VDSBusTypeAtapi);
    BS_ASSERT(BusTypeAta == VDSBusTypeAta);
    BS_ASSERT(BusType1394 == VDSBusType1394);
    BS_ASSERT(BusTypeSsa == VDSBusTypeSsa);
    BS_ASSERT(BusTypeFibre == VDSBusTypeFibre);
    BS_ASSERT(BusTypeUsb == VDSBusTypeUsb);
    BS_ASSERT(BusTypeRAID == VDSBusTypeRAID);

    // buffer for VOLUME_DISK_EXTENTS structure
    BYTE *bufExtents = NULL;

    // buffer for various device queries
    BYTE *bufQuery = NULL;

    // allocated lun information
    VDS_LUN_INFORMATION *rgLunInfo = NULL;

    // number of luns found
    UINT cLuns = 0;

    // volume name copy, updated to remove final slash
    LPWSTR wszVolumeNameCopy = NULL;
    try
        {
        // if called multiple times with same volume, don't do anything
        if (m_wszOriginalVolumeName)
            {
            if (wcscmp(m_wszOriginalVolumeName, wszVolumeName) == 0)
                {
                *pbIsSupported = true;
                throw S_OK;
                }
            else
                DeleteCachedInfo();
            }

        wszVolumeNameCopy = new WCHAR[wcslen(wszVolumeName) + 1];

        if (wszVolumeNameCopy == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

        wcscpy(wszVolumeNameCopy, wszVolumeName);
        if (wszVolumeNameCopy[wcslen(wszVolumeName) - 1] == L'\\')
            wszVolumeNameCopy[wcslen(wszVolumeName) - 1] = L'\0';

        if (!BuildLunInfoFromVolume
                (
                wszVolumeNameCopy,
                bufExtents,
                cLuns,
                rgLunInfo
                ))
            {
            *pbIsSupported = false;
            throw S_OK;
            }

        // call AreLunsSupported with the lun information and the context
        // for the snapshot
        ft.hr = m_pHWItf->AreLunsSupported
            (
            (LONG) cLuns,
            m_lContext,
            rgLunInfo,
            pbIsSupported
            );

        // remap any provider failures
        if (ft.HrFailed())
            ft.TranslateProviderError
                (
                VSSDBG_COORD,
                m_ProviderId,
                L"IVssSnapshotSnapshotProvider::AreLunsSupported failed with error 0x%08lx",
                ft.hr
                );

        if(*pbIsSupported)
            {
            // provider is chose.  Save way original volume name
            m_wszOriginalVolumeName = new WCHAR[wcslen(wszVolumeName) + 1];
            if (m_wszOriginalVolumeName == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate volume name");

            wcscpy(m_wszOriginalVolumeName, wszVolumeName);

            // save away lun information
            m_rgLunInfoProvider = rgLunInfo;
            m_cLunInfoProvider = cLuns;

            // don't free up the lun information
            rgLunInfo = NULL;
            cLuns = 0;

            // save disk extent information
            m_pExtents = (VOLUME_DISK_EXTENTS *) bufExtents;

            // don't free up the extents buffer
            bufExtents = NULL;
            }
        }
    VSS_STANDARD_CATCH(ft)

    // free up lun info if not NULL
    FreeLunInfo(rgLunInfo, cLuns);

    delete wszVolumeNameCopy;

    // free up buffers used for ioctls
    delete bufExtents;
    delete bufQuery;

    return ft.hr;
    }

// wrapper for provider BeginPrepareSnapshot call.  Uses
// lun information cached during AreLunsSupported call.
STDMETHODIMP CVssHardwareProviderWrapper::BeginPrepareSnapshot
    (
    IN VSS_ID SnapshotSetId,
    IN VSS_ID SnapshotId,
    IN VSS_PWSZ wszVolumeName
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BeginPrepareSnapshot");

    // make sure volume name is valid
    BS_ASSERT(wcscmp(wszVolumeName, m_wszOriginalVolumeName) == 0);

    // temporary computer name string
    LPWSTR wszComputerName = NULL;
    try
        {
        // make sure persistent snapshot set data is loaded
        CheckLoaded();

        // save snapshot set id
        m_SnapshotSetId = SnapshotSetId;

        // save away state
        m_eState = VSS_SS_PROCESSING_PREPARE;

        // call provider BeginPrepareSnapshot with cached lun information
        ft.hr = m_pHWItf->BeginPrepareSnapshot
                    (
                    SnapshotSetId,
                    SnapshotId,
                    m_lContext,
                    (LONG) m_cLunInfoProvider,
                    m_rgLunInfoProvider
                    );

        // Check if the volume is a non-supported one.
        if (ft.hr == E_INVALIDARG)
            ft.Throw
                (
                VSSDBG_COORD,
                E_INVALIDARG,
                L"Invalid arguments to BeginPrepareSnapshot for provider " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(m_ProviderId)
                );

        if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER)
            {
            BS_ASSERT( m_ProviderId != GUID_NULL );
            ft.Throw
                (VSSDBG_COORD,
                VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume %s not supported by provider " WSTR_GUID_FMT,
                wszVolumeName,
                GUID_PRINTF_ARG(m_ProviderId)
                );
            }

        if (ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED)
            ft.Throw
                (
                VSSDBG_COORD,
                VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
                L"Volume %s has too many snapshots" WSTR_GUID_FMT,
                wszVolumeName,
                GUID_PRINTF_ARG(m_ProviderId)
                );

        if (ft.HrFailed())
            ft.TranslateProviderError
                (
                VSSDBG_COORD,
                m_ProviderId,
                L"BeginPrepareSnapshot("WSTR_GUID_FMT L",%s)",
                GUID_PRINTF_ARG(m_ProviderId),
                wszVolumeName
                );

        // allocate snapshot set description object if there is not yet one
        // allocated for this snapshot set.
        if (m_pSnapshotSetDescription == NULL)
            {
            ft.hr = CreateVssSnapshotSetDescription
                        (
                        m_SnapshotSetId,
                        m_lContext,
                        &m_pSnapshotSetDescription
                        );

            ft.CheckForErrorInternal(VSSDBG_COORD, L"CreateVssSnapshotSetDescription");
            }

        BS_ASSERT(m_pSnapshotSetDescription);

        // create snapshot description object for this volume
        ft.hr = m_pSnapshotSetDescription->AddSnapshotDescription(SnapshotId, m_ProviderId);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::AddSnapshotDescription");


        // obtain snapshot description just created
        CComPtr<IVssSnapshotDescription> pSnapshotDescription;
        ft.hr = m_pSnapshotSetDescription->FindSnapshotDescription(SnapshotId, &pSnapshotDescription);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnaphotSetDescription::FindSnapshotDescription");

        BS_ASSERT(pSnapshotDescription);

        wszComputerName = GetLocalComputerName();
        // set originating machine and computer name
        ft.hr = pSnapshotDescription->SetOrigin(wszComputerName, wszVolumeName);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetOrigin");

        // set service machine
        ft.hr = pSnapshotDescription->SetServiceMachine(wszComputerName);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetServiceMachine");

        // set attributes.  Will be the same as the context with the additional
        // indication that the snapshot is surfaced by a hardware provider
        ft.hr = pSnapshotDescription->SetAttributes(m_lContext | VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::SetAttributes");

        // add a mapping for each lun
        for(UINT iLun = 0; iLun < m_cLunInfoProvider; iLun++)
            {
            ft.hr = pSnapshotDescription->AddLunMapping();
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::AddLunMapping");
            }

        // number of extents
        UINT cExtents = m_pExtents->NumberOfDiskExtents;

        // first extent and disk
        DISK_EXTENT *pExtent = m_pExtents->Extents;
        ULONG PrevDiskNo = pExtent->DiskNumber;

        // just past last extent
        DISK_EXTENT *pExtentMax = pExtent + cExtents;

        for(UINT iLun = 0; iLun < m_cLunInfoProvider; iLun++)
            {
            CComPtr<IVssLunMapping> pLunMapping;

            ft.hr = pSnapshotDescription->GetLunMapping(iLun, &pLunMapping);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetLunMapping");

            // add extents for the current disk
            for (; pExtent < pExtentMax && pExtent->DiskNumber == PrevDiskNo; pExtent++)
                {
                ft.hr = pLunMapping->AddDiskExtent
                            (
                            pExtent->StartingOffset.QuadPart,
                            pExtent->ExtentLength.QuadPart
                            );

                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunMapping::AddDiskExtent");
                }
            }

        // save all lun information
        SaveLunInformation
            (
            pSnapshotDescription,
            false,
            m_rgLunInfoProvider,
            m_cLunInfoProvider
            );

        m_eState = VSS_SS_PREPARING;
        }
    VSS_STANDARD_CATCH(ft)

    DeleteCachedInfo();

    // delete temporary computer name
    delete wszComputerName;

    return ft.hr;
    }

// routine called after snapshot is created.  This call GetTargetLuns to
// get the target luns and then persists all the snapshot information into
// the backup components document by using the IVssWriterCallback::SetContent
// method
STDMETHODIMP CVssHardwareProviderWrapper::PostSnapshot
    (
    IN IDispatch *pCallback
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PostSnapshot");

    // array of destination luns
    VDS_LUN_INFORMATION *rgDestLuns = NULL;
    LUN_MAPPING_STRUCTURE *pMapping = NULL;

    // array of source luns
    VDS_LUN_INFORMATION *rgSourceLuns = NULL;
    UINT cSourceLuns = 0;
    try
        {
        BS_ASSERT(m_pHWItf);
        BS_ASSERT(m_pSnapshotSetDescription);
        CComBSTR bstrXML;
        UINT cSnapshots;

        // get count of snapshots in the snapshot set
        ft.hr = m_pSnapshotSetDescription->GetSnapshotCount(&cSnapshots);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

        // loop through the snampshots
        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            {
            CComPtr<IVssSnapshotDescription> pSnapshot;

            // get snapshot description
            ft.hr = m_pSnapshotSetDescription->GetSnapshotDescription(iSnapshot, &pSnapshot);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

            // get source lun information for the snapshot
            GetLunInformation(pSnapshot, false, &rgSourceLuns, &cSourceLuns);

            // call provider to get the corresponding target luns
            ft.hr = m_pHWItf->GetTargetLuns
                (
                cSourceLuns,
                rgSourceLuns,
                &rgDestLuns
                );

            // remap and throw any failures
            if (ft.HrFailed())
                ft.TranslateProviderError(VSSDBG_COORD, m_ProviderId, L"IVssHardwareSnapshotProvider::GetTargetLuns");

            // save destination lun information into the snapshot set description
            SaveLunInformation(pSnapshot, true, rgDestLuns, cSourceLuns);

            // free up surce and destination luns
            FreeLunInfo(rgDestLuns, cSourceLuns);
            FreeLunInfo(rgSourceLuns, cSourceLuns);
            rgSourceLuns = NULL;
            rgDestLuns = NULL;
            cSourceLuns = 0;

            // set timestamp for the snapshot
            CVsFileTime timeNow;
            pSnapshot->SetTimestamp(timeNow);
            }


        // save snapshot set description as XML string
        ft.hr = m_pSnapshotSetDescription->SaveAsXML(&bstrXML);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::SaveAsXML");

        if (pCallback)
            {
            // get IVssWriterCallback interface from IDispatch passed to us
            // from the requestor process.
            CComPtr<IVssWriterCallback> pWriterCallback;
            ft.hr = pCallback->SafeQI(IVssWriterCallback, &pWriterCallback);
            if (ft.HrFailed())
                {
                // log any failure
                ft.LogError(VSS_ERROR_QI_IVSSWRITERCALLBACK, VSSDBG_COORD << ft.hr);
                ft.Throw
                    (
                    VSSDBG_COORD,
                    E_UNEXPECTED,
                    L"Error querying for IVssWriterCallback interface.  hr = 0x%08lx",
                    ft.hr
                    );
                }

            // special GUID indicating that this is the snapshot service
            // making the callback.
            CComBSTR bstrSnapshotService = idVolumeSnapshotService;

            // add the snapshot set description to the backup components document
            ft.hr = pWriterCallback->SetContent(bstrSnapshotService, bstrXML);
            ft.CheckForError(VSSDBG_COORD, L"IVssWriterCallback::SetContent");
            }

        if ((m_lContext & VSS_VOLSNAP_ATTR_TRANSPORTABLE) == 0)
            {
            BuildLunMappingStructure(m_pSnapshotSetDescription, &pMapping);
            LocateAndExposeVolumes(pMapping, false);
            WriteDeviceNames(m_pSnapshotSetDescription, pMapping);
            }

        // construct a new snapshot set list element.  We hold onto the snapshot
        // set description in order to answer queries about the snapshot set
        // and also to persist information on service shutdown
        VSS_SNAPSHOT_SET_LIST *pNewElt = new VSS_SNAPSHOT_SET_LIST;
        if (pNewElt == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Couldn't allocate snapshot set list element");

            {
            // append new element to list
            // list is protected by critical section
            CVssSafeAutomaticLock lock(m_csList);

            pNewElt->m_next = m_pList;
            pNewElt->m_pDescription = m_pSnapshotSetDescription.Detach();
            m_pList = pNewElt;
            if ((m_lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
                {
                m_bChanged = true;
                TrySaveData();
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    // free up lun mapping structure if allocated
    DeleteLunMappingStructure(pMapping);

    if (ft.HrFailed())
        {
        if (rgDestLuns != NULL)
            {
            // we have gottent the target luns from the provider but for
            // some reason the snapshot set could not be created.  Check
            // to see if any of the destination luns are now totally free.
            CancelSnapshotOnLuns(rgDestLuns, cSourceLuns);
            FreeLunInfo(rgDestLuns, cSourceLuns);
            }

        // we failed somewhere in this routine before snapshot set could
        // be successfully created.  check to see if we have destination
        // luns and if so whether any of those luns are free.
        CancelCreatedSnapshots();

        // free any source luns we have
        FreeLunInfo(rgSourceLuns, cSourceLuns);
        }
    else
        {
        // no longer working on this snapshot
        m_SnapshotSetId = GUID_NULL;
        }

    m_pSnapshotSetDescription = NULL;
    return ft.hr;
    }

// build VSS_SNAPSHOT_PROP structure from a snapshot set description and
// snapshot description.
void CVssHardwareProviderWrapper::BuildSnapshotProperties
    (
    IN IVssSnapshotSetDescription *pSnapshotSet,
    IN IVssSnapshotDescription *pSnapshot,
    IN VSS_SNAPSHOT_STATE eState,
    OUT VSS_SNAPSHOT_PROP *pProp
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildSnapshotProperties");

    UINT cSnapshots;
    VSS_ID SnapshotSetId;
    VSS_ID SnapshotId;
    CComBSTR bstrOriginalVolume;
    CComBSTR bstrOriginatingMachine;
    CComBSTR bstrServiceMachine;
    CComBSTR bstrDeviceName;
    LONG lContext;
    VSS_TIMESTAMP timestamp;

    // get snapshot set id
    ft.hr = pSnapshotSet->GetSnapshotSetId(&SnapshotSetId);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

    // get snapshot context
    ft.hr = pSnapshotSet->GetContext(&lContext);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

    // get count of snapshots
    ft.hr = pSnapshotSet->GetSnapshotCount(&cSnapshots);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

    // get snapshot id
    ft.hr = pSnapshot->GetSnapshotId(&SnapshotId);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetSnapshotId");

    // get snapshot timestamp
    ft.hr = pSnapshot->GetTimestamp(&timestamp);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetTimestamp");

    // get originating machine and original volume name
    ft.hr = pSnapshot->GetOrigin(&bstrOriginatingMachine, &bstrOriginalVolume);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetOrigin");

    // get service machine
    ft.hr = pSnapshot->GetServiceMachine(&bstrServiceMachine);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetServiceMachine");

    // get device name
    ft.hr = pSnapshot->GetDeviceName(&bstrDeviceName);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetDeviceName");

    VSS_PWSZ wszDeviceName = NULL;
    VSS_PWSZ wszOriginatingMachine = NULL;
    VSS_PWSZ wszOriginalVolume = NULL;
    VSS_PWSZ wszServiceMachine = NULL;
    try
        {
        CreateCoTaskString(ft, bstrDeviceName, wszDeviceName);
        CreateCoTaskString(ft, bstrOriginalVolume, wszOriginalVolume);
        CreateCoTaskString(ft, bstrOriginatingMachine, wszOriginatingMachine);
        CreateCoTaskString(ft, bstrServiceMachine, wszServiceMachine);
        }
    catch(...)
        {
        if (wszDeviceName)
            CoTaskMemFree(wszDeviceName);

        if (wszOriginatingMachine)
            CoTaskMemFree(wszOriginatingMachine);

        if (wszOriginalVolume)
            CoTaskMemFree(wszOriginalVolume);

        throw;
        }


    // copy values into property structure
    pProp->m_SnapshotId = SnapshotId;
    pProp->m_SnapshotSetId = SnapshotSetId;
    pProp->m_ProviderId = m_ProviderId;
    pProp->m_lSnapshotsCount = (LONG) cSnapshots;
    pProp->m_lSnapshotAttributes = lContext | VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED;
    pProp->m_eStatus = eState;
    pProp->m_pwszSnapshotDeviceObject = wszDeviceName;
    pProp->m_pwszOriginalVolumeName = wszOriginalVolume;
    pProp->m_pwszOriginatingMachine = wszOriginatingMachine;
    pProp->m_pwszServiceMachine = wszServiceMachine;
    pProp->m_tsCreationTimestamp = timestamp;
    }



// determine if a particular snapshot belongs to a snapshot set and if
// so return its properties
bool CVssHardwareProviderWrapper::FindSnapshotProperties
    (
    IN IVssSnapshotSetDescription *pSnapshotSet,
    IN VSS_ID SnapshotId,
    IN VSS_SNAPSHOT_STATE eState,
    OUT VSS_SNAPSHOT_PROP *pProp
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::FindSnapshotProperties");

    CComPtr<IVssSnapshotDescription> pSnapshot;
    ft.hr = pSnapshotSet->FindSnapshotDescription(SnapshotId, &pSnapshot);
    if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        return false;

    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::FindSnapshotDescription");

    BuildSnapshotProperties(pSnapshotSet, pSnapshot, eState, pProp);
    return true;
    }

// obtain the properties of a specific snapshot
STDMETHODIMP CVssHardwareProviderWrapper::GetSnapshotProperties
    (
    IN      VSS_ID          SnapshotId,
    OUT     VSS_SNAPSHOT_PROP   *pProp
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::GetSnapshotProperties");

    bool bFound = false;
    try
        {
        if (pProp == NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL output parameter");

        memset(pProp, 0, sizeof(VSS_SNAPSHOT_PROP));

        CheckLoaded();

        if (m_pSnapshotSetDescription &&
            FindSnapshotProperties
                (
                m_pSnapshotSetDescription,
                SnapshotId,
                m_eState,
                pProp
                ))
            bFound = true;

        VSS_SNAPSHOT_SET_LIST *pList = m_pList;
        while(!bFound && pList)
            {
            if (FindSnapshotProperties
                    (
                    pList->m_pDescription,
                    SnapshotId,
                    VSS_SS_CREATED,
                    pProp
                    ))
                bFound = true;
            // Go to the next element
            pList = pList->m_next;
            }

        if (!bFound)
            ft.hr = VSS_E_OBJECT_NOT_FOUND;
        }
    VSS_STANDARD_CATCH(ft);

    return ft.hr;
    }

STDMETHODIMP CVssHardwareProviderWrapper::Query
    (
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::Query");

    try
        {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        ft.Trace( VSSDBG_COORD, L"Parameters: QueriedObjectId = " WSTR_GUID_FMT
                  L"eQueriedObjectType = %d. eReturnedObjectsType = %d, ppEnum = %p",
                  GUID_PRINTF_ARG( QueriedObjectId ),
                  eQueriedObjectType,
                  eReturnedObjectsType,
                  ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if (eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
        BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
        // The only purpose of this is to use a smart ptr to destroy correctly the array on error.
        // Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        CheckLoaded();

        // Snapshot set list is protected by critical section
        CVssSafeAutomaticLock lock(m_csList);

        // Get the list of snapshots in the give array
        CVssHardwareProviderWrapper::EnumerateSnapshots( m_lContext, pArray);

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
        // Now pEnumObject's reference count becomes 1 (because of the smart pointer).
        // So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
        // The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
        ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
        // The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

        BS_ASSERT( !ft.HrFailed() );
        ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CVssHardwareProviderWrapper::DeleteSnapshots
    (
    IN      VSS_ID          SourceObjectId,
    IN      VSS_OBJECT_TYPE eSourceObjectType,
    IN      BOOL            bForceDelete,
    OUT     LONG*           plDeletedSnapshots,
    OUT     VSS_ID*         pNonDeletedSnapshotID
    )
    {
    UNREFERENCED_PARAMETER(bForceDelete);

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DeleteSnapshots");

    try
        {
        BS_ASSERT(pNonDeletedSnapshotID);
        BS_ASSERT(plDeletedSnapshots);
        BS_ASSERT(eSourceObjectType == VSS_OBJECT_SNAPSHOT_SET ||
                  eSourceObjectType == VSS_OBJECT_SNAPSHOT);

        CheckLoaded();

        if (eSourceObjectType == VSS_OBJECT_SNAPSHOT_SET)
            InternalDeleteSnapshotSet
                (
                SourceObjectId,
                plDeletedSnapshots,
                pNonDeletedSnapshotID
                );
        else
            {
            *plDeletedSnapshots = 0;
            *pNonDeletedSnapshotID = SourceObjectId;
            InternalDeleteSnapshot(SourceObjectId);
            *plDeletedSnapshots = 1;
            *pNonDeletedSnapshotID = GUID_NULL;
            }

        TrySaveData();
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CVssHardwareProviderWrapper::IsVolumeSnapshotted
    (
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
    OUT     LONG *          plSnapshotCompatibility
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsVolumeSnapshotted");
    try
        {
        VssZeroOut(pbSnapshotsPresent);
        VssZeroOut(plSnapshotCompatibility);

        if (plSnapshotCompatibility == NULL ||
            pbSnapshotsPresent == NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL output parameter.");

        if (pwszVolumeName == NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL required input parameter");
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// mark the snapshot set as ReadWrite
STDMETHODIMP CVssHardwareProviderWrapper::MakeSnapshotReadWrite
    (
    IN      VSS_ID          SourceObjectId
    )
    {
    UNREFERENCED_PARAMETER(SourceObjectId);

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::MakeSnapshotReadWrite");


    return ft.hr;
    }


STDMETHODIMP CVssHardwareProviderWrapper::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::SetSnapshotProperty");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(eSnapshotPropertyId);
    UNREFERENCED_PARAMETER(vProperty);
}




// call provider with EndPrepareSnapshots.  Upon successful completion of
// this call all snapshots in the set are prepared
STDMETHODIMP CVssHardwareProviderWrapper::EndPrepareSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::EndPrepareSnapshots");

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);
    try
        {
        ft.hr = m_pCreationItf->EndPrepareSnapshots(SnapshotSetId);
        HideVolumes();
        }
    VSS_STANDARD_CATCH(ft)

    if (!ft.HrFailed())
        m_eState = VSS_SS_PREPARED;

    return ft.hr;
    }

void CVssHardwareProviderWrapper::HideVolumes()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::HideVolumes");

    BS_ASSERT(m_pSnapshotSetDescription);
    CComBSTR bstrXML;
    UINT cSnapshots;
    DWORD *rgwHiddenDrives;
    DWORD cwHiddenDrives = 64;

    rgwHiddenDrives = new DWORD[cwHiddenDrives];
    if (rgwHiddenDrives == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate bitmap");

    memset(rgwHiddenDrives, 0, sizeof(DWORD) * cwHiddenDrives);

    try
        {
        // get count of snapshots in the snapshot set
        ft.hr = m_pSnapshotSetDescription->GetSnapshotCount(&cSnapshots);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

        m_rghVolumes = new HANDLE[cSnapshots];
        m_chVolumes = cSnapshots;
        if (m_rghVolumes == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate handle array");

        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            m_rghVolumes[iSnapshot] = INVALID_HANDLE_VALUE;

        // loop through the snampshots
        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            {
            CComPtr<IVssSnapshotDescription> pSnapshot;
            CComBSTR bstrOriginalVolume;
            CComBSTR bstrOriginalMachine;

            // get snapshot description
            ft.hr = m_pSnapshotSetDescription->GetSnapshotDescription(iSnapshot, &pSnapshot);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

            ft.hr = pSnapshot->GetOrigin(&bstrOriginalMachine, &bstrOriginalVolume);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSet::GetOrigin");
            WCHAR wsz[128];

            wcscpy(wsz, bstrOriginalVolume);

            // get rid of trailing backslash
            wsz[wcslen(wsz) - 1] = L'\0';

            m_rghVolumes[iSnapshot] =
                CreateFile
                    (
                    wsz,
                    0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE
                    );

            if (m_rghVolumes[iSnapshot] == INVALID_HANDLE_VALUE)
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForErrorInternal(VSSDBG_COORD, L"CreateFile(VOLUME)");
                }


            STORAGE_DEVICE_NUMBER devnumber;
            DWORD size;

            if (DeviceIoControl
                    (
                    m_rghVolumes[iSnapshot],
                    IOCTL_STORAGE_GET_DEVICE_NUMBER,
                    NULL,
                    0,
                    &devnumber,
                    sizeof(devnumber),
                    &size,
                    NULL
                    ))
                {
                ULONG Disk = devnumber.DeviceNumber;
                if (Disk * 32 > cwHiddenDrives)
                    {
                    DWORD *rgwNew = new DWORD[cwHiddenDrives * 2];
                    if (rgwNew == NULL)
                        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot grow bitmap");

                    memcpy(rgwNew, rgwHiddenDrives, cwHiddenDrives);
                    delete rgwHiddenDrives;
                    rgwHiddenDrives = rgwNew;
                    cwHiddenDrives *= 2;
                    }
                else if ((rgwHiddenDrives[Disk/32] & (1 << (Disk % 32))) != 0)
                    {
                    // close handle since we don't need it
                    CloseHandle(m_rghVolumes[iSnapshot]);
                    m_rghVolumes[iSnapshot] = INVALID_HANDLE_VALUE;

                    // don't hide a drive that we have already hidden
                    continue;
                    }
                else
                    // mark drive as hidden
                    rgwHiddenDrives[Disk/32] |= 1 << (Disk % 32);
                }


            VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   getAttributesInfo;
            VOLUME_SET_GPT_ATTRIBUTES_INFORMATION setAttributesInfo;

            if (!DeviceIoControl
                    (
                    m_rghVolumes[iSnapshot],
                    IOCTL_VOLUME_GET_GPT_ATTRIBUTES,
                    NULL,
                    0,
                    &getAttributesInfo,
                    sizeof(getAttributesInfo),
                    &size,
                    NULL
                    ))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl(IOCTL_VOLUME_GET_GPT_ATTRIBUTES)");
                }

            // mark drive as hidden, read-only, and no drive letter
            memset(&setAttributesInfo, 0, sizeof(setAttributesInfo));
            setAttributesInfo.GptAttributes = getAttributesInfo.GptAttributes;
            setAttributesInfo.ApplyToAllConnectedVolumes = TRUE;
            setAttributesInfo.GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_HIDDEN|GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER|GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY;
            setAttributesInfo.RevertOnClose = true;
            if (!DeviceIoControl
                    (
                    m_rghVolumes[iSnapshot],
                    IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
                    &setAttributesInfo,
                    sizeof(setAttributesInfo),
                    NULL,
                    0,
                    &size,
                    NULL
                    ))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForErrorInternal(VSSDBG_COORD, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                }
            }
        }
    catch(...)
        {
        delete rgwHiddenDrives;
        throw;
        }

    delete rgwHiddenDrives;
    }



// call provider with PreCommitSnapshots
STDMETHODIMP CVssHardwareProviderWrapper::PreCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PreCommitSnapshots");

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);

    try
        {
        BS_ASSERT(m_pHWItf);

        m_eState = VSS_SS_PROCESSING_PRECOMMIT;
        ft.hr = m_pCreationItf->PreCommitSnapshots(SnapshotSetId);
        }
    VSS_STANDARD_CATCH(ft)

    if (!ft.HrFailed())
        m_eState = VSS_SS_PRECOMMITTED;


    return ft.hr;
    }

// call provider with CommitSnapshots
STDMETHODIMP CVssHardwareProviderWrapper::CommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CommitSnapshots");

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);

    m_eState = VSS_SS_PROCESSING_COMMIT;
    ft.hr = m_pCreationItf->CommitSnapshots(SnapshotSetId);
    if (!ft.HrFailed())
        ft.hr = VSS_SS_COMMITTED;


    return ft.hr;
    }

void CVssHardwareProviderWrapper::CloseVolumeHandles()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CloseVolumeHandles");

    for(UINT ih = 0; ih < m_chVolumes; ih++)
        {
        if (m_rghVolumes[ih] != INVALID_HANDLE_VALUE)
            {
            CloseHandle(m_rghVolumes[ih]);
            m_rghVolumes[ih] = INVALID_HANDLE_VALUE;
            }
        }

    m_chVolumes = 0;
    delete m_rghVolumes;
    m_rghVolumes = NULL;
    }



// call provider with PostCommitSnapshots
STDMETHODIMP CVssHardwareProviderWrapper::PostCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::PostCommitSnapshots");

    try
        {
        BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
        BS_ASSERT(m_pCreationItf);

        m_eState = VSS_SS_PROCESSING_POSTCOMMIT;

        CloseVolumeHandles();
        ft.hr = m_pCreationItf->PostCommitSnapshots(SnapshotSetId, lSnapshotsCount);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// abort snapshot creation that is in progress
STDMETHODIMP CVssHardwareProviderWrapper::AbortSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AbortSnapshots");

    BS_ASSERT(SnapshotSetId == m_SnapshotSetId);
    BS_ASSERT(m_pCreationItf);

    m_eState = VSS_SS_ABORTED;
    CloseVolumeHandles();
    ft.hr = m_pCreationItf->AbortSnapshots(SnapshotSetId);



    m_SnapshotSetId = GUID_NULL;
    return ft.hr;
    }



// cancel snapshots after set of destination luns for a snapshot
// are determined.
void CVssHardwareProviderWrapper::CancelSnapshotOnLuns
    (
    VDS_LUN_INFORMATION *rgLunInfo,
    LONG cLuns
    )
    {
    UNREFERENCED_PARAMETER(rgLunInfo);
    UNREFERENCED_PARAMETER(cLuns);

    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CancelSnapshotOnLuns");
    }

// save VDS_LUN_INFORMATION array into SNAPSHOT_DESCRIPTION XML document.
void CVssHardwareProviderWrapper::SaveLunInformation
    (
    IN IVssSnapshotDescription *pSnapshotDescription,
    IN bool bDest,
    IN VDS_LUN_INFORMATION *rgLunInfo,
    IN UINT cLunInfo
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::SaveLunInformation");

    // loop through luns
    for(UINT iLunInfo = 0; iLunInfo < cLunInfo; iLunInfo++)
        {
        CComPtr<IVssLunInformation> pLunInfo;
        CComPtr<IVssLunMapping> pLunMapping;
        VDS_LUN_INFORMATION *pLun = &rgLunInfo[iLunInfo];

        // get lun mapping
        ft.hr = pSnapshotDescription->GetLunMapping(iLunInfo, &pLunMapping);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetLunMapping");

        // get XML node for either source or destination lun
        if(bDest)
            ft.hr = pLunMapping->GetDestinationLun(&pLunInfo);
        else
            ft.hr = pLunMapping->GetSourceLun(&pLunInfo);

        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunMapping::GetSourceLun");

        // save basic lun information into XML document
        ft.hr = pLunInfo->SetLunBasicType
                    (
                    pLun->m_DeviceType,
                    pLun->m_DeviceTypeModifier,
                    pLun->m_bCommandQueueing,
                    pLun->m_szVendorId,
                    pLun->m_szProductId,
                    pLun->m_szProductRevision,
                    pLun->m_szSerialNumber,
                    pLun->m_BusType
                    );

        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::SetBasicType");

        // save disk signature
        ft.hr = pLunInfo->SetDiskSignature(pLun->m_diskSignature);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::SetDiskSignature");


        // convert VDS_STORAGE_DEVICE_ID_DESCRIPTOR to STORAGE_DEVICE_ID_DESCRIPTOR
        STORAGE_DEVICE_ID_DESCRIPTOR *pStorageDeviceIdDescriptor =
            BuildStorageDeviceIdDescriptor(&pLun->m_deviceIdDescriptor);

        try
            {
            // save STORAGE_DEVICE_ID_DESCRIPTOR in XML document
            ft.hr = pLunInfo->SetStorageDeviceIdDescriptor(pStorageDeviceIdDescriptor);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"ILunInformation::SetStorageDeviceIdDescriptor");
            }
        catch(...)
            {
            // free temporary STORAGE_DEVICE_ID_DESCRIPTOR
            CoTaskMemFree(pStorageDeviceIdDescriptor);
            throw;
            }

        // free temporary STORAGE_DEVICE_ID_DESCRIPTOR
        CoTaskMemFree(pStorageDeviceIdDescriptor);

        // get count of interconnect addresses
        ULONG cInterconnects = pLun->m_cInterconnects;
        VDS_INTERCONNECT *pInterconnect = pLun->m_rgInterconnects;
        for(UINT iInterconnect = 0; iInterconnect < cInterconnects; iInterconnect++, pInterconnect++)
            {
            // add each interconnect address
            ft.hr = pLunInfo->AddInterconnectAddress
                        (
                        pInterconnect->m_addressType,
                        pInterconnect->m_cbPort,
                        pInterconnect->m_pbPort,
                        pInterconnect->m_cbAddress,
                        pInterconnect->m_pbAddress
                        );

            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::AddInterconnectAddress");
            }
        }
    }

// obtain either source or destination lun information from the
// snapshot description and convert it to a VDS_LUN_INFORMATION array
void CVssHardwareProviderWrapper::GetLunInformation
    (
    IN IVssSnapshotDescription *pSnapshotDescription,
    IN bool bDest,
    OUT VDS_LUN_INFORMATION **prgLunInfo,
    OUT UINT *pcLunInfo
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::GetLunInformation");

    // obtain count of luns
    UINT cLuns;
    ft.hr = pSnapshotDescription->GetLunCount(&cLuns);
    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetLunCount");

    // allocate array of luns
    VDS_LUN_INFORMATION *rgLunInfo =
        (VDS_LUN_INFORMATION *) CoTaskMemAlloc(cLuns * sizeof(VDS_LUN_INFORMATION));

    if (rgLunInfo == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate lun information array");

    // clear lun information so that if we throw this field is cleared
    memset(rgLunInfo, 0, cLuns * sizeof(VDS_LUN_INFORMATION));

    STORAGE_DEVICE_ID_DESCRIPTOR *pStorageDeviceIdDescriptor = NULL;

    try
        {
        for(UINT iLun = 0; iLun < cLuns; iLun++)
            {
            CComPtr<IVssLunInformation> pLunInfo;
            CComPtr<IVssLunMapping> pLunMapping;

            VDS_LUN_INFORMATION *pLun = &rgLunInfo[iLun];

            ft.hr = pSnapshotDescription->GetLunMapping(iLun, &pLunMapping);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetLunMapping");

            // get appropriate lun information based on whether we are
            // looking for a destination or source lun
            if(bDest)
                ft.hr = pLunMapping->GetDestinationLun(&pLunInfo);
            else
                ft.hr = pLunMapping->GetSourceLun(&pLunInfo);

            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunMapping::GetSourceLun");

            // get standard information about the lun
            ft.hr = pLunInfo->GetLunBasicType
                        (
                        &pLun->m_DeviceType,
                        &pLun->m_DeviceTypeModifier,
                        &pLun->m_bCommandQueueing,
                        &pLun->m_szVendorId,
                        &pLun->m_szProductId,
                        &pLun->m_szProductRevision,
                        &pLun->m_szSerialNumber,
                        &pLun->m_BusType
                        );

            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::GetLunBasicType");

            // get disk signature
            ft.hr = pLunInfo->GetDiskSignature(&pLun->m_diskSignature);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::GetDiskSignature");

            // get storage device id descriptor
            ft.hr = pLunInfo->GetStorageDeviceIdDescriptor(&pStorageDeviceIdDescriptor);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::GetStorageDeviceIdDescriptor");

            // convert it to VDS_STORAGE_DEVICE_ID_DESCRIPTOR
            CopyStorageDeviceIdDescriptorToLun(pStorageDeviceIdDescriptor, pLun);

            CoTaskMemFree(pStorageDeviceIdDescriptor);
            pStorageDeviceIdDescriptor = NULL;

            // et count of interconnects
            UINT cInterconnects;
            ft.hr = pLunInfo->GetInterconnectAddressCount(&cInterconnects);

            // allocate interconnect array
            pLun->m_rgInterconnects = (VDS_INTERCONNECT *) CoTaskMemAlloc(cInterconnects * sizeof(VDS_INTERCONNECT));
            memset(pLun->m_rgInterconnects, 0, sizeof(VDS_INTERCONNECT) * cInterconnects);

            // set number of interconnects
            pLun->m_cInterconnects = cInterconnects;
            for(UINT iInterconnect = 0; iInterconnect < cInterconnects; iInterconnect++)
                {
                VDS_INTERCONNECT *pInterconnect = &pLun->m_rgInterconnects[iInterconnect];

                // fill in each interconnect address
                ft.hr = pLunInfo->GetInterconnectAddress
                        (
                        iInterconnect,
                        &pInterconnect->m_addressType,
                        &pInterconnect->m_cbPort,
                        &pInterconnect->m_pbPort,
                        &pInterconnect->m_cbAddress,
                        &pInterconnect->m_pbAddress
                        );

                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssLunInformation::GetInterconnectAddress");
                }

            // set out parameters
            *prgLunInfo = rgLunInfo;
            *pcLunInfo = cLuns;
            }
        }
    catch(...)
        {
        // free up temporary STORAGE_DEVICE_ID_DESCRIPTOR
        if (pStorageDeviceIdDescriptor)
            CoTaskMemFree(pStorageDeviceIdDescriptor);

        // free up allocate lun information
        FreeLunInfo(rgLunInfo, cLuns);
        throw;
        }
    }


// snapshot creation failed after PostCommitSnapshots was called but prior
// to the snapshot set description actually being persisted into the requestors
// document.  This routine should attempt to notify the provider about destination
// luns that are free because the snapshots on them are no longer relavent
void CVssHardwareProviderWrapper::CancelCreatedSnapshots()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CancelCreatedSnapshots()");
    }


// obtain the local computer name
LPWSTR CVssHardwareProviderWrapper::GetLocalComputerName()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHWSnapshotProvider::GetLocalComputerName");

    // compute size of computer name
    DWORD cwc = 0;
    GetComputerNameEx(ComputerNameDnsFullyQualified, NULL, &cwc);
    DWORD dwErr = GetLastError();
    if (dwErr != ERROR_MORE_DATA)
        {
        ft.hr = HRESULT_FROM_WIN32(dwErr);
        ft.CheckForError(VSSDBG_COORD, L"GetComputerName");
        }

    // allocate space for computer name
    LPWSTR wszComputerName = new WCHAR[cwc];
    if (wszComputerName == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate space for computer name");

    if (!GetComputerNameEx(ComputerNameDnsFullyQualified, wszComputerName, &cwc))
        {
        delete wszComputerName;
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"GetComputerName");
        }

    return wszComputerName;
    }

////////////////////////////////////////////////////////////////////////
// IVssProviderNotifications

STDMETHODIMP CVssHardwareProviderWrapper::OnLoad
    (
    IN  IUnknown* pCallback
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::OnLoad");

    return m_pNotificationItf? m_pNotificationItf->OnLoad(pCallback): S_OK;
    }

// call provider with unload method
STDMETHODIMP CVssHardwareProviderWrapper::OnUnload
    (
    IN      BOOL    bForceUnload
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::OnUnload");

    if (m_pNotificationItf)
        ft.hr = m_pNotificationItf->OnUnload(bForceUnload);

    return ft.hr;
    }


// delete information cached in AreLunsSupported
void CVssHardwareProviderWrapper::DeleteCachedInfo()
    {
    // free cached lun information for this volume
    FreeLunInfo(m_rgLunInfoProvider, m_cLunInfoProvider);
    m_cLunInfoProvider = 0;

    // delete cached extents for this volume
    delete m_pExtents;
    m_pExtents = NULL;

    // delete cached original volume name
    delete m_wszOriginalVolumeName;
    m_wszOriginalVolumeName = NULL;
    }

// Enumerate the snapshots into the given array
void CVssHardwareProviderWrapper::EnumerateSnapshots(
        IN  LONG lContext,
        IN OUT  VSS_OBJECT_PROP_Array* pArray
        ) throw(HRESULT)
    {
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssHardwareProviderWrapper::EnumerateSnapshots");

    for(VSS_SNAPSHOT_SET_LIST *pList = m_pList; pList; pList = pList->m_next)
        {
        IVssSnapshotSetDescription* pSnapshotSetDescription = pList->m_pDescription;
        BS_ASSERT(pSnapshotSetDescription);

        // Make sure we are in the correct context
        LONG lSnapshotSetContext = 0;
        ft.hr = pSnapshotSetDescription->GetContext(&lSnapshotSetContext);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");
        if ((lContext != VSS_CTX_ALL) && (lContext != lSnapshotSetContext))
            continue;

        // Get the number of snapshots for this set
        UINT uSnapshotsCount = 0;
        ft.hr = pSnapshotSetDescription->GetSnapshotCount(&uSnapshotsCount);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

        // For each snapshot - try to add it to the array (if it is in the right context)
        for( UINT uSnapshotIndex = 0; uSnapshotIndex < uSnapshotsCount; uSnapshotIndex++)
            {
            // Get the snapshot description
            IVssSnapshotDescription* pSnapshotDescription = NULL;
            ft.hr = pSnapshotSetDescription->GetSnapshotDescription(uSnapshotIndex, &pSnapshotDescription);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");
            BS_ASSERT(pSnapshotDescription);

            // Create a new snapshot structure
            VSS_OBJECT_PROP_Ptr ptrSnapProp;
            ptrSnapProp.InitializeAsEmpty(ft);

            // Get the structure from the union
            VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
            BS_ASSERT(pObj);
            VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

            // Make it a snapshot structure
            pObj->Type = VSS_OBJECT_SNAPSHOT;

            // Fill in the snapshot structure
            BuildSnapshotProperties(
                pSnapshotSetDescription,
                pSnapshotDescription,
                VSS_SS_CREATED,
                pSnap
                );

            // Add the snapshot to the array
            if (!pArray->Add(ptrSnapProp))
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                          L"Cannot add element to the array");

            ptrSnapProp.Reset();
            }
        }
    }


// locate and expose volumes
void CVssHardwareProviderWrapper::LocateAndExposeVolumes
    (
    IN LUN_MAPPING_STRUCTURE *pLunMapping,
    IN bool bTransported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::LocateAndExpose");

    ResetDiskArrivalList();
    SetArrivalHandler(this);

    VDS_LUN_INFORMATION *rgLunInfo = NULL;
    UINT cLuns = 0;

    for(UINT iVolume = 0; iVolume < pLunMapping->m_cVolumes; iVolume++)
        cLuns += pLunMapping->m_rgVolumeMappings[iVolume].m_cLuns;

    rgLunInfo = new VDS_LUN_INFORMATION[cLuns];
    cLuns = pLunMapping->m_rgVolumeMappings[0].m_cLuns;
    memcpy(rgLunInfo, pLunMapping->m_rgVolumeMappings[0].m_rgLunInfo, sizeof(VDS_LUN_INFORMATION) * cLuns);
    for(iVolume = 1; iVolume < pLunMapping->m_cVolumes; iVolume++)
        {
        VOLUME_MAPPING_STRUCTURE *pVol = &pLunMapping->m_rgVolumeMappings[iVolume];
        for(UINT iLun = 0; iLun < pVol->m_cLuns; iLun++)
            {
            bool bMatched = false;
            VDS_LUN_INFORMATION *pLun = &pVol->m_rgLunInfo[iLun];
            for(UINT iLunM = 0; iLunM < cLuns; iLunM++)
                {
                if (IsMatchLun(*pLun, rgLunInfo[iLunM], bTransported))
                    {
                    bMatched = true;
                    break;
                    }
                }

            if (!bMatched)
                rgLunInfo[cLuns++] = *pLun;
            }
        }


    BS_ASSERT(m_pHWItf);
    ft.hr = m_pHWItf->LocateLuns(cLuns, rgLunInfo);
    if (ft.HrFailed())
        ft.TranslateProviderError(VSSDBG_COORD, m_ProviderId, L"LocateLuns");

    DoRescan();
    SetArrivalHandler(NULL);
    DiscoverAppearingVolumes(pLunMapping, bTransported);
    RemapVolumes(pLunMapping, bTransported);
    }


// reset the volume arrival list
void CVssHardwareProviderWrapper::ResetDiskArrivalList()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::ResetDiskArrivalList");

    CVssSafeAutomaticLock lock(m_csList);
    for(UINT i = 0; i < m_cDisksArrived; i++)
        {
        delete m_rgwszDisksArrived[i];
        m_rgwszDisksArrived[i] = NULL;
        }

    m_cDisksArrived = 0;
    }


// record information about a volume that has arrived
STDMETHODIMP CVssHardwareProviderWrapper::RecordDiskArrival
    (
    LPCWSTR wszDiskName
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::RecordDiskArrival");

    CVssSafeAutomaticLock lock(m_csList);
    try
        {
        if (m_cDisksArrived == m_cDisksArrivedMax)
            {
            LPCWSTR *rgwsz = new LPCWSTR[m_cDisksArrived + 4];
            if (rgwsz == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"can't grow volume arrival array");

            memcpy(rgwsz, m_rgwszDisksArrived, m_cDisksArrived * sizeof(LPWSTR));
            m_cDisksArrivedMax = m_cDisksArrived + 4;
            delete m_rgwszDisksArrived;
            m_rgwszDisksArrived = rgwsz;
            }

        LPWSTR wsz = new WCHAR[wcslen(wszDiskName) + 1];
        if (wsz == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"can't allocate volume name");

        wcscpy(wsz, wszDiskName);

        m_rgwszDisksArrived[m_cDisksArrived++] = wsz;
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }



void CVssHardwareProviderWrapper::GetHiddenVolumeList
    (
    UINT &cVolumes,
    LPWSTR &wszVolumes
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::GetHiddenVolumeList");

    cVolumes = 0;
    wszVolumes = new WCHAR[1024];
    UINT cwcVolumes = 1024;
    UINT iwcVolumes = 0;

    GUID guid = VOLMGR_VOLUME_MANAGER_GUID;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pDetailData = NULL;
    DWORD RequiredSize;
    DWORD SizeDetailData = 0;
    PVOLMGR_HIDDEN_VOLUMES pnames = NULL;

    HANDLE hDev = SetupDiGetClassDevs
                    (
                    &guid,
                    NULL,
                    NULL,
                    DIGCF_DEVICEINTERFACE|DIGCF_PRESENT
                    );

    if (hDev == INVALID_HANDLE_VALUE)
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"SetupDiGetClassDevs");
        }

    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;


    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    // Enumerate each volume manager information element in the set of current disks.

    try
        {
        LONG lRetCode;
        for(int i = 0;
            SetupDiEnumDeviceInterfaces(hDev, NULL, &guid, i, &DeviceInterfaceData);
            i++)
            {
            //
            // Get the disk interface detail buffer size.
            //

            lRetCode = SetupDiGetDeviceInterfaceDetail
                        (
                        hDev,
                        &DeviceInterfaceData,
                        pDetailData,
                        SizeDetailData,
                        &RequiredSize,
                        NULL
                        );
            while ( !lRetCode )
                {

                //
                // 1st time call to get the Interface Detail should fail with
                // an insufficient buffer.  If it fails with another error, then fail out.
                // Else, if we get the insufficient error then we use the RequiredSize return value
                // to prep for the next Interface Detail call.
                //

                lRetCode = GetLastError();
                if ( lRetCode != ERROR_INSUFFICIENT_BUFFER )
                    {
                    ft.hr = HRESULT_FROM_WIN32(lRetCode);
                    ft.CheckForError(VSSDBG_COORD, L"SetupDiGetDeviceInterfaceDetail");
                    }
                else
                    {
                    SizeDetailData = RequiredSize;
                    pDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) new BYTE[SizeDetailData];

                    //
                    // If memory allocation error break out of the for loop and fail out.
                    //

                    if ( pDetailData == NULL )
                        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate Device inteface detail data");

                    }

                pDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                lRetCode = SetupDiGetDeviceInterfaceDetail
                            (
                            hDev,
                            &DeviceInterfaceData,
                            pDetailData,
                            SizeDetailData,
                            &RequiredSize,
                            NULL);
                }


        //
        // Hopefully have the detailed interface data for a volume
        //

        if ( pDetailData )
            {
            CVssAutoWin32Handle hVolMgr =
                    CreateFile
                        (
                        pDetailData->DevicePath,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE
                        );

            if (hVolMgr == INVALID_HANDLE_VALUE)
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"CreateFile(VOLUME_MANAGER)");
                }

            VOLMGR_HIDDEN_VOLUMES names;

            DWORD size;

            if (!DeviceIoControl
                    (
                    hVolMgr,
                    IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES,
                    NULL,
                    0,
                    &names,
                    sizeof(names),
                    &size,
                    NULL
                    ))
                {
                DWORD dwErr = GetLastError();
                if (dwErr != ERROR_MORE_DATA)
                    {
                    delete pDetailData;
                    pDetailData = NULL;
                    SizeDetailData = 0;
                    continue;
                    }
                }



            size = names.MultiSzLength + sizeof(VOLMGR_HIDDEN_VOLUMES);
            pnames = (PVOLMGR_HIDDEN_VOLUMES) new BYTE[size];
            if (pnames == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate VOLMGR_HIDDEN_VOLUMES structure");

            if (!DeviceIoControl
                    (
                    hVolMgr,
                    IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES,
                    NULL,
                    0,
                    pnames,
                    size,
                    &size,
                    NULL
                    ))
                    {
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl(IOCTL_VOLMGR_QUERY_HIDDEN_VOLUMES");
                    }

            LPWSTR wszName = pnames->MultiSz;
            while(*wszName != L'\0')
                {
                LPCWSTR wszPrepend = L"\\\\?\\GlobalRoot";
                UINT cwc = (UINT) wcslen(wszName) + 1;
                if (iwcVolumes + wcslen(wszPrepend) + cwc + 1 >= cwcVolumes)
                    {
                    LPWSTR wszNew = new WCHAR[cwcVolumes * 2];
                    memcpy(wszNew, wszVolumes, iwcVolumes);
                    cwcVolumes *= 2;
                    delete wszVolumes;
                    wszVolumes = wszNew;
                    }

                wcscpy(wszVolumes + iwcVolumes, wszPrepend);
                iwcVolumes += (UINT) wcslen(wszPrepend);
                memcpy(wszVolumes + iwcVolumes, wszName, cwc * sizeof(WCHAR));
                iwcVolumes += cwc;
                wszVolumes[iwcVolumes] = L'\0';
                cVolumes++;
                wszName += cwc;
                }


            delete pnames;
            pnames = NULL;
            delete pDetailData;
            pDetailData = NULL;
            SizeDetailData = 0;
            }
        }   // end for

        //
        // Check that SetupDiEnumDeviceInterfaces() did not fail.
        //

        lRetCode = GetLastError();
        if ( lRetCode != ERROR_NO_MORE_ITEMS )
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"SetDiEnumDeviceInterfaces");
            }

        }
    catch(...)
        {
        // Free memory allocated for Device Interface List
        SetupDiDestroyDeviceInfoList(hDev);
        delete pDetailData;
        delete pnames;
        throw;
        }

    SetupDiDestroyDeviceInfoList(hDev);
    }

// cause a PNP rescan to take place
void CVssHardwareProviderWrapper::DoRescan()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DoRescan");


    DoRescanForDeviceChanges();

    GUID guid = DiskClassGuid;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pDetailData = NULL;
    DWORD RequiredSize;
    DWORD SizeDetailData = 0;

    HANDLE hDev = SetupDiGetClassDevs
                    (
                    &guid,
                    NULL,
                    NULL,
                    DIGCF_DEVICEINTERFACE|DIGCF_PRESENT
                    );

    if (hDev == INVALID_HANDLE_VALUE)
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"SetupDiGetClassDevs");
        }

    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;


    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

     //p
    // Enumerate each disk information element in the set of current disks.


    try
        {
        LONG lRetCode;
        for(int i = 0;
            SetupDiEnumDeviceInterfaces(hDev, NULL, &guid, i, &DeviceInterfaceData);
            i++)
            {
            //
            // Get the disk interface detail buffer size.
            //

            lRetCode = SetupDiGetDeviceInterfaceDetail
                        (
                        hDev,
                        &DeviceInterfaceData,
                        pDetailData,
                        SizeDetailData,
                        &RequiredSize,
                        NULL
                        );
            while ( !lRetCode )
                {

                //
                // 1st time call to get the Interface Detail should fail with
                // an insufficient buffer.  If it fails with another error, then fail out.
                // Else, if we get the insufficient error then we use the RequiredSize return value
                // to prep for the next Interface Detail call.
                //

                lRetCode = GetLastError();
                if ( lRetCode != ERROR_INSUFFICIENT_BUFFER )
                    {
                    ft.hr = HRESULT_FROM_WIN32(lRetCode);
                    ft.CheckForError(VSSDBG_COORD, L"SetupDiGetDeviceInterfaceDetail");
                    }
                else
                    {
                    SizeDetailData = RequiredSize;
                    pDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) new BYTE[SizeDetailData];

                    //
                    // If memory allocation error break out of the for loop and fail out.
                    //

                    if ( pDetailData == NULL )
                        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate Device inteface detail data");

                    }

                pDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                lRetCode = SetupDiGetDeviceInterfaceDetail
                            (
                            hDev,
                            &DeviceInterfaceData,
                            pDetailData,
                            SizeDetailData,
                            &RequiredSize,
                            NULL);
                }


        //
        // Hopefully have the detailed interface data for a volume
        //

        if ( pDetailData )
            {
            RecordDiskArrival(pDetailData->DevicePath);
            delete pDetailData;
            pDetailData = NULL;
            SizeDetailData = 0;
            }
        }   // end for

        //
        // Check that SetupDiEnumDeviceInterfaces() did not fail.
        //

        lRetCode = GetLastError();
        if ( lRetCode != ERROR_NO_MORE_ITEMS )
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"SetDiEnumDeviceInterfaces");
            }

        }
    catch(...)
        {
        // Free memory allocated for Device Interface List
        SetupDiDestroyDeviceInfoList(hDev);
        delete pDetailData;
        throw;
        }

    SetupDiDestroyDeviceInfoList(hDev);
    }

// dertermine if a volume that has arrived matches any snapshot volumes.  If
// so fill in the device name for the arrived volume

void CVssHardwareProviderWrapper::RemapVolumes
    (
    IN LUN_MAPPING_STRUCTURE *pLunMapping,
    IN bool bTransported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::RemapVolumes");

    LPBYTE bufExtents = NULL;
    UINT cLunInfo = 0;
    VDS_LUN_INFORMATION *rgLunInfo = NULL;
    UINT cVolumes = 0;
    LPWSTR wszHiddenVolumes = NULL;


    try
        {
        // loop until all volumes appear
        while(TRUE)
            {
            GetHiddenVolumeList(cVolumes, wszHiddenVolumes);
            LPWSTR wszVolumes = wszHiddenVolumes;

            for(UINT iVolume = 0; iVolume < cVolumes; iVolume++)
                {
                LPCWSTR wszVolume = wszVolumes;

                if (BuildLunInfoFromVolume
                        (
                        wszVolume,
                        bufExtents,
                        cLunInfo,
                        rgLunInfo
                        ))
                    {
                    for(UINT iMapping = 0; iMapping < pLunMapping->m_cVolumes; iMapping++)
                        {
                        VOLUME_MAPPING_STRUCTURE *pVol = &pLunMapping->m_rgVolumeMappings[iMapping];
                        if (IsMatchVolume
                                (
                                (const VOLUME_DISK_EXTENTS *) bufExtents,
                                cLunInfo,
                                rgLunInfo,
                                pVol,
                                bTransported
                                ))
                            {
                            pVol->m_wszDevice = new WCHAR[wcslen(wszVolume) + 1];
                            if (pVol->m_wszDevice == NULL)
                                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate volume name");

                            wcscpy(pVol->m_wszDevice, wszVolume);
                            break;
                            }
                        }
                    }

                delete bufExtents;
                bufExtents = NULL;
                FreeLunInfo(rgLunInfo, cLunInfo);
                rgLunInfo = NULL;
                cLunInfo = 0;
                wszVolumes += wcslen(wszVolumes) + 1;
                }

            for(UINT iMapping = 0; iMapping < pLunMapping->m_cVolumes; iMapping++)
                {
                VOLUME_MAPPING_STRUCTURE *pVol = &pLunMapping->m_rgVolumeMappings[iMapping];
                if (pVol->m_wszDevice == NULL)
                    break;
                }

            if (iMapping == pLunMapping->m_cVolumes)
                break;
            }
        }
    VSS_STANDARD_CATCH(ft)

    delete bufExtents;
    FreeLunInfo(rgLunInfo, cLunInfo);

    if (ft.HrFailed())
        ft.Throw(VSSDBG_COORD, ft.hr, L"Rethrow exception");
    }

// determine if a volume matches by seeing if the luns match and the
// extents match
bool CVssHardwareProviderWrapper::IsMatchVolume
    (
    IN const VOLUME_DISK_EXTENTS *pExtents,
    IN UINT cLunInfo,
    IN const VDS_LUN_INFORMATION *rgLunInfo,
    IN const VOLUME_MAPPING_STRUCTURE *pMapping,
    IN bool bTransported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsMatchVolume");
    if (!IsMatchingDiskExtents(pExtents, pMapping->m_pExtents))
        return false;

    if (cLunInfo != pMapping->m_cLuns)
        return false;

    for(UINT iLun = 0; iLun < pMapping->m_cLuns; iLun++)
        {
        if (!IsMatchLun(rgLunInfo[iLun], pMapping->m_rgLunInfo[iLun], bTransported))
            return false;
        }

    return true;
    }

// determine if two sets of disk extents match
bool CVssHardwareProviderWrapper::IsMatchingDiskExtents
    (
    IN const VOLUME_DISK_EXTENTS *pExtents1,
    IN const VOLUME_DISK_EXTENTS *pExtents2
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsMatchingDiskExtents");

    // number of extents
    UINT cExtents = pExtents1->NumberOfDiskExtents;
    if (pExtents1->NumberOfDiskExtents != cExtents)
        return false;

    // first extent and disk
    const DISK_EXTENT *pExtent1 = pExtents1->Extents;
    const DISK_EXTENT *pExtent2 = pExtents2->Extents;
    const DISK_EXTENT *pExtent1Prev = NULL;
    const DISK_EXTENT *pExtent2Prev = NULL;


    for(UINT iExtent = 0; iExtent < cExtents; iExtent++)
        {
        if (pExtent1->StartingOffset.QuadPart != pExtent2->StartingOffset.QuadPart)
            return false;

        if (pExtent1->ExtentLength.QuadPart != pExtent2->ExtentLength.QuadPart)
            return false;

        // make sure extents refer to the correct disks.  Basically the extent
        // is either on the same physical disk as the previous extent or
        // on another disk.
        if (pExtent1Prev)
            {
            if (pExtent1->DiskNumber == pExtent1Prev->DiskNumber)
                {
                if (pExtent2->DiskNumber != pExtent2Prev->DiskNumber)
                    return false;
                }
            else
                {
                if (pExtent2->DiskNumber == pExtent2Prev->DiskNumber)
                    return false;
                }
            }

        pExtent1Prev = pExtent1;
        pExtent2Prev = pExtent2;
        }

    return true;
    }

// determine if two VDS_LUN_INFORMATION structures match
bool CVssHardwareProviderWrapper::IsMatchLun
    (
    const VDS_LUN_INFORMATION &info1,
    const VDS_LUN_INFORMATION &info2,
    bool bTransported
    )
    {
    if (info1.m_DeviceType != info2.m_DeviceType)
        return false;

    if (info1.m_DeviceTypeModifier != info2.m_DeviceTypeModifier)
        return false;

    if (info1.m_BusType != info2.m_BusType)
        return false;

    if (!cmp_str_eq(info1.m_szVendorId, info2.m_szVendorId))
        return false;

    if (!cmp_str_eq(info1.m_szProductId, info2.m_szProductId))
        return false;

    if (!cmp_str_eq(info1.m_szProductRevision, info2.m_szProductRevision))
        return false;

    if (!cmp_str_eq(info1.m_szSerialNumber, info2.m_szSerialNumber))
        return false;

    if (bTransported && info1.m_diskSignature != info2.m_diskSignature)
        return false;

    if (!IsMatchDeviceIdDescriptor(info1.m_deviceIdDescriptor, info2.m_deviceIdDescriptor))
        return false;

    return true;
    }


// make sure that the storage device id descriptors match.  Only look for
// device id descriptors that differ since we can't be sure we will get the
// same amount of information from two different controllers.
bool CVssHardwareProviderWrapper::IsMatchDeviceIdDescriptor
    (
    IN const VDS_STORAGE_DEVICE_ID_DESCRIPTOR &desc1,
    IN const VDS_STORAGE_DEVICE_ID_DESCRIPTOR &desc2
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsMatchDeviceIdDescriptor");

    VDS_STORAGE_IDENTIFIER *pId1 = desc1.m_rgIdentifiers;
    VDS_STORAGE_IDENTIFIER *rgId2 = desc2.m_rgIdentifiers;

    for(ULONG iIdentifier = 0; iIdentifier < desc1.m_cIdentifiers; iIdentifier++, pId1++)
        {
        if (IsConflictingIdentifier(pId1, rgId2, desc2.m_cIdentifiers))
            return false;
        }
    return true;
    }

// determine if there is a conflicting identifier in an array of storage
// identifiers
bool CVssHardwareProviderWrapper::IsConflictingIdentifier
    (
    IN const VDS_STORAGE_IDENTIFIER *pId1,
    IN const VDS_STORAGE_IDENTIFIER *rgId2,
    IN ULONG cId2
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::IsConflictingIdentifier");

    const VDS_STORAGE_IDENTIFIER *pId2 = rgId2;

    // loop through identifiers
    for(UINT iid = 0; iid < cId2; iid++)
        {
        // if type of identifer matches then the rest of the identifier
        // information must match
        if (pId1->m_Type == pId2->m_Type)
            {
            if (pId1->m_CodeSet != pId2->m_CodeSet ||
                pId1->m_cbIdentifier != pId2->m_cbIdentifier ||
                memcmp(pId1->m_rgbIdentifier, pId2->m_rgbIdentifier, pId1->m_cbIdentifier) != 0)
                return true;
            }
        }

    return false;
    }

// free up structure used to map volumes during import
void CVssHardwareProviderWrapper::DeleteLunMappingStructure
    (
    LUN_MAPPING_STRUCTURE *pMapping
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DeleteLunMappingStructure");

    // free up information for each volume
    for(UINT iVolume = 0; iVolume < pMapping->m_cVolumes; iVolume++)
        {
        VOLUME_MAPPING_STRUCTURE *pVol = &pMapping->m_rgVolumeMappings[iVolume];
        FreeLunInfo(pVol->m_rgLunInfo, pVol->m_cLuns);
        delete pVol->m_pExtents;
        delete pVol->m_wszDevice;
        }

    // free up array of volume mappings
    delete pMapping->m_rgVolumeMappings;

    // free overall mapping structure
    delete pMapping;
    }


// build a structure used to import luns by mapping lun information to
// device objects
void CVssHardwareProviderWrapper::BuildLunMappingStructure
    (
    IN IVssSnapshotSetDescription *pSnapshotSetDescription,
    OUT LUN_MAPPING_STRUCTURE **ppMapping
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildLunMappingStructure");

    UINT cVolumes;
    ft.hr = pSnapshotSetDescription->GetSnapshotCount(&cVolumes);
    ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");
    LUN_MAPPING_STRUCTURE *pMappingT = new LUN_MAPPING_STRUCTURE;
    if (pMappingT == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Can't allocate LUN_MAPPING_STRUCTURE");

    pMappingT->m_rgVolumeMappings = new VOLUME_MAPPING_STRUCTURE[cVolumes];
    if (pMappingT->m_rgVolumeMappings == NULL)
        {
        delete pMappingT;
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate VOLUME_MAPPING_STRUCTURE array");
        }

    pMappingT->m_cVolumes = cVolumes;
    memset(pMappingT->m_rgVolumeMappings, 0, cVolumes * sizeof(VOLUME_MAPPING_STRUCTURE));
    try
        {
        for(UINT iVolume = 0; iVolume < cVolumes; iVolume++)
            {
            CComPtr<IVssSnapshotDescription> pSnapshot;
            ft.hr = pSnapshotSetDescription->GetSnapshotDescription(iVolume, &pSnapshot);
            ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnasphotDescription");
            BuildVolumeMapping(pSnapshot, pMappingT->m_rgVolumeMappings[iVolume]);
            }
        }
    catch(...)
        {
        DeleteLunMappingStructure(pMappingT);
        throw;
        }

    *ppMapping = pMappingT;
    }

// build a volume mapping structure from a snapshot description.  The
// volume mapping structure has lun information and extent information
// extracted from the XML description of the snapshot
void CVssHardwareProviderWrapper::BuildVolumeMapping
    (
    IN IVssSnapshotDescription *pSnapshot,
    OUT VOLUME_MAPPING_STRUCTURE &mapping
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::BuildVolumeMapping");

    // get lun information from the snapshot description
    GetLunInformation(pSnapshot, true, &mapping.m_rgLunInfo, &mapping.m_cLuns);

    // compute total number of extents for all luns
    ULONG cExtents = 0;
    for(UINT iLun = 0; iLun < mapping.m_cLuns; iLun++)
        {
        CComPtr<IVssLunMapping> pLunMapping;
        ft.hr = pSnapshot->GetLunMapping(iLun, &pLunMapping);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshot::GetLunMapping");
        UINT cDiskExtents;
        ft.hr = pLunMapping->GetDiskExtentCount(&cDiskExtents);
        cExtents += (ULONG) cDiskExtents;
        }

    // allocate space for disk extents
    mapping.m_pExtents = (VOLUME_DISK_EXTENTS *) new BYTE[sizeof(VOLUME_DISK_EXTENTS) + (cExtents - 1) * sizeof(DISK_EXTENT)];
    if (mapping.m_pExtents == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate VOLUME_DISK_EXTENTS");

    // set number of extents
    mapping.m_pExtents->NumberOfDiskExtents = cExtents;

    // assume volume is not exposed
    mapping.m_bExposed = false;

    // allocate lun bitmap
    mapping.m_rgdwLuns = new DWORD[(mapping.m_cLuns + 31)/32];
    if (mapping.m_rgdwLuns == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate lun bitmap");

    // clear lun bitmap
    memset(mapping.m_rgdwLuns, 0, ((mapping.m_cLuns + 31)/32) * 4);

    DISK_EXTENT *pDiskExtent = mapping.m_pExtents->Extents;
    for(UINT iLun = 0; iLun < mapping.m_cLuns; iLun++)
        {
        CComPtr<IVssLunMapping> pLunMapping;
        ft.hr = pSnapshot->GetLunMapping(iLun, &pLunMapping);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshot::GetLunMapping");
        UINT cDiskExtents;
        ft.hr = pLunMapping->GetDiskExtentCount(&cDiskExtents);

        // fill in disk extents
        for(UINT iDiskExtent = 0; iDiskExtent < cDiskExtents; iDiskExtent++)
            {
            pDiskExtent->DiskNumber = iLun;
            ft.hr = pLunMapping->GetDiskExtent
                        (
                        iDiskExtent,
                        (ULONGLONG *) &pDiskExtent->StartingOffset.QuadPart,
                        (ULONGLONG *) &pDiskExtent->ExtentLength.QuadPart
                        );

            ft.CheckForError(VSSDBG_COORD, L"IVssLunMapping::GetDiskExtent");
            }
        }
    }

// write device names for snapshots into the XML documents for
// those snapshot volumes that have appeared after importing
// luns.
void CVssHardwareProviderWrapper::WriteDeviceNames
    (
    IN IVssSnapshotSetDescription *pSnapshotSet,
    IN LUN_MAPPING_STRUCTURE *pMapping
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::WriteDeviceNames");

    // loop through snapshot volumes
    for(UINT iVolume = 0; iVolume < pMapping->m_cVolumes; iVolume++)
        {
        VOLUME_MAPPING_STRUCTURE *pVol = &pMapping->m_rgVolumeMappings[iVolume];

        // if we have a device name, update the XML document with it
        if (pVol->m_wszDevice)
            {
            CComPtr<IVssSnapshotDescription> pSnapshot;
            ft.hr = pSnapshotSet->GetSnapshotDescription(iVolume, &pSnapshot);
            ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnasphotDescription");
            ft.hr = pSnapshot->SetDeviceName(pVol->m_wszDevice);
            ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::SetDeviceName");
            }
        }
    }

// compare two strings.  Ignore trailing spaces
bool CVssHardwareProviderWrapper::cmp_str_eq
    (
    LPCSTR sz1,
    LPCSTR sz2
    )
    {
    if (sz1 == NULL && sz2 == NULL)
        return true;

    if (sz1 != NULL && sz2 != NULL)
        {
        while(*sz1 == *sz2 && *sz1 != '\0')
            {
            sz1++;
            sz2++;
            }

        if (*sz1 == *sz2)
            return true;

        if (*sz1 == '\0' && *sz2 == ' ')
            {
            while(*sz2 != '\0')
                {
                if (*sz2 != ' ')
                    return false;

                sz2++;
                }

            return true;
            }
        else if (*sz1 == ' ' && *sz2 == ' ')
            {
            while(*sz1 != '\0')
                {
                if (*sz1 != ' ')
                    return false;

                sz1++;
                }

            return true;
            }

        return false;
        }

    return false;
    }




// this routine figures out which disks arrived and for each one which
// snapshot volumes should be surfaced because the snapshot volume
// is now fully available
void CVssHardwareProviderWrapper::DiscoverAppearingVolumes
    (
    IN LUN_MAPPING_STRUCTURE *pLunMapping,
    bool bTransported
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DiscoverAppearingVolumes");

    VDS_LUN_INFORMATION *pLun = NULL;

    try
        {
        for(UINT iDisk = 0; iDisk < m_cDisksArrived; iDisk++)
            {
            // get PNP name of drive
            LPCWSTR wszDisk = m_rgwszDisksArrived[iDisk];

            // allocate lun information
            pLun = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(sizeof(VDS_LUN_INFORMATION));
            if (pLun == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate VDS_LUN_INFORMATION");

            // clear lun information in case of error
            memset(pLun, 0, sizeof(VDS_LUN_INFORMATION));
            if (BuildLunInfoForDrive(wszDisk, pLun))
                {
                for(UINT iVolume = 0; iVolume < pLunMapping->m_cVolumes; iVolume++)
                    {
                    VOLUME_MAPPING_STRUCTURE *pVolume = &pLunMapping->m_rgVolumeMappings[iVolume];
                    for(UINT iLun = 0; iLun < pVolume->m_cLuns; iLun++)
                        {
                        // if lun matches that mark corresponding bit in
                        // bit array for luns as on.
                        if (IsMatchLun(pVolume->m_rgLunInfo[iLun], *pLun, bTransported))
                            pVolume->m_rgdwLuns[iLun/32] |= 1 << (iLun % 32);
                        }
                    }
                }

            // cree lun information and continue
            FreeLunInfo(pLun, 1);
            pLun = NULL;
            }

        for(UINT iVolume = 0; iVolume < pLunMapping->m_cVolumes; iVolume++)
            {
            VOLUME_MAPPING_STRUCTURE *pVolume = &pLunMapping->m_rgVolumeMappings[iVolume];

            // determine if all luns for a partitular snapshot volume are
            // surfaced
            for(UINT iLun = 0; iLun < pVolume->m_cLuns; iLun++)
                {
                if ((pVolume->m_rgdwLuns[iLun / 32] & (1 << (iLun % 32))) == 0)
                    break;
                }

            // if all luns are surfaced mark the volume as exposed
            if (iLun == pVolume->m_cLuns)
                pVolume->m_bExposed = true;
            }
        }
    catch(...)
        {
        // free the lun in case of an exception
        if (pLun)
            FreeLunInfo(pLun, 1);

        throw;
        }
    }




// We will enumerate those device ids that belong to GUID_DEVCLASS_SCSIADAPTER
//  According to Lonny, all others are not needed at all.
//  This will of cource speed up enumeration
//  An excerpt of his mail is shown below
//  Other classes of interest include:
//   PCMCIA,
//  There should be no need to manually force a re-enumeration of PCMCIA
//  devices, since PCMCIA automatically detects/reports cards the moment they
//  arrive.
//
//   HDC,
//  The only way IDE devices can come or go (apart from PCMCIA IDE devices
//  covered under the discussion above) is via ACPI.  In that case, too,
//  hot-plug notification is given, thus there's no need to go and manually
//  re-enumerate.
//
//   MULTI_FUNCTION_ADAPTER,
//  There are two types of multifunction devices--those whose children are
//  enumerated via a bus-standard multi-function mechanism, and those whose
//  children a enumerated based on registry information.  In the former case, it
//  is theoretically possible that you'd need to do a manual re-enumeration in
//  order to cause the bus to find any new multi-function children.  In reality,
//  however, there are no such situations today.  In the latter case, there's no
//  point at all, since it's the registry spooge that determines what children
//  get exposed, not the bus driver.
//
//  Bottom line--I don't think that manual enumeration is necessary for any
//  (setup) class today except ScsiAdapter.  Ideally, the list of devices
//  requiring re-enumeration would be based on interface class instead.  Thus,
//  each device (regardless of setup class) that requires manual re-enumeration
//  in order to detect newly-arrived disks would expose an interface.  This
//  interface wouldn't need to actually be opened, it'd just be a mechanism to
//  enumerate such devices.  Given that ScsiAdapter is the only class today that
//  needs this functionality, and given the fact that all new hot-plug busses
//  actually report the device as soon as it arrives, we probably don't need to
//  go to this extra trouble.
//
void CVssHardwareProviderWrapper::DoRescanForDeviceChanges()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::DoRescanForDeviceChanges");

    //  the following algorithm will be used
    //  a) Get all the deviceIds
    //  b) For each deviceId, get the class guid
    //  c) If the class GUID matches any of the following:
    //      GUID_DEVCLASS_SCSIADAPTER
    //    then get the devinst of the devidId and enumerate the devinst


    CONFIGRET result;
    GUID guid;
    ULONG length;
    LPWSTR deviceList = NULL;
    PWSTR ptr = NULL;
    DEVINST devinst;

    result = CM_Get_Device_ID_List_Size_Ex
                (
                &length,
                NULL, // No enumerator
                CM_GETIDLIST_FILTER_NONE,
                NULL
                );

    if (result != CR_SUCCESS)
        {
        ft.Trace(VSSDBG_COORD, L"unable to do rescan, cannot get buffer size");
        return;
        }

    // allocate device list
    deviceList = new WCHAR[length];
    if (!deviceList)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string");

    result = CM_Get_Device_ID_List_Ex
                (
                NULL,
                deviceList,
                length,
                CM_GETIDLIST_FILTER_NONE,
                NULL
                );

    if (result != CR_SUCCESS)
        {
        // delete device list and return
        delete deviceList;
        ft.Trace(VSSDBG_COORD, L"Cannot get device list");
        return;
        }

    ptr = deviceList;

    while (ptr && *ptr)
        {
        LPWSTR TempString;

        devinst = DeviceIdToDeviceInstance(ptr);
        if (GetDevicePropertyString(devinst, SPDRP_CLASSGUID, &TempString))
            {
            if (GuidFromString(TempString, &guid))
                {
                if (guid == GUID_DEVCLASS_SCSIADAPTER)
                    // cause rescan on a scsi adapter
                    ReenumerateDevices(devinst);
                }

            delete TempString;
            }

        ptr = ptr + (wcslen(ptr) + 1);
        }

    if (deviceList)
        delete deviceList;
    }

// This routine converts the character representation of a GUID into its binary
// form (a GUID struct).  The GUID is in the following form:
//
//  {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
//
//    where 'x' is a hexadecimal digit.
//
//  If the function succeeds, the return value is NO_ERROR.
//  If the function fails, the return value is RPC_S_INVALID_STRING_UUID.
BOOL CVssHardwareProviderWrapper::GuidFromString
    (
    IN LPCWSTR GuidString,
    OUT GUID *Guid
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::GuidFromString");

    // length of guid string
    const GUID_STRING_LEN = 39;

    WCHAR UuidBuffer[GUID_STRING_LEN - 1];

    if(*GuidString++ != L'{' || lstrlen(GuidString) != GUID_STRING_LEN - 2)
        return FALSE;

    // copy string into buffer
    lstrcpy(UuidBuffer, GuidString);

    if (UuidBuffer[GUID_STRING_LEN - 3] != L'}')
        return FALSE;

    // null out terminating bracket
    UuidBuffer[GUID_STRING_LEN - 3] = L'\0';
    return ((UuidFromString(UuidBuffer, Guid) == RPC_S_OK) ? TRUE : FALSE);
    }


// Given the device Id this routine will enumerate all the devices under
// it. Example, given a scsi adapter ID it will find new disks.
// This function uses the user mode PNP manager.
// Returns TRUE on success.
BOOL CVssHardwareProviderWrapper::ReenumerateDevices
    (
    IN DEVINST deviceInstance
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareTestProvider::ReenumerateDevices");
    CONFIGRET result;
    BOOL bResult = TRUE;

    result = CM_Reenumerate_DevNode_Ex(deviceInstance, CM_REENUMERATE_SYNCHRONOUS, NULL);

    bResult = (result == CR_SUCCESS ? TRUE : FALSE);
    if (!bResult)
        ft.Trace(VSSDBG_COORD, L"CM_Reenumerate_DevNode returned an error");

    return bResult;
    }



// Given a deviceId return the device instance (handle)
// returns 0 on a failure
DEVINST CVssHardwareProviderWrapper::DeviceIdToDeviceInstance(LPWSTR deviceId)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareTestProvider::DeviceIdToDeviceInstance");

    CONFIGRET result;
    DEVINST devinst = 0;

    BS_ASSERT(deviceId != NULL);
    result = CM_Locate_DevNode(&devinst, deviceId,CM_LOCATE_DEVNODE_NORMAL | CM_LOCATE_DEVNODE_PHANTOM);
    if (result == CR_SUCCESS)
        return devinst;

    return 0;
    }



// Given the devinst, query the PNP subsystem for a property.
// This function can only be used if the property value is a string.
// propCodes supported are: SPDRP_DEVICEDESC, SPDRP_CLASSGUID,
// SPDRP_FRIENDLYNAME.
BOOL CVssHardwareProviderWrapper::GetDevicePropertyString
    (
    IN DEVINST devinst,
    IN ULONG propCode,
    OUT LPWSTR *data
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::GetDevicePropertyString");

    BOOL bResult = FALSE;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfo;
    ULONG reqSize = 0;
    LPWSTR deviceIdString = NULL;

    BS_ASSERT(data);

    // null out output parameter
    *data = NULL;
    if (!devinst)
        return bResult;

    // compute maximum size of output string
    switch(propCode)
        {
        case (SPDRP_DEVICEDESC):
            reqSize = LINE_LEN + 1;
            break;

        case (SPDRP_CLASSGUID):
            reqSize = MAX_GUID_STRING_LEN + 1;
            break;

        case (SPDRP_FRIENDLYNAME):
            reqSize = MAX_PATH + 1;
            break;

        default:
            return bResult;
        }

    // get device id string
    if (!DeviceInstanceToDeviceId(devinst, &deviceIdString))
        return bResult;

    // allocate string
    *data = new WCHAR[reqSize];
    if ((*data) == NULL)
        {
        delete deviceIdString;
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");
        }

    // clear string
    memset (*data, 0, reqSize * sizeof(WCHAR));

    DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
        ft.Trace (VSSDBG_COORD, L"SetupDiCreateDeviceInfoList failed: %lx", GetLastError());
    else
        {
        DeviceInfo.cbSize = sizeof(SP_DEVINFO_DATA);
        if (SetupDiOpenDeviceInfo
                (
                DeviceInfoSet,
                deviceIdString,
                NULL,
                0,
                &DeviceInfo
                ))
            {
            if (SetupDiGetDeviceRegistryProperty
                    (
                    DeviceInfoSet,
                    &DeviceInfo,
                    propCode,
                    NULL,
                    (PBYTE)*data,
                    reqSize*sizeof(WCHAR),
                    NULL
                    ))
                bResult = TRUE;
            else
                ft.Trace (VSSDBG_COORD, L"SetupDiGetDeviceRegistryProperty failed: %lx", GetLastError());
            }
        else
            ft.Trace (VSSDBG_COORD, L"SetupDiOpenDeviceInfo failed: %lx", GetLastError());

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        }

    if (!bResult)
        {
        delete *data;
        *data = NULL;
        }

    delete deviceIdString;
    return bResult;
    }



// given a device instance handle set the deviceId
// return TRUE on success FALSE otherwise
BOOL CVssHardwareProviderWrapper::DeviceInstanceToDeviceId
    (
    IN DEVINST devinst,
    OUT LPWSTR *deviceId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DeviceInstanceToDeviceId");

    CONFIGRET result;
    BOOL bResult = FALSE;
    DWORD size;

    // null out output parameter
    *deviceId = NULL;
    result = CM_Get_Device_ID_Size_Ex(&size, devinst, 0, NULL);

    if (result != CR_SUCCESS)
        return FALSE;

    // allocate space for string
    *deviceId = new WCHAR[size + 1];

    // check for allocation failure
    if (!(*deviceId))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate string.");

    // clear string
    memset(*deviceId, 0, (size + 1) * sizeof(WCHAR));
    result = CM_Get_Device_ID
                    (
                    devinst,
                    *deviceId,
                    size + 1,
                    0
                    );

    if (result == CR_SUCCESS)
        bResult = TRUE;
    else
        {
        // delete string on failure
        delete *deviceId;
        *deviceId = NULL;
        }

    return bResult;
    }

// delete a specific snapshot
void CVssHardwareProviderWrapper::InternalDeleteSnapshot
    (
    IN      VSS_ID          SourceObjectId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::InternalDeleteSnapshot");

    // flag indicating that the target snapshot was found
    bool fFound = false;

    // previous snapshot list element
    VSS_SNAPSHOT_SET_LIST *pSnapshotSetPrev = NULL;

    // initialize list of deleted snapshot volumes
    InitializeDeletedVolumes();

    // loop through snapshot sets
    for(VSS_SNAPSHOT_SET_LIST *pList = m_pList; pList; pList = pList->m_next)
        {
        // get snapshot set description for the current set
        IVssSnapshotSetDescription* pSnapshotSetDescription = pList->m_pDescription;
        BS_ASSERT(pSnapshotSetDescription);

        // get count of snapshots in the current set
        UINT uSnapshotsCount = 0;
        ft.hr = pSnapshotSetDescription->GetSnapshotCount(&uSnapshotsCount);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");

        // loop through each snapshot in the snapshot set
        for( UINT uSnapshotIndex = 0; uSnapshotIndex < uSnapshotsCount; uSnapshotIndex++)
            {
            CComPtr<IVssSnapshotDescription> pSnapshot;

            // get snapshot description for current snaphot
            ft.hr = pSnapshotSetDescription->GetSnapshotDescription(uSnapshotIndex, &pSnapshot);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

            // get snapshot id
            VSS_ID SnapshotId;
            ft.hr = pSnapshot->GetSnapshotId(&SnapshotId);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetSnapshotId");

            // check if we have the target snapshot
            if (SnapshotId == SourceObjectId)
                {
                CComBSTR bstrDeviceName;

                // get device name for snapshot volume
                ft.hr = pSnapshot->GetDeviceName(&bstrDeviceName);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetDeviceName");

                // add snapshot volumes to list of deleted volumes
                AddDeletedVolume(bstrDeviceName);

                LONG lContext;
                ft.hr = pSnapshotSetDescription->GetContext(&lContext);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetContext");

                if (uSnapshotsCount == 1)
                    {
                    // snapshot set contains only one snapshot.  Delete
                    // the entire snapshot sest
                    if (pSnapshotSetPrev == NULL)
                        m_pList = pList->m_next;
                    else
                        pSnapshotSetPrev->m_next = pList->m_next;

                    pSnapshotSetDescription->Release();
                    delete pList;
                    }
                else
                    {
                    // delete the snapshot from the snapshot set
                    ft.hr = pSnapshotSetDescription->DeleteSnapshotDescription(SourceObjectId);
                    ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::DeleteSnapshotDescription");
                    }

                // indicate that the snapshot set list was changed
                if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
                    m_bChanged = true;

                // indicate that the snapshot set was found and deleted
                fFound = true;
                break;
                }
            }

        // break out of loop if snapshot was found
        if (fFound)
            break;

        pSnapshotSetPrev = pList;
        }

    if (pList == NULL)
        ft.Throw
            (
            VSSDBG_COORD,
            VSS_E_OBJECT_NOT_FOUND,
            L"Snapshot not found" WSTR_GUID_FMT,
            GUID_PRINTF_ARG(SourceObjectId)
            );

    // notify hardware provider of any luns that are now free.
    ProcessDeletedVolumes();
    }

// scan the list of deleted snapshot volumes to determine if any underlying
// drives are now empty and can therefore be recycled.
void CVssHardwareProviderWrapper::ProcessDeletedVolumes()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::ProcessDeletedVolumes");

    DISK_EXTENT *rgExtents = NULL;
    LPBYTE bufExtents = NULL;
    DWORD cbBufExtents = 1024;

    try
        {
        LPWSTR wszDeletedVolumes = m_wszDeletedVolumes;

        rgExtents = new DISK_EXTENT[64];
        UINT cExtentsMax = 64;
        UINT cExtentsUsed = 0;

        if (rgExtents == NULL)
            ft.Throw (VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate extent array");

        // loop through the deleted snapshot volumes
        while(*wszDeletedVolumes != L'\0')
            {
            // create handle to volume
            CVssAutoWin32Handle hVol =
                CreateFile
                    (
                    wszDeletedVolumes,
                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

            if (hVol == INVALID_HANDLE_VALUE)
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"CreateFile(Volume)");
                }

            // get extents for the volume
            if (!DoDeviceIoControl
                    (
                    hVol,
                    IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                    NULL,
                    0,
                    (LPBYTE *) &bufExtents,
                    &cbBufExtents
                    ))
                {
                ft.hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
                ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS)");
                }


            VOLUME_DISK_EXTENTS *pDiskExtents = (VOLUME_DISK_EXTENTS *) bufExtents;

            // get number of disk extents
            DWORD cExtents = pDiskExtents->NumberOfDiskExtents;

            // grow extent array if necessary
            if (cExtents + cExtentsUsed > cExtentsMax)
                {
                DISK_EXTENT *rgExtentsNew = new DISK_EXTENT[cExtents + cExtentsUsed + 64];
                if (rgExtentsNew == NULL)
                    ft.Throw (VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate extent array");

                memcpy(rgExtentsNew, rgExtents, sizeof(DISK_EXTENT) * cExtentsUsed);
                delete rgExtents;
                rgExtents = rgExtentsNew;
                cExtentsMax = cExtentsUsed + cExtents + 64;
                }

            // add extents for volume to array
            memcpy
                (
                rgExtents + cExtentsUsed,
                pDiskExtents->Extents,
                pDiskExtents->NumberOfDiskExtents * sizeof(DISK_EXTENT)
                );

            cExtentsUsed += pDiskExtents->NumberOfDiskExtents;

            // move to next volume name
            wszDeletedVolumes += wcslen(wszDeletedVolumes) + 1;
            }

        // sort all the extents we have by disk and by offset
        qsort
            (
            rgExtents,
            cExtentsUsed,
            sizeof(DISK_EXTENT),
            cmpDiskExtents
            );

        DISK_EXTENT *pExtent = rgExtents;
        DISK_EXTENT *pExtentMax = rgExtents + cExtentsUsed;

        // loop for each disk covered by an extent
        while(pExtent < pExtentMax)
            {
            // get current drive number
            DWORD DiskNo = pExtent->DiskNumber;
            WCHAR wszBuf[64];
            swprintf(wszBuf, L"\\\\.\\PHYSICALDRIVE%u", DiskNo);

                // obtain the drive layout
                {
                CVssAutoWin32Handle hDisk = CreateFile
                                            (
                                            wszBuf,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL
                                            );

                if (hDisk == INVALID_HANDLE_VALUE)
                    {
                    // all errors are remapped (and potentially logged)
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.CheckForError(VSSDBG_COORD, L"CreateFile(PhysicalDisk)");
                    }

                if (!DoDeviceIoControl
                        (
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,
                        (LPBYTE *) &bufExtents,
                        &cbBufExtents
                        ))
                    {
                    ft.hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
                    ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl(IOCTL_DISK_GET_DRIVE_LAYOUT_EX)");
                    }
                }

            DRIVE_LAYOUT_INFORMATION_EX *pLayout = (DRIVE_LAYOUT_INFORMATION_EX *) bufExtents;

            // partition count
            DWORD cPartitions = pLayout->PartitionCount;
            for(DWORD iPartition = 0; iPartition < cPartitions; iPartition++)
                {
                // get current partition
                PARTITION_INFORMATION_EX *pPartition = &pLayout->PartitionEntry[iPartition];

                // skip partition if its length is zero
                if (pPartition->PartitionLength.QuadPart == 0)
                    continue;

                // break out of loop if we have run out of extents
                if (pExtent >= pExtentMax)
                    break;

                // break out of loop if disk number of current extent does
                // not match disk number of the current drive
                if (pExtent->DiskNumber != DiskNo)
                    break;

                // break out of loop if partition does not exactly match
                // the extent
                if (pPartition->StartingOffset.QuadPart != pExtent->StartingOffset.QuadPart ||
                    pPartition->PartitionLength.QuadPart != pExtent->ExtentLength.QuadPart)
                    break;

                // move to next extent
                pExtent++;
                }


            // if all partitions of a particular drive are free then notify
            // the provider that this is the case.
            if (iPartition == cPartitions)
                NotifyDriveFree(DiskNo);

            // skip to first extent belonging to next disk
            while(pExtent < pExtentMax && pExtent->DiskNumber == DiskNo)
                pExtent++;
            }
        }
    VSS_STANDARD_CATCH(ft)

    // delete temporary buffer used by DeviceIoControls
    delete bufExtents;

    // delete array of extents
    delete rgExtents;

    // clear existing multi-sz string
    delete m_wszDeletedVolumes;
    m_wszDeletedVolumes = NULL;
    m_iwcDeletedVolumes = 0;
    m_cwcDeletedVolumes = 0;
    }

// initialize multi-sz volume name list
void CVssHardwareProviderWrapper::InitializeDeletedVolumes()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::InitializeDeletedVolumes");

    // delete current value
    delete m_wszDeletedVolumes;
    m_wszDeletedVolumes = NULL;
    m_cwcDeletedVolumes = 0;
    m_iwcDeletedVolumes = 0;

    // initialize value to 256 characters in length
    m_wszDeletedVolumes = new WCHAR[256];
    if (m_wszDeletedVolumes == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate deleted volumes string");

    // terminate multi-sz string
    m_wszDeletedVolumes[0] = L'\0';
    m_cwcDeletedVolumes = 256;
    m_iwcDeletedVolumes = 0;
    }

// add the name of a deleted snapshot volume to the list of volumes
void CVssHardwareProviderWrapper::AddDeletedVolume(LPCWSTR wszVolume)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::AddDeletedVolumes");

    // compute length of string including trailing NULL
    UINT cwc = (UINT) wcslen(wszVolume) + 1;
    if (cwc + m_iwcDeletedVolumes + 1 > m_cwcDeletedVolumes)
        {
        // grow string
        LPWSTR wszNew = new WCHAR[cwc + m_iwcDeletedVolumes + 256];
        if (wszNew == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"cannot allocate deleted volumes string");

        memcpy(wszNew, m_wszDeletedVolumes, (m_iwcDeletedVolumes + 1) * sizeof(WCHAR));
        delete m_wszDeletedVolumes;
        m_wszDeletedVolumes = wszNew;
        m_cwcDeletedVolumes = cwc + m_iwcDeletedVolumes + 256;
        }

    // append string to multi-sz
    memcpy(m_wszDeletedVolumes + m_iwcDeletedVolumes, wszVolume, cwc * sizeof(WCHAR));
    m_iwcDeletedVolumes += cwc;

    // add trailing NULL character for multi-sz
    m_wszDeletedVolumes[m_iwcDeletedVolumes] = L'\0';
    }


// delete a snapshot set
// note that either all snapshots in the set are deleted or none are.
void CVssHardwareProviderWrapper::InternalDeleteSnapshotSet
    (
    IN VSS_ID SourceObjectId,
    OUT LONG *plDeletedSnapshots,
    OUT VSS_ID *pNonDeletedSnapshotId
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::InternalDeleteSnapshotSet");

    // initialize output parameters
    *plDeletedSnapshots = 0;
    *pNonDeletedSnapshotId = GUID_NULL;


    // initialize list of deleted volumes
    InitializeDeletedVolumes();

    // previous element in list
    VSS_SNAPSHOT_SET_LIST *pListPrev = NULL;
    for(VSS_SNAPSHOT_SET_LIST *pList = m_pList; pList; )
        {
        // get snapshot set description
        IVssSnapshotSetDescription* pSnapshotSetDescription = pList->m_pDescription;
        BS_ASSERT(pSnapshotSetDescription);
        VSS_ID id;

        // get snapshot set id
        ft.hr = pSnapshotSetDescription->GetSnapshotSetId(&id);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

        if (id == SourceObjectId)
            {
            LONG lContext;
            ft.hr = pSnapshotSetDescription->GetContext(&lContext);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

            // found snapshot set to be deleted.  scan snapshots in set

            // get count of snapshots in the snapshot set
            UINT uSnapshotsCount = 0;
            ft.hr = pSnapshotSetDescription->GetSnapshotCount(&uSnapshotsCount);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotCount");
            for(UINT iSnapshot = 0; iSnapshot < uSnapshotsCount; iSnapshot++)
                {
                CComPtr<IVssSnapshotDescription> pSnapshot;

                // get snapshot set description
                ft.hr = pSnapshotSetDescription->GetSnapshotDescription(iSnapshot, &pSnapshot);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotDescription");

                // get snapshot set id.  Set it as snapshot id of failure if
                // operation fails at this point
                ft.hr = pSnapshot->GetSnapshotId(pNonDeletedSnapshotId);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetSnapshotId");

                CComBSTR bstrDeviceName;

                // get device name for snapshot volume
                ft.hr = pSnapshot->GetDeviceName(&bstrDeviceName);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotDescription::GetDeviceName");

                // add to list of deleted volumes
                AddDeletedVolume(bstrDeviceName);
                }
            // remove element from list
            if (pListPrev == NULL)
                m_pList = pList->m_next;
            else
                pListPrev->m_next = pList->m_next;


            // release XML snapshot set description
            pList->m_pDescription->Release();

            // delete list element
            delete pList;

            if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
                m_bChanged = true;

            // number of deleted snapshots is the snapshot count
            *plDeletedSnapshots = uSnapshotsCount;
            break;
            }

        // advance to next snapshot set
        pListPrev = pList;
        pList = pList->m_next;
        }

    if (pList == NULL)
        ft.Throw
            (
            VSSDBG_COORD,
            VSS_E_OBJECT_NOT_FOUND,
            L"Snapshot set not found: " WSTR_GUID_FMT,
            GUID_PRINTF_ARG(SourceObjectId)
            );

    // notify underlying hardware provider if any luns are now free
    ProcessDeletedVolumes();
    }

// delete all snapshots for snapshot sets that are auto release
void CVssHardwareProviderWrapper::DeleteAutoReleaseSnapshots()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::DeleteAutoReleaseSnapshots");

    try
        {
        VSS_SNAPSHOT_SET_LIST *pListNext = NULL;
        for(VSS_SNAPSHOT_SET_LIST *pList = m_pList; pList; pList = pListNext)
            {
            // get snapshot set description
            IVssSnapshotSetDescription* pSnapshotSetDescription = pList->m_pDescription;
            BS_ASSERT(pSnapshotSetDescription);

            pListNext = pList->m_next;

            LONG lContext;

            // get snapshot context
            ft.hr = pSnapshotSetDescription->GetContext(&lContext);
            ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");

            if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0)
                {
                VSS_ID SnapshotSetId;
                // get snapshot set id
                ft.hr = pSnapshotSetDescription->GetSnapshotSetId(&SnapshotSetId);
                ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

                LONG lDeletedSnapshots;
                VSS_ID NonDeletedSnapshotId;
                InternalDeleteSnapshotSet(SnapshotSetId, &lDeletedSnapshots, &NonDeletedSnapshotId);
                }
            }
        }
    VSS_STANDARD_CATCH(ft)
    }

// notify the hardware provider that a lun is free
void CVssHardwareProviderWrapper::NotifyDriveFree(DWORD DiskNo)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::NotifyDriveFree");


    // construct name of the drive
    WCHAR wszBuf[64];
    swprintf(wszBuf, L"\\\\.\\PHYSICALDRIVE%u", DiskNo);

    // allocate lun information
    VDS_LUN_INFORMATION *pLun = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(sizeof(VDS_LUN_INFORMATION));
    if (pLun == NULL)
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate VDS_LUN_INFORMATION");

    try
        {
        // clera lun information in case build fails
        memset(pLun, 0, sizeof(VDS_LUN_INFORMATION));
        if (BuildLunInfoForDrive(wszBuf, pLun))
            {
            BS_ASSERT(m_pHWItf);

            // call provider
            ft.hr = m_pHWItf->OnLunEmpty(pLun);
            if (ft.HrFailed())
                ft.TranslateProviderError(VSSDBG_COORD, m_ProviderId, L"OnLunEmpty");
            }
        }
    VSS_STANDARD_CATCH(ft)

    // free lun information
    FreeLunInfo(pLun, 1);
    }



// unhide a partition that is marked as hidden.  This is used when breaking
// a snapshot set
void CVssHardwareProviderWrapper::UnhidePartition(LPCWSTR wszPartition)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::UnhidePartition");

    // open handle to volume
    CVssAutoWin32Handle hVol = CreateFile
                    (
                    wszPartition,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (hVol == INVALID_HANDLE_VALUE)
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"CreateFile(VOLUME)");
        }

    // get attributes
    DWORD size;
    VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   getAttributesInfo;
    VOLUME_SET_GPT_ATTRIBUTES_INFORMATION setAttributesInfo;

    if (!DeviceIoControl
            (
            hVol,
            IOCTL_VOLUME_GET_GPT_ATTRIBUTES,
            NULL,
            0,
            &getAttributesInfo,
            sizeof(getAttributesInfo),
            &size,
            NULL
            ))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl(IOCTL_VOLUME_GET_GPT_ATTRIBUTES)");
        }


    // hide volume
    memset(&setAttributesInfo, 0, sizeof(setAttributesInfo));
    setAttributesInfo.GptAttributes = getAttributesInfo.GptAttributes;
    setAttributesInfo.GptAttributes &= ~GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
    if (!DeviceIoControl
            (
            hVol,
            IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
            &setAttributesInfo,
            sizeof(setAttributesInfo),
            NULL,
            0,
            &size,
            NULL
            ))
        {
        // try doing operation again with ApplyToAllConnectedVolumes set
        // required for MBR disks
        setAttributesInfo.ApplyToAllConnectedVolumes = FALSE;
        if (!DeviceIoControl
                (
                hVol,
                IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
                &setAttributesInfo,
                sizeof(setAttributesInfo),
                NULL,
                0,
                &size,
                NULL
                ))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
            }
        }
    }

// get volume name for volume containing the system root
void CVssHardwareProviderWrapper::GetBootDrive
    (
    OUT LPWSTR buf
    )
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::GetBootDrive");

    if (!GetSystemDirectory(buf, MAX_PATH))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"GetSystemDirectory");
        }

    INT iwc = (INT) wcslen(buf);
    while(--iwc > 0)
        {
        if (buf[iwc] == L'\\')
            {
            WCHAR volname[64];

            buf[iwc+1] = L'\0';
            if (GetVolumeNameForVolumeMountPoint(buf, volname, 64))
                break;
            }
        }

    if (iwc == 0)
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"GetVolumeNameForVolumeMountPoint");
        }
    }


static LPCWSTR x_wszSnapshotDatabase = L"HardwareSnapshotsDatabase";
static LPCWSTR x_wszAlternateSnapshotDatabase = L"AlternateHardwareSnapshotDatabase";

static const DWORD x_DBSignature = 0x9d4feff5;
static const DWORD x_DBVersion = 1;


// create a data store for the snapshot sets for this provider
void CVssHardwareProviderWrapper::CreateDataStore(bool bAlt)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper:CreateDataStore");

    SECURITY_ATTRIBUTES *psa = NULL;
    WCHAR wcsPath[MAX_PATH+64];

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    SID *pSid = NULL;

    struct
        {
        ACL acl;                          // the ACL header
        BYTE rgb[ 128 - sizeof(ACL) ];     // buffer to hold 2 ACEs
        } DaclBuffer;

    struct
        {
        ACL acl;                          // the ACL header
        BYTE rgb[ 128 - sizeof(ACL) ];     // buffer to hold 2 ACEs
        } DaclBuffer2;

    SID_IDENTIFIER_AUTHORITY SaNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SaWorld = SECURITY_WORLD_SID_AUTHORITY;

    if (!InitializeAcl(&DaclBuffer.acl, sizeof(DaclBuffer), ACL_REVISION))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"InitializeAcl");
        }

    // Create the SID.  We'll give the local system full access
    if (!AllocateAndInitializeSid
            (
            &SaNT,  // Top-level authority
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            (void **) &pSid
            ))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"AllocateAndInitializeSid");
        }
    try
        {
        if (!AddAccessAllowedAce
                (
                &DaclBuffer.acl,
                ACL_REVISION,
                STANDARD_RIGHTS_ALL | GENERIC_ALL,
                pSid
                ))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"AddAccessAllowedAce");
            }

        if (!InitializeAcl(&DaclBuffer2.acl, sizeof(DaclBuffer2), ACL_REVISION))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"InitializeAcl");
            }

        FreeSid (pSid);
        pSid = NULL;
        if(!AllocateAndInitializeSid
                (
                &SaWorld,  // Top-level authority
                1,
                SECURITY_WORLD_RID,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                (void **) &pSid
                ))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"AllocateAndInitializeSid");
            }


        if (!AddAccessAllowedAceEx
                (
                &DaclBuffer2.acl,
                ACL_REVISION,
                CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                STANDARD_RIGHTS_ALL | GENERIC_ALL,
                pSid
                ))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"AddAccessAllowedAceEx");
            }

        // Set up the security descriptor with that DACL in it.

        if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"InitializeSecurityDescriptor");
            }

        if(!SetSecurityDescriptorDacl(&sd, TRUE, &DaclBuffer.acl, FALSE))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"SetSecurityDescriptorDacl");
            }



        // Put the security descriptor into the security attributes.
        ZeroMemory (&sa, sizeof(sa));
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = TRUE;
        psa = &sa;

        WCHAR buf[MAX_PATH];

        GetBootDrive(buf);

        // create "System Volume Information" if it does not exist
        // set "system only" dacl on this directory
        // make this S+H+non-CI

        wsprintf(wcsPath, L"%sSystem Volume Information", buf);
        if (-1 == GetFileAttributes(wcsPath))
            {
            if (FALSE == CreateDirectory(wcsPath, psa))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"CreateDirectory");
                }

            if (!SetFileAttributes
                    (
                    wcsPath,
                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                        FILE_ATTRIBUTE_HIDDEN |
                        FILE_ATTRIBUTE_SYSTEM
                    ))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"SetFileAttributes");
                }
            }

        // now create our file
        swprintf(
                wcsPath,
                L"%sSystem Volume Information\\%s" WSTR_GUID_FMT,
                buf,
                bAlt ? x_wszAlternateSnapshotDatabase : x_wszSnapshotDatabase,
                GUID_PRINTF_ARG(m_ProviderId)
                );

        if (-1 == GetFileAttributes(wcsPath))
            {
            CVssAutoWin32Handle h = CreateFile
                                        (
                                        wcsPath,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        psa,
                                        CREATE_NEW,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        );

            if (h == INVALID_HANDLE_VALUE)
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"CreateFile");
                }



            if (!SetFileAttributes
                    (
                    wcsPath,
                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                        FILE_ATTRIBUTE_HIDDEN |
                        FILE_ATTRIBUTE_SYSTEM
                    ))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"SetFileAttributes");
                }

            VSS_HARDWARE_SNAPSHOTS_HDR hdr;
            hdr.m_identifier = x_DBSignature;
            hdr.m_version = x_DBVersion;
            hdr.m_NumberOfSnapshotSets = 0;

            DWORD dwWritten;
            if (!WriteFile
                    (
                    h,
                    &hdr,
                    sizeof(hdr),
                    &dwWritten,
                    NULL
                    ))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"WriteFile");
                }
            }
        }
    catch(...)
        {
        if (pSid != NULL)
            FreeSid (pSid);

        throw;
        }

    if (pSid != NULL)
        FreeSid (pSid);
    }

HANDLE CVssHardwareProviderWrapper::OpenDatabase(bool bAlt)
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::OpenDatabase");

    WCHAR wcsPath[MAX_PATH+64];
    GetBootDrive(wcsPath);

    LPWSTR pwc = wcsPath + wcslen(wcsPath);


    // try opening the file
    swprintf
            (
            pwc,
            L"System Volume Information\\%s" WSTR_GUID_FMT,
            bAlt ? x_wszAlternateSnapshotDatabase : x_wszSnapshotDatabase,
            GUID_PRINTF_ARG(m_ProviderId)
            );

    if (GetFileAttributes(wcsPath) == -1)
        CreateDataStore(bAlt);

    HANDLE h = CreateFile
                    (
                    wcsPath,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (h == INVALID_HANDLE_VALUE)
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"CreateFile(VOLUME)");
        }

    return h;
    }


// load snapshot set data into wrapper
void CVssHardwareProviderWrapper::LoadData()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::LoadData");

    CVssSafeAutomaticLock lock(m_csList);

    CVssAutoWin32Handle h = OpenDatabase(false);

    VSS_HARDWARE_SNAPSHOTS_HDR hdr;
    DWORD cbRead;

    if (!ReadFile(h, &hdr, sizeof(hdr), &cbRead, NULL))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"ReadFile");
        }

    BS_ASSERT(cbRead == sizeof(hdr));

    if (hdr.m_identifier != x_DBSignature ||
        hdr.m_version != x_DBVersion)
        {
        ft.LogError(VSS_ERROR_BAD_SNAPSHOT_DATABASE, VSSDBG_COORD);
        ft.Throw
            (
            VSSDBG_COORD,
            E_UNEXPECTED,
            L"Contents of the hardware snapshot set database are invalid"
            );
        }

    DWORD cSnapshots = hdr.m_NumberOfSnapshotSets;
    while(cSnapshots-- != 0)
        {
        VSS_SNAPSHOT_SET_HDR sethdr;

        if (!ReadFile(h, &sethdr, sizeof(sethdr), &cbRead, NULL))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"ReadFile");
            }

        BS_ASSERT(cbRead == sizeof(sethdr));

        VSS_SNAPSHOT_SET_LIST *pList = NULL;
        LPWSTR wsz = new WCHAR[sethdr.m_cwcXML];

        if (wsz == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cant allocate XML string");

        try
            {
            pList = new VSS_SNAPSHOT_SET_LIST;
            if (pList == NULL)
                ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cant allocate snapshot set description");

            if (!ReadFile(h, wsz, sethdr.m_cwcXML*sizeof(WCHAR), &cbRead, NULL))
                {
                ft.hr = HRESULT_FROM_WIN32(GetLastError());
                ft.CheckForError(VSSDBG_COORD, L"ReadFile");
                }

            BS_ASSERT(cbRead == sethdr.m_cwcXML * sizeof(WCHAR));

            ft.hr = LoadVssSnapshotSetDescription(wsz, &pList->m_pDescription);
            ft.CheckForError(VSSDBG_COORD, L"LoadVssSnapshotSetDescription");
            pList->m_next = m_pList;
            m_pList = pList;
            delete wsz;
            wsz = NULL;
            }
        catch(...)
            {
            delete wsz;
            delete pList;
            throw;
            }
        }
    }

void CVssHardwareProviderWrapper::SaveData()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CHardwareProviderWrapper::SaveData");

    CVssSafeAutomaticLock lock(m_csList);

    CVssAutoWin32Handle h = OpenDatabase(true);

    VSS_HARDWARE_SNAPSHOTS_HDR hdr;
    DWORD cbWritten;

    hdr.m_identifier = x_DBSignature;
    hdr.m_version = x_DBVersion;
    hdr.m_NumberOfSnapshotSets = 0;
    VSS_SNAPSHOT_SET_LIST *pList = m_pList;
    while(pList)
        {
        IVssSnapshotSetDescription *pSnapshotSet = pList->m_pDescription;
        LONG lContext;
        ft.hr = pSnapshotSet->GetContext(&lContext);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");
        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) != 0)
            hdr.m_NumberOfSnapshotSets += 1;

        pList = pList->m_next;
        }

    if (!WriteFile(h, &hdr, sizeof(hdr), &cbWritten, NULL) ||
        cbWritten != sizeof(hdr))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"WriteFile");
        }


    pList = m_pList;
    while(pList != NULL)
        {
        LONG lContext;
        ft.hr = pList->m_pDescription->GetContext(&lContext);
        ft.CheckForError(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetContext");
        if ((lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0)
            {
            pList = pList->m_next;
            continue;
            }

        CComBSTR bstrXML;
        ft.hr = pList->m_pDescription->SaveAsXML(&bstrXML);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::SaveAsXML");

        VSS_SNAPSHOT_SET_HDR sethdr;

        sethdr.m_cwcXML = (UINT) wcslen(bstrXML) + 1;

        ft.hr = pList->m_pDescription->GetSnapshotSetId(&sethdr.m_idSnapshotSet);
        ft.CheckForErrorInternal(VSSDBG_COORD, L"IVssSnapshotSetDescription::GetSnapshotSetId");

        if (!WriteFile(h, &sethdr, sizeof(sethdr), &cbWritten, NULL) ||
            cbWritten != sizeof(sethdr))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"WriteFile");
            }

        if (!WriteFile(h, bstrXML, sethdr.m_cwcXML * sizeof(WCHAR), &cbWritten, NULL) ||
            cbWritten != sethdr.m_cwcXML * sizeof(WCHAR))
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_COORD, L"WriteFile");
            }

        pList = pList->m_next;
        }

    h.Close();

    WCHAR wcsPathSource[MAX_PATH+64];
    WCHAR wcsPathDest[MAX_PATH+64];
    GetBootDrive(wcsPathSource);
    wcscpy(wcsPathDest, wcsPathSource);

    LPWSTR pwc = wcsPathSource + wcslen(wcsPathSource);

    // try opening the file
    swprintf
            (
            pwc,
            L"System Volume Information\\%s" WSTR_GUID_FMT,
            x_wszAlternateSnapshotDatabase,
            GUID_PRINTF_ARG(m_ProviderId)
            );

    pwc = wcsPathDest + wcslen(wcsPathDest);

    // try opening the file
    swprintf
            (
            pwc,
            L"System Volume Information\\%s" WSTR_GUID_FMT,
            x_wszSnapshotDatabase,
            GUID_PRINTF_ARG(m_ProviderId)
            );

    if (!MoveFileEx
            (
            wcsPathSource,
            wcsPathDest,
            MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH
            ))
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_COORD, L"MoveFileEx");
        }
    }


// load snapshot set database if necessary
void CVssHardwareProviderWrapper::CheckLoaded()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::CheckLoaded");

    if (!m_bLoaded)
        {
        BS_ASSERT(m_pList == NULL);
        try
            {
            LoadData();
            }
        catch(...)
            {
            }

        m_bLoaded = true;
        }
    }



// try saving snapshot set database
void CVssHardwareProviderWrapper::TrySaveData()
    {
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssHardwareProviderWrapper::TrySaveData");

    if (m_bChanged)
        {
        try
            {
            SaveData();
            m_bChanged = false;
            }
        VSS_STANDARD_CATCH(ft)

        if (ft.HrFailed())
            ft.LogError(VSS_ERROR_CANNOT_SAVE_SNAPSHOT_DATABASE, VSSDBG_COORD << ft.hr);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\coord.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssCoordinator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
    aoltean     09/21/1999  Adding a new header for the "ptr" class.
    aoltean     09/27/1999  Provider-generic code.
    aoltean     10/04/1999  Treatment of writer error codes.
    aoltean     10/12/1999  Adding HoldWrites, ReleaseWrites
    aoltean     10/12/1999  Moving all code in Snap_set.cxx in order to facilitate the async interface.
    aoltean     10/15/1999  Adding async support

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

 #include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "admin.hxx"
#include "provmgr.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "async_shim.hxx"
#include "coord.hxx"
#include "vs_sec.hxx"


#include "async.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORCOORC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssCoordinator


STDMETHODIMP CVssCoordinator::StartSnapshotSet(
    OUT     VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:

    Implements IVssCoordinator::StartSnapshotSet

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
        - CVssSnapshotSetObject::CreateInstance failures
    VSS_E_BAD_STATE
        - wrong context

    [CVssSnapshotSetObject::StartSnapshotSet() failures]
        E_OUTOFMEMORY
        VSS_E_BAD_STATE
            - wrong calling sequence.
        E_UNEXPECTED
            - if CoCreateGuid fails

        [Deactivate() failures] or
        [Activate() failures]
            [lockObj failures]
                E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::StartSnapshotSet" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSnapshotSetId );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: pSnapshotSetId = %p", pSnapshotSetId );

        // Argument validation
        BS_ASSERT(pSnapshotSetId);
        if (pSnapshotSetId == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pSnapshotSetId");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Check if we can create snapshots in this context
        if (!IsSnapshotCreationAllowed())
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Bad state: attempting to create snapshots in wrong context %ld",
                        GetContextInternal());

        // Create the snapshot object, if needed.
        // This call may throw
        // Remark: we cannot re-create this interface since the automatic garbage collection
        // requires that the snapshot set object should be alive.
        if (m_pSnapshotSet == NULL)
            m_pSnapshotSet = CVssSnapshotSetObject::CreateInstance();

        // Set the snapshot set context
        FreezeContext();
        m_pSnapshotSet->SetContextInternal(GetContextInternal());

        // Call StartSnapshotSet on the given object.
        ft.hr = m_pSnapshotSet->StartSnapshotSet(pSnapshotSetId);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
                      L"Internal StartSnapshotSet failed. 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,
    IN      VSS_ID      ProviderId,
    OUT     VSS_ID *    pSnapshotId
    )
/*++

Routine description:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [CVssCoordinator::IsVolumeSupported() failures]
        E_ACCESSDENIED
            The user is not a backup operator.
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        VSS_E_PROVIDER_NOT_REGISTERED
            The Provider ID does not correspond to a registered provider.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

        [CVssProviderManager::GetProviderInterface() failures]
            [lockObj failures]
                E_OUTOFMEMORY

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [CVssProviderManager::GetProviderItfArray() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_ACCESSDENIED
                The user is not an administrator.
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            E_UNEXPECTED
                Unexpected programming error. Logging not done and not needed.
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                The device does not exist or it is not ready.


    [CVssSnapshotSetObject::AddToSnapshotSet() failures]
        E_OUTOFMEMORY
        VSS_E_BAD_STATE
            - wrong calling sequence.
        E_INVALIDARG
            - Invalid arguments (for example the volume name is invalid).
        VSS_E_VOLUME_NOT_SUPPORTED
            - The volume is not supported by any registered providers

        [GetSupportedProviderId() failures]
            E_OUTOFMEMORY
            E_INVALIDARG
                - if the volume is not in the correct format.
            VSS_E_VOLUME_NOT_SUPPORTED
                - If the given volume is not supported by any provider

            [QuerySupportedProvidersIntoArray() failures]
                E_OUTOFMEMORY

                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    Unexpected provider error on calling IsVolumeSupported

                [lockObj failures]
                    E_OUTOFMEMORY

                [LoadInternalProvidersArray() failures]
                    E_OUTOFMEMORY
                    E_UNEXPECTED
                        - error while reading from registry. An error log entry is added describing the error.

                [GetProviderInterface failures]
                    [lockObj failures]
                        E_OUTOFMEMORY

                    [GetProviderInterfaceInternal() failures]
                        E_OUTOFMEMORY

                        [CoCreateInstance() failures]
                            VSS_E_UNEXPECTED_PROVIDER_ERROR
                                - The provider interface couldn't be created. An error log entry is added describing the error.

                        [QueryInterface failures]
                            VSS_E_UNEXPECTED_PROVIDER_ERROR
                                - Unexpected provider error. An error log entry is added describing the error.

                        [OnLoad() failures]
                            VSS_E_UNEXPECTED_PROVIDER_ERROR
                                - Unexpected provider error. The error code is logged into the event log.
                            VSS_E_PROVIDER_VETO
                                - Expected provider error. The provider already did the logging.

                        [SetContext() failures]
                            VSS_E_UNEXPECTED_PROVIDER_ERROR
                                - Unexpected provider error. The error code is logged into the event log.

                [InitializeAsProvider() failures]
                    E_OUTOFMEMORY

                [IVssSnapshotProvider::IsVolumeSupported() failures]
                    E_INVALIDARG
                        NULL pointers passed as parameters or a volume name in an invalid format.
                    E_OUTOFMEMORY
                        Out of memory or other system resources
                    VSS_E_PROVIDER_VETO
                        An error occured while opening the IOCTL channel. The error is logged.
                    VSS_E_OBJECT_NOT_FOUND
                        If the volume name does not correspond to an existing mount point

        [GetProviderInterfaceForSnapshotCreation() failures]
            VSS_E_PROVIDER_NOT_REGISTERED

            [lockObj failures]
                E_OUTOFMEMORY

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [CVssQueuedVolumesList::AddVolume() failures]
            E_UNEXPECTED
                - The thread state is incorrect. No logging is done - programming error.
            VSS_E_OBJECT_ALREADY_EXISTS
                - The volume was already added to the snapshot set.
            VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
                - The maximum number of volumes was reached.
            E_OUTOFMEMORY

            [Initialize() failures]
                E_OUTOFMEMORY

        [BeginPrepareSnapshot() failures]
            E_INVALIDARG
            VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
            VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - Volume not found or device not connected.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::AddToSnapshotSet" );

    try
    {
        // Initialize out parameters
        ::VssZeroOut(pSnapshotId);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  VolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pSnapshotId = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             pSnapshotId);

        // Argument validation
        if (pwszVolumeName == NULL || wcslen(pwszVolumeName) == 0)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pSnapshotId == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pSnapshotId");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Check if the snapshot object is created.
        if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        // The context must be already frozen
        BS_ASSERT(IsContextFrozen());

        // Check to see if the volume is supported
        BOOL bIsVolumeSupported = FALSE;
        ft.hr = IsVolumeSupported( ProviderId, pwszVolumeName, &bIsVolumeSupported);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_COORD, ft.hr,
                L"IsVolumeSupported() failed with error code 0x%08lx", ft.hr);
        if (!bIsVolumeSupported)
            ft.Throw(VSSDBG_COORD,
                (ProviderId == GUID_NULL)?
                    VSS_E_VOLUME_NOT_SUPPORTED: VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume not supported");

        // Call StartSnapshotSet on the given object.
        ft.hr = m_pSnapshotSet->AddToSnapshotSet( pwszVolumeName,
            ProviderId,
            pSnapshotId);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
                      L"Internal AddToSnapshotSet failed. 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::DoSnapshotSet(
    IN     IDispatch*  pWriterCallback,
    OUT     IVssAsync** ppAsync
    )
/*++

Routine description:

    Implements IVssCoordinator::DoSnapshotSet
    Calls synchronously the CVssSnapshotSetObject::DoSnapshotSet in a separate thread

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssAsync::CreateInstanceAndStartJob] failures]
        E_OUTOFMEMORY
            - On CComObject<CVssAsync>::CreateInstance failure
            - On PrepareJob failure
            - On StartJob failure

        E_UNEXPECTED
            - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::DoSnapshotSet" );

    try
    {
        // Nullify all out parameters
        ::VssZeroOutPtr(ppAsync);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Check if the snapshot object is created.
        if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        // The context must be already frozen
        BS_ASSERT(IsContextFrozen());

    if (ppAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL async interface.");

        // save callback interface
        m_pSnapshotSet->SetWriterCallback(pWriterCallback);

        // Create the new async interface corresponding to the new job.
        // Remark: AddRef will be called on the snapshot set object.
        CComPtr<IVssAsync> ptrAsync;
        ptrAsync.Attach(CVssAsync::CreateInstanceAndStartJob( m_pSnapshotSet));

        // The reference count of the pAsync interface must be 2
        // (one for the returned interface and one for the background thread).
        (*ppAsync) = ptrAsync.Detach(); // Drop that interface in the OUT parameter

        // The ref count remnains 2
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
    OUT     VSS_SNAPSHOT_PROP   *pProp
    )
/*++

Routine description:

    Implements IVssCoordinator::GetSnapshotProperties

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::GetSnapshotProperties() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            - The snapshot with this ID does not exists.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::GetSnapshotProperties" );

    try
    {
        // Initialize [out] arguments
        ::VssZeroOut( pProp );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT L"\n"
             L"  pProp = %p\n",
             GUID_PRINTF_ARG( SnapshotId ),
             pProp);

        // Argument validation
        BS_ASSERT(pProp);
        if (pProp == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pProp");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Get the array of interfaces
        CVssSnapshotProviderItfMap* pItfMap;
        CVssProviderManager::GetProviderItfArray( GetContextInternal(), &pItfMap );
        BS_ASSERT(pItfMap);

        // For each provider get all objects tht corresponds to the filter
        for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
        {
            CComPtr<IVssSnapshotProvider> pProviderItf = pItfMap->GetValueAt(nIndex);
            if (pProviderItf == NULL)
                continue;

            // Get the snapshot interface
            ft.hr = pProviderItf->GetSnapshotProperties(
                SnapshotId,
                pProp);

            // If a snapshot was not found then continue with the next provider.
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                continue;

            // If an error happened then abort the entire search.
            if (ft.HrFailed())
                ft.TranslateProviderError( VSSDBG_COORD, pItfMap->GetKeyAt(nIndex),
                    L"GetSnapshot("WSTR_GUID_FMT L",%p)",
                    GUID_PRINTF_ARG(SnapshotId), pProp);

            // The snapshot was found
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    // The ft.hr may be an VSS_E_OBJECT_NOT_FOUND or not.
    return ft.hr;
}


STDMETHODIMP CVssCoordinator::ExposeSnapshot(
    IN      VSS_ID SnapshotId,
    IN      VSS_PWSZ wszPathFromRoot,
    IN      LONG lAttributes,
    IN      VSS_PWSZ wszExpose,
    OUT     VSS_PWSZ *pwszExposed
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::ExposeSnapshot" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(wszPathFromRoot);
    UNREFERENCED_PARAMETER(lAttributes);
    UNREFERENCED_PARAMETER(wszExpose);
    UNREFERENCED_PARAMETER(pwszExposed);
}


STDMETHODIMP CVssCoordinator::RemountReadWrite(
    IN      VSS_ID SnapshotId,
    OUT     IVssAsync** ppAsync
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::RemountReadWrite" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(ppAsync);
}


STDMETHODIMP CVssCoordinator::ImportSnapshots(
    IN      BSTR bstrXMLSnapshotSet,
    OUT     IVssAsync** ppAsync
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::ImportSnapshots" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(bstrXMLSnapshotSet);
    UNREFERENCED_PARAMETER(ppAsync);
}


STDMETHODIMP CVssCoordinator::BreakSnapshotSet(
    [in]    VSS_ID          SnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::BreakSnapshotSet" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotSetId);
}


STDMETHODIMP CVssCoordinator::IsVolumeSupported(
    IN      VSS_ID          ProviderId,
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbIsSupported
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the
    corresponding provider.

Parameters
    ProviderID
        [in] It can be:
            - GUID_NULL: in this case the function checks if the volume is supported
            by at least one provider
            - A provider ID: In this case the function checks if the volume is supported
            by the indicated provider
    pwszVolumeName
        [in] The volume name to be checked, It must represent a volume mount point, like
        in the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format or c:\
        (with trailing backslash)
    pbIsSupported
        [out] Non-NULL pointer that receives TRUE if the volume can be
        snapshotted using this provider or FALSE otherwise.

Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not a backup operator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_OBJECT_NOT_FOUND
        If the volume name does not correspond to an existing mount point or volume.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported

    [CVssProviderManager::GetProviderInterface() failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

    [VerifyVolumeIsSupportedByVSS]
        VSS_E_OBJECT_NOT_FOUND
            - The volume was not found

Remarks
    The function will return TRUE in the pbSupportedByThisProvider
    parameter if it is possible to create a snapshot on the given volume.
    The function must return TRUE on that volume even if the current
    configuration does not allow the creation of a snapshot on that volume.
    For example, if the maximum number of snapshots were reached on the
    given volume (and therefore no more snapshots can be created on that volume),
    the method must still indicate that the volume can be snapshotted.

--*/


{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::IsVolumeSupported" );
    WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pbIsSupported );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             pwszVolumeName,
             pbIsSupported);

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbIsSupported == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid bool ptr");

        // Getting the volume name
        if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
                wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
            ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
                      L"GetVolumeNameForVolumeMountPoint(%s,...) "
                      L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
        BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
        BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Freeze context
        FreezeContext();

        // Verify if the volume is supported by VSS itself.
        // If not this will throw an VSS_E_VOLUME_NOT_SUPPORTED exception
        VerifyVolumeIsSupportedByVSS( wszVolumeNameInternal );

        // Choose the way of checking if the volume is supported
        if (ProviderId != GUID_NULL) {
            // Try to find the provider interface
            CComPtr<IVssSnapshotProvider> pProviderItf;
            if (!(CVssProviderManager::GetProviderInterface(ProviderId, GetContextInternal(), pProviderItf)))
                ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED,
                    L"Provider not found");

            // Call the Provider's IsVolumeSupported
            BS_ASSERT(pProviderItf);
            ft.hr = pProviderItf->IsVolumeSupported(
                        wszVolumeNameInternal, pbIsSupported);
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD,
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
            if (ft.HrFailed())
                ft.TranslateProviderError( VSSDBG_COORD, ProviderId,
                    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );
        } else {
            CComPtr<IVssSnapshotProvider> pProviderItf;

            // Get the array of interfaces
            CVssSnapshotProviderItfMap* pItfMap;
            CVssProviderManager::GetProviderItfArray( GetContextInternal(), &pItfMap );
            BS_ASSERT(pItfMap);

            // Ask each provider if the volume is supported.
            // If we find at least one provider that supports the
            // volume then stop iteration.
            for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
            {
                pProviderItf = pItfMap->GetValueAt(nIndex);
                if (pProviderItf == NULL)
                    continue;

                BOOL bVolumeSupportedByThisProvider = FALSE;
                ft.hr = pProviderItf->IsVolumeSupported(
                            wszVolumeNameInternal, &bVolumeSupportedByThisProvider);
                if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                    ft.Throw(VSSDBG_COORD,
                        VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
                if (ft.HrFailed())
                    ft.TranslateProviderError( VSSDBG_COORD, pItfMap->GetKeyAt(nIndex),
                        L"Cannot ask provider " WSTR_GUID_FMT
                        L" if volume is supported. [0x%08lx]",
                        GUID_PRINTF_ARG(pItfMap->GetKeyAt(nIndex)), ft.hr);

                // Check to see if the volume is supported by this provider.
                if (bVolumeSupportedByThisProvider) {
                    BS_ASSERT(pbIsSupported);
                    (*pbIsSupported) = TRUE;
                    break;
                }
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

    // If an exception was thrown from VerifyVolumeIsSupportedByVSS
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::IsVolumeSnapshotted(
    IN      VSS_ID          ProviderId,
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
    OUT     LONG *          plSnapshotCompatibility
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the
    corresponding provider.

Parameters
    ProviderID
        [in] It can be:
            - GUID_NULL: in this case the function checks if the volume is supported
            by at least one provider
            - A provider ID
    pwszVolumeName
        [in] The volume name to be checked, It mus represent a mount point, like
        in the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format or c:\
        (with trailing backslash)
    pbSnapshotPresent
        [out] Non-NULL pointer that receives TRUE if the volume has at least
        one snapshot or FALSE otherwise.

Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not a backup operator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_OBJECT_NOT_FOUND
        If the volume name does not correspond to an existing mount point or volume.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSnapshotted

    [CVssProviderManager::GetProviderInterface() failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [IVssSnapshotProvider::IsVolumeSnapshotted() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

    [VerifyVolumeIsSupportedByVSS]
        VSS_E_OBJECT_NOT_FOUND
            - The volume was not found

Remarks
    The function will return S_OK even if the current volume is a non-supported one.
    In this case FALSE must be returned in the pbSnapshotPresent parameter.

--*/


{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::IsVolumeSnapshotted" );
    WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pbSnapshotsPresent );
        VssZeroOut( plSnapshotCompatibility );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n"
             L"  plSnapshotCompatibility = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             pwszVolumeName,
             pbSnapshotsPresent,
             plSnapshotCompatibility
             );

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSnapshotsPresent == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid bool ptr");
        if (plSnapshotCompatibility == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid ptr");

        // Getting the volume name
        if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
                wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
            ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
                      L"GetVolumeNameForVolumeMountPoint(%s,...) "
                      L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
        BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
        BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Freeze context
        FreezeContext();

        // Verify if the volume is supported by VSS itself.
        // If not this will throw an VSS_E_VOLUME_NOT_SUPPORTED exception
        VerifyVolumeIsSupportedByVSS( wszVolumeNameInternal );

        // Choose the way of checking if the volume is supported
        if (ProviderId != GUID_NULL) {
            // Try to find the provider interface
            CComPtr<IVssSnapshotProvider> pProviderItf;
            if (!(CVssProviderManager::GetProviderInterface(ProviderId, GetContextInternal(), pProviderItf)))
                ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED,
                    L"Provider not found");

            // Call the Provider's IsVolumeSnapshotted
            BS_ASSERT(pProviderItf);
            ft.hr = pProviderItf->IsVolumeSnapshotted(
                        wszVolumeNameInternal,
                        pbSnapshotsPresent,
                        plSnapshotCompatibility);
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD,
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
            if (ft.HrFailed())
                ft.TranslateProviderError( VSSDBG_COORD, ProviderId,
                    L"IVssSnapshotProvider::IsVolumeSnapshotted() failed with 0x%08lx", ft.hr );
        } else {
            CComPtr<IVssSnapshotProvider> pProviderItf;

            // Get the array of interfaces
            CVssSnapshotProviderItfMap* pItfMap;
            CVssProviderManager::GetProviderItfArray( GetContextInternal(), &pItfMap );
            BS_ASSERT(pItfMap);

            // Ask each provider if the volume is supported.
            // If we find at least one provider that supports the
            // volume then stop iteration.
            bool bObjectFound = false;
            for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
            {
                pProviderItf = pItfMap->GetValueAt(nIndex);
                if (pProviderItf == NULL)
                    continue;

                BOOL bVolumeSnapshottedByThisProvider = FALSE;
                LONG lSnapshotCompatibility = 0;
                ft.hr = pProviderItf->IsVolumeSnapshotted(
                            wszVolumeNameInternal,
                            &bVolumeSnapshottedByThisProvider,
                            &lSnapshotCompatibility);
                if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                    continue;
                if (ft.HrFailed())
                    ft.TranslateProviderError( VSSDBG_COORD, pItfMap->GetKeyAt(nIndex),
                        L"Cannot ask provider " WSTR_GUID_FMT
                        L" if volume is snapshotted. [0x%08lx]",
                        GUID_PRINTF_ARG(pItfMap->GetKeyAt(nIndex)), ft.hr);

                // We found a provider...
                bObjectFound = true;

                // Check to see if the volume has snapshots on this provider.
                if (bVolumeSnapshottedByThisProvider) {
                    BS_ASSERT(pbSnapshotsPresent);
                    (*pbSnapshotsPresent) = TRUE;
                    (*plSnapshotCompatibility) |= lSnapshotCompatibility;
                }
            }

            if (!bObjectFound)
                ft.Throw(VSSDBG_COORD,
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
        }
    }
    VSS_STANDARD_CATCH(ft)

    // If an exception was thrown from VerifyVolumeIsSupportedByVSS
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::SetWriterInstances(
    IN      LONG            lWriterInstanceIdCount,
    IN      VSS_ID          *rgWriterInstanceId
    )
/*++

Routine description:

    Implements IVssCoordinator::SetWriterInstances

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SetWriterInstances" );

    try
        {

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Check if the snapshot object is created.
        if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        // The context must be already frozen
        BS_ASSERT(IsContextFrozen());

        m_pSnapshotSet->SetWriterInstances(lWriterInstanceIdCount, rgWriterInstanceId);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  IVssShim methods


STDMETHODIMP CVssCoordinator::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
    IN      ULONG           ulOptionFlags,
    IN      ULONG           ulVolumeCount,
    IN      VSS_PWSZ*       ppwszVolumeNamesArray,
    OUT     IVssAsync**     ppAsync
    )
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotFreeze

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssAsyncShim::CreateInstanceAndStartJob() failures]
        E_OUTOFMEMORY
            - On CComObject<CVssAsync>::CreateInstance failure
            - On copy the data members for the async object.
            - On PrepareJob failure
            - On StartJob failure

        E_UNEXPECTED
            - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SimulateSnapshotFreeze" );

    try
    {
        // Nullify all out parameters
        ::VssZeroOutPtr(ppAsync);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        if (ppAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL async interface.");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Create the shim object, if needed.
        // This call may throw
        if (m_pShim == NULL)
            m_pShim = CVssShimObject::CreateInstance();
        else {
            // TBD: Ckeck and throw VSS_E_BAD_STATE
            // if another "simulate background thread is already running" !!!!!
        }

        // Create the new async interface corresponding to the new job.
        // Remark: AddRef will be called on the shim object.
        CComPtr<IVssAsync> ptrAsync;
        ptrAsync.Attach(CVssShimAsync::CreateInstanceAndStartJob(
                            m_pShim,
                            guidSnapshotSetId,
                            ulOptionFlags,
                            ulVolumeCount,
                            ppwszVolumeNamesArray));
        if (ptrAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Async interface creation failed");

        // The reference count of the pAsync interface must be 2
        // (one for the returned interface and one for the background thread).
        (*ppAsync) = ptrAsync.Detach(); // Drop that interface in the OUT parameter

        // The ref count remnains 2
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::SimulateSnapshotThaw(
    IN      VSS_ID            guidSnapshotSetId
    )
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotThaw

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    VSS_E_BAD_STATE
        - Wrong calling sequence

    !!! TBD !!!

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SimulateSnapshotThaw" );

    try
    {
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        //
        // most likely the shim object is not around since SimulateSnapshotFreeze in
        // VssApi releases the IVssShim interface before it returns.
        //
        if (m_pShim == NULL)
            m_pShim = CVssShimObject::CreateInstance();

        // Call the thaw method.
        ft.hr = m_pShim->SimulateSnapshotThaw(guidSnapshotSetId);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::WaitForSubscribingCompletion()
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotThaw

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator

    [_Module.WaitForSubscribingCompletion() failures]
        E_UNEXPECTED
            - WaitForSingleObject failures

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::WaitForSubscribingCompletion" );

    try
    {
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        _Module.WaitForSubscribingCompletion();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



CVssCoordinator::~CVssCoordinator()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::~CVssCoordinator" );
}



/////////////////////////////////////////////////////////////////////////////
//  Context-related methods


STDMETHODIMP CVssCoordinator::SetContext(
        IN      LONG    lContext
        )
/*++

Routine description:

    Implements IVssCoordinator::SetContext

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator (for the backup context) or an administrator
    VSS_E_UNSUPPORTED_CONTEXT
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Attempt to change the context while it is frozen. It is illegal to
        change the context after the first call on the IVssCoordinator object.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinator::SetContext");

    try
    {

        // Access check - depends on the context!
        if (lContext == VSS_CTX_ALL)
            {
            if (!IsAdministrator())
                ft.Throw( VSSDBG_COORD, E_ACCESSDENIED, L"The client is not a administrator");
            }
        else
            {
            switch(lContext & ~VSS_VOLSNAP_ATTR_TRANSPORTABLE)
                {
                case VSS_CTX_FILE_SHARE_BACKUP:
                case VSS_CTX_BACKUP:
                    if (!IsBackupOperator())
                        ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                                  L"The client is not a backup operator");
                    break;

                case VSS_CTX_NAS_ROLLBACK:
                case VSS_CTX_APP_ROLLBACK:
                case VSS_CTX_CLIENT_ACCESSIBLE:
                case VSS_CTX_PERSISTENT_CLIENT_ACCESSIBLE:
                    if (CVssSKU::IsClient())
                        ft.Throw( VSSDBG_COORD, E_NOTIMPL, L"Method not implemented in client SKU");

                    break;

                default:
                    ft.Throw( VSSDBG_COORD, VSS_E_UNSUPPORTED_CONTEXT, L"Invalid context 0x%08lx", lContext);
                }
            }

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
                  L"lContext = %ld\n",
                  lContext
                  );

        BS_ASSERT(CVssProviderManager::IsContextValid(lContext));

        // Lock in order to update both variables atomically
        // The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(m_cs);

        // Check if the context has been freezed
        if (IsContextFrozen())
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                      L"The context is already frozen");

        // Change the context
        m_lSnapContext = lContext;

        // Freeze the context
        FreezeContext();

    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


LONG CVssCoordinator::GetContextInternal() const
/*++

Routine description:

    Returns the current context

--*/
{
    return m_lSnapContext;
}


bool CVssCoordinator::IsContextFrozen() const
/*++

Routine description:

    Returns true if the current context is frozen

--*/
{
    return m_bContextFrozen;
}


bool CVssCoordinator::IsSnapshotCreationAllowed() const
/*++

Routine description:

    Returns true if the current context allows snapshot creation

--*/
{
    LONG lContext = GetContextInternal();
    lContext &= ~(VSS_VOLSNAP_ATTR_TRANSPORTABLE);
    return ((lContext == VSS_CTX_CLIENT_ACCESSIBLE) ||
            (lContext == VSS_CTX_BACKUP) ||
            (lContext == VSS_CTX_FILE_SHARE_BACKUP) ||
            (lContext == VSS_CTX_APP_ROLLBACK) ||
            (lContext == VSS_CTX_NAS_ROLLBACK) ||
            (lContext == VSS_CTX_PERSISTENT_CLIENT_ACCESSIBLE));
}


void CVssCoordinator::FreezeContext()
/*++

Routine description:

    Freezes the current context. To be called in IVssCoordinator methods.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinator::FreezeContext");

    // m_bContextFrozen may be already true...
    m_bContextFrozen = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\lovelace.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Lovelace.cxx

Abstract:

    Definition of CVssQueuedVolume	


    Adi Oltean  [aoltean]  10/20/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/20/1999  Created

--*/

#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORLOVLC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - constructors, destructors and initialization methods


CVssQueuedVolume::CVssQueuedVolume():
	m_hBeginReleaseWritesEvent(NULL),
	m_hFinishHoldWritesEvent(NULL),
	m_InstanceID(GUID_NULL),
	m_ulNumberOfVolumesToFlush(0),
	m_usSecondsToHoldFileSystemsTimeout(nFileSystemsLovelaceTimeout),
	m_usSecondsToHoldIrpsTimeout(nHoldingIRPsLovelaceTimeout),
	m_pwszVolumeName(NULL),
	m_pwszVolumeDisplayName(NULL),
	m_bFlushSucceeded(false),
	m_bReleaseSucceeded(false),
	m_hrFlush(S_OK),
	m_hrRelease(S_OK),
	m_hrOnRun(S_OK)
{
}

	
CVssQueuedVolume::~CVssQueuedVolume()
{
	// Wait for the worker thread to finish, if running.
	// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
	// Virtual methods in classes derived from CVssQueuedVolume are now inaccessible!
	FinalReleaseWorkerThreadObject();

	// Release the attached strings.
	::VssFreeString(m_pwszVolumeName);
	::VssFreeString(m_pwszVolumeDisplayName);
}


HRESULT CVssQueuedVolume::Initialize(
	IN	LPWSTR pwszVolumeName,
	IN	LPWSTR pwszVolumeDisplayName
	)
/*++

Routine description:

    Initialize a Queued volume object.

Return codes:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssQueuedVolume::Initialize");

	try
	{
		// Copy with the trailing "\\". 
		::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName);

		// Copy the volume displayed name 
		::VssSafeDuplicateStr(ft, m_pwszVolumeDisplayName, pwszVolumeDisplayName);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - thread-related methods



void CVssQueuedVolume::SetParameters(
	IN	HANDLE hBeginReleaseWritesEvent,
	IN	HANDLE hFinishHoldWritesEvent,
	IN	VSS_ID	InstanceID,
	IN	ULONG	ulNumberOfVolumesToFlush
	)
{
	m_hBeginReleaseWritesEvent = hBeginReleaseWritesEvent;
	m_hFinishHoldWritesEvent = hFinishHoldWritesEvent;
	m_InstanceID = InstanceID;
	m_ulNumberOfVolumesToFlush = ulNumberOfVolumesToFlush;
}


bool CVssQueuedVolume::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnInit" );

	return (m_hBeginReleaseWritesEvent != NULL)
		&& (m_hFinishHoldWritesEvent != NULL)
		&& (m_InstanceID != GUID_NULL)
		&& (m_ulNumberOfVolumesToFlush != 0)
		&& (m_usSecondsToHoldFileSystemsTimeout != 0)
		&& (m_usSecondsToHoldIrpsTimeout != 0);
}


void CVssQueuedVolume::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnRun" );

	try
	{
		// Open the IOCTL channel
		// Eliminate the trailing backslash
		// Throw on error 
		BS_ASSERT(::wcslen(m_pwszVolumeName) == nLengthOfVolMgmtVolumeName);
		m_objIChannel.Open(ft, m_pwszVolumeName, true, true);

		// Hold writes
		OnHoldWrites();

		// Signal the thread set that the writes are now hold...
		if (!::SetEvent(m_hFinishHoldWritesEvent))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"SetEvent(%p)", m_hFinishHoldWritesEvent );
		m_hFinishHoldWritesEvent = NULL;

		// Wait for the "Release Writes" event
		if (::WaitForSingleObject( m_hBeginReleaseWritesEvent, nHoldingIRPsVssTimeout * 1000 ) == WAIT_FAILED)
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"WaitForSingleObject(%p,%d) == WAIT_FAILED", 
		        m_hFinishHoldWritesEvent, nHoldingIRPsVssTimeout * 1000 );

		// Release writes.
		OnReleaseWrites();
	}
	VSS_STANDARD_CATCH(ft);

	m_hrOnRun = ft.hr;
}


void CVssQueuedVolume::OnFinish()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnFinish" );

	m_hBeginReleaseWritesEvent = NULL;	// released by the ThreadSet
	m_hFinishHoldWritesEvent = NULL;	// released by the ThreadSet
	m_InstanceID = GUID_NULL;
	m_ulNumberOfVolumesToFlush = 0;
	m_usSecondsToHoldFileSystemsTimeout = 0;
	m_usSecondsToHoldIrpsTimeout = 0;

	// Mark thread state as finished
	MarkAsFinished();
};


void CVssQueuedVolume::OnTerminate()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnTerminate" );
}


void CVssQueuedVolume::OnHoldWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnHoldWrites" );

	try
	{
		BS_ASSERT(m_bFlushSucceeded == false);
		m_bFlushSucceeded = false;
		
		// pack the IOCTL [in] arguments
		m_objIChannel.Pack(ft, m_InstanceID);
		m_objIChannel.Pack(ft, m_ulNumberOfVolumesToFlush);
		m_objIChannel.Pack(ft, m_usSecondsToHoldFileSystemsTimeout);
		m_objIChannel.Pack(ft, m_usSecondsToHoldIrpsTimeout);

		// send the IOCTL
		m_objIChannel.Call(ft, IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES);

        BS_ASSERT(ft.hr == S_OK);
		m_bFlushSucceeded = true;
	}
	VSS_STANDARD_CATCH(ft)

	m_hrFlush = ft.hr;
};



void CVssQueuedVolume::OnReleaseWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnReleaseWrites" );

	try
	{
		BS_ASSERT(m_bReleaseSucceeded == false);
		m_bReleaseSucceeded = false;

		// If the Flush IOCTL was succeeded 
        if (IsFlushSucceeded()) {
    		// then send the Release IOCTL.
    		m_objIChannel.Call(ft, IOCTL_VOLSNAP_RELEASE_WRITES);

            BS_ASSERT(ft.hr == S_OK);
    		m_bReleaseSucceeded = true;
        }
	}
	VSS_STANDARD_CATCH(ft)

	m_hrRelease = ft.hr;
};






/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolumesList


CVssQueuedVolumesList::CVssQueuedVolumesList():
	m_eState(VSS_TS_INITIALIZING),
	m_hBeginReleaseWritesEvent(NULL)
{}
	

CVssQueuedVolumesList::~CVssQueuedVolumesList()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::~CVssQueuedVolumesList" );

	try
	{
		// Remove all volumes from the map
		Reset();

		// Release the internal synchronization objects
		if (m_hBeginReleaseWritesEvent)
			::CloseHandle(m_hBeginReleaseWritesEvent);
	}
	VSS_STANDARD_CATCH(ft)
};


HRESULT CVssQueuedVolumesList::AddVolume(
	WCHAR* pwszVolumeName,
	WCHAR* pwszVolumeDisplayName
	)
/*++

Routine description:

    Adds a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_ALREADY_EXISTS
        - The volume was already added to the snapshot set.
    VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
        - The maximum number of volumes was reached.
    E_OUTOFMEMORY

    [Initialize() failures]
        E_OUTOFMEMORY
        
--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::AddVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);
		BS_ASSERT(pwszVolumeDisplayName && pwszVolumeDisplayName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING) {
		    BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
		}

		// Find if the volume was already added
		if (m_VolumesMap.Lookup(pwszVolumeName))
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_ALREADY_EXISTS, L"Volume already added");

		// Check if the maximum number of objects was reached
		if (m_VolumesMap.GetSize() >= MAXIMUM_WAIT_OBJECTS)
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED,
                      L"The maximum number (%d) of Lovelace threads was reached.",
                      m_VolumesMap.GetSize());

		// Create the queued volume object
		CVssQueuedVolume* pQueuedVol = new CVssQueuedVolume();
		if (pQueuedVol == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Initialize the pQueuedVol object. This method may throw
		ft.hr = pQueuedVol->Initialize(pwszVolumeName, pwszVolumeDisplayName);
		if (ft.HrFailed()) {
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
            		  L"Cannot initialize volume object 0x%08lx", ft.hr);
		}

		// Add the volume object to the map
		// Beware that the volume name is already allocated.
		BS_ASSERT(pQueuedVol->GetVolumeName() != NULL);
		if (!m_VolumesMap.Add(pQueuedVol->GetVolumeName(), pQueuedVol))	{
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


HRESULT CVssQueuedVolumesList::RemoveVolume(
	WCHAR* pwszVolumeName
	)
/*++

Routine description:

    Removes a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_NOT_FOUND
        - The volume was not added to the snapshot set.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::RemoveVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING)
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);

		// Find if the volume was already added
		CVssQueuedVolume* pQueuedVol = m_VolumesMap.Lookup(pwszVolumeName);
		if (pQueuedVol == NULL)
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Volume does not exist");

		// Remove the corresponding entry
		BOOL bRemoved = m_VolumesMap.Remove(pwszVolumeName);
		if (!bRemoved) {
			BS_ASSERT(bRemoved);
			ft.Trace( VSSDBG_COORD, L"Error removing the volume entry");
		}

		// Delete the volume object.
		delete pQueuedVol;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


void CVssQueuedVolumesList::Reset()
/*++

Routine description:

    Waits for all background threads. Reset the snapshot set.

Thrown errors:

    None.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::Reset" );

    // If the flush faield this must be treated already in the "flush" error case
    if (  (m_eState == VSS_TS_HOLDING)
        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
    {
        BS_ASSERT(m_VolumesMap.GetSize() > 0);

	    // Wait for all threads to finish. 
	    // This will signal the m_hBeginReleaseWritesEvent event.
	    // WARNING: Ignore return codes from this call. Trace already done.
	    WaitForFinish();
    }

	// Remove all queued volumes
	for(int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++) {
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
		BS_ASSERT(pVol);
		delete pVol;
	}

	// Remove all map entries
	m_VolumesMap.RemoveAll();

    ft.Trace(VSSDBG_COORD, L"Current state %d. Reset to initializing", m_eState);
    m_eState = VSS_TS_INITIALIZING;
}
	

HRESULT CVssQueuedVolumesList::FlushAndHoldAllWrites(
	IN	VSS_ID	SnapshotSetID
	)
/*++

Routine description:

    Creates the background threads.
    Flush and Hold all writes on the background threads.
    Wait until all IOCTLS are performed.

Return codes:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Invalid thread state. Dev error - no entry is put in the event log.
        - Empty volume array. Dev error - no entry is put in the event log.
        - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
    VSS_ERROR_FLUSH_WRITES_TIMEOUT
        - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::FlushAndHoldAllWrites" );

	HANDLE* pHandleArray = NULL;
	INT nFilledHandles = 0;

	try
	{
		// Check to see if the state is correct
        if (m_eState != VSS_TS_INITIALIZING) {
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
        }

		// Check we have added some volumes first
		if (m_VolumesMap.GetSize() <= 0) {
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Improper array size.");
		}

		// Create the Begin Release Writes event, as a manual reset non-signaled event
		if (m_hBeginReleaseWritesEvent == NULL) {
    		m_hBeginReleaseWritesEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    		if (m_hBeginReleaseWritesEvent == NULL)
    			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
    			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");
		} else
		    ::ResetEvent( m_hBeginReleaseWritesEvent );

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Prepares all jobs
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Create the Finish Hold Writes event, as a manual reset non-signaled event
			pHandleArray[nIndex] = ::CreateEvent( NULL, TRUE, FALSE, NULL );
			if (pHandleArray[nIndex] == NULL)
			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");

			// Increase the number of filled handles
			nFilledHandles++;
			BS_ASSERT(nFilledHandles == nIndex + 1);

			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// Transfer parameters to the current job
			pVol->SetParameters(
				m_hBeginReleaseWritesEvent,
				pHandleArray[nIndex],
				SnapshotSetID,
				m_VolumesMap.GetSize()
				);

			// Prepare the job
			ft.hr = pVol->PrepareJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

		// Flush and hold writes. All threads will wait for the event to be signaled.
		// This thread will wait until all IOCTLS were sent.

		// Start (i.e. Resume) all threads
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ ) {
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// This can happen only because some thread objects were in invalid state...
			ft.hr = pVol->StartJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

		// Wait for all threads to send the FlushAndHold IOCTLS.
		if (::WaitForMultipleObjects( m_VolumesMap.GetSize(),
				pHandleArray, TRUE, nFlushVssTimeout * 1000) == WAIT_FAILED)
			ft.TranslateGenericError( VSSDBG_COORD, 
			    HRESULT_FROM_WIN32(GetLastError()), L"WaitForMultipleObjects(%d,%p,1,%d) == WAIT_FAILED", 
			    m_VolumesMap.GetSize(),pHandleArray, nFlushVssTimeout * 1000);

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Flush succeeded.
			if (!pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetReleaseError() == S_OK);
                
                if ((pVol->GetFlushError() == E_OUTOFMEMORY) ||
                    (pVol->GetOnRunError() == E_OUTOFMEMORY))
                    ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx]",
                        pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
			    
			    ft.LogError(VSS_ERROR_FLUSH_WRITES_TIMEOUT, 
			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
				ft.Throw( VSSDBG_COORD, VSS_E_FLUSH_WRITES_TIMEOUT,
						  L"Lovelace failed to hold writes at volume %d - '%s'",
						  nIndex, pVol->GetVolumeDisplayName() );
			}
		}

		m_eState = VSS_TS_HOLDING;
	}
	VSS_STANDARD_CATCH(ft)

	// Close all events (from 0..nFilledHandles-1)
	for (int nIndexTmp = 0; nIndexTmp < nFilledHandles; nIndexTmp++ )
		::CloseHandle(pHandleArray[nIndexTmp]);

	// Deallocate the handle array
	delete[] pHandleArray;

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_FLUSH;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::ReleaseAllWrites()
/*++

Routine description:

    Signals all the background threads to release the writes.
    Wait until all IOCTLS are performed.

Return codes:

    [WaitForFinish() failures]
        E_UNEXPECTED
            - The list of volumes is empty. Dev error - nothing is logged on.
            - SetEvent failed. An entry is put in the error log.
            - WaitForMultipleObjects failed. An entry is put in the error log.
        E_OUTOFMEMORY
            - Cannot create the array of handles.
            - One of the background threads failed with E_OUTOFMEMORY
        VSS_E_HOLD_WRITES_TIMEOUT
            - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::ReleaseAllWrites" );

    try
    {
        // If the flush faield this must be treated already in the "flush" error case
	    if (  (m_eState == VSS_TS_HOLDING)
	        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
        {
            BS_ASSERT(m_VolumesMap.GetSize() > 0);
    	    // Wait for all threads to finish.
    	    // This will signal the m_hBeginReleaseWritesEvent event.
    	    ft.hr = WaitForFinish();
    	    if (ft.HrFailed())
    		    ft.Throw( VSSDBG_COORD, ft.hr, L"Error waiting threads for finishing");
	    }
    }
    VSS_STANDARD_CATCH(ft)

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_RELEASE;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::WaitForFinish()
/*++

Routine description:

    Wait until all Lovelace threads are finished.

Thrown errors:

    E_UNEXPECTED
        - The list of volumes is empty. Dev error - nothing is logged on.
        - SetEvent failed. An entry is put in the error log.
        - WaitForMultipleObjects failed. An entry is put in the error log.
    E_OUTOFMEMORY
        - Cannot create the array of handles.
        - One of the background threads failed with E_OUTOFMEMORY
    VSS_E_HOLD_WRITES_TIMEOUT
        - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::WaitForFinish" );

	// Table of handles used for synchronization
	HANDLE* pHandleArray = NULL;

	try
	{
		// Release all blocked threads by signaling the m_hBeginReleaseWritesEvent event.
		if(m_hBeginReleaseWritesEvent != NULL) {
			if (!::SetEvent(m_hBeginReleaseWritesEvent))
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()), 
				    L"SetEvent(%p)", m_hBeginReleaseWritesEvent);
		}

		// Get the size of the array.
		if (m_VolumesMap.GetSize() <= 0) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Zero array size.");
		}

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Search to find any running threads
		int nThreadHandlesCount = 0;
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);
			
			// Get the thread handle, if it is still running
			// Note: the "prepared" threads will not be in "running" state at this point
			// The only procedure that can fire them up (i.e. StartJob) cannot
			// be called anymore at this point.
			if (pVol->IsStarted()) {
			    HANDLE hThread = pVol->GetThreadHandle();
    			BS_ASSERT(hThread != NULL);
    			pHandleArray[nThreadHandlesCount++] = hThread; // will be closed on job array destruction.
			}
		}

        // If we have threads that we can wait on...
        if (nThreadHandlesCount != 0) {
    		// Wait for all threads to send the Release IOCTLS.
    		if (::WaitForMultipleObjects( nThreadHandlesCount,
    				pHandleArray, TRUE, nReleaseVssTimeout * 1000) == WAIT_FAILED)
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()),
				    L"WaitForMultipleObjects(%d,%p,1,%d) == WAIT_FAILED", 
				    nThreadHandlesCount,pHandleArray, nReleaseVssTimeout * 1000);
        }

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Release writers succeeded. 
            if (pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetFlushError() == S_OK);

                // Check if Release writes succeeded
    			if (!pVol->IsReleaseSucceeded()) {
                    if ((pVol->GetFlushError() == E_OUTOFMEMORY) ||
                        (pVol->GetReleaseError() == E_OUTOFMEMORY) ||
                        (pVol->GetOnRunError() == E_OUTOFMEMORY))
                        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx]",
                            pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
    			    
    			    ft.LogError(VSS_ERROR_HOLD_WRITES_TIMEOUT, 
    			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
    			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
    				ft.Throw( VSSDBG_COORD, VSS_E_HOLD_WRITES_TIMEOUT,
    						  L"Lovelace failed to hold writes at volume %d - '%s'",
    						  nIndex, pVol->GetVolumeDisplayName() );
    			}
            }
		}

		m_eState = VSS_TS_RELEASED;
	}
	VSS_STANDARD_CATCH(ft)

	// Deallocate the handle array
	delete[] pHandleArray;

	return ft.hr;
};


CComBSTR CVssQueuedVolumesList::GetVolumesList() throw(HRESULT)
/*++

Routine description:

    Gets the list of volumes as a BSTR.

Throws:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::GetVolumesList" );
	CComBSTR bstrVolumeNamesList;

    BS_ASSERT(m_VolumesMap.GetSize() > 0);

	// Concatenate the list of volume display names
	for (int nIndexTmp = 0; nIndexTmp < m_VolumesMap.GetSize(); nIndexTmp++ ) {
		// Obtain the queued volume object in discussion
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndexTmp);
		BS_ASSERT(pVol);

		// Check to see if this is the first item
		if (nIndexTmp == 0) {
			// Put the first volume name
			bstrVolumeNamesList = pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		} else {
			// Append the semicolon
			bstrVolumeNamesList += wszVolumeNamesSeparator;
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
			// Append the next volume name
			bstrVolumeNamesList += pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		}
	}

	// Return the built list
	return bstrVolumeNamesList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\callback.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    callback.cxx

Abstract:

    Declaration of CVssCoordinatorCallback object


    Brian Berkowitz  [brianb]  3/23/2001

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      3/23/2001   Created

--*/

#ifndef __VSS_CALLBACK_HXX__
#define __VSS_CALLBACK_HXX__


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORCALBC"
//
////////////////////////////////////////////////////////////////////////

#include "stdafx.hxx"

CComModule _Module;
#include <atlcom.h>

#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

#include "vss.h"
#include "vsevent.h"
#include "callback.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORCALBC"
//
////////////////////////////////////////////////////////////////////////

// get coordinator callback
void CVssCoordinatorCallback::Initialize
	(
	IDispatch *pDispWriter,
	IDispatch **ppDispCoordinator
	)
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::Initialize");

	// create object
	CComObject<CVssCoordinatorCallback> *pCallback;
	ft.hr = CComObject<CVssCoordinatorCallback>::CreateInstance(&pCallback);
	((IVssCoordinatorCallback *) pCallback)->SetWriterCallback(pDispWriter);
	if (FAILED(ft.hr))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"CreateInstance failed");

	// get IDispatch interface
	ft.hr = pCallback->GetUnknown()->SafeQI(IDispatch, ppDispCoordinator);
	if (FAILED(ft.hr))
		{
		ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_COORD << ft.hr);
		ft.Throw
			(
			VSSDBG_COORD,
            E_UNEXPECTED,
			L"Error querying for the IDispatch interface.  hr = 0x%08x",
			ft.hr
			);
        }
	}



// get writer callback
void CVssCoordinatorCallback::GetWriterCallback(IVssWriterCallback **ppWriterCallback)
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::GetWriterCallback");

	// check that pointer is supplied
	BS_ASSERT(ppWriterCallback != NULL);
	BS_ASSERT(m_pDisp != NULL);

	ft.hr = m_pDisp->SafeQI(IVssWriterCallback, ppWriterCallback);
	if (FAILED(ft.hr))
		{
		ft.LogError(VSS_ERROR_QI_IVSSWRITERCALLBACK, VSSDBG_COORD << ft.hr);
		ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"QI to IVssWriterCallback failed");
		}
    
    //  Setting the proxy blanket to disallow impersonation and enable dynamic cloaking.
	ft.hr = CoSetProxyBlanket
				(
				*ppWriterCallback,
				RPC_C_AUTHN_DEFAULT,
				RPC_C_AUTHZ_DEFAULT,
				NULL,
				RPC_C_AUTHN_LEVEL_CONNECT,
				RPC_C_IMP_LEVEL_IDENTIFY,
				NULL,
				EOAC_DYNAMIC_CLOAKING
				);

    // note E_NOINTERFACE means that the pWriterCallback is a in-proc callback
	// and there is no proxy
    if (FAILED(ft.hr) && ft.hr != E_NOINTERFACE)
		{
		ft.LogError(VSS_ERROR_BLANKET_FAILED, VSSDBG_COORD << ft.hr);
		ft.Throw
			(
			VSSDBG_COORD,
			E_UNEXPECTED,
			L"Call to CoSetProxyBlanket failed.  hr = 0x%08lx", ft.hr
			);
        }
	}


// called by writer to expose its WRITER_METADATA XML document
STDMETHODIMP CVssCoordinatorCallback::ExposeWriterMetadata
	(							
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR strWriterXMLMetadata
	)
	{
	UNREFERENCED_PARAMETER(WriterInstanceId);
	UNREFERENCED_PARAMETER(WriterClassId);
	UNREFERENCED_PARAMETER(bstrWriterName);
	UNREFERENCED_PARAMETER(strWriterXMLMetadata);

	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::ExposeWriterMetadata");
	ft.hr = VSS_E_BAD_STATE;

	return ft.hr;
	};


// called by the writer to obtain the WRITER_COMPONENTS document for it
STDMETHODIMP CVssCoordinatorCallback::GetContent
	(
	IN  BSTR WriterInstanceId,
	OUT BSTR* pbstrXMLDOMDocContent
	)
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::GetContent");

	try
		{
		CComPtr<IVssWriterCallback> pWriterCallback;
		HRESULT hr;
		bool bImpersonate = true;

		GetWriterCallback(&pWriterCallback);

		if (pbstrXMLDOMDocContent == NULL)
			ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Null output paramater.");

		ft.hr = CoImpersonateClient();
		if (ft.hr == RPC_E_CALL_COMPLETE)
			bImpersonate = false;
		else if (FAILED(ft.hr))
			ft.CheckForError(VSSDBG_COORD, L"CoImpersonateClient");

		hr = pWriterCallback->GetContent(WriterInstanceId, pbstrXMLDOMDocContent);

		if (bImpersonate)
			{
			ft.hr = CoRevertToSelf();
			ft.CheckForError(VSSDBG_COORD, L"CoRevertToSelf");
			}

		ft.hr = hr;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



// called by the writer to update the WRITER_COMPONENTS document for it
STDMETHODIMP CVssCoordinatorCallback::SetContent
	(
	IN BSTR WriterInstanceId,
	IN BSTR bstrXMLDOMDocContent
	)
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::SetContent");

	try
		{
		HRESULT hr;
		bool bImpersonate = true;
		CComPtr<IVssWriterCallback> pWriterCallback;

		if (bstrXMLDOMDocContent == NULL)
			ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL required input paramter.");


		GetWriterCallback(&pWriterCallback);
		ft.hr = CoImpersonateClient();
		if (ft.hr == RPC_E_CALL_COMPLETE)
			bImpersonate = false;
		else if (FAILED(ft.hr))
			ft.CheckForError(VSSDBG_COORD, L"CoImpersonateClient");

		hr = pWriterCallback->SetContent(WriterInstanceId, bstrXMLDOMDocContent);
		if (bImpersonate)
			{
			ft.hr = CoRevertToSelf();
			ft.CheckForError(VSSDBG_COORD, L"CoRevertToSelf");
			}

		ft.hr = hr;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// called by the writer to get information about the backup
STDMETHODIMP CVssCoordinatorCallback::GetBackupState
	(
	OUT BOOL *pbBootableSystemStateBackedUp,
	OUT BOOL *pbAreComponentsSelected,
	OUT VSS_BACKUP_TYPE *pBackupType,
	OUT BOOL *pbPartialFileSupport
	)
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::GetBackupState");

	try
		{
		HRESULT hr;
		bool bImpersonate = true;
		CComPtr<IVssWriterCallback> pWriterCallback;

		if (pbBootableSystemStateBackedUp == NULL ||
			pbAreComponentsSelected == NULL ||
			pBackupType == NULL ||
			pbPartialFileSupport == NULL)
			ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"NULL output parameter");

		GetWriterCallback(&pWriterCallback);

		ft.hr = CoImpersonateClient();
		if (ft.hr == RPC_E_CALL_COMPLETE)
			bImpersonate = false;
		else if (FAILED(ft.hr))
			ft.CheckForError(VSSDBG_COORD, L"CoImpersonateClient");


		hr = pWriterCallback->GetBackupState
			(
			pbBootableSystemStateBackedUp,
			pbAreComponentsSelected,
			pBackupType,
			pbPartialFileSupport
			);

		if (bImpersonate)
			{
			ft.hr = CoRevertToSelf();
			ft.CheckForError(VSSDBG_COORD, L"CoRevertToSelf");
			}

		ft.hr = hr;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// called by the writer to indicate its status
STDMETHODIMP CVssCoordinatorCallback::ExposeCurrentState
	(							
	IN BSTR WriterInstanceId,					
	IN VSS_WRITER_STATE nCurrentState,
	IN HRESULT hrWriterFailure
	)
	{
	UNREFERENCED_PARAMETER(WriterInstanceId);
	UNREFERENCED_PARAMETER(nCurrentState);
	UNREFERENCED_PARAMETER(hrWriterFailure);

	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinatorCallback::ExposeCurrentState");

	ft.hr = VSS_E_BAD_STATE;
	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Shim.cxx | Implementation of CVssShimObject
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"

#include "shim.hxx"

#include "vswriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSHIMC"
//
////////////////////////////////////////////////////////////////////////

// Global semaphore used to serialize creation of snapshot sets, CVssShimObject also uses
// this semaphore to serialize both StartSnapshotSet and SimulateSnapshotFreeze.  Defined
// in snap_set.cxx.
extern LONG g_hSemSnapshotSets;

/////////////////////////////////////////////////////////////////////////////
//  CVssShimObject


HRESULT CVssShimObject::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotFreeze" );

    try
    {
		BS_ASSERT(!m_bHasAcquiredSem);

        // Trace the input parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: SnapshotSetID = " WSTR_GUID_FMT L" "
            L" OptionFlags = %lu, VolumeCount = %d", 
            GUID_PRINTF_ARG(guidSnapshotSetId), ulOptionFlags, ulVolumeCount );
        for ( ULONG ulIndex = 0; ulIndex < ulVolumeCount ; ulIndex++ )
            ft.Trace( VSSDBG_COORD, L"   Volume[%02d]= %s", 
                ulIndex, ppwszVolumeNamesArray[ulIndex] );

        // Prevent simultaneous creation of multiple snapshot sets and SimulateSnapshotFreeze
        // on the same machine.
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
			ft.Throw
				(
				VSSDBG_COORD,
				VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				L"Snapshot set creation is already in progress."
				);
        m_bHasAcquiredSem = true;

        //
        // Finally call into the VssApi.DLL's SimulateSnaphotFreezeInternal!
        //
        PFunc_SimulateSnapshotFreezeInternal pFuncFreeze;
        _Module.GetSimulateFunctions( &pFuncFreeze, NULL );
        if ( pFuncFreeze != NULL )
        {
            m_guidSimulateSnapshotSetId = guidSnapshotSetId;        
            ft.hr = pFuncFreeze( guidSnapshotSetId, ulOptionFlags,	ulVolumeCount,	ppwszVolumeNamesArray, &m_bCancel );
            if ( ft.HrFailed() )
            {
                ft.Trace( VSSDBG_COORD, L"ERROR: SimulateSnapshotFreezeInternal returned hr: 0x%08lx", ft.hr );
            }
        }
        else
        {
            ft.Trace( VSSDBG_COORD, L"ERROR: pFuncFreeze is NULL, no registered simulate snapshot function!!" );
        }
        
        if ( ft.HrSucceeded() )
        {
            TestIfCancelNeeded(ft);        
        }
    }
    VSS_STANDARD_CATCH(ft);

	// Cleanup on error...
	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
	{
		ft.Trace( VSSDBG_COORD, L"Abort detected 0x%08lx", ft.hr );
        // These functions should not throw

        // If it was a cancel then abort the snapshot set in progress.
        if (ft.hr == VSS_S_ASYNC_CANCELLED) {
            // TBD: User cancelled.            
        }

        // Thaw any shim writers that got frozen before the error occurred or the
        // async operation was cancelled.  Note that SimulateSnapshotThaw will
        // release the semaphore.
        if ( m_bHasAcquiredSem )
            SimulateSnapshotThaw( guidSnapshotSetId );
	}

    // We may return here VSS_S_ASYNC_CANCELLED
    return ft.hr;
}


HRESULT CVssShimObject::SimulateSnapshotThaw(
    IN      VSS_ID          guidSnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotThaw" );

    //
    // Finally call into the VssApi.DLL's SimulateSnaphotThawInternal!
    //
    PFunc_SimulateSnapshotThawInternal pFuncThaw;
    _Module.GetSimulateFunctions( NULL, &pFuncThaw );
    if ( pFuncThaw != NULL )
    {
        pFuncThaw( guidSnapshotSetId );
    }
    else
    {
        ft.Trace( VSSDBG_COORD, L"ERROR: pFuncThaw is NULL, no registered simulate snapshot function!!" );
    }

    //
    //  Thaw can be called out of order since the requestor might be making sure that
    //  all writers thaw properly.
    //
    if ( m_bHasAcquiredSem )
    {
    	if ( InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1) == 1 )
            m_bHasAcquiredSem = false;
    }

    m_guidSimulateSnapshotSetId = GUID_NULL;
    
    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


void CVssShimObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


STDMETHODIMP CVssShimObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssShimObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssShimObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssShimObject* CVssShimObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CreateInstance");
	
	CVssShimObject* pObj = new CVssShimObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssShimObject::FinalConstructInternal()
{
	return S_OK;
}


CVssShimObject::CVssShimObject():
	m_bCancel(false),
	m_lRef(0),
	m_guidSimulateSnapshotSetId( GUID_NULL ),
	m_bHasAcquiredSem( false )
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CVssShimObject");
}


CVssShimObject::~CVssShimObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssShimObject::~CVssShimObject");

	//
	// If we acquired the semaphore then make
	// sure to call SimulateSnapshotThaw.  This happens if the requestor doesn't
	// call it before exiting.
	//
	if ( m_bHasAcquiredSem )
	{
        ft.Trace( VSSDBG_COORD, L"Calling SimulateSnapshotThaw since requestor did not do so" );
        SimulateSnapshotThaw( m_guidSimulateSnapshotSetId );

        //  Make sure we always clear the semaphore.  SimulateSnapshotThaw should always 
        if ( m_bHasAcquiredSem )
        {
        	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
        	m_bHasAcquiredSem = false;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    StdAfx.cxx

Abstract:

    Source file that includes just the standard includes.  stdafx.pch will be
    the pre-compiled header and stdafx.obj will contain the pre-compiled type
    information.

Author:

    Adi Oltean   [aoltean]      07/02/1999

Revision History:

--*/

#include "StdAfx.hxx"

// Needed here to match COM server definitions with the <atlimpl.cpp> stuff
#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\setup.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    setup.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		10/05/1999	Moved from svc.cxx
	aoltean		03/10/2000	Simplifying Setup

--*/



////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"

// General utilities
#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSETUC"
//
////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT CVsServiceModule::RegisterServer(
    BOOL bRegTypeLib
    )

/*++

Routine Description:

    Register the new COM server.

Arguments:

    bRegTypeLib,

Remarks:

    Called by CVsServiceModule::_WinMain()

Return Value:

    S_OK
    E_UNEXPECTED  if an error has occured. See trace file for details

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::RegisterServer" );

    try
    {
        //
        // Initialize the COM library
        //

        ft.hr = CoInitialize(NULL);
        if ( ft.HrFailed() )
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"CoInitialize failed 0x%08lx", ft.hr );

        // Add registry entries for CLSID and APPID by running proper scripts
        ft.hr = UpdateRegistryFromResource(IDR_VSSVC, TRUE);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        // Register the type library and add object map registry entries
        ft.hr = CComModule::RegisterServer(bRegTypeLib);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        //
        // Uninitialize the COM library
        //
        CoUninitialize();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\snap_set.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssSnapshotSetObject
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Provider-generic code.
	aoltean		10/04/1999	Treatment of writer error codes.
	aoltean		10/12/1999	Adding HoldWrites, ReleaseWrites
	aoltean		10/13/1999	Moving from coord.cxx into snap_set.cxx
	brianb		04/20/2000  Added SQL wrapper stuff
	brianb      04/21/2000  Disable SQL writer until new ODBC driver is available

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "provmgr.hxx"
#include "snap_set.hxx"

#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_filter.hxx"
#include "callback.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSNPSC"
//
////////////////////////////////////////////////////////////////////////

// global semaphore used to serialize creation of snapshot sets
LONG g_hSemSnapshotSets = 0;



/////////////////////////////////////////////////////////////////////////////
//  CVssSnapshotSetObject


HRESULT CVssSnapshotSetObject::StartSnapshotSet(
    OUT		VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:
	
	Starts a new calling sequence for snapshot creation.
	Called by CVssCoordinator::StartSnapshotSet.

Arguments:

    OUT		VSS_ID*     pSnapshotSetId

Return values:

    E_OUTOFMEMORY
    VSS_E_SNAPSHOT_SET_IN_PROGRESS
        - StartSnapshotSet is called while another snapshot set in in the
		  process of being created
    E_UNEXPECTED
        - if CoCreateGuid fails

    [Deactivate() failures] or
    [Activate() failures]
        [lockObj failures]
            E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::StartSnapshotSet" );

    try
    {
		BS_ASSERT(pSnapshotSetId);
		BS_ASSERT(!m_bHasAcquiredSem);
		BS_ASSERT(IsContextValid(GetContextInternal()));

        // Prevent simultaneous creation of multiple snapshot sets on the same machine.
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
			ft.Throw
				(
				VSSDBG_COORD,
				VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				L"Snapshot set creation is already in progress."
				);

        m_bHasAcquiredSem = true;

        // Verifying state...
        if (m_lCoordState != VSSC_Initialized) {
			// Mark the ending of the snapshot set creation!
			// Warning: may throw E_OUTOFMEMORY
			Deactivate();
        }

		// We should be in the correct state.
        BS_ASSERT(m_lCoordState == VSSC_Initialized);
        BS_ASSERT(m_lSnapshotsCount == 0);

        // Allocate a new Snapshot Set ID
		CVssGlobalSnapshotSetId::NewID();

		// Mark the beginning of the snapshot set creation
		// WARNING: This call may throw an E_OUTOFMEMORY exception!
		Activate();

        // Initialize the state of the snapshot set object.
		// Do not initialize any state that is related to the background state.
        ft.Trace( VSSDBG_COORD, L"Initialize the state of the snapshot set object" );
        (*pSnapshotSetId) = CVssGlobalSnapshotSetId::GetID();
        m_lCoordState = VSSC_SnapshotSetStarted;
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed() && m_bHasAcquiredSem)
		{
        // Reset the allocated Snapshot Set ID
		CVssGlobalSnapshotSetId::ResetID();

		InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
		m_bHasAcquiredSem = false;
		}

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,
    IN      VSS_ID      ProviderId,
	OUT 	VSS_ID		*pSnapshotId
    )
/*++

Routine description:
	
	Adds a volume to the snapshot set

Arguments:

    pwszVolumeName, - volume name (to be parsed by GetVolumeNameForVolumeMountPointW)
    ProviderId      - ID of the provider or GUID_NULL for automatic choosing of the provider
    ppSnapshot      - If non-NULL then will hold a pointer for the returned IVssSnapshot

Return values:

    E_OUTOFMEMORY
    VSS_E_BAD_STATE
        - wrong calling sequence.
    E_INVALIDARG
        - Invalid arguments (for example the volume name is invalid).
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [GetSupportedProviderId() failures]
        E_OUTOFMEMORY
        E_INVALIDARG
            - if the volume is not in the correct format.
        VSS_E_VOLUME_NOT_SUPPORTED
            - If the given volume is not supported by any provider

        [QuerySupportedProvidersIntoArray() failures]
            E_OUTOFMEMORY

            VSS_E_UNEXPECTED_PROVIDER_ERROR
                Unexpected provider error on calling IsVolumeSupported

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [GetProviderInterface failures]
                [lockObj failures]
                    E_OUTOFMEMORY

                [GetProviderInterfaceInternal() failures]
                    E_OUTOFMEMORY

                    [CoCreateInstance() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - The provider interface couldn't be created. An error log entry is added describing the error.

                    [QueryInterface failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. An error log entry is added describing the error.

                    [OnLoad() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. The error code is logged into the event log.
                        VSS_E_PROVIDER_VETO
                            - Expected provider error. The provider already did the logging.

                    [SetContext() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. The error code is logged into the event log.

            [InitializeAsProvider() failures]
                E_OUTOFMEMORY

            [IVssSnapshotProvider::IsVolumeSupported() failures]
                E_INVALIDARG
                    NULL pointers passed as parameters or a volume name in an invalid format.
                E_OUTOFMEMORY
                    Out of memory or other system resources
                VSS_E_PROVIDER_VETO
                    An error occured while opening the IOCTL channel. The error is logged.
                VSS_E_OBJECT_NOT_FOUND
                    If the volume name does not correspond to an existing mount point

    [GetProviderInterfaceForSnapshotCreation() failures]
        VSS_E_PROVIDER_NOT_REGISTERED

        [lockObj failures]
            E_OUTOFMEMORY

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [CVssQueuedVolumesList::AddVolume() failures]
        E_UNEXPECTED
            - The thread state is incorrect. No logging is done - programming error.
        VSS_E_OBJECT_ALREADY_EXISTS
            - The volume was already added to the snapshot set.
        VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
            - The maximum number of volumes was reached.
        E_OUTOFMEMORY

        [Initialize() failures]
            E_OUTOFMEMORY

    [BeginPrepareSnapshot() failures]
        E_INVALIDARG
        VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddToSnapshotSet" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
	VSS_ID InternalProviderId = ProviderId;

    bool bVolumeInserted = false;
    bool bProviderItfInserted = false;

    try
    {
		BS_ASSERT(::wcslen(pwszVolumeName) > 0);
		BS_ASSERT(IsContextValid(GetContextInternal()));
		BS_ASSERT(pSnapshotId);

        // Verifying state
        if (m_lCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
					  L"Snapshot Set in incorrect state %ld", m_lCoordState);

		// Getting the volume name
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
				wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
			ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, // Changed from E_INVALIDARG, bug 197074
					  L"GetVolumeNameForVolumeMountPoint(%s,...) "
					  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
		BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
		BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // If the caller did not specified a provider
        if (InternalProviderId == GUID_NULL) {
            // Choose a provider that works.
            // This call may throw!
            GetSupportedProviderId( wszVolumeNameInternal, &InternalProviderId );
            ft.Trace( VSSDBG_COORD, L"Provider found: " WSTR_GUID_FMT, GUID_PRINTF_ARG(InternalProviderId) );

            BS_ASSERT(InternalProviderId != GUID_NULL);
        }

		// Get the provider interface
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.Lookup( InternalProviderId );
        if (pProviderItf == NULL) {
            // The ref count will be 2 since the method keeps another
            // copy in its internal local cache.
            // We ignore the return value since we know for sure that the provider must return that interface
		    GetProviderInterfaceForSnapshotCreation( InternalProviderId, pProviderItf );
            if (pProviderItf == NULL)
            {
                // IsVolumeSupported was already called in coord.cxx!AddToSnapshotSet.
                // It is impossible to succeed there and fail here.
                BS_ASSERT(false);
                // The volume is not supported. Defensive code.
    		    ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED,
    		        L"Volume %s not supported by provider " WSTR_GUID_FMT L"in the context %ld",
    		        pwszVolumeName,
    		        GUID_PRINTF_ARG(InternalProviderId),
    		        GetContextInternal()
    		        );
            }

		    // Add the interface to the array. In this moment the reference count will become 3.
            // We cannot use the local cache for keeping these interfaces because we need to
            // differentiate between provider interfaces involved in the current snapshot set
            // and provider interfaces involved in auto-delete snapshots.
		    if ( !m_mapProviderItfInSnapSet.Add( InternalProviderId, pProviderItf ) )
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

		    // Mark the provider interface as inserted
            bProviderItfInserted = true;
        }

		// Add volume to the thread set.
		// TBD: In the future snapshots will be allowed without involving Lovelace.
		ft.hr = m_VolumesList.AddVolume(wszVolumeNameInternal, pwszVolumeName);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Error adding volume %s to the thread set. 0x%08lx",
					  wszVolumeNameInternal, ft.hr);

		// Mark the volume as inserted
		bVolumeInserted = true;

        // Create the snapshot Id
        VSS_ID SnapshotId;
		ft.hr = ::CoCreateGuid(&SnapshotId);
		if (ft.HrFailed())
			ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"CoCreateGuid()");

        // Prepare the snapshot
        ft.hr = pProviderItf->BeginPrepareSnapshot(
                    CVssGlobalSnapshotSetId::GetID(),
                    SnapshotId,
                    wszVolumeNameInternal
                    );
        // Check if the volume is a non-supported one.
        if ( ft.hr == E_INVALIDARG ) {
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                L"Invalid arguments to BeginPrepareSnapshot for provider " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER ) {
            BS_ASSERT( ProviderId != GUID_NULL );
            ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume %s not supported by provider " WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED ) {
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
                L"Volume %s has too many snapshots" WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.HrFailed() )
            ft.TranslateProviderError(VSSDBG_COORD, InternalProviderId,
                L"BeginPrepareSnapshot("WSTR_GUID_FMT L","WSTR_GUID_FMT L",%s)",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()),
                GUID_PRINTF_ARG(SnapshotId),
                wszVolumeNameInternal);

        // Increment the number of snapshots on this set
        m_lSnapshotsCount++;

        // Set the Snapshot ID
        (*pSnapshotId) = SnapshotId;

        // The pProviderItf reference count will be again 2
        // (the itfs in local cache and in the snapshot set cache) since the smart pointer is gone
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {
		// We do not need to abort the snapshot on error since BeginPrepareSnapshot is the last call.

    	// Remove the volume from the list, if added
    	if (bVolumeInserted) {
    		HRESULT hr2 = m_VolumesList.RemoveVolume( wszVolumeNameInternal );
    		if (FAILED(hr2)) {
    		    BS_ASSERT(false);
    			ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the volume 0x%08lx", hr2);
    		}
    	}

    	// Remove the new interface, if added
    	if (bProviderItfInserted) {
    		if (!m_mapProviderItfInSnapSet.Remove( InternalProviderId ))
    			ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the added interface");
    	}
    }

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::DoSnapshotSet()
/*++

Routine description:

    Performs DoSnapshotSet in a synchronous manner.

Error codes:

    E_OUTOFMEMORY
        - lock statement.
    VSS_E_BAD_STATE
        - Wrong calling sequence.

    [EndPrepareAllSnapshots() failures] or
    [PreCommitAllSnapshots() failures] or
    [CommitAllSnapshots() failures] or
    [PostCommitAllSnapshots() failures]

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Invalid number of prepared snapshots

        [EndPrepareSnapshots() failures] or
        [PreCommitSnapshots() failures] or
        [CommitSnapshots() failures] or
        [PostCommitSnapshots() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - If the volume name does not correspond to an existing mount point then abort
                snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)
            VSS_E_INSUFFICIENT_STORAGE
                Not enough disk storage to create a snapshot (for ex. diff area)
                (remark: when a snapshot is not created since there is not enough disk space
                this error is not guaranteed to be returned. VSS_E_PROVIDER_VETO or VSS_E_OBJECT_NOT_FOUND
                may also be returned in that case.)

    [PrepareAndFreezeWriters() failures] or
    [ThawWriters() failures]
        E_OUTOFMEMORY

        [CoCreateInstance(CLSID_VssEvent) failures] or
        [PrepareForSnapshot() failures] or
        [Freeze() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_WRITER_ERROR
                - Unexpected writer error. The error code is logged into the event log.

    [LovelaceFlushAndHold() failures]
        [FlushAndHoldAllWrites() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - Invalid thread state. Dev error - no entry is put in the event log.
                - Empty volume array. Dev error - no entry is put in the event log.
                - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
            VSS_ERROR_FLUSH_WRITES_TIMEOUT
                - An error occured while flushing the writes from a background thread. An event log entry is added.

    [LovelaceRelease() failures]
        [ReleaseAllWrites() failures]
            [WaitForFinish() failures]
                E_UNEXPECTED
                    - The list of volumes is empty. Dev error - nothing is logged on.
                    - SetEvent failed. An entry is put in the error log.
                    - WaitForMultipleObjects failed. An entry is put in the error log.
                E_OUTOFMEMORY
                    - Cannot create the array of handles.
                    - One of the background threads failed with E_OUTOFMEMORY
                VSS_E_HOLD_WRITES_TIMEOUT
                    - Lovelace couldn't keep more the writes. An event log entry is added.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet" );

    try
    {
		BS_ASSERT(IsContextValid(GetContextInternal()));
		
        // Change state from VSSC_SnapshotSetStarted to VSSC_SnapshotCreation
        // BUG 381357: we do not allow multiple calls to DoSnapshotSet in the context of the same Snapshot Set
        LONG lNewCoordState = ::InterlockedCompareExchange( &m_lCoordState, VSSC_SnapshotCreation, VSSC_SnapshotSetStarted);
        if (lNewCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set in incorrect state %ld", m_lCoordState);

        // The snapshot set must not be empty
        if (m_lSnapshotsCount == 0)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set is empty");

		//
		// Create the snapshot set
		//

		// End the prepare phase for all snapshots. Cancel detection inside
		EndPrepareAllSnapshots();

		// Send PrepareForSnapshot and Freeze to writers.
		// This function may throw HRESULTs
		// Cancel detection inside.
        if (AreWritersAllowed())
	    	PrepareAndFreezeWriters();

		// Pre-commit all snapshots. Cancel detection inside
		PreCommitAllSnapshots();

		// Flush and Hold writes on involved volumes
		LovelaceFlushAndHold();

		// Commit all snapshots. Cancel detection inside
		CommitAllSnapshots();

		// Release writes on involved volumes
		LovelaceRelease();

		// On each involved provider, call PostCommitSnapshots for all committed snapshots.
		PostCommitAllSnapshots();

		// Send the Thaw event to all writers.
		ThawWriters();

		//
		// Snapshot set created.
		//

        // Remove any snapshotset related  state
		Deactivate();

		// Hide errors in eventuality of writer vetos
		ft.hr = S_OK;
    }
    VSS_STANDARD_CATCH(ft)

	m_pWriterCallback = NULL;

	CVssFunctionTracer ft2( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet_failure_block" );

    try
    {
    	// Cleanup on error...
    	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
    	{
    		ft.Trace( VSSDBG_COORD, L"Abort detected while commiting the snapshot set 0x%08lx", ft.hr );
            // These functions should not throw

    		// Deal correctly with committed snapshots
    		AbortAllSnapshots();

        	// Release writes on involved volumes using Lovelace.
        	// Tracing the return value already done.
        	m_VolumesList.ReleaseAllWrites();

    		// Send Abort to all writers,regardless of what events they were already received.
            if (AreWritersAllowed())
        		AbortWriters();

            // If it was a cancel then abort the snapshot set in progress.
            // WARNING: This call may throw
            if (ft.hr == VSS_S_ASYNC_CANCELLED)
                Deactivate();
    	}
    }
    VSS_STANDARD_CATCH(ft2);

    if (ft2.HrFailed())
	    ft2.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft2.hr);

	BS_ASSERT(m_bHasAcquiredSem);
	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
	m_bHasAcquiredSem = false;

    return ft.hr;
}


void CVssSnapshotSetObject::PrepareAndFreezeWriters() throw (HRESULT)
/*++

Routine description:

    Send the PrepareForSnapshot and Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [CoCreateInstance(CLSID_VssEvent) failures] or
    [PrepareForSnapshot() failures] or
    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PrepareAndFreezeWriters" );
		
    // Allocate the string for snapshot set ID
     CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();
    if (!bstrSnapshotSetID)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

    // Create the instance of the event class
    if (m_pWriters == NULL)
    {
        CVssFunctionTracer ft( VSSDBG_COORD, L"PrepareAndFreezeWriters_create_writers_instance" );
        ft.hr = m_pWriters.CoCreateInstance(CLSID_VssEvent);
        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"CoCreateInstance(CLSID_VssEvent)");
        BS_ASSERT(m_pWriters);
		SetupPublisherFilter
			(
			m_pWriters,
			NULL,
			NULL,
			m_rgWriterInstances,
			m_cWriterInstances,
			false,
			false
			);
    }

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);

	// Get the list of volumes to be snapshotted
	CComBSTR bstrVolumeNamesList = m_VolumesList.GetVolumesList();
	if (bstrVolumeNamesList.Length() == 0)
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Null volume list");

	// We will ignore the case when if some subscribers returned and
	// error code while treating the event. This is because
	// transient subscriptions are not garbage collected in the event system.
	// In other words, if a subscriber process died without having a change to remove its
	// transient subscriptions the sending event will return one of these
	// EVENT_XXXX_SUBSCRIBERS_FAILED - which is wrong. Therefore this mechanism is not so
	// reliable therefore we will not use it.

    // Send "PrepareForSnapshot" event to all subscribers
    ft.hr = m_pWriters->PrepareForSnapshot(
				bstrSnapshotSetID,
				bstrVolumeNamesList
				);
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"PrepareForSnapshot(%s,%s)", bstrSnapshotSetID, bstrVolumeNamesList);

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);

    // Freeze the front-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_FRONT_END);

    // Freeze the back-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_BACK_END);

    // Freeze the system writers
    FreezePhase(bstrSnapshotSetID, VSS_APP_SYSTEM);
}


void CVssSnapshotSetObject::FreezePhase(
        IN  CComBSTR& bstrSnapshotSetID,
        IN  VSS_APPLICATION_LEVEL eAppLevel
        ) throw (HRESULT)
/*++

Routine description:

    Send the Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::FreezePhase" );
		
    // Send "Freeze" event to all level 0 subscribers
    BS_ASSERT(m_pWriters != NULL);
    ft.hr = m_pWriters->Freeze(bstrSnapshotSetID, eAppLevel);
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Freeze(%s,%d)", bstrSnapshotSetID, (INT)eAppLevel);

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);
}


void CVssSnapshotSetObject::ThawWriters() throw (HRESULT)
/*++

Routine description:

    Send the Thaw events to all writers.

Error codes:

    E_OUTOFMEMORY

    [Thaw() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
	{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::ThawWriters" );

	// Allocate the string for snapshot set ID
	CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

	if (!bstrSnapshotSetID)
		// We cannot send anymore the Thaw event since we have a memory allocation error
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");


	if (AreWritersAllowed())
		{
		// Send "Thaw" event to all subscribers
		BS_ASSERT(m_pWriters != NULL);
		ft.hr = m_pWriters->Thaw(bstrSnapshotSetID);
		ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Thaw(%s)", bstrSnapshotSetID);
		}

	// call PostSnapshot method on the providers
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
		{
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PostSnapshot(m_pWriterCallback);
		if (ft.HrFailed())
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PostCommitSnapshots("WSTR_GUID_FMT L", %ld)",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()), m_lSnapshotsCount);
		}

	if (AreWritersAllowed())
		{
		CComPtr<IDispatch> pCallback;
		CVssCoordinatorCallback::Initialize(m_pWriterCallback, &pCallback);

		ft.hr = m_pWriters->PostSnapshot(bstrSnapshotSetID, pCallback);
		ft.TranslateWriterReturnCode( VSSDBG_COORD, L"PostSnapshot(%s)", bstrSnapshotSetID);
		}
	}





void CVssSnapshotSetObject::AbortWriters()
/*++

Routine description:

    Send the Abort events to all writers.

Error codes:

    [Abort() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortWriters" );
		
	if (m_pWriters != NULL) {

		// Allocate the string for snapshot set ID
		CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

		if (!bstrSnapshotSetID) {
			// We cannot send anymore the Abort event since we have a memory allocation error
			ft.Trace( VSSDBG_COORD, L"Memory allocation error");
		} else {

			// Send "Abort" event to all subscribers
			ft.hr = m_pWriters->Abort(bstrSnapshotSetID);
            ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Abort(%s)", bstrSnapshotSetID);
		}
	}
}


void CVssSnapshotSetObject::SetWriterInstances
	(
	LONG cWriterInstances,
	VSS_ID *rgWriterInstances
	)
/*++

Routine description:

	Set the set of writers that participate in the snapshot

Throws:

	E_OUTOFMEMORY
--*/

	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::SetWriterInstances");

	m_rgWriterInstances = new VSS_ID[cWriterInstances];

	if (m_rgWriterInstances == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot allocate array of writer instances");

	m_cWriterInstances = cWriterInstances;

	memcpy(m_rgWriterInstances, rgWriterInstances, m_cWriterInstances * sizeof(VSS_ID));
	}


void CVssSnapshotSetObject::LovelaceFlushAndHold()
/*++

Routine description:

    Invokes the Lovelace's Flush& Hold on all volumes in the snapshot set.

Throws:

    [FlushAndHoldAllWrites() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - Invalid thread state. Dev error - no entry is put in the event log.
            - Empty volume array. Dev error - no entry is put in the event log.
            - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
        VSS_ERROR_FLUSH_WRITES_TIMEOUT
            - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceFlushAndHold" );

	// Flush And Hold writes on involved volumes using Lovelace.
	ft.hr = m_VolumesList.FlushAndHoldAllWrites(CVssGlobalSnapshotSetId::GetID());
	if (ft.HrFailed())
		ft.Throw(VSSDBG_COORD, ft.hr, L"Flush and Hold failure");
}


void CVssSnapshotSetObject::LovelaceRelease()
/*++

Routine description:

    Invokes the Lovelace's Release on all volumes in the snapshot set,

Throws:

    [ReleaseAllWrites() failures]
        [WaitForFinish() failures]
            E_UNEXPECTED
                - The list of volumes is empty. Dev error - nothing is logged on.
                - SetEvent failed. An entry is put in the error log.
                - WaitForMultipleObjects failed. An entry is put in the error log.
            E_OUTOFMEMORY
                - Cannot create the array of handles.
                - One of the background threads failed with E_OUTOFMEMORY
            VSS_E_HOLD_WRITES_TIMEOUT
                - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceRelease" );

	// Release writes on involved volumes using Lovelace.
	ft.hr = m_VolumesList.ReleaseAllWrites();
	if (ft.HrFailed())
		ft.Throw(VSSDBG_COORD, ft.hr, L"Release failure");
}


void CVssSnapshotSetObject::EndPrepareAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call EndPrepareSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [EndPrepareSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)
        VSS_E_INSUFFICIENT_STORAGE
            Not enough disk storage to create a snapshot (for ex. diff area)
            (remark: when a snapshot is not created since there is not enough disk space
            this error is not guaranteed to be returned. VSS_E_PROVIDER_VETO or VSS_E_OBJECT_NOT_FOUND
            may also be returned in that case.)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::EndPrepareAllSnapshots" );
		
	// On each involved provider, call PreCommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{

		// End the background prepare phase
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->EndPrepareSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_INSUFFICIENT_STORAGE )
    		ft.Throw(VSSDBG_COORD, VSS_E_INSUFFICIENT_STOR