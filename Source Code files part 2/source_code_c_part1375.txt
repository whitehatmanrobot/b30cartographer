    // Converting a NULL to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        hr = THR(FormsAllocString( _T("null"),
            &V_BSTR(pVArgDest) ) );
        goto Cleanup;
    }
    else if (vt == VT_BSTR && V_VT(pvarg) == VT_EMPTY)
    {
        // Converting "undefined" to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        hr = THR(FormsAllocString( _T("undefined"),
            &V_BSTR(pVArgDest) ) );
        goto Cleanup;
    }
    else if (vt == VT_BOOL && V_VT(pvarg) == VT_BSTR)
    {
        // Converting from BSTR to BOOL
        // To match Navigator compatibility empty strings implies false when
        // assigned to a boolean type any other string implies true.
        V_VT(pVArgDest) = VT_BOOL;
        V_BOOL(pVArgDest) = FormsStringLen(V_BSTR(pvarg)) == 0 ? VB_FALSE : VB_TRUE;
        goto Cleanup;
    }
    else if (  V_VT(pvarg) == VT_BOOL && vt == VT_BSTR )
    {
        // Converting from BOOL to BSTR
        // To match Nav we either get "true" or "false"
        V_VT(pVArgDest) = VT_BSTR;
        hr = THR(FormsAllocString( V_BOOL(pvarg) == VB_TRUE ? _T("true") : _T("false"),
            &V_BSTR(pVArgDest) ) );
        goto Cleanup;
    }
    // If we're converting R4 or R8 to a string then we need special handling to
    // map Nan and +/-Inf.
    else if (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        double  dblValue = V_VT(pvarg) == VT_R8 ? V_R8(pvarg) : (double)(V_R4(pvarg));

        // Infinity or NAN?
        if (!isFinite(dblValue))
        {
            if (isNAN(dblValue))
            {
                // NAN
                hr = FormsAllocStringW(_T("NaN"), &(V_BSTR(pVArgDest)));
            }
            else
            {
                // Infinity
                hr = FormsAllocStringW((dblValue < 0) ? _T("-Infinity") : _T("Infinity"), &(V_BSTR(pVArgDest)));
            }
        }
        else
            goto DefaultConvert;


        // Any error from allocating string?
        if (hr)
           goto Cleanup;

        V_VT(pVArgDest) = vt;
        goto Cleanup;
    }


DefaultConvert:
    //
    // Default VariantChangeTypeEx.
    //

    // VARIANT_NOUSEROVERRIDE flag is undocumented flag that tells OLEAUT to convert to the lcid
    // given. Without it the conversion is done to user localeid
    hr = THR_NOTRACE(VariantChangeTypeEx(pVArgDest, pvarg, LCID_SCRIPTING, dwFlags|VARIANT_NOUSEROVERRIDE, vt));

    
    if (hr == DISP_E_TYPEMISMATCH  )
    {
        if ( V_VT(pvarg) == VT_NULL )
        {
            hr = S_OK;
            switch ( vt )
            {
            case VT_BOOL:
                V_BOOL(pVArgDest) = VB_FALSE;
                V_VT(pVArgDest) = VT_BOOL;
                break;

            // For NS compatability - NS treats NULL args as 0
            default:
                V_UNKNOWN(pVArgDest) = NULL;
                break;
            }
        }
        else if (V_VT(pvarg) == VT_DISPATCH )
        {
            // Nav compatability - return the string [object] or null 
            V_VT(pVArgDest) = VT_BSTR;
            hr = THR(FormsAllocString ( (V_DISPATCH(pvarg)) ? _T("[object]") : _T("null"), &V_BSTR(pVArgDest) ) );
        }
        else if (   V_VT(pvarg) == VT_BSTR 
                &&  (   V_BSTR(pvarg)  
                    &&  ((V_BSTR(pvarg))[0] == _T('\0')) 
                    ||  ! V_BSTR(pvarg) )
                &&  (  vt == VT_I4 || vt == VT_I2 
                    || vt == VT_UI2 || vt == VT_UI4 
                    || vt == VT_I8 || vt == VT_UI8 
                    || vt == VT_INT || vt == VT_UINT ) )
        {
            // Converting empty string to integer => Zero
            hr = S_OK;
            V_VT(pVArgDest) = vt;
            V_I4(pVArgDest) = 0;
            goto Cleanup;
        }    
    }
    else if (hr == DISP_E_OVERFLOW && vt == VT_I4 && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        // Nav compatability - return MAXLONG on overflow
        V_VT(pVArgDest) = VT_I4;
        V_I4(pVArgDest) = MAXLONG;
        hr = S_OK;
        goto Cleanup;
    }

    // To match Navigator change any scientific notation E to e.
    if (!hr && (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4)))
    {
        TCHAR *pENotation;

        pENotation = _tcschr(V_BSTR(pVArgDest), _T('E'));
        if (pENotation)
            *pENotation = _T('e');
    }

Cleanup:
    ReleaseInterface(pVarChangeType);

    RRETURN(hr);
}

HRESULT ClipVarString(VARIANT *pvarSrc, VARIANT *pvarDest, BOOL *pfAlloc, WORD wMaxstrlen)
{
    HRESULT hr = S_OK;
    if (wMaxstrlen && (V_VT(pvarSrc) == VT_BSTR) && FormsStringLen(V_BSTR(pvarSrc)) > wMaxstrlen)
    {
        hr = FormsAllocStringLen(V_BSTR(pvarSrc), wMaxstrlen, &V_BSTR(pvarDest));
        if (hr)
            goto Cleanup;

        *pfAlloc = TRUE;
        V_VT(pvarDest) = VT_BSTR;
    }
    else
        hr = S_FALSE;

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg]         -- Variant to convert.
//              [pfAlloc]       -- BSTR allocated during conversion caller is
//                                 now owner of this BSTR or IUnknown or IDispatch
//                                 object allocated needs to be released.
//              [vt]            -- Type to convert to.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8, VT_ERROR.
//----------------------------------------------------------------------------

HRESULT
VARIANTARGToCVar(VARIANT * pvarg, BOOL *pfAlloc, VARTYPE vt, void * pv, IServiceProvider *pSrvProvider, WORD wMaxstrlen)
{
    HRESULT         hr = S_OK;
    VARIANTARG     *pVArgCopy = pvarg;
    VARIANTARG      vargNew;                    // variant of new type
    BOOL            fAlloc;

    Assert(pvarg);
    Assert(pv);

    VariantInit(&vargNew);

    if (!pfAlloc)
        pfAlloc = &fAlloc;

    Assert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    // Assume no allocations yet.
    *pfAlloc = FALSE;

    if (vt & VT_BYREF)
    {
        // If the parameter is a variant pointer then everything is acceptable.

        if ((vt & VT_TYPEMASK) == VT_VARIANT)
        {
            switch (V_VT(pvarg))
            {
            case VT_VARIANT | VT_BYREF :
                hr = ClipVarString(pvarg->pvarVal, *(VARIANT **)pv, pfAlloc, wMaxstrlen);
                break;
            default:
                hr = ClipVarString(pvarg, *(VARIANT **)pv, pfAlloc, wMaxstrlen);
                break;
            }
            if (hr == S_FALSE)
            {
                hr = S_OK;
                *(PVOID *)pv = (PVOID)pvarg;
            }

            goto Cleanup;
        }

        if ((V_VT(pvarg) & VT_TYPEMASK) != (vt & VT_TYPEMASK))
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Type of both original and destination or same type (however, original
        // may not be a byref only the original.

        if (V_ISBYREF(pvarg))
        {
            // Destination and original are byref and same type just copy pointer.
            *(PVOID *)pv = V_BYREF(pvarg);
        }
        else
        {
            // Convert original to byref.
            switch (vt & VT_TYPEMASK)
            {
            case VT_BOOL:
                *(PVOID *)pv = (PVOID)&V_BOOL(pvarg);
                break;

            case VT_I2:
                *(PVOID *)pv = (PVOID)&V_I2(pvarg);
                break;

            case VT_ERROR:
            case VT_I4:
                *(PVOID *)pv = (PVOID)&V_I4(pvarg);
                break;

            case VT_I8:
                *(PVOID *)pv = (PVOID)&V_I8(pvarg);
                break;
                
            case VT_R4:
                *(PVOID *)pv = (PVOID)&V_R4(pvarg);
                break;

            case VT_R8:
                *(PVOID *)pv = (PVOID)&V_R8(pvarg);
                break;

            case VT_CY:
                *(PVOID *)pv = (PVOID)&V_CY(pvarg);
                break;

            // All pointer types.
            case VT_PTR:
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                *(PVOID *)pv = (PVOID)&V_UNKNOWN(pvarg);
                break;

            case VT_VARIANT:
                Assert("Dead code: shudn't have gotten here!");
                *(PVOID *)pv = (PVOID)pvarg;
                break;

            default:
                Assert(!"Unknown type in BYREF VARIANTARGToCVar().\n");
                hr = DISP_E_TYPEMISMATCH;
                goto Cleanup;
            }
        }

        goto Cleanup;
    }
    // If the c style parameter is the same type as the VARIANT then we'll just
    // move the data.  Also if the c style type is a VARIANT then there's
    // nothing to convert just copy the variant to the C parameter.
    else if ((V_VT(pvarg) & (VT_TYPEMASK | VT_BYREF)) != vt && (vt != VT_VARIANT))
    {
        // If the request type isn't the same as the variant passed in then we
        // need to convert.
        pVArgCopy = &vargNew;

        hr = VariantChangeTypeSpecial(pVArgCopy, pvarg, vt,pSrvProvider);

        if (hr)
            goto Cleanup;

        *pfAlloc = (vt == VT_BSTR) || (vt == VT_UNKNOWN) || (vt == VT_DISPATCH);
    }

    // Move the variant data to C style data.
    switch (vt)
    {
    case VT_BOOL:
        #if DBG==1
            if (V_BOOL(pVArgCopy) != VB_FALSE && V_BOOL(pVArgCopy) != VB_TRUE)
            {
                TraceTag((tagWarning, "Illegal VT_BOOL in VARIANTARGToCVar"));
            }
        #endif

        // convert VT_TRUE and any other non-zero values to TRUE
        *(VARIANT_BOOL *)pv = V_BOOL(pVArgCopy);
        break;

    case VT_I2:
        *(short *)pv = V_I2(pVArgCopy);
        break;

    case VT_ERROR:
    case VT_I4:
        *(long *)pv = V_I4(pVArgCopy);
        break;

    case VT_I8:
        *(LONGLONG *)pv = V_I8(pVArgCopy);
        break;
        
    case VT_R4:
        *(float *)pv = V_R4(pVArgCopy);
        break;

    case VT_R8:
        *(double *)pv = V_R8(pVArgCopy);
        break;

    case VT_CY:
        *(CY *)pv = V_CY(pVArgCopy);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
        if (wMaxstrlen && FormsStringLen(V_BSTR(pVArgCopy)) > wMaxstrlen)
        {
            hr = FormsAllocStringLen(V_BSTR(pVArgCopy), wMaxstrlen, (BSTR *)pv);
            if (hr)
                goto Cleanup;

            if (*pfAlloc)
                VariantClear(&vargNew);
            else
                *pfAlloc = TRUE;

            goto Cleanup;
        }
    case VT_PTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(pVArgCopy);
        break;

    case VT_VARIANT:
        hr = ClipVarString(pVArgCopy, (VARIANT *)pv, pfAlloc, wMaxstrlen);
        if (hr == S_FALSE)
        {
            hr = S_OK;
            // Copy entire variant to output parameter.
            *(VARIANT *)pv = *pVArgCopy;
        }

        break;

    default:
        Assert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        hr = DISP_E_TYPEMISMATCH;
        break;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToIndex
//
//  Synopsis:   Converts a VARIANT to an index of type long. Sets the index to
//              -1 if the VARIANT type is bad or empty.
//
//  Arguments:  [pvarg]         -- Variant to convert.
//              [plIndex        -- Location to place index.
//
//  Notes:      Useful special case of VARIANTARGToCVar for reading array
//              indices.
//----------------------------------------------------------------------------

HRESULT
VARIANTARGToIndex(VARIANT * pvarg, long * plIndex)
{
    HRESULT         hr = S_OK;
        
    Assert(pvarg);
    *plIndex = -1;

    // Quick return for the common case
    if(V_VT(pvarg) == VT_I4 || V_VT(pvarg) == (VT_I4 | VT_BYREF))
    {
        *plIndex = (V_VT(pvarg) == VT_I4) ? V_I4(pvarg) : *V_I4REF(pvarg);
        return S_OK;
    }

    if (V_VT(pvarg) == VT_ERROR || V_VT(pvarg) == VT_EMPTY)
    {
        return S_OK;
    }

    // Must perform type corecion
    CVariant varNum;
    hr = THR(VariantChangeTypeEx(&varNum, pvarg, LCID_SCRIPTING, 0, VT_I4));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varNum) == VT_I4 || V_VT(&varNum) == (VT_I4 | VT_BYREF));
    *plIndex = (V_VT(&varNum) == VT_I4) ? V_I4(&varNum) : *V_I4REF(&varNum);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8, VT_ERROR.
//
//----------------------------------------------------------------------------

void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    Assert(pv);
    Assert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        Assert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_ERROR:
    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    case VT_CY:
        V_CY(pvarg) = *(CY *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_PTR:
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(void **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pb]         -- List of C parameter types.  May be NULL.
//                              Construct using EVENT_PARAM macro.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        const BYTE *    pb,
        va_list         va)
{
    Assert(pDispParams);
    Assert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    const BYTE *    pbCur;              // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    pDispParams->cArgs = strlen((char *) pb);
    Assert(pDispParams->cArgs < EVENTPARAMS_MAX);

    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    Assert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pbCur = pb; *pbCur; pbCur++)
    {
        pvargCur--;
        Assert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = VARTYPEFromBYTE(*pbCur);
        if (V_VT(pvargCur) & VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (V_VT(pvargCur))
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                Assert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_ERROR:
            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = (float) va_arg(va, double);
                // casting & change to double inserted to fix BUG 5005
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_PTR:
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, void **);
                break;

            case VT_VARIANT:
                *pvargCur = va_arg(va, VARIANT);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pb]  -- Array of types of C-params.  May be NULL.
//                       Construct using EVENT_PARAM macro.
//              [...] -- List of pointers to c-params to be converted to.
//              -1    -- Last parameter to signal end of parameter list.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

HRESULT
__cdecl DispParamsToCParams(
        IServiceProvider   *pSrvProvider,
        DISPPARAMS         *pDP,
        ULONG              *pAlloc,
        WORD                wMaxstrlen,
        VARTYPE            *pVT,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    UINT            cArgs;             // count of arguments.

    Assert(pDP);

    hr = S_OK;
    va_start(va, pVT);
    if (!pVT)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    for (cArgs = 0; cArgs < pDP->cArgs; cArgs++)
    {
        BOOL    fAlloc;

        // If the DISPID_THIS named argument is passed in skip it.
        if (pDP->cNamedArgs && (pDP->cArgs - cArgs <= pDP->cNamedArgs))
        {
            if (pDP->rgdispidNamedArgs[(pDP->cArgs - cArgs) - 1] == DISPID_THIS)
            {
                pvargCur--;
                continue;
            }
        }

        pv = va_arg(va, void *);

        // Done processing arguments?
        if (pv == (void *)-1)
            goto Cleanup;

        // Skip all byvalue variants custom invoke doesn't pass them.
        if (!((*pVT == VT_VARIANT) && (pv == NULL)))
        {
            hr = THR(VARIANTARGToCVar(pvargCur, &fAlloc, *pVT, pv, pSrvProvider, ((wMaxstrlen == pdlNoLimit) ? 0 : wMaxstrlen)));
            if (hr)
                goto Cleanup;

            // Any BSTRs or objects (IUnknow, IDispatch) allocated during
            // conversion to CVar then remember which param this occurred to so
            // we can de-allocate it when we're finished.
            if (pAlloc && fAlloc)
            {
                *pAlloc |= (1 << cArgs);
            }
        }

        pvargCur--;
        pVT++;
    }

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}

//----------------------------------------------------------------------
//
// Function: GetNamedProp
//
// Description: Gets a property by name.  Does all the work for you
//
//----------------------------------------------------------------------
HRESULT
GetNamedProp(IDispatch *pDispatch, BSTR bstrPropName, LCID lcid, VARIANT *pv, DISPID *pDispid, EXCEPINFO *pexecpinfo, BOOL fMethodCall, BOOL fCaseSensitive)
{
    HRESULT hr;
    DISPID dispid;
    IDispatchEx *pDEX = 0;
    DWORD flags = fMethodCall ? DISPATCH_METHOD : DISPATCH_PROPERTYGET;
    DISPPARAMS dp;
    UINT uiErr;

    if (pDispid == 0)
        pDispid = &dispid;
    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(pv);

    if (fCaseSensitive)
    {
        hr = THR(pDispatch->QueryInterface(IID_IDispatchEx, (LPVOID *) &pDEX));
        if (hr)
            goto Cleanup;

        hr = THR(pDEX->GetDispID(bstrPropName, fdexNameCaseSensitive , pDispid));
        if (hr)
            goto Cleanup;

        hr = THR(pDEX->InvokeEx(*pDispid, lcid, flags, &dp, pv, pexecpinfo, NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pDispatch->GetIDsOfNames(IID_NULL, &bstrPropName, 1, lcid, pDispid));
        if (hr)
            goto Cleanup;

        hr = THR(pDispatch->Invoke(*pDispid, IID_NULL, lcid, flags, &dp, pv, pexecpinfo, &uiErr));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pDEX);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//              [pexcepinfo] -- where caller wants exception info
//              [fMethodCall] -- a straight method call should be used,
//                               rather than property-specific mechanisms
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo,
        DWORD       dwFlags)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    Assert(pDisp);
    Assert(pvar);

    dwFlags = (dwFlags & DISPATCH_METHOD) ? DISPATCH_METHOD : DISPATCH_PROPERTYGET;
    
    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = THR_NOTRACE(pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            dwFlags,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr));


    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//              [pexcepinfo] -- where caller wants exception info
//              [fMethodCall] -- a straight method call should be used,
//                               rather than property-specific mechanisms
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo,
        DWORD           dwFlags)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    Assert(pDisp);
    Assert(pvarg);

    dp.rgvarg = pvarg;
    dp.cArgs = 1;
    
    if (dwFlags & DISPATCH_METHOD)
    {
        dwFlags = DISPATCH_METHOD;
        dp.cNamedArgs = 0;
        dp.rgdispidNamedArgs = NULL;
    }
    else
    {
        dwFlags = (dispid == DISPID_FONT || (dwFlags & DISPATCH_PROPERTYPUTREF))
                    ? DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT;
        dp.cNamedArgs = 1;
        dp.rgdispidNamedArgs = &dispidPut;
    }
    hr = THR_NOTRACE(pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            dwFlags,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr));

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pbParams]  -- List of param types.  May be NULL.
//                             Construct using EVENT_PARAM macro.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
__cdecl CallDispMethod(
        IServiceProvider *pSrvProvider,
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        BYTE *      pbParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.
    EXCEPINFO   excepinfo;             // macnote: this is a required param to IDispatch->Invoke
    BOOL        fVariantClear = FALSE;
    IDispatchEx *pDispEx = NULL;

    Assert(pDisp);
    Assert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pbParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pbParams, va);
    va_end(va);
    memset(&excepinfo,0,sizeof(excepinfo));

    if (pvReturn)
        VariantInit(&varReturn);

    // use IDispatchEx, if available
    hr = pDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx);

    if (!hr && pDispEx)
    {
        hr = THR_NOTRACE(pDispEx->InvokeEx(
                dispid,
                lcid,
                DISPATCH_METHOD,
                &dp,
                pvReturn ? &varReturn : NULL,
                &excepinfo,
                pSrvProvider));
    }
    else
    {
        hr = THR_NOTRACE(pDisp->Invoke(
                dispid,
                IID_NULL,
                lcid,
                DISPATCH_METHOD,
                &dp,
                pvReturn ? &varReturn : NULL,
                &excepinfo,
                NULL));
    }
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = THR(VARIANTARGToCVar(&varReturn, &fVariantClear, vtReturn, pvReturn, pSrvProvider));
    if (fVariantClear)
        VariantClear(&varReturn);

Cleanup:
    FreeEXCEPINFO(&excepinfo);
    ReleaseInterface(pDispEx);
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !FormsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_PTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        Assert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}


//+------------------------------------------------------------------------
//  Function:   DispParamsToSAFEARRAY, public API
//
//  Synopsis:   Converts all arguments in dispparams to a SAFEARRAY
//              If the DISPPARAMS contains no arguments we should create
//              an empty SAFEARRAY.
//
//  Arguments:  [pdispparams] -- VARIANTARGs to add to safearray.
//
//  Returns:    If the DISPPARAMS contains no arguments we should create an
//              empty SAFEARRAY.  It is the responsibility of the caller to
//              call SafeArrayDestroy.
//-------------------------------------------------------------------------

SAFEARRAY *
DispParamsToSAFEARRAY (DISPPARAMS *pdispparams)
{
    SAFEARRAY  *psa = NULL;
    HRESULT     hr = S_OK;

    LONG saElemIdx;
    SAFEARRAYBOUND  sabounds;
    const LONG cArgsToArray = pdispparams->cArgs;
    const LONG cArgsNamed = pdispparams->cNamedArgs;

    sabounds.cElements = cArgsToArray;

    // If first named arg is DISPID_THIS then this parameter won't be part of
    // the safearray.
    if (cArgsNamed)
    {
        if (pdispparams->rgdispidNamedArgs[0] == DISPID_THIS)
            sabounds.cElements--;
    }

    sabounds.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabounds);
    if (psa == NULL)
        goto Cleanup;

    // dispparams are in right to left order.
    for( saElemIdx = 0; saElemIdx < cArgsToArray; saElemIdx++ )
    {
        // Don't process any DISPID_THIS named arguments.
        if (cArgsNamed && (cArgsToArray - saElemIdx <= cArgsNamed))
        {
            if (pdispparams->rgdispidNamedArgs[(cArgsToArray - saElemIdx) - 1] == DISPID_THIS)
                continue;
        }

        hr = SafeArrayPutElement(psa, &saElemIdx, pdispparams->rgvarg + (cArgsToArray - 1 - saElemIdx) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr && psa)
    {
        hr = SafeArrayDestroy(psa);
        psa = NULL;
    }

    return psa;
}

//+------------------------------------------------------------------------
//
//  Class:      CInvoke
//
//-------------------------------------------------------------------------

CInvoke::CInvoke()
{
    memset (this, 0, sizeof(*this));
}

CInvoke::CInvoke (IDispatchEx * pdispex)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(pdispex));
}

CInvoke::CInvoke (IDispatch * pdisp)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(pdisp));
}

CInvoke::CInvoke (IUnknown * punk)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(punk));
}

CInvoke::CInvoke (CBase * pBase)
{
    memset (this, 0, sizeof(*this));
    IGNORE_HR(Init(pBase));
}

CInvoke::~CInvoke()
{
    Clear();
}

HRESULT
CInvoke::Init(IDispatchEx * pdispex)
{
    ReplaceInterface (&_pdispex, pdispex);

    return S_OK;
};

HRESULT
CInvoke::Init(IDispatch * pdisp)
{
    ReplaceInterface (&_pdisp, pdisp);

    return S_OK;
};

HRESULT
CInvoke::Init(IUnknown * punk)
{
    HRESULT hr;

    hr = THR(punk->QueryInterface(IID_IDispatchEx, (void**)&_pdispex));
    if (hr)
    {
        _pdispex = NULL;

        hr = THR(punk->QueryInterface(IID_IDispatch, (void**)&_pdisp));
    }

    RRETURN (hr);
}

HRESULT
CInvoke::Init(CBase * pBase)
{
    HRESULT hr;

    hr = THR(pBase->PrivateQueryInterface(IID_IDispatchEx, (void**)&_pdispex));

    RRETURN (hr);
}

void
CInvoke::Clear()
{
    ClearInterface(&_pdispex);
    ClearInterface(&_pdisp);
    ClearArgs();
    ClearRes();
}

void
CInvoke::ClearArgs()
{
    UINT i;

    for (i = 0; i < _dispParams.cArgs; i++)
    {
        VariantClear(&_aryvarArg[i]);
    }
    _dispParams.cArgs  = 0;
    _dispParams.rgvarg = NULL;
}

void
CInvoke::ClearRes()
{
    VariantClear(&_varRes);
}

HRESULT
CInvoke::Invoke (DISPID dispid, WORD wFlags)
{
    HRESULT     hr;

    Assert (_pdispex || _pdisp);

    if (_pdispex)
    {
        hr = THR_NOTRACE(_pdispex->InvokeEx(
            dispid, g_lcidUserDefault, wFlags, &_dispParams, &_varRes, &_excepInfo, NULL));
    }
    else if (_pdisp)
    {
        UINT    nArgErr;

        hr = THR_NOTRACE(_pdisp->Invoke(
            dispid, IID_NULL, g_lcidUserDefault, wFlags, &_dispParams, &_varRes, &_excepInfo, &nArgErr));
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN (hr);
}

HRESULT
CInvoke::AddArg()
{
    HRESULT     hr = S_OK;

    if (ARRAY_SIZE(_aryvarArg) <= _dispParams.cArgs)
        RRETURN (E_NOTIMPL);

    if (0 == _dispParams.cArgs)
    {
        _dispParams.rgvarg = _aryvarArg;
    }

    _dispParams.cArgs++;

    RRETURN (hr);
}

HRESULT
CInvoke::AddArg(VARIANT * pvarArg)
{
    HRESULT     hr;

    hr = THR(AddArg());
    if (hr)
        goto Cleanup;

    VariantCopy(&_aryvarArg[_dispParams.cArgs - 1], pvarArg);

Cleanup:

    RRETURN (hr);
}

HRESULT
CInvoke::AddNamedArg(DISPID dispid)
{
    HRESULT     hr = S_OK;

    if (ARRAY_SIZE(_arydispidNamedArg) <= _dispParams.cNamedArgs)
        RRETURN (E_NOTIMPL);

    if (0 == _dispParams.cNamedArgs)
    {
        _dispParams.rgdispidNamedArgs = _arydispidNamedArg;
    }

    _dispParams.cNamedArgs++;

    _arydispidNamedArg[_dispParams.cNamedArgs - 1] = dispid;

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\fbstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       fbstr.cxx
//
//  Contents:   Wrappers around BSTR api to account for wierdness with NULL
//
//  Functions:  FormsAllocString
//              FormsAllocStringLen
//              FormsReAllocString
//              FormsReAllocStringLen
//              FormsFreeString
//              FormsStringLen
//              FormsStringByteLen
//              FormsStringCmp
//              FormsStringNCmp
//              FormsStringICmp
//              FormsStringNICmp
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+---------------------------------------------------------------------------
//
//  Function:   FormsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------
HRESULT
FormsAllocStringW(LPCWSTR pch, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (!pch || !*pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }
    *pBSTR = SysAllocString(pch);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsAllocStringLen
//
//  Synopsis:   Allocs a BSTR of [uc] + 1 OLECHARS, and
//              initializes it from an optional string.  If [uc] == 0, the
//              resulting bstr is NULL.
//
//  Arguments:  [pch]   -- String to initialize.
//              [uc]    -- Count of characters of string.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
FormsAllocStringLenW(LPCWSTR pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr;

    Assert(pBSTR);
    if (uc == 0)
    {
        *pBSTR = NULL;
        return S_OK;
    }

    *pBSTR = SysAllocStringLen(pch, uc);
    hr = *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsReAllocString
//
//  Synopsis:   Allocates a BSTR initialized from a string; if successful,
//              frees the original string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
FormsReAllocStringW(BSTR * pBSTR, LPCWSTR pch)
{
    Assert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = THR(FormsAllocStringW(pch, &bstrTmp));
    if (hr)
        RRETURN(hr);

    FormsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else  //DBG == 1
#  ifndef _MAC
    return SysReAllocString(pBSTR, pch) ? S_OK : E_OUTOFMEMORY;
#  else
    // mac note: Richedit text requires BSTRs that contain unicode strings
    //          so we will occasionally need to call this wide char version 
    return SysReAllocStringLen(pBSTR, (OLECHAR *)pch, wcslen(pch) * sizeof(WCHAR)) ? S_OK : E_OUTOFMEMORY;
#  endif

#endif //DBG == 1
}


//+---------------------------------------------------------------------------
//
//  Function:   FormsReAllocStringLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 OLECHARs and optionally
//              initializes it from a string; if successful, frees the original
//              string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//              [uc]    -- Count of characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
FormsReAllocStringLenW(BSTR * pBSTR, LPCWSTR pch, UINT uc)
{
    Assert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = THR(FormsAllocStringLen(pch, uc, &bstrTmp));
    if (hr)
        RRETURN(hr);

    FormsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else
    return SysReAllocStringLen(pBSTR, pch, uc) ? S_OK : E_OUTOFMEMORY;
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   FormsStringLen
//
//  Synopsis:   Returns the length of the BSTR.
//
//  History:    5-06-94   adams   Created
//              6-30-95   andrewl Changed BSTR to const BSTR
//
//----------------------------------------------------------------------------

UINT
FormsStringLen(const BSTR bstr)
{
    return bstr ? SysStringLen((BSTR)bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   FormsStringByteLen
//
//  Synopsis:   Returns the length of a BSTR in bytes.
//
//  History:    5-06-94   adams   Created
//              6-30-95   andrewl Changed BSTR to const BSTR
//
//----------------------------------------------------------------------------

UINT
FormsStringByteLen(const BSTR bstr)
{
    return bstr ? SysStringByteLen((BSTR)bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   FormsStringCmp
//
//  Synopsis:   As per _tcscmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

int
FormsStringCmp(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcscmp(STRVAL(bstr1), STRVAL(bstr2));
}
int
FormsStringCmpLoc(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcscmpLoc(STRVAL(bstr1), STRVAL(bstr2));
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsStringNCmp
//
//  Synopsis:   As per _tcsncmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

int
FormsStringNCmp(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsncmp(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}
int
FormsStringNCmpLoc(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsncmpLoc(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}



//+---------------------------------------------------------------------------
//
//  Function:   FormsStringICmp
//
//  Synopsis:   As per wcsicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsicmp to _tcsicmp
//
//----------------------------------------------------------------------------

int
FormsStringICmp(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}
int
FormsStringICmpLoc(LPCTSTR bstr1, LPCTSTR bstr2)
{
    return _tcsicmpLoc(STRVAL(bstr1), STRVAL(bstr2));
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsStringNICmp
//
//  Synopsis:   As per wcsnicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsnicmp to _tcsnicmp
//
//----------------------------------------------------------------------------

int
FormsStringNICmp(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsnicmp(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}
int
FormsStringNICmpLoc(LPCTSTR bstr1, int cch1, LPCTSTR bstr2, int cch2)
{
    return _tcsnicmpLoc(STRVAL(bstr1), cch1, STRVAL(bstr2), cch2);
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsStringCmpCase
//
//----------------------------------------------------------------------------

int
FormsStringCmpCase(LPCTSTR bstr1, LPCTSTR bstr2, BOOL fCaseSensitive)
{
    return (fCaseSensitive) ?
        _tcscmp (STRVAL(bstr1), STRVAL(bstr2)) :
        _tcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}
int
FormsStringCmpCaseLoc(LPCTSTR bstr1, LPCTSTR bstr2, BOOL fCaseSensitive)
{
    return (fCaseSensitive) ?
        _tcscmpLoc (STRVAL(bstr1), STRVAL(bstr2)) :
        _tcsicmpLoc(STRVAL(bstr1), STRVAL(bstr2));
}


//+-------------------------------------------------------------------------
// Function:    FormsSplitAtDelimiter
//
// Synopsis:    split a name into its head component (everything before the first
//              dot), and the tail component (the rest).
//
// Arguments:	bstrName    name to be split
//              pbstrHead   where to store head component
//              pbstrTail   where to store the rest
//              fFirst      TRUE - split at first delimiter, FALSE - at last
//              tchDelim    delimiter character (defaults to _T('.'))

void
FormsSplitAtDelimiter(LPCTSTR bstrName, BSTR *pbstrHead, BSTR *pbstrTail,
                            BOOL fFirst, TCHAR tchDelim)
{
    if (FormsIsEmptyString(bstrName))
    {
        *pbstrHead = NULL;
        *pbstrTail = NULL;
    }
    else
    {
        TCHAR *ptchDelim = fFirst ?  _tcschr(bstrName, tchDelim)
                                  : _tcsrchr(bstrName, tchDelim);

        if (ptchDelim)
        {
            FormsAllocStringLen(bstrName, ptchDelim - bstrName, pbstrHead);
            FormsAllocString(ptchDelim + 1, pbstrTail);
        }
        else if (fFirst)
        {
            FormsAllocString(bstrName, pbstrHead);
            *pbstrTail = NULL;
        }
        else
        {
            *pbstrHead = NULL;
            FormsAllocString(bstrName, pbstrTail);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\dvutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       dvutils.cxx
//
//  Contents:   Helper functions for implementing IDataObject and IViewObject
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//
//  Globals
//


// Names used to register the standard clipboard formats
//  Localization: Do not localize
static const char * const s_apstrClipName[] =
{
    "Embedded Object",
    "Embed Source",
    "Link Source",
    "Link Source Descriptor",
    "Object Descriptor",
    "MS Forms CLSID",
    "MS Forms Text",
};
// Array of common registered clip formats used in Forms^3
CLIPFORMAT g_acfCommon[ARRAY_SIZE(s_apstrClipName)];

HRESULT
CloneStgMedium(const STGMEDIUM *    pcstgmedSrc,
               STGMEDIUM *          pstgmedDest)
{
    HRESULT         hr;
    void *          pvDest;
    const void *    pcvSrc;
    DWORD           dwcbLen;
    HGLOBAL         hGlobalDest;

    memset(pstgmedDest, 0, sizeof(*pstgmedDest));

    // We only understand how to clone TYMED_HGLOBAL.
    if (pcstgmedSrc->tymed != TYMED_HGLOBAL)
    {
        hr = DV_E_TYMED;
        goto Cleanup;
    }

    hr = E_OUTOFMEMORY;
    pcvSrc = GlobalLock(pcstgmedSrc->hGlobal);
    if (!pcvSrc)
        goto Cleanup;


    dwcbLen = GlobalSize(pcstgmedSrc->hGlobal);
    if (dwcbLen == 0)
    {
        GlobalUnlock(pcstgmedSrc->hGlobal);
        goto Cleanup;
    }
    
    hGlobalDest = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE), dwcbLen);
    if (!hGlobalDest)
    {
        GlobalUnlock(pcstgmedSrc->hGlobal);
        goto Cleanup;
    }


    pvDest = GlobalLock(hGlobalDest);
    if (!pvDest)
    {
        GlobalFree(hGlobalDest);
        GlobalUnlock(pcstgmedSrc->hGlobal);
        goto Cleanup;
    }

    memcpy(pvDest, pcvSrc, dwcbLen);

    pstgmedDest->tymed = TYMED_HGLOBAL;
    pstgmedDest->hGlobal = hGlobalDest;
    pstgmedDest->pUnkForRelease = pcstgmedSrc->pUnkForRelease;
    if (pstgmedDest->pUnkForRelease)
        (pstgmedDest->pUnkForRelease)->AddRef();

    GlobalUnlock(hGlobalDest);
    GlobalUnlock(pcstgmedSrc->hGlobal);
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


BOOL
DVTARGETDEVICEMatchesRequest(const DVTARGETDEVICE * pcdvtdRequest,
                             const DVTARGETDEVICE * pcdvtdActual)
{
    BOOL bMatch;

    /*
    * A NULL requested PCDVTARGETDEVICE matches any NULL or non-NULL actual
    * PCDVTARGETDEVICE.
    *
    * Any non-NULL requested PCDVTARGETDEVICE matches any NULL actual
    * PCDVTARGETDEVICE.
    *
    * A non-NULL requested PCDVTARGETDEVICE only matches a non-NULL actual
    * PCDVTARGETDEVICE if the actual CDVTARGETDEVICE is an exact binary copy of
    * the requested CDVTARGETDEVICE.
    */

    if (pcdvtdRequest && pcdvtdActual)
        bMatch = (memcmp(pcdvtdRequest, pcdvtdActual,
                         min(pcdvtdRequest->tdSize, pcdvtdActual->tdSize))
                  == 0);
    else
        bMatch = TRUE;

    return(bMatch);
}


BOOL
TYMEDMatchesRequest(TYMED tymedRequest, TYMED tymedActual)
{
    // The actual TYMED matches the requested TYMED if they have any flags set
    // in common.
    return(tymedRequest & tymedActual);
}


BOOL
FORMATETCMatchesRequest(const FORMATETC *   pcfmtetcRequest,
                        const FORMATETC *   pcfmtetcActual)
{
    // Don't check lindex. Strictly speaking, it should be ignored only
    // for DVASPECT_ICON and DVASPECT_THUMBNAIL, but our clients (notably
    // Athena) usually set it to 0 instead of the correct default -1.
    return(pcfmtetcRequest->cfFormat == pcfmtetcActual->cfFormat &&
           DVTARGETDEVICEMatchesRequest(pcfmtetcRequest->ptd,
                                        pcfmtetcActual->ptd) &&
           pcfmtetcRequest->dwAspect == pcfmtetcActual->dwAspect &&
           TYMEDMatchesRequest((TYMED)(pcfmtetcRequest->tymed),
                               (TYMED)(pcfmtetcActual->tymed)));
}


//+---------------------------------------------------------------
//
//  Function:   RegisterClipFormats
//
//  Synopsis:   Initialize g_acfCommon, an array of common
//              registered clip formats used in Forms^3.
//              This array is indexed by the ICF_xxx enumeration.
//
//----------------------------------------------------------------

void
RegisterClipFormats()
{
    // Mac note: clipboard formats need not be registered because we are using
    //          Mac OLE instead of WLM OLE; Mac OLE uses a 4 character ID
    int i;

    for (i = 0; i < ARRAY_SIZE(g_acfCommon); i++)
    {
        g_acfCommon[i] = (CLIPFORMAT)
                RegisterClipboardFormatA(s_apstrClipName[i]);
    }
}

//+---------------------------------------------------------------
//
//  Function:   SetCommonClipFormats
//
//  Synopsis:   Set FORMATETC::cfFormat initialzed by CF_COMMON()
//              macro to the true registered clip format.
//
//  Arguments:  pfmtetc Array of to modify
//              cfmtetc Number of elements in the array
//
//----------------------------------------------------------------

void
SetCommonClipFormats(FORMATETC *pfmtetc, int cfmtetc)
{
    for (; cfmtetc > 0; pfmtetc++, cfmtetc--)
    {
        if (pfmtetc->cfFormat >= CF_PRIVATEFIRST &&
            pfmtetc->cfFormat <= CF_PRIVATELAST)
        {
            Assert(pfmtetc->cfFormat - CF_PRIVATEFIRST < ARRAY_SIZE(g_acfCommon));
            pfmtetc->cfFormat = g_acfCommon[pfmtetc->cfFormat - CF_PRIVATEFIRST];
        }
    }
}

//+---------------------------------------------------------------
//
//  Function:   FindCompatibleFormat
//
//  Synopsis:   Searches a table of FORMATETC structures and
//              returns the index of the first entry that is
//              compatible with a specified FORMATETC.
//
//  Arguments:  [FmtTable] -- the table of FORMATETCs
//              [iSize] -- the number of entries in the format table
//              [formatetc] -- the FORMATETC we are comparing for compatibility
//
//  Returns:    The index into the table of the compatible format, or
//              -1 if no compatible format was found.
//
//  Notes:      This function is typically used in conjunction with
//              IDataObject methods that need to check if a requested format
//              is available.
//
//----------------------------------------------------------------

int
FindCompatibleFormat(const FORMATETC * FmtTable, int iSize, const FORMATETC& formatetc)
{
    // look through the table for a compatible format
    for (int i = 0; i < iSize; i++)
    {
        if (FORMATETCMatchesRequest(&formatetc, &FmtTable[i]))
            return i;
    }
    return -1;
}


//+---------------------------------------------------------------
//
//  Function:   GetObjectDescriptor
//
//  Synopsis:   Extracts an OBJECTDESCRIPTOR from an IDataObject,
//              if available.
//
//  Arguments:  [pDataObj] -- data object from which to extract an object descriptor
//              [pDescOut] -- object descriptor structure to fill in
//
//  Returns:    Success iff the object descriptor could be extracted.
//              This does not copy out the dwFullUserTypeName or
//              dwSrcOfCopy strings.
//
//
//  Attention: most containers (like Excel) do not support GetDataHere
//             therefore we use GetData (frankman, Bug 5889)
//
//----------------------------------------------------------------

HRESULT
GetObjectDescriptor(LPDATAOBJECT pDataObj, LPOBJECTDESCRIPTOR pDescOut)
{
    HRESULT r;
    FORMATETC formatetc =
        { g_acfCommon[ICF_OBJECTDESCRIPTOR],
            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    STGMEDIUM stgmedium;
    stgmedium.tymed = TYMED_HGLOBAL;
    stgmedium.hGlobal = 0;
    stgmedium.pUnkForRelease = NULL;

    if (OK(r = pDataObj->GetData(&formatetc, &stgmedium)))
    {
        if (pDescOut != NULL)
        {
            LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(stgmedium.hGlobal);
            if (pObjDesc == NULL)
            {
                r = E_OUTOFMEMORY;
            }
            else
            {
                // note: in the future we may wish to copy out the strings
                // into two out parameters.  This would be used in
                // implementing the Paste Special dialog box.
                *pDescOut = *pObjDesc;
                pDescOut->dwFullUserTypeName = 0;
                pDescOut->dwSrcOfCopy = 0;
                GlobalUnlock(stgmedium.hGlobal);
            }
        }
    }
    ReleaseStgMedium(&stgmedium);
    RRETURN(r);
}

//+---------------------------------------------------------------
//
//  Function:   UpdateObjectDescriptor
//
//  Synopsis:   Updates the pointl and dwDrawAspects of an OBJECTDESCRIPTOR
//              on a data object
//
//  Arguments:  [pDataObj] -- the data object to update
//              [ptl] -- the pointl to update in the object descriptor
//              [dwAspect] -- the draw aspect to update in the object descriptor
//
//  Returns:    Success iff the object descriptor could be updated
//
//  Notes:      This method is for IDataObjects used in drag-drop.
//              The object being dragged supplies the object descriptor but only
//              the container knows where the point that the mouse button went
//              down relative to the corner of the object, and what aspect
//              of the object the container is displaying.
//              The container uses this method to fill in that missing information.
//              This performs a GetDataHere on the object to get a filled-in
//              object descriptor.  It then updates the pointl and dwDrawAspect
//              fields and uses SetData to update the object.
//
//----------------------------------------------------------------

HRESULT
UpdateObjectDescriptor(LPDATAOBJECT pDataObj, POINTL& ptl, DWORD dwAspect)
{
    HRESULT r;
    FORMATETC formatetc =
        { g_acfCommon[ICF_OBJECTDESCRIPTOR],
            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    STGMEDIUM stgmedium;
    stgmedium.tymed = TYMED_HGLOBAL;
    stgmedium.hGlobal = 0;
    stgmedium.pUnkForRelease = NULL;
    if (OK(r = pDataObj->GetData(&formatetc, &stgmedium)))
    {
        LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(stgmedium.hGlobal);
        if (pObjDesc == NULL)
        {
            r = E_OUTOFMEMORY;
        }
        else
        {
            pObjDesc->pointl = ptl;
            pObjDesc->dwDrawAspect = dwAspect;
            r = pDataObj->SetData(&formatetc, &stgmedium, FALSE);
            GlobalUnlock(stgmedium.hGlobal);
        }
    }

    ReleaseStgMedium(&stgmedium);
    RRETURN(r);
}



//+-------------------------------------------------------------------------
//
//  Member:     FormSetClipboard(IDataObject *pdo)
//
//  Synopsis:   helper function to set the clipboard contents
//
//--------------------------------------------------------------------------
HRESULT
FormSetClipboard(IDataObject *pdo)
{
    HRESULT hr;
    hr = OleSetClipboard(pdo);
    
    if (!hr && !GetPrimaryObjectCount())
    {
        hr = THR(OleFlushClipboard());
    }
    else
    {
        ReplaceInterface(&TLS(pDataClip), pdo);
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Member:     FormClearClipboard(THREADSTATE * pts)
//
//  Synopsis:   Clear clipboard during shutdown
//
//--------------------------------------------------------------------------
HRESULT
FormClearClipboard(THREADSTATE * pts)
{
    if (pts->pDataClip)
    {
        if (!OleIsCurrentClipboard(pts->pDataClip))
        {
            WHEN_DBG(HRESULT hr =) THR(OleFlushClipboard());
            #if DBG==1
            if (hr)
            {
                 Assert(!pts->pDataClip && "Clipboard data should be flushed now");
            }
            #endif
        }

        ClearInterface(&pts->pDataClip);
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\errinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       errinfo.cxx
//
//  Contents:   CErrorInfo
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

const CLSID CLSID_CErrorInfo = { 0x44102920, 0xD5AA, 0x11ce, 0xB6, 0x56, 0x00, 0xAA, 0x00, 0x4C, 0xD6, 0xD8 };

extern HRESULT GetSolutionText(HRESULT hrError, LPTSTR pstr, int cch);

MtDefine(CErrorInfo, ObjectModel, "CErrorInfo")

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::CErrorInfo
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------

CErrorInfo::CErrorInfo()
{
    _ulRefs = 1;
    IncrementSecondaryObjectCount( 2 );
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::~CErrorInfo
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CErrorInfo::~CErrorInfo()
{
    int c;
    TCHAR **ppch;

    for (ppch = _apch, c = EPART_LAST; c > 0; ppch++, c--)
    {
        delete *ppch;
    }

    DecrementSecondaryObjectCount( 2 );
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::QueryInterface, IUnknown
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IErrorInfo ||
        iid == IID_IUnknown)
    {
        *ppv = (IErrorInfo *)this;
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else if (iid == CLSID_CErrorInfo)
    {
        *ppv = this;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::SetTextV/SetText
//
//  Synopsis:   Set text of error description.
//
//  Arguments:  epart   Part of error message, taken from EPART enum.
//              ids     String id of format string.
//              pvArgs  Arguments
//
//----------------------------------------------------------------------------

void
CErrorInfo::SetTextV(EPART epart, UINT ids, void *pvArgs)
{
    if (_apch[epart])
    {
        delete _apch[epart];
        _apch[epart] = NULL;
    }

    IGNORE_HR(VFormat(
            FMT_OUT_ALLOC, 
            &_apch[epart], 
            0, 
            MAKEINTRESOURCE(ids),
            pvArgs));
}

void __cdecl
CErrorInfo::SetText(EPART epart, UINT ids, ...)
{
    va_list arg;

    va_start(arg, ids);
    SetTextV(epart, ids, &arg);
    va_end(arg);    
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetGUID, IErrorInfo
//
//  Synopsis:   Return iid of interface defining error code.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetGUID(GUID *pguid)
{
    // Assume OS defined errors only.
    *pguid = g_Zero.clsid;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetSource, IErrorInfo
//
//  Synopsis:   Get progid of error source.
//
//----------------------------------------------------------------------------

extern "C" CLSID CLSID_CCDControl;

HRESULT
CErrorInfo::GetSource(BSTR *pbstrSource)
{
    HRESULT hr; 
    OLECHAR * pstrProgID = NULL;

    *pbstrSource = 0;
    if (_clsidSource == g_Zero.clsid)
        RRETURN(E_FAIL);

    hr = THR(ProgIDFromCLSID(_clsidSource, &pstrProgID));
    if (hr)
        goto Cleanup;

    hr = THR(FormsAllocString(pstrProgID, pbstrSource));

Cleanup:

    CoTaskMemFree(pstrProgID);
    RRETURN(hr);
}
        
//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetHelpFile, IErrorInfo
//
//  Synopsis:   Get help file describing error.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetHelpFile(BSTR *pbstrHelpFile)
{
    RRETURN(THR(FormsAllocString(GetFormsHelpFile(), pbstrHelpFile)));
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetHelpContext, IErrorInfo
//
//  Synopsis:   Get help context describing error.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetHelpContext(DWORD *pdwHelpContext)
{
    *pdwHelpContext = _dwHelpContext;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetDescription, IErrorInfo
//
//  Synopsis:   Get description of the error.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetDescription(BSTR *pbstrDescription)
{
    HRESULT hr;
    BSTR    bstrSolution = NULL;
    BSTR    bstrDescription = NULL;

    hr = THR(GetDescriptionEx(&bstrDescription, &bstrSolution));
    if (hr)
        goto Cleanup;

    if (bstrDescription && bstrSolution)
    {
        hr = THR(FormsAllocStringLen(
                (LPCTSTR)NULL, 
                FormsStringLen(bstrDescription) + 2 + FormsStringLen(bstrSolution),
                pbstrDescription));
        if (hr)
            goto Cleanup;

        _tcscpy(*pbstrDescription, bstrDescription);
        _tcscat(*pbstrDescription, TEXT("  "));         //  Review: FE grammar?
        _tcscat(*pbstrDescription, bstrSolution);
    }
    else
    {
        *pbstrDescription = bstrDescription;
        bstrDescription = NULL;
    }

Cleanup:
    FormsFreeString(bstrDescription);
    FormsFreeString(bstrSolution);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetMemberName
//
//  Synopsis:   Get name of member _dispidInvoke in interface _iidInvoke.
//
//----------------------------------------------------------------------------

HRESULT
CErrorInfo::GetMemberName(BSTR *pbstrName)
{
    HRESULT hr;
    ITypeInfo *pTI = NULL;

    hr = THR(LoadF3TypeInfo(_iidInvoke, &pTI));
    if (hr)
        goto Cleanup;

    hr = THR(pTI->GetDocumentation(_dispidInvoke, pbstrName, NULL, NULL, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pTI);
    RRETURN(hr);
   
}

//+---------------------------------------------------------------------------
//
//  Method:     CErrorInfo::GetDescriptionEx, IErrorInfo2
//
//  Synopsis:   
//
//  Arguments:  
//
//----------------------------------------------------------------------------

HRESULT 
CErrorInfo::GetDescriptionEx(
    BSTR *pbstrDescription,
    BSTR *pbstrSolution)
{
    HRESULT hr = S_OK;
    TCHAR   achBufAction[FORMS_BUFLEN];
    TCHAR   achBufError[FORMS_BUFLEN];
    TCHAR   achBufSolution[FORMS_BUFLEN];
    TCHAR * pchAction;
    TCHAR * pchError;
    TCHAR * pchSolution;
    BSTR    bstrMemberName = NULL;

    *pbstrDescription = NULL;
    *pbstrSolution = NULL;

    if (_apch[EPART_ACTION])
    {
        pchAction = _apch[EPART_ACTION];
    }
    else if (_invkind == INVOKE_PROPERTYPUT &&
            _hr == E_INVALIDARG)
    {
        pchAction = NULL;
    }
    else if (_invkind)
    {
        hr = THR(GetMemberName(&bstrMemberName));
        if (hr)
            goto Error;

        hr = THR(Format(
                0, 
                achBufAction, 
                ARRAY_SIZE(achBufAction),
                _invkind == INVOKE_PROPERTYPUT ? 
                    MAKEINTRESOURCE(IDS_EA_SETTING_PROPERTY) :
                (_invkind == INVOKE_PROPERTYGET ? 
                    MAKEINTRESOURCE(IDS_EA_GETTING_PROPERTY) :
                    MAKEINTRESOURCE(IDS_EA_CALLING_METHOD)),
                bstrMemberName));
        if (hr)
            goto Error;
        
        pchAction = achBufAction;
    }
    else
    {
        pchAction = NULL;
    }

    if (_apch[EPART_ERROR])
    {
        pchError = _apch[EPART_ERROR];
    }
    else if (_invkind == INVOKE_PROPERTYPUT && 
            _hr == E_INVALIDARG)
    {
        hr = THR(GetMemberName(&bstrMemberName));
        if (hr)
            goto Error;

        hr = THR(Format(
                0, 
                achBufError, 
                ARRAY_SIZE(achBufError),
                MAKEINTRESOURCE(IDS_EE_INVALID_PROPERTY_VALUE),
                bstrMemberName));
        if (hr)
            goto Error;

        pchError = achBufError;
    }
    else
    {
        hr = THR(GetErrorText(_hr, achBufError, ARRAY_SIZE(achBufError)));
        if (hr)
            goto Error;

        pchError = achBufError;
    }

    if (pchAction)
    {
        hr = FormsAllocStringLen(
                pchAction,
                _tcslen(pchAction) + _tcslen(pchError) + 2,
                pbstrDescription);
        if (!*pbstrDescription)
            goto MemoryError;
        _tcscat(*pbstrDescription, TEXT(" "));
        _tcscat(*pbstrDescription, pchError);
    }
    else
    {
        hr = FormsAllocString(pchError,pbstrDescription);
        if (!*pbstrDescription)
            goto MemoryError;
    }

    if (_apch[EPART_SOLUTION])
    {
        pchSolution = _apch[EPART_SOLUTION];
    }
    else
    {
        hr = THR(GetSolutionText(_hr, achBufSolution, ARRAY_SIZE(achBufSolution)));
        if (hr)
            goto Error;

        pchSolution = achBufSolution[0] ? achBufSolution : NULL;
    }

    hr = THR(FormsAllocString(pchSolution, pbstrSolution));
    if (hr)
        goto Error;

Cleanup:
    SysFreeString(bstrMemberName);
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    SysFreeString(*pbstrDescription);
    SysFreeString(*pbstrSolution);
    *pbstrDescription = NULL;
    *pbstrSolution = NULL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorInfo
//
//----------------------------------------------------------------------------

CErrorInfo * 
GetErrorInfo()
{
    THREADSTATE *   pts = GetThreadState();

    if (!pts->pEI)
    {
        pts->pEI = new CErrorInfo;
    }

    return pts->pEI;
}

//+---------------------------------------------------------------------------
//
//  Function:   ClearErrorInfo
//
//----------------------------------------------------------------------------

void         
ClearErrorInfo(
    THREADSTATE *   pts)
{
    if (!pts)
        pts = GetThreadState();
    ClearInterface(&(pts->pEI));
}


//+---------------------------------------------------------------------------
//
//  Function:   CloseErrorInfo
//
//----------------------------------------------------------------------------

void
CloseErrorInfo(HRESULT hr, REFCLSID clsidSource)
{
    IErrorInfo *    pErrorInfo;

    Assert(FAILED(hr));
  
    if (GetErrorInfo() == NULL)
    {
        // There's an error, but we couldn't allocate
        // an error info object.  Release the global error
        // object so that our caller's caller will
        // not be confused.

        hr = GetErrorInfo(0, &pErrorInfo);
        if (!hr)
        {
            ReleaseInterface(pErrorInfo);
        }
    }
    else
    {
        THREADSTATE *   pts = GetThreadState();
        pts->pEI->_hr = hr;
        pts->pEI->_clsidSource = clsidSource;
        SetErrorInfo(NULL, pts->pEI);

        ClearInterface(&(pts->pEI));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PutErrorInfoText
//
//----------------------------------------------------------------------------

void
__cdecl PutErrorInfoText(EPART epart, UINT ids, ...)
{
    va_list arg;

    if (GetErrorInfo() != NULL)
    {
        va_start(arg, ids);
        TLS(pEI)->SetTextV(epart, ids, &arg);
        va_end(arg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\file.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       file.cxx
//
//  Contents:   Import/export dialog helpers
//
//  History:    16-May-95   RobBear     Taken from formtool
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

CGlobalCriticalSection  g_csFile;
TCHAR                   g_achSavePath[MAX_PATH];

static HRESULT  SwitchToDirectory(LPTSTR lpwsz);

//+---------------------------------------------------------------------------
//
//  Function:   SwitchToDirectory
//
//  Synopsis:   Switches the current directory to that of the file.
//
//  Arguments:  [lptsz] -- The file whose directory we want to switch to.
//
//  Returns:    HRESULT.
//
//  History:    7-22-94   adams   Created
//
//----------------------------------------------------------------------------

static HRESULT
SwitchToDirectory(LPTSTR pstrFilePath)
{
    BOOL    fOK;
    TCHAR   path[_MAX_PATH];
    TCHAR * pch;

    _tcscpy(path, pstrFilePath);

    pch = _tcsrchr(path, _T(FILENAME_SEPARATOR));

    if (pch)
        *(pch + 1)= 0;

    fOK = SetCurrentDirectory(path);
    if (!fOK)
       RRETURN(GetLastWin32Error());

    return S_OK;
}


#ifndef NO_IME

#ifndef X_INTLCORE_HXX_
#define X_INTLCORE_HXX_
#include <intlcore.hxx>
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

// Hook procedure for open file dialog.
UINT_PTR APIENTRY SaveOFNHookProc(HWND hdlg,
                              UINT uiMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    ULONG i, iCurSel;

    switch (uiMsg)
    {
        // Populate the dropdown.
        case WM_INITDIALOG:
        {
            LPOPENFILENAME pofn = (LPOPENFILENAME)lParam;
            IEnumCodePage * pEnumCodePage = NULL;
            CODEPAGE        codepageDefault = *(CODEPAGE *)pofn->lCustData;
            
            if (mlang().EnumCodePages(MIMECONTF_SAVABLE_BROWSER | MIMECONTF_VALID, &pEnumCodePage) == S_OK)
            {
                MIMECPINFO cpInfo;
                ULONG      ccpInfo;

                ZeroMemory(&cpInfo, sizeof(MIMECPINFO));

                if (   (mlang().GetCodePageInfo(codepageDefault, MLGetUILanguage(), &cpInfo) == S_OK) 
                    && !(cpInfo.dwFlags & MIMECONTF_SAVABLE_BROWSER))
                {
                    // If the codepage selected is not savable (eg JP_AUTO),
                    // use the family codepage.
                    codepageDefault = cpInfo.uiFamilyCodePage;
                }
                    
                // Can't have 4 billion languages.
                iCurSel = 0xffffffff;

                for (i = 0; pEnumCodePage->Next(1, &cpInfo, &ccpInfo) == S_OK; ++i)
                {
                    if (codepageDefault == cpInfo.uiCodePage)
                    {
                        iCurSel = i;
                    }

                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET_MSHTML,
                                       CB_ADDSTRING, 0,
                                       (LPARAM)cpInfo.wszDescription);
                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET_MSHTML,
                                       CB_SETITEMDATA, i,
                                       (LPARAM)cpInfo.uiCodePage);
                }
                if (iCurSel != 0xffffffff)
                    SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET_MSHTML, CB_SETCURSEL,
                                        (WPARAM)iCurSel, (LPARAM)0);
            }
            ReleaseInterface(pEnumCodePage);
            break;
        }

        case WM_NOTIFY:
        {
            LPOFNOTIFY phdr = (LPOFNOTIFY)lParam;
            if (phdr->hdr.code == CDN_FILEOK)
            {
                iCurSel = SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET_MSHTML, CB_GETCURSEL, 0, 0);
                *(CODEPAGE *)phdr->lpOFN->lCustData =
                    SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET_MSHTML, CB_GETITEMDATA,
                                         (WPARAM)iCurSel, (LPARAM)0);
            }
            break;
        }
    }
    return (FALSE);
}

#endif //!NO_IME


//+---------------------------------------------------------------------------
//
//  Function:   FormsGetFileName
//
//  Synopsis:   Gets a file name using either the GetOpenFileName or
//              GetSaveFileName functions.
//
//  Arguments:  [fSaveFile]   -- TRUE means use GetSaveFileName
//                               FALSE means use GetOpenFileName
//
//              [idFilterRes] -- The string resource specifying text in the
//                                  dialog box.  It must have the
//                                  following format:
//                            Note: the string has to be _one_ contiguous string.
//                                  The example is broken up to make it fit
//                                  on-screen. The verical bar ("pipe") characters
//                                  are changed to '\0'-s on the fly.
//                                  This allows the strings to be localized
//                                  using Espresso.
//
//          IDS_FILENAMERESOURCE, "Save Dialog As|         // the title
//                                 odg|                    // default extension
//                                 Forms3 Dialog (*.odg)|  // pairs of filter strings
//                                 *.odg|
//                                 Any File (*.*)|
//                                 *.*|"
//
//              [pstrFile]    -- Buffer for file name.
//              [cchFile]     -- Size of buffer in characters.
//
//  Modifies:   [pstrFile]
//
//----------------------------------------------------------------------------
#ifdef _MAC
extern "C" {
char * __cdecl _p2cstr(unsigned char *);
}
#endif

HRESULT
FormsGetFileName(
        BOOL fSaveFile,
        HWND hwndOwner,
        int idFilterRes,
        LPTSTR pstrFile,
        int cchFile,
        LPARAM lCustData,
        DWORD *pnFilterIndex)
{
    HRESULT         hr  = S_OK;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    LPTSTR          pstr;
    OPENFILENAME    ofn;
    TCHAR           achBuffer[4096];    //  Max. size of a string resource
    TCHAR *         cp;
    TCHAR *         pstrExt;
    int             cbBuffer;
    TCHAR           achInitialDir[MAX_PATH + 1];
    TCHAR *         pstrEndOfDir;
    TCHAR *         pstrEndOfPath = achInitialDir;

    // Check to make sure that we have a buffer and that it's NULL terminated
    Assert(pstrFile);
    pstrFile[cchFile - 1] = 0;

    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndOwner;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = pstrFile;
    ofn.nMaxFile        = cchFile;
    ofn.lCustData       = lCustData;

#ifndef UNIX
#ifndef NO_IME
    // We add an extra control to the save file dialog.
    if (fSaveFile && lCustData)
    {
        ofn.Flags |= OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
        ofn.lpfnHook = SaveOFNHookProc;
        ofn.lpTemplateName = L"IDD_ADDTOSAVE_DIALOG_MSHTML";
        ofn.hInstance = GetResourceHInst();
    }
#endif
#endif // UNIX

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = pstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt >= pstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }
    if( pstrExt < pstrFile )
        pstrExt = NULL;

    // Load the filter spec.

    cbBuffer = ::LoadString(GetResourceHInst(),idFilterRes,achBuffer,ARRAY_SIZE(achBuffer));
    Assert(cbBuffer > 0);
    if ( ! cbBuffer )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ofn.lpstrTitle = achBuffer;

    for ( cp = achBuffer; *cp; cp++ )
    {
        if ( *cp == _T('|') )
        {
            *cp = _T('\0');
        }
    }

    Assert(ofn.lpstrTitle != NULL);

    // Default extension is second string.
    pstr = (LPTSTR) ofn.lpstrTitle;
    while (*pstr++)
    {
    }

    // N.B. (johnv) Here we assume that filter index one corresponds with the default
    //  extension, otherwise we would have to introduce a default filter index into
    //  the resource string.
    ofn.nFilterIndex    = ((pnFilterIndex)? *pnFilterIndex : 1);
    ofn.lpstrDefExt     = pstr;

    // Filter is third string.
    while(*pstr++)
    {
    }

    ofn.lpstrFilter = pstr;
    
    // Try to match the extension with an entry in the filter list
    // If we match, remove the extension from the incoming path string,
    //   set the default extension to the one we found, and appropriately
    //   set the filter index.

    if( pstrExt )
    {
        // N.B. (johnv) We are searching more than we need to.

        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

#ifndef UNIX // We need this extension for UNIX
                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');
#endif /* UNIX */

                break;
            }
            pSearch += _tcslen(pSearch);
            if( pSearch[1] == 0 )
            {
                ofn.lpstrDefExt  = NULL;
                break;
            }

            pSearch++;
            iIndex++;
        }
    }
       
    //
    // Figure out the initial directory from the given filename.
    // If an initial directory cannot be determined, then use the
    // saved directroy.
    // If an initial directory can be determined, then it will override
    // the saved directory.
    //

    // Copy the contentx of pstrFile into achInitialDir, but check the bounds.
    _tcsncpy(achInitialDir, pstrFile, MAX_PATH);
    achInitialDir[MAX_PATH] = 0;

    // Find the end of the filename
    while (*pstrEndOfPath)
    {
        pstrEndOfPath++;
    }
    pstrEndOfDir = pstrEndOfPath;

    // Move back until a backslash or colon is found
    while ((*pstrEndOfDir != _T('\\')) && (*pstrEndOfDir != _T(':')))
    {
        pstrEndOfDir--;
        if (pstrEndOfDir < achInitialDir)
        {
            // We're beyond the beginning, so bail out
            break;
        }
    }

    if (pstrEndOfDir >= achInitialDir)
    {
        TCHAR * pstrBeforeEnd = NULL;

        // A backslash or colon was found.
        if ((pstrEndOfDir - achInitialDir) > 0)
        {
            pstrBeforeEnd = pstrEndOfDir - 1;

            // Check for the \\ case
            if (*pstrBeforeEnd == _T('\\'))
            {
                // Move back to the end
                pstrEndOfDir = pstrEndOfPath;
            }
        }

        // Copy just the filename (without the directory)
        // into the filename buffer, but only if there
        // is a filename.
        if (pstrEndOfDir != pstrEndOfPath)
        {
            _tcscpy(pstrFile, pstrEndOfDir + 1);
        }
        else
        {
            *pstrFile = _T('\0');
        }

        // Separate the directory from the filename.
        if ((*pstrEndOfDir == _T(':')) ||
            (pstrBeforeEnd && (*pstrBeforeEnd == _T(':'))))
        {
            // We need to keep colons and we need to keep
            // the backslash in the c:\ case
            if (pstrEndOfDir != pstrEndOfPath)
            {
                *(pstrEndOfDir + 1) = _T('\0');
            }
        }
        else
        {
            *pstrEndOfDir = _T('\0');
        }
    }
    else
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(achInitialDir, g_achSavePath);
    }

    ofn.lpstrInitialDir = *achInitialDir ? achInitialDir : NULL;

    //
    // TODO -- The following call hides memory leaks in GetOpenFileName
    //

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (fOK)
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName = _tcsrchr(g_achSavePath, _T(FILENAME_SEPARATOR));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }

        if (pnFilterIndex)
            *pnFilterIndex = ofn.nFilterIndex;
    }
    else
    {
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
        }
        else
        {
            hr = S_FALSE;
        }
#else // WINCE
		hr = E_FAIL;
#endif // WINCE
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\format.cxx ===
//+------------------------------------------------------------------------
//
//  File:       format.cxx
//
//  Contents:   Formatting Swiss Army Knife
//
//  History:    20-Oct-94   GaryBu  Created from Sterling & Ren
//              5-22-95     kfl     converted WCHAR to TCHAR
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef UNIX
#ifndef X_MAINWIN_H_
#define X_MAINWIN_H_
#include "mainwin.h"
#endif
#endif

MtDefine(OutputStream_pch, Utilities, "Format OutputStream::_pch")

//
//  CONSIDER:  This file does not include support for simulated
//    failures.  It includes methods that can fail, but are called
//    once for each character in the output string--which would
//    produce an unwieldy number of failure points.
//
//    Should this be changed?
//

//+------------------------------------------------------------------------
//  Format and VFormat
//
//  Format and VFormat are similiar to the sprintf family.
//  Format fixes two problems exhibited by sprintf.  First, the
//  order of argument substitution in sprintf is specified by
//  function caller. To support localization, the order of argument
//  substitution should be specified in the format string.  Second,
//  the range of formatting options are limited and cannot be
//  extended.
//
//  A format string consists of characters to be copied to the
//  output string and argument substitutions.  Arguments can be
//  referenced more than once.  This allows for very nice handling
//  of plurals.  For example: "There <0p/are/is/> <0d> toaster<0p//s/>
//  flying across my screen."
//
//  BiDi consideration: Arabic has a "dual" case between singular
//                      and plural (separate conjugation for a pair
//                      of things). We should find out if that poses
//                      a problem for Format.
//
//  FORMAT SPECIFIERS
//
//   "<" arg format options ">"
//
//      arg     - A single digit specifying the argument number.
//      handler - A single character specifying argument
//                type and display format.
//      options - Formatting options specific to format type.
//
//  NOTES
//
//      Two '<' characters in a row will print out as one '<'
//      character and does not mark the beginning of a format
//      specification.  Ex.: "The symbol << means less than."
//
//
//  FORMATS
//
//  d   Format long as decimal.
//      Options:
//          u       Argument is unsigned.
//          <digit> Field width.
//
//  s   Format zero terminated TCHAR *.
//      Options:
//          <none>
//
//  p   Format long as plural.
//      Options:
//          delimiter singular delimiter plural delimiter.
//      Example:
//          "There <0p/is/are/> <0d> toaster<0p//s/> flying across my screen"
//
//  i   Format resource string. First argugment is HINSTANCE, second
//      argument is string id.
//      Options:
//          <none>
//
//  g   Format GUID.
//      Options:
//          <none>
//
//  x   Format long as 8 character hex.
//      Options:
//          <none>
//
//  c   Format long as 6 character lowercase hex.  Option is for color.
//      Options:
//          <none>
//
//  C   Format long as 3 character lowercase hex.  Option is for color.
//      Options:
//          <none>
//
//  CALLING SEQUENCE
//
//      HRESULT VFormat(DWORD dwOptions,
//          void *pvOutput, int cchOutput,
//          TCHAR *pchFmt,
//          void *pvArgs);
//
//      HRESULT Format(DWORD dwOptions,
//          void *pvOutput, int cchOutput,
//          TCHAR *pchFmt,
//          ...);
//
//          dwOptions
//              Flags taken from the FMT_OPTIONS enumeration.
//
//              FMT_OUT_ALLOC
//                  Specifies that the pvOutput parameter is a pointer
//                  to a TCHAR*, and that the cchOutput parameter specifies
//                  the minimum number of characters to allocate for an
//                  output message buffer. The function allocates a buffer
//                  large enough to hold the formatted message, and
//                  places a pointer to the allocated buffer at the address
//                  specified by pvOutput. The caller should use the
//                  delete [] operator to free the buffer when it is no
//                  longer needed.
//
//              FMT_ARG_ARRAY
//                  Specifies that the pvArg parameter is NOT a va_list
//                  structure, but instead is just a pointer to an array
//                  of 32-bit values that represent the arguments.
//
//              FMT_EXTRA_NULL_MASK
//                  Add (dwOptions & FMT_EXTRA_NULL_MASK) null terminators to
//                  the end of the string.  This is useful for parsing
//                  multi-part strings where each part is separated
//                  by a null character.
//
//          pvOutput
//              Points to a buffer for the formatted (and null-terminated)
//              string. If dwOptions includes FMT_OUT_ALLOC, the function
//              allocates a buffer via operator new, and places the
//              address of the buffer at the address specified in pvOutput.
//
//          cchOutput
//              If the FMT_OUT_ALLOC flag is not set, this parameter
//              specifies the maximum number of characters that can be
//              stored in the output buffer. If the FMT_OUT_ALLOC flag is
//              set, this parameter specifies the minimum number of
//              characters to allocate for an output buffer.
//
//          pchFmt
//              Specifies the format string. Use MAKEINTRESOURCE(ids) to
//              specify the id of a string resource.
//
//          pvArgs
//              Pointe to 32-bit values thare are used as insert values
//              in the formatted string. By default this parameter is of
//              type va_list *.  If FMT_ARG_ARRAY is set, then pvArgs
//              is a pointer to an array of 32-bit values.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Function:   LoadString
//
//  Synopsis:   Get pointer to string resource. The returned
//              pointer does not need to be freed and is not
//              null terminated.
//
//  Arguments:  [hinst] - load from this module.
//              [ids] - string id.
//              [pcch] - number of characters in string.
//              [ppsz] - the string
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
LoadString(HINSTANCE hinst, UINT ids, int *pcch, TCHAR **ppsz)
{
    BYTE *  pb;
    int     i;

    pb = (BYTE *)GetResource(hinst, MAKEINTRESOURCE(((ids / 16) + 1)), RT_STRING, NULL);

#ifndef _MAC
    if (pb)
    {
        for (i = ids & 0xF; --i >= 0; )
        {
            pb += *(WORD *)pb * sizeof(TCHAR) + sizeof(TCHAR);
        }

        *pcch = *(WORD *)pb;
        *ppsz = (TCHAR *)(pb + sizeof(TCHAR));
    }
    else
    {
        *pcch = 0;
        *ppsz = NULL;
    }
#else
    // count of the STRs in this STR#
    pb += sizeof(WORD);

    for (i = ids & 0xF; --i >= 0; )
    {
#ifdef _MAC
        pb += *(BYTE *)pb * sizeof(BYTE) + sizeof(BYTE);
#else
        pb += *(BYTE *)pb * sizeof(OLECHAR) + sizeof(BYTE);
#endif
    }

    *pcch = *(BYTE *)pb;
    *ppsz = MacConvertPStrToWSTR(pb);
#endif
    return *pcch != 0 ? S_OK : E_FAIL;
}


//+------------------------------------------------------------------------
//
//  Class:      OutputStream
//
//  Synopsis:   Abstracts writing to allocated buffer or fixed buffer.
//
//-------------------------------------------------------------------------

#define CCH_OUT_GROW 128
class OutputStream // tag: Output
{
private:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))
public:
    HRESULT Init(BOOL fFixed, void *pvOutput, int cchOutput);
    HRESULT Put(TCHAR ch);
    HRESULT Put(TCHAR *sz);
    void    Nuke();
private:
    int     _cch;
    int     _cchAlloc;
    BOOL    _fAlloc;
    TCHAR * _pch;
    union {
        TCHAR **_ppchAlloc;
        TCHAR *_pchBase;
    };
};

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Init
//
//  Synopsis:   Initialize the output stream.
//
//  Arguments:  fAlloc - true if should allocate output buffer.
//              pvOutput - if fAlloc then place to store output buffer pointer,
//                  else pointer to acutal buffer.
//              cchOutput - if fAlloc then minimum allocation size
//                  else size of outpu buffer.
//
//-------------------------------------------------------------------------
HRESULT
OutputStream::Init(BOOL fAlloc, void *pvOutput, int cchOutput)
{
    HRESULT hr = NOERROR;

    _fAlloc = fAlloc;
    if (fAlloc)
    {
        if (cchOutput <= 0)
            cchOutput = CCH_OUT_GROW;
        _ppchAlloc = (TCHAR **)pvOutput;
        _pch = *_ppchAlloc = (TCHAR *)MemAlloc(Mt(OutputStream_pch), sizeof(TCHAR)*cchOutput);
        if (_pch)
            _cch = _cchAlloc = cchOutput;
        else
        {
            _cch = 0;
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        _cch = cchOutput;
        _pch = _pchBase = (TCHAR *)pvOutput;
        _pch[_cch-1] = 0;
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Put
//
//  Synopsis:   Put a character on the output stream.
//
//-------------------------------------------------------------------------
HRESULT
OutputStream::Put(TCHAR ch)
{
    if (--_cch >= 0)
    {
        *_pch++ = ch;
    }
    else if (!_fAlloc)
    {
        Assert(0 && "Format: pvOutput too small.");
        return E_FAIL;
    }
    else
    {
        TCHAR *pch = *_ppchAlloc;
        *_ppchAlloc = (TCHAR *)MemAlloc(Mt(OutputStream_pch), sizeof(TCHAR)*(_cchAlloc + CCH_OUT_GROW));
        if (!*_ppchAlloc)
        {
            MemFree(pch);
            _cch = 0;
            return E_OUTOFMEMORY;
        }
        else
        {
            memcpy(*_ppchAlloc, pch, _cchAlloc * sizeof(TCHAR));
            MemFree(pch);
            _pch = *_ppchAlloc + _cchAlloc;
            _cchAlloc += CCH_OUT_GROW;
            _cch = CCH_OUT_GROW - 1;
            *_pch++ = ch;
        }
    }
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Put
//
//  Synopsis:   Put a string on the output stream.
//
//-------------------------------------------------------------------------
HRESULT
OutputStream::Put(TCHAR *sz)
{
    HRESULT hr = NOERROR;
    while (hr == NOERROR && *sz)
        hr = Put(*sz++);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     OutputStream::Nuke
//
//  Synopsis:   Nuke the output stream. Called in case of error.
//
//-------------------------------------------------------------------------
void
OutputStream::Nuke()
{
    if (!_fAlloc)
        *_pchBase = 0;
    else if (*_ppchAlloc)
    {
        MemFree(*_ppchAlloc);
        *_ppchAlloc = 0;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   FormatDecimal
//
//  Synopsis:   Format adwArg[0] as decimal to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatDecimal(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    BOOL    fUnsigned = FALSE;
    TCHAR   szBuf[33];
    int     cWidth = 0;
    int     i;

    if (**ppchFmt == TEXT('u'))
    {
        fUnsigned = TRUE;
        *ppchFmt += 1;
    }
    if ( InRange( **ppchFmt, _T('0'), _T('9') ) )
    {
        cWidth = **ppchFmt - _T('0');
        *ppchFmt += 1;
    }
    
	// WINCETODO - these cruntime func don't seem to work on CE!
#ifdef WINCE
	{
		char	szFix[40];

		if (fUnsigned)
		{
			_ultoa(adwArg[0], szFix, 10);
		}
		else
		{
			_ltoa(adwArg[0], szFix, 10);
		}
		MultiByteToWideChar(CP_ACP, 0, szFix, -1, szBuf, 33);
	}
#else
    if (fUnsigned)
    {
        _ultot(adwArg[0], szBuf, 10);
    }
    else
    {
        _ltot(adwArg[0], szBuf, 10);
    }
#endif

    if (cWidth > 0)
    {
        for (i = cWidth - _tcslen(szBuf); --i >= 0;)
        {
            pOutput->Put(_T("0"));
        }
    }

    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatHex
//
//  Synopsis:   Format adwArg[0] as hex to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatHex(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR   szBuf[33];
    int     i;

    _ultot(adwArg[0], szBuf, 16);
    for (i = 8 - _tcsclen(szBuf); i > 0; i--)
        pOutput->Put(_T('0'));
    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatColor
//
//  Synopsis:   Format adwArg[0] as a 6-digit hex to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatColor(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR   szBuf[33];
    long    lRGB = (long)adwArg[0];
    long    lBGR = ((lRGB & 0xffL) << 16) |
                   (lRGB & 0xff00L) |
                   ((lRGB & 0xff0000L) >> 16);

    pOutput->Put(_T('#'));
    _ultot(lBGR, szBuf, 16);
#ifndef _MAC
    CharLower(szBuf);
#endif
    for (int i = 6 - _tcsclen(szBuf); i > 0; i--)
        pOutput->Put(_T('0'));
    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatPound3
//
//  Synopsis:   Format adwArg[0] as a 3-digit hex to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static
HRESULT FormatPound3(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR   szBuf[33];
    long    lRGB = (long)adwArg[0];
    long    lBGR = ((lRGB&0xf) << 8) | ((lRGB&0xf00) >> 4) | ((lRGB&0xf0000) >> 16);

    pOutput->Put(_T('#'));
    _ultot(lBGR, szBuf, 16);
#ifndef _MAC
    CharLower(szBuf);
#endif
    for (int i = 3 - _tcsclen(szBuf); i > 0; i--)
    {
        pOutput->Put(_T('0'));
    }
    return pOutput->Put(szBuf);
}


//+------------------------------------------------------------------------
//
//  Function:   FormatString
//
//  Synopsis:   Format adwArg[0] as string ptr to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatString(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    return pOutput->Put((TCHAR *)adwArg[0]);
}


//+------------------------------------------------------------------------
//
//  Function:   FormatGuid
//
//  Synopsis:   Format adwArg[0] as guid ptr to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatGuid(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    TCHAR szBuf[40];
    Verify(StringFromGUID2(*(CLSID *)adwArg[0], szBuf,
            ARRAY_SIZE(szBuf))>0);
    return pOutput->Put(szBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   FormatRsrc
//
//  Synopsis:   Format resource string to the output stream.
//              adwArg[0] is the HINSTANCE and adArg[1] is the string id.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatRsrc(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    HRESULT hr;
    int     cch;
#ifndef _MACUNICODE
    TCHAR * psz;

    hr = THR(LoadString((HINSTANCE)adwArg[0], adwArg[1], &cch, &psz));
    Assert(!hr);
    while (hr == NOERROR && --cch >= 0)
        hr = pOutput->Put(*psz++);
#else
    // Macs store resources as ansi so we can't use the LoadString helper
    //      function 'cuz it just returns a pointer to the string resource.
    CHAR    psz[MAX_PATH];

    cch = THR(LoadStringA((HINSTANCE)adwArg[0], adwArg[1], psz, MAX_PATH ));
    if( cch )
        hr = pOutput->Put(MAKEWSTR(psz));
    else
        return E_FAIL;
#endif
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   FormatPlural
//
//  Synopsis:   Format adwArg[0] as plural to the output stream.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
static HRESULT
FormatPlural(TCHAR **ppchFmt, OutputStream *pOutput, DWORD_PTR *adwArg)
{
    HRESULT hr = NOERROR;
    TCHAR * pch = *ppchFmt;
    TCHAR   chDelim;
    TCHAR   ch;

    chDelim = *pch++;
    if (adwArg[0] == 1)
    {
        while (*pch && (ch = *pch++) != chDelim)
        {
            hr = pOutput->Put(ch);
            if (hr)
                return hr;

        }
        while (*pch && *pch++ != chDelim)
            ;
    }
    else
    {
        while (*pch && *pch++ != chDelim)
            ;
        while (*pch && (ch = *pch++) != chDelim)
        {
            hr = pOutput->Put(ch);
            if (hr)
                return hr;

        }
    }
    *ppchFmt = pch;
    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Function:   Format
//
//  Synopsis:   Replacement for sprintf and its friends.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
HRESULT __cdecl
Format(DWORD dwOptions, void *pvOutput, int cchOutput, TCHAR *pchFmt,...)
{
    HRESULT hr;
    va_list arg;

    va_start(arg, pchFmt);
    hr = VFormat(dwOptions, pvOutput, cchOutput, pchFmt, &arg);
    va_end(arg);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   Format
//
//  Synopsis:   Replacement for vsprintf and its friends.
//              See block comment at top of this file for more discussion.
//
//-------------------------------------------------------------------------
HRESULT
VFormat(DWORD dwOptions, void *pvOutput, int cchOutput,
        TCHAR *pchFmt, void *pvArgs)
{
    HRESULT hr = NOERROR;
    int     i;
    int     cch;
    TCHAR * pchFmtEnd;            // pointer location past end of format string.
    DWORD_PTR * adwArg;           // pointer to argument array
    DWORD_PTR   adwArgBuf[10];    // buffer for va_list args
    HRESULT (*pfn)(TCHAR **, OutputStream *, DWORD_PTR*);
    OutputStream output;

    // Step 1: Setup argument array pointer, pdwArgs.

    if (dwOptions & FMT_ARG_ARRAY)
    {
        adwArg = (DWORD_PTR *)pvArgs;
    }
    else
    {
        // Fetch arguments from variable length argument list.
        // Two assumptons are made here that are not generally true
        // of floating point types:
        //  - sizeof(argument) == sizeof(DWORD_PTR)
        //  - va_arg(arg, DWORD_PTR) does the right thing for all types.

        adwArg = adwArgBuf;
        for (i = 0; i < ARRAY_SIZE(adwArgBuf); i++)
        {
            adwArgBuf[i] = va_arg(*(va_list *)pvArgs, DWORD_PTR);
        }
    }

    // Step 2: Setup source string pointers, pchFmt & pchFmtEnd.

    if (!IS_INTRESOURCE(pchFmt))
    {
        pchFmtEnd = pchFmt + _tcslen(pchFmt);
    }
    else
    {
        hr = THR(LoadString(GetResourceHInst(), (UINT)(UINT_PTR)pchFmt, &cch, &pchFmt));
        if (hr)
            return hr;

        pchFmtEnd = pchFmt + cch;
    }

    // Step 3: Do the formatting.

    hr = output.Init(dwOptions & FMT_OUT_ALLOC, pvOutput, cchOutput);
    if (hr)
        return hr;

    while (pchFmt < pchFmtEnd)
    {
        if (*pchFmt != TEXT('<'))
            {
            hr = output.Put(*pchFmt++);
            if (hr)
                goto Cleanup;
            }
        else
        {
            pchFmt += 1;
            if (!InRange( *pchFmt, _T('0'), _T('9') ))
            {
                hr = output.Put(*pchFmt++);
                if (hr)
                    goto Cleanup;
            }
            else
            {
                i = *pchFmt++ - TEXT('0');
                if ( InRange( *pchFmt, _T('0'), _T('9') ) )
                {
                    i = i * 10 + *pchFmt++ - TEXT('0');
                }
                Assert(i < ARRAY_SIZE(adwArgBuf));

                switch (*pchFmt++)
                {
                case 'd': pfn = FormatDecimal; break;
                case 's': pfn = FormatString;  break;
                case 'p': pfn = FormatPlural;  break;
                case 'i': pfn = FormatRsrc;    break;
                case 'g': pfn = FormatGuid;    break;
                case 'x': pfn = FormatHex;     break;
                case 'c': pfn = FormatColor;   break;
                case 'C': pfn = FormatPound3;  break;
                default:
                    Assert(0 && "Format: Unknown format type.");
                    hr = E_FAIL;
                    goto Cleanup;
                    break;
                }
                hr = pfn(&pchFmt, &output, &adwArg[i]);
                if (hr)
                    goto Cleanup;
                if (*pchFmt++ != TEXT('>'))
                {
                    Assert(0 && "Format: Unknown option.");
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
        }
    }

    for (i = dwOptions & FMT_EXTRA_NULL_MASK; i >= 0; i--)
    {
        hr = output.Put((TCHAR)0);
        if (hr)
            goto Cleanup;
    }

    return S_OK;

Cleanup:
    output.Nuke();
    return hr;
}

#if DBG==1

static int __cdecl Test1Format(HRESULT hrExpected, TCHAR *pszExpected,
        TCHAR *pszFmt, ...)
{
    HRESULT hr;
    int     cErrors = 0;
    va_list arg;
    TCHAR   szBuf[256];
    TCHAR * pszOutput;

    va_start(arg, pszFmt);
    hr = VFormat(0, szBuf, ARRAY_SIZE(szBuf), pszFmt, &arg);
    va_end(arg);
    if (hr != hrExpected)
    {
        cErrors += 1;
        TraceTag((tagError, "Error for buf '%ls'\n  "
                "Expected=%08x\n Actual  =%08x\n", pszFmt, hrExpected, hr));
    }
    else if (!hrExpected && _tcscmp(szBuf, pszExpected))
    {
        cErrors += 1;
        TraceTag((tagError, "Error for buf '%ls'\n  "
                "Expected '%ls'\n  Actual   '%ls'\n",
                pszFmt, pszExpected, szBuf));
    }

    va_start(arg, pszFmt);
    hr = VFormat(FMT_OUT_ALLOC, &pszOutput, 10, pszFmt,&arg);
    va_end(arg);
    if (hr != hrExpected)
    {
        cErrors += 1;
        TraceTag((tagError, "Error for alloc 'l%s'\n  "
                "Expected=%08x\n Actual  =%08x\n", pszFmt, hrExpected, hr));
    }
    else if (!hrExpected && _tcscmp(pszOutput, pszExpected))
    {
        cErrors += 1;
        TraceTag((tagError, "Error for alloc '%ls'\n  "
                "Expected '%ls'\n  Actual   '%ls'\n",
                pszFmt, pszExpected, pszOutput));
    }
    MemFree(pszOutput);
    return cErrors;
}

int TestFormat()
{
    int cErrors = 0;

    cErrors += Test1Format(0, TEXT("Now is the time."), TEXT("Now is the time."));

    cErrors += Test1Format(0, TEXT("1 2 3 4 5"),
        TEXT("<0d> <1d> <2d> <3d> <4d>"),
        (long)1, (long)2, (long)3, (long)4, (long)5);

    cErrors += Test1Format(0, TEXT("1 2 3 4 5"),
        TEXT("<0s> <1s> <2s> <3s> <4s>"),
        TEXT("1"), TEXT("2"), TEXT("3"), TEXT("4"), TEXT("5"));

    cErrors += Test1Format(0, TEXT("<0d>"),
        TEXT("<<<0d>d>"),
        (long)0);

    cErrors += Test1Format(0, TEXT("aba"),
        TEXT("<0s><1s><0s>"),
        TEXT("a"), TEXT("b"));

    cErrors += Test1Format(0, TEXT("-1 -2 -3 -4 -5"),
        TEXT("<0d> <1d> <2d> <3d> <4d>"),
        (long)-1, (long)-2, (long)-3, (long)-4, (long)-5);

    cErrors += Test1Format(0, TEXT("There is 1 toaster flying across my screen"),
            TEXT("There <0p/is/are/> <0d> toaster<0p//s/> flying across my screen"),
            (long)1);

    cErrors += Test1Format(0, TEXT("There are 2 toasters flying across my screen"),
            TEXT("There <0p/is/are/> <0d> toaster<0p//s/> flying across my screen"),
            (long)2);

    cErrors += Test1Format(E_FAIL, TEXT("-1 -2 -3 -4 -5"),
        TEXT("<0q> <1d> <2d> <3d> <4d>"),
        (long)-1, (long)-2, (long)-3, (long)-4, (long)-5);

    cErrors += Test1Format(E_FAIL, TEXT("-1 -2 -3 -4 -5"),
        TEXT("<0dfoobar> <1d> <2d> <3d> <4d>"),
        (long)-1, (long)-2, (long)-3, (long)-4, (long)-5);

    return cErrors;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\genutil.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       General control utility functions
//
//-------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CTRLUTIL_HXX_
#define X_CTRLUTIL_HXX_
#include "ctrlutil.hxx"
#endif

DWORD
FormsDrawDiagonalLine(HDC hdc, LPRECT lprc, int iDirection, int iThickness, UINT flags)
{
    RECT    rc;
    LPINT   py;
    int     cx;
    int     cy;
    int     dx;
    int     dy;
    LPINT   pc;
    int     cxBorder = GetSystemMetrics(SM_CXBORDER);
    int     cyBorder = GetSystemMetrics(SM_CYBORDER);

    if (IsRectEmpty(lprc))
        return(0L);

    CopyRect(&rc, lprc);

    //
    // We draw slopes < 1 by varying y instead of x.
    //
    --iThickness;

    // HACK HACK HACK. REMOVE THIS ONCE MARLETT IS AROUND
    cy = rc.bottom - rc.top;
    cx = rc.right - rc.left;

    if (!flags && (cy != cx))
        cy -= iThickness * cyBorder;

    if (cy >= cx)
    {
        // "slope" is >= 1, so vary x by 1
        cy /= cx;
        pc = &cy;

        cx = cxBorder;
    }
    else
    {
        // "slope" is < 1, so vary y by 1
        cx /= cy;
        pc = &cx;

        cy = cyBorder;
    }

    dx = cx;
    dy = iDirection * cy;

    *pc = (*pc + iThickness) * cyBorder;

    rc.right -= cx;
    rc.bottom -= cy;

    // For negative slopes, start from opposite side.
    if (iDirection < 0)
        py = (int *)&rc.top;
    else
        py = (int *)&rc.bottom;

    while ((rc.left <= rc.right) && (rc.top <= rc.bottom))
    {
        if (!(flags & BF_MIDDLE))
            PatBlt(hdc, rc.left, *py, cx, cy, PATCOPY);
        else
        {
            // Fill interior.  We can determine vertex in interior
            // by vector define.

            if (cy > cyBorder)
            {
                if (flags & BF_LEFT)
                    PatBlt(hdc, rc.left, lprc->top, cx, *py - lprc->top + cy, PATCOPY);
                else
                    PatBlt(hdc, rc.left, *py, cx, lprc->bottom - *py, PATCOPY);
            }
            else
            {
                if (flags & BF_TOP)
                    PatBlt(hdc, rc.left, *py, lprc->right - rc.left, cy, PATCOPY);
                else
                    PatBlt(hdc, lprc->left, *py, rc.left - lprc->left + cx, cy, PATCOPY);
            }
        }

        rc.left += dx;
        *py -= dy;
    }

    return(MAKELONG(cx, cy));
}


BOOL
FormsDrawCheckMark(HDC hdc, LPRECT lprc, int iThickness)
{
    int i = (lprc->right - lprc->left + 2) / 3;
    int saveRight = lprc->right;

    lprc->top += ((lprc->bottom - lprc->top - (i * 2)) / 2) + i - 1;
    lprc->bottom = lprc->top + i + (iThickness - 1);

    lprc->left += (lprc->right - lprc->left - ((i * 3) - 1)) / 2;

    lprc->right = lprc->left + i - 1;
    FormsDrawDiagonalLine(hdc, lprc, -1, iThickness, 0);
    lprc->top -= i;
    lprc->left = lprc->right;
    lprc->right = saveRight;
    FormsDrawDiagonalLine(hdc, lprc, 1, iThickness, 0);
    return(TRUE);
}


const int HAIRLINE_IN_HIMETRICS = 26;

BOOL
FormsDrawGlyph(CDrawInfo * pDI, LPGDIRECT prc, UINT wType, UINT wState)
{
    COLORREF crSaveBkColor=0;           // save background color
    COLORREF crSaveFrColor=0;           // save foreground color
    INT nTechnology     = GetDeviceCaps(pDI->_hdc, TECHNOLOGY);
    INT nNumColors      = GetDeviceCaps(pDI->_hdc, NUMCOLORS);
    DWORD dwDCObjType   = GetObjectType(pDI->_hdc);
    HDC     hdcMem      = NULL;
    HBITMAP hbmMem      = NULL;
    HBITMAP oldhbmMem   = NULL;

    int nHeight, nWidth;

    // this function only handles buttons...
    Assert (wType == DFC_BUTTON);


    nHeight = prc->bottom - prc->top;
    nWidth = prc->right - prc->left;

    switch (nTechnology)
    {
// WINCEREVIEW: no support for  DT_METAFILE:
#ifndef WINCE
    case DT_METAFILE:
        Assert(dwDCObjType == OBJ_ENHMETADC || dwDCObjType == OBJ_METADC);
#endif // WINCE
    case DT_RASPRINTER:
    case DT_PLOTTER:
        if (nNumColors == 2)                            // if this is a black and white printer
        {
            crSaveBkColor = GetBkColor(pDI->_hdc);      // save the back color
            crSaveFrColor = GetTextColor(pDI->_hdc);    // save the fore color
            SetBkColor(pDI->_hdc, RGB(255, 255, 255));
            SetTextColor(pDI->_hdc, RGB(0, 0, 0));
        }

        switch(dwDCObjType)
        {
        case    OBJ_ENHMETADC:
// WINCEREVIEW: no support for  DT_METAFILE:
#ifndef WINCE
        case    OBJ_METADC:
#endif // WINCE
            if (nNumColors == 2)                        // if this is a black and white printer
            {
                hdcMem = CreateCompatibleDC(TLS(hdcDesktop));
                if (hdcMem)
                {
                    hbmMem = CreateCompatibleBitmap(TLS(hdcDesktop), nWidth, nHeight);
                    if (hbmMem)
                    {
                        GDIRECT rcMem;

                        rcMem.top = rcMem.left = 0;
                        rcMem.right = nWidth;
                        rcMem.bottom = nHeight;

                        oldhbmMem = (HBITMAP)SelectObject(hdcMem, hbmMem);
                        BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdcMem, 0, 0, WHITENESS);
// causes an assert in the bitBlt code....  why would we want to do this anyhow?
//                        BitBlt(pDI->_hdc, prc->left, prc->top,
//                                            nWidth, nHeight, pDI->_hdc, 0, 0, WHITENESS);
                        DrawFrameControl(hdcMem, &rcMem, wType, wState);

                        BitBlt(pDI->_hdc, prc->left, prc->top,
                                            nWidth, nHeight, XHDC(hdcMem, NULL), 0, 0, SRCCOPY);
                        SelectObject(hdcMem, oldhbmMem);
                        DeleteDC(hdcMem);
                        DeleteObject(hbmMem);
                        DeleteObject(oldhbmMem);
                        break;
                    }
                    DeleteDC(hdcMem);
                }
            }

            // if something wrong, fall through
        default:
            DrawFrameControl(pDI->_hdc, prc, wType, wState);
        }
        if (nNumColors == 2)                            // if this is a black and white printer
        {
          SetBkColor(pDI->_hdc, crSaveBkColor);       // restore the back color
          SetTextColor(pDI->_hdc, crSaveFrColor);     // restore the fore color
        }
        break;
    default:
        DrawFrameControl(pDI->_hdc, prc, wType, wState);
    } // end of swtich

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\formsary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   formsary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CImplAry
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

DeclareTag(CImplAryLock, "CImplAry", "Detect data array changing when lock is on.");

#define CFORMSARY_MAXELEMSIZE    128

MtDefine(CURLAry, Utilities, "CURLAry")
MtDefine(CURLAry_pv, CURLAry, "CURLAry::_pv")
MtDefine(CIPrintAry, Printing, "CIPrintAry")
MtDefine(CIPrintAry_pv, CIPrintAry, "CIPrintAry::_pv")
MtDefine(CPrintInfoFlagsAry, Printing, "CPrintInfoFlagsAry")
MtDefine(CPrintInfoFlagsAry_pv, CPrintInfoFlagsAry, "CPrintInfoFlagsAry::_pv")

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//+------------------------------------------------------------------------
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CImplAry::~CImplAry( )
{
    if (!UsingStackArray())
    {
        MemFree(PData());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is _cStack*cb if
//              we're still using the stack-allocated array.
//
//----------------------------------------------------------------------------

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }
    else
    {
        return MemGetSize(PData());
    }
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::EnsureSize ( size_t cb, long c )
{
    HRESULT  hr = S_OK;
    unsigned long cbAlloc;

    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        goto Cleanup;

    Assert( c >= 0 );

    cbAlloc = ((c < 8) ? c : ((c + 7) & ~7)) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((_c < 8) ? _c : ((_c + 7) & ~7))) && cbAlloc > MemGetSize(PData())))
    {
        Assert(!(_fCheckLock && IsTagEnabled(CImplAryLock)) && "CDataAry changing while CImplAryLock is on");

        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            
            void * pbDataOld = PData();
            int    cbOld     = GetAlloced( cb );

            PData() = MemAlloc( _mt, cbAlloc );
            
            if (!PData())
            {
                PData() = pbDataOld;

                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy( PData(), pbDataOld, cbOld );
        }
        else
        {
            hr = MemRealloc( _mt, (void **) & PData(), cbAlloc );
            
            if (hr)
                goto Cleanup;
        }

        _fDontFree = FALSE;

        MemSetName((PData(), "CImplAry data (%d elements)", c));
    }

Cleanup:
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (!hr)
    {
        SetSize(c);
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::AppendIndirect(size_t cb, void * pv, void ** ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, _c);
    }

    if (!pv)
    {
        memset(Deref(cb, _c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, _c), pv, cb);
    }

    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CImplAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::Delete(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)_c);

    Assert(!(_fCheckLock && IsTagEnabled(CImplAryLock)) && "CDataAry changing while CImplAryLock is on");

    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//-------------------------------------------------------------------------
BOOL
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        Delete(cb, i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)_c) && (end < (int)_c));
    Assert(end >= start);

    if ((unsigned)end < (_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (_c - end - 1) * cb);
    }

    _c -= (end - start) + 1;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteAll(void)
{
    Assert(!(_fCheckLock && IsTagEnabled(CImplAryLock)) && "CDataAry changing while CImplAryLock is on");

    if (!UsingStackArray())
    {
        MemFree(PData());

        if (_fStack)
        {
            PData() = GetStackPtr();
            _fDontFree = TRUE;
        }
        else
        {
            PData() = NULL;
        }
    }

    _c = 0;
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (_c - i ) * cb);

    if (!pv)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }
    _c++;
    return NOERROR;

}

#ifdef NEVER
//+------------------------------------------------------------------------
//
//  Member: CImplAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CImplAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    Assert(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + cb, PData(), i * cb);
    memcpy(PData(), rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CImplAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CImplAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    Assert(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) PData()) + ((_c - 1) * cb), rgb, cb);
}


//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Swap
//
//  Synopsis:   swap two members of array with each other.
//
//  Arguments:  cb  size of elements
//              i1  1st element
//              i2  2nd element
//----------------------------------------------------------------------------
void
CImplAry::Swap(size_t cb, int i1, int i2)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    Assert(cb <= CFORMSARY_MAXELEMSIZE);

    if ((unsigned)i1 >= _c)
        i1 = _c - 1;
    if ((unsigned)i2 >= _c)
        i2 = _c - 1;

    if (i1 != i2)
    {
        memcpy(rgb, ((BYTE *) PData()) + (i1 * cb), cb);
        memcpy(((BYTE *) PData()) + (i1 * cb), ((BYTE *) PData()) + (i2 * cb), cb);
        memcpy(((BYTE *) PData()) + (i2 * cb), rgb, cb);
    }
}
#endif // NEVER

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//----------------------------------------------------------------------------

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = _c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return _c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::CopyAppend
//
//  Synopsis:   Copies the entire contents of another CImplAry object and
//              appends it to the end of the array.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

#ifdef NEVER
HRESULT
CImplAry::CopyAppend(size_t cb, const CImplAry& ary, BOOL fAddRef)
{
    RRETURN(CopyAppendIndirect(cb, ary._c, ((CImplAry *)&ary)->PData(), fAddRef));
}


HRESULT
CImplAry::CopyAppendIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown ** ppUnk;                  // elem to addref

    if (EnsureSize(cb, _c + c))
        RRETURN(E_OUTOFMEMORY);

    if (pv)
    {
        memcpy((BYTE*) PData() + (_c * cb), pv, c * cb);
    }

    _c += c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) pv; c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}
#endif // NEVER

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, BOOL fAddRef)
{
    RRETURN(CopyIndirect(cb, ary._c, ((CImplAry *)&ary)->PData(), fAddRef));
}



//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown **     ppUnk;

    if (pv == PData())
        return S_OK;

    DeleteAll();
    if (pv)
    {
        if (EnsureSize(cb, c))
            RRETURN(E_OUTOFMEMORY);

        memcpy(PData(), pv, c * cb);
    }

    _c = c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//-------------------------------------------------------------------------

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
}

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
}

int
CImplPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CImplPtrAry::Delete(int i)
{
    CImplAry::Delete(sizeof(void *), i);
}

BOOL
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::Delete(sizeof(void *), i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
}

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown * pUnk;

    Assert(idx < (int)_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];

#if defined(UNIX) && defined(ux10)
    if (pUnk)
        (pUnk)->Release();

    Delete(idx);
#else
    Delete(idx);

    if (pUnk)
        (pUnk)->Release();
#endif
}


void
CImplPtrAry::ReleaseAll(void)
{
    int         i;
    IUnknown ** ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < _c; i++, ppUnk++)
    {
        if (*ppUnk)
            (*ppUnk)->Release();
    }

    DeleteAll();
}

#ifdef NEVER
void
CImplPtrAry::BringToFront(int i)
{
    CImplAry::BringToFront(sizeof(void *), i);
}


void
CImplPtrAry::SendToBack(int i)
{
    CImplAry::SendToBack(sizeof(void *), i);
}

void
CImplPtrAry::Swap(int i1, int i2)
{
    CImplAry::Swap(sizeof(void *), i1, i2);
}


HRESULT
CImplPtrAry::CopyAppendIndirect(int c, void * pv, BOOL fAddRef)
{
    return CImplAry::CopyAppendIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CImplPtrAry::CopyAppend(const CImplAry& ary, BOOL fAddRef)
{
    return CImplAry::CopyAppend(sizeof(void *), ary, fAddRef);
}
#endif // NEVER

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, BOOL fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, BOOL fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
}


HRESULT
CImplPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CImplAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}


HRESULT
CImplPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CImplAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}


CStackCStrAry::~CStackCStrAry()
{
    CStr *pcstr = (CStr*) PData();
    int iSize = Size();

    while (iSize--) 
    {
        pcstr->Free();
        pcstr++;
    }
}


CStackIPrintAry::~CStackIPrintAry()
{
    IPrint **ppPrint = (IPrint**) PData();
    int iSize = Size();

    while (iSize--) 
    {
        ClearInterface(ppPrint);
        ppPrint++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\himetric.cxx ===
//+---------------------------------------------------------------------
//
//  File:       himetric.cxx
//
//  Contents:   Routines to convert Pixels to Himetric and vice versa
//
//              These routines assume the standard {96 x 96} screen logical pixel
//              sizes.  If this could ever be invalid (for a printer, a virtual device,
//              etc...), these should not be used.  CTransform provides a more
//              flexible, but more heavyweight, way of transforming pix <-> himetric.
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_HIMETRIC_HXX_
#define X_HIMETRIC_HXX_
#include "himetric.hxx"
#endif

// This is a resolution threshold. Above it we stop treating "OM pixels"
// as 1-to-1 corresponding to screen pixel and start treating them
// as 1/96th of an inch.
// We use hi-res units (~16K DPI) when we do layout for printing.
// In this case, we will compare the "document resolution" (~16K) with
// threshold and use FIXED_PIXELS_PER_INCH for conversions between
// physical length (inches, etc) to "OM pixels" and vice versa.
// "OM pixels" are "px" sizes in HTML/CSS and units in which OM
// sets/returns sizes of elements.
// Because we calculate layout in isotropic coordinates, we don't need
// separate x- and y- resolutions here.

extern BOOL g_fUseHR;
extern BOOL g_fHiResAware;

// check only X resolution - for consistency
inline BOOL IsLowRes(LONG sizeInchX, LONG sizeInchY) 
{
    if (!(g_fUseHR && g_fHiResAware))
        return (sizeInchX < RESOLUTION_THRESHOLD);
    else
        return FALSE;
}


#ifdef PRODUCT_96
void
PixelFromHMRect(RECT *prcDest, RECTL *prcSrc)
{
    prcDest->left = HPixFromHimetric(prcSrc->left);
    prcDest->top = VPixFromHimetric(prcSrc->top);
    prcDest->right = HPixFromHimetric(prcSrc->right);
    prcDest->bottom = VPixFromHimetric(prcSrc->bottom);
}
#endif

#ifdef PRODUCT_96
void
HMFromPixelRect(RECTL *prcDest, RECT *prcSrc)
{
    prcDest->left = HimetricFromHPix(prcSrc->left);
    prcDest->top = HimetricFromVPix(prcSrc->top);
    prcDest->right = HimetricFromHPix(prcSrc->right);
    prcDest->bottom = HimetricFromVPix(prcSrc->bottom);
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   StringToHimetric
//
//  Synopsis:   Converts a numeric string with units to a himetric value.
//              Expects a NULL-terminated string.  The contents of the
//              string may be altered.
//
//              Example: "72 pt" returns 2540 and UNITS_POINT
//
//  Arguments:  [szString]  String to convert
//              [pUnits]    Returns the original units found.  NULL ok.
//              [plValue]   Resulting himetric value
//
//  QUESTION - Is atof the right thing to use here?
//
//--------------------------------------------------------------------------

HRESULT
StringToHimetric(TCHAR * pstr, UNITS * punits, long * plValue)
{
    HRESULT hr;
    int     units;
    TCHAR * pstrT;
    float   flt;
    TCHAR   achUnits[UNITS_BUFLEN];

    *plValue = 0;

    // Convert all trailing spaces to nulls so they don't confuse
    // the units.

    for (pstrT = pstr; *pstrT; pstrT++);
    do { *pstrT-- = 0; } while (*pstrT == ' ');

    //  First, see if the user specified units in the string

    for (units = UNITS_MIN; units < UNITS_UNKNOWN; units++)
    {


        Verify(LoadString(
                    GetResourceHInst(),
                    IDS_UNITS_BASE + units,
                    achUnits,
                    ARRAY_SIZE(achUnits)));

        for (pstrT = pstr; *pstrT; pstrT++)
        {
            if (!_tcsicmp(pstrT, achUnits))
            {
                *pstrT = 0;
                goto FoundMatch;
            }
        }
    }

    //  If no units are specified, use the global default

    Assert(units == UNITS_UNKNOWN);

#if NEVER // we should use UNITS_POINT in Forms3 96.
    units = g_unitsMeasure;
#else // ! NEVER
    units = UNITS_POINT;
#endif // ! NEVER

FoundMatch:

    //  Use OleAuto to convert the string to a float; this assumes
    //    that the conversion will ignore "noise" like the units
    hr = THR(VarR4FromStr(pstr, g_lcidUserDefault, 0, &flt));
    if (hr)
        goto Cleanup;

    switch (units)
    {
    case UNITS_CM:
        *plValue = (long) (flt * 1000);
        break;

    case UNITS_UNKNOWN:
    case UNITS_POINT:
        *plValue = (long) ((flt * 2540) / 72);
        break;

    case UNITS_INCH:
        *plValue = (long) (flt * 2540);
        break;

    default:
        Assert(FALSE);
        break;
    }

Cleanup:

    *punits = (UNITS) units;

    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  Function:   HimetricToString
//
//  Synopsis:   Converts a himetric value to a numeric string of the
//              specified units.
//
//              Example:  2540 and UNITS_POINT returns "72 pt"
//
//  Arguments:  [lVal]      Value to convert
//              [units]     Units to convert to
//              [szRet]     Buffer for returned string
//              [cch]       Size of buffer
//
//--------------------------------------------------------------------------

HRESULT
HimetricToString(long lVal, UNITS units, TCHAR * szRet, int cch)
{
    HRESULT     hr;
    float       flt;
    BSTR        bstr = NULL;

    Assert(units == UNITS_POINT);

    flt = UserFromHimetric(lVal);

    hr = THR(VarBstrFromR4(flt, g_lcidUserDefault, 0, &bstr));
    if (hr)
        goto Cleanup;



    hr = Format(
            0,
            szRet,
            cch,
            _T("<0s> <1i>"),
            bstr,
            GetResourceHInst(), IDS_UNITS_BASE + units);

Cleanup:
    FormsFreeString(bstr);

    RRETURN(hr);
}



#if DBG == 1
BOOL
CheckFPConversion( )
{
    long    i;
    float   xf;
    float   xf2;

    for (i = 0; i < 72 * 20; i++)
    {
        xf = i / 20.0f;
        xf2 = UserFromHimetric(HimetricFromUser(xf));

        Assert(xf == xf2);
    }

    return TRUE;
}
#endif

StartupAssert(CheckFPConversion());

//+-------------------------------------------------------------------------
//
//  Function:   UserFromHimetric
//
//  Synopsis:   Converts a himetric long value to point size float.
//
//--------------------------------------------------------------------------

float
UserFromHimetric(long lValue)
{
    //  Rounds to the nearest .05pt.  This is about the maximum
    //    precision we can get keeping things in himetric internally

#if NEVER // Should not change the default unit in Forms3 96. Use UNITS_POINT.
          // Leave this code to roll back in 97.
    switch (g_unitsMeasure)
    {
    case UNITS_CM:
        return (float)lValue / (float)1000;

    case UNITS_POINT:
    default:
        return ((float) MulDivQuick(lValue, 72 * 20, 2540)) / 20;
    }

#else // ! NEVER

    return ((float) MulDivQuick(lValue, 72 * 20, 2540)) / 20;

#endif // ! NEVER

}


//+-------------------------------------------------------------------------
//
//  Function:   HimetricFromUser
//
//  Synopsis:   Converts a point size double to himetric long.  Rounds
//              to the nearest himetric value.
//
//--------------------------------------------------------------------------

long
HimetricFromUser(float xf)
{
    long lResult;

#if NEVER // Should not change the default unit in Forms3 96. Use UNITS_POINT.
          // Leave this code to roll back in 97.
    switch (g_unitsMeasure)
    {
    case UNITS_CM:
        xf = xf * (float)1000;
        break;
    case UNITS_POINT:
    default:
        xf = xf * ( ((float)2540) / 72 );
        break;
    }

#else // ! NEVER

    xf = xf * ( ((float)2540) / 72 );

#endif // ! NEVER

    if (xf > LONG_MAX)
        lResult = LONG_MAX;
    else if (xf > .0)
        lResult = long(xf + .5);
    else if (xf < LONG_MIN)
        lResult = LONG_MIN;
    else
        lResult = long(xf - .5);

    return lResult;
}

#if DBG == 1
#include <math.h>
#pragma intrinsic(fabs)
int MulDivQuick(int nMultiplicand, int nMultiplier, int nDivisor)
{
    int nResult = (!nDivisor-1) & MulDiv(nMultiplicand, nMultiplier, nDivisor);

    Assert(nDivisor);

#ifdef _M_IX86
#define F2I_PRECISION_24         0x000  //_PC_24  0x00020000
#define F2I_PRECISION_53         0x200  //_PC_53  0x00010000
#define F2I_PRECISION_64         0x300  //_PC_64  0x00000000
#define F2I_PRECISION_MASK       0x300  //_MCW_PC 0x00030000
        unsigned cw;
        _asm fstcw cw;
        unsigned cw_saved = cw & F2I_PRECISION_MASK;
        cw = cw & ~F2I_PRECISION_MASK | F2I_PRECISION_64;
        _asm fldcw cw;

	    double dv = double(nMultiplicand)*nMultiplier
	              - double(nDivisor)*nResult;

        _asm fstcw cw;
        cw = cw & ~F2I_PRECISION_MASK | cw_saved;
        _asm fldcw cw;

	    Assert (fabs(dv) <= fabs(nDivisor*.5));
#endif
    return nResult;
}
#endif

#ifndef _M_IX86
int CFloatlet::Mul(int x) const
{
    __int64 m = Int32x32To64(x, _mult);
    int r = int(m>>(_shift-1));
    return (r+1)>>1;
}

int _stdcall CFloatlet::MulCeil(int x) const
{
    __int64 m = Int32x32To64(-x, _mult);
    return -int(m>>_shift);
}
#else //_M_IX86
#pragma warning(disable:4035)
int _declspec(naked) CFloatlet::Mul(int x) const
{
    _asm
    {
        mov eax,[esp+4] //x
        imul [ecx]._mult
        mov ecx,[ecx]._shift
        shrd eax,edx,cl
        adc eax,0
        ret 4
    }
}

int _declspec(naked) CFloatlet::MulCeil(int x) const
{
    _asm
    {
        mov eax,[esp+4] //x
        neg eax
        imul [ecx]._mult
        mov ecx,[ecx]._shift
        shrd eax,edx,cl
        neg eax
        ret 4
    }
}

// calculate ceil((a<<31)/b)
inline int __MakeRatio(unsigned a, unsigned b)
{
    _asm
    {
        mov edx,a
        xor eax,eax
        shrd eax,edx,1
        shr edx,1
        mov ebx,b
        sub ebx,1
        add eax,ebx
        adc edx,0
        div b
    }
}

#pragma warning(default:4035)
#endif


void CFloatlet::MakeRatio(unsigned a, unsigned b)
{
    {
        // the following precautions were made to surpress
        // looping when incorrect arguments are supplied (see bug 32496).
        // This will not improve the bug case (that was observed just once
        // and never reproed) but at least we wouldn't hang (mikhaill 4/25/1)
        Assert(a < 0x80000000 && b != 0);

        if (a >= 0x80000000)
            a = 0x7FFFFFFF;
        
        if (b == 0)
            b = 1;
    }

    _shift = 31;
    while (b <= a)
    {
        b <<= 1;
        _shift--;
    }
#ifdef _M_IX86
    _mult = __MakeRatio(a,b);
#else
    __int64 p = __int64(a) << 31;
    p += b-1;	// force division to generate ceil() instead of floor()
    _mult = int(p/b);
#endif
}


CUnitInfo::CUnitInfo(int dpi_x, int dpi_y, int target_dpi_x, int target_dpi_y)
{
    _SetMainResolution(dpi_x, dpi_y);
    _SetTargetResolution(target_dpi_x, target_dpi_y);
}

void
CUnitInfo::SetResolution(int dpi_x, int dpi_y)
{
    _SetMainResolution(dpi_x, dpi_y);

    Assert(this == &g_uiDisplay || this == &g_uiVirtual);
    CUnitInfo& target = this == &g_uiDisplay ? g_uiVirtual : g_uiDisplay;

    SIZE const& thisRes = GetResolution();
    SIZE const& targetRes = target.GetResolution();

    _SetTargetResolution(targetRes.cx, targetRes.cy);
    target._SetTargetResolution(thisRes.cx, thisRes.cy);
}

void
CUnitInfo::_SetMainResolution(int dpi_x, int dpi_y)
{
    _sizeInch.cx = dpi_x;
    _sizeInch.cy = dpi_y;
    if (IsLowRes(_sizeInch.cx, _sizeInch.cy))
        _sizeDocRes = _sizeInch;
    else
        _sizeDocRes.cx = _sizeDocRes.cy = FIXED_PIXELS_PER_INCH;

    if (_sizeInch.cx >= TWIPS_PER_INCH)
        _sizeMax.cx = 0x3FFFFFFF - _sizeInch.cx/2;
    else
    {
        _sizeMax.cx = MulDiv(0x3FFFFFFF, _sizeInch.cx, TWIPS_PER_INCH);
        if (Int32x32To64(_sizeMax.cx, TWIPS_PER_INCH) > Int32x32To64(0x3FFFFFFF, _sizeInch.cx))
        _sizeMax.cx--;
    }

    if (_sizeInch.cy >= TWIPS_PER_INCH)
        _sizeMax.cy = 0x3FFFFFFF - _sizeInch.cy/2;
    else
    {
        _sizeMax.cy = MulDiv(0x3FFFFFFF, _sizeInch.cy, TWIPS_PER_INCH);
        if (Int32x32To64(_sizeMax.cy, TWIPS_PER_INCH) > Int32x32To64(0x3FFFFFFF, _sizeInch.cy))
            _sizeMax.cy--;
    }

    _flDeviceFromHimetricX.MakeRatio(_sizeInch.cx, HIMETRIC_PER_INCH);
    _flDeviceFromHimetricY.MakeRatio(_sizeInch.cy, HIMETRIC_PER_INCH);

    _flDeviceFromTwipsX.MakeRatio(_sizeInch.cx, TWIPS_PER_INCH);
    _flDeviceFromTwipsY.MakeRatio(_sizeInch.cy, TWIPS_PER_INCH);

    _flDeviceFromDocPixelsX.MakeRatio(_sizeInch.cx, _sizeDocRes.cx);
    _flDeviceFromDocPixelsY.MakeRatio(_sizeInch.cy, _sizeDocRes.cy);

    _flHimetricFromDeviceX.MakeRatio(HIMETRIC_PER_INCH, _sizeInch.cx);
    _flHimetricFromDeviceY.MakeRatio(HIMETRIC_PER_INCH, _sizeInch.cy);

    _flTwipsFromDeviceX.MakeRatio(TWIPS_PER_INCH, _sizeInch.cx);
    _flTwipsFromDeviceY.MakeRatio(TWIPS_PER_INCH, _sizeInch.cy);

    _flDocPixelsFromDeviceX.MakeRatio(_sizeDocRes.cx, _sizeInch.cx);
    _flDocPixelsFromDeviceY.MakeRatio(_sizeDocRes.cy, _sizeInch.cy);
}

void
CUnitInfo::_SetTargetResolution(int target_dpi_x, int target_dpi_y)
{
    _flTargetFromDeviceX.MakeRatio(target_dpi_x, _sizeInch.cx);
    _flTargetFromDeviceY.MakeRatio(target_dpi_y, _sizeInch.cy);
}


void CUnitInfo::DeviceFromHimetric(SIZE& result, int x, int y) const
{
    result.cx = DeviceFromHimetricX(x);
    result.cy = DeviceFromHimetricY(y);
}

void CUnitInfo::DeviceFromTwips(SIZE& result, int x, int y) const
{
    result.cx = DeviceFromTwipsX(x);
    result.cy = DeviceFromTwipsY(y);
}

void CUnitInfo::DeviceFromDocPixels(SIZE& result, int x, int y) const
{
    result.cx = DeviceFromDocPixelsX(x);
    result.cy = DeviceFromDocPixelsY(y);
}

void CUnitInfo::HimetricFromDevice(SIZE& result, int x, int y) const
{
    result.cx = HimetricFromDeviceX(x);
    result.cy = HimetricFromDeviceY(y);
}

void CUnitInfo::TwipsFromDevice(SIZE& result, int x, int y) const
{
    result.cx = TwipsFromDeviceX(x);
    result.cy = TwipsFromDeviceY(y);
}

void CUnitInfo::DocPixelsFromDevice(SIZE& result, int x, int y) const
{
    result.cx = DocPixelsFromDeviceX(x);
    result.cy = DocPixelsFromDeviceY(y);
}

void CUnitInfo::DocPixelsFromDevice(RECT& rcIn, RECT& rcOut) const
{
    rcOut.left   = DocPixelsFromDeviceX(rcIn.left);
    rcOut.right  = DocPixelsFromDeviceX(rcIn.right);
    rcOut.top    = DocPixelsFromDeviceY(rcIn.top);
    rcOut.bottom = DocPixelsFromDeviceY(rcIn.bottom);
}


void 
CUnitInfo::DocPixelsFromDevice(POINT *pPt) const
{
    pPt->x = DocPixelsFromDeviceX(pPt->x);
    pPt->y = DocPixelsFromDeviceY(pPt->y);
}

void 
CUnitInfo::DeviceFromDocPixels(POINT *pPt) const
{
    pPt->x = DeviceFromDocPixelsX(pPt->x);
    pPt->y = DeviceFromDocPixelsY(pPt->y);
}

void 
CUnitInfo::DocPixelsFromDevice(RECT *pRect) const
{
    pRect->left   = DocPixelsFromDeviceX(pRect->left);
    pRect->right  = DocPixelsFromDeviceX(pRect->right);
    pRect->top    = DocPixelsFromDeviceY(pRect->top);
    pRect->bottom = DocPixelsFromDeviceY(pRect->bottom);
}

void 
CUnitInfo::DeviceFromDocPixels(RECT *pRect) const
{
    pRect->left   = DeviceFromDocPixelsX(pRect->left);
    pRect->right  = DeviceFromDocPixelsX(pRect->right);
    pRect->top    = DeviceFromDocPixelsY(pRect->top);
    pRect->bottom = DeviceFromDocPixelsY(pRect->bottom);
}

//-----------------------------
//cross-device conversion: rounding to nearest
void CUnitInfo::_TargetFromDevice(SIZE & size, CUnitInfo const & cuiTarget) const
{
    Assert(this == &g_uiDisplay && &cuiTarget == &g_uiVirtual ||
           this == &g_uiVirtual && &cuiTarget == &g_uiDisplay);

    size.cx = _flTargetFromDeviceX.Mul(size.cx);
    size.cy = _flTargetFromDeviceY.Mul(size.cy);
}

void CUnitInfo::_TargetFromDevice(RECT & rc, CUnitInfo const & cuiTarget) const
{
    SIZE size;

    Assert(this == &g_uiDisplay && &cuiTarget == &g_uiVirtual ||
           this == &g_uiVirtual && &cuiTarget == &g_uiDisplay);

    size.cx     = _flTargetFromDeviceX.Mul(rc.right - rc.left);
    size.cy     = _flTargetFromDeviceY.Mul(rc.bottom - rc.top);

    rc.left     = _flTargetFromDeviceX.Mul(rc.left);
    rc.top      = _flTargetFromDeviceY.Mul(rc.top);

    rc.right    = rc.left + size.cx;
    rc.bottom   = rc.top + size.cy;
}

CUnitInfo g_uiDisplay(96, 96, 0x4000, 0x4000);  // will be reinited in InitSystemMetricValues()
CUnitInfo g_uiVirtual(0x4000, 0x4000, 96, 96);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\help.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       help.cxx
//
//  Contents:   Helpers for help
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

EXTERN_C const GUID LIBID_MSHTML;
EXTERN_C const GUID CLSID_HTMLDocument;

//+-------------------------------------------------------------------------
//
//  Function:   FormsHelp
//
//  Synopsis:   Helper for WinHelp
//
//  Arguments:  [uCmd]      type of help - see WinHelp
//              [dwData]    additional data - see WinHelp
//
//--------------------------------------------------------------------------

HRESULT
FormsHelp(TCHAR * szHelpFile, UINT uCmd, DWORD dwData)
{
    BOOL        fRet;

    fRet = WinHelp(
                TLS(gwnd.hwndGlobalWindow),
                szHelpFile,
                uCmd,
                dwData);

    RRETURN(fRet ? S_OK : E_FAIL);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetTypeInfoForCLSID
//
//  Synopsis:   Gets the TypeInfo for the CLSID by chasing through the
//              registry and into the TypeLib.
//
//--------------------------------------------------------------------------

HRESULT
GetTypeInfoForCLSID(HKEY hkRoot, REFCLSID clsid, ITypeInfo ** ppTI)
{
    OLECHAR       szGuidTyp[128];
    TCHAR       szVersion[128];
    TCHAR       szTypeLib[128];
    IID         iid;
    ITypeLib *  pTypeLib = NULL;
    ITypeInfo * pTypeInfo;
    long        cb;
    long        err;
    HKEY        hkType = NULL;
    HRESULT     hr;

    // Get TypeLib GUID.
    Format(0, szGuidTyp, ARRAY_SIZE(szGuidTyp), _T("<0g>\\TypeLib"), &clsid);
    cb = ARRAY_SIZE(szGuidTyp) * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkRoot, szGuidTyp, szGuidTyp, &cb));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Translate the guid from the registry into an iid.
    hr = THR(IIDFromString(szGuidTyp, &iid));
    if (hr)
        goto Cleanup;

    // See if this idd matches our TypeLib.
    if (IsEqualIID(iid, LIBID_MSHTML))
    {
        hr = THR(LoadF3TypeInfo(clsid, &pTypeInfo));
        if (!hr)
            goto Complete;

        goto Cleanup;
    }

    // Get Version.
    Format(0, szVersion, ARRAY_SIZE(szVersion), _T("<0g>\\Version"), &clsid);
    cb = ARRAY_SIZE(szVersion) * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkRoot, szVersion, szVersion, &cb));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Open TypeLib key.
    err = TW32_NOTRACE(1,RegOpenKey(HKEY_CLASSES_ROOT,TEXT("TypeLib"),&hkType));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // CONSIDER - At some point getting the localized TypeLib.  Here we always
    // get the default TypeLib. (rodc)
    //
    // Get TypeLib path and filename.
    Format(0, szTypeLib, ARRAY_SIZE(szTypeLib), _T("<0s>\\<1s>\\0\\win32"),
            szGuidTyp,
            szVersion);
    cb = ARRAY_SIZE(szTypeLib) * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkType, szTypeLib, szTypeLib, &cb));
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Load the type library.
    hr = THR(LoadTypeLib(szTypeLib, &pTypeLib));
    if (hr)
        goto Cleanup;

    // Get the type info for this specific classid.
    hr = THR(pTypeLib->GetTypeInfoOfGuid(clsid, &pTypeInfo));
    if (hr)
        goto Cleanup;

Complete:
    *ppTI = pTypeInfo;

Cleanup:
    if (hkType)
        RegCloseKey(hkType);
    ReleaseInterface(pTypeLib);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetDocumentationForCLSID
//
//  Synopsis:   Gets the TypeInfo documentation for the CLSID.
//
//--------------------------------------------------------------------------

HRESULT
GetDocumentationForCLSID(
        HKEY hkRoot,
        REFCLSID clsid,
        BSTR * pbstrName,
        DWORD * pdwHelpContextId,
        BSTR * pbstrHelpFile)
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT     hr;

    // Get the TypeInfo for this specific classid.
    hr = THR_NOTRACE(GetTypeInfoForCLSID(hkRoot, clsid, &pTypeInfo));
    if (hr)
        goto Cleanup;

    // Get the documentation for this classid from the TypeInfo.
    hr = THR(pTypeInfo->GetDocumentation(
            MEMBERID_NIL,
            pbstrName,
            NULL,
            pdwHelpContextId,
            pbstrHelpFile));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pTypeInfo);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetNameForCLSID
//
//  Synopsis:   Gets the name for the CLSID.
//
//--------------------------------------------------------------------------

HRESULT
GetNameForCLSID(HKEY hkRoot, REFCLSID clsid, TCHAR * szName, int cch)
{
    TCHAR       szUser[128];
    BSTR        bstrName = NULL;
    long        cb;
    long        err;
    HRESULT     hr;

    Assert(szName);

    // Otherwise, try the name for this classid.
    hr = THR_NOTRACE(GetDocumentationForCLSID(
            hkRoot,
            clsid,
            &bstrName,
            NULL,
            NULL));
    if (!hr)
    {
        // If we got the name, copy it and get out.
        _tcsncpy(szName, bstrName, cch);
        goto Cleanup;
    }

    // Next, try to get the AuxUserType name.
    Format(0, szUser, ARRAY_SIZE(szUser), _T("<0g>\\AuxUserType\\2"), &clsid);
    cb = cch * sizeof(TCHAR);
    err = TW32_NOTRACE(1, RegQueryValue(hkRoot, szUser, szName, &cb));
    if (err == ERROR_SUCCESS)
    {
        // If we got the name, get out.
        hr = S_OK;
        goto Cleanup;
    }

    // Finally, if nothing else worked, load unknown.
    if (LoadString(GetResourceHInst(), IDS_UNKNOWN, szName, cch))
        hr = S_OK;
    else
        hr = GetLastWin32Error();

Cleanup:
    FormsFreeString(bstrName);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetHelpForCLSID
//
//  Synopsis:   Gets the help for the CLSID.
//
//--------------------------------------------------------------------------

HRESULT
GetHelpForCLSID(
        HKEY hkRoot,
        REFCLSID clsid,
        DWORD * pdwId,
        TCHAR * szHelpFile,
        int cch)
{
    BSTR        bstrHelp = NULL;
    HRESULT     hr;

    // Get the help info for this classid.
    hr = THR_NOTRACE(GetDocumentationForCLSID(
            hkRoot,
            clsid,
            NULL,
            pdwId,
            &bstrHelp));
    if (hr)
        goto Cleanup;

    // If we didn't get a help path\name, then get out.
    if (!bstrHelp || !FormsStringLen(bstrHelp))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // If we got the name, copy it and get out.
    _tcsncpy(szHelpFile, bstrHelp, cch);

Cleanup:
    FormsFreeString(bstrHelp);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     OnDialogHelp
//
//  Synopsis:   Display dialog box's help
//
//--------------------------------------------------------------------------

HRESULT
OnDialogHelp(
        CBase * pBase,
        HELPINFO * phi, 
        DWORD dwHelpContextID) 
{
    HRESULT     hr;
    TCHAR       szPath[_MAX_PATH];
    HKEY        hkRoot = NULL;

    // Get the key to the CLSID root.
    hr = THR(RegDbOpenCLSIDKey(&hkRoot));
    if (hr)
        goto Cleanup;

    // Get the help file name.
    hr = THR_NOTRACE(GetHelpForCLSID(
            hkRoot,
            CLSID_HTMLDocument,
            NULL,
            szPath,
            ARRAY_SIZE(szPath)));
    if (hr)
        goto Cleanup;

    _tcscat(szPath, _T(">LangRef"));

    BOOL    fRet;
    
    fRet = WinHelp(
            TLS(gwnd.hwndGlobalWindow), 
            szPath, 
            HELP_CONTEXT, 
            dwHelpContextID);
    hr = THR(fRet ? S_OK : E_FAIL);
Cleanup:
    if (hkRoot)
        Verify(RegCloseKey(hkRoot) == ERROR_SUCCESS);
    RRETURN(hr);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\hashatomtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       hashatomtbl.cxx
//
//  History:    t-rajatg     Created
//
//  Contents:   CHashAtomTable implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HASHATOMTBL_HXX_
#define X_HASHATOMTBL_HXX_
#include "hashatomtbl.hxx"
#endif

MtDefine(CHashAtomTable, Utilities, "CHashAtomTable")
MtDefine(CHashAtomTable_pv, CHashAtomTable, "CHashAtomTable::_pv")
MtDefine(HashAtomTable, Mem, "CHashAtomTable")
MtDefine(Atom, HashAtomTable, "CHashAtomTable<SAtom>")
MtDefine(CIndexAtom_ary, HashAtomTable, "CIndexAtom_ary")
MtDefine(CHtEnt_ary, HashAtomTable, "CHtEnt_ary")

BOOL CHashAtomTable::CompareIt(const void *pObject, const void *pvKeyPassedIn, const void *pvVal2)
{
    CHtEnt *    pary;
    SAtom *     pAtom;
    SAtomProbe *pap;

    pap = (SAtomProbe*)pvKeyPassedIn;
    pary = (CHtEnt *)pvVal2;

    Assert( pary && pary->Size() );

    if (!pap->_fStatsComputed)
    {
        pap->_cch = CountWithAsciiCheck(pap->_pch, &(pap->_fAllAscii));
        pap->_fStatsComputed = TRUE;
    }

    pAtom = *((SAtom **)pary->Deref(sizeof(SAtom *), 0));

    if (    pAtom->_cch != pap->_cch
        ||  !!(BOOL)pAtom->_fAllAscii != !!(BOOL)pap->_fAllAscii)
        return FALSE;

    if (pap->_fAllAscii)
    {
        return !StrCmpNICW(pap->_pch, pAtom->_ach, pAtom->_cch);
    }
    else
    {
        return _tcsiequal(pAtom->_ach, pap->_pch);
    }
}
long 
CHashAtomTable::CountWithAsciiCheck(LPCTSTR pch, BOOL * pfAllAscii)
{
    WHEN_DBG( LPCTSTR pchOrig = pch );
    long cch = 0;
    *pfAllAscii = TRUE;

    while( *pch )
    {
        if (*pch > 0x7f)
            *pfAllAscii = FALSE;
        cch++;
        pch++;
    }

    Assert( (ULONG)cch == _tcslen(pchOrig) );

    return cch;
}

HRESULT
CHashAtomTable::AddNameToAtomTable(LPCTSTR pch, long *plId)
{
    HRESULT     hr = S_OK;
    long        lId = 0;
    long        cch;
    BOOL        fAllAscii;
    CHtEnt *    pPtrAry = NULL;
    SAtom *     pAtom = NULL;
    BOOL        fPtrAryNew = FALSE;

    Assert( pch );

    // Do a case sensitive search for the element
    if (GetAtomFromName(pch, NULL, &lId, TRUE, FALSE) != DISP_E_MEMBERNOTFOUND)
    {
        if (plId)
        {
            *plId = lId;
        }

        goto Cleanup;
    }

    //
    // Not found, so add element
    //
    Assert( _dwCacheHash != 0 );

    // Create the atom

    // count the string and look for ascii-ness
    cch = CountWithAsciiCheck(pch, &fAllAscii);

    pAtom = (SAtom *)MemAlloc(Mt(Atom), sizeof(SAtom) + sizeof(TCHAR)*(cch+1));
    if (!pAtom)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    Assert(lId == _aryId.Size());

    pAtom->_cch = cch;
    pAtom->_lId = lId;
    pAtom->_fAllAscii = fAllAscii;
    _tcsncpy(pAtom->_ach, pch, cch+1);

    // Add the atom to the id list
    hr = _aryId.Append(pAtom);
    if (hr)
        goto Error;

    // Add the atom to the case insensitive list
    {
        pPtrAry = _pHtCacheEnt;

        if (!pPtrAry)
        {
            pPtrAry = new CHtEnt;
            if (!pPtrAry)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
            fPtrAryNew = TRUE;
        }

        // Add new data to the end of Structure
        hr = pPtrAry->Append(pAtom);
        if (hr)
            goto Error;

        // Do insert
        if (fPtrAryNew)
        {
#if DBG==1
            SAtomProbe ap = {0};
            ap._pch = pch;
#endif

            hr = _htStr.Insert(ULongToPtr(_dwCacheHash), (void*)pPtrAry DBG_COMMA WHEN_DBG((void*)&ap) );
            if (hr)
                goto Error;
        }

    }

    if (plId)
    {
        *plId = lId;
    }

Cleanup:
    RRETURN(hr);

Error:
    // Clean up the atom
    delete pAtom;

    // Clean up _aryId
    _aryId.DeleteByValue(pAtom);

    // Clean up the pPtrAry
    if (fPtrAryNew)
    {
        delete pPtrAry;
    }
    else if (pPtrAry)
    {
        pPtrAry->DeleteByValue(pAtom);
    }

    // The hash table is the last thing we do, so no cleanup necessary

    goto Cleanup;
}

HRESULT
CHashAtomTable::AddNameWithID(LPCTSTR pch, long lId)
{
    HRESULT     hr = S_OK;
    SAtom *     pAtom = NULL;
    DWORD       dwCacheHash;
    BOOL        fAllAscii;
    CHtEnt *    pHtCacheEnt;
    BOOL        fHtEntNew = FALSE;
    long        cch;
    SAtomProbe	ap = {0};

    Assert( pch );

    // We shouldn't have this already in the table
    Assert( GetAtomFromName(pch, NULL, NULL, TRUE, FALSE) == DISP_E_MEMBERNOTFOUND );

    // The ID must be the next one in sequence
    Assert( lId == _aryId.Size() );

    dwCacheHash = HashStringCiDetectW(pch, _tcslen(pch), 0) << 2;
    if (dwCacheHash == 0)
        dwCacheHash = (1<<2);

    ap._pch = pch;

    if (S_OK != _htStr.LookupSlow(ULongToPtr(dwCacheHash), (void*)&ap, (void**)&pHtCacheEnt))
    {
        // We didn't find a case insensitive list in the hash table so add one
        pHtCacheEnt = new CHtEnt;
        if (!pHtCacheEnt)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        fHtEntNew = TRUE;

    }

    // Create the atom

    // count the string and look for ascii-ness
    cch = CountWithAsciiCheck(pch, &fAllAscii);

    pAtom = (SAtom *)MemAlloc(Mt(Atom), sizeof(SAtom) + sizeof(TCHAR)*(cch+1));
    if (!pAtom)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pAtom->_cch = cch;
    pAtom->_lId = lId;
    pAtom->_fAllAscii = fAllAscii;
    _tcsncpy(pAtom->_ach, pch, cch+1);

    // Append to the ID array
    hr = _aryId.Append(pAtom);
    if (hr)
        goto Error;

    // Append to the end of the case insensitive list
    hr = pHtCacheEnt->Append(pAtom);
    if (hr)
        goto Error;

    if (fHtEntNew)
    {
        // Do insert into hash table -- must come after pAtom is added to pHtCacheEnt
        hr = _htStr.Insert(ULongToPtr(dwCacheHash), (void*)pHtCacheEnt DBG_COMMA WHEN_DBG((void*)&ap) );
        if (hr)
            goto Error;
    }

Cleanup:
    RRETURN(hr);

Error:
    // Clean up pHtCacheEnt
    if (fHtEntNew)
    {
        // Make sure that _pHtCacheEnd is out of the hash table
        delete pHtCacheEnt;
    }
    else if (pHtCacheEnt)
    {
        pHtCacheEnt->DeleteByValue(pAtom);
    }

    // Clean up the atom
    delete pAtom;

    // Clean up _aryId
    _aryId.DeleteByValue(pAtom);

    // The hash table is the last thing we do, so no cleanup necessary

    goto Cleanup;
}

MtDefine(MHashAtomTable, Metrics, "Atom Table String Matching");
MtDefine(MHashAtomTableCsCmp, MHashAtomTable, "Atom Table Case Sensitive String Compares");
MtDefine(MHashAtomTableCsiCmp, MHashAtomTable, "Atom Table Case Insensitive String Compares");

/*************************************************************************************
 * GetAtomFromName
 *
 *************************************************************************************/
HRESULT
CHashAtomTable::GetAtomFromName(LPCTSTR pch, long *plIndex, /* Use this if fStartFromGivenIndex is needed */
                            long *plId, /* USE THIS to get the EXPANDO Index */
                            BOOL fCaseSensitive /*= TRUE */,
                            BOOL fStartFromGivenIndex /* = FALSE */)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;
    long        lId = _aryId.Size();
    BOOL        fFound = FALSE;
    SAtom *     patom = NULL;
    CHtEnt *    pPtrAry;

    Assert( pch );

    if (_aryId.Size() == 0)
    {
        _dwCacheHash = HashStringCiDetectW(pch, _tcslen(pch), 0) << 2;
        if (_dwCacheHash == 0)
            _dwCacheHash = (1<<2);

        _pHtCacheEnt = NULL;
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (fCaseSensitive && _fFound && _tcsequal(pch, _pchCache))
    {
        lId = _lId;
        lIndex = _lIndex;
        patom = _psaCache;
        fFound = TRUE;
        goto Cleanup;
    }

    _dwCacheHash = HashStringCiDetectW(pch, _tcslen(pch), 0) << 2;
    if (_dwCacheHash == 0)
        _dwCacheHash = (1<<2);

    {
        SAtomProbe ap = {0};
        ap._pch = pch;

        if (_htStr.LookupSlow(ULongToPtr(_dwCacheHash), (void*)&ap, (void**)&pPtrAry))
        {
            _pHtCacheEnt = NULL;
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
    }

    // We should have a case insensitive array at this point since
    // the lookup succeeded.
    Assert( pPtrAry );

    _pHtCacheEnt = pPtrAry;

    if (fStartFromGivenIndex)
    {
        // It doesn't make sence do iterate over
        // all case insensitive matches if fCaseSensitive
        // is passed in
        Assert(!fCaseSensitive);
        Assert( plIndex );

        lIndex = *plIndex;

        // Someone shouldn't initiate this loop with an index of 0
        Assert(lIndex > 0);

        if (lIndex >= pPtrAry->Size())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        patom = *((SAtom **)pPtrAry->Deref(sizeof(SAtom *), lIndex));

        Assert(_tcsiequal(patom->_ach, pch));

        lId = patom->_lId;
        fFound = TRUE;
    }
    else
    {
        if (fCaseSensitive)
        {
            for (int i = 0; i < pPtrAry->Size(); i += 1)
            {
                patom = *((SAtom **)pPtrAry->Deref(sizeof(SAtom *), i));

                if (_tcsequal(patom->_ach, pch))
                {
                    lId = patom->_lId;
                    lIndex = i;
                    fFound = TRUE;
                    break;
                }
            }
        }
        else
        {
            patom = *((SAtom **)pPtrAry->Deref(sizeof(SAtom *), 0));
            Assert(_tcsiequal(patom->_ach, pch));
            lId = patom->_lId;
            lIndex = 0;
            fFound = TRUE;
        }

        if (!fFound)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
    }

Cleanup:
    if (fFound && fCaseSensitive)
    {
        _fFound = TRUE;
        _lId = lId;
        _lIndex = lIndex;
        _pchCache = patom->_ach;
        _psaCache = patom;
    }
    else
        _fFound = FALSE;


    if (plIndex)
    {
        *plIndex = lIndex;
    }

    if (plId)
    {
        *plId = lId;
    }

    RRETURN(hr);
}

HRESULT
CHashAtomTable::GetNameFromAtom(long lId, LPCTSTR *ppch)
{
    HRESULT hr = S_OK;
    SAtom *  patom;

    if (_aryId.Size() <= lId)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    patom = (SAtom *)_aryId[lId];
    Assert(lId == patom->_lId);
    *ppch = (TCHAR *)patom->_ach;

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

void
CHashAtomTable::Free()
{
    SAtom *     patom;
    long        i;
    CHtEnt *    pary;
    UINT        iIndex;

    for (pary = (CHtEnt *)_htStr.GetFirstEntry(&iIndex);
         pary;
         pary = (CHtEnt *)_htStr.GetNextEntry(&iIndex))
    {
        Assert(pary);
        delete pary;
    }

    _htStr.ReInit();

    for (i = 0; i < _aryId.Size(); i++)
    {
        patom = _aryId[i];
        MemFree(patom);
    }
    _aryId.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\gwnd.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       gwnd.cxx
//
//  Contents:   Class implementation for CFormsGlobalWindow and helpers.
//
//--------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL     0x00400000L // Right to left mirroring
#else
#error "WS_EX_LAYOUTRTL is already defined in winuser.h"
#endif

PerfDbgTag(tagPerfWatch, "Perf", "PerfWatch: Trace MSHTML performance points")

MtDefine(THREADSTATE, PerThread, "THREADSTATE")
MtDefine(CTlsOptionAry, PerThread, "CTlsOptionAry::_pv")
MtDefine(CTlsDocAry, PerThread, "CTlsDocAry::_pv")
MtDefine(CTlsDocSvrAry, PerThread, "CTlsDocSvrAry::_pv")

#define WM_METHODCALL (WM_APP + 2)

extern void DwnCacheOnSettingsChange(WPARAM wParam, LPARAM lParam);

struct TIMERENTRY
{
    void *              pvObject;
    PFN_VOID_ONTICK     pfnOnTick;
    UINT                idTimer;
    UINT                idTimerAlias;
};


//this thing is for Win9x only, uses assumption that pointer and DWORD is the same size,
//so turn it off in compile for other platforms (like 64-bit)
#ifdef _M_IX86

/*
   Stack corruption protection for Win9x.

    16-bit code in Win9x GDI (and may be in User too) checks old 16-bit-world 
    assumption that at the very bottom of the stack (that can't be more then 64K 
    for this code) there is a "stack header" - 16-byte structure used to kep 
    local heep and atom table in 16-bit process...
    Of course when this code calls into 32-bit code and this 32-bit code eats 
    more then 64K of stack, it's possible to overwrite that "stack header" and, 
    depending on whether that area was overwritten, by what data and what 16-bit 
    code called us and some other things, we could get 16-bit GDI code to panic 
    about stack being trashed and bail and not to draw something.
    System seems to make an attempt to avoid such a problem (I can't tell for sure
    , but I think it's what I've seen in the debugger) in case when stack is not 
    yet commited into depth more then 64K. Then "stack header" is separated from 
    the stack by non-commited page(s) and system could see if that thing gets 
    overwritten. However if the stack was once quite extended, it could happen 
    that thunk will place "stack header" into a page that connects with stack by 
    contiguous range of commited pages so system doesn't get a chance to notice 16
    -bit stack overflow and can't correct it.
    The proposed fix is to save "stack header" on entry into our WindowProc and 
    restore it on exit. That involves walking 15 4K pages down starting from the 
    next page after the one pointed by ESP (we don't know where SS of 16-bit code is based) 
    and if any of them are commited - save 16bytes from the beginning into a buffer. 
    Restore on exit.

    The usage of this class - create an instance of it on stack on entry to WindProc
    and it will automatically do work in constructor/destructor.


    Note: the same is used in CServer::WndProc.
 */

CWin9xStackSave::CWin9xStackSave()
{
    if(VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        //start from the page that is next down the stack from the current one
        _startPageAddr = (((DWORD)this) - W95_PAGE_SIZE) & ~(W95_PAGE_SIZE-1);
        DWORD curPageAddr = _startPageAddr;
        for(int i=0; i<W95_STACK_MAX_PAGES; i++)
        {

            MEMORY_BASIC_INFORMATION pageInfo;
            if(    VirtualQuery((void*)curPageAddr, &pageInfo, sizeof(pageInfo))
                && pageInfo.Protect == PAGE_READWRITE
                && pageInfo.State == MEM_COMMIT
              )
            {
                memcpy(_buffer + i*W95_STACK_BUF_SIZE, (void*)curPageAddr, W95_STACK_BUF_SIZE);
                _fSaved[i] = true;
            }    
            else
                _fSaved[i] = false;
            
            curPageAddr -= W95_PAGE_SIZE;
        }
    }
}

CWin9xStackSave::~CWin9xStackSave()
{
    if(VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        //need two passes because first is calling into kernel and who knows
        //how much stack they consume so they can override what we are restoring.

        int i;
        DWORD curPageAddr = _startPageAddr;
        for(i=0; i<W95_STACK_MAX_PAGES; i++)
        {
            if(_fSaved[i])
            {
                //need to probe again because pages can become un-commited bacause 
                MEMORY_BASIC_INFORMATION pageInfo;
                if(    !VirtualQuery((void*)curPageAddr, &pageInfo, sizeof(pageInfo))
                    || pageInfo.Protect != PAGE_READWRITE
                    || pageInfo.State != MEM_COMMIT
                  )
                {
                    _fSaved[i] = false; //if page become not accessible, don't restore it
                }
            }
            curPageAddr -= W95_PAGE_SIZE;
        }

        curPageAddr = _startPageAddr;
        for(i=0; i<W95_STACK_MAX_PAGES; i++)
        {
            if(_fSaved[i])
            {
                memcpy((void*)curPageAddr, _buffer + i*W95_STACK_BUF_SIZE, W95_STACK_BUF_SIZE);
            }
            curPageAddr -= W95_PAGE_SIZE;
        }
    }
}

#endif

// We have to do this because of the forward declare in thread state.
MtDefine(CAryTimers, PerThread, "CAryTimers")
MtDefine(CAryTimers_pv, CAryTimers, "CAryTimers::_pv")
DECLARE_CDataAry(CAryTimers, TIMERENTRY, Mt(CAryTimers), Mt(CAryTimers_pv))

struct CALLENTRY
{
    void *              pvObject;
    PFN_VOID_ONCALL     pfnOnCall;
    DWORD_PTR           dwContext;
#if DBG==1 || defined(PERFTAGS)
    char *              pszOnCall;
#endif
};

// We have to do this because of the forward declare in thread state.

MtDefine(CAryCalls, PerThread, "CAryCalls")
MtDefine(CAryCalls_pv, CAryCalls, "CAryCalls::_pv")
DECLARE_CDataAry(CAryCalls, CALLENTRY, Mt(CAryCalls), Mt(CAryCalls_pv))

// Menu stuff

static void  *              s_pvCommand = NULL;
static PFN_VOID_ONCOMMAND   s_pfnOnCommand;

// Mouse capture

LRESULT CALLBACK GWMouseProc(int  nCode, WPARAM  wParam, LPARAM  lParam);

extern void                 DllUpdateSettings(UINT msg);

#if DBG==1 || defined(PERFTAGS)
char *
DecodeMessage(UINT msg)
{
    switch (msg)
    {
        case WM_NULL:               return("WM_NULL");
        case WM_CREATE:             return("WM_CREATE");
        case WM_DESTROY:            return("WM_DESTROY");
        case WM_MOVE:               return("WM_MOVE");
        case WM_SIZE:               return("WM_SIZE");
        case WM_ACTIVATE:           return("WM_ACTIVATE");
        case WM_SETFOCUS:           return("WM_SETFOCUS");
        case WM_KILLFOCUS:          return("WM_KILLFOCUS");
        case WM_ENABLE:             return("WM_ENABLE");
        case WM_SETREDRAW:          return("WM_SETREDRAW");
        case WM_SETTEXT:            return("WM_SETTEXT");
        case WM_GETTEXT:            return("WM_GETTEXT");
        case WM_GETTEXTLENGTH:      return("WM_GETTEXTLENGTH");
        case WM_PAINT:              return("WM_PAINT");
        case WM_CLOSE:              return("WM_CLOSE");
        case WM_QUERYENDSESSION:    return("WM_QUERYENDSESSION");
        case WM_QUERYOPEN:          return("WM_QUERYOPEN");
        case WM_ENDSESSION:         return("WM_ENDSESSION");
        case WM_QUIT:               return("WM_QUIT");
        case WM_ERASEBKGND:         return("WM_ERASEBKGND");
        case WM_SYSCOLORCHANGE:     return("WM_SYSCOLORCHANGE");
        case WM_THEMECHANGED :      return("WM_THEMECHANGED");
        case WM_SHOWWINDOW:         return("WM_SHOWWINDOW");
        case WM_WININICHANGE:       return("WM_WININICHANGE");
        case WM_DEVMODECHANGE:      return("WM_DEVMODECHANGE");
        case WM_ACTIVATEAPP:        return("WM_ACTIVATEAPP");
        case WM_FONTCHANGE:         return("WM_FONTCHANGE");
        case WM_TIMECHANGE:         return("WM_TIMECHANGE");
        case WM_CANCELMODE:         return("WM_CANCELMODE");
        case WM_SETCURSOR:          return("WM_SETCURSOR");
        case WM_MOUSEACTIVATE:      return("WM_MOUSEACTIVATE");
        case WM_CHILDACTIVATE:      return("WM_CHILDACTIVATE");
        case WM_QUEUESYNC:          return("WM_QUEUESYNC");
        case WM_GETMINMAXINFO:      return("WM_GETMINMAXINFO");
        case WM_PAINTICON:          return("WM_PAINTICON");
        case WM_ICONERASEBKGND:     return("WM_ICONERASEBKGND");
        case WM_NEXTDLGCTL:         return("WM_NEXTDLGCTL");
        case WM_SPOOLERSTATUS:      return("WM_SPOOLERSTATUS");
        case WM_DRAWITEM:           return("WM_DRAWITEM");
        case WM_MEASUREITEM:        return("WM_MEASUREITEM");
        case WM_DELETEITEM:         return("WM_DELETEITEM");
        case WM_VKEYTOITEM:         return("WM_VKEYTOITEM");
        case WM_CHARTOITEM:         return("WM_CHARTOITEM");
        case WM_SETFONT:            return("WM_SETFONT");
        case WM_GETFONT:            return("WM_GETFONT");
        case WM_SETHOTKEY:          return("WM_SETHOTKEY");
        case WM_GETHOTKEY:          return("WM_GETHOTKEY");
        case WM_QUERYDRAGICON:      return("WM_QUERYDRAGICON");
        case WM_COMPAREITEM:        return("WM_COMPAREITEM");
        case WM_COMPACTING:         return("WM_COMPACTING");
        case WM_COMMNOTIFY:         return("WM_COMMNOTIFY");
        case WM_WINDOWPOSCHANGING:  return("WM_WINDOWPOSCHANGING");
        case WM_WINDOWPOSCHANGED:   return("WM_WINDOWPOSCHANGED");
        case WM_POWER:              return("WM_POWER");
        case WM_COPYDATA:           return("WM_COPYDATA");
        case WM_CANCELJOURNAL:      return("WM_CANCELJOURNAL");
        case WM_NOTIFY:             return("WM_NOTIFY");
        case WM_INPUTLANGCHANGEREQUEST: return("WM_INPUTLANGCHANGEREQUEST");
        case WM_INPUTLANGCHANGE:    return("WM_INPUTLANGCHANGE");
        case WM_TCARD:              return("WM_TCARD");
        case WM_HELP:               return("WM_HELP");
        case WM_USERCHANGED:        return("WM_USERCHANGED");
        case WM_NOTIFYFORMAT:       return("WM_NOTIFYFORMAT");
        case WM_CONTEXTMENU:        return("WM_CONTEXTMENU");
        case WM_STYLECHANGING:      return("WM_STYLECHANGING");
        case WM_STYLECHANGED:       return("WM_STYLECHANGED");
        case WM_DISPLAYCHANGE:      return("WM_DISPLAYCHANGE");
        case WM_GETICON:            return("WM_GETICON");
        case WM_SETICON:            return("WM_SETICON");
        case WM_NCCREATE:           return("WM_NCCREATE");
        case WM_NCDESTROY:          return("WM_NCDESTROY");
        case WM_NCCALCSIZE:         return("WM_NCCALCSIZE");
        case WM_NCHITTEST:          return("WM_NCHITTEST");
        case WM_NCPAINT:            return("WM_NCPAINT");
        case WM_NCACTIVATE:         return("WM_NCACTIVATE");
        case WM_GETDLGCODE:         return("WM_GETDLGCODE");
        case WM_SYNCPAINT:          return("WM_SYNCPAINT");
        case WM_NCMOUSEMOVE:        return("WM_NCMOUSEMOVE");
        case WM_NCLBUTTONDOWN:      return("WM_NCLBUTTONDOWN");
        case WM_NCLBUTTONUP:        return("WM_NCLBUTTONUP");
        case WM_NCLBUTTONDBLCLK:    return("WM_NCLBUTTONDBLCLK");
        case WM_NCRBUTTONDOWN:      return("WM_NCRBUTTONDOWN");
        case WM_NCRBUTTONUP:        return("WM_NCRBUTTONUP");
        case WM_NCRBUTTONDBLCLK:    return("WM_NCRBUTTONDBLCLK");
        case WM_NCMBUTTONDOWN:      return("WM_NCMBUTTONDOWN");
        case WM_NCMBUTTONUP:        return("WM_NCMBUTTONUP");
        case WM_NCMBUTTONDBLCLK:    return("WM_NCMBUTTONDBLCLK");
        case WM_KEYDOWN:            return("WM_KEYDOWN");
        case WM_KEYUP:              return("WM_KEYUP");
        case WM_CHAR:               return("WM_CHAR");
        case WM_DEADCHAR:           return("WM_DEADCHAR");
        case WM_SYSKEYDOWN:         return("WM_SYSKEYDOWN");
        case WM_SYSKEYUP:           return("WM_SYSKEYUP");
        case WM_SYSCHAR:            return("WM_SYSCHAR");
        case WM_SYSDEADCHAR:        return("WM_SYSDEADCHAR");
        case WM_IME_STARTCOMPOSITION:   return("WM_IME_STARTCOMPOSITION");
        case WM_IME_ENDCOMPOSITION: return("WM_IME_ENDCOMPOSITION");
        case WM_IME_COMPOSITION:    return("WM_IME_COMPOSITION");
        case WM_INITDIALOG:         return("WM_INITDIALOG");
        case WM_COMMAND:            return("WM_COMMAND");
        case WM_SYSCOMMAND:         return("WM_SYSCOMMAND");
        case WM_TIMER:              return("WM_TIMER");
        case WM_HSCROLL:            return("WM_HSCROLL");
        case WM_VSCROLL:            return("WM_VSCROLL");
        case WM_INITMENU:           return("WM_INITMENU");
        case WM_INITMENUPOPUP:      return("WM_INITMENUPOPUP");
        case WM_MENUSELECT:         return("WM_MENUSELECT");
        case WM_MENUCHAR:           return("WM_MENUCHAR");
        case WM_ENTERIDLE:          return("WM_ENTERIDLE");
        case WM_CTLCOLORMSGBOX:     return("WM_CTLCOLORMSGBOX");
        case WM_CTLCOLOREDIT:       return("WM_CTLCOLOREDIT");
        case WM_CTLCOLORLISTBOX:    return("WM_CTLCOLORLISTBOX");
        case WM_CTLCOLORBTN:        return("WM_CTLCOLORBTN");
        case WM_CTLCOLORDLG:        return("WM_CTLCOLORDLG");
        case WM_CTLCOLORSCROLLBAR:  return("WM_CTLCOLORSCROLLBAR");
        case WM_CTLCOLORSTATIC:     return("WM_CTLCOLORSTATIC");
        case WM_MOUSEMOVE:          return("WM_MOUSEMOVE");
        case WM_LBUTTONDOWN:        return("WM_LBUTTONDOWN");
        case WM_LBUTTONUP:          return("WM_LBUTTONUP");
        case WM_LBUTTONDBLCLK:      return("WM_LBUTTONDBLCLK");
        case WM_RBUTTONDOWN:        return("WM_RBUTTONDOWN");
        case WM_RBUTTONUP:          return("WM_RBUTTONUP");
        case WM_RBUTTONDBLCLK:      return("WM_RBUTTONDBLCLK");
        case WM_MBUTTONDOWN:        return("WM_MBUTTONDOWN");
        case WM_MBUTTONUP:          return("WM_MBUTTONUP");
        case WM_MBUTTONDBLCLK:      return("WM_MBUTTONDBLCLK");
        case WM_MOUSEWHEEL:         return("WM_MOUSEWHEEL");
        case WM_PARENTNOTIFY:       return("WM_PARENTNOTIFY");
        case WM_ENTERMENULOOP:      return("WM_ENTERMENULOOP");
        case WM_EXITMENULOOP:       return("WM_EXITMENULOOP");
        case WM_NEXTMENU:           return("WM_NEXTMENU");
        case WM_SIZING:             return("WM_SIZING");
        case WM_CAPTURECHANGED:     return("WM_CAPTURECHANGED");
        case WM_MOVING:             return("WM_MOVING");
        case WM_POWERBROADCAST:     return("WM_POWERBROADCAST");
        case WM_DEVICECHANGE:       return("WM_DEVICECHANGE");
        case WM_MDICREATE:          return("WM_MDICREATE");
        case WM_MDIDESTROY:         return("WM_MDIDESTROY");
        case WM_MDIACTIVATE:        return("WM_MDIACTIVATE");
        case WM_MDIRESTORE:         return("WM_MDIRESTORE");
        case WM_MDINEXT:            return("WM_MDINEXT");
        case WM_MDIMAXIMIZE:        return("WM_MDIMAXIMIZE");
        case WM_MDITILE:            return("WM_MDITILE");
        case WM_MDICASCADE:         return("WM_MDICASCADE");
        case WM_MDIICONARRANGE:     return("WM_MDIICONARRANGE");
        case WM_MDIGETACTIVE:       return("WM_MDIGETACTIVE");
        case WM_MDISETMENU:         return("WM_MDISETMENU");
        case WM_ENTERSIZEMOVE:      return("WM_ENTERSIZEMOVE");
        case WM_EXITSIZEMOVE:       return("WM_EXITSIZEMOVE");
        case WM_DROPFILES:          return("WM_DROPFILES");
        case WM_MDIREFRESHMENU:     return("WM_MDIREFRESHMENU");
        case WM_IME_SETCONTEXT:     return("WM_IME_SETCONTEXT");
        case WM_IME_NOTIFY:         return("WM_IME_NOTIFY");
        case WM_IME_CONTROL:        return("WM_IME_CONTROL");
        case WM_IME_COMPOSITIONFULL:    return("WM_IME_COMPOSITIONFULL");
        case WM_IME_SELECT:         return("WM_IME_SELECT");
        case WM_IME_CHAR:           return("WM_IME_CHAR");
        case WM_IME_KEYDOWN:        return("WM_IME_KEYDOWN");
        case WM_IME_KEYUP:          return("WM_IME_KEYUP");
        case WM_MOUSEHOVER:         return("WM_MOUSEHOVER");
        case WM_MOUSELEAVE:         return("WM_MOUSELEAVE");
        case WM_CUT:                return("WM_CUT");
        case WM_COPY:               return("WM_COPY");
        case WM_PASTE:              return("WM_PASTE");
        case WM_CLEAR:              return("WM_CLEAR");
        case WM_UNDO:               return("WM_UNDO");
        case WM_RENDERFORMAT:       return("WM_RENDERFORMAT");
        case WM_RENDERALLFORMATS:   return("WM_RENDERALLFORMATS");
        case WM_DESTROYCLIPBOARD:   return("WM_DESTROYCLIPBOARD");
        case WM_DRAWCLIPBOARD:      return("WM_DRAWCLIPBOARD");
        case WM_PAINTCLIPBOARD:     return("WM_PAINTCLIPBOARD");
        case WM_VSCROLLCLIPBOARD:   return("WM_VSCROLLCLIPBOARD");
        case WM_SIZECLIPBOARD:      return("WM_SIZECLIPBOARD");
        case WM_ASKCBFORMATNAME:    return("WM_ASKCBFORMATNAME");
        case WM_CHANGECBCHAIN:      return("WM_CHANGECBCHAIN");
        case WM_HSCROLLCLIPBOARD:   return("WM_HSCROLLCLIPBOARD");
        case WM_QUERYNEWPALETTE:    return("WM_QUERYNEWPALETTE");
        case WM_PALETTEISCHANGING:  return("WM_PALETTEISCHANGING");
        case WM_PALETTECHANGED:     return("WM_PALETTECHANGED");
        case WM_HOTKEY:             return("WM_HOTKEY");
        case WM_PRINT:              return("WM_PRINT");
        case WM_PRINTCLIENT:        return("WM_PRINTCLIENT");
        case WM_USER:               return("WM_USER");
        case WM_USER+1:             return("WM_USER+1");
        case WM_USER+2:             return("WM_USER+2");
        case WM_USER+3:             return("WM_USER+3");
        case WM_USER+4:             return("WM_USER+4");
    }

    return("");
}

char *
DecodeWindowClass(HWND hwnd)
{
    static char ach[40];
    ach[0] = 0;
    GetClassNameA(hwnd, ach, sizeof(ach));
    return(ach);
}

#endif

//+-------------------------------------------------------------------------
//
//  Method:     ResetTimer
//
//  Synopsis:   Resets the timer identified by dwCookie.  ResetTimer
//              results in the timer setting being changed for the
//              given timer without allocating a new, unique timer id.
//
//--------------------------------------------------------------------------

static HRESULT
ResetTimer(void * pvObject, UINT idTimer, UINT uTimeout)
{
    TIMERENTRY *    pte;
    int             c;
    THREADSTATE *   pts = GetThreadState();

    // Windows NT rounds the time up to 10.  If time is less 
    // than 10, NT spews to the debugger.  Work around
    // this problem by rounding up to 10.

    if (uTimeout < 10)
        uTimeout = 10;

    for (c = pts->gwnd.paryTimers->Size(), pte = *pts->gwnd.paryTimers;
        c > 0;
        c--, pte++)
    {
        if ((pte->pvObject == pvObject) && (pte->idTimer == idTimer))
        {
            if (SetTimer(pts->gwnd.hwndGlobalWindow,
                    pte->idTimerAlias, uTimeout, NULL) == 0)
            {
                RRETURN(E_FAIL);
            }

            return S_OK;
        }
    }

    return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     OnTimer
//
//  Synopsis:   Handles timer event from the global window.
//
//--------------------------------------------------------------------------

static void  CALLBACK
OnTimer(HWND hwnd, UINT id)
{
    TIMERENTRY *    pte;
    int             c;
    THREADSTATE *   pts = GetThreadState();

    PerfDbgLog(tagPerfWatch, NULL, "+Gwnd OnTimer");

    for (c = pts->gwnd.paryTimers->Size(), pte = *pts->gwnd.paryTimers;
        c > 0;
        c--, pte++)
    {
        if (pte->idTimerAlias == id)
        {
            PerfDbgLog(tagPerfWatch, NULL, "+Gwnd OnTimer OnTick");

            CALL_METHOD((CVoid *)pte->pvObject,pte->pfnOnTick,(pte->idTimer));

            PerfDbgLog(tagPerfWatch, NULL, "-Gwnd OnTimer OnTick");

            break;
        }
    }

    PerfDbgLog(tagPerfWatch, NULL, "-Gwnd OnTimer");
}


//+-------------------------------------------------------------------------
//
//  Method:     OnCommand
//
//  Synopsis:   Handles menu commands.
//
//--------------------------------------------------------------------------

static void
OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (s_pvCommand != NULL)
    {
        CALL_METHOD((CVoid *)s_pvCommand, s_pfnOnCommand, (id, hwndCtl, codeNotify));
        s_pvCommand = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     GetUniqueID
//
//  Synopsis:   Fetches a unique timer ID by checking our sorted array
//              of used IDs for a new value.
//
//--------------------------------------------------------------------------

static UINT
GetUniqueID()
{
    THREADSTATE *   pts;
    int             c;
    TIMERENTRY *    pte;
    BOOL            fDone = FALSE;

    pts = GetThreadState();
    while (fDone == FALSE)
    {
        pts->gwnd.uID++;

        // Note: We don't use the range 0x0000 through 0x1FFF.  This is
        // reserved for hard-coded timer identifiers.  Compuserve incorrectly
        // intercepts timer id 0x000F, which is yet another reason for doing
        // this.

        if (pts->gwnd.uID < 0x2000)
        {
            pts->gwnd.uID = 0x2000;
        }

        fDone = TRUE;

        for (c = (*(pts->gwnd.paryTimers)).Size(), pte = *(pts->gwnd.paryTimers);
            c > 0;
            c--, pte++)
        {
            if (pts->gwnd.uID == pte->idTimerAlias)
            {
                fDone = FALSE;
                break;
            }
        }
    }

    return pts->gwnd.uID;
}

//+-------------------------------------------------------------------------
//
//  Function:   FormsSetTimer
//
//  Synopsis:   Sets a timer using the forms global window.
//
//  Arguments:  [pGWS]      Pointer to a timer sink
//              [idTimer]   Caller-specified id that will be passed back
//                          on a timer event.
//              [uTimeout]  Elapsed time between timer events
//
//--------------------------------------------------------------------------

HRESULT
FormsSetTimer(
        void *pvObject,
        PFN_VOID_ONTICK pfnOnTick,
        UINT idTimer, UINT uTimeout)
{
    THREADSTATE *   pts;
    UINT            idTimerAlias;
    HRESULT         hr;

    Assert(pvObject);

    pts = GetThreadState();

    if (pts->gwnd.hwndGlobalWindow == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Attempt to reset the timer.  If this fails, ie, no matching
    //  timer exists, continue on and set the timer.
    //

    hr = ResetTimer(pvObject, idTimer, uTimeout);
    if (hr == S_OK)
        goto Cleanup;

    hr = (*(pts->gwnd.paryTimers)).EnsureSize((*(pts->gwnd.paryTimers)).Size() + 1);
    if (hr)
        goto Cleanup;

    idTimerAlias = GetUniqueID();

    if (    g_dwPlatformID == VER_PLATFORM_WIN32_NT
        &&  g_dwPlatformVersion >= 0x00050000
        )
    {
        // NOTE
        // Windows NT 5.0 rounds the time up to 10.  If time is less 
        // than 10, it spews to the debugger.  Work around
        // this problem by rounding up to 10.

        if (uTimeout < 10)
            uTimeout = 10;
    }

    if (SetTimer(pts->gwnd.hwndGlobalWindow, idTimerAlias, uTimeout, NULL) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].pvObject = pvObject;
    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].pfnOnTick = pfnOnTick;
    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].idTimerAlias = idTimerAlias;
    (*(pts->gwnd.paryTimers))[(*(pts->gwnd.paryTimers)).Size()].idTimer = idTimer;
    (*(pts->gwnd.paryTimers)).SetSize((*(pts->gwnd.paryTimers)).Size() + 1);

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Function:   FormsKillTimer
//
//  Synopsis:   Kills a forms timer.
//
//  Arguments:  [dwCookie]  Cookie identifying the timer.  Obtained from
//                          FormsSetTimer.
//
//--------------------------------------------------------------------------

HRESULT
FormsKillTimer(void * pvObject, UINT idTimer)
{
    extern DWORD g_dwTls;
    THREADSTATE *   pts;
    TIMERENTRY *    pte;
    int             i, c;
    UINT            idTimerAlias;

    // Note: We do not use pts = GetThreadState() function because
    // this function is called from the DLL process detach
    // code after TlsGetValue() has ceased to function correctly.
    // This scenario is probably a result of a bug in Windows '95.
    pts = (THREADSTATE *)(TlsGetValue(g_dwTls));
    if (!pts || pts->gwnd.paryTimers == NULL)
        return S_FALSE;

    for (c = (*(pts->gwnd.paryTimers)).Size(), i = 0, pte = (*(pts->gwnd.paryTimers));
        c > 0;
        c--, i++, pte++)
    {
        if ((pte->pvObject == pvObject) && (pte->idTimer == idTimer))
        {
            idTimerAlias = pte->idTimerAlias;
            (*(pts->gwnd.paryTimers)).Delete(i);
            KillTimer(TLS(gwnd.hwndGlobalWindow), idTimerAlias);
            return S_OK;
        }
    }
    return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   FormsTrackPopupMenu
//
//  Synopsis:   Allows windowless controls to use the global window for
//              command routing of popup menu selection.
//
//--------------------------------------------------------------------------

HRESULT
FormsTrackPopupMenu(
        HMENU hMenu,
        UINT fuFlags,
        int x,
        int y,
        HWND hwndMessage,
        int *piSelection)
{
    BOOL    fAvail;
    HRESULT hr = S_OK;
    MSG     msg;
    HWND    hwnd;

    hwnd = (hwndMessage) ? (hwndMessage) : (TLS(gwnd.hwndGlobalWindow));

    if (::TrackPopupMenu(hMenu, fuFlags, x, y, 0, hwnd, (RECT *)NULL))
    {
        // The menu popped up and the item was chosen.  Peek messages
        // until the specified command was found.
        fAvail = PeekMessage(&msg,
            hwnd,
            WM_COMMAND,
            WM_COMMAND,
            PM_REMOVE);

        if (fAvail)
        {
            *piSelection = GET_WM_COMMAND_ID(msg.wParam, msg.lParam);
            hr = S_OK;
        }
        else
        {
            // No WM_COMMAND was available, so this means that the
            // menu was brought down
            hr = S_FALSE;
        }
    }
    else
    {
        hr = GetLastWin32Error();
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Function:   InvalidateProcessWindow
//
//--------------------------------------------------------------------------

static BOOL CALLBACK
InvalidateProcessWindow(HWND hwnd, LPARAM lparam)
{
    DWORD dwProcessId;

    GetWindowThreadProcessId(hwnd, &dwProcessId);
    if (dwProcessId == (DWORD)lparam && hwnd)
    {
        RedrawWindow(
            hwnd,
            NULL,
            NULL,
            RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
    }
    return TRUE;
}

void InvalidateProcessWindows()
{
    EnumWindows(InvalidateProcessWindow, GetCurrentProcessId());
}

//+-------------------------------------------------------------------------
//
//  Function:   _GWPostMethodCallEx
//
//  Synopsis:   Call given method on given object a later time.
//              It is the caller's responsiblity to insure that the
//              object remains valid until the call is made or the
//              posted call is killed.
//
//  Arguments:  pvObject    The object
//              pfnOnCall   Method to call.
//              dwContext   Context for method
//
//--------------------------------------------------------------------------

HRESULT _GWPostMethodCallEx(THREADSTATE * pts, void *pvObject,
    PFN_VOID_ONCALL pfnOnCall, DWORD_PTR dwContext, BOOL fIgnoreContext
#if DBG==1 || defined(PERFTAGS)
    , char * pszOnCall
#endif
    )
{
    HRESULT         hr;
    CALLENTRY *     pce;
    int             c;

    EnterCriticalSection(&pts->gwnd.cs);

    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject == pvObject &&
            pce->pfnOnCall == pfnOnCall &&
            pce->dwContext == dwContext &&
            !fIgnoreContext)
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    c = pts->gwnd.paryCalls->Size();

    hr = (*(pts->gwnd.paryCalls)).EnsureSize(c + 1);
    if (hr)
        goto Cleanup;

    (*(pts->gwnd.paryCalls)).SetSize(c + 1);

    pce = &(*(pts->gwnd.paryCalls))[c];

    pce->pvObject = pvObject;
    pce->pfnOnCall = pfnOnCall;
    pce->dwContext = dwContext;

#if DBG==1 || defined(PERFTAGS)
    pce->pszOnCall = pszOnCall;
#endif

    if (!pts->gwnd.fMethodCallPosted)
    {
        if (!PostMessage(pts->gwnd.hwndGlobalWindow, WM_METHODCALL, 0, 0))
        {
            hr = GetLastWin32Error();

            // If PostMessage failed, we need to remove the CALLENTRY we just added, or
            // someone's going to get a callback they're not expecting!
            (*(pts->gwnd.paryCalls)).SetSize(c);
            goto Cleanup;
        }

        pts->gwnd.fMethodCallPosted = TRUE;
    }

Cleanup:
    LeaveCriticalSection(&pts->gwnd.cs);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   GWKillMethodCallEx
//
//  Synopsis:   Kill method call posted with GWPostMethodCall.
//
//  Arguments:  pvObject    The object
//              pfnOnCall   Method to call.  If null, kills all calls
//                          for pvObject.
//              dwContext   Context.  If zero, kills all calls for pvObject
//                          and pfnOnCall.
//
//--------------------------------------------------------------------------

void
GWKillMethodCallEx(THREADSTATE * pts, void *pvObject, PFN_VOID_ONCALL pfnOnCall,
    DWORD_PTR dwContext)
{
    CALLENTRY *     pce;
    int             c;

    // Handle pts being NULL for
    Assert(pts);

    // check for no calls before entering critical section
    if (!pts || !(pts->gwnd.paryCalls) || (pts->gwnd.paryCalls->Size() == 0))
        return;

    EnterCriticalSection(&pts->gwnd.cs);

    // Null pointer instead of deleting array element to
    // handle calls to this function when OnMethodCall
    // is iterating over the array.

    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject == pvObject)
        {
            if (pfnOnCall == NULL)
            {
                pce->pvObject = NULL;
            }
            else if (pce->pfnOnCall == pfnOnCall)
            {
                if (pce->dwContext == dwContext || dwContext == 0)
                {
                    pce->pvObject = NULL;
                }
            }
        }
    }

    LeaveCriticalSection(&pts->gwnd.cs);
}

void
GWKillMethodCall(void *pvObject, PFN_VOID_ONCALL pfnOnCall, DWORD_PTR dwContext)
{
    GWKillMethodCallEx(GetThreadState(), pvObject, pfnOnCall, dwContext);
}

#if DBG == 1

BOOL
GWHasPostedMethod( void *pvObject )
{
    extern DWORD    g_dwTls;
    THREADSTATE *   pts = (THREADSTATE *)(TlsGetValue(g_dwTls));
    CALLENTRY *     pce;
    int             c;
    BOOL            fRet = FALSE;

    if (!pts)
        return FALSE;

    EnterCriticalSection(&pts->gwnd.cs);

    // Null pointer instead of deleting array element to
    // handle calls to this function when OnMethodCall
    // is iterating over the array.

    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject == pvObject)
        {
            fRet = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&pts->gwnd.cs);

    return fRet;
}

#endif

//+-------------------------------------------------------------------------
//
//  Funciton:   GlobalWndOnMethodCall
//
//  Synopsis:   Handles deferred method calls.
//
//--------------------------------------------------------------------------

void
GlobalWndOnMethodCall()
{
    THREADSTATE *   pts = GetThreadState();
    CALLENTRY *     pce;
    CALLENTRY *     pceLive;
    int             i;
    int             c;

    PerfDbgLog(tagPerfWatch, NULL, "+Gwnd OnMethodCall");

    //
    // Re-enable posting of layout messages because the function call
    // could cause us to enter a modal loop and then OnMethodCall would
    // not process further messages.  This will happen if the function
    // call fires an event procedure that calls Userform.Show in VB.
    //

    EnterCriticalSection(&pts->gwnd.cs);

    pts->gwnd.fMethodCallPosted = FALSE;

    // Stress bug fix for bug # 31985.
    if (! pts->gwnd.paryCalls)
        goto Cleanup;

    for (i = 0; i < (*(pts->gwnd.paryCalls)).Size(); i++)
    {
        // Pointer into array is fetched at every iteration in order
        // to handle calls to GWPostMethodCall during the loop.

        pce = &(*(pts->gwnd.paryCalls))[i];
        if (pce->pvObject)
        {
            CALLENTRY ce = *pce;
            pce->pvObject = NULL;

            LeaveCriticalSection(&pts->gwnd.cs);

            PerfDbgLog1(tagPerfWatch, NULL, "+Gwnd OnMethodCall (%s)", ce.pszOnCall);

            CALL_METHOD((CVoid *)ce.pvObject, ce.pfnOnCall, (ce.dwContext));

            PerfDbgLog1(tagPerfWatch, NULL, "-Gwnd OnMethodCall (%s)", ce.pszOnCall);

            EnterCriticalSection(&pts->gwnd.cs);

            //
            // DO NOT USE pce after the method call - if the object calls
            // GWPostMethodCall it may cause gwnd.paryCalls to do a ReAlloc,
            // which invalidates pce!
            //

            // Stress bug fix for bug # 31985.  pts->gwnd.paryCalls could be
            // deleted during the method call above.
            if (! pts->gwnd.paryCalls)
                goto Cleanup;
        }
    }

    pceLive = (*(pts->gwnd.paryCalls));
    i = 0;
    for (c = (*(pts->gwnd.paryCalls)).Size(), pce = (*(pts->gwnd.paryCalls));
        c > 0;
        c--, pce++)
    {
        if (pce->pvObject)
        {
            *pceLive++ = *pce;
            i++;
        }
    }

    (*(pts->gwnd.paryCalls)).SetSize(i);

Cleanup:
    LeaveCriticalSection(&pts->gwnd.cs);

    PerfDbgLog(tagPerfWatch, NULL, "-Gwnd OnMethodCall");
}

//+-------------------------------------------------------------------------
//
//  Function:   GWSetCapture
//
//  Synopsis:   Capture the mouse.
//
//--------------------------------------------------------------------------

HRESULT
GWSetCapture(void *pvObject, PFN_VOID_ONMESSAGE pfnOnMouseMessage, HWND hwnd)
{
    THREADSTATE *   pts;

    Assert(pvObject);

    pts = GetThreadState();

    if (pvObject != pts->gwnd.pvCapture)
    {
        if (pts->gwnd.pvCapture)
            CALL_METHOD((CVoid *)pts->gwnd.pvCapture, pts->gwnd.pfnOnMouseMessage,
                        (WM_CAPTURECHANGED, 0, 0));
        pts->gwnd.pvCapture = pvObject;
        pts->gwnd.pfnOnMouseMessage = pfnOnMouseMessage;
        pts->gwnd.hwndCapture = hwnd;
    }

    if (GetCapture() != TLS(gwnd.hwndGlobalWindow))
    {
        SetCapture(TLS(gwnd.hwndGlobalWindow));

        if (((g_dwPlatformID == VER_PLATFORM_WIN32_NT) ||
             (g_dwPlatformID == VER_PLATFORM_WIN32_UNIX)) &&
            !pts->gwnd.hhookGWMouse)
        {
            pts->gwnd.hhookGWMouse = SetWindowsHookEx(
                                           WH_MOUSE,
                                           GWMouseProc,
                                           (HINSTANCE) NULL, GetCurrentThreadId());
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   GWReleaseCapture
//
//  Synopsis:   Release the mouse capture.
//
//--------------------------------------------------------------------------

void
GWReleaseCapture(void *pvObject)
{
    THREADSTATE *   pts;

    Assert(pvObject);

    pts = GetThreadState();

    if (pts->gwnd.pvCapture == pvObject)
    {
        CVoid * pvCapture = (CVoid *) pts->gwnd.pvCapture;
        pts->gwnd.pvCapture = NULL;
        CALL_METHOD(pvCapture,pts->gwnd.pfnOnMouseMessage,(WM_CAPTURECHANGED, 0, 0));

        if (((g_dwPlatformID == VER_PLATFORM_WIN32_NT) ||
             (g_dwPlatformID == VER_PLATFORM_WIN32_UNIX)) && 
            pts->gwnd.hhookGWMouse)
        {
            UnhookWindowsHookEx(pts->gwnd.hhookGWMouse);
            pts->gwnd.hhookGWMouse = NULL;
        }

        if (GetCapture() == TLS(gwnd.hwndGlobalWindow))
        {
#if DBG==1
            Assert(!TLS(fHandleCaptureChanged));
#endif DBG==1
            ReleaseCapture();
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   GWGetCapture
//
//  Synopsis:   Return the object that has captured the mouse.
//
//--------------------------------------------------------------------------

BOOL
GWGetCapture(void * pvObject)
{
    if (GetCapture() == TLS(gwnd.hwndGlobalWindow))
        return pvObject == TLS(gwnd.pvCapture);
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   GWMouseProc
//
//  Synopsis:   Mouse proc for the global window.  This mouse hook is installed
//              under WinNT when the global window has mouse capture and removed
//              when it releases capture.  Under windows 95, the global window
//              receives WM_CAPTURECHANGED messages and this hook isn't necessary.
//              Under WinNT this mouse proc simulates the WM_CAPTURECHANGED.
//
//  TODO - This global mouse proc should be modified  so that WM_CAPTURECHANGED
//           is sent to all forms3 windows when mouse capture changes.
//--------------------------------------------------------------------------

LRESULT CALLBACK 
GWMouseProc(int  nCode, WPARAM  wParam, LPARAM  lParam)
{
    if (nCode < 0)  /* do not process the message */
        return CallNextHookEx(TLS(gwnd.hhookGWMouse), nCode,
            wParam, lParam);

    if (nCode == HC_ACTION)
    {
        MOUSEHOOKSTRUCT *   pmh = (MOUSEHOOKSTRUCT *) lParam;

        if (wParam >= WM_MOUSEFIRST &&
            wParam <= WM_MOUSELAST &&
            TLS(gwnd.pvCapture) &&
            pmh->hwnd != TLS(gwnd.hwndGlobalWindow))
        {
            GWReleaseCapture(TLS(gwnd.pvCapture));
        }
    }

    // Stress scenario where we have already been shut down and the DLL is just leaving. GWReleaseCapture 
    // sends a capture update message before it unhooks the mouse hook, causing this code to execute at 
    // an inopportune time.
    if (GetThreadState())
    {
        return CallNextHookEx(TLS(gwnd.hhookGWMouse), nCode, wParam, lParam);
    }
    else
    {
        return 0;   // MSDN tells to return 0 if we are not delegating to the CallNextHookEx...
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   GlobalWndProc
//
//  Synopsis:   Window proc for the global window
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
GlobalWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PerfDbgLog4(tagPerfWatch, NULL, "+GlobalWndProc msg=%04lX (%s) hwnd=%lX (%s)",
                msg, DecodeMessage(msg), hwnd, DecodeWindowClass(hwnd));

#ifdef _M_IX86
    //stack corruption protection for Win9x. See definition of CWin9xStackSave.
    CWin9xStackSave stackSave;
#endif
/* 260 bytes - try 255 and it will break travel.js (bug 108309)
BYTE aryTest[sizeof(CWin9xStackSave)];
memset(aryTest,0xFF,sizeof(CWin9xStackSave));
*/

    extern DWORD g_dwTls;
    THREADSTATE *   pts;
    LRESULT         lRet = 0;
    LONG            lDllCount;
    BOOL            fCallDefWndProc = FALSE;

    // (paulnel) Turn off mirroring if the system supports it. This will *really* mess us up.
    if (msg == WM_NCCREATE)
    {
        DWORD dwExStyles;
        if ((dwExStyles = GetWindowLong(hwnd, GWL_EXSTYLE)) & WS_EX_LAYOUTRTL)
        {
            SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles &~ WS_EX_LAYOUTRTL);
        }
    }

    pts = (THREADSTATE *)TlsGetValue(g_dwTls);
    lDllCount = pts ? pts->dll.lObjCount : 0;

    // We need to guard against a Release() call made during
    // message processing causing the ref count to go to zero 
    // and the TLS getting blown away.  This will be done
    // by manually adjusting the counter (to be fast) and 
    // only call DecrementObjectCount if necessary.

    if (lDllCount)
        Verify(++pts->dll.lObjCount > 0);

#ifdef _MAC
    if ( msg == WM_MACINTOSH && LOWORD(wParam) == WLM_SETMENUBAR)
            // dont change the menu bar
                return TRUE;
    if ((msg >= WM_LBUTTONDOWN) && msg <= WM_LBUTTONDBLCLK)
    {
        // We only want to process the Left Button messages
        MacSimulateMouseButtons (msg, wParam);
    }
#endif

    if (WM_THEMECHANGED == msg)
    {
        TraceTag((tagError, "Processing theme change"));
        DllUpdateSettings(msg);
    }

    CHECK_HEAP();

    // Note: When adding new messages to this loop do the 
    //       following:
    //  - Handle the message
    //  - set lRet to be the lResult to return (if not 0)
    //  - set fCallDefWndProc to TRUE if DefWindowProc() should
    //    be called (default is to NOT call DefWindowProc())
    //  - use 'break' to exit the switch statement
    
    switch (msg)
    {
    case WM_TIMER:
        OnTimer(hwnd, (UINT)wParam);
        break;

    HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        
    case WM_METHODCALL:
        GlobalWndOnMethodCall();
        break;    

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
        if (pts && pts->gwnd.pvCapture)
        {
            POINT  pt;
            pt.x = MAKEPOINTS(lParam).x;
            pt.y = MAKEPOINTS(lParam).y;
            ScreenToClient(pts->gwnd.hwndCapture, &pt);
            lRet = CALL_METHOD((CVoid *)pts->gwnd.pvCapture, pts->gwnd.pfnOnMouseMessage,
                               (msg,
                                wParam,
                                MAKELONG(pt.x, pt.y)));
        }
        else
        {
            fCallDefWndProc = TRUE;
        }
        break;

    case WM_CAPTURECHANGED:
#if DBG==1
        TLS(fHandleCaptureChanged) = TRUE;
#endif DBG==1

        if (pts && pts->gwnd.pvCapture)
        {
            CVoid * pvCapture = (CVoid *) pts->gwnd.pvCapture;
#if DBG == 1
            BOOL fHasHook = pts->gwnd.hhookGWMouse != NULL ;
#endif

            lRet = CALL_METHOD(pvCapture, pts->gwnd.pfnOnMouseMessage,
                               (msg,
                                wParam,
                                lParam));

            pts->gwnd.pvCapture = 0;                                

            AssertSz( ! fHasHook || ! pts->gwnd.hhookGWMouse, 
                      "There's still a Mouse Proc on the thread state. But you don't have capture anymore.");
        }
        else
        {
            fCallDefWndProc = TRUE;
        }
#if DBG==1
        TLS(fHandleCaptureChanged) = FALSE;
#endif DBG==1
        break;

    // case WM_WININICHANGE: obsolete, should not be used anymore
    // replaced with WM_SETTINGCHANGE (which has the same ID, but uses wParam)    
    case WM_SETTINGCHANGE:
        DwnCacheOnSettingsChange(wParam, lParam);
        // Fall through
    case WM_SYSCOLORCHANGE:
    case WM_DEVMODECHANGE:
    case WM_FONTCHANGE:
#if(WINVER >= 0x0400)
    case WM_DISPLAYCHANGE:
#endif
    case WM_USER + 338:         // sent by properties change dialog
        TraceTag((tagError, "Processing system change %d", msg));
        DllUpdateSettings(msg);
        break;

    default:
        fCallDefWndProc = TRUE;
        goto Cleanup;
    }

    CHECK_HEAP();

Cleanup:

    if (lDllCount && pts->dll.lObjCount == 1)
    {
        // TLS about to go away.  Let the Passivates occur
        // and then say we handled the message.  Since
        // DecrementObjectCount plays with the secondary
        // count as well we need to increment it as well.

        IncrementSecondaryObjectCount( 3 );
        DecrementObjectCount(NULL);
        lRet = 0;
    }
    else
    {
        if (lDllCount)
            Verify(--pts->dll.lObjCount >= 0);
        if (fCallDefWndProc)
        {
            lRet = DefWindowProc(hwnd, msg, wParam, lParam);
        }
    }

    PerfDbgLog(tagPerfWatch, NULL, "-GlobalWndProc");

    return lRet;

}


//+-------------------------------------------------------------------------
//
//  Function:   DeinitGlobalWindow
//
//--------------------------------------------------------------------------

void
DeinitGlobalWindow(
    THREADSTATE *   pts)
{
    Assert(pts);

#if DBG==1
    if (pts->gwnd.paryTimers)
    {
        Assert((*(pts->gwnd.paryTimers)).Size() == 0);
    }
    if (pts->gwnd.paryCalls)
    {
        for (int i = 0; i < (*(pts->gwnd.paryCalls)).Size(); i++)
        {
            Assert((*(pts->gwnd.paryCalls))[i].pvObject == NULL);
        }
    }
#endif

    if (pts->gwnd.paryCalls)
        (*(pts->gwnd.paryCalls)).DeleteAll();

    // Delete per-thread dynamic arrays
    delete pts->gwnd.paryTimers;
    pts->gwnd.paryTimers = NULL;

    delete pts->gwnd.paryCalls;
    pts->gwnd.paryCalls = NULL;

    if (pts->gwnd.hwndGlobalWindow)
    {
#if !defined(_MAC)
        if (pts->dll.idThread == GetCurrentThreadId())
            Verify(DestroyWindow(pts->gwnd.hwndGlobalWindow));
#endif

        // NOTE: if we're on the wrong thread we can't destroy the window

        pts->gwnd.hwndGlobalWindow = NULL;

        DeleteCriticalSection(&pts->gwnd.cs);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   InitGlobalWindow
//
//  Synopsis:   Initializes and creates the global hwnd.
//
//--------------------------------------------------------------------------
extern ATOM GetWndClassAtom(UINT uIndex);
extern void SetWndClassAtom(UINT uIndex, ATOM atomWndClass);
extern enum WNDCLASS_TYPES;

HRESULT
InitGlobalWindow(
    THREADSTATE *   pts)
{
    HRESULT     hr = S_OK;
    TCHAR * pszBuf;

    Assert(pts);

#if !defined(_MAC) 
    // Create the per-thread "global" window
    if (!GetWndClassAtom(WNDCLASS_HIDDEN))
    {
        hr = THR(RegisterWindowClass(
                WNDCLASS_HIDDEN,
                GlobalWndProc,
                0,
                NULL,
                NULL));
        if (hr)
            goto Error;
    }
#endif // _MAC

#if defined(_MAC)
    TCHAR szBuf[128];
    GlobalGetAtomName(GetWndClassAtom(WNDCLASS_HIDDEN), szBuf, ARRAY_SIZE(szBuf));
    pszBuf = szBuf;
#else
    pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_HIDDEN); 
#endif

#if defined(_MAC) 
	pts->gwnd.hwndGlobalWindow = (HWND) GlobalWndProc;
#else
    pts->gwnd.hwndGlobalWindow = TW32(NULL, CreateWindow(
            pszBuf,
            NULL,
            WS_POPUP,
            0, 0, 0, 0,
            NULL,
            NULL,
            g_hInstCore,
            NULL));
    if (pts->gwnd.hwndGlobalWindow == NULL)
    {
        hr = GetLastWin32Error();
        goto Error;
    }
#endif // _MAC

    hr = HrInitializeCriticalSection(&pts->gwnd.cs);
    if (hr)
        goto Error;

    // Allocate per-thread dynamic arrays
    pts->gwnd.paryTimers = new CAryTimers;
    pts->gwnd.paryCalls  = new CAryCalls;
    if (!pts->gwnd.paryTimers || !pts->gwnd.paryCalls)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

Error:
    RRETURN(hr);
}

#ifdef _MAC // MACTODO:  don't think this function is necessary anymore ???
Boolean GWMouseCaptured(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
	Boolean Result = false;
	
	switch ( msg )
	{
		case WM_MOUSEMOVE:
		case WM_LBUTTONUP:
		 	if ( ::GetCapture() == TLS(gwnd.hwndGlobalWindow) )
		 	{
				(*plResult) = GlobalWndProc(nil, msg, wParam, lParam);
				Result = true;
			}
			break;
			
		default:
			break;
	}
	
	return Result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\htpvpv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       htpvpv.cxx
//
//  Contents:   Hash table mapping PVOID to PVOID
//
//              CHtPvPv
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTPVPV_HXX_
#define X_HTPVPV_HXX_
#include "htpvpv.hxx"
#endif

DeclareTag(tagHtPvPvGrow, "Utils", "Trace CHtPvPv Grow/Shrink")
MtDefine(CHtPvPv, Elements, "CHtPvPv")
MtDefine(CHtPvPv_pEnt, CHtPvPv, "CHtPvPv::_pEnt")

// This is here because I don't have a .cxx file to put it in
MtDefine(CNCache, Elements, "CNCache")

// Definitions ----------------------------------------------------------------

#define HtKeyEqualFast(pvKey1, pvKey2)  (((void *)((DWORD_PTR)pvKey1 & ~1L)) == (pvKey2))
#define HtKeyInUse(pvKey)           ((DWORD_PTR)pvKey > 1L)
#define HtKeyTstFree(pvKey)         (pvKey == NULL)
#define HtKeyTstBridged(pvKey)      ((DWORD_PTR)pvKey & 1L)
#define HtKeySetBridged(pvKey)      ((void *)((DWORD_PTR)pvKey | 1L))
#define HtKeyClrBridged(pvKey)      ((void *)((DWORD_PTR)pvKey & ~1L))
#define HtKeyTstRehash(pvKey)       ((DWORD_PTR)pvKey & 2L)
#define HtKeySetRehash(pvKey)       ((void *)((DWORD_PTR)pvKey | 2L))
#define HtKeyClrRehash(pvKey)       ((void *)((DWORD_PTR)pvKey & ~2L))
#define HtKeyTstFlags(pvKey)        ((DWORD_PTR)pvKey & 3L)
#define HtKeyClrFlags(pvKey)        ((void *)((DWORD_PTR)pvKey & ~3L))

#define WRAPREADER(ret, fn, arglist, args)  \
ret CTsHtPvPv::fn arglist                   \
{                                           \
    ret retval;                             \
    AvoidThreadAssert();                    \
    rwLock.ReaderClaim();                   \
    retval = CHtPvPv::fn args;              \
    rwLock.ReaderRelease();                 \
    return retval;                          \
}

#define WRAPWRITER(ret, fn, arglist, args)  \
ret CTsHtPvPv::fn arglist                   \
{                                           \
    ret retval;                             \
    AvoidThreadAssert();                    \
    rwLock.WriterClaim();                   \
    retval = CHtPvPv::fn args;              \
    rwLock.WriterRelease();                 \
    return retval;                          \
}

#define WRAPUNSAFE(ret, fn, arglist, args)  \
ret CTsHtPvPv::fn##Unsafe arglist           \
{                                           \
    ret retval;                             \
    AvoidThreadAssert();                    \
    retval = CHtPvPv::fn args;              \
    return retval;                          \
}

WRAPREADER(void *, GetFirstEntry, (UINT * iIndex), (iIndex))
WRAPREADER(void *, GetNextEntry, (UINT * iIndex), (iIndex))
WRAPREADER(void *, GetKey, (UINT iIndex), (iIndex))
WRAPUNSAFE(void *, GetFirstEntry, (UINT * iIndex), (iIndex))
WRAPUNSAFE(void *, GetNextEntry, (UINT * iIndex), (iIndex))
WRAPUNSAFE(void *, GetKey, (UINT iIndex), (iIndex))
WRAPWRITER(HRESULT, Set, (UINT iIndex, void * pvKey, void * pvVal), (iIndex, pvKey, pvVal))
WRAPREADER(void *, Lookup, (void *pvKey) const, (pvKey))
#if DBG==1
WRAPWRITER(HRESULT, Insert, (void * pvKey, void * pvVal, const void *pvData), (pvKey, pvVal, pvData))
#else
WRAPWRITER(HRESULT, Insert, (void * pvKey, void * pvVal), (pvKey, pvVal))
#endif
WRAPREADER(HRESULT, LookupSlow, (void * pvKey, const void * pvData, void **ppvVal), (pvKey, pvData, ppvVal))
WRAPWRITER(void *, Remove, (void * pvKey, const void * pvData), (pvKey, pvData))
WRAPREADER(HRESULT, CloneMemSetting, (CHtPvPv **ppClone, BOOL fCreateNew), (ppClone, fCreateNew))


// Constructor / Destructor ---------------------------------------------------

void
CHtPvPv::Init()
{
    memset(this, 0, sizeof(CHtPvPv));
    _pEnt           = &_EntEmpty;
    _pEntLast       = &_EntEmpty;
    _cEntMax        = 1;
    _cStrideMask    = 1;
#if DBG==1
    _dwTidDbg       = GetCurrentThreadId();
#endif
}

HRESULT 
CTsHtPvPv::Init()
{
    HRESULT hr;
    CHtPvPv::Init();    
    hr = rwLock.Init();
    RRETURN(hr);
}

void
CHtPvPv::ReInit()
{
    AssertSz(_dwTidDbg == GetCurrentThreadId(), "Hash table accessed from wrong thread.  This will corrupt lookups");
    if (_pEnt != &_EntEmpty)
    {
        MemFree(_pEnt);
    }
    LPFNCOMPARE lpfnCompare = _lpfnCompare;
    void *pObject = _pObject;
    Init();
    SetCallBack(pObject, lpfnCompare);
}

void
CTsHtPvPv::ReInit()
{
    AvoidThreadAssert();
    rwLock.WriterClaim();
    CHtPvPv::ReInit();   
    rwLock.WriterRelease();
}


// Utilities ------------------------------------------------------------------

UINT
CHtPvPv::ComputeStrideMask(UINT cEntMax)
{
    UINT iMask;
    for (iMask = 1; iMask < cEntMax; iMask <<= 1);
    return((iMask >> 1) - 1);
}

// Private Methods ------------------------------------------------------------

HRESULT
CHtPvPv::Grow()
{
    HRESULT hr;
    const DWORD * pdw;
    UINT    cEntMax;
    UINT    cEntGrow;
    UINT    cEntShrink;
    HTENT * pEnt;

    extern const DWORD s_asizeAssoc[];

    for (pdw = s_asizeAssoc; *pdw <= _cEntMax; pdw++) ;

    cEntMax    = *pdw;
    cEntGrow   = cEntMax * 8L / 10L;
    cEntShrink = (pdw > s_asizeAssoc) ? *(pdw - 1) * 4L / 10L : 0;
    pEnt       = (_pEnt == &_EntEmpty) ? NULL : _pEnt;

    hr = MemRealloc(Mt(CHtPvPv_pEnt), (void **)&pEnt, cEntMax * sizeof(HTENT));

    if (hr == S_OK)
    {
        _pEnt           = pEnt;
        _pEntLast       = &_EntEmpty;
        _cEntGrow       = cEntGrow;
        _cEntShrink     = cEntShrink;
        _cStrideMask    = ComputeStrideMask(cEntMax);

        memset(&_pEnt[_cEntMax], 0, (cEntMax - _cEntMax) * sizeof(HTENT));

        if (_cEntMax == 1)
        {
            memset(_pEnt, 0, sizeof(HTENT));
        }

        Rehash(cEntMax);
    }

    TraceTag((tagHtPvPvGrow, "Growing to cEntMax=%ld (cEntShrink=%ld,cEnt=%ld,cEntGrow=%ld)",
        _cEntMax, _cEntShrink, _cEnt, _cEntGrow));

    RRETURN(hr);
}

void
CHtPvPv::Shrink()
{
    const DWORD * pdw;
    UINT    cEntMax;
    UINT    cEntGrow;
    UINT    cEntShrink;

    extern const DWORD s_asizeAssoc[];

    for (pdw = s_asizeAssoc; *pdw < _cEntMax; pdw++) ;

    cEntMax    = *--pdw;
    cEntGrow   = cEntMax * 8L / 10L;
    cEntShrink = (pdw > s_asizeAssoc) ? *(pdw - 1) * 4L / 10L : 0;

    Assert(_cEnt < cEntGrow);
    Assert(_cEnt > cEntShrink);

    _pEntLast       = &_EntEmpty;
    _cEntGrow       = cEntGrow;
    _cEntShrink     = cEntShrink;
    _cStrideMask    = ComputeStrideMask(cEntMax);

    Rehash(cEntMax);

    Verify(MemRealloc(Mt(CHtPvPv_pEnt), (void **)&_pEnt, cEntMax * sizeof(HTENT)) == S_OK);

    TraceTag((tagHtPvPvGrow, "Shrinking to cEntMax=%ld (cEntShrink=%ld,cEnt=%ld,cEntGrow=%ld)",
        _cEntMax, _cEntShrink, _cEnt, _cEntGrow));
}

void
CHtPvPv::Rehash(UINT cEntMax)
{
    UINT    iEntScan    = 0;
    UINT    cEntScan    = _cEntMax;
    HTENT * pEntScan    = _pEnt;
    UINT    iEnt;
    UINT    cEnt;
    HTENT * pEnt;

    _cEntDel = 0;
    _cEntMax = cEntMax;

    for (; iEntScan < cEntScan; ++iEntScan, ++pEntScan)
    {
        if (HtKeyInUse(pEntScan->pvKey))
            pEntScan->pvKey = HtKeyClrBridged(HtKeySetRehash(pEntScan->pvKey));
        else
            pEntScan->pvKey = NULL;
        Assert(!HtKeyTstBridged(pEntScan->pvKey));
    }

    iEntScan = 0;
    pEntScan = _pEnt;

    for (; iEntScan < cEntScan; ++iEntScan, ++pEntScan)
    {

    repeat:

        if (HtKeyTstRehash(pEntScan->pvKey))
        {
            pEntScan->pvKey = HtKeyClrRehash(pEntScan->pvKey);

            iEnt = ComputeProbe(pEntScan->pvKey);
            cEnt = ComputeStride(pEntScan->pvKey);

            for (;;)
            {
                pEnt = &_pEnt[iEnt];

                if (pEnt == pEntScan)
                    break;

                if (pEnt->pvKey == NULL)
                {
                    *pEnt = *pEntScan;
                    pEntScan->pvKey = NULL;
                    break;
                }

                if (HtKeyTstRehash(pEnt->pvKey))
                {
                    void * pvKey1 = HtKeyClrBridged(pEnt->pvKey);
                    void * pvKey2 = HtKeyClrBridged(pEntScan->pvKey);
                    void * pvVal1 = pEnt->pvVal;
                    void * pvVal2 = pEntScan->pvVal;

                    if (HtKeyTstBridged(pEntScan->pvKey))
                    {
                        pvKey1 = HtKeySetBridged(pvKey1);
                    }

                    if (HtKeyTstBridged(pEnt->pvKey))
                    {
                        pvKey2 = HtKeySetBridged(pvKey2);
                    }

                    pEntScan->pvKey = pvKey1;
                    pEntScan->pvVal = pvVal1;
                    pEnt->pvKey = pvKey2;
                    pEnt->pvVal = pvVal2;

                    goto repeat;
                }
            
                pEnt->pvKey = HtKeySetBridged(pEnt->pvKey);

                iEnt += cEnt;

                if (iEnt >= _cEntMax)
                    iEnt -= _cEntMax;
            }
        }
    }
}

// Public Methods -------------------------------------------------------------
void *
CHtPvPv::GetFirstEntry(UINT * iIndex)
{
    Assert(iIndex);

    *iIndex = 0;

    if (!_pEnt || !_cEnt)
        return NULL;

    while ((*iIndex < _cEntMax) && !HtKeyInUse(_pEnt[*iIndex].pvKey))
        ++(*iIndex);

    return (*iIndex >= _cEntMax) ? NULL : _pEnt[*iIndex].pvVal;

}

void *
CHtPvPv::GetNextEntry(UINT * iIndex)
{
    Assert(iIndex);

    ++(*iIndex);

    if (!_pEnt)
        return NULL;

    while ((*iIndex < _cEntMax) && !HtKeyInUse(_pEnt[*iIndex].pvKey))
        ++(*iIndex);

    return (*iIndex >= _cEntMax) ? NULL : _pEnt[*iIndex].pvVal;

}

void *
CHtPvPv::GetKey(UINT iIndex)
{
    return (iIndex >= _cEntMax) ? NULL : _pEnt[iIndex].pvKey;
}

HRESULT 
CHtPvPv::Set(UINT iIndex, void *pvKey, void *pvVal)
{
    if ( iIndex >= _cEntMax )
        return E_INVALIDARG;

    _pEnt[iIndex].pvKey = pvKey;
    _pEnt[iIndex].pvVal = pvVal;
    return S_OK;
}


//
// Clone a hash table with necessary memory space. However,
// the entries are not cloned! In the other word, the entries 
// are empty! To clone the entire hash table:
//
//      CloneMemSetting
//      GetFirstEntry/GetNextEntry/GetKey 
//      <Clone Key Val>
//      Set( Key, Val)
//
// This could be replaced with a single Clone function
// if we add a callback function that knows how to clone Key/Val
//

HRESULT 
CHtPvPv::CloneMemSetting(CHtPvPv **ppClone, BOOL fCreateNew)
{
    HRESULT  hr = S_OK;

    Assert( ppClone );
    if (fCreateNew)
    {
        *ppClone = new CHtPvPv();
        if (!*ppClone)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    Assert( *ppClone );

    (*ppClone)->_cEnt       = _cEnt;
    (*ppClone)->_cEntDel    = _cEntDel;
    (*ppClone)->_cEntGrow   = _cEntGrow;
    (*ppClone)->_cEntMax    = _cEntMax;
    (*ppClone)->_cStrideMask= _cStrideMask;
    if ( _pEnt != &_EntEmpty )
    {
        (*ppClone)->_pEnt = (HTENT *)MemAllocClear( Mt(CHtPvPv_pEnt),  _cEntMax * sizeof(HTENT) );
        if (! (*ppClone)->_pEnt )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    
Cleanup:
    if (hr)
    {
        if (!fCreateNew && (*ppClone))
        {
            delete (*ppClone);
            *ppClone = NULL;
        }
    }
    RRETURN(hr);
}




void *
CHtPvPv::Lookup(void *pvKey) const
{
    HTENT * pEnt;
    UINT        iEnt;
    UINT        cEnt;

    Assert(_lpfnCompare == NULL);
    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));
    AssertSz(_dwTidDbg == GetCurrentThreadId(), "Hash table accessed from wrong thread.  This will corrupt lookups");

    if (HtKeyEqualFast(_pEntLast->pvKey, pvKey))
    {
        return(_pEntLast->pvVal);
    }

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (HtKeyEqualFast(pEnt->pvKey, pvKey))
    {
        _pEntLast = pEnt;
        return(pEnt->pvVal);
    }

    if (!HtKeyTstBridged(pEnt->pvKey))
    {
        return(NULL);
    }

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (HtKeyEqualFast(pEnt->pvKey, pvKey))
        {
            _pEntLast = pEnt;
            return(pEnt->pvVal);
        }

        if (!HtKeyTstBridged(pEnt->pvKey))
        {
            return(NULL);
        }
    }
}

HRESULT
CHtPvPv::LookupSlow(void * pvKey, const void *pvData, void ** ppvVal)
{
    HTENT * pEnt;
    UINT        iEnt;
    UINT        cEnt;

    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));
    AssertSz(_dwTidDbg == GetCurrentThreadId(), "Hash table accessed from wrong thread.  This will corrupt lookups");

    if (HtKeyEqual(_pEntLast, pvKey, pvData))
    {
        *ppvVal = _pEntLast->pvVal;
        return S_OK;
    }

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (HtKeyEqual(pEnt, pvKey, pvData))
    {
        _pEntLast = pEnt;
        *ppvVal = pEnt->pvVal;
        return S_OK;
    }

    if (!HtKeyTstBridged(pEnt->pvKey))
    {
        return S_FALSE;
    }

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (HtKeyEqual(pEnt, pvKey, pvData))
        {
            _pEntLast = pEnt;
            *ppvVal = pEnt->pvVal;
            return S_OK;
        }

        if (!HtKeyTstBridged(pEnt->pvKey))
        {
            return S_FALSE;
        }
    }
}

HRESULT
#if DBG==1
CHtPvPv::Insert(void * pvKey, void * pvVal, const void *pvData)
#else
CHtPvPv::Insert(void * pvKey, void * pvVal)
#endif
{
    HTENT * pEnt;
    UINT    iEnt;
    UINT    cEnt;
    
    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));
    Assert(!IsPresent(pvKey, pvData));

    if (_cEnt + _cEntDel >= _cEntGrow)
    {
        if (_cEntDel > (_cEnt >> 2))
            Rehash(_cEntMax);
        else
        {
            HRESULT hr = Grow();

            if (hr)
            {
                RRETURN(hr);
            }
        }
    }

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (!HtKeyInUse(pEnt->pvKey))
    {
        goto insert;
    }

    pEnt->pvKey = HtKeySetBridged(pEnt->pvKey);

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (!HtKeyInUse(pEnt->pvKey))
        {
            goto insert;
        }

        pEnt->pvKey = HtKeySetBridged(pEnt->pvKey);
    }

insert:

    if (HtKeyTstBridged(pEnt->pvKey))
    {
        _cEntDel -= 1;
        pEnt->pvKey = HtKeySetBridged(pvKey);
    }
    else
    {
        pEnt->pvKey = pvKey;
    }

    pEnt->pvVal = pvVal;

    _pEntLast = pEnt;

    _cEnt += 1;

    return(S_OK);
}

void *
CHtPvPv::Remove(void * pvKey, const void * pvData)
{
    HTENT * pEnt;
    UINT    iEnt;
    UINT    cEnt;

    Assert(!HtKeyTstFree(pvKey) && !HtKeyTstFlags(pvKey));

    iEnt = ComputeProbe(pvKey);
    pEnt = &_pEnt[iEnt];

    if (HtKeyEqual(pEnt, pvKey, pvData))
    {
        goto remove;
    }

    if (!HtKeyTstBridged(pEnt->pvKey))
    {
        return(NULL);
    }

    cEnt = ComputeStride(pvKey);

    for (;;)
    {
        iEnt += cEnt;

        if (iEnt >= _cEntMax)
            iEnt -= _cEntMax;

        pEnt = &_pEnt[iEnt];

        if (HtKeyEqual(pEnt, pvKey, pvData))
        {
            goto remove;
        }

        if (!HtKeyTstBridged(pEnt->pvKey))
        {
            return(NULL);
        }
    }

remove:

    if (HtKeyTstBridged(pEnt->pvKey))
    {
        pEnt->pvKey = HtKeySetBridged(NULL);
        _cEntDel += 1;
    }
    else
    {
        pEnt->pvKey = NULL;
    }

    pvKey = pEnt->pvVal;

    _cEnt -= 1;

    if (_cEnt < _cEntShrink)
    {
        Shrink();
    }

    return(pvKey);
}

// Testing --------------------------------------------------------------------

#if 0

#define MAKE_HTKEY(i)   ((void *)((((DWORD)(i) * 4567) << 2) | 4))
#define MAKE_HTVAL(k)   ((void *)(~(DWORD)MAKE_HTKEY(k)))

CHtPvPv * phtable = NULL;

BOOL TestHTInsert(int i)
{
    void * pvKey = MAKE_HTKEY(i);
    void * pvVal = MAKE_HTVAL(i);
    Verify(phtable->Insert(pvKey, pvVal) == S_OK);
    Verify(phtable->Lookup(pvKey) == pvVal);
    return(TRUE);
}

BOOL TestHTRemove(int i)
{
    void * pvKey = MAKE_HTKEY(i);
    void * pvVal = MAKE_HTVAL(i);
    Verify(phtable->Remove(pvKey) == pvVal);
    Verify(phtable->Remove(pvKey) == NULL);
    return(TRUE);
}

BOOL TestHTVerify(int i, int n)
{
    void * pvKey;
    void * pvVal; 
    int    j;

    Verify((int)phtable->GetCount() == (n - i));

    for (j = i; j < n; ++j)
    {
        pvKey = MAKE_HTKEY(j);
        pvVal = MAKE_HTVAL(j);
        Verify(phtable->Lookup(pvKey) == pvVal);
    }

    return(TRUE);
}

HRESULT TestHtPvPv()
{
    CHtPvPv *   pht = new CHtPvPv;
    int         cLim, cEntMax;
    int         i, j;

    // Insufficient memory, don't crash.
    if (!pht)
        return S_FALSE;

//  printf("---- Begin testing CHashTable implementation\n\n");

    cLim    = 256;
    cEntMax = 383;
    phtable = pht;

    // Insert elements from 0 to cLim
//  printf("  Inserting from %3d to %3d\n", 0, cLim); fflush(stdout);
    for (i = 0; i < cLim; ++i) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(0, i + 1)) return(S_FALSE);
    }

    // Remove elements from 0 to cLim
//  printf("  Removing  from %3d to %3d\n", 0, cLim); fflush(stdout);
    for (i = 0; i < cLim; ++i) {
        if (!TestHTRemove(i)) return(S_FALSE);
        if (!TestHTVerify(i + 1, cLim)) return(S_FALSE);
    }

    // Rehash and make sure number of deleted entries is now zero
    phtable->Rehash(phtable->GetMaxCount());
    Verify(phtable->GetDelCount() == 0);
    if (!TestHTVerify(0, 0)) return(S_FALSE);

    // Insert elements from 0 to cLim/2
//  printf("  Inserting from %3d to %3d\n", 0, cLim / 2); fflush(stdout);
    for (i = 0; i < cLim/2; ++i) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(0, i + 1)) return(S_FALSE);
    }

    // Insert elements from cLim/2 to cLim and remove elements from 0 to cLim/2
//  printf("  Inserting from %3d to %3d, removing from %3d to %3d\n", cLim / 2, cLim, 0, cLim / 2); fflush(stdout);
    for (i = cLim/2, j = 0; i < cLim; ++i, ++j) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(j, i + 1)) return(S_FALSE);
        if (!TestHTRemove(j)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 1)) return(S_FALSE);
    }

    // Insert two elements from cLim to cLim*2, remove one element from cLim/2 to cLim
//  printf("  Inserting from %3d to %3d, removing from %3d to %3d\n", cLim, cLim*2, cLim / 2, cLim);
    for (i = cLim, j = cLim / 2; i < cLim*2; i += 2, ++j) {
        if (!TestHTRemove(j)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i)) return(S_FALSE);
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 1)) return(S_FALSE);
        if (!TestHTInsert(i + 1)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 2)) return(S_FALSE);
    }

    // Rehash and make sure number of deleted entries is now zero
    phtable->Rehash(phtable->GetMaxCount());
    Verify(phtable->GetDelCount() == 0);

    if (!TestHTVerify(cLim, cLim*2)) return(S_FALSE);

    // Insert elements from cLim*2, remove two elements from cLim
//  printf("  Inserting from %3d to %3d, removing from %3d to %3d\n", cLim*2, cLim*3, cLim, cLim*3);
    for (i = cLim*2, j = cLim; i < cLim*3; ++i, j += 2) {
        if (!TestHTInsert(i)) return(S_FALSE);
        if (!TestHTVerify(j, i + 1)) return(S_FALSE);
        if (!TestHTRemove(j)) return(S_FALSE);
        if (!TestHTVerify(j + 1, i + 1)) return(S_FALSE);
        if (!TestHTRemove(j + 1)) return(S_FALSE);
        if (!TestHTVerify(j + 2, i + 1)) return(S_FALSE);
    }

    // Rehash and make sure number of deleted entries is now zero
    phtable->Rehash(phtable->GetMaxCount());
    Verify(phtable->GetDelCount() == 0);
    if (!TestHTVerify(0, 0)) return(S_FALSE);

    delete pht;

    return(S_OK);
}

#endif

// Reader/writer lock implementation -------------------------------------------------------------------
//
// There are two important synchronization primitives involved in this implementation:
// the group event (_hGroupEvent) and the reader critical section (csReader)
//
// Group Event - 
//
// The group mutex is held by either the collective readers or by one writer, 
// and allows threads of that group to be active. The group mutex is not 
// manually reset - when it is released, one thread waiting on it will 
// automatically be activated. Therefore only one reader should be waiting on 
// this mutex at any given time. The first reader gets this mutex before 
// proceeding, and the last reader releases it when it is finished. Writers 
// are slightly different: each writer is treated separately to ensure that 
// only one writer is active at a time. Therefore any number of writers can 
// block on this event, and only one will be activated at a time.
//
// Reader Critical Section - 
//
// This critical section ensures that only one reader blocks on the group
// event at a time. When the readers collectively have the group event,
// all readers are allowed to pass through until the last reader leaves,
// at which time the group event is reset. This critical section also
// serves to protect the reader count.

CRWLock::CRWLock()
{
    _cReaders = 0;   
    _hGroupEvent = NULL;    
}


CRWLock::~CRWLock()
{
    if (_hGroupEvent)
        CloseHandle(_hGroupEvent);    
}

HRESULT
CRWLock::Init()
{
    HRESULT hr = S_OK;
    
    hr = csReader.Init();
    if (hr)
        goto Cleanup;

    _hGroupEvent = CreateEvent(NULL, FALSE, TRUE, NULL);        

    if (!_hGroupEvent)
        hr = E_FAIL;
    
Cleanup:
    RRETURN(hr);
}

void
CRWLock::WriterClaim()
{    
    WaitForSingleObject(_hGroupEvent, INFINITE);    
}

void 
CRWLock::WriterRelease()
{    
    SetEvent(_hGroupEvent); 
}

void 
CRWLock::ReaderClaim()
{

    csReader.Enter();
    
    if (++_cReaders == 1)
    {
        WaitForSingleObject(_hGroupEvent, INFINITE);       
    }
    
    csReader.Leave();           
}

void CRWLock::ReaderRelease()
{
    csReader.Enter();
    
    if (--_cReaders == 0)
    {        
        SetEvent(_hGroupEvent);
    }
    
    csReader.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\identpal.cxx ===
//+------------------------------------------------------------------------
//
//  File:       identpal.cxx
//
//  Contents:   Debug routines for faster BitBlt to palette devices
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

DeclareTag(tagIdentity, "Performance", "Warn if non-identity palette, BitBlt");

BOOL 
IsSameAsPhysicalPalette(HPALETTE hpal)
{
    BOOL fIdentityPalette = TRUE;

    if ((GetDeviceCaps(TLS(hdcDesktop), RASTERCAPS) & RC_PALETTE) &&
        GetDeviceCaps(TLS(hdcDesktop), BITSPIXEL) * GetDeviceCaps(TLS(hdcDesktop), PLANES) == 8)
    {
        PALETTEENTRY apeSystem[256];
        PALETTEENTRY apePalette[256];

        GetSystemPaletteEntries(TLS(hdcDesktop), 0, ARRAY_SIZE(apeSystem), apeSystem);
        GetPaletteEntries(hpal, 0, ARRAY_SIZE(apePalette), apePalette);

        for (int i = 256; --i >= 0; )
        {
            if (apePalette[i].peRed != apeSystem[i].peRed ||
                apePalette[i].peGreen != apeSystem[i].peGreen ||
                apePalette[i].peBlue != apeSystem[i].peBlue)
            {
                fIdentityPalette = FALSE;
                break;
            }
        }
    }

    return fIdentityPalette;
}

/****************************************************************************

 IsIdentityPalette

    handy debug code to determine if a palette has a 1:1 logical to
    foreground translate (ie is a identity palette)

    Identity palettes are very important for windows apps using DIBs,
    DIBSections, WinGBitmaps in order to get the fastest possible
    speed out of BitBlt.

    it might be a good idea to put a Assert(IsIdentityPalette(hpal))
    in your app if you care about Blt speed.

    further reading....

        WinG help file (on MSDN) - great discusion of Identity palettes
        why you need them, how to get them etc...

        Win32 Animation techniques, Nigel Thompson

        MSDN search for identity

    03/02/95    ToddLa

 ****************************************************************************/


BOOL 
IsIdentityPalette(HPALETTE hpal)
{
    BOOL fIdentityPalette = TRUE;
    HDC hdcS;

    hdcS = GetDC(NULL);

    if ((GetDeviceCaps(hdcS, RASTERCAPS) & RC_PALETTE) &&
        GetDeviceCaps(hdcS, BITSPIXEL) * GetDeviceCaps(hdcS, PLANES) == 8)
    {
        int n=0;
        int i;
        BYTE xlat[256];
        HBITMAP hbm;
        HDC hdcM;

        GetObject(hpal, sizeof(n), &n);

        hdcM = CreateCompatibleDC(hdcS);
        if (hdcM)
        {
            hbm = CreateCompatibleBitmap(hdcS, 256, 1);
            if (hbm)
            {
                SelectObject(hdcM, hbm);

                Verify(SelectPalette(hdcM, hpal, TRUE));
                RealizePalette(hdcM);
                for (i=0; i<n; i++)
                {
                    SetPixel(hdcM, i, 0, PALETTEINDEX(i));
                }
                GetBitmapBits(hbm, sizeof(xlat), xlat);
                SelectPalette(hdcM, (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE);

                DeleteObject(hbm);

                for (i=0; i<n; i++)
                {
                    if (xlat[i] != i)
                    {
                        TraceTag((tagIdentity, "Using non-identity palette"));
                        fIdentityPalette = FALSE;
                        break;
                    }
                }
            }
            DeleteDC(hdcM);
        }
    }

    ReleaseDC(NULL, hdcS);

    return fIdentityPalette;
}

/****************************************************************************

 IsIdentityBlt

    handy debug code to determine if a DibSection Blt is 1:1

  hdcS  - screen DC
  hdcD  - DIBSection DC
  xWid  - row width of hdcD
    
    03/02/95    ToddLa

 ****************************************************************************/

BOOL 
IsIdentityBlt(HDC hdcS, HDC hdcD, int xWid)
{
    BOOL fIdentityBlt = TRUE;

    if (    xWid > 0
        &&  (GetDeviceCaps(hdcS, RASTERCAPS) & RC_PALETTE)
        &&  GetDeviceCaps(hdcS, BITSPIXEL) * GetDeviceCaps(hdcS, PLANES) == 8)
    {
        int i, j, xSpan;
        BYTE xlat[256];
        HBITMAP hbm;
        HDC hdcM;
        COLORREF argb[256];
        HPALETTE hpal;

        hpal = (HPALETTE)GetCurrentObject(hdcS, OBJ_PAL);

        hdcM = CreateCompatibleDC(hdcS);
        if (hdcM)
        {
            hbm = CreateCompatibleBitmap(hdcS, 256, 1);
            if (hbm)
            {
                SelectObject(hdcM, hbm);

                Verify(SelectPalette(hdcM, hpal, TRUE));
                RealizePalette(hdcM);

                if (xWid > 256)
                    xWid = 256;

                for (i=0; i<xWid; i++)
                {
                    argb[i] = GetPixel(hdcD, i, 0);
                }

                for (j=0; j<256; j += xWid)
                {
                    xSpan = min(xWid, 256 - j);

                    for (i = 0; i < xSpan; i++)
                    {
                        SetPixel(hdcD, i, 0, PALETTEINDEX(j + i));
                    }

                    BitBlt(hdcM, 0, 0, xSpan, 1, hdcD, 0, 0, SRCCOPY);

                    GetBitmapBits(hbm, xSpan, xlat);

                    for (i=0; i < xSpan; i++)
                    {
                        if (xlat[i] != j + i)
                        {
                            TraceTag((tagIdentity, "Performing non-identity BitBlt"));
                            fIdentityBlt = FALSE;
                            break;
                        }
                    }

                    if (!fIdentityBlt)
                        break;
                }

                SelectPalette(hdcM, (HPALETTE)GetStockObject(DEFAULT_PALETTE), FALSE);
                DeleteObject(hbm);
            }
            DeleteDC(hdcM);
        }

        for (i=0; i<xWid; i++)
        {
            SetPixel(hdcD, i, 0, argb[i]);
        }
    }    

    return fIdentityBlt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\hlink16.cxx ===
//+------------------------------------------------------------------------
//
//  File:       chlink.cxx
//  Created :   27th June 1997
//  Contents:   Implementing IHlink.
//              Done for storing and retrieving the 
//              bookmark fragment of an URL
//              Constructor - initializes the bookmark "_szLocation"
//              GetMonikerReference - Currently used for retrieving the bookmark
//              HlinkCreateFromMoniker - Instantiates the CHlink class   
//-------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HLINK_H_
#define X_HLINK_X_
#include "hlink.h"        // for std hyperlink object
#endif

class CHlink : public IHlink
{
public:
    CHlink();
    CHlink(IMoniker* pmk, LPCTSTR pszLocation, LPCSTR pszFriedlyName);
    ~CHlink();

    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE  QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual ULONG STDMETHODCALLTYPE AddRef(void) ;
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // *** IOleWindow methods ***
        virtual HRESULT STDMETHODCALLTYPE SetHlinkSite( 
            /* [unique][in] */ IHlinkSite __RPC_FAR *pihlSite,
            /* [in] */ DWORD dwSiteData) ;
        
        virtual HRESULT STDMETHODCALLTYPE GetHlinkSite( 
            /* [out] */ IHlinkSite __RPC_FAR *__RPC_FAR *ppihlSite,
            /* [out] */ DWORD __RPC_FAR *pdwSiteData) ;

        virtual HRESULT STDMETHODCALLTYPE GetMonikerReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppimkTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation);

        virtual HRESULT STDMETHODCALLTYPE GetStringReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ LPWSTR __RPC_FAR *ppwzTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation);

        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ LPWSTR __RPC_FAR *ppwzFriendlyName);

            virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ LPBC pibc,
            /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
            /* [unique][in] */ IHlinkBrowseContext __RPC_FAR *pihlbc);

  
    virtual HRESULT STDMETHODCALLTYPE SetMonikerReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ IMoniker __RPC_FAR *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation) ;
        
    virtual HRESULT STDMETHODCALLTYPE SetStringReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ LPCWSTR pwzTarget,
            /* [unique][in] */ LPCWSTR pwzLocation) ;
                
    virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [unique][in] */ LPCWSTR pwzFriendlyName) ;
        
        
    virtual HRESULT STDMETHODCALLTYPE SetTargetFrameName( 
            /* [unique][in] */ LPCWSTR pwzTargetFrameName) ;
        
    virtual HRESULT STDMETHODCALLTYPE GetTargetFrameName( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzTargetFrameName) ;
        
    virtual HRESULT STDMETHODCALLTYPE GetMiscStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
    virtual HRESULT STDMETHODCALLTYPE SetAdditionalParams( 
            /* [unique][in] */ LPCWSTR pwzAdditionalParams) ;
        
    virtual HRESULT STDMETHODCALLTYPE GetAdditionalParams( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzAdditionalParams);


protected:
    UINT	_cRef;
    IHlinkSite* _pihlSite;
    IMoniker*   _pmk;
    TCHAR	_szLocation[MAX_PATH];
};

CHlink::CHlink(IMoniker* pmk, LPCTSTR pszLocation, LPCSTR pszFriedlyName)
		    : _cRef(1), _pihlSite(NULL), _pmk(pmk)
{
    if (_pmk) {
	_pmk->AddRef();
    }
    if (pszLocation) {
	lstrcpy(_szLocation, pszLocation);
    } else {
	_szLocation[0] = '\0';
    }
}


CHlink::~CHlink()
{
    if (_pmk) {
	_pmk->Release();
    }

    if (_pihlSite) {
	_pihlSite->Release();
    }
}

HRESULT CHlink::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
     if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IHlink))
    {
        *ppvObj = (IHlink *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
    
}

ULONG CHlink::AddRef(void)
{
    return ++_cRef;
}

ULONG CHlink::Release(void)
{
    if (--_cRef > 0) {
	return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CHlink::SetHlinkSite( 
            /* [unique][in] */ IHlinkSite __RPC_FAR *pihlSite,
            /* [in] */ DWORD dwSiteData) 
{
    if (_pihlSite) {
	_pihlSite->Release();
    }

    _pihlSite = pihlSite;

    if (_pihlSite) {
	_pihlSite->AddRef();
    }

    return S_OK;
}

HRESULT CHlink::GetHlinkSite( 
            /* [out] */ IHlinkSite __RPC_FAR *__RPC_FAR *ppihlSite,
            /* [out] */ DWORD __RPC_FAR *pdwSiteData) 
{
    *ppihlSite = _pihlSite;
    if (_pihlSite) {
	_pihlSite->AddRef();
    }

    return S_OK;
}

HRESULT CHlink::GetMonikerReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ IMoniker **ppimkTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation)
{
    if (ppimkTarget) {
	*ppimkTarget = _pmk;
	if (_pmk) {
	    _pmk->AddRef();
	}
    }

    if (ppwzLocation) 
    {
        *ppwzLocation = SysAllocString ( _szLocation ) ;
    }
    
    return S_OK;
}

HRESULT CHlink::GetStringReference( 
            /* [in] */ DWORD dwWhichRef,
            /* [out] */ LPWSTR __RPC_FAR *ppwzTarget,
            /* [out] */ LPWSTR __RPC_FAR *ppwzLocation)
{
    return E_NOTIMPL;
}

HRESULT CHlink::GetFriendlyName( 
            /* [in] */ DWORD grfHLFNAMEF,
            /* [out] */ LPWSTR __RPC_FAR *ppwzFriendlyName){
    return E_NOTIMPL;
}

HRESULT CHlink::Navigate( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ LPBC pibc,
            /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
            /* [unique][in] */ IHlinkBrowseContext __RPC_FAR *pihlbc)
{
       return E_NOTIMPL ;
}


HRESULT CHlink::SetMonikerReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ IMoniker __RPC_FAR *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation)
{
 return E_NOTIMPL ;   
}
        
HRESULT CHlink::SetStringReference( 
            /* [in] */ DWORD grfHLSETF,
            /* [unique][in] */ LPCWSTR pwzTarget,
            /* [unique][in] */ LPCWSTR pwzLocation)
{
    return E_NOTIMPL ;
}
                
HRESULT CHlink::SetFriendlyName( 
            /* [unique][in] */ LPCWSTR pwzFriendlyName)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::SetTargetFrameName( 
            /* [unique][in] */ LPCWSTR pwzTargetFrameName)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::GetTargetFrameName( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzTargetFrameName)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::GetMiscStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::SetAdditionalParams( 
            /* [unique][in] */ LPCWSTR pwzAdditionalParams)
{
    return E_NOTIMPL ;
}
        
HRESULT CHlink::GetAdditionalParams( 
            /* [out] */ LPWSTR __RPC_FAR *ppwzAdditionalParams)
{
    return E_NOTIMPL ;
}

STDAPI HlinkCreateFromMoniker(
             IMoniker * pimkTrgt,
             LPCWSTR pwzLocation,
             LPCWSTR pwzFriendlyName,
             IHlinkSite * pihlsite,
             DWORD dwSiteData,
             IUnknown * piunkOuter,
             REFIID riid,
             void ** ppvObj)
               
{
    if ( pimkTrgt == NULL)
        return E_FAIL;
                          
		CHlink *ptemp = NULL;
        
        ptemp = new CHlink ( pimkTrgt, pwzLocation, pwzFriendlyName) ; 
        if ( !ptemp )
        	return E_OUTOFMEMORY ;

        *ppvObj = NULL ;                          

        *ppvObj = (void * )ptemp ;
        

    return S_OK ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\perfdbg.cxx ===
//+------------------------------------------------------------------------
//
//  File:       perfdbg.cxx
//
//  Contents:   PerfDbgLogFn
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#if DBG==1

static CGlobalCriticalSection s_csPerfDbg;

int __cdecl PerfDbgLogFn(int tag, void * pvObj, char * pchFmt, ...)
{
    static char ach[1024];

    if (IsPerfDbgEnabled(tag))
    {
        LOCK_SECTION(s_csPerfDbg);

        va_list vl;
        va_start(vl, pchFmt);
        ach[0] = 0;
        wsprintfA(ach, "[%lX] %8lX ", GetCurrentThreadId(), pvObj);
        wvsprintfA(ach + lstrlenA(ach), pchFmt, vl);
        TraceTag((tag, "%s", ach));
        va_end(vl);
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\offscrn.cxx ===
//+------------------------------------------------------------------------
//
//  File:       offscrn.cxx
//
//  Contents:   OffScreen drawing utilities.
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include <coreguid.h>
#endif

#ifdef PRODUCT_PROF_FERG
// for PROFILING perposes only
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall SuspendCAP(void);
#endif

DeclareTag(tagOscStats,         "OffScreen stats",    "OffScreen statistics")
DeclareTag(tagOscClear,         "OffScreen clear",    "pre-clear offscreen buffer with green")
PerfDbgTag(tagOscCacheDisable,  "OffScreen caching",  "Disable OffScreen caching")
PerfDbgTag(tagOscUseDD,         "OffScreen DD",       "Force DirectDraw OffScreen usage")
PerfDbgTag(tagOscFullsize,      "OffScreen full size","Allow cache of a fullsize screen buffer")
PerfDbgTag(tagOscTinysize,      "OffScreen tiny size","Allow cache of a tiny screen buffer")

MtDefine(COffScreenContext, Locals, "COffScreenContext")

#if !defined(NODD)

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include <ddraw.h>
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif

// QUESTION: can we get these GUIDs from a lib from DDEx??

#define DEFINE_DD_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_DD_GUID(CLSID_DirectDrawFactory, 
0x4fd2a832, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_DD_GUID(IID_IDirectDrawFactory, 
0x4fd2a833, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_DD_GUID(IID_IDirectDraw3, 
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

IDirectDraw*        g_pDirectDraw = NULL;
HRESULT             g_hrDirectDraw = S_OK;

extern const PALETTEENTRY g_pal16[];
const PALETTEENTRY g_pal16[] = // maps to 16 colors for standard 4-bpp palette
{
//    Red   Green Blue  Flags
    { 0x00, 0x00, 0x00, 0x00 },
    { 0x80, 0x00, 0x00, 0x00 },
    { 0x00, 0x80, 0x00, 0x00 },
    { 0x80, 0x80, 0x00, 0x00 },
    { 0x00, 0x00, 0x80, 0x00 },
    { 0x80, 0x00, 0x80, 0x00 },
    { 0x00, 0x80, 0x80, 0x00 },
    { 0xC0, 0xC0, 0xC0, 0x00 },
    { 0x80, 0x80, 0x80, 0x00 },
    { 0xFF, 0x00, 0x00, 0x00 },
    { 0x00, 0xFF, 0x00, 0x00 },
    { 0xFF, 0xFF, 0x00, 0x00 },
    { 0x00, 0x00, 0xFF, 0x00 },
    { 0xFF, 0x00, 0xFF, 0x00 },
    { 0x00, 0xFF, 0xFF, 0x00 },
    { 0xFF, 0xFF, 0xFF, 0x00 }
};

extern const PALETTEENTRY g_pal2[];
const PALETTEENTRY g_pal2[] = // maps to 2 colors for standard 1-bpp palette
{
//    Red   Green Blue  Flags
    { 0x00, 0x00, 0x00, 0x00 },
    { 0xFF, 0xFF, 0xFF, 0x00 }
};

#endif // !defined(NODD)

CGlobalCriticalSection    g_csOscCache;

#define DEFAULT_HEIGHT 150

struct
{
    SIZE        _sizeTgt;
    long        _areaTgt;
    SIZE        _size;
    long        _cHits;
    long        _cMisses;
    HDC         _hdcMem;
    HPALETTE    _hpal;
    long        _cBitsPixel;
    BOOL        _fInUse;
    HBITMAP     _hbmMem;
    HBITMAP     _hbmOld;
#if !defined(NODD)
    BOOL        _fUseDD;
    BOOL        _fUse3D;
    IDirectDrawSurface* _pDDSurface;
#endif // !defined(NODD)
} g_OscCache = { 0, DEFAULT_HEIGHT };

DeclareTag(tagPalette, "Palette", "Trace Palette and ColorSet behaviour");

long GetCacheAreaTgt()
{
#if DBG==1 || defined(PERFTAGS)

    if (IsPerfDbgEnabled(tagOscFullsize))
        g_OscCache._sizeTgt.cy = GetSystemMetrics(SM_CYSCREEN);
    else if (IsPerfDbgEnabled(tagOscTinysize))
        g_OscCache._sizeTgt.cy = 8;
    else 
        g_OscCache._sizeTgt.cy = DEFAULT_HEIGHT;

    g_OscCache._sizeTgt.cx = 0;

#endif // DBG==1 || defined(PERFTAGS)
    if (g_OscCache._sizeTgt.cx == 0)
    {
        g_OscCache._sizeTgt.cx = GetSystemMetrics(SM_CXSCREEN);
        g_OscCache._areaTgt = g_OscCache._sizeTgt.cx * g_OscCache._sizeTgt.cy;
    }
    return g_OscCache._areaTgt;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::COffScreenContext
//
//  Synopsis:   Setup a DD surface or DDB for offscreen drawing.
//
//-------------------------------------------------------------------------

COffScreenContext::COffScreenContext(HDC hdcWnd, long width, long height, HPALETTE hpal, DWORD dwFlags)
{
#if !defined(NODD)
    _fUseDD = !!(dwFlags & (OFFSCR_SURFACE | OFFSCR_3DSURFACE | OFFSCR_BPP));
    _fUse3D = !!(dwFlags & OFFSCR_3DSURFACE);

#if DBG==1 || defined(PERFTAGS)
    _fUseDD |= !!IsPerfDbgEnabled(tagOscUseDD);
#endif // DBG==1 || defined(PERFTAGS)
#endif // !defined(NODD)

    GetCacheAreaTgt();

    Assert(hdcWnd);
    _hdcWnd = hdcWnd;
    _hdcMem = NULL;

    _nSavedDC = 0;
    _fOffScreen = FALSE;
    _hbmMem = NULL;
#if !defined(NODD)
    _pDDSurface = NULL; 
#endif // !defined(NODD)

    // zero width means use default cache dimensions
    if (width == 0)
    {
        _widthActual  = g_OscCache._sizeTgt.cx;
        _heightActual = g_OscCache._sizeTgt.cy;
    }
    else
    {
        _widthActual  = width;
        _heightActual = height;
    }

#if DBG == 1
    extern void DumpPalette(CHAR *sz, HPALETTE hpal);

    DumpPalette("Destination DC", (HPALETTE)GetCurrentObject(hdcWnd, OBJ_PAL));
    DumpPalette("Offscreen buffer", hpal);
#endif

    _fCaret = !!(dwFlags & OFFSCR_CARET);

    _cBitsPixel = dwFlags & OFFSCR_BPP;
    switch (_cBitsPixel)
    {
    case 1:
    case 4:
    case 8:
    case 16:
    case 24:
    case 32:
        break;
    default:
        // if the hdc could be an OBJ_MEMDC we'd have to GetCurrentObject(HBITMAP)
        // and GetObject() to get the cBitsPixel
        //NOTE GetObjectType throws first change exceptions. Turn off to clean up dbg output.
        //Assert(GetObjectType(_hdcWnd) == OBJ_DC);

        // here we handle poorly-specified cases, but especially
        // (from the bufferDepth property):
        //       0 - which means DEFAULT DDB buffering at the screen depth
        //      -1 - which means EXPLICIT DD surface buffering at the screen depth
        _cBitsPixel = GetDeviceCaps(_hdcWnd, PLANES) * GetDeviceCaps(_hdcWnd, BITSPIXEL);
        break;
    }

#if !defined(NODD)
    TraceTag((tagOscStats, "OffScreen construct - DD: %d width: %d height: %d BitsPixel: %d",
            _fUseDD, _widthActual, _heightActual, _cBitsPixel));
#endif

    if (_cBitsPixel == 8)
    {
        if (hpal == NULL)
        {
            Assert(g_hpalHalftone);
            hpal = g_hpalHalftone;
        }
    }
    else
    {
        hpal = NULL;
    }

#if !defined(NODD)
    // we either need to use one or we already have one (frankman)
    if (_fUseDD || g_OscCache._pDDSurface)
    {
        _fUseDD = TRUE; 
	    if (!GetDDSurface(hpal))
            return;
    }
    else
#endif // !defined(NODD)
    {
	    if (!GetDDB(hpal))
            return;
    }

    // We have succesfully created the offscreen context.

    _fOffScreen = TRUE;

    // set palette
    if (hpal)
    {
        Verify(SelectPalette(_hdcMem, hpal, TRUE));
        RealizePalette(_hdcMem);
    }

    TraceTag((tagOscStats, "OffScreen Cache - hits: %d misses: %d widthTgt: %d heightTgt: %d",
            g_OscCache._cHits, g_OscCache._cMisses,
            g_OscCache._sizeTgt.cx, g_OscCache._sizeTgt.cy));

    return;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::GetDC
//
//  Synopsis:   Get the DC and establish view parameters.
//
//-------------------------------------------------------------------------

HDC COffScreenContext::GetDC(RECT *prc)
{
    if (_fOffScreen)
    {
        _rc = *prc;
        _nSavedDC = SaveDC(_hdcMem);
        Assert(_nSavedDC);
#if DBG==1
        if (IsTagEnabled(tagOscClear))
        {
            HBRUSH  hbr;
            RECT    rc;

            // Fill the rect with green
            hbr = GetCachedBrush(RGB(0,255,0));
            SetRect(&rc, 0, 0, _widthActual, _heightActual);
            FillRect(_hdcMem, &rc, hbr);
            ReleaseCachedBrush(hbr);
        }
#endif
        SetViewportOrgEx(_hdcMem, -_rc.left, -_rc.top, (POINT *)NULL);
        return _hdcMem;
    }
    return _hdcWnd;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::ReleaseDC
//
//  Synopsis:   If painting offscreen, blt the bits to the screen.
//
//-------------------------------------------------------------------------

HDC COffScreenContext::ReleaseDC(HWND hwnd, BOOL fDraw /* = TRUE */ )
{
    if (_fOffScreen)
    {
        if (fDraw)
        {
            if (_fCaret)
            {
                ::HideCaret(hwnd);
            }
            
            BitBlt(_hdcWnd, _rc.left, _rc.top, _rc.right - _rc.left, _rc.bottom - _rc.top,
                _hdcMem, _rc.left, _rc.top,
                SRCCOPY);
            
            if (_fCaret)
            {
                ::ShowCaret(hwnd);
            }
        }

        if (_nSavedDC)
        {
            Verify(RestoreDC(_hdcMem, _nSavedDC));
            _nSavedDC = 0;
        }
    }
    return _hdcWnd;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::~COffScreenContext()
//
//  Synopsis:   Release resources used by this class.
//
//-------------------------------------------------------------------------

COffScreenContext::~COffScreenContext()
{
    _fOffScreen = FALSE;
    if (_nSavedDC)
    {
        // restore the DC for the cached case
        Verify(RestoreDC(_hdcMem, _nSavedDC));
        _nSavedDC = 0;
    }

	// Put back a reasonable palette so ours can be deleted safely
	Verify(SelectPalette(_hdcMem, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));

#if !defined(NODD)
    if (_fUseDD)
    {
        ReleaseDDSurface();
    }
    else
#endif // !defined(NODD)
    {
        ReleaseDDB();
    }
}

#if !defined(NODD)
//+------------------------------------------------------------------------
//
//  Function:   ClearSurfaceCache()
//
//  Synopsis:   Free the cached DD surface, if any.
//
//-------------------------------------------------------------------------

void ClearSurfaceCache()
{
    // Quick test without entering critical section, then retest afterwards in case it
    // changes.

    if (!g_OscCache._fInUse && g_OscCache._fUseDD && g_OscCache._pDDSurface != NULL)
    {
        LOCK_SECTION(g_csOscCache);

        if (!g_OscCache._fInUse && g_OscCache._fUseDD && g_OscCache._pDDSurface != NULL)
        {
            TraceTag((tagOscStats, "surface cache deleted"));
            if (g_OscCache._hdcMem)
            {
                Verify(SelectPalette(g_OscCache._hdcMem, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));
                Verify(g_OscCache._pDDSurface->ReleaseDC(g_OscCache._hdcMem) == DD_OK);
                g_OscCache._hdcMem = NULL;
            }
            ClearInterface(&g_OscCache._pDDSurface);
            g_OscCache._fUseDD = FALSE;
        }
    }
}
#endif // !defined(NODD)

//+------------------------------------------------------------------------
//
//  Function:   ClearDDBCache()
//
//  Synopsis:   Free the cached DDD, if any.
//
//-------------------------------------------------------------------------

void ClearDDBCache()
{
    if (!g_OscCache._fInUse && 
#if !defined(NODD)
        !g_OscCache._fUseDD &&
#endif // !defined(NODD)
        g_OscCache._hbmMem != NULL)
    {
        TraceTag((tagOscStats, "DDB cache deleted"));
        if (g_OscCache._hdcMem)
        {
            if (g_OscCache._hbmOld)
                SelectObject(g_OscCache._hdcMem, g_OscCache._hbmOld);
            g_OscCache._hbmOld = NULL;
            DeleteDC(g_OscCache._hdcMem);
            g_OscCache._hdcMem = NULL;
        }
        DeleteObject(g_OscCache._hbmMem);
        g_OscCache._hbmMem = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   InitSurface
//
//  Synopsis:   Allocate DirectDraw object which is used to create surfaces
//              for offscreen rendering
//
//-----------------------------------------------------------------------------

HRESULT InitSurface()
{
#if !defined(NODD)

    if (g_hrDirectDraw || g_pDirectDraw)  // DD already initialized (or failed)
        return(g_hrDirectDraw);

#ifdef PRODUCT_PROF_FERG
    // for PROFILING perposes only
    ::SuspendCAP();
#endif

    LOCK_SECTION(g_csOscCache);

    // Check again after obtaining the lock
    // (since another thread could have made the attempt while we waited)
    if (g_hrDirectDraw || g_pDirectDraw)
        return (g_hrDirectDraw);

    IDirectDrawFactory* pDDFactory = NULL;
    // create the DDFactory used to create the DirectDraw object
    g_hrDirectDraw = THR(CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC_SERVER,
                           IID_IDirectDrawFactory, (void **)&pDDFactory));
    if (SUCCEEDED(g_hrDirectDraw))
    {
        // DirectDraw will put up annoying UI if the bpp is less than 8.
        // Low bpp video cards are simply not support.  Force DirectDraw to
        // silently quietly fail under this circumstance.
        DWORD dwMode = SetErrorMode( SEM_FAILCRITICALERRORS );

        // create the actual DirectDraw object from which we can create surfaces later
        g_hrDirectDraw = THR(pDDFactory->CreateDirectDraw(NULL, GetDesktopWindow(),
                                            DDSCL_NORMAL, 0, NULL, &g_pDirectDraw));
        SetErrorMode( dwMode );

        // release the factory
        ReleaseInterface((IUnknown*)pDDFactory);
    }
#ifdef PRODUCT_PROF_FERG
    // for PROFILING perposes only
    ::ResumeCAP();
#endif

    RRETURN(g_hrDirectDraw);
#else
    return S_OK;
#endif // !defined(NODD)
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitSurface
//
//  Synopsis:   Release the DirectDraw surface factory and all our cached surfaces.
//
//-----------------------------------------------------------------------------

void DeinitSurface()
{
    LOCK_SECTION(g_csOscCache);
#if !defined(NODD)
    ClearSurfaceCache();
    ClearInterface(&g_pDirectDraw);
#endif // !defined(NODD)
    ClearDDBCache();
    TraceTag((tagOscStats, "OffScreen Cache - hits: %d misses: %d widthTgt: %d heightTgt: %d",
            g_OscCache._cHits, g_OscCache._cMisses,
            g_OscCache._sizeTgt.cx, g_OscCache._sizeTgt.cy));
}

#if !defined(NODD)
// NOTE: can't be const, modified by PixelFormat()
DDPIXELFORMAT aPixelFormats[] =
{
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED1, 0, 1, 0, 0, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED4, 0, 4, 0, 0, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0, 0, 0, 0}, 
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x0000F800, 0x000007E0, 0x0000001F, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0}
};

//+------------------------------------------------------------------------
//
//  Function:   PixelFormat()
//
//  Synopsis:   Return a pointer to the DDPIXELFORMAT structure compatible
//              with the specified bits-per-pixel (and HDC, if 16-bpp).
//
//-------------------------------------------------------------------------

DDPIXELFORMAT* PixelFormat(HDC hdc, long cBitsPixel)
{
    static BOOL fMaskInit = FALSE;

    DDPIXELFORMAT* pPF = NULL;
    for (int i = 0; i < ARRAY_SIZE(aPixelFormats); i++)
    {
        if (aPixelFormats[i].dwRGBBitCount == (DWORD)cBitsPixel)
        {
            pPF = &aPixelFormats[i];
            break;
        }
    }

    if (cBitsPixel == 16 && !fMaskInit)
    {
        // for 16-bit displays we need to decide if we're 555 or 565
        // cacheing this answer assumes we're only dealing with 16-bit
        // screen displays and that the bit format won't change on the fly
        fMaskInit = TRUE;
        HBITMAP hbm;
        struct
        {
            BITMAPINFOHEADER bih;
            DWORD            bf[3];
        }   bi;
        hbm = CreateCompatibleBitmap(hdc, 1, 1);
        if (!hbm)
            return NULL;
        memset(&bi, 0, sizeof(bi));
        bi.bih.biSize = sizeof(BITMAPINFOHEADER);

        // first call will fill in the optimal biBitCount
        GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
        if (bi.bih.biBitCount == 16)
        {
            // we'll default to the preset 5-6-5 if screen is not in 16-bit mode
            // second call will get the optimal bitfields
            GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
            // Win95 only supports 5-5-5 and 5-6-5
            // For NT we'll assume this covers the majority cases too
            pPF->dwRBitMask = bi.bf[0]; // red mask
            pPF->dwGBitMask = bi.bf[1]; // green mask
            pPF->dwBBitMask = bi.bf[2]; // blue mask
        }
        else
        {
            Assert(0 && "invalid biBitCount");
        }
        DeleteObject(hbm);
    }
    return pPF;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::CreateDDSurface
//
//  Synopsis:   Create a DD surface with the specified dimensions and palette.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::CreateDDSurface(long width, long height, HPALETTE hpal)
{
    HRESULT hr = InitSurface();
    if (FAILED(hr))
        return FALSE;

    DDPIXELFORMAT* pPF = PixelFormat(_hdcWnd, _cBitsPixel);
    if (!pPF)
        return FALSE;

    DDSURFACEDESC	ddsd;

	ddsd.dwSize = sizeof(ddsd);
    ddsd.ddpfPixelFormat = *pPF;
	ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	ddsd.ddsCaps.dwCaps = DDSCAPS_DATAEXCHANGE | DDSCAPS_OWNDC;
    if (_fUse3D)
        ddsd.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
	ddsd.dwWidth = width;
	ddsd.dwHeight = height;
	hr = THR(g_pDirectDraw->CreateSurface(&ddsd, &_pDDSurface, NULL));
    if (FAILED(hr))
        return FALSE;

    // set color table
    if (_cBitsPixel <= 8)
    {
        IDirectDrawPalette* pDDPal;
        const PALETTEENTRY* pPal;
        PALETTEENTRY        pal256[256];
        long                cEntries;
        DWORD		        pcaps;
        
        if (_cBitsPixel == 8)
        {
            cEntries = GetPaletteEntries(hpal, 0, 256, pal256);
            pPal = pal256;
            pcaps = DDPCAPS_8BIT;
        }
        else if (_cBitsPixel == 4)
        {
            cEntries = 16;
            pPal = g_pal16;
            pcaps = DDPCAPS_4BIT;
        }
        else if (_cBitsPixel == 1)
        {
            cEntries = 2;
            pPal = g_pal2;
            pcaps = DDPCAPS_1BIT;
        }
        else
        {
            Assert(0 && "invalid cBitsPerPixel");
            return FALSE;
        }
        
        // create and initialize a new DD palette
        hr = THR(g_pDirectDraw->CreatePalette(pcaps | DDPCAPS_INITIALIZE, (LPPALETTEENTRY) pPal, &pDDPal, NULL));
        if (SUCCEEDED(hr))
        {
            // attach the DD palette to the DD surface
            hr = THR(_pDDSurface->SetPalette(pDDPal));
            pDDPal->Release();
        }
        if (FAILED(hr))
            return FALSE;
    }


    hr = THR(_pDDSurface->GetDC(&_hdcMem));
    return SUCCEEDED(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::GetDDSurface
//
//  Synopsis:   Create a suitable DD surface or get one from the cache.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::GetDDSurface(HPALETTE hpal)
{
    HRESULT hr;

    LOCK_SECTION(g_csOscCache);

    if (!g_OscCache._fInUse
#if DBG==1 || defined(PERFTAGS)
         && !IsPerfDbgEnabled(tagOscCacheDisable)
#endif
         )
    {
        ClearDDBCache();    // don't allow both DD & DDB in the cache

        if (g_OscCache._pDDSurface != NULL)
        {
            Assert(g_OscCache._fUseDD);
            if (_widthActual > g_OscCache._size.cx
                || _heightActual > g_OscCache._size.cy
                || _cBitsPixel != g_OscCache._cBitsPixel
                || (_fUse3D && !g_OscCache._fUse3D))
            {
                ++g_OscCache._cMisses;
                ClearSurfaceCache();
            }
            else
            {
                ++g_OscCache._cHits;
                g_OscCache._fInUse = TRUE;
                _pDDSurface   = g_OscCache._pDDSurface;
                _pDDSurface->AddRef();
                _hdcMem       = g_OscCache._hdcMem;
                _widthActual  = g_OscCache._size.cx;
                _heightActual = g_OscCache._size.cy;
            }
        }
        if (g_OscCache._pDDSurface == NULL)
        {
            // use max area allowed for the cache, so we get max reuse potential
            // favor width over height for those wide text runs
            // also adjust the max size in a growing fashion based on former allocations
            
            g_OscCache._size.cx  = max(g_OscCache._size.cx, max(min(g_OscCache._areaTgt / _heightActual, g_OscCache._sizeTgt.cx), _widthActual));
            g_OscCache._size.cy = max(g_OscCache._size.cy , max(g_OscCache._areaTgt / g_OscCache._size.cx, _heightActual));
            if (!CreateDDSurface(g_OscCache._size.cx, g_OscCache._size.cy, hpal))
                return FALSE;
            TraceTag((tagOscStats, "surface cache created"));
            g_OscCache._fInUse     = TRUE;
            g_OscCache._fUseDD     = TRUE;
            g_OscCache._fUse3D     = _fUse3D;
            g_OscCache._pDDSurface = _pDDSurface;
            g_OscCache._pDDSurface->AddRef();        // addref the global surface
            g_OscCache._cBitsPixel = _cBitsPixel;
            g_OscCache._hdcMem     = _hdcMem;
            g_OscCache._hpal       = hpal;
            _widthActual           = g_OscCache._size.cx;
            _heightActual          = g_OscCache._size.cy;
        }
    }
    else
    {
        TraceTag((tagOscStats, "surface cache in use"));
    }

    if (_pDDSurface == NULL)
    {
        if (!CreateDDSurface(_widthActual, _heightActual, hpal))
            return FALSE;
    }

    // reset the color table when using cache
    if (_cBitsPixel == 8
        && _pDDSurface == g_OscCache._pDDSurface
        && hpal != g_OscCache._hpal
        && hpal != g_hpalHalftone)
    {
        IDirectDrawPalette* pDDPal;
        PALETTEENTRY        pal256[256];
        long                cEntries;
        
        cEntries = GetPaletteEntries(hpal, 0, 256, pal256);
        
        // get the DD palette and set entries
        hr = THR(_pDDSurface->GetPalette(&pDDPal));
        if (SUCCEEDED(hr))
        {
            hr = THR(pDDPal->SetEntries(0, 0, cEntries, pal256));
            pDDPal->Release();
            if (SUCCEEDED(hr))
            {
                g_OscCache._hpal = hpal;
            }
        }
    }

    return TRUE;
}
    
//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::ReleaseDDSurface
//
//  Synopsis:   Release the DD surface or return it to the cache.
//
//-------------------------------------------------------------------------

void COffScreenContext::ReleaseDDSurface()
{
    if (_pDDSurface == NULL)
        return;
    
    if (_pDDSurface == g_OscCache._pDDSurface)
    {
        // keep the surface cache; mark as available
        LOCK_SECTION(g_csOscCache);

        Assert(g_OscCache._fInUse);
        g_OscCache._fInUse = FALSE; 
        
        // If some rogue client left the surface locked we could be locked out for a long time.
        // So, to be more robust, we attempt to lock the surface and if we fail, we discard the
        // cache so we can start fresh next time.
        DDSURFACEDESC desc;
        desc.dwSize = sizeof(desc);

        HRESULT hr = _pDDSurface->Lock(NULL, &desc, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
        if (hr == S_OK)
        {
            _pDDSurface->Unlock(NULL);
        }
        else
        {
            Assert(0 && "DD surface left locked!");
            // release the surface cache
            ClearSurfaceCache();
        }
        _pDDSurface->Release();

    }
    else
    {
        // free the non-cached surface
        if (_hdcMem)
        {
            _pDDSurface->ReleaseDC(_hdcMem);
            _hdcMem = NULL;
        }
        _pDDSurface->Release();
    }
    _pDDSurface = NULL;
}
#endif // !defined(NODD)


//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::CreateDDB
//
//  Synopsis:   Create a DDB with the specified dimensions.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::CreateDDB(long width, long height)
{
    _hbmMem = CreateCompatibleBitmap(_hdcWnd, width, height);
    if (!_hbmMem)
        return FALSE;

    _hdcMem = CreateCompatibleDC(_hdcWnd);
    if (!_hdcMem)
        return FALSE;

    _hbmOld = (HBITMAP)SelectObject(_hdcMem, _hbmMem);
    if (!_hbmOld)
        return FALSE;

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::GetDDB
//
//  Synopsis:   Create a suitable DDB or get one from the cache.
//
//-------------------------------------------------------------------------

BOOL COffScreenContext::GetDDB(HPALETTE hpal)
{
    LOCK_SECTION(g_csOscCache);

    if (!g_OscCache._fInUse
#if DBG==1 || defined(PERFTAGS)
         && !IsPerfDbgEnabled(tagOscCacheDisable)
#endif
         )
    {
#if !defined(NODD)
        ClearSurfaceCache();    // don't allow both DD & DDB in the cache
#endif // !defined(NODD)

        if (g_OscCache._hbmMem != NULL)
        {
            if (_widthActual > g_OscCache._size.cx
                || _heightActual > g_OscCache._size.cy
                || _cBitsPixel != g_OscCache._cBitsPixel)
            {
                ++g_OscCache._cMisses;
                ClearDDBCache();
            }
            else
            {
                ++g_OscCache._cHits;
                g_OscCache._fInUse = TRUE;
                _hbmMem       = g_OscCache._hbmMem;
                _hdcMem       = g_OscCache._hdcMem;
                _widthActual  = g_OscCache._size.cx;
                _heightActual = g_OscCache._size.cy;
            }
        }
        if (g_OscCache._hbmMem == NULL
            && _widthActual * _heightActual <= g_OscCache._areaTgt)
        {
            // use max area allowed for the cache, so we get max reuse potential
            // favor width over height for those wide text runs
            g_OscCache._size.cx  = max(min(g_OscCache._areaTgt / _heightActual, g_OscCache._sizeTgt.cx), _widthActual);
            g_OscCache._size.cy = max(g_OscCache._areaTgt / g_OscCache._size.cx, _heightActual);
            if (!CreateDDB(g_OscCache._size.cx, g_OscCache._size.cy))
                return FALSE;
            TraceTag((tagOscStats, "DDB cache created"));
            g_OscCache._fInUse     = TRUE;
            g_OscCache._hbmMem     = _hbmMem;
            g_OscCache._hbmOld     = _hbmOld;
            g_OscCache._cBitsPixel = _cBitsPixel;
            g_OscCache._hdcMem     = _hdcMem;
            g_OscCache._hpal       = hpal;
            _widthActual           = g_OscCache._size.cx;
            _heightActual          = g_OscCache._size.cy;
        }
    }
    else
    {
        TraceTag((tagOscStats, "DDB cache in use"));
    }

    if (_hbmMem == NULL)
    {
        if (!CreateDDB(_widthActual, _heightActual))
            return FALSE;
    }

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     COffScreenContext::ReleaseDDB
//
//  Synopsis:   Release the DDB or return it to the cache.
//
//-------------------------------------------------------------------------

void COffScreenContext::ReleaseDDB()
{
    if (_hbmMem == NULL)
        return;

    if (_hbmMem == g_OscCache._hbmMem)
    {
        // keep the DDB cache; mark as available
        LOCK_SECTION(g_csOscCache);
        Assert(g_OscCache._fInUse);
        g_OscCache._fInUse = FALSE;
    }
    else
    {
        // Prevent Windows from RIPing when we delete our palette later on
        Verify(SelectPalette(_hdcMem, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));

        // free the non-cached DDB
        if (_hbmOld)
            SelectObject(_hdcMem, _hbmOld);
        _hbmOld = NULL;
        DeleteDC(_hdcMem);
        _hdcMem = NULL;
        DeleteObject(_hbmMem);
    }
    _hbmMem = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\memutils.cxx ===
//+------------------------------------------------------------------------
//
//  File:       memutil.cxx
//
//  Contents:   Memory utilities
//
//  History:    30-Oct-94   GaryBu  Consolidated from places far & wide.
//              06-Jul-95   PaulG   Macintosh compiles now use Global instead
//                                  of Heap memory functions
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_VMEM_HXX_
#define X_VMEM_HXX_
#include "vmem.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#if TIMEHEAP
#define HeapBegTimer(x) SwitchesBegTimer(x)
#define HeapEndTimer(x) SwitchesEndTimer(x)
#else
#define HeapBegTimer(x)
#define HeapEndTimer(x)
#endif

MtDefine(PerfPigs, NULL, "MSHTML Performance Pigs")
MtDefine(Metrics, NULL, "MSHTML Metrics")
MtDefine(WorkingSet, NULL, "MSHTML Working Set")
MtDefine(Mem, WorkingSet, "MemAlloc")
MtDefine(OpNew, Mem, "operator new")
MtDefine(Locals, Mem, "Per Function Local")
MtDefine(PerThread, Mem, "Per Thread Global")
MtDefine(PerProcess, Mem, "Per Process Global")
MtDefine(Layout, Mem, "Layout")
MtDefine(ObjectModel, Mem, "Object Model")
MtDefine(Utilities, Mem, "Utilities")
MtDefine(Printing, Mem, "Printing")
MtDefine(Tree, Mem, "Tree")
MtDefine(Edit, Mem, "Edit")
MtDefine(Behaviors, Mem, "Behaviors")

EXTERN_C HANDLE g_hProcessHeap;

#if !defined(UNIX) && !defined(_MAC) && !defined(_M_AMD64) && !defined(_M_IA64) && !defined(SLOWALLOC)
#define SMALLBLOCKHEAP 1
#endif

// DbgExCheckHeap -------------------------------------------------------------

#if DBG==1

DeclareTag(tagNoCheckHeap, "!Memory", "Disable CHECK_HEAP() macro");

void WINAPI
DbgExCheckHeap()
{
    if (!DbgExIsTagEnabled(tagNoCheckHeap))
    {
        AssertSz(DbgExValidateInternalHeap(), "Internal heap is corrupt!");
        AssertSz(CheckSmallBlockHeap(), "Small block heap is corrupt!");
    }
}

#endif

//+------------------------------------------------------------------------
// Allocation functions not implemented in this file:
//
//      CDUTIL.HXX
//          operator new
//          operator delete
//
//      OLE's OBJBASE.H
//          CoTaskMemAlloc, CoTaskMemFree
//
//-------------------------------------------------------------------------

#if SMALLBLOCKHEAP

DeclareTag(tagSmallBlockHeap, "!Memory", "Check small block heap every time")
DeclareTag(tagSmallBlockHeapDisable, "!Memory", "Disable small block heap");

#define _CRTBLD 1
#include "winheap.h"
EXTERN_C CRITICAL_SECTION g_csHeap;

#if DBG == 1
#define CHECKSBH if (IsTagEnabled(tagSmallBlockHeap)) {Assert(CheckSmallBlockHeap() && "Small block heap corrupt");};
BOOL IsSmallBlockHeapEnabled()
{
    static int g_fSmallBlockHeap = -1;
    if (g_fSmallBlockHeap == -1)
        g_fSmallBlockHeap = IsTagEnabled(tagSmallBlockHeapDisable) ? 0 : 1;
    return(g_fSmallBlockHeap == 1);
}
BOOL CheckSmallBlockHeap()
{
    if (IsSmallBlockHeapEnabled())
    {
        EnterCriticalSection(&g_csHeap);
        BOOL f = __sbh_heap_check() >= 0;
        LeaveCriticalSection(&g_csHeap);
        return f;
    }
    return TRUE;
}
#else
#define CHECKSBH
#endif

#else

#if DBG == 1
BOOL CheckSmallBlockHeap()
{
    return TRUE;
}
#endif

#endif SMALLBLOCKHEAP

#if DBG==1

static BOOL  g_fVMemInit    = FALSE;
static BOOL  g_fVMemEnable  = FALSE;
static DWORD g_dwFlagsVMem  = 0;

BOOL
IsVMemEnabled()
{
    if (!g_fVMemInit)
    {
        g_fVMemEnable = IsTagEnabled(tagMemoryStrict);

        if (IsTagEnabled(tagMemoryStrictTail))
        {
            g_dwFlagsVMem |= VMEM_BACKSIDESTRICT;

            if (IsTagEnabled(tagMemoryStrictAlign))
            {
                g_dwFlagsVMem |= VMEM_BACKSIDEALIGN8;
            }
        }

        g_fVMemInit = TRUE;
    }

    return(g_fVMemEnable);
}

#define VMEM

#elif defined(PERFTAGS) && !defined(PERFMETER)

PerfTag(tgMemoryStrict,        "!Memory", "Use VMem for MemAlloc")
PerfTag(tgMemoryStrictHead,    "!Memory", "VMem strict at beginning (vs end)")
PerfTag(tgMemoryStrictAlign,   "!Memory", "VMem pad to quadword at end")

static BOOL  g_fVMemInit   = FALSE;
static BOOL  g_fVMemEnable = FALSE;
static DWORD g_dwFlagsVMem = 0;

BOOL
IsVMemEnabled()
{
    if (!g_fVMemInit)
    {
        g_fVMemEnable = IsPerfEnabled(tgMemoryStrict);

        if (!IsPerfEnabled(tgMemoryStrictHead))
        {
            g_dwFlagsVMem |= VMEM_BACKSIDESTRICT;

            if (IsPerfEnabled(tgMemoryStrictAlign))
            {
                g_dwFlagsVMem |= VMEM_BACKSIDEALIGN8;
            }
        }

        g_fVMemInit = TRUE;
    }

    return(g_fVMemEnable);
}

#define VMEM

#elif defined(USE_VMEM_FOR_MEMALLOC)

#ifdef VMEM_FOR_MEMALLOC_FLAGS
#define g_dwFlagsVMem   VMEM_FOR_MEMALLOC_FLAGS
#else
#define g_dwFlagsVMem   VMEM_BACKSIDESTRICT
#endif

BOOL
IsVMemEnabled()
{
    return(TRUE);
}

#define VMEM

#endif

//+------------------------------------------------------------------------
//
//  Function:   _MemGetSize
//
//  Synopsis:   Get size of block allocated with MemAlloc/MemRealloc.
//
//              Note that MemAlloc/MemRealloc can allocate more than
//              the requested number of bytes. Therefore the size returned
//              from this function is possibly greater than the size
//              passed to MemAlloc/Realloc.
//
//  Arguments:  [pv] - Return size of this block.
//
//  Returns:    The size of the block, or zero of pv == NULL.
//
//-------------------------------------------------------------------------
ULONG
_MemGetSize(void *pv)
{
    if (pv == NULL)
        return 0;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemGetSize(pv));
    }
#endif

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;
        __map_t *           pmap;

        EnterCriticalSection(&g_csHeap);

        HeapBegTimer(SWITCHES_TIMER_SBHEAP_GETSIZE);

        if ((pmap = __sbh_find_block(DbgPreGetSize(pv), &preg, &ppage)) != NULL )
        {
            Assert(*pmap != 0);
            size_t s = DbgPostGetSize(((size_t)(*pmap)) << _PARASHIFT);

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_GETSIZE);

            LeaveCriticalSection(&g_csHeap);

            return s;
        }

        HeapEndTimer(SWITCHES_TIMER_SBHEAP_GETSIZE);

        LeaveCriticalSection(&g_csHeap);
    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_GETSIZE);

    ULONG cbRet = DbgPostGetSize(HeapSize(g_hProcessHeap, 0, DbgPreGetSize(pv)));

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_GETSIZE);

    return cbRet;
}

//+------------------------------------------------------------------------
//
//  Function:   _MemAlloc
//
//  Synopsis:   Allocate block of memory.
//
//              The contents of the block are undefined.  If the requested size
//              is zero, this function returns a valid pointer.  The returned
//              pointer is guaranteed to be suitably aligned for storage of any
//              object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAlloc(ULONG cb)
{
    AssertSz (cb, "Requesting zero sized block.");
    void * pvRet;

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemAlloc(cb, g_dwFlagsVMem));
    }
#endif


    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;

            EnterCriticalSection(&g_csHeap);

            HeapBegTimer(SWITCHES_TIMER_SBHEAP_ALLOC);

            pvRet = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_ALLOC);

            LeaveCriticalSection(&g_csHeap);
            Assert(!pvRet || _MemGetSize(pvRet) >= cb);
            if (pvRet)
            {
                return pvRet;
            }

        }
    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_ALLOC);

    pvRet = DbgPostAlloc(HeapAlloc(g_hProcessHeap, 0, DbgPreAlloc(cb)));

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_ALLOC);

    return pvRet;
}


//+------------------------------------------------------------------------
//  Function:   _MemAllocClear
//
//  Synopsis:   Allocate a zero filled block of memory.
//
//              If the requested size is zero, this function returns a valid
//              pointer. The returned pointer is guaranteed to be suitably
//              aligned for storage of any object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAllocClear(ULONG cb)
{
    AssertSz (cb, "Allocating zero sized block.");

    void * pvRet;

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemAllocClear(cb, g_dwFlagsVMem));
    }
#endif

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;


            EnterCriticalSection(&g_csHeap);

            HeapBegTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);

            pvRet = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);

            LeaveCriticalSection(&g_csHeap);
            Assert(!pvRet || _MemGetSize(pvRet) >= cb);
            if (pvRet)
            {
                HeapBegTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);
                memset(pvRet, 0, cb);
                HeapEndTimer(SWITCHES_TIMER_SBHEAP_ALLOCCLEAR);

                return pvRet;
            }

        }
    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_ALLOCCLEAR);

    pvRet = DbgPostAlloc(HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY,
                         DbgPreAlloc(cb)));

    // In debug, DbgPostAlloc set the memory so we need to clear it again.
    // On the Mac, HpAlloc doesn't support HEAP_ZERO_MEMORY.

#if DBG==1 || defined(_MAC)
    if (pvRet)
    {
        memset(pvRet, 0, cb);
    }
#endif

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_ALLOCCLEAR);

    return pvRet;
}

//+------------------------------------------------------------------------
//
//  Function:   _MemFree
//
//  Synopsis:   Free a block of memory allocated with MemAlloc,
//              MemAllocFree or MemRealloc.
//
//  Arguments:  [pv] - Pointer to block to free.  A value of zero is
//              is ignored.
//
//-------------------------------------------------------------------------

void
_MemFree(void *pv)
{
    // The null check is required for HeapFree.
    if (pv == NULL)
        return;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        VMemFree(pv);
        return;
    }
#endif

    Assert(g_hProcessHeap);

#if DBG == 1
    pv = DbgPreFree(pv);
#endif

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *preg;
        __sbh_page_t *  ppage;
        __map_t *       pmap;

        CHECKSBH;

        EnterCriticalSection(&g_csHeap);

        HeapBegTimer(SWITCHES_TIMER_SBHEAP_FREE);

        if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL ) {
            Assert(*pmap != 0);
            __sbh_free_block(preg, ppage, pmap);

            HeapEndTimer(SWITCHES_TIMER_SBHEAP_FREE);

            LeaveCriticalSection(&g_csHeap);
            DbgPostFree();

            return;
        }

        HeapEndTimer(SWITCHES_TIMER_SBHEAP_FREE);

        LeaveCriticalSection(&g_csHeap);

    }
#endif

    HeapBegTimer(SWITCHES_TIMER_PROCHEAP_FREE);

    HeapFree(g_hProcessHeap, 0, pv);

    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_FREE);

    DbgPostFree();
}

//+------------------------------------------------------------------------
//  Function:   _MemRealloc
//
//  Synopsis:   Change the size of an existing block of memory, allocate a
//              block of memory, or free a block of memory depending on the
//              arguments.
//
//              If cb is zero, this function always frees the block of memory
//              and *ppv is set to zero.
//
//              If cb is not zero and *ppv is zero, then this function allocates
//              cb bytes.
//
//              If cb is not zero and *ppv is non-zero, then this function
//              changes the size of the block, possibly by moving it.
//
//              On error, *ppv is left unchanged.  The block contents remains
//              unchanged up to the smaller of the new and old sizes.  The
//              contents of the block beyond the old size is undefined.
//              The returned pointer is guaranteed to be suitably aligned for
//              storage of any object type.
//
//              The signature of this function is different than thy typical
//              realloc-like function to avoid the following common error:
//                  pv = realloc(pv, cb);
//              If realloc fails, then null is returned and the pointer to the
//              original block of memory is leaked.
//
//  Arguments:  [cb] - Requested size in bytes. A value of zero always frees
//                  the block.
//              [ppv] - On input, pointer to existing block pointer or null.
//                  On output, pointer to new block pointer.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemRealloc(void **ppv, ULONG cb)
{
    void *  pv;

#ifdef VMEM
    if (IsVMemEnabled())
    {
        return(VMemRealloc(ppv, cb, g_dwFlagsVMem));
    }
#endif

    Assert(g_hProcessHeap);

    if (cb == 0)
    {
        _MemFree(*ppv);
        *ppv = 0;
    }
    else if (*ppv == NULL)
    {
        *ppv = _MemAlloc(cb);
        if (*ppv == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {
    #if DBG == 1
    	#if SMALLBLOCKHEAP
    	    ULONG cbReq = cb;
    	#endif
        cb = DbgPreRealloc(*ppv, cb, &pv);
    #else
        pv = *ppv;
    #endif

    #if SMALLBLOCKHEAP
    #if DBG==1
        if (IsSmallBlockHeapEnabled())
    #endif
        {
            __sbh_region_t *preg;
            __sbh_page_t *  ppage;
            __map_t *       pmap;
            ULONG           cbr;
            void *          pvNew;

            cbr = (cb + _PARASIZE - 1) & ~(_PARASIZE - 1);

            CHECKSBH;

            EnterCriticalSection(&g_csHeap);

            HeapBegTimer(SWITCHES_TIMER_SBHEAP_REALLOC);

            if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL )
            {
                Assert(*pmap != 0);

                pvNew = NULL;
                /*
                 * If the new size falls below __sbh_threshold, try to
                 * carry out the reallocation within the small-block
                 * heap.
                 */
                if ( cbr < __sbh_threshold ) {
                    if ( __sbh_resize_block(preg, ppage, pmap, cbr >> _PARASHIFT))
                    {
                        pvNew = pv;
                    }
                    else if ((pvNew = __sbh_alloc_block(cbr >> _PARASHIFT)) != NULL)
                    {
                        ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                        memcpy(pvNew, pv, min(cbOld, cb));
                        __sbh_free_block(preg, ppage, pmap);
                    }
                }

                HeapEndTimer(SWITCHES_TIMER_SBHEAP_REALLOC);

                /*
                 * If the reallocation has not been (successfully)
                 * performed in the small-block heap, try to allocate a
                 * new block with HeapAlloc.
                 */
                HeapBegTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

                if ((pvNew == NULL) && ((pvNew = HeapAlloc(g_hProcessHeap, 0, cb)) != NULL))
                {
                    ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                    memcpy(pvNew, pv, min(cbOld, cb));

                    HeapEndTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

                    __sbh_free_block(preg, ppage, pmap);
                }

                HeapEndTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

                LeaveCriticalSection(&g_csHeap);
                pv = DbgPostRealloc(pvNew);
                if (pv == NULL)
                {
                    return E_OUTOFMEMORY;
                }
                else
                {
#if DBG ==1
                    Assert(_MemGetSize(pv) >= cbReq);
#endif
                    *ppv = pv;
                    return S_OK;
                }
            }
            else
            {
                HeapEndTimer(SWITCHES_TIMER_SBHEAP_REALLOC);

                LeaveCriticalSection(&g_csHeap);
            }
        }

    #endif

        HeapBegTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

        pv = DbgPostRealloc(HeapReAlloc(g_hProcessHeap, 0, pv, cb));

        HeapEndTimer(SWITCHES_TIMER_PROCHEAP_REALLOC);

        *ppv = pv;
        if (pv == NULL)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

#if DBG==1

char *
_MemGetName(void * pv)
{
    return(DbgExMemGetName(pv));
}

void __cdecl
_MemSetName(void * pv, char * szFmt, ...)
{
    if (!IsVMemEnabled())
    {
        char szBuf[1024];
        va_list va;

        va_start(va, szFmt);
        wvsprintfA(szBuf, szFmt, va);
        va_end(va);

        DbgExMemSetName(pv, "%s", szBuf);
    }
}

void
_MemSetHeader(void * pv, ULONG cb, PERFMETERTAG mt)
{
#ifdef PERFMETER
    if (!IsVMemEnabled())
    {
        DbgExMemSetHeader(pv, cb, mt);
    }
#endif
}

#else

#define _MemSetHeader(pv, cb, mt)

#endif

// Metered Memory -------------------------------------------------------------

#ifdef PERFMETER

struct MTMEMBLK
{
    PERFMETERTAG    mt;
    ULONG           cb;
};

void *
_MtMemAlloc(PERFMETERTAG mt, ULONG cb)
{
    if (MtSimulateOutOfMemory(mt, -1))
    {
        return NULL;
    }

    MTMEMBLK * pmb = (MTMEMBLK *)_MemAlloc(sizeof(MTMEMBLK) + cb);

    if (pmb)
    {
        _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);
        pmb->mt = mt;
        pmb->cb = cb;
        MtAdd(mt, 1, (LONG)cb);
        return(pmb + 1);
    }
    else
    {
        return(NULL);
    }
}

void *
_MtMemAllocClear(PERFMETERTAG mt, ULONG cb)
{
    if (MtSimulateOutOfMemory(mt, -1))
    {
        return NULL;
    }

    MTMEMBLK * pmb = (MTMEMBLK *)_MemAllocClear(sizeof(MTMEMBLK) + cb);

    if (pmb)
    {
        _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);
        pmb->mt = mt;
        pmb->cb = cb;
        MtAdd(mt, 1, (LONG)cb);
        return(pmb + 1);
    }
    else
    {
        return(NULL);
    }
}

HRESULT
_MtMemRealloc(PERFMETERTAG mt, void ** ppv, ULONG cb)
{
    if (cb == 0)
    {
        _MtMemFree(*ppv);
        *ppv = 0;
        return(S_OK);
    }

    if (*ppv == NULL)
    {
        *ppv = _MtMemAlloc(mt, cb);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }

    MTMEMBLK *  pmb = (MTMEMBLK *)*ppv - 1;
    HRESULT     hr = _MemRealloc((void **)&pmb, sizeof(MTMEMBLK) + cb);

    if (hr == S_OK)
    {
        _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);

        if (pmb->mt == mt)
        {
            MtAdd(mt, 0, (LONG)cb - (LONG)pmb->cb);
        }
        else
        {
            MtAdd(pmb->mt, -1, -(LONG)pmb->cb);
            pmb->mt = mt;
            MtAdd(pmb->mt, +1, +(LONG)cb);
        }

        pmb->cb = cb;

        *ppv = pmb + 1;
    }

    return(hr);
}

ULONG
_MtMemGetSize(void * pv)
{
    if (pv == NULL)
        return(0);
    else
        return(_MemGetSize((MTMEMBLK *)pv - 1) - sizeof(MTMEMBLK));
}

void
_MtMemFree(void * pv)
{
    if (pv)
    {
        MTMEMBLK * pmb = (MTMEMBLK *)pv - 1;
        MtAdd(pmb->mt, -1, -(LONG)pmb->cb);
        _MemFree(pmb);
    }
}

HRESULT
_MtMemAllocString(PERFMETERTAG mt, LPCTSTR pchSrc, LPTSTR * ppchDst)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDst = pch = (TCHAR *)_MtMemAlloc(mt, cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}

HRESULT
_MtMemAllocString(PERFMETERTAG mt, ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)MemAlloc(mt, cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

HRESULT
_MtMemReplaceString(PERFMETERTAG mt, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MtMemAllocString(mt, pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MtMemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

#if DBG==1

char *
_MtMemGetName(void * pv)
{
    return(DbgExMemGetName((MTMEMBLK *)pv - 1));
}

void __cdecl
_MtMemSetName(void * pv, char * szFmt, ...)
{
    if (pv && !IsVMemEnabled())
    {
        char szBuf[1024];
        va_list va;

        va_start(va, szFmt);
        wvsprintfA(szBuf, szFmt, va);
        va_end(va);

        DbgExMemSetName((MTMEMBLK *)pv - 1, "%s", szBuf);
    }
}

#endif

int
_MtMemGetMeter(void * pv)
{
    return(((MTMEMBLK *)pv - 1)->mt);
}

void
_MtMemSetMeter(void * pv, PERFMETERTAG mt)
{
    if (pv)
    {
        MTMEMBLK * pmb = (MTMEMBLK *)pv - 1;

        if (pmb->mt != mt)
        {
            MtAdd(pmb->mt, -1, -(LONG)pmb->cb);
            pmb->mt = mt;
            MtAdd(pmb->mt, +1, +(LONG)pmb->cb);
            _MemSetHeader(pmb, sizeof(MTMEMBLK), mt);
        }
    }
}

#endif

#ifdef PERFMETER

DeclareTag(tagUseMeterOpNew, "!Memory", "Trap invalid operator new calls")

void * __cdecl UseOperatorNewWithMemoryMeterInstead(size_t cb)
{
    AssertSz(!IsTagEnabled(tagUseMeterOpNew), "Invalid use of global operator new.  "
        "Use the version which requires a meter tag instead.");

    return(MemAlloc(Mt(OpNew), cb));
}

#endif

// MEMGUARD -------------------------------------------------------------------

#if defined(MEMGUARD)

#define MGGUARDDATA 0xF0F0BAAD

struct MGGUARD
{
    MGGUARD *pNext;
    DWORD    dw;
};

MGGUARD * g_pMemList = NULL;

void
_MgMemValidate()
{
    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    while (pg)
    {
        if (pg->dw != MGGUARDDATA)
        {
            DebugBreak();
        }

        pg = pg->pNext;
    }

    LeaveCriticalSection(&g_csHeap);
}

void
_MgRemove(MGGUARD *pmg)
{
    if (!pmg)
        return;

    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    if (pmg == pg)
    {
        g_pMemList = pg->pNext;
        goto Cleanup;
    }

    while (pg)
    {
        if (pg->pNext == pmg)
        {
            pg->pNext = pg->pNext->pNext;
            break;
        }

        pg = pg->pNext;
    }

Cleanup:
    LeaveCriticalSection(&g_csHeap);

}

void
_MgAdd(MGGUARD *pmg)
{
    EnterCriticalSection(&g_csHeap);

    pmg->pNext = g_pMemList;
    g_pMemList = pmg;

    LeaveCriticalSection(&g_csHeap);
}

void *
_MgMemAlloc(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAlloc(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }

}

void *
_MgMemAllocClear(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAllocClear(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }
}

HRESULT
_MgMemRealloc(void ** ppv, ULONG cb)
{
    _MgMemValidate();

    if (cb == 0)
    {
        _MgMemFree(*ppv);
        *ppv = 0;
        return(S_OK);
    }

    if (*ppv == NULL)
    {
        *ppv = _MgMemAlloc(cb);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }

    MGGUARD *  pmg = (MGGUARD *)*ppv - 1;

    _MgRemove(pmg);

    HRESULT    hr = _MemRealloc((void **)&pmg, sizeof(MGGUARD) + cb);

    if (hr == S_OK)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        *ppv = pmg + 1;
    }

    return(hr);
}

ULONG
_MgMemGetSize(void * pv)
{
    _MgMemValidate();

    if (pv == NULL)
        return(0);
    else
        return(_MemGetSize((MGGUARD *)pv - 1) - sizeof(MGGUARD));
}

void
_MgMemFree(void * pv)
{
    _MgMemValidate();

    if (pv)
    {
        MGGUARD * pmg = (MGGUARD *)pv - 1;
        if (pmg->dw != MGGUARDDATA)
        {
            // The memory guard DWORD was overwritten! Bogus!
#ifdef _M_IX86
            _asm int 3  // To get a proper stacktrace.
#else
            DebugBreak();
#endif
        }
        _MgRemove(pmg);

        _MemFree(pmg);
    }
}

HRESULT
_MgMemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDst = pch = (TCHAR *)_MgMemAlloc(cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}

HRESULT
_MgMemAllocString(ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)_MgMemAlloc(cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

HRESULT
_MgMemReplaceString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MgMemAllocString(pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MgMemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

#endif // MEMGUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MAKE_UNALIGNED_TYPE( LONG, 4 );

#if DBG == 1
//
// Global vars for use by the DYNCAST macro
//
char g_achDynCastMsg[200];
char *g_pszDynMsg = "Invalid Static Cast -- Attempt to cast object "
                    "of type %s to type %s.";
char *g_pszDynMsg2 = "Dynamic Cast Attempted ---  "
                     "Attempt to cast between two base classes of %s. "
                     "The cast was to class %s from some other base class "
                     "pointer. This cast will not succeed in a retail build.";
#endif

DeclareTag(tagAccess, "Accessibility", "Accessibility traces")

//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
}


//+------------------------------------------------------------------------
//
//  Function:   _MemAllocString
//
//  Synopsis:   Allocates a string copy using MemAlloc.
//
//              The inline function MemFreeString is provided for symmetry.
//
//  Arguments:  pchSrc    String to copy
//              ppchDest  Copy of string is returned in *ppch
//                        NULL is stored on error
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemAllocString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDest = pch = (TCHAR *)_MemAlloc(cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}



//+------------------------------------------------------------------------
//
//  Function:   _MemAllocString
//
//  Synopsis:   Allocates a string copy using MemAlloc.  Doesn't require
//              null-terminated input string.
//
//              The inline function MemFreeString is provided for symmetry.
//
//  Arguments:  cch       number of characters in input string,
//                        not including any trailing null character
//              pchSrc    pointer to source string
//              ppchDest  Copy of string is returned in *ppch
//                        NULL is stored on error
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemAllocString(ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)_MemAlloc(cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   _MemReplaceString
//
//  Synopsis:   Allocates a string using MemAlloc, replacing and freeing
//              another string on success.
//
//  Arguments:  pchSrc    String to copy. May be NULL.
//              ppchDest  On success, original string is freed and copy of
//                        source string is returned here
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemReplaceString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MemAllocString(pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:   TaskAllocString
//
//  Synopsis:   Allocates a string copy that can be passed across an interface
//              boundary, using the standard memory allocation conventions.
//
//              The inline function TaskFreeString is provided for symmetry.
//
//  Arguments:  pstrSrc    String to copy
//              ppstrDest  Copy of string is returned in *ppstr
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

#if !defined(_MACUNICODE) || defined(_MAC) 
HRESULT
TaskAllocString(const TCHAR *pstrSrc, TCHAR **ppstrDest)
{
    TCHAR *pstr;
    size_t cb;

    cb = (_tcsclen(pstrSrc) + 1) * sizeof(TCHAR);
    *ppstrDest = pstr = (TCHAR *)CoTaskMemAlloc(cb);
    if (!pstr)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pstr, pstrSrc, cb);
        return S_OK;
    }
}
#else
HRESULT
TaskAllocString(const OLECHAR *pstrSrc, OLECHAR **ppstrDest)
{
    OLECHAR *pstr;
    size_t cb;

    cb = (strlen(pstrSrc) + 1) * sizeof(OLECHAR);
    *ppstrDest = pstr = (OLECHAR *)CoTaskMemAlloc(cb);
    if (!pstr)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pstr, pstrSrc, cb);
        return S_OK;
    }
}
#endif

//+------------------------------------------------------------------------
//
//  Function:   TaskReplaceString
//
//  Synopsis:   Replaces a string copy that can be passed across an interface
//              boundary, using the standard memory allocation conventions.
//
//              The inline function TaskFreeString is provided for symmetry.
//
//  Arguments:  pstrSrc    String to copy. May be NULL.
//              ppstrDest  Copy of string is returned in *ppstrDest,
//                         previous string is freed on success
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT TaskReplaceString(const TCHAR * pstrSrc, TCHAR **ppstrDest)
{
    TCHAR *pstr;
    HRESULT hr;

    if (pstrSrc)
    {
        hr = THR(TaskAllocString(pstrSrc, &pstr));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pstr = NULL;
    }

    CoTaskMemFree(*ppstrDest);
    *ppstrDest = pstr;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   MulDivQuick
//
//  Synopsis:   Mutiply two signed 32-bit values and then divide the
//              64-bit result by a third unsigned 32-bit value.
//              The return value is rounded up or down to the nearest
//              integer.  If the multiplier and divisor are both zero,
//              this function returns 0.
//
//  Arguments:  nMultiplicand   Specifies the multiplicand.
//              nMultiplier     Specifies the multiplier.
//              nDivisor        Specifies the number by which the result of
//                              the multiplication (nMultiplicand * nMultiplier)
//                              is to be divided.
//
//----------------------------------------------------------------------------

// The OS routines are almost as fast (no inlining) and more robust, so
// this routine is no longer used...

#if 0

#pragma warning(disable: 4035)

int __declspec(naked) __stdcall
MulDivQuick(int nMultiplicand, int nMultiplier, int nDivisor)
{
    __asm
    {
        mov eax, 8[esp]
        test eax, eax
        je  L0
        mov ecx, 4[esp]
        imul ecx
        mov ecx, 12[esp]
        shr ecx, 1
        test edx, edx
        jl  L1
        add eax, ecx
        adc edx, 0
        mov ecx, 12[esp]
        idiv ecx
L0:
        ret 12
L1:
        sub eax, ecx
        sbb edx, 0
        mov ecx, 12[esp]
        idiv ecx
        ret 12
    }
}

#pragma warning(default: 4035)

#endif

//+-------------------------------------------------------------------------
//
//  Function:   InitSystemMetricValues
//
//  Synopsis:   Initializes globals holding system metric values.
//
//--------------------------------------------------------------------------

LONG        g_cMetricChange = 0;

SIZE        g_sizeDragMin;
SIZE        g_sizeScrollButton;
SIZEL       g_sizelScrollbar;
SIZEL       g_sizelScrollButton;
SIZEL       g_sizelScrollThumb;
LONG        g_lScrollGutterRatio;

LONG        g_alHimetricFrom8Pixels[2] = {0, 0};
SIZE        g_sizeSystemChar;

  // Locale Information
LCID        g_lcidUserDefault = 0;
LCID        g_lcidLocalUserDefault = 0;

UINT        g_cpDefault;

// hold for number shaping used by system: 0 = Context, 1 = None, 2 = Native
NUMSHAPE    g_iNumShape;
DWORD       g_uLangNationalDigits;

//  Accessibility information

BOOL g_fHighContrastMode = FALSE;
BOOL g_fScreenReader = FALSE;


HRESULT
InitSystemMetricValues(
    THREADSTATE *   pts)
{

    HIGHCONTRAST hc;
    HFONT       hfontOld;
    TEXTMETRIC  tm;
    SIZEL       sizeScrollbar;

    InterlockedIncrement(&g_cMetricChange);

    if (!pts->hdcDesktop)
    {
        pts->hdcDesktop = CreateCompatibleDC(NULL);
        if (!pts->hdcDesktop)
            RRETURN(E_OUTOFMEMORY);
    }


    {
        int logPixelsX = GetDeviceCaps(pts->hdcDesktop, LOGPIXELSX);
        int logPixelsY = GetDeviceCaps(pts->hdcDesktop, LOGPIXELSY);

        // The following Assert was added for bug 32496.
        // Seems like GetDeviceCaps once returned zero here.
        // Since the bug does'n want to repro, let's keep the assertion here
        // (mikhaill 4/25/1)
        Assert(logPixelsX > 0 && logPixelsY > 0);

        g_uiDisplay.SetResolution(logPixelsX, logPixelsY);
    }


#if defined(_MAC)
    // Width and height, in pixels, of a rectangle centered on a drag point
    // to allow for limited movement of the mouse pointer before a drag operation
    // begins. This allows the user to click and release the mouse button easily
    // without unintentionally starting a drag operation
    //
    g_sizeDragMin.cx = 3;
    g_sizeDragMin.cy = 3;
#else
    g_sizeDragMin.cx = GetSystemMetrics(SM_CXDRAG);
    g_sizeDragMin.cy = GetSystemMetrics(SM_CYDRAG);
#endif

    sizeScrollbar.cx = GetSystemMetrics(SM_CXVSCROLL);
    sizeScrollbar.cy = GetSystemMetrics(SM_CYHSCROLL);
    g_sizelScrollbar.cx = HimetricFromHPix(sizeScrollbar.cx);
    g_sizelScrollbar.cy = HimetricFromVPix(sizeScrollbar.cy);

    g_sizeScrollButton.cx  = GetSystemMetrics(SM_CXHSCROLL);
    g_sizeScrollButton.cy  = GetSystemMetrics(SM_CYVSCROLL);
    g_sizelScrollButton.cx = HimetricFromHPix(g_sizeScrollButton.cx);
    g_sizelScrollButton.cy = HimetricFromVPix(g_sizeScrollButton.cy);

    g_sizelScrollThumb.cx = HimetricFromHPix(GetSystemMetrics(SM_CXHTHUMB));
    g_sizelScrollThumb.cy = HimetricFromVPix(GetSystemMetrics(SM_CYVTHUMB));

    g_lScrollGutterRatio =  (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
                            ? 8 : 2;    // NT5 uses 8, NT4/W9x uses 2
    
    g_alHimetricFrom8Pixels[0] = HimetricFromHPix(8);
    g_alHimetricFrom8Pixels[1] = HimetricFromVPix(8);

    //
    // System font info
    //

    hfontOld = (HFONT)SelectObject(pts->hdcDesktop, GetStockObject(SYSTEM_FONT));
    if(hfontOld)
    {
        GetTextMetrics(pts->hdcDesktop, &tm);

        g_sizeSystemChar.cx = tm.tmAveCharWidth;
        g_sizeSystemChar.cy = tm.tmHeight;

        SelectObject(pts->hdcDesktop, hfontOld);
    }
    else
    {
        g_sizeSystemChar.cx =
        g_sizeSystemChar.cy = 10;
    }


    //
    // Locale info
    //

    g_cpDefault = GetACP();

    // TODO - PaulNel - g_lcidUserDefault needs to be evaluated to determine if
    //                    the desired intent is to use the User's default or that
    //                    of the System
    g_lcidUserDefault = GetSystemDefaultLCID(); //Set Global Locale ID
    g_lcidLocalUserDefault = GetUserDefaultLCID(); //Set Global Locale ID

    GetSystemNumberSettings(&g_iNumShape, &g_uLangNationalDigits);

#if !defined(UNIX)
    //
    //  Accessibility info
    //

    SystemParametersInfo(SPI_GETSCREENREADER, 0, &g_fScreenReader, FALSE);

    memset(&hc, 0, sizeof(HIGHCONTRAST));
    hc.cbSize = sizeof(HIGHCONTRAST);
    if (SystemParametersInfo(
                SPI_GETHIGHCONTRAST,
                sizeof(HIGHCONTRAST),
                &hc,
                0))
    {
        g_fHighContrastMode = !!(hc.dwFlags & HCF_HIGHCONTRASTON);
    }
    else
    {
        TraceTag((tagAccess, "SPI failed with error %x", GetLastError()));
    }
#endif

     RRETURN(S_OK);
 }

//+-------------------------------------------------------------------------
//
//  Function:   DeinitSystemMetricValues
//
//  Synopsis:   Deinitializes globals holding system metric values.
//
//--------------------------------------------------------------------------

void
DeinitSystemMetricValues(
    THREADSTATE *   pts)
{
   if(pts->hdcDesktop)
   {
       Verify(DeleteDC(pts->hdcDesktop));
#ifdef _MAC
    // Mac note: We need to recreate the hdcDesktop on a WM_SYSCOLORCHANGE
       pts->hdcDesktop = NULL;
#endif
   }

}

//+-------------------------------------------------------------------------
//
//  Function:   GetNumberOfSize
//              SetNumberOfSize
//
//  Synopsis:   Helpers to get/set an integer value of given byte size
//              by dereferencing a pointer
//
//              pv - pointer to dereference
//              cb - size (1, 2 or 4)
//
//--------------------------------------------------------------------------

long
GetNumberOfSize (void * pv, int cb)
{
    switch(cb)
    {
        case 1:
            return *(BYTE*) pv;

        case 2:
            return *(SHORT*) pv;

        case 4:
            return *(LONG*) pv;

        default:
            Assert(FALSE);
            return 0;
    }
}

void
SetNumberOfSize (void * pv, int cb, long i)
{
    switch(cb)
    {
        case 1:
            Assert((char)i >= SCHAR_MIN && (char)i <= SCHAR_MAX);
            * (BYTE*) pv = BYTE(i);
            break;

        case 2:
            Assert(i >= SHRT_MIN && i <= SHRT_MAX);
            * (SHORT*) pv  = SHORT(i);
            break;

        case 4:
            * (LONG*) pv = i;
            break;

        default:
            Assert(FALSE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetNumberOfType
//              SetNumberOfType
//
//  Synopsis:   Helpers to get/set an integer value of given variant type
//              by dereferencing a pointer
//
//              pv - pointer to dereference
//              vt - variant type
//
//--------------------------------------------------------------------------

// NOTE: The VC 5 compiler flags this as an error because VT_BOOL4 is not
// a valid VARENUM value.  Disable the warning for now.
#pragma warning(disable:4063)       // case '254' is not a valid value for switch of enum 'VARENUM'

long
GetNumberOfType (void * pv, VARENUM vt)
{
    switch(vt)
    {
        case VT_I2:
        case VT_BOOL:
            return * (SHORT*) pv;

        case VT_I4:
        case VT_BOOL4:
            return * (LONG*) pv;

        default:
            Assert(FALSE);
            return 0;
    }
}

void
SetNumberOfType (void * pv, VARENUM vt, long l)
{
    switch(vt)
    {
        case VT_BOOL:
            l = l ? VB_TRUE : VB_FALSE;
            //  vvvvvvvvvvv  FALL THROUGH vvvvvvvvvvvvv

        case VT_I2:
            Assert(l >= SHRT_MIN && l <= SHRT_MAX);
            * (SHORT*) pv = SHORT(l);
            break;

        case VT_BOOL4:
            l = l ? VB_TRUE : VB_FALSE;
            //  vvvvvvvvvvv  FALL THROUGH vvvvvvvvvvvvv

        case VT_I4:
            * (LONG_UNALIGNED *) pv = l;
            break;

        default:
            Assert(FALSE);
    }
}

#pragma warning(default:4063)


//+---------------------------------------------------------------------------
//
//  Function:   TextConvert
//
//  Synopsis:   Converts the text for a multiline/singleline textbox
//              Parameters:
//                  pszTextIn: current/passed in text
//                  pBstrOut: out parameter allocated in method
//                          will only be used in cased of Glyph->CR/LF/FF
//                          otherwise, conversion in place
//                  fToGlyph: force conversion to glyph case (used
//                      when multiline property is changed
//                  returns S_FALSE when no conversion happened
//
//----------------------------------------------------------------------------
#pragma warning(disable:4706)   // assignment within conditional expression
HRESULT
TextConvert(LPTSTR pszTextIn, BSTR *pBstrOut, BOOL fToGlyph)
{

    HRESULT hr = S_FALSE;

    LPTSTR  pszWrite;
    BOOL    fCRAndLF;
    const   int k_GlyphChar = 182;
    int     iHowManyGlyphs=0;

    if (!pszTextIn)
        goto Cleanup;

    if (fToGlyph)
    {
        TCHAR   ch;

        // so we are multiline and need to convert to the glyph representation
        pszWrite = pszTextIn;
        while ((ch = *pszTextIn))
        {
            if (ch != '\n' && ch != '\r' && ch != '\f')
            {
                *pszWrite++ = *pszTextIn++;
                continue;
            }

            fCRAndLF = (ch) == '\n';
            hr = S_OK;
            *pszWrite++ = k_GlyphChar;
            pszTextIn++;

            // NOTE: If we encountered a <FF> then map the <FF> to a <CR/LF> and
            // continue.  If this isn't done we could get into a nasty condition
            // if a <CR> or <LF> followed the <FF> then we would treat the
            // <FF><LF> as one CR/LF combination.  We don't want to do that the
            // <FF> by itself is one CR/LF combination.
            if (ch == '\f')
                continue;

            // the following part of the code tries to cover all the cases
            // of multiple presentations of CR/LF, like CR/LF, LF/CR, or
            // just LF or just CR. This is done by advancing the input pointer
            // and testing the next character to be the companion.
            if (*pszTextIn)
            {
                if (*pszTextIn == '\n' && !fCRAndLF)
                {
                    pszTextIn++;
                }
                else if (*pszTextIn == '\r' && fCRAndLF)
                {
                    pszTextIn++;
                }
            }

        }
        while (pszWrite != pszTextIn)
        {
            *pszWrite++ = 0;
        }
    }
    else if (pszTextIn)
    {
#ifdef _MAC
        CStr str;
        int  cStr;
#endif
        // scan the text first to check if memory allocation
        // and conversion is needed.Count the number of glyphs
        // to make a smart allocation
        pszWrite = pszTextIn;
        while (*pszWrite)
        {
            if (*pszWrite==k_GlyphChar)
            {
                iHowManyGlyphs++;
            }
            pszWrite++;
        }

        if (!iHowManyGlyphs)
            goto Cleanup;

        // so we are singleline and need to get rid of the glyphs...
        // first allocate a new and bigger buffer
#ifdef _MAC
        *pBstrOut = NULL;

        cStr = _tcslen(pszTextIn) + iHowManyGlyphs;
        str.ReAlloc(cStr);
        pszWrite = (LPTSTR)str;
#else
        *pBstrOut = SysAllocStringLen(0, (_tcslen(pszTextIn)+iHowManyGlyphs));
        pszWrite = (TCHAR*)*pBstrOut;
#endif

        if (!pszWrite)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        while (*pszTextIn)
        {
            if (*pszTextIn == k_GlyphChar)
            {
                hr = S_OK;
                *pszWrite++ = '\r';
                *pszWrite++ = '\n';
                pszTextIn++;
            }
            else
            {
                *pszWrite++ = *pszTextIn++;
            }
        }
        *pszWrite = 0;

#ifdef _MAC
        str.SetLengthNoAlloc(cStr);
        hr = str.AllocBSTR(pBstrOut);
#endif
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}
#pragma warning(default:4706)   // assignment within conditional expression


// Coerce pArgFrom into this instance from anyvariant to a given type
HRESULT CVariant::CoerceVariantArg ( VARIANT *pArgFrom, WORD wCoerceToType)
{
    HRESULT hr = S_OK;
    VARIANT *pvar;

    if( V_VT(pArgFrom) == (VT_BYREF | VT_VARIANT) )
        pvar = V_VARIANTREF(pArgFrom);
    else
        pvar = pArgFrom;

    if ( !(pvar->vt == VT_EMPTY || pvar->vt == VT_ERROR ) )
    {
        hr = THR(VariantChangeTypeSpecial ( (VARIANT *)this, pvar,  wCoerceToType ));
    }
    else
    {
        return S_FALSE;
    }
    RRETURN(hr);
}

// Coerce current variant into itself
HRESULT CVariant::CoerceVariantArg (WORD wCoerceToType)
{
    HRESULT hr = S_OK;

    if ( !(vt == VT_EMPTY || vt == VT_ERROR ) )
    {
        hr = THR(VariantChangeTypeSpecial ( (VARIANT *)this, (VARIANT *)this, wCoerceToType ));
    }
    else
    {
        return S_FALSE;
    }
    RRETURN(hr);
}


// Coerce any numeric (VT_I* or  VT_UI*) into a VT_I4 in this instance
BOOL CVariant::CoerceNumericToI4 ()
{
    switch (vt)
    {
    case VT_I1:
    case VT_UI1:
        lVal = 0x000000FF & (DWORD)bVal;
        break;
    
    case VT_UI2:
    case VT_I2:
        lVal = 0x0000FFFF & (DWORD)iVal;
        break;
    
    case VT_UI4:
    case VT_I4:
    case VT_INT: 
    case VT_UINT:
        break;

    case VT_R8:
        lVal = (LONG)dblVal;
        break;

    case VT_R4:
        lVal = (LONG)fltVal;
        break;

    default:
        return FALSE;
    }

    vt = VT_I4;
    return TRUE;
}
//+------------------------------------------------------------------------
//
//  Binary search routine
//      pb - Pointer to array
//      c  - Number of entries in the array
//      l  - Value for which to search (expressed as a long)
//      cb - Size of an array entry (defaults to 4 bytes)
//      ob - Offset within entry of comparison value (defaults to 0)
//
//-------------------------------------------------------------------------
int BSearch(const BYTE * pb, const int c, const unsigned long l, const int cb,
            const int ob)
{
    int i = 0;

    if (c)
    {
        int iLow  = 0;
        int iHigh = c;

        while (iLow < iHigh)
        {
            i = (iLow + iHigh) >> 1;

            if ((*((unsigned long *)(pb + (cb * i) + ob))) < l)
                iLow = i + 1;

            else
                iHigh = i;
        }

        i = iLow;
    }

    return i;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetBStrFromStream
//
//  Synopsis:   Given a stream, this function allocates and returns a bstr
//              representing its contents.
//
//----------------------------------------------------------------------------

HRESULT
GetBStrFromStream(IStream * pIStream, BSTR * pbstr, BOOL fStripTrailingCRLF)
{
    HRESULT  hr;
    HGLOBAL  hHtmlText = 0;
    TCHAR *  pstrWide = NULL;

    *pbstr = NULL;
    
    hr = THR(GetHGlobalFromStream(pIStream, &hHtmlText));
    if (hr)
        goto Cleanup;

    pstrWide = (TCHAR *) GlobalLock( hHtmlText );

    if (!pstrWide)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fStripTrailingCRLF)
    {
        // Remove trailing cr/lf's
        
        TCHAR * pstr = pstrWide + _tcslen(pstrWide);

        while (pstr-- > pstrWide && (*pstr == '\r' || *pstr == '\n'))
            ;

        *(pstr + 1) = 0;
    }
                
    hr = FormsAllocString(pstrWide, pbstr);

    GlobalUnlock(hHtmlText);
    
Cleanup:
    
    RRETURN(hr);
}

BOOL MakeThisTopBrowserInProcess(HWND hwnd)
{
    HWND hwndThisBrowser = NULL;
    HWND hwndTopMostBrowser = NULL;
    DWORD pid, thisPid = 0;
    TCHAR achClassName[126];

    // return if a window in the called thread has the keyboard focus
    if (::GetFocus() != NULL)
        return FALSE;

    // get top-level browser window for which the alert was called
    while(hwnd)
    {
        hwndThisBrowser = hwnd;
        hwnd = ::GetParent(hwnd);
    }

    // if found, get the pid of this one and the next top-level window above this one
    if (hwndThisBrowser)
    {
        hwnd = ::GetNextWindow(hwndThisBrowser, GW_HWNDPREV);
        ::GetWindowThreadProcessId(hwndThisBrowser, &thisPid);
    }

    // see if any of the top-level windows above this one are browser windows
    while (hwnd && thisPid)
    {
        ::GetWindowThreadProcessId(hwnd, &pid);
        // if the pids are same then it could be a browser window
        if (pid == thisPid)
        {
            ::GetClassName(hwnd, achClassName, ARRAY_SIZE(achClassName));
            // IEFrame is the classname for normally launched browsers and CabinetWClass is the
            // classname for browsers launched with window.open(). Check for both!
            if(!_tcscmp(achClassName, _T("IEFrame")) || !_tcscmp(achClassName, _T("CabinetWClass")))
                hwndTopMostBrowser = hwnd;
        }

        hwnd = ::GetNextWindow(hwnd, GW_HWNDPREV);
    }

    // if top browser window found, get the next top-level window just above it in
    // the z-order, so that this browser window can be inserted just before it (so
    // that it now becomes the top browser window).
    if (hwndTopMostBrowser)
    {
        // if there is a top browser above us and it is the currently active window, then
        // make ourselves active instead
        if (::GetForegroundWindow() == hwndTopMostBrowser)
        {
            ::SetForegroundWindow(hwndThisBrowser);
            return FALSE;
        }
        else    // else, just insert ourselves above the top browser, w/o activating
        {
            hwndTopMostBrowser = ::GetNextWindow(hwndTopMostBrowser, GW_HWNDPREV);
            if (hwndTopMostBrowser)
            {
                ::SetWindowPos(hwndThisBrowser, hwndTopMostBrowser, 0, 0, 0, 0,
                               SWP_SHOWWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
            }
        }
    }

    return TRUE;
}


#ifndef LANG_TIBETAN
#define LANG_TIBETAN     0x51
#endif
#ifndef LANG_LAO
#define LANG_LAO         0x54
#endif

void GetSystemNumberSettings(
    NUMSHAPE * piNumShape,
    DWORD * plangNationalDigits)
{
    NUMSHAPE iNumShape = NUMSHAPE_NONE;
    DWORD langDigits = LANG_NEUTRAL;
    HKEY hkey = NULL;
    DWORD dwType;
    DWORD cbData;
    char achBufferData[41]; // Max Size user can fit in our variables edit field
    WCHAR achDigits[16];

    Assert(piNumShape != NULL && plangNationalDigits != NULL);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\International"), 0L, KEY_READ, &hkey))
    {
        goto Cleanup;
    }

    Assert(hkey != NULL);

    cbData = sizeof(achBufferData);
    if (RegQueryValueExA(hkey, "NumShape",
        0L, &dwType, (LPBYTE) achBufferData, &cbData) == ERROR_SUCCESS &&
        achBufferData[0] != TEXT('\0') && (dwType & REG_SZ) && !(dwType & REG_NONE))
    {
        iNumShape = (NUMSHAPE) max(min(atoi(achBufferData), (int) NUMSHAPE_NATIVE), (int) NUMSHAPE_CONTEXT);
    }

    RegCloseKey(hkey);

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SNATIVEDIGITS, achDigits, 16))
    {
        switch (achDigits[4])
        {
        case 0x664: // Arabic-Indic digits
            langDigits = LANG_ARABIC;
            break;
        case 0x6F4: // Eastern Arabic-Indic digits
            langDigits = LANG_FARSI;
            break;
        case 0x96A: // Devanagari digits
            langDigits = LANG_HINDI;
            break;
        case 0x9EA: // Bengali digits
            langDigits = LANG_BENGALI;
            break;
        case 0xA6A: // Gurmukhi digits
            langDigits = LANG_PUNJABI;
            break;
        case 0xAEA: // Gujarati digits
            langDigits = LANG_GUJARATI;
            break;
        case 0xB6A: // Oriya digits
            langDigits = LANG_ORIYA;
            break;
        case 0xBEA: // Tamil digits
            langDigits = LANG_TAMIL;
            break;
        case 0xC6A: // Telugu digits
            langDigits = LANG_TELUGU;
            break;
        case 0xCEA: // Kannada digits
            langDigits = LANG_KANNADA;
            break;
        case 0xD6A: // Malayalam digits
            langDigits = LANG_MALAYALAM;
            break;
        case 0xE54: // Thai digits
            langDigits = LANG_THAI;
            break;
        case 0xED4: // Lao digits
            langDigits = LANG_LAO;
            break;
        case 0xF24: // Tibetan digits
            langDigits = LANG_TIBETAN;
            break;
        default:
            langDigits = LANG_NEUTRAL;
            break;
        }
    }
    else
    {
        // Work from the platform's locale.
        langDigits = PRIMARYLANGID(GetUserDefaultLangID());
    }
    if (langDigits != LANG_ARABIC &&
        langDigits != LANG_FARSI &&
        langDigits != LANG_HINDI &&
        langDigits != LANG_BENGALI &&
        langDigits != LANG_PUNJABI &&
        langDigits != LANG_GUJARATI &&
        langDigits != LANG_ORIYA &&
        langDigits != LANG_TAMIL &&
        langDigits != LANG_TELUGU &&
        langDigits != LANG_KANNADA &&
        langDigits != LANG_MALAYALAM &&
        langDigits != LANG_THAI &&
        langDigits != LANG_LAO &&
        langDigits != LANG_TIBETAN)
    {
        langDigits = LANG_NEUTRAL;
        iNumShape = NUMSHAPE_NONE;
    }

Cleanup:
    *piNumShape = iNumShape;
    *plangNationalDigits = langDigits;
}

HINSTANCE EnsureMLLoadLibrary()
{
#ifndef UNIX
    HINSTANCE hInst = MLLoadLibrary(_T("shdoclc.dll"), g_hInstCore, ML_CROSSCODEPAGE);
#else
    HINSTANCE hInst = MLLoadLibrary(_T("shdocvw.dll"), g_hInstCore, ML_CROSSCODEPAGE);
#endif
    if (hInst)
    {
        LOCK_GLOBALS;

        if (!g_hInstResource)
        {
            g_hInstResource = hInst;
            hInst = NULL;
        }
    }

    if (hInst)
        MLFreeLibrary(hInst);

    Assert(g_hInstResource && "Resource DLL is not loaded!");

    return g_hInstResource;
}

DWORD
CreateRandomNum(void)
{
    GUID guid;
    DWORD dw;

    CoCreateGuid(&guid);
    HashData((LPBYTE)&guid, sizeof(guid), (LPBYTE)&dw, sizeof(dw));

    return dw;
}

//+---------------------------------------------------------------------------
//
//  Function:   GCD
//
//  Synopsis:   greatest common divisor
//----------------------------------------------------------------------------
int GCD(int w1, int w2)
{
    w1 = abs(w1);
    w2 = abs(w2);

    if (w2 > w1)
    {
        int wT = w1;
            w1 = w2;
            w2 = wT;
    }
    
    if (w2 == 0)
    {
        AssertSz(0, "GCD(x,0): return 1");
        return 1;
    }

    for (;;)
    {
        if ((w1 %= w2) == 0)
            return w2;

        if ((w2 %= w1) == 0)
            return w1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\misccom.cxx ===
//+------------------------------------------------------------------------
//
//  File:       misccom.cxx
//
//  Contents:   Misc COM object helper functions.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)



//+------------------------------------------------------------------------
//
//  Function:   ClearInterfaceFn
//
//  Synopsis:   Sets an interface pointer to NULL, after first calling
//              Release if the pointer was not NULL initially
//
//  Arguments:  [ppUnk]     *ppUnk is cleared
//
//-------------------------------------------------------------------------

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ClearClassFn
//
//  Synopsis:   Nulls a pointer to a class, releasing the class via the
//              provided IUnknown implementation if the original pointer
//              is non-NULL.
//
//  Arguments:  [ppv]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ClearClassFn(void ** ppv, IUnknown * pUnk)
{
    *ppv = NULL;
    if (pUnk)
        pUnk->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReplaceInterfaceFn
//
//  Synopsis:   Replaces an interface pointer with a new interface,
//              following proper ref counting rules:
//
//              = *ppUnk is set to pUnk
//              = if *ppUnk was not NULL initially, it is Release'd
//              = if pUnk is not NULL, it is AddRef'd
//
//              Effectively, this allows pointer assignment for ref-counted
//              pointers.
//
//  Arguments:  [ppUnk]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReleaseInterface
//
//  Synopsis:   Releases an interface pointer if it is non-NULL
//
//  Arguments:  [pUnk]
//
//-------------------------------------------------------------------------

void
ReleaseInterface(IUnknown * pUnk)
{
    if (pUnk)
        pUnk->Release();
}


//+---------------------------------------------------------------
//
// Function:    IsSameObject
//
// Synopsis:    Checks for COM identity
//
// Arguments:   pUnkLeft, pUnkRight
//
//+---------------------------------------------------------------

BOOL
IsSameObject(IUnknown *pUnkLeft, IUnknown *pUnkRight)
{
    IUnknown *pUnk1, *pUnk2;

    if (pUnkLeft == pUnkRight)
        return TRUE;

    if (pUnkLeft == NULL || pUnkRight == NULL)
        return FALSE;

    if (SUCCEEDED(pUnkLeft->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk1)))
    {
        pUnk1->Release();
        if (pUnk1 == pUnkRight)
            return TRUE;
        if (SUCCEEDED(pUnkRight->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk2)))
        {
            pUnk2->Release();
            return pUnk1 == pUnk2;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------
//
//  Function:   GetResource
//
//  Synopsis:   Loads any kind of resource.
//
//  Arguments:  [hinst] -- instance of the module with the resource
//              [lpstrId] -- the identifier of the resource
//              [lpstrType] -- the identifier of the resource type
//              [pcbSize] -- points to the out param: the number of bytes of resource data to load
//
//  Returns:    lpvBuf if the resource was successfully loaded, NULL otherwise
//
//  Notes:      This function combines Windows' FindResource, LoadResource,
//              LockResource.
//
//----------------------------------------------------------------

LPVOID
GetResource(HINSTANCE hinst,
            LPCTSTR lpstrId,
            LPCTSTR lpstrType,
            ULONG * pcbSize)
{
    LPVOID  lpv;
    HGLOBAL hgbl;
    HRSRC   hrsrc;

    hrsrc = FindResource(hinst, lpstrId, lpstrType);
    if (!hrsrc)
        return NULL;

    hgbl = LoadResource(hinst, hrsrc);
    if (!hgbl)
        return NULL;

    lpv = LockResource(hgbl);
    if ( pcbSize )
    {
        *pcbSize = lpv ? ::SizeofResource(hinst, hrsrc) : 0;
    }

#if !defined(_MAC) && !defined(UNIX)
    //  Win95 is said to need this
    FreeResource(hgbl);
#endif

    return lpv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\proppage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       proppage.cxx
//
//  Contents:   Display property dialog.
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PROPPAGE_HXX_
#define X_PROPPAGE_HXX_
#include "proppage.hxx"
#endif

const CBase::CLASSDESC CPropertyPage::s_classdesc = 
{
    NULL,                               // _pclsid
    0,                                  // _idrBase
    NULL,                               // _apClsidPages
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    NULL,                               // _piidDispinterface
    NULL,                               // _apHdlDesc
};


//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Passivate
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

void
CPropertyPage::Passivate()
{
    // clean up our window.
    //
    if (_hwnd)
    {
        SetWindowLong(_hwnd, DWL_USER, 0xffffffff);
        DestroyWindow(_hwnd);
    }

    // release all the objects we're holding on to.
    //
    ReleaseAllObjects();

    // release the site
    //
    ClearInterface(&_pPropertyPageSite);
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::QueryInterface
//
//  Synopsis:   we support IPP and IPP2.
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyPage::PrivateQueryInterface(REFIID iid, void **ppvObj)
{
    *ppvObj = NULL;

    if ( IsEqualIID(iid, IID_IPropertyPage) )
    {
        *ppvObj = (IPropertyPage *)this;
    }
    else if ( IsEqualIID(iid, IID_IPropertyPage2) )
    {
        *ppvObj = (IPropertyPage2 *)this;
    }
    else
    {
        RRETURN(super::PrivateQueryInterface(iid, ppvObj));
    }

    ((IUnknown*)(*ppvObj))->AddRef();

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Init
//
//  Synopsis:   Init.
//
//  Note:       Load up the descriptor strings
//
//-------------------------------------------------------------------------

HRESULT
CPropertyPage::Init(void)
{
    HRESULT hr;
    int cch;
    TCHAR * pch;

    hr = LoadString(GetResourceHInst(), ProppageDesc()->wTitleId, &cch, &pch);
    if ( hr )
        goto Cleanup;

    hr = _cstrTitle.Set(pch, cch);
    if ( hr )
        goto Cleanup;

    hr = LoadString(GetResourceHInst(), ProppageDesc()->wDocStringId, &cch, &pch);
    if ( hr )
        goto Cleanup;

    hr = _cstrDocString.Set(pch, cch);
    if ( hr )
        goto Cleanup;


Cleanup:
    RRETURN(hr);
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::SetPageSite
//
//  Synopsis:   Set the proppage site on the proppage dialog
//
//  Arguments:  pPropertyPageSite  - [in] new site.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::SetPageSite(IPropertyPageSite *pPropertyPageSite)
{
    if ( pPropertyPageSite && _pPropertyPageSite )
        return E_UNEXPECTED;

    ReplaceInterface(&_pPropertyPageSite, pPropertyPageSite);

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Activate
//
//  Synopsis:   instructs the page to create its
//              display window as a child of hwndparent
//              and to position it according to prc
//
//  Arguments:  hwndParent      the parent window
//              prcBounds       the rect to use for display
//              fModal          or not
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Activate(HWND    hwndParent,
                        LPCRECT prcBounds,
                        BOOL    fModal)
{
    HRESULT hr = S_OK;
    BOOL fActivating = _fActivating;

    _fActivating = TRUE;

    // first make sure the dialog window is loaded and created.
    //
    if (_hwnd)
        goto Cleanup;

    _hwnd = CreateDialogParam(GetResourceHInst(),
                              MAKEINTRESOURCE(GetProppageDesc()->wDlgResourceId),
                              hwndParent,
                              &CPropertyPage::DlgProc,
                              (LPARAM)this);
    if ( ! _hwnd )
        goto Win32Error;

    _fActive = TRUE;

    THR_NOTRACE(ConnectObjects());

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);

Cleanup:
    _fActivating = fActivating;
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Deactivate
//
//  Synopsis:   instructs the page to destroy the window created in activate
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Deactivate(void)
{
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
    }

    _hwnd = NULL;
    _fActive = FALSE;

    Disconnect();

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::GetPageInfo
//
//  Synopsis:   asks the page to fill a PROPPAGEINFO structure
//
//  Arguments:  pPropPageInfo - [out] where to put info.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::GetPageInfo(PROPPAGEINFO * pPropPageInfo)
{
    HRESULT hr = S_OK;
    RECT rc;

    if ( ! pPropPageInfo )
        return E_POINTER;


    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));
    pPropPageInfo->cb = sizeof(PROPPAGEINFO);

    hr = TaskAllocString(_cstrTitle, &pPropPageInfo->pszTitle);
    if ( hr )
        goto Cleanup;

    TaskAllocString(_cstrDocString, &pPropPageInfo->pszDocString);
    TaskAllocString(ProppageDesc()->szHelpFile, &pPropPageInfo->pszHelpFile);
    pPropPageInfo->dwHelpContext = ProppageDesc()->dwHelpContextId;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (_hwnd)
    {
        GetWindowRect(_hwnd, &rc);
        pPropPageInfo->size.cx = rc.right - rc.left;
        pPropPageInfo->size.cy = rc.bottom - rc.top;
    }
    else
    {
        DLGTEMPLATE * pdt;

        pdt = (DLGTEMPLATE *)GetResource(GetResourceHInst(),
                                         MAKEINTRESOURCE(ProppageDesc()->wDlgResourceId),
                                         RT_DIALOG,
                                         NULL);

        if ( pdt )
        {
            hr = ComputeDialogSize(pdt, &pPropPageInfo->size);
        }
    }


Cleanup:
    RRETURN(hr);

}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::SetObjects
//
//  Synopsis:   provides the page with the objects being affected by the changes.
//
//  Arguments:  cObjects        - [in] count of objects.
//              ppUnkObjects    - [in] objects.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::SetObjects(ULONG       cObjects,
                          IUnknown ** ppUnkObjects)
{
    HRESULT hr = S_OK;
    ULONG   i;
    IUnknown * pUnk;

    ReleaseAllObjects();

    if (!cObjects)
        goto Cleanup;

    // now go and set up the new ones.
    //

    hr = _aryUnk.EnsureSize(cObjects);
    if ( hr )
        goto Cleanup;


    //  Loop through and copy over all the objects.
    //  Get only those supporting our requested primary interface

    for (i = 0; i < cObjects; i++)
    {
        if ( ppUnkObjects[i] &&
             OK(ppUnkObjects[i]->QueryInterface(*GetProppageDesc()->piidPrimary, (void**)&pUnk)) )
        {
            hr = _aryUnk.Append(pUnk);
            if ( hr )
                goto Cleanup;
        }

    }


    _fDirty = FALSE;


Cleanup:
    RRETURN(hr);
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Show
//
//  Synopsis:   asks the page to show or hide its window
//
//  Arguments:  nCmdShow    - [in] whether to show or hide
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Show(UINT nCmdShow)
{
    if ( ! _hwnd )
        return E_UNEXPECTED;

    ShowWindow(_hwnd, nCmdShow);

    return S_OK;
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Move
//
//  Synopsis:   asks the page to relocate and resize itself
//              to a position other than what was specified through Activate
//
//  Arguments:  prcBounds    - [in] new position and size
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Move(LPCRECT prcBounds)
{
    if ( ! _hwnd )
    {
        return E_UNEXPECTED;
    }

    MoveWindow(_hwnd,
               prcBounds->left,
               prcBounds->top,
               prcBounds->right - prcBounds->left,
               prcBounds->bottom - prcBounds->top,
               TRUE);

    return S_OK;
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::IsPageDirty
//
//  Synopsis:   asks the page whether it has changed its state
//
//  Returns:    S_OK    dirty
//              S_FALSE not dirty
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::IsPageDirty(void)
{
    return _fDirty ? S_OK : S_FALSE;
}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Apply
//
//  Synopsis:   instructs the page to send its changes
//              to all the objects passed through SetObjects()
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Apply(void)
{
    HRESULT hr = S_OK;

    if (_fDirty)
    {
        _fDirty = FALSE;
        if (_pPropertyPageSite)
        {
            _pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    }

    RRETURN(hr);
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Help
//
//  Synopsis:   instructs the page that the help button was clicked.
//
//  Arguments:  pszHelpDir  - [in] help directory
//
//  Note:       Default implementation bounces back with E_NOTIMPL
//              forcing caller to use help info from GetPageInfo.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::Help(LPCOLESTR pszHelpDir)
{
    if ( _hwnd )
        return E_UNEXPECTED;

    return E_NOTIMPL;   //  force prop sheet to use GetPageInfo.
}








//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::TranslateAccelerator
//
//  Synopsis:   informs the page of keyboard events,
//              allowing it to implement its own keyboard interface.
//
//  Arguments:  pmsg   - [in] message that triggered this
//
//  Returns:    S_OK    if consumed
//              S_FALSE if not processed
//              E_xxxx  if error
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::TranslateAccelerator(LPMSG pmsg)
{
    Assert(_hwnd && "How can we get a TranslateAccelerator call if we're not visible?");
    Assert(_pPropertyPageSite);

    // just pass this message on to the dialog proc and see if they want it.
    //
    RRETURN1(_pPropertyPageSite->TranslateAccelerator(pmsg),S_FALSE);
}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::EditProperty
//
//  Synopsis:   instructs the page to set the focus
//              to the property matching the dispid.
//
//  Arguments:  dispid   - [in] dispid of property to set focus to.
//
//  Note:       Derived should overload
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::EditProperty(DISPID dispid)
{
    return E_NOTIMPL;
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::ReleaseAllObjects, protected
//
//  Synopsis:   releases all the objects that we're working with
//
//  Note:       Derived class can overload to catch the action
//
//-------------------------------------------------------------------------

void
CPropertyPage::ReleaseAllObjects(void)
{
    //  Be robust. Objects are disconnected in Deactivate but
    //  we want ot be able to survive the lack of it

    Disconnect();
    _aryUnk.ReleaseAll();
}





//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::ComputeDialogSize, protected
//
//  Synopsis:   releases all the objects that we're working with
//
//  Note:       Derived class can overload to catch the action
//
//-------------------------------------------------------------------------

HRESULT
CPropertyPage::ComputeDialogSize(DLGTEMPLATE * pdt, SIZE * psize)
{
    HRESULT hr = S_OK;
    int i;
    SIZE sizeBaseUnit = {0,0};
    IFont *pFont = 0;

    Assert(pdt);
    Assert(psize);

    if ( pdt->style & DS_SETFONT )
    {
        short * ps;
        int iFontSize;
        TCHAR * pszFontName;

        //  Walk the dialog template to get at the specified font

        ps = (short*)((char*)pdt + sizeof(DLGTEMPLATE));

        //  Skip the menu and class descriptors
        for ( i = 0; i < 2; i++ )
        {
            switch (*ps)
            {
                case 0:
                    //  Non-existent
                    ps++;
                    break;

                case 0xffff:
                    //  Specified via resourceID/atom,
                    //  next short is the ID
                    ps += 2;
                    break;

                default:
                    //  Null-terminated Unicode string
                    while (*ps++);
                    break;
            }
        }

        while(*ps++);

        iFontSize = *ps++;
        pszFontName = (TCHAR *)ps;

        //  Get the font

        if ( iFontSize && pszFontName )
        {
            FONTDESC fd;
            TEXTMETRICOLE tm;

            memset(&fd, 0, sizeof(fd));
            fd.cbSizeofstruct = sizeof(fd);
            fd.lpstrName = pszFontName;
            fd.cySize.Hi = iFontSize;

            hr = OleCreateFontIndirect(&fd, IID_IFont, (void**)&pFont);
            if ( hr )
                goto Cleanup;

            hr = pFont->QueryTextMetrics(&tm);
            if ( hr )
                goto Cleanup;

            sizeBaseUnit.cx = tm.tmAveCharWidth;
            sizeBaseUnit.cy = tm.tmHeight;
        }
    }
    else
    {
        DWORD dwBaseUnits;

        dwBaseUnits = GetDialogBaseUnits();
        sizeBaseUnit.cx = LOWORD(dwBaseUnits);
        sizeBaseUnit.cy = HIWORD(dwBaseUnits);
    }

    psize->cx = ( pdt->cx * sizeBaseUnit.cx) / 4;
    psize->cy = ( pdt->cy * sizeBaseUnit.cy) / 8;


Cleanup:
    ReleaseInterface(pFont);
    RRETURN(hr);
}







//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::PropPageDlgProc
//
//  Synopsis:   static global helper dialog proc
//              that gets called before we pass the message on to anybody
//
//  Arguments:  Like a Dialog Proc. See Win32
//
//-------------------------------------------------------------------------

BOOL CALLBACK
CPropertyPage::DlgProc(HWND    hwnd,
                       UINT    msg,
                       WPARAM  wParam,
                       LPARAM  lParam)
{
    BOOL rc = TRUE;
    CPropertyPage *pPropertyPage = (CPropertyPage *)GetWindowLong(hwnd, DWL_USER);

    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLong(hwnd, DWL_USER, lParam);
            pPropertyPage = (CPropertyPage *)lParam;
            return pPropertyPage->OnInitDialog(hwnd);
            break;

#if NEVER
        case WM_CLOSE:
            pPropertyPage->Close();
            break;

        case WM_NOTIFY:
            pPropertyPage->OnNotify((int)wParam, (LPNMHDR)lParam);
            break;

        case WM_COMMAND:
            pPropertyPage->OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                                     GET_WM_COMMAND_ID(wParam, lParam), 
                                     GET_WM_COMMAND_HWND(wParam, lParam));
            break;
#endif

        default:
            rc = pPropertyPage ? pPropertyPage->DialogProc(hwnd, msg, wParam, lParam) : FALSE;
            break;
    }

    return rc;
}






//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::MakeDirty
//
//  Synopsis:   marks a page as dirty.
//
//-------------------------------------------------------------------------

void
CPropertyPage::MakeDirty(void)
{
    if ( ! _fActivating )
    {
        _fDirty = TRUE;
        if (_pPropertyPageSite)
            _pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
    }
}





//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::ConnectObjects
//
//  Synopsis:   Connection to current selected objectes
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CPropertyPage::ConnectObjects(void)
{
    HRESULT         hr;
    int             i;
    IUnknown **     ppUnk = NULL;
    DWORD *         pdw;

    Disconnect();   //  the old ones

    // Get space for connection IDs.
    hr = _aryAdvise.EnsureSize(_aryUnk.Size());
    if (hr)
        goto Cleanup;

    // Register as sink to each object.
    ppUnk = _aryUnk;
    pdw = _aryAdvise;

    for (i = 0, ppUnk = _aryUnk;
         i < _aryUnk.Size();
         i++, ppUnk++)
    {
        //  Ignore errors
        IGNORE_HR(ConnectSink(*ppUnk, IID_IPropertyNotifySink, &_PropertyPagePNS, pdw));

        // Next object.
        pdw++;
    }

    //  Set the correct count on the cookie array
    _aryAdvise.SetSize(_aryUnk.Size());

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPropertyPage::Disconnect
//
//  Synopsis:   Disconnect to current selected objected
//
//-------------------------------------------------------------------------
void
CPropertyPage::Disconnect(void)
{
    HRESULT         hr = S_OK;
    int             i;
    IUnknown **     ppUnk = NULL;
    DWORD *         pdw;

    //
    // Revoke as property notify sink from each object.
    //

    for (i = 0, ppUnk = _aryUnk, pdw = _aryAdvise;
         i < min ( _aryUnk.Size(), _aryAdvise.Size() );
         i++, ppUnk++)
    {
        IGNORE_HR(DisconnectSink(*ppUnk, IID_IPropertyNotifySink, pdw));

        // Next object.
        pdw++;
    }

    _aryAdvise.SetSize(0);
}




//+------------------------------------------------------------------------
//
//  CPropertyPagePNS implementation.
//
//-------------------------------------------------------------------------


IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CPropertyPage::CPropertyPagePNS, CPropertyPage, _PropertyPagePNS)


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::CPropertyPagePNS::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::CPropertyPagePNS::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyNotifySink))
    {
        *ppv = (IPropertyNotifySink *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::CPropertyPagePNS::OnChanged
//
//  Synopsis:   Refreshes property page.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::CPropertyPagePNS::OnChanged(DISPID dispid)
{
    if (MyCPropertyPage()->_fInApply)
        return S_OK;

    //  TODO: Need to implement this functionality

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPropertyPage::CPropertyPagePNS::OnRequestEdit
//
//  Synopsis:   Does nothing.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPropertyPage::CPropertyPagePNS::OnRequestEdit(DISPID dispid)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\rostm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       rostm.cxx
//
//  Contents:   CROStmOnBuffer
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

MtDefine(CROStmOnBuffer, Utilities, "CROStmOnBuffer")
MtDefine(CROStmOnHGlobal, Utilities, "CROStmOnHGlobal")
MtDefine(CROStmOnBuffer_pbBuf, CROStmOnBuffer, "CROStmOnBuffer::_pbBuf")

//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::CROStmOnBuffer
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------

CROStmOnBuffer::CROStmOnBuffer()
{
    _ulRefs = 1;
    _pbSeekPtr = NULL;
    _pbBuf = NULL;
    _cbBuf = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::~CROStmOnBuffer
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CROStmOnBuffer::~CROStmOnBuffer()
{
    if (_pbBuf)
    {
        delete _pbBuf;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Init
//
//  Synopsis:   Initializer
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Init(BYTE *pb, long cb)
{
    HRESULT hr = S_OK;
    
    _cbBuf = cb;
    if (cb)
    {
        _pbBuf = new(Mt(CROStmOnBuffer_pbBuf)) BYTE[cb];
        if (!_pbBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        memcpy((void *)_pbBuf, pb, cb);
        _pbSeekPtr = _pbBuf;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::QueryInterface
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (riid == IID_IStream || riid == IID_IUnknown)
    {
        *ppvObj = (IStream *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::AddRef
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

ULONG
CROStmOnBuffer::AddRef()
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Release
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

ULONG
CROStmOnBuffer::Release()
{
    ULONG   ulRefs = _ulRefs;
    
    if (--_ulRefs == 0)
    {
        delete this;
    }

    return ulRefs - 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Read
//
//  Synopsis:   per IStream
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Read(void HUGEP * pv, ULONG cb, ULONG * pcbRead)
{
    HRESULT hr = S_OK;
    
    if (!pv)
    {
        hr = STG_E_INVALIDPOINTER;
        goto Cleanup;
    }
    
    //
    // Catch the case where a read might go beyond the end
    // of the buffer
    //
    
    if (_pbBuf + _cbBuf < _pbSeekPtr + cb)
    {
        cb = _pbBuf + _cbBuf - _pbSeekPtr;
    }

    memcpy(pv, (void *)_pbSeekPtr, cb);
    _pbSeekPtr += cb;
    
    if (pcbRead)
    {
        *pcbRead = cb;
    }

    if (cb == 0)
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Seek
//
//  Synopsis:   per IStream
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Seek(
    LARGE_INTEGER dlibMove, 
    DWORD dwOrigin, 
    ULARGE_INTEGER * plibNewPosition)
{
    HRESULT     hr  = S_OK;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        if (dlibMove.HighPart != 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _pbSeekPtr = _pbBuf + dlibMove.LowPart;
        }
        break;

    case STREAM_SEEK_CUR:
        if (dlibMove.HighPart != 0 && dlibMove.HighPart != -1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            _pbSeekPtr += (int) dlibMove.LowPart;
        }
        break;

    case STREAM_SEEK_END:
        if (dlibMove.HighPart != -1 && dlibMove.HighPart != 0)
        {
            hr = STG_E_ACCESSDENIED;
        }
        else
        {
            _pbSeekPtr = _pbBuf + _cbBuf + (int) dlibMove.LowPart;
        }
        break;

    default:
        hr = STG_E_INVALIDFUNCTION;
        break;
    }

    if (_pbSeekPtr < _pbBuf)
    {
        _pbSeekPtr = _pbBuf;
        hr = E_INVALIDARG;
    }
    else if (_pbSeekPtr > _pbBuf + _cbBuf)
    {
        _pbSeekPtr = _pbBuf + _cbBuf;
        hr = STG_E_ACCESSDENIED;
    }

    if (plibNewPosition)
    {
        plibNewPosition->LowPart = _pbSeekPtr - _pbBuf;
        plibNewPosition->HighPart = 0;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::CopyTo
//
//  Synopsis:   per IStream
//
//      As far as I know this routine is only used during the
//      FullWindowEmbed IHistory saving scenario.  This scenario
//      copies only a view bytes so this routine is not very optimized.
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::CopyTo(
     IStream * pstm,
     ULARGE_INTEGER cb,
     ULARGE_INTEGER * pcbRead,
     ULARGE_INTEGER * pcbWritten)
{
    ULONG   ulWritten, ulToWrite, ulAvailable;
    HRESULT hr = S_OK;

    ulToWrite = cb.LowPart;
    if( cb.HighPart != 0 )
        return( E_INVALIDARG );  // sorry guy.

    ulAvailable = (_pbBuf + _cbBuf) - _pbSeekPtr;
    if( ulToWrite > ulAvailable )
        ulToWrite = ulAvailable;

    hr = pstm->Write( _pbSeekPtr, ulToWrite, &ulWritten );

    _pbSeekPtr += ulWritten;  // advance past what was written.
    
    if( pcbRead != NULL )
    {
        pcbRead->LowPart = ulWritten;
        pcbRead->HighPart = 0;
    }
    if( pcbWritten != NULL )
    {
        pcbWritten->LowPart = ulWritten;
        pcbWritten->HighPart = 0;
    }

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CROStmOnBuffer::Stat
//
//  Synopsis:   per IStream
//
//----------------------------------------------------------------------------

HRESULT
CROStmOnBuffer::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if (pstatstg)
    {
        memset(pstatstg, 0, sizeof(STATSTG));
        pstatstg->type = STGTY_STREAM;
        ULISet32(pstatstg->cbSize, _cbBuf);
        pstatstg->grfMode = STGM_READ;
    }

    return S_OK;
}


//
// CROStmOnHGlobal derived class
//
// Most implementation is same as CROStmOnBuffer.  Main difference is that
// _pbBuf is initialized to the return value of GlobalLock instead of 
// copying off some other buffer.
//

CROStmOnHGlobal::CROStmOnHGlobal()
{
    _hGlobal = NULL;
}

CROStmOnHGlobal::~CROStmOnHGlobal()
{
    if( _pbBuf )
    {
        Assert( _hGlobal != NULL );
        GlobalUnlock( _hGlobal );
        _pbBuf = NULL;
    }
}

HRESULT
CROStmOnHGlobal::Init( HGLOBAL hGlobal, long cb )
{
    HRESULT hr = S_OK;

    _cbBuf = cb;
    if( _cbBuf )
    {
        _pbBuf = (BYTE *)GlobalLock( hGlobal );
        if( !_pbBuf )
        {
            _cbBuf = 0;
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        _hGlobal = hGlobal;
        _pbSeekPtr = _pbBuf;
    }
Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\specpage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       specpage.cxx
//
//  Contents:   AddPages()
//
//  Classes:    None.
//
//  Functions:  AddPages -- adds property pages to those provided by an
//                  implementation of ISpecifyPropertyPages::GetPages.
//
//  History:    5-02-94   adams   Created
//              27-Jul-94 doncl   MemAlloc->CoTaskMemAlloc
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------------------
//
//  Function:   AddPages
//
//  Synopsis:   Adds property pages to those provided by an implementation of
//              ISpecifyPropertyPages::GetPages.
//
//  Arguments:  [pUnk]     -- Implementation of GetPages.  May be NULL.
//              [apUUID]   -- Array of pages to add.
//              [pCAUUID]  -- Result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pcauuid].
//
//----------------------------------------------------------------------------

STDAPI
AddPages(
        IUnknown *          pUnk,
        const UUID * const  apuuid[],
        CAUUID *            pcauuid)
{
    HRESULT                 hr      = S_OK;
    ISpecifyPropertyPages * pSPP;           // spp iface of agg
    CAUUID                  cauuid;         // pSPP's property pages
    ULONG                   ul;             // counter
    UUID *                  puuidDest;      // copy destination
    const UUID * const *    ppuuidSrc;      // copy source
    UUID *                  puuid;          // search
    ULONG                   c;
    ULONG                   ulcPages;

    if (!apuuid)
    {
        ulcPages = 0;
    }
    else
    {
        for (ulcPages = 0; apuuid[ulcPages]; ulcPages++)
            ;
    }

    //  NOTE that this routine accepts requests to add zero
    //    pages, in which case ulcPages == 0 and apuuid == NULL

    pcauuid->cElems = 0;
    pcauuid->pElems = NULL;

    // Get source propery pages.
    cauuid.cElems = 0;
    cauuid.pElems = NULL;
    if (pUnk)
    {
        if (!THR(pUnk->QueryInterface(
                IID_ISpecifyPropertyPages,
                (void **) &pSPP)))
        {
            hr = THR(pSPP->GetPages(&cauuid));
            pSPP->Release();

            if (hr)
                goto Cleanup;
        }
    }

    // Alloc space for combined array of pages.
    pcauuid->pElems =
        (UUID *) CoTaskMemAlloc((cauuid.cElems + ulcPages) * sizeof(UUID));
    if (!pcauuid->pElems)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Copy pages to new array.
    memcpy(
            pcauuid->pElems,
            cauuid.pElems,
            (UINT) (cauuid.cElems * sizeof(UUID)));

    ppuuidSrc = apuuid;
    puuidDest = pcauuid->pElems + cauuid.cElems;
    for (ul = 0; ul < ulcPages; ul++)
    {
        //  Make sure we don't add any duplicate pages
        for (c = cauuid.cElems, puuid = cauuid.pElems;
             c > 0;
             c--, puuid++)
        {
            if (**ppuuidSrc == *puuid)
                goto NextUUID;
        }

        *puuidDest++ = **ppuuidSrc;

NextUUID:
        ppuuidSrc++;
    }

    pcauuid->cElems = puuidDest - pcauuid->pElems;

Cleanup:
    if (cauuid.pElems)
        CoTaskMemFree(cauuid.pElems);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\regdbhlp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       regdbhlp.cxx
//
//  Contents:   Registration helper functions
//
//  History:    20-Oct-94   GaryBu  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+------------------------------------------------------------------------
//
//  Function:    RegDbDeleteKey
//
//  Synopsis:   Recursively delete registry key given key name.
//
//  Arguments:  [hkeyParent] - Parent of the key to delete.
//              [szDelete] - Name of key to delete.
//
//-------------------------------------------------------------------------
void
RegDbDeleteKey(HKEY hkeyParent, const TCHAR *pszDelete)
{
    DWORD   dwResult;
    HKEY    hkeyDelete;

    dwResult = RegOpenKey(hkeyParent, pszDelete, &hkeyDelete);
    if (dwResult != ERROR_SUCCESS)
        goto Error;
#ifndef _MAC
    // Mac note: RegDeleteKey deletes all subkeys
    {
        TCHAR   szSubKey[256];
        while (RegEnumKey(hkeyDelete, 0, szSubKey, ARRAY_SIZE(szSubKey))
                == ERROR_SUCCESS)
        {
            RegDbDeleteKey(hkeyDelete, szSubKey);
        }
    }
#endif

    Verify(RegCloseKey(hkeyDelete) == ERROR_SUCCESS);

    dwResult = RegDeleteKey(hkeyParent, pszDelete);
Error:
    Assert((dwResult == ERROR_SUCCESS) || (dwResult == ERROR_BADKEY) ||
        (dwResult == ERROR_FILE_NOT_FOUND));

}

//+------------------------------------------------------------------------
//
//  Function:    RegDbOpenCLSIDKey
//
//  Synopsis:   Open HKEY_CLASSES_ROOT\CLISD.
//
//  Arguments:  [phkeyCLISD] - Address at which to return the HKEY
//
//-------------------------------------------------------------------------
HRESULT
RegDbOpenCLSIDKey(HKEY *phkeyCLSID)
{
    return RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), phkeyCLSID) ==
            ERROR_SUCCESS ? NOERROR : REGDB_E_READREGDB;
}

//+------------------------------------------------------------------------
//
//  Function:    RegDbDSetValues
//
//  Synopsis:   Add key and values to registry.
//
//              The keys and values are described by a string
//              and an array of arguments for substitution into
//              the string. The string consists of alternating
//              key and value format strings separted by nulls.
//              These format strings are in the format described
//              by the Format function (see CORE\FORMAT.CXX).
//              The string is terminated with two nulls.
//              The first key-value pair is treated as a parent
//              for the remaining keys.
//
//  Arguments:  [hkeyParent] - Add key/value pairs to this key.
//              [szFmt] - String describing values to add to registry.
//                  See description above.
//              [adwArgs] - Values to insert into format string.
//
//-------------------------------------------------------------------------
HRESULT
RegDbSetValues(HKEY hkeyParent, TCHAR *szFmt, DWORD_PTR *adwArgs)
{
    HRESULT hr          = S_OK;
    LONG    lError;
    HKEY    hkeySubkey;
    TCHAR   szKey[128];
    TCHAR   szSubkey[128];
    TCHAR   szValue[MAX_PATH];
    BOOL    fNamedSubkey;
    BOOL    fFirstTime  = TRUE;

    Assert(szFmt && *szFmt);

    hkeySubkey   = NULL;
    fNamedSubkey = FALSE;
    while (*szFmt)
    {
        // First, extract the major key
        // (Only cause of key format error is programmer error.)
        Verify(VFormat(FMT_ARG_ARRAY,
                szKey, ARRAY_SIZE(szKey), szFmt, adwArgs) == S_OK);
        szFmt += _tcslen(szFmt) + 1;

        // Then, write each subkey/value pair
        do
        {
            //  If it is a named subkey (rather than a value on the major key),
            //  format the subkey
            //  (Default values, those associated directly with the major
            //   key, use the name of the major key)
            if (*szFmt)
            {
                fNamedSubkey = TRUE;
                Verify(VFormat(FMT_ARG_ARRAY,
                        szSubkey, ARRAY_SIZE(szSubkey), szFmt, adwArgs) == S_OK);
            }
            szFmt += _tcslen(szFmt) + 1;

            // Format the value
            hr = THR(VFormat(FMT_ARG_ARRAY,
                    szValue, ARRAY_SIZE(szValue), szFmt, adwArgs));
            if (hr)
                goto Cleanup;

            szFmt += _tcslen(szFmt) + 1;

            //  Open (and use) the key if writing a named subkey beneath it
            //  (The key must have already been created...this assumes that
            //   all keys have default values which, when set, will create
            //   the key)
            if (fNamedSubkey && !hkeySubkey)
            {
                if (RegOpenKey(hkeyParent, szKey, &hkeySubkey) != ERROR_SUCCESS)
                {
                    hr = REGDB_E_WRITEREGDB;
                    goto Cleanup;
                }
            }

            // Write the key and value
            if (!fNamedSubkey)
            {
                lError = RegSetValue(hkeyParent, szKey, REG_SZ, szValue,0);
            }
            else
            {
                Assert(hkeySubkey);
                lError = RegSetValueEx(hkeySubkey, szSubkey, 0, REG_SZ,
                                        (CONST BYTE *)szValue,
                                        (sizeof(TCHAR)*_tcslen(szValue))+1);
            }
            if (lError != ERROR_SUCCESS)
            {
                hr = REGDB_E_WRITEREGDB;
                goto Cleanup;
            }

        }
        while (*szFmt);
        szFmt += _tcslen(szFmt) + 1;    // Skip over the subkey/value pair terminator

        // If an HKEY was opened for the key itself, close it before continuing
        if (hkeySubkey)
        {
            Assert(fNamedSubkey);
            Verify(RegCloseKey(hkeySubkey) == ERROR_SUCCESS);
            hkeySubkey   = NULL;
            fNamedSubkey = FALSE;
        }

        // If further major keys exist, write them as children of the first major key
        if (fFirstTime && *szFmt)
        {
            if (RegOpenKey(hkeyParent, szKey, &hkeyParent) != ERROR_SUCCESS)
            {
                hr = REGDB_E_WRITEREGDB;
                goto Cleanup;
            }
            fFirstTime = FALSE;
        }
    }

Cleanup:
    if (hkeySubkey)
    {
        Verify(RegCloseKey(hkeySubkey) == ERROR_SUCCESS);
    }

    if (!fFirstTime)
    {
        Verify(RegCloseKey(hkeyParent) == ERROR_SUCCESS);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\stdenum.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdenum.cxx
//
//  Contents:   Standard implementations of common enumerators
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+---------------------------------------------------------------
//
//  Class:      CEnumXXX
//
//  Synopsis:   Base class for enumerators.
//
//----------------------------------------------------------------

class CEnumXXX : public IUnknown
{
private:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))
public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(CEnumXXX);

    //*** IEnumX methods ***
    STDMETHOD(Next) (ULONG c, void * pv, ULONG * pcFetched);
    STDMETHOD(Skip) (ULONG c);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (void ** ppEnumXXX) = 0;

protected:
    CEnumXXX(REFIID iid, int c, int i);
    virtual ~CEnumXXX();

    virtual HRESULT FetchElements(int c, void *pv) = 0;

    REFIID _iid;
    int  _c;
    int  _i;

#ifdef OBJCNTCHK
    DWORD _dwObjCnt;
#endif

};

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::CEnumXXX
//
//  Synopsis:   Constructor.
//
//  Arguments:  iid     iid for this enumerator.
//              c       count of elements
//              i       starting index
//
//----------------------------------------------------------------

CEnumXXX::CEnumXXX(REFIID iid, int c, int i)
    : _iid(iid)
{
    _c = c;
    _i = i;
    _ulRefs = 1;
    IncrementObjectCount(&_dwObjCnt);
}

CEnumXXX::~CEnumXXX()
{
    DecrementObjectCount(&_dwObjCnt);
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::QueryInterface, IUnknown
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::QueryInterface(REFIID iid, void ** ppvObj)
{
    if (IsEqualIID(iid,IID_IUnknown) || IsEqualIID(iid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Next(ULONG c, void *pv, ULONG *pcFetched)
{
    int   cFetched;
    HRESULT hr;

    cFetched = c;
    if (cFetched > _c - _i)
        cFetched = _c - _i;

    Assert(cFetched >= 0);

    hr = THR(FetchElements(cFetched, pv));
    if (hr)
        goto Error;

    _i += cFetched;
    hr = cFetched == (int)c ? S_OK : S_FALSE;

Cleanup:
    if (pcFetched)
    {
        *pcFetched = cFetched;
    }

    RRETURN1(hr, S_FALSE);

Error:
    cFetched = 0;
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CEnumXXX::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Skip(ULONG c)
{
    _i += c;
    if (_i > _c)
        _i = c;

    return _i == _c ? S_FALSE : S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumXXX::Reset()
{
    _i = 0;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Class:      StdEnumOLEVERB
//
//  Purpose:    Standard enumerator of OLEVERB tables
//
//---------------------------------------------------------------

MtDefine(CEnumOLEVERB, ObjectModel, "CEnumOLEVERB")

class CEnumOLEVERB: public CEnumXXX
{
    friend HRESULT CreateOLEVERBEnum(OLEVERB const *, ULONG, LPENUMOLEVERB FAR*);

public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumOLEVERB))
    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

private:
    CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iVerb);

    OLEVERB const * _pOleVerb;
};

//+---------------------------------------------------------------
//
//  Member:     CEnumOLEVERB::CEnumOLEVERB, private
//
//  Synopsis:   Constructor for CEnumOLEVERB objects
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [iOleVerb] -- starting index for enumerator.
//
//  Notes:      OLEVERB enumerators should be constructed using the
//              CreateOLEVERBEnum function.
//
//----------------------------------------------------------------

inline
CEnumOLEVERB::CEnumOLEVERB(OLEVERB const * pOleVerb, int cOleVerb, int iOleVerb)
    : CEnumXXX(IID_IEnumOLEVERB, cOleVerb, iOleVerb)
{
    _pOleVerb = pOleVerb;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
CEnumOLEVERB::FetchElements(int c, void *pv)
{
    HRESULT   hr = S_OK;
    int       i;
    LPOLEVERB pOleVerb = (LPOLEVERB)pv;

    for (i = 0; i < c; i++)
    {
        pOleVerb[i] = _pOleVerb[i + _i];
        if (pOleVerb[i].lpszVerbName)
        {
            hr = TaskAllocString(pOleVerb[i].lpszVerbName,
                    &pOleVerb[i].lpszVerbName);
            if (hr)
                goto Error;
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    while (--i >= 0)
    {
        TaskFreeString(pOleVerb[i].lpszVerbName);
    }
    memset(pv, 0, sizeof(OLEVERB) * c);
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
CEnumOLEVERB::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new CEnumOLEVERB(_pOleVerb, _c, _i);
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateOLEVERBEnum, public
//
//  Synopsis:   Creates a standard enumerator over OLEVERB arrays
//
//  Arguments:  [pOleVerb] -- pointer to the beginning of the OLEVERB array
//              [cOleVerb] -- the number of elements in the array
//              [ppEnum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IOleObject::EnumVerbs
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateOLEVERBEnum(OLEVERB const * pOleVerb, ULONG cOleVerb, LPENUMOLEVERB * ppEnum)
{
    *ppEnum = (LPENUMOLEVERB)new CEnumOLEVERB(pOleVerb, cOleVerb, 0);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Class:      StdEnumFORMATETC
//
//  Purpose:    Standard enumerator of FORMATETC tables
//
//---------------------------------------------------------------

MtDefine(_CEnumFORMATETC, ObjectModel, "_CEnumFormatETC")

class _CEnumFORMATETC: public CEnumXXX
{
    friend HRESULT CreateFORMATETCEnum(LPFORMATETC, ULONG, LPENUMFORMATETC FAR*, BOOL fDeleteOnExit);
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(_CEnumFORMATETC))
    // IEnumOLEVERB methods
    STDMETHOD(Clone) (void ** ppEnumXXX);

    // CEnumXXX methods
    HRESULT FetchElements(int c, void *pv);

    _CEnumFORMATETC  *_pClonedFrom;

protected:
    virtual ~_CEnumFORMATETC();

private:
    _CEnumFORMATETC(LPFORMATETC pFmt, int cFmt, int iFmt, BOOL fDeleteOnExit);

    LPFORMATETC     _pFmtEtc;
    BOOL            _fDeleteOnExit;

};

//+---------------------------------------------------------------
//
//  Member:     _CEnumFORMATETC::_CEnumFORMATETC, private
//
//  Synopsis:   Constructor for _CEnumFORMATETC objects
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [iFmtEtc] -- starting position for enumerator.
//
//  Notes:      Static enumerators should be constructed using the
//              CreateFORMATETCEnum function.
//
//----------------------------------------------------------------

inline
_CEnumFORMATETC::_CEnumFORMATETC(LPFORMATETC pFmtEtc, int cFmtEtc, int iFmtEtc, BOOL fDeleteOnExit)
    : CEnumXXX(IID_IEnumFORMATETC, cFmtEtc, iFmtEtc)
{
    _pFmtEtc = pFmtEtc;
    _fDeleteOnExit = fDeleteOnExit;
    _pClonedFrom = 0;
}

_CEnumFORMATETC::~_CEnumFORMATETC()
{
    if (_fDeleteOnExit)
    {
        delete [] _pFmtEtc;
    }
    ReleaseInterface(_pClonedFrom);
}

//+---------------------------------------------------------------
//
//  Member:     _CEnumFORMATETC::FetchElements
//
//  Synopsis:   Fetch elements, called from CEnumXXX::Next
//
//  Arguments:  c   Number of elements to fetch from _i.
//                  Caller insures that this is valid.
//              pv  Where stuff the elements.
//
//----------------------------------------------------------------

HRESULT
_CEnumFORMATETC::FetchElements(int c, void *pv)
{
    HRESULT     hr = S_OK;
    int         i;
    LPFORMATETC pFmtEtc = (LPFORMATETC)pv;

    for (i = 0; i < c; i++)
    {
        pFmtEtc[i] = _pFmtEtc[i + _i];
        if (pFmtEtc[i].ptd)
        {
            pFmtEtc[i].ptd = (DVTARGETDEVICE *)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));
            if (!pFmtEtc[i].ptd)
                goto MemoryError;
            *(pFmtEtc[i].ptd) = *(_pFmtEtc[i + _i].ptd);
        }
    }

Cleanup:
    RRETURN(hr);

MemoryError:
    while (--i >= 0)
    {
        CoTaskMemFree(pFmtEtc[i].ptd);
    }
    memset(pv, 0, sizeof(FORMATETC) * c);
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     _CEnumFORMATETC::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
_CEnumFORMATETC::Clone(void **ppEnumXXX)
{
    *ppEnumXXX = new _CEnumFORMATETC(_pFmtEtc, _c, _i, FALSE);
    if (*ppEnumXXX && _fDeleteOnExit)
    {
        ((_CEnumFORMATETC*)*ppEnumXXX)->_pClonedFrom = this;
        AddRef();
    }
    RRETURN(*ppEnumXXX ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Function:   CreateFORMATETCEnum, public
//
//  Synopsis:   Creates a standard enumerator over FORMATETC arrays
//
//  Arguments:  [pFmtEtc] -- pointer to the beginning of the FORMATETC array
//              [cFmtEtc] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IDataObject::EnumFormatetc
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateFORMATETCEnum(LPFORMATETC pFmtEtc, ULONG cFmtEtc, LPENUMFORMATETC * ppEnum, BOOL fDeleteOnExit)
{
    *ppEnum = (IEnumFORMATETC *)new _CEnumFORMATETC(pFmtEtc, cFmtEtc, 0, fDeleteOnExit);
    RRETURN(*ppEnum ? S_OK : E_OUTOFMEMORY);
}


#if 0   // this maybe useful later but is not currently used.

//+---------------------------------------------------------------
//
//  Class:      StdStaticEnum
//
//  Purpose:    Enumerates over a static array
//
//  Notes:      This may not be used to enumerate over structures
//              that are "deep".  For instance, it cannot be used
//              to enumerate over an array of FORMATETCs because such
//              an enumerator needs to deep copy the ptd field
//              and the enumerator client frees these allocated ptd.
//              Similarly for the OLEVERB structure where the verb
//              name string must be deep copied.
//
//---------------------------------------------------------------

class StdStaticEnum: public IUnknown
{
    friend HRESULT CreateStaticEnum(REFIID, LPVOID, ULONG, ULONG, LPVOID FAR*);

public:
    DECLARE_FORMS_STANDARD_IUNKNOWN(StdStaticEnum);

    //*** IEnumerator methods ***
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (LPSTDSTATICENUM FAR* ppenm);

private:
    // constructor/destructor
    StdStaticEnum(REFIID riid, LPVOID pStart, ULONG cSize, ULONG cCount);
    ~StdStaticEnum(void);

    IID _iid;
    LPVOID _pStart;
    ULONG _cSize;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::StdStaticEnum, private
//
//  Synopsis:   Constructor for StdStaticEnum objects
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateStaticEnum function.
//
//----------------------------------------------------------------

StdStaticEnum::StdStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount)
{
    _ulRefs = 1;
    _iid = riid;
    _pStart = pStart;
    _cSize = cSize;
    _cCount = cCount;
    _cCurrent = 0;

    TraceTag((tagStdEnum, "StdStaticEnum constructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdStaticEnum::~StdStaticEnum(void)
{
    TraceTag((tagStdEnum, "StdStaticEnum destructed."));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Next(ULONG celt,
        LPVOID pArrayObjs,
        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = min(celt, _cCount-_cCurrent);

    // calculate the number of bytes to copy
    if (celtFetched != 0 && _cSize > (UINT_MAX/celtFetched))
    {
        return E_FAIL;         // overflow!
    }

    UINT count = (UINT) (celtFetched*_cSize);
    _fmemcpy(pArrayObjs, (LPBYTE)_pStart+_cCurrent*_cSize, count);
    _cCurrent += celtFetched;
    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }
    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Clone(LPSTDSTATICENUM FAR* ppenm)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    _iid,
                                                    _pStart,
                                                    _cSize,
                                                    _cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
        r = NOERROR;
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStaticEnum, public
//
//  Synopsis:   Creates a standard enumerator over static arrays
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//----------------------------------------------------------------

HRESULT
CreateStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount,
        LPVOID FAR* ppenum)
{
    HRESULT r;
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    riid,
                                                    pStart,
                                                    cSize,
                                                    cCount);
    if (penum == NULL)
    {
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    CClassFactory
//              CStaticCF
//              CDynamicCF
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_CLSFAC3_HXX_
#define X_CLSFAC3_HXX_
#include "clsfac3.hxx"
#endif


//+---------------------------------------------------------------
//
//  Member:     CClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CClassFactory::AddRef
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CClassFactory::AddRef()
{
    IncrementSecondaryObjectCount( 4 );
    return 1;
}


//+---------------------------------------------------------------
//
//  Member:     CClassFactory::Release
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CClassFactory::Release(void)
{
    DecrementSecondaryObjectCount( 4 );
    return 1;
}


//+---------------------------------------------------------------
//
//  Member:     CClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface.
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
CClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        IncrementSecondaryObjectCount(4);
    else
        DecrementSecondaryObjectCount(4);

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CStaticCF::CreateInstance, public
//
//  Synopsis:   Method of IClassFactory interface.
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticCF::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT hr;
    IUnknown *pUnk = 0;

    *ppv = NULL;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;

    if (pUnkOuter && iid != IID_IUnknown)
        return E_INVALIDARG;

    if (!_pfnCreate)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR((*_pfnCreate)(pUnkOuter, &pUnk));
    if (hr)
        goto Cleanup;

    if (pUnkOuter)
    {
        *ppv = pUnk;
    }
    else 
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::CDynamicCF
//
//  Synopsis:   Constructor.
//
//----------------------------------------------------------------------------

CDynamicCF::CDynamicCF()
{
    _ulRefs = 1;
    IncrementSecondaryObjectCount( 5 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::~CDynamicCF
//
//  Synopsis:   Destructor.
//
//----------------------------------------------------------------------------

CDynamicCF::~CDynamicCF()
{
    DecrementSecondaryObjectCount( 5 );
}


//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDynamicCF::AddRef()
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDynamicCF::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }
    return _ulRefs;
}


BEGIN_TEAROFF_TABLE_(CStaticCF3, IClassFactoryEx)
    TEAROFF_METHOD(CStaticCF3, CreateInstance, createinstance, (IUnknown *punkOuter, REFIID riid, void **ppvObject))
    TEAROFF_METHOD(CStaticCF3, LockServer, lockserver, (BOOL fLock))
    TEAROFF_METHOD(CStaticCF3, CreateInstanceWithContext, createinstancewithcontext, (IUnknown *punkContext, IUnknown *punkOuter, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()


STDMETHODIMP
CStaticCF3::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IClassFactory)
    QI_TEAROFF(this, IClassFactoryEx, NULL)
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}


STDMETHODIMP
CStaticCF3::CreateInstance(IUnknown *pUnkOuter, REFIID iid, void **ppv)
{
    return CreateInstanceWithContext(NULL, pUnkOuter, iid, ppv);
}

//+---------------------------------------------------------------
//
//  Member:     CStaticCF3::CreateInstanceWithContext, public
//
//  Synopsis:   Method of IClassFactoryEx interface.
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticCF3::CreateInstanceWithContext(
    IUnknown *punkContext,
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT hr;
    IUnknown *pUnk = 0;

    *ppv = NULL;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;

    if (pUnkOuter && iid != IID_IUnknown)
        return E_INVALIDARG;

    hr = THR((*_pfnCreate)(punkContext, pUnkOuter, &pUnk));
    if (hr)
        goto Cleanup;

    if (pUnkOuter)
    {
        *ppv = pUnk;
    }
    else 
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\stmbuff.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stmbuff.cxx
//
//  Contents:   Useful OLE helper functions
//
//----------------------------------------------------------------------

#ifdef UNIX
#  ifdef MW_MSCOMPATIBLE_LI
#    undef MW_MSCOMPATIBLE_LI
#  endif
#endif

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

const LARGE_INTEGER LINULL = {0, 0};

//+---------------------------------------------------------------------------
//
//  Class:      CStreamBuffered 
//
//  Purpose:    IStream wrapper with a small internal cache for buffering read
//              operations
//
//  Interface:  CStreamBuffered             -- Constructor
//
//----------------------------------------------------------------------------

MtDefine(CStreamBuffered, Utilities, "CStreamBuffered")

class CStreamBuffered : public IStream
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CStreamBuffered))
    CStreamBuffered(IStream * pStream);
    ~CStreamBuffered();

    // IUnknown methods
    STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (void) ;
    STDMETHOD_(ULONG, Release) (void);

    // IStream methods
    STDMETHOD(Read)(
         void * pv,
         ULONG cb,
         ULONG * pcbRead);

    STDMETHOD(Write)(
         const void * pv,
         ULONG cb,
         ULONG * pcbWritten);

    STDMETHOD(Seek)(
         LARGE_INTEGER dlibMove,
         DWORD dwOrigin,
         ULARGE_INTEGER * plibNewPosition);

    STDMETHOD(SetSize)(
         ULARGE_INTEGER libNewSize);

    STDMETHOD(CopyTo)(
         IStream * pstm,
         ULARGE_INTEGER cb,
         ULARGE_INTEGER * pcbRead,
         ULARGE_INTEGER * pcbWritten);

    STDMETHOD(Commit)(
         DWORD grfCommitFlags);

    STDMETHOD(Revert)( void);

    STDMETHOD(LockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(UnlockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(Stat)(
         STATSTG * pstatstg,
         DWORD grfStatFlag);

    STDMETHOD(Clone)(
         IStream ** ppstm);

#define STREAMBUFSIZE 4096

    ULONG       _ulRefs;
    IStream *   _pStm;
    BYTE    _ab[STREAMBUFSIZE];
    ULONG   _ulPos;                 // position in buffer
    ULONG   _ulSize;                // size filled in buffer
    ULARGE_INTEGER _uliSeekPos;     // seek position
};

//+------------------------------------------------------------------------
//
//  Return buffered stream if created or the original stream
//
//-------------------------------------------------------------------------

IStream *
BufferStream(IStream * pStm)
{
    CStreamBuffered * pStream = new CStreamBuffered(pStm);
    return pStream ? pStream : pStm;
}

//+------------------------------------------------------------------------
//
//  CStreamBuffered implementation.
//
//-------------------------------------------------------------------------

CStreamBuffered::CStreamBuffered(IStream * pStm)
{
    _pStm = pStm;
    _ulRefs = 1;
    _ulPos = 0;
    _ulSize = 0;
#ifndef _MAC
    _uliSeekPos.QuadPart = 0;
#else
    _uliSeekPos.LowPart = 0;
    _uliSeekPos.HighPart = 0;
#endif
    IncrementSecondaryObjectCount( 6 );
}

CStreamBuffered::~CStreamBuffered()
{
    DecrementSecondaryObjectCount( 6 );
}

STDMETHODIMP
CStreamBuffered::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IStream))
    {
        *ppvObj = (IStream *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CStreamBuffered::AddRef(void)
{
    ++_ulRefs;
    return _pStm->AddRef();
}

STDMETHODIMP_(ULONG)
CStreamBuffered::Release(void)
{
    ULONG   ul;

    ul = _pStm->Release();
    if (--_ulRefs == 0)
    {
        delete this;
    }

    return ul;
}

#if DBG == 1
static BOOL s_fThru = FALSE;
#endif

STDMETHODIMP
CStreamBuffered::Read(
     void * pv,
     ULONG cb,
     ULONG * pcbRead)
{
    HRESULT hr;
    ULONG ul;
    ULONG ulRead;

#if DBG == 1
    if (s_fThru)
    {
        return _pStm->Read(pv, cb, pcbRead);
    }
#endif
    hr = S_OK;
    ulRead = 0;

    while (cb > 0 && !hr)
    {
        if (_ulPos == _ulSize)
        {
            //  If we need to read more bytes than will fit in our
            //    buffer, then read directly to the stream rather
            //    than trying to buffer.

            if (cb > sizeof(_ab))
            {
                hr = THR(_pStm->Read(pv, cb, &ul));
                ulRead += ul;

                goto Cleanup;
            }

            hr = THR(_pStm->Read(_ab, sizeof(_ab), &ul));

            // get current seek position
            hr = _pStm->Seek(LINULL, STREAM_SEEK_CUR, &_uliSeekPos);

            _ulPos = 0;
            _ulSize = ul;

            if (hr)
            {
                //  We may have attempted to read more bytes from the
                //    stream than actually exist.  If this happens, but
                //    we still read enough bytes to satisfy the user
                //    request, then report success from this call.

                if (ul >= cb)
                {
                    hr = S_OK;
                }
            }
            else
            {
                //  We may hit the end of the stream, and read less than
                //    the necessary number of bytes without getting an
                //    error code back.  In this case, we force an exit
                //    from the loop, but return S_OK as per docfiles.

                if (ul < cb)
                {
                    cb = ul;
                }
            }
        }

        ul = _ulSize - _ulPos;
        if (ul > cb)
        {
            ul = cb;
        }

        memcpy(pv, &_ab[_ulPos], ul);
        pv = (BYTE *)pv + ul;
        cb -= ul;

        _ulPos += ul;
        ulRead += ul;
    }

Cleanup:
    if (pcbRead)
    {
        *pcbRead = ulRead;
    }

    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CStreamBuffered::Write(
     const void * pv,
     ULONG cb,
     ULONG * pcbWritten)
{
    if (pcbWritten)
    {
        *pcbWritten = 0;
    }
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::Seek(
     LARGE_INTEGER dlibMove,
     DWORD dwOrigin,
     ULARGE_INTEGER * plibNewPosition)
{

    // NOTE this is the fast solution but cost a call to get seek pos
    // at read (istvanc)
#ifndef _MAC
    // if buffer is not empty use our position
    if (_ulPos != _ulSize && dwOrigin != STREAM_SEEK_END)
    {
        if (dwOrigin == STREAM_SEEK_CUR)
        {
            dlibMove.QuadPart += (LONG)_ulPos - (LONG)_ulSize;
        }
        else   // dwOrigin == STREAM_SEEK_SET
        {
            dlibMove.QuadPart -= (LONGLONG)_uliSeekPos.QuadPart;
            dwOrigin = STREAM_SEEK_CUR;
        }
        if (dlibMove.QuadPart < 0 && dlibMove.QuadPart >= -(LONG)_ulSize)
        {
            _ulPos = (LONG)_ulSize + (LONG)dlibMove.QuadPart;
            if (plibNewPosition)
            {
                plibNewPosition->QuadPart = _uliSeekPos.QuadPart + dlibMove.QuadPart;
            }
            return S_OK;
        }
    }
#else
// MACTODO - Someone please check this block! - is it right?

    // if buffer is not empty use our position
    if (_ulPos != _ulSize && dwOrigin != STREAM_SEEK_END)
    {
        if (dwOrigin == STREAM_SEEK_CUR)
        {
            dlibMove.LowPart += (LONG)_ulPos - (LONG)_ulSize;
            if((LONG) dlibMove.LowPart < 0)
                dlibMove.HighPart = -1;
            else
                dlibMove.HighPart = 0;
        }
        else   // dwOrigin == STREAM_SEEK_SET
        {
            dlibMove.LowPart -= _uliSeekPos.LowPart;
            if((LONG) dlibMove.LowPart < 0)
                dlibMove.HighPart = -1;
            else
                dlibMove.HighPart = 0;
            dwOrigin = STREAM_SEEK_CUR;
        }
        if (dlibMove.HighPart < 0 && (LONG)dlibMove.LowPart >= -(LONG)_ulSize)
        {
            _ulPos = (LONG)_ulSize + (LONG)dlibMove.LowPart;
            if (plibNewPosition)
            {
                plibNewPosition->LowPart = _uliSeekPos.LowPart + (LONG)dlibMove.LowPart;
                plibNewPosition->HighPart = 0;
            }
            return S_OK;
        }
    }
#endif
    // mark buffer empty
    _ulPos = _ulSize;
    RRETURN(THR(_pStm->Seek(dlibMove, dwOrigin, plibNewPosition)));
}

STDMETHODIMP
CStreamBuffered::SetSize(
     ULARGE_INTEGER libNewSize)
{
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::CopyTo(
     IStream * pstm,
     ULARGE_INTEGER cb,
     ULARGE_INTEGER * pcbRead,
     ULARGE_INTEGER * pcbWritten)
{
    if (pcbWritten)
    {
#ifndef _MAC
        pcbWritten->QuadPart = 0;
#else
        pcbWritten->LowPart = 0;
        pcbWritten->HighPart = 0;
#endif
    }
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::Commit(
     DWORD grfCommitFlags)
{
    return E_FAIL;
}

STDMETHODIMP
CStreamBuffered::Revert( void)
{
    // mark buffer empty
    _ulPos = _ulSize;
    RRETURN(THR(_pStm->Revert()));
}

STDMETHODIMP
CStreamBuffered::LockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    RRETURN(THR(_pStm->LockRegion(libOffset, cb, dwLockType)));
}

STDMETHODIMP
CStreamBuffered::UnlockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    RRETURN(THR(_pStm->UnlockRegion(libOffset, cb, dwLockType)));
}

STDMETHODIMP
CStreamBuffered::Stat(
     STATSTG * pstatstg,
     DWORD grfStatFlag)
{
    RRETURN(THR(_pStm->Stat(pstatstg, grfStatFlag)));
}

STDMETHODIMP
CStreamBuffered::Clone(
     IStream ** ppstm)
{
#if 1
    // TODO fix later, fail for now (istvanc)
    *ppstm = NULL;
    return E_FAIL;
#else
    HRESULT hr;

    //  TODO the underlying stream's current pos may not match the
    //    buffering layer's position (chrisz)

    hr = THR(_pStm->Clone(ppstm));
    if (hr)
        goto Cleanup;

    //
    // Don't wrap if already wrapped. We can determine
    // if it is wrapped by looking at the vtable pointer.
    //

    if (**(DWORD**)ppstm == *(DWORD *)this)
        goto Cleanup;

    *ppstm = BufferStream(*ppstm);

Cleanup:
    RRETURN(hr);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\strtype1.cxx ===
//+------------------------------------------------------------------------
//
//  File:       strtype1.c
//
//  Contents:   widechar character type function (CT_CTYPE1)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRTYPE_HXX_
#define X_STRTYPE_HXX_
#include "strtype.hxx"
#endif

DWORD adwData[218] =
{
#if 0
    0x00000000, 0x7fffffe0, 0xfffffeff, 0xffffffff,  // 0x00-0x03
    0xfffffd3f, 0xffffff00, 0x0000ffff, 0xff800000,  // 0x04-0x07
    0x02ebffff, 0xdfffffff, 0xfffefe2a, 0xbffff000,  // 0x08-0x0b
    0x7ffbffff, 0xffff7ffb, 0xd000ffff, 0xf998ffff,  // 0x0c-0x0f
    0xfff3fdd0, 0x00007fff, 0xfffffe00, 0x7fffffff,  // 0x10-0x13
    0xff000000, 0xffe0e000, 0x7fe00000, 0xffffff3e,  // 0x14-0x17
    0xfffef400, 0x07ffffff, 0xffffffd0, 0x000000ff,  // 0x18-0x1b
    0xd0000000, 0x07f99fff, 0xffbfa3d0, 0x0000000d,  // 0x1c-0x1f
    0xd000d000, 0x07e19fff, 0xffbfb6d0, 0x0000007a,  // 0x20-0x23
    0x07f5dfff, 0xffbfb7d0, 0x80000000, 0xffbfb3d0,  // 0x24-0x27
    0x07e3bd6b, 0x18e3fdd0, 0x07fbbfff, 0xffbff7d0,  // 0x28-0x2b
    0x00000002, 0xffbfffd0, 0xfffeb000, 0xfd000000,  // 0x2c-0x2f
    0x69a40f7f, 0x75360000, 0x0000000d, 0xfd00ffff,  // 0x30-0x33
    0xffffffd1, 0xe0ffffff, 0xffffffe0, 0xfffffdfd,  // 0x34-0x37
    0xfdfdff55, 0xfffffffd, 0xfffffbf8, 0x3bf8f3f0,  // 0x38-0x3b
    0xfff83bf8, 0x0000000f, 0xffd00000, 0x04000000,  // 0x3c-0x3f
    0xfffff81e, 0xffffffee, 0xfff87fff, 0xfffe0000,  // 0x40-0x43
    0xf0000000, 0xfffd0000, 0xfe001f01, 0xfffffefa,  // 0x44-0x47
    0xdbffffff, 0xffffd000, 0x00001fff, 0xffbfffff,  // 0x48-0x4b
    0xbfffffff, 0xffff3fff, 0x0000fff0, 0xfffffff8,  // 0x4c-0x4f
    0x03ffffff, 0x7ffffffe, 0x3f3f3f38, 0x007d0000,  // 0x50-0x53
    0xfff00000, 0x00000001, 0x7fff003f, 0x8000001f,  // 0x54-0x57
    0x8000001e, 0x00000100, 0x00002000, 0xfffffffe,  // 0x58-0x5b
    0xd0000d22, 0x0d000000, 0x3e000000, 0x0000007f,  // 0x5c-0x5f
    0x00400000, 0x00001800, 0x00080011, 0x801fe000,  // 0x60-0x63
    0x003d8000, 0x00000bff, 0x70000000, 0xfffdf800,  // 0x64-0x67
    0x3d008000, 0x0000000b, 0xf99d0100, 0x30003fe0,  // 0x68-0x6b
    0x20000000, 0xe19d0000, 0x0000f800, 0xfddd8000,  // 0x6c-0x6f
    0xf19d0300, 0x00008000, 0x30000000, 0x00000003,  // 0x70-0x73
    0xe3bd0100, 0xfbbd0600, 0xf3bd0100, 0x00014fe1,  // 0x74-0x77
    0x03ff0030, 0x0001ffdd, 0xfafd0000, 0x00000010,  // 0x78-0x7b
    0x00000007, 0xd0070007, 0x00070006, 0xfffeffff,  // 0x7c-0x7f
    0xfe000000, 0x003f003f, 0x003e0000, 0xffffff80,  // 0x80-0x83
    0xe000ffff, 0xffe00000, 0xf8000000, 0xfffffd00,  // 0x84-0x87
    0xfffbffff, 0xffff0000, 0xfffff03f, 0x7bdfffff,  // 0x88-0x8b
    0xff7fffff, 0xfff5e2fe, 0x7f0003ff, 0xfffff8ff,  // 0x8c-0x8f
    0xffff7ffe, 0xffffff01, 0x0000007e, 0x0000001e,  // 0x90-0x93
    0xfffffff1, 0xffff8000, 0xfff0ffff, 0xfffffe1f,  // 0x94-0x97
    0xf000ffff, 0xf87fefff, 0xfef0ebff, 0x7d008000,  // 0x98-0x9b
    0xfefe0000, 0x0000ffd0, 0x00003040, 0x03ff0000,  // 0x9c-0x9f
    0x01ffe000, 0x00008fd0, 0x7e000000, 0xfffffefe,  // 0xa0-0xa3
    0xaaaaaaaa, 0xaaaaaa55, 0x552aaaaa, 0xaaaaaad4,  // 0xa4-0xa7
    0x6b73db8d, 0xa94b7588, 0x0db55552, 0xaaaa682a,  // 0xa8-0xab
    0xaaaaaa00, 0x02eb7fff, 0xdff00000, 0x0000382a,  // 0xac-0xaf
    0xaaaa0000, 0x8000aaaa, 0x5110aaaa, 0xaaa2a880,  // 0xb0-0xb3
    0xaaaaa800, 0xaaaaaa80, 0x00ff00fd, 0x00ff00ff,  // 0xb4-0xb7
    0x00fd0055, 0x00ff0000, 0x00ff00f8, 0x00f800f0,  // 0xb8-0xbb
    0x00f800f8, 0x000003ff, 0x55555555, 0x555555aa,  // 0xbc-0xbf
    0xaad55555, 0x5555552b, 0x948d2472, 0x54948a64,  // 0xc0-0xc3
    0x06daaaad, 0x5555b415, 0x55555500, 0xdfdff5ff,  // 0xc4-0xc7
    0x3ffef026, 0x9f800000, 0x000fffff, 0xfffed600,  // 0xc8-0xcb
    0x1555f000, 0x40005555, 0x28885555, 0x55515440,  // 0xcc-0xcf
    0x555557e0, 0x55555540, 0xff00fd00, 0xff00ff00,  // 0xd0-0xd3
    0xfd00ff00, 0xff00fffd, 0xff00fb00, 0x3b00f300,  // 0xd4-0xd7
    0xff003b00, 0xfe001f00
#else
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
#endif
};

BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL FormsIsCharSpace(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

#if 0   
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
   
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL FormsIsCharXDigit(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
#if 0
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
}

#ifdef NEVER
// unused
BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};
#endif // NEVER

BOOL FormsIsCharCntrl(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL FormsIsCharBlank(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}

BOOL FormsIsCharAlphaNumeric(WCHAR wch)
{
    return FormsIsCharAlpha(wch) || FormsIsCharDigit(wch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\stgutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stgutils.hxx
//
//  Contents:   IStorage and IStream Helper functions
//
//
//	History:	
//				5-22-95		kfl		converted WCHAR to TCHAR
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------
//
//  Function:   GetMonikerDisplayName
//
//  Synopsis:   Retrieves the display name of a moniker
//
//  Arguments:  [pmk] -- the moniker for which the display name is requested
//              [ppstr] -- the place where the display name is returned
//
//  Returns:    Success iff the display name could be retrieved
//
//  Notes:      The display name string is allocated using the task allocator
//              and should be freed by the same.
//
//----------------------------------------------------------------

HRESULT
GetMonikerDisplayName(LPMONIKER pmk, LPTSTR FAR* ppstr)
{
    HRESULT hr;
    LPBC    pbc;

    hr = THR(CreateBindCtx(0, &pbc));
    if (!hr)
    {
#ifndef _MACUNICODE
        hr = THR(pmk->GetDisplayName(pbc, NULL, ppstr));
#else
        LPOLESTR    szName;
        CStr        str;
        hr = THR(pmk->GetDisplayName(pbc, NULL, &szName));
        str.Set(szName);
        *ppstr = (LPTSTR)CoTaskMemAlloc (str.Length()*sizeof(TCHAR) + sizeof(TCHAR));
        if (*ppstr == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
            _tcscpy( *ppstr, str);
        CoTaskMemFree(szName);
#endif
        pbc->Release();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Function:   CreateStorageOnHGlobal
//
//  Synopsis:   Creates an IStorage on a global memory handle
//
//  Arguments:  [hgbl] -- memory handle to create storage on
//              [ppStg] -- where the storage is returned
//
//  Returns:    Success iff the storage could be successfully created
//              on the memory handle.
//
//  Notes:      This helper function combines CreateILockBytesOnHGlobal
//              and StgCreateDocfileOnILockBytes.  hgbl may be NULL in
//              which case a global memory handle will be automatically
//              allocated.
//
//----------------------------------------------------------------

HRESULT
CreateStorageOnHGlobal(HGLOBAL hgbl, LPSTORAGE FAR* ppStg)
{
    HRESULT     hr;
    LPLOCKBYTES pLockBytes;

#ifndef _MAC
    hr = THR(CreateILockBytesOnHGlobal(hgbl, TRUE, &pLockBytes));
#else
    {
        Handle hv = NULL;

        if(!hgbl || GetWrapperHandle (hgbl,&hv))
        {

            hr = THR(CreateILockBytesOnHGlobal(hv, TRUE, &pLockBytes));
        }
        else
        {
            Assert ( 0&& "Failed to GetWrapperHandle");
            hr = E_INVALIDARG;
        }
    }
#endif

    if (!hr)
    {
        //REVIEW: should be use STGM_DELETEONRELEASE when hgbl == NULL?
        hr = THR(StgCreateDocfileOnILockBytes(
                pLockBytes,
                STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                0,
                ppStg));
        pLockBytes->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\strtype3.cxx ===
//+------------------------------------------------------------------------
//
//  File:       strtype3.c
//
//  Contents:   widechar character type function (CT_CTYPE3)
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRTYPE_HXX_
#define X_STRTYPE_HXX_
#include "strtype.hxx"
#endif

static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};

BOOL _stdcall
GetStringType3Ex(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPBYTE  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        BYTE bCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                bCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                bCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                bCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                bCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    bCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    bCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = bCharType;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\taskman.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       taskman.cxx
//
//  Contents:   Lightweight task manager
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

//+---------------------------------------------------------------------------
//  Trace Tags
//----------------------------------------------------------------------------

PerfDbgTag(tagTaskMan, "TaskMan", "Trace lightweight task manager")

//+---------------------------------------------------------------------------
//  Definitions
//----------------------------------------------------------------------------

#define TASKMAN_TIMERID     1000
#define TIMER_INFINITE      0x7FFFFFFF

//+---------------------------------------------------------------------------
//
//  Member:     InitTaskManager
//
//  Synopsis:   Initializes the lightweight task manager
//
//----------------------------------------------------------------------------

HRESULT InitTaskManager(THREADSTATE * pts)
{
    PerfDbgLog(tagTaskMan, 0, "+InitTaskManager");

    pts->task.dwTickRun   = 200;
    pts->task.dwTickTimer = TIMER_INFINITE;

    PerfDbgLog(tagTaskMan, 0, "-InitTaskManager");
    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     DeinitTaskManager
//
//----------------------------------------------------------------------------

void DeinitTaskManager(THREADSTATE * pts)
{
    PerfDbgLog(tagTaskMan, 0, "+DeinitTaskManager");

    CTask * ptask;

    Assert(pts->task.ptaskHead == NULL && "Active tasks remain at shutdown");
    Assert(pts->task.ptaskCur == NULL);

    while ((ptask = pts->task.ptaskHead) != NULL)
    {
        Assert(!ptask->TestFlag(TASKF_INRUN));
        ptask->Terminate();
        ptask->Release();
    }

    FormsKillTimer(InitTaskManager, TASKMAN_TIMERID);

    PerfDbgLog(tagTaskMan, 0, "-DeinitTaskManager");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanResetTimer
//
//  Synopsis:   Sets the timer to the minimum interval of all unblocked
//              tasks.
//
//----------------------------------------------------------------------------

void CTask::TaskmanResetTimer()
{
    PerfDbgLog(tagTaskMan, 0, "+CTask::TaskmanResetTimer");

    THREADSTATE * pts = GetThreadState();
    CTask * ptask;
    DWORD   dwMin;
    DWORD   dwCurTick = GetTickCount();
    DWORD   dwFromLastTick;

    if (pts->task.fSuspended)
    {
        dwMin = TIMER_INFINITE;
    }
    else if (pts->task.cInterval > 0)
    {
        dwMin = TIMER_INFINITE;

        for (ptask = pts->task.ptaskHead; ptask; ptask = ptask->_ptaskNext)
        {
            if (!ptask->TestFlag(TASKF_BLOCKED | TASKF_TERMINATED))
            {
                // Check for smallest interal
                if (dwMin > ptask->_dwTickInterval)
                    dwMin = ptask->_dwTickInterval;

                dwFromLastTick = dwCurTick - ptask->_dwTickLast;

                // Check if a task needs to run earlier then that
                if (dwMin > dwFromLastTick)
                    dwMin = dwFromLastTick;
            }
        }
    }
    else if (pts->task.cUnblocked > 0)
    {
        dwMin = 0;
    }
    else
    {
        dwMin = TIMER_INFINITE;
    }

    TaskmanSetTimer(dwMin);

    PerfDbgLog(tagTaskMan, 0, "-CTask::TaskmanResetTimer");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanSetTimer
//
//  Synopsis:   Sets timer if new interval is different then existing one
//
//----------------------------------------------------------------------------

void
CTask::TaskmanSetTimer(DWORD dwTimeOut)
{
    THREADSTATE * pts = GetThreadState();

    if (dwTimeOut != pts->task.dwTickTimer)
    {
        PerfDbgLog1(tagTaskMan, 0, "CTask::TaskmanSetTimer %ld", dwTimeOut);

        IGNORE_HR(FormsSetTimer(InitTaskManager,
            ONTICK_METHOD(CTask, OnTaskTick, ontasktick), TASKMAN_TIMERID, dwTimeOut));

        pts->task.dwTickTimer = dwTimeOut;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanEnqueue
//
//  Synopsis:   Adds a task to the list of tasks
//
//----------------------------------------------------------------------------

void CTask::TaskmanEnqueue(CTask * ptask)
{
    PerfDbgLog(tagTaskMan, ptask, "+CTask::TaskmanEnqueue");

    THREADSTATE * pts = GetThreadState();
    CTask ** pptask, * ptaskT;

    Assert(!ptask->TestFlag(TASKF_ENQUEUED));
    Assert(!ptask->TestFlag(TASKF_TERMINATED));

    for (pptask = &pts->task.ptaskHead; (ptaskT = *pptask) != NULL;
            pptask = &ptaskT->_ptaskNext)
        ;
    *pptask = ptask;
    ptask->_ptaskNext = NULL;
    ptask->SetFlag(TASKF_ENQUEUED);

    if (!ptask->TestFlag(TASKF_BLOCKED))
    {
        pts->task.cUnblocked += 1;
    }

    if (ptask->_dwTickInterval > 0)
    {
        pts->task.cInterval += 1;
    }

    TaskmanResetTimer();

    PerfDbgLog(tagTaskMan, ptask, "-CTask::TaskmanEnqueue");
}

//+---------------------------------------------------------------------------
//
//  Member:     CTaskManager::Dequeue
//
//  Synopsis:   Removes a task from the list of tasks
//
//----------------------------------------------------------------------------

void CTask::TaskmanDequeue(CTask * ptask)
{
    PerfDbgLog(tagTaskMan, ptask, "+CTask::TaskmanDequeue");

    THREADSTATE * pts;
    CTask ** pptask, * ptaskT;

    if (!ptask->TestFlag(TASKF_ENQUEUED))
        goto exit;

    pts = GetThreadState();

    for (pptask = &pts->task.ptaskHead; (ptaskT = *pptask) != NULL;
            pptask = &ptaskT->_ptaskNext)
    {
        if (ptaskT == ptask)
        {
            if (pts->task.ptaskNext == ptask)
                pts->task.ptaskNext = ptask->_ptaskNext;

            if (pts->task.ptaskNextInLoop == ptask)
                pts->task.ptaskNextInLoop = ptask->_ptaskNext;


            *pptask = ptask->_ptaskNext;

            ptask->ClearFlag(TASKF_ENQUEUED);

            if (!ptask->TestFlag(TASKF_BLOCKED))
            {
                pts->task.cUnblocked -= 1;
            }

            if (ptask->_dwTickInterval > 0)
            {
                pts->task.cInterval -= 1;
            }

            TaskmanResetTimer();

            goto exit;
        }
    }

    AssertSz(FALSE, "Task not found on task manager queue");

exit:
    PerfDbgLog(tagTaskMan, ptask, "-CTask::TaskmanDequeue");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanRunTask
//
//  Synopsis:   Calls the OnRun method of the given task
//
//----------------------------------------------------------------------------

void CTask::TaskmanRunTask(THREADSTATE * pts, DWORD dwTick, CTask * ptask)
{
    PerfDbgLog(tagTaskMan, ptask, "+CTask::TaskmanRunTask");

    // Don't allow more than one task to run at the same time

    if (pts->task.ptaskCur)
        goto exit;

    ptask->SetFlag(TASKF_INRUN);
    pts->task.ptaskCur = ptask;
    ptask->_dwTickLast = dwTick;
    ptask->OnRun(dwTick + pts->task.dwTickRun);

    if (ptask->TestFlag(TASKF_DOTERM))
    {
        ptask->OnTerminate();
        TaskmanDequeue(ptask);
    }

    pts->task.ptaskCur = NULL;
    ptask->ClearFlag(TASKF_INRUN);

    if (pts->task.fSuspended)
    {
        PerfDbgLog(tagTaskMan, 0, "CTask::TaskmanRunTask (resume taskman)");
        pts->task.fSuspended = FALSE;
        TaskmanResetTimer();
    }

    if (ptask->TestFlag(TASKF_DODESTRUCT))
        delete ptask;

exit:
    PerfDbgLog(tagTaskMan, ptask, "-CTask::TaskmanRunTask");
}

//+---------------------------------------------------------------------------
//
//  Member:     TaskmanRun
//
//  Synopsis:   Finds the next available task and calls it's OnRun method
//
//----------------------------------------------------------------------------

void CTask::TaskmanRun()
{
    PerfDbgLog(tagTaskMan, 0, "+CTask::TaskmanRun");

    THREADSTATE * pts = GetThreadState();
    CTask *  ptask;
    DWORD    dwTick;
    DWORD    dwNewInterval = 0;
    DWORD    dwFromLast;

    if (!pts->task.ptaskHead)
        goto exit;

    if (pts->task.ptaskCur)
    {
        if (!pts->task.fSuspended)
        {
            PerfDbgLog(tagTaskMan, 0, "CTask::TaskmanRun (suspend taskman)");
            pts->task.fSuspended = TRUE;
            TaskmanResetTimer();
        }
        goto exit;
    }

    if (pts->task.ptaskNext == NULL)
        pts->task.ptaskNext = pts->task.ptaskHead;

    ptask  = pts->task.ptaskNext;
    dwTick = GetTickCount();

    // Run one 0-interval  task first
    for (;;)
    {
        if (    !ptask->TestFlag(TASKF_BLOCKED | TASKF_TERMINATED)
            &&  0 == ptask->_dwTickInterval)
        {
            pts->task.ptaskNext = ptask->_ptaskNext;

            TaskmanRunTask(pts, dwTick, ptask);

            break;
        }

        ptask = ptask->_ptaskNext;

        if (ptask == NULL)
            ptask = pts->task.ptaskHead;

        if (ptask == pts->task.ptaskNext)
            break;
    }

    if (pts->task.cInterval)
    {
        // Now run all interval tasks that need to run
        ptask = pts->task.ptaskHead;

        // We cache the next task in the thread task, so we can fix it
        // when tasks are destroyed as result of being run.
        //pptaskNext = &pts->task.ptaskNextInLoop;

        for (;;)
        {
            // Before we run the task we should get the next task, since TaskmanRunTask
            // might delete any task on the chain including ptask. If the next task is deleted
            // as result of calling TaskmanRunTask, pts->task.ptaskNextInLoop will be updated.
            pts->task.ptaskNextInLoop = ptask->_ptaskNext;//*pptaskNext = ptask->_ptaskNext;

            // skip 0 tasks
            if (    !ptask->TestFlag(TASKF_BLOCKED | TASKF_TERMINATED)
                &&  0 != ptask->_dwTickInterval)
            {

                if (0 == ptask->_dwTickLast)
                {
                    // Force first run
                    dwFromLast = ptask->_dwTickInterval;
                }
                else
                {
                    dwFromLast = dwTick - ptask->_dwTickLast;
                }

                // If we are 10 ticks or less from running this task run it now
                if (dwFromLast + 10>= ptask->_dwTickInterval)
                {
                    TaskmanRunTask(pts, dwTick, ptask);
                }
                else
                {
                    if (dwFromLast < dwNewInterval)
                    {
                        dwNewInterval = dwFromLast;
                    }
                }
            }

        
            // grab the next task
            ptask = pts->task.ptaskNextInLoop;

            if (ptask == NULL )
            {
                break;
            }

        }

        if (dwNewInterval)
        {
            TaskmanSetTimer(dwNewInterval);
        }
 
    }

exit:
    PerfDbgLog(tagTaskMan, 0, "-CTask::TaskmanRun");
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::CTask
//
//  Synopsis:   Constructor.
//
//----------------------------------------------------------------------------

CTask::CTask(BOOL fBlocked)
{
    #if DBG==1
    _dwThreadId = GetCurrentThreadId();
    #endif

    _ulRefs = 1;

    if (fBlocked)
        SetFlag(TASKF_BLOCKED);
    
    TaskmanEnqueue(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::~CTask
//
//  Synopsis:   Destructor.
//
//----------------------------------------------------------------------------

CTask::~CTask()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    TaskmanDequeue(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::AddRef
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTask::AddRef()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    return(++_ulRefs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::Release
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTask::Release()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (--_ulRefs == 0)
    {
        Terminate();

        if (TestFlag(TASKF_INRUN))
            SetFlag(TASKF_DODESTRUCT);
        else
            delete this;

        return(0);
    }

    return(_ulRefs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::SetInterval
//
//  Synopsis:   Sets the periodic interval for this task
//
//----------------------------------------------------------------------------

void CTask::SetInterval(DWORD dwTick)
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (dwTick != _dwTickInterval)
    {
        if (!TestFlag(TASKF_BLOCKED) && !!dwTick != !!_dwTickInterval)
        {
            THREADSTATE * pts = GetThreadState();

            if (dwTick == 0)
                pts->task.cInterval -= 1;
            else
                pts->task.cInterval += 1;
        }

        _dwTickInterval = dwTick;

        TaskmanResetTimer();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::SetBlocked
//
//  Synopsis:   Blocks or unblocks the task
//
//----------------------------------------------------------------------------

void CTask::SetBlocked(BOOL fBlocked)
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (!!fBlocked != !!TestFlag(TASKF_BLOCKED))
    {
        THREADSTATE * pts = GetThreadState();

        if (fBlocked)
        {
            SetFlag(TASKF_BLOCKED);
            pts->task.cUnblocked -= 1;

            if (_dwTickInterval > 0)
                pts->task.cInterval -= 1;
        }
        else
        {
            ClearFlag(TASKF_BLOCKED);
            pts->task.cUnblocked += 1;

            if (_dwTickInterval > 0)
                pts->task.cInterval += 1;
        }

        TaskmanResetTimer();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::Terminate
//
//  Synopsis:   Requests that task be terminated.  As soon as possible,
//              the task's OnTerminate method will be called (typically
//              before this method returns).  Actual object destruction
//              doesn't happen until all references are released.
//
//----------------------------------------------------------------------------

void CTask::Terminate()
{
    Assert(_dwThreadId == GetCurrentThreadId());

    if (!TestFlag(TASKF_TERMINATED))
    {
        if (TestFlag(TASKF_INRUN))
            SetFlag(TASKF_DOTERM);
        else
        {
            OnTerminate();
            TaskmanDequeue(this);
        }

        SetFlag(TASKF_TERMINATED);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::OnTerminate
//
//  Synopsis:   Base implementation.  Does nothing.
//
//----------------------------------------------------------------------------

void CTask::OnTerminate()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTask::OnTaskTick
//
//  Synopsis:   Callback timer procedure.
//
//----------------------------------------------------------------------------

HRESULT CTask::OnTaskTick(UINT idTimer)
{
    TaskmanRun();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\substm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       substm.hxx
//
//  Contents:   Substream implementation
//
//  History:    04-22-1997   DBau (David Bau)    Created
//
//-------------------------------------------------------------------------

#ifdef UNIX
#  ifdef MW_MSCOMPATIBLE_LI
#    undef MW_MSCOMPATIBLE_LI
#  endif
#endif

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SUBSTM_HXX_
#define X_SUBSTM_HXX_
#include "substm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

MtDefine(CSubstream, Dwn, "CSubstream")

//+------------------------------------------------------------------------
//
//  Function:   CreateReadOnlySubstream
//
//  Synopsis:   Constructs and intializes a read-only substream.
//
//              The substream begins at the current seek pointer in
//              the source stream, and stores its data in the next
//              cb bytes. The source stream's seek pointer is not
//              affected by a read only substream.
//
//-------------------------------------------------------------------------
HRESULT CreateReadOnlySubstream(CSubstream **ppStreamOut, IStream *pStreamSource, ULARGE_INTEGER cb)
{
    HRESULT hr;
    CSubstream *pSubstream = NULL;

    pSubstream = new CSubstream();
    if (!pSubstream)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pSubstream->InitRead(pStreamSource, cb));
    if (hr)
        goto Cleanup;
    
    *ppStreamOut = pSubstream;
    pSubstream = NULL;
    
Cleanup:
    ReleaseInterface(pSubstream);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CreateWritableSubstream
//
//  Synopsis:   Constructs and intializes a writable substream.
//
//              The substream begins at the current seek pointer in
//              the source stream, and grows as data is written. The
//              source stream's seek pointer is used directly by
//              the substream, so no operations should be done directly
//              on the source while the substream is in use.
//
//-------------------------------------------------------------------------
HRESULT CreateWritableSubstream(CSubstream **ppStreamOut, IStream *pStreamSource)
{
    HRESULT hr;
    CSubstream *pSubstream = NULL;

    pSubstream = new CSubstream();
    if (!pSubstream)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pSubstream->InitWrite(pStreamSource));
    if (hr)
        goto Cleanup;

    *ppStreamOut = pSubstream;
    pSubstream = NULL;
    
Cleanup:
    ReleaseInterface(pSubstream);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CSubstream::ctor
//
//  Synopsis:   Maintains a secondary object count for the object
//
//-------------------------------------------------------------------------
CSubstream::CSubstream()
{
    IncrementSecondaryObjectCount(10);
    _ulRefs = 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::dtor
//
//  Synopsis:   Destructor
//
//-------------------------------------------------------------------------
CSubstream::~CSubstream()
{
    Detach();
    DecrementSecondaryObjectCount(10);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Detach
//
//  Synopsis:   Detaches a substream from the original stream.
//              Useful for ensuring no further writes to the
//              real stream after a substream is leaked.
//
//-------------------------------------------------------------------------
void CSubstream::Detach()
{
    if (_pOrig && _pOrig != this)
    {
        _pOrig->Release();
        _pOrig = this;
    }
    
    ClearInterface(&_pStream);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::InitRead
//
//  Synopsis:   Initializes a fixed-size, read-only substream
//              object at the current seek pointer in the
//              source stream.
//
//-------------------------------------------------------------------------
HRESULT CSubstream::InitRead(IStream *pStream, ULARGE_INTEGER cb)
{
    IStream *pClone = NULL;
    HRESULT hr;
    
    Assert(!_pStream && !_pOrig); // Init can only be called once

    _pOrig = this;
    _fWritable = FALSE;
    
    hr = THR(pStream->Clone(&pClone));
    if (hr)
        goto Cleanup;
    
    hr = THR(pClone->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &_ibStart));
    if (hr)
        goto Cleanup;
        
    _ibEnd.QuadPart = _ibStart.QuadPart + cb.QuadPart;

    _pStream = pClone;
    pClone = NULL;

Cleanup:
    ReleaseInterface(pClone);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::InitWrite
//
//  Synopsis:   Initializes a zero-size, writable substream
//              object at the current seek pointer in the
//              source stream.
//
//-------------------------------------------------------------------------
HRESULT CSubstream::InitWrite(IStream *pStream)
{
    HRESULT hr;
    
    Assert(!_pStream && !_pOrig); // Init can only be called once

    _pOrig = this;
    _fWritable = TRUE;
    
    pStream->AddRef();
    _pStream = pStream;

    hr = THR(pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &_ibStart));
    if (hr)
        goto Cleanup;
        
    _ibEnd.QuadPart = _ibStart.QuadPart; // begin as zero-sized substream
    
Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::InitClone
//
//  Synopsis:   Initializes a clone of an existing substream.
//
//-------------------------------------------------------------------------
HRESULT CSubstream::InitClone(CSubstream *pOrig)
{
    HRESULT hr;
    
    Assert(!_pStream && !_pOrig); // Init can only be called once
    
    Assert(pOrig->_pOrig);
    
    hr = THR(pOrig->_pStream->Clone(&_pStream));
    if (hr)
        goto Cleanup;
        
    pOrig->_pOrig->AddRef();
    _pOrig = pOrig->_pOrig;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::QueryInterface
//
//  Synopsis:   QI implementation
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::QueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IStream)
        QI_INHERITS(this, IStream)
    default:
        return(E_NOINTERFACE);
    }
    
    ((IUnknown *) *ppv)->AddRef();

    DbgTrackItf(iid, "CSubstream", FALSE, ppv);
    
    return(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Read, IStream
//
//  Synopsis:   Read wrapper, guards against reading beyond
//              the boundaries of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Read(void HUGEP *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;
    ULARGE_INTEGER ibCur;
    
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
    if (hr)
        goto Cleanup;
        
    Assert(_pOrig->_ibEnd.QuadPart >= ibCur.QuadPart);

    if (cb > _pOrig->_ibEnd.QuadPart - ibCur.QuadPart)
        cb = _pOrig->_ibEnd.QuadPart - ibCur.QuadPart;
        
    hr = THR(_pStream->Read(pv, cb, pcbRead));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Write, IStream
//
//  Synopsis:   Write wrapper, expands stream if needed when
//              writing beyond the end.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Write(const void HUGEP *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;
    ULARGE_INTEGER ibCur;
    
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);
        
    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
    if (hr)
        goto Cleanup;
        
    if (cb + ibCur.QuadPart > _pOrig->_ibEnd.QuadPart)
        _pOrig->_ibEnd.QuadPart = ibCur.QuadPart + cb;
        
    hr = THR(_pStream->Write(pv, cb, pcbRead));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Seek, IStream
//
//  Synopsis:   Seek wrapper, expands stream if needed when
//              seeking beyond the end.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Seek(LARGE_INTEGER cbMove, DWORD dwOrigin, ULARGE_INTEGER *pibNewPosition)
{
    LARGE_INTEGER cbSeek;
    ULARGE_INTEGER ibCur;
    
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    switch (dwOrigin)
    {
    default:
    case STREAM_SEEK_SET:
        cbSeek.QuadPart = _pOrig->_ibStart.QuadPart + cbMove.QuadPart;
        break;
    case STREAM_SEEK_CUR:
        hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
        if (hr)
            goto Cleanup;
        cbSeek.QuadPart = ibCur.QuadPart + cbMove.QuadPart;
        break;
    case STREAM_SEEK_END:
        cbSeek.QuadPart = _pOrig->_ibEnd.QuadPart + cbMove.QuadPart;
        break;
    }

    if ((unsigned)cbSeek.QuadPart < _pOrig->_ibStart.QuadPart)
        return(STG_E_ACCESSDENIED);
        
    if ((unsigned)cbSeek.QuadPart > _pOrig->_ibEnd.QuadPart)
    {
        if (!_pOrig->_fWritable)
            return(STG_E_ACCESSDENIED);
        _pOrig->_ibEnd.QuadPart = cbSeek.QuadPart;
    }
 
    hr = THR(_pStream->Seek(cbSeek, STREAM_SEEK_SET, &ibCur));
    if (hr)
        goto Cleanup;

    Assert((unsigned)cbSeek.QuadPart == ibCur.QuadPart);

    if (pibNewPosition)
        pibNewPosition->QuadPart = ibCur.QuadPart - _pOrig->_ibStart.QuadPart;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::SetSize, IStream
//
//  Synopsis:   SetSize wrapper, delegates to source stream's
//              SetSize implementation.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::SetSize(ULARGE_INTEGER cbNewSize)
{
    ULARGE_INTEGER cbSourceNewSize;
    HRESULT hr;
   
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);

    cbSourceNewSize.QuadPart = _pOrig->_ibStart.QuadPart + cbNewSize.QuadPart;
        
    hr = THR(_pStream->SetSize(cbSourceNewSize));
    if (hr)
        goto Cleanup;
        
    _pOrig->_ibEnd.QuadPart = cbSourceNewSize.QuadPart;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::CopyTo, IStream
//
//  Synopsis:   CopyTo wrapper, guards against reading beyond
//              the boundaries of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::CopyTo(IStream *pStream, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    ULARGE_INTEGER ibCur;
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur));
    if (hr)
        goto Cleanup;
        
    Assert(_pOrig->_ibEnd.QuadPart >= ibCur.QuadPart);

    if (cb.QuadPart > _pOrig->_ibEnd.QuadPart - ibCur.QuadPart)
        cb.QuadPart = _pOrig->_ibEnd.QuadPart - ibCur.QuadPart;

    hr = THR(_pStream->CopyTo(pStream, cb, pcbRead, pcbWritten));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Commit, IStream
//
//  Synopsis:   Commit wrapper.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Commit(DWORD dwFlags)
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);

    RRETURN(THR(_pStream->Commit(dwFlags)));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Revert, IStream
//
//  Synopsis:   Revert wrapper.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Revert()
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    if (!_pOrig->_fWritable)
        return(STG_E_ACCESSDENIED);

    RRETURN(THR(_pStream->Revert()));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::LockRegion, IStream
//
//  Synopsis:   LockRegion wrapper, guards against locking
//              beyond the boundary of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::LockRegion(ULARGE_INTEGER ibOffset, ULARGE_INTEGER cb, DWORD dwFlags)
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    ibOffset.QuadPart += _pOrig->_ibStart.QuadPart;
    
    if (ibOffset.QuadPart < _pOrig->_ibStart.QuadPart || ibOffset.QuadPart + cb.QuadPart > _pOrig->_ibEnd.QuadPart)
        return STG_E_ACCESSDENIED;

    RRETURN(_pStream->LockRegion(ibOffset, cb, dwFlags));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::UnlockRegion, IStream
//
//  Synopsis:   UnlockRegion wrapper, guards against unlocking
//              beyond the boundary of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::UnlockRegion(ULARGE_INTEGER ibOffset, ULARGE_INTEGER cb, DWORD dwFlags)
{
    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    ibOffset.QuadPart += _pOrig->_ibStart.QuadPart;
    
    if (ibOffset.QuadPart < _pOrig->_ibStart.QuadPart || ibOffset.QuadPart + cb.QuadPart > _pOrig->_ibEnd.QuadPart)
        return STG_E_ACCESSDENIED;

    RRETURN(_pStream->LockRegion(ibOffset, cb, dwFlags));
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Stat, IStream
//
//  Synopsis:   Stat wrapper, reports the size of the substream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Stat(STATSTG *pstatstg, DWORD dwFlags)
{
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    hr = THR(_pStream->Stat(pstatstg, dwFlags));
    if (hr)
        goto Cleanup;

    pstatstg->cbSize.QuadPart = _pOrig->_ibEnd.QuadPart - _pOrig->_ibStart.QuadPart;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSubstream::Clone, IStream
//
//  Synopsis:   Clone wrapper, creates a new instance of
//              CSubstream pointing to the same IStream.
//
//-------------------------------------------------------------------------
STDMETHODIMP CSubstream::Clone(IStream **ppStream)
{
    CSubstream *pSubstream;
    HRESULT hr;

    if (!_pOrig->_pStream)
        return(E_FAIL); // Detached

    pSubstream = new CSubstream();
    if (!pSubstream)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = THR(pSubstream->InitClone(this));
    if (hr)
        goto Cleanup;

    *ppStream = pSubstream;
    pSubstream = NULL;

Cleanup:
    ReleaseInterface(pSubstream);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\tearoff.cxx ===
//+------------------------------------------------------------------------
//
//  File:       toff.cxx
//
//  Contents:   Tear off interfaces.
//
//  History:
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

MtDefine(TearOff, PerProcess, "TearOff Thunk")
DeclareTag(tagNoTearoffCache, "Tearoff", "Disable tearoff cache")
DeclareTag(tagLeakTearoffs, "Tearoff", "Leak all tearoffs on purpose")
DeclareTag(tagZapTearoffs, "Tearoff", "Zap contents of tearoffs on release")
DeclareTag(tagTearoffSymbols, "!Memory", "Leaks: Stacktraces and Symbols for Tearoffs")

typedef HRESULT (FNQI)(void *pv, REFIID iid, void **ppv);
typedef ULONG   (FNAR)(void *pv);

#if defined(_M_IX86) && !defined(_MAC)

#define THUNK_IMPLEMENT_COMPARE(n)\
void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n()\
{                                           \
    /* this = thisArg                   */  \
    __asm mov eax, [esp + 4]                \
    /* save original this               */  \
    __asm push eax                          \
    /*  if this->_dwMask & 1 << n       */  \
    __asm test dword ptr [eax + 28], 1<<n   \
    /* jmp if < to Else */                  \
    __asm je $+9                            \
    /* increment offset to pvObject2    */  \
    __asm add eax, 8                        \
    /* increment offset to pvObject1    */  \
    __asm add eax, 12                       \
    /* pvObject = this->_pvObject       */  \
    __asm mov ecx, [eax]                    \
    /* thisArg = pvObject2              */  \
    __asm mov [esp + 8], ecx                \
    /* apfnObject = this->_apfnVtblObj  */  \
    __asm mov ecx, [eax + 4]                \
    /* pfn = apfnObject[n]              */  \
    __asm mov ecx, [ecx + (4 * n)]          \
    /* set eax back to the tearoff      */  \
    __asm pop eax                           \
    /* remember vtbl index of method    */  \
    __asm mov dword ptr [eax + 32], n       \
    /* jump....                         */  \
    __asm jmp ecx                           \
}

#define THUNK_IMPLEMENT_SIMPLE(n)\
void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n()\
{                                           \
    /* this = thisArg                   */  \
    __asm mov eax, [esp + 4]                \
    /* remember vtbl index of method    */  \
    __asm mov dword ptr [eax + 32], n       \
    /* pvObject = this->_pvObject       */  \
    __asm mov ecx, [eax + 12]               \
    /* thisArg = pvObject               */  \
    __asm mov [esp + 4], ecx                \
    /* apfnObject = this->_apfnVtblObj  */  \
    __asm mov ecx, [eax + 16]               \
    /* pfn = apfnObject[n]              */  \
    __asm mov ecx, [ecx + (4 * n)]          \
    /* jump....                         */  \
    __asm jmp ecx                           \
}

// Single step a few times for the function you are calling.

THUNK_ARRAY_3_TO_15(IMPLEMENT_COMPARE);
THUNK_ARRAY_16_AND_UP(IMPLEMENT_SIMPLE);

#elif defined(_MAC)

#define offsetof_pvObject    12      // Keep in sync w/ TOFF.CXX
#define offsetof_apfn        16
#define offsetof_Mask        28

//* ON ENTRY
//*
//*      r3  - this
//*      The stack frame is of the original caller.
//*
//* REGISTER USAGE
//*
//*      r11 - temp
//*
//* ON EXIT
//*
//*      r3 - this
//*      r12 - The transition vector address (thunk function being called)
//*      r31 - address of thunk

#define THUNK_IMPLEMENT_COMPARE(n)\
asm void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n()\
{                                           \
       stw     r3,-4(SP);                /* save this pointer on stack */ \
       li      r12, 1;                  /* load 1 into r12, and... */\
       slwi    r12, r12, n;             /* ...shift left by the index */\
       lwz     r11, offsetof_Mask(r3);  /* load mask dword into r11 */\
       and     r11, r11, r12;           \
       cmpli   cr1, 0, r11, 0;            /* compare */\
       li      r12, n;                  /* Put the method # in r12 */\
       stw     r12, 32(r3);             /* save method # in thunk */ \
       bc      12, 6, Obj;          \
       addi    r3, r3, 8;               /* add for object 1 */\
Obj:   addi    r3, r3, 12;             /* add offset */\
                        /* r3 is now the pvObject ptr, i.e. the intermediate 'this' ptr */\
       lwz     r11, 0x4(r3);            /* Copy this->apfn to r11 */\
       lwz     r3,0(r3);                    /* set r3 to object pointer */\
       lwz     r0,0(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,tear;                /* bne - tearoff non virtual */\
       lwz     r0,8(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,realvt;                /* bne - c++ vtable */\
tear:  li      r12, (n*12);             /* Put the method # * 12 in r12 */\
       add     r12,r12,r11  ;                   /* r12 points to correct tearoff vtbl entry */\
       lwz     r11,4(r12);                  /* get vtbl offset / flag */\
       lwz     r12,8(r12);                  /* get address in non virtual */\
       cmpi    crf0,0,r11,0;                    /* check if virtual */\
       bc      12, 0, Non;                      /* branch if not virtual */\
       lwz     r12,0(r3);               \
       lwzx    r12,r12,r11;                 /* get function vector address */\
Non:   lwz     r0,0(r12);                   /* get function address */\
       mtctr   r0;  \
       lwz     r2,4(r12);                   /* load new toc */ \
       lwz     r11,-4(SP);              /* restore this pointer */\
       bctr;                            /* branch to counter */\
realvt: li     r12,(n*4+4);             /* offset into c++ vtable */\
       lwzx    r12,r11,r12;              /* get vtable entry */\
       b       Non;                     \
}

/*
Checking for type of vtable works as follows
long               0      2
_______________________________
tearoff virtual    0      0
tearoff non virt   -1     non 0
c++ vtable         0      non 0
*/

#define THUNK_IMPLEMENT_SIMPLE(n)\
asm void __declspec(naked) STDMETHODCALLTYPE TearoffThunk##n() \
{                                                \
       li      r12, n;         /* Put the method # in r12 */    \
       stw     r12, 32(r3);    /* save method # in thunk */ \
       stw     r3,-4(SP);                /* save this pointer on stack */ \
       lwz     r11, offsetof_apfn(r3);      /* Copy this->apfn to r11 */\
       lwz     r3,offsetof_pvObject(r3);                    /* set r3 to object pointer */\
       lwz     r0,0(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,tear;                /* bne - tearoff non virtual */\
       lwz     r0,8(r11);                  /* get first vtable entry */\
       cmpi    crf0,0,r0,0;                 /* check for c++ vtable */\
       bc      4,2,realvt;                /* bne - c++ vtable */\
tear:  li      r12, (n*12);             /* Put the method # * 12 in r12 */\
       add     r12,r12,r11  ;                   /* r12 points to correct tearoff vtbl entry */\
       lwz     r11,4(r12);                  /* get vtbl offset / flag */\
       lwz     r12,8(r12);                  /* get address in non virtual */\
       cmpi    crf0,0,r11,0;                    /* check if virtual */\
       bc      12, 0, Non;                      /* branch if not virtual */\
       lwz     r12,0(r3);               \
       lwzx    r12,r12,r11;                 /* get function vector address */\
Non:   lwz     r0,0(r12);                   /* get function address */\
       mtctr   r0;  \
       lwz     r2,4(r12);                   /* load new toc */ \
       lwz     r11,-4(SP);              /* restore this pointer */\
       bctr;                                /* branch to counter */\
realvt: li     r12,(n*4+4);             /* offset into c++ vtable */\
       lwzx    r12,r11,r12;              /* get vtable entry */\
       b       Non;                     \
}

#pragma require_prototypes off

THUNK_ARRAY_3_TO_15(IMPLEMENT_COMPARE);
THUNK_ARRAY_16_TO_101(IMPLEMENT_SIMPLE);
THUNK_ARRAY_102_TO_145(IMPLEMENT_SIMPLE);
THUNK_ARRAY_146_AND_UP(IMPLEMENT_SIMPLE);

#pragma require_prototypes reset
asm TEAROFF_THUNK* GetThunk()
{
    addi    r3,r11,0        // return the saved thunk pointer
    blr
}


#endif

#ifdef WIN16
void TearoffCheck()
#else
void STDMETHODCALLTYPE TearoffCheck()
#endif
{
    AssertSz( 0, "Tearoff table too small" );
}

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv)
{
    void *pv;
    const void *apfnVtbl;
    IID const * const * ppIID;

    for (ppIID = pthunk->apIID; *ppIID; ppIID++)
    {
        if (**ppIID == iid)
        {
            *ppv = pthunk;
            pthunk->ulRef += 1;
            return S_OK;
        }
    }

    if (pthunk->dwMask & 1)
    {
        pv = pthunk->pvObject2;
        apfnVtbl = pthunk->apfnVtblObject2;
    }
    else
    {
        pv = pthunk->pvObject1;
        apfnVtbl = pthunk->apfnVtblObject1;
    }

#ifdef _MAC
	typedef HRESULT ( IUnknown::*const tFunc)(REFIID iid, void **ppv) ;
	

	if(((long*)apfnVtbl)[0] || (((long*)apfnVtbl)[2] == 0))
	{
		tFunc	qi = ((tFunc*)apfnVtbl)[0];
		
	    return (((IUnknown*)pv)->*qi)(iid, ppv);
	}
	else
    	return ((FNQI *)((void **)apfnVtbl)[1])(pv, iid, ppv);
	
#else
    return ((FNQI *)((void **)apfnVtbl)[0])(pv, iid, ppv);
#endif // _MAC
}


ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk)
{
    if (pthunk->dwMask & CACHEDTEAROFF_MASK)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & 2) == 0)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject1)[1])(pthunk->pvObject1);
        }
        if (pthunk->pvObject2)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject2)[1])(pthunk->pvObject2);
        }
    }
    return ++pthunk->ulRef;
}

static void * s_pvCache1 = NULL;
static void * s_pvCache2 = NULL;

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk)
{
    WHEN_DBG(static long l = 0; l++;)

    Assert( pthunk->ulRef > 0 );

    if (--pthunk->ulRef == 0)
    {
#ifdef _MAC    
	    void *pv;
        const void *apfnVtbl;
    
	    if (pthunk->dwMask & 4)
	    {
	        pv = pthunk->pvObject2;
     	    apfnVtbl = pthunk->apfnVtblObject2;
	    }
	    else
	    {
	        pv = pthunk->pvObject1;
  	        apfnVtbl = pthunk->apfnVtblObject1;
	    }

		typedef unsigned long ( IUnknown::*const tFunc)(void) ;
		
		// if no null entry, vtable is tearoff
		if(((long*)apfnVtbl)[0] || (((long*)apfnVtbl)[2] == 0))
		{
			tFunc	rel = ((tFunc*)apfnVtbl)[2];
			
	    	return (((IUnknown*)pv)->*rel)();
		}
		else	// must be c++ vtable
            ((FNAR *)((void **)apfnVtbl)[3])(pv);
	    	
#else
        if (!(pthunk->dwMask & CACHEDTEAROFF_MASK))
        {
            if (pthunk->pvObject1 && (pthunk->dwMask & 4) == 0)
            {
                ((FNAR *)((void **)pthunk->apfnVtblObject1)[2])(pthunk->pvObject1);
            }
            if (pthunk->pvObject2)
            {
                ((FNAR *)((void **)pthunk->apfnVtblObject2)[2])(pthunk->pvObject2);
            }
        }
#endif

#if DBG==1
        if (IsTagEnabled(tagNoTearoffCache) || IsTagEnabled(tagTearoffSymbols))
        {
            MemFree(pthunk);
            return(0);
        }
        else
        {
            if (IsTagEnabled(tagZapTearoffs))
            {
                memset(pthunk, 0xFE, sizeof(TEAROFF_THUNK));
            }

            if (IsTagEnabled(tagLeakTearoffs))
            {
                return(0);
            }
        }
#endif

#ifdef SLOWALLOC
        MemFree(pthunk);
        return (0);
#else

        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, pthunk );

        if (pthunk)
        {
            pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, pthunk );

            if (pthunk)
            {
                MemFree( pthunk );
            }
        }

        return 0;
#endif
    }
    else if (pthunk->dwMask & CACHEDTEAROFF_MASK)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & 4) == 0)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject1)[2])(pthunk->pvObject1);
        }
        if (pthunk->pvObject2)
        {
            ((FNAR *)((void **)pthunk->apfnVtblObject2)[2])(pthunk->pvObject2);
        }
    }

    return pthunk->ulRef;
}

typedef void (STDMETHODCALLTYPE *PFNVOID)();

#if defined(_M_IX86)
#define THUNK_EXTERN(n) extern void STDMETHODCALLTYPE TearoffThunk##n();
#else
#define THUNK_EXTERN(n) EXTERN_C void TearoffThunk##n();
#endif

THUNK_ARRAY_3_TO_15(EXTERN)
#ifdef _MAC
THUNK_ARRAY_16_TO_101(EXTERN)
THUNK_ARRAY_102_TO_145(EXTERN)
THUNK_ARRAY_146_AND_UP(EXTERN)
#else
THUNK_ARRAY_16_AND_UP(EXTERN)
#endif // _MAC

#define THUNK_ADDRESS(n) & TearoffThunk##n,

static void (STDMETHODCALLTYPE *s_apfnPlainTearoffVtable[])() =
{
#ifdef _MAC
    PFNVOID( NULL ),
#endif
    PFNVOID( & PlainQueryInterface ),
    PFNVOID( & PlainAddRef ),
    PFNVOID( & PlainRelease ),
    THUNK_ARRAY_3_TO_15(ADDRESS)
#ifdef _MAC
    THUNK_ARRAY_16_TO_101(ADDRESS)
    THUNK_ARRAY_102_TO_145(ADDRESS)
    THUNK_ARRAY_146_AND_UP(ADDRESS)
#else
    THUNK_ARRAY_16_AND_UP(ADDRESS)
#endif
#if DBG==1
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck,  &TearoffCheck, \
    &TearoffCheck,  &TearoffCheck,  &TearoffCheck
#endif
};

void DeinitTearOffCache()
{
    MemFree(s_pvCache1);
    MemFree(s_pvCache2);
}


//+------------------------------------------------------------------------
//
//  Function:   CreateTearOffThunk
//
//  Synopsis:   Create a tearoff interface thunk. The returned object
//              must be AddRef'ed by the caller.
//
//  Arguments:  pvObject    Delegate to this object using...
//              apfnObject    ...this array of pointers to member functions.
//              pUnkOuter   Delegate IUnknown methods to this object.
//              ppvThunk    The returned thunk.
//              pvObject2   Delegate to this object instead...
//              apfnObject2   ... this array of pointers to functions...
//              dwMask        ... when the index of the method call is
//                            marked in this mask.
//
//  Notes:      The basic implementation here consists of a thunk with
//              a pointer to two different objects.  If the second object
//              is NULL, it is assumed to be the first object.  This
//              is the logic of the thunks:
//
//                  i is the index of the method that is called.
//
//                  if (i < 16)
//                  {
//                      if (dwMask & 2^i)
//                      {
//                          Delegate to pvObject2 using apfnObject2
//                      }
//                  }
//                  Delegate to pvObject1 using apfnObject1
//
//-------------------------------------------------------------------------

#ifdef DEBUG_TEAROFFS
BOOL g_fDoneTearoffCompression = FALSE;
DEBUG_TEAROFF_NOTE *g_pnoteFirst = NULL;
#endif

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      pvObject2,
        void *      apfn2,
        DWORD       dwMask,
        const IID * const * apIID,
        void *      appropdescsInVtblOrder)
{
    TEAROFF_THUNK * pthunk;

    Assert(ppvThunk);
    Assert(apfn1);
    Assert((!pvObject2 && !apfn2) || (pvObject2 && apfn2));
    Assert(!(dwMask & 0xFFFE0000) && "Only 16 overrides and CACHEDTEAROFF_MASK allowed");
    Assert(!dwMask || (dwMask && pvObject2));
    Assert(!pUnkOuter || (dwMask == 0 && pvObject2 == 0));
    Assert((dwMask & (2|4)) == 0 || (dwMask & (2|4)) == (2|4));

#ifdef DEBUG_TEAROFFS
    Assert(g_fDoneTearoffCompression);
    Assert(((DWORD**)apfn1)[1] && "Tearoff compression not yet done!");
    Assert(!apfn2 || ((DWORD**)apfn2)[1] && "Tearoff compression not yet done!");
#endif

    if (pUnkOuter)
    {
        pvObject2 = pUnkOuter;
        apfn2 = *(void **)pUnkOuter;
        dwMask = 1;
    }

    pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, NULL);

    if (!pthunk)
    {
        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, NULL);

        if (!pthunk)
        {
#if DBG==1
            #define LEAKS_TRACE_TAG "Leaks: Stacktraces & symbols"
            AssertSz(DbgExFindTag(LEAKS_TRACE_TAG), "Please update the LEAKS_TRACE_TAG definition"); 
            BOOL fEnabled = FALSE;
            if (IsTagEnabled(tagTearoffSymbols))
            {
                fEnabled = DbgExEnableTag(DbgExFindTag(LEAKS_TRACE_TAG), TRUE);
            }
#endif

            pthunk = (TEAROFF_THUNK *) MemAlloc(Mt(TearOff), sizeof(TEAROFF_THUNK));

            MemSetName((pthunk, "Tear-Off Thunk - owner=%08x", pvObject1));

#if DBG==1
            if (IsTagEnabled(tagTearoffSymbols))
            {
                DbgExEnableTag(DbgExFindTag(LEAKS_TRACE_TAG), fEnabled);
            }
#endif

        }
    }

    if (!pthunk)
    {
        *ppvThunk = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    pthunk->papfnVtblThis = s_apfnPlainTearoffVtable;
    pthunk->ulRef = 0;
    pthunk->pvObject1 = pvObject1;
    pthunk->apfnVtblObject1 = apfn1;
    pthunk->pvObject2 = pvObject2;
    pthunk->apfnVtblObject2 = apfn2;
    pthunk->dwMask = dwMask;
    pthunk->apIID = apIID ? apIID : (const IID * const *)&g_Zero;
    pthunk->apVtblPropDesc = appropdescsInVtblOrder;

#ifdef _MAC
	((IUnknown*)pthunk)->AddRef();
#else
    if (dwMask & CACHEDTEAROFF_MASK)
    {
        pthunk->ulRef++;
    }
    else
    {
        if (pvObject1 && (dwMask & 2) == 0)
        {
            Assert(((void**)apfn1)[1]);

            ((FNAR *)((void**)apfn1)[1])(pvObject1);
        }
        if (pvObject2)
        {
            Assert(((void**)apfn2)[1]);

            ((FNAR *)((void**)apfn2)[1])(pvObject2);
        }
    }
#endif // _MAC
    *ppvThunk = pthunk;

    return S_OK;
}

// Short argument list version saves space in calling functions.

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      appropdescsInVtblOrder)
{
    return CreateTearOffThunk(
            pvObject1, 
            apfn1, 
            pUnkOuter, 
            ppvThunk, 
            NULL, 
            NULL, 
            0, 
            NULL,
            appropdescsInVtblOrder);
}

HRESULT
InstallTearOffObject(void * pvthunk, void * pvObject, void *apfn, DWORD dwMask)
{
    TEAROFF_THUNK *pthunk = (TEAROFF_THUNK*)pvthunk;

    Assert(pthunk);
    Assert(!pthunk->pvObject2);
    Assert(!pthunk->apfnVtblObject2);
    Assert(!pthunk->dwMask);

    pthunk->pvObject2 = pvObject;
    pthunk->apfnVtblObject2 = apfn;
    pthunk->dwMask = dwMask;

    if (pvObject)
    {
        ((FNAR *)((void**)apfn)[1])(pvObject);
    }

    return S_OK;
}


#ifdef DEBUG_TEAROFFS

//+------------------------------------------------------------------------
//
// DEBUG_TEAROFFs check for multiple inheritance problems with tearoffs.
//
// With multiple inheritance with MSVC on Win32/X86 the calling
// convention for a virtual function in vtable X is to adjust the
// "this" pointer to point to offset in the object containing the
// pointer to vtable X before doing the call. Since the offset is
// needed to make the call correctly, a pointer to a method of a
// class with virtual methods and multiple inheritance is stored
// as two DWORDs: the first is the function pointer for the method,
// and the second is the offset to apply to the "this" pointer.
//
// Tearoffs tables are a table of ordinary function pointers to
// methods. The function pointers are obtained from full method
// pointers using a cast that truncates a possible 8-byte value
// to its first 4 bytes.
//
// Since any information about the "this" offset is lost when casting
// a method pointer down to a single-DWORD function pointer, tearoffs
// assume that the adjustment to "this" is zero. This means that
// tearoffs cannot refer to virtual methods which appear in multiple-
// inheritance vtables; only nonvirtual methods and methods in the
// primary vtable work.
//
// The DEBUG_TEAROFFS code verifies that multiple-inheritance problems
// do not occur by construcing actual 8-byte method pointers for every
// tearoff method and asserting that the second DWORD (the "this"
// offset) is zero.  While the check is being done, the table is
// compressed down to a table of 4-byte function pointers as required
// by the rest of the tearoff code.
//
//-------------------------------------------------------------------------


// Note: The check must be deferred until ProcessAttach time because at
// VC Runtime init time, method pointers are not initialized yet and
// cannot be read.

int DeferDebugCheckTearoffTable(DEBUG_TEAROFF_NOTE *pnote, void *apfn, char *string)
{
    pnote->pnoteNext = g_pnoteFirst;
    g_pnoteFirst = pnote;
    pnote->apfn = apfn;
    pnote->pchDebug = string;

    return 1;
}

void DebugCheckAllTearoffTables()
{
    Assert(!g_fDoneTearoffCompression);

    DEBUG_TEAROFF_NOTE *pnote;

    DEBUG_TEAROFF_METHOD<CVoid> *pfnFrom;
    DWORD *pfnTo;
    
    for (pnote=g_pnoteFirst; pnote; pnote=pnote->pnoteNext)
    {
        pfnFrom = (DEBUG_TEAROFF_METHOD<CVoid>*)(pnote->apfn);
        pfnTo = (DWORD*)pnote->apfn;

        while (pfnFrom->d.fn)
        {
            AssertSz(!pfnFrom->d.off, pnote->pchDebug);
            *pfnTo = pfnFrom->d.fn;
            pfnFrom++;
            pfnTo++;
        }
    }
    
    g_fDoneTearoffCompression = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\themehlp.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       Themehlp.cxx
//
//  Contents:   Theme helper
//
//  Classes:    CThemeHelper
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_UXTHEME_H
#undef _UXTHEME_
#define _UXTHEME_
#define X_UXTHEME_H
#include "uxtheme.h"
#endif

#ifndef X_CDUTIL_HXX
#define X_CDUTIL_HXX
#include "cdutil.hxx"
#endif

#ifndef X_THEMEHLP_HXX
#define X_THEMEHLP_HXX
#include "themehlp.hxx"
#endif

DeclareTag(tagTheme, "Theme", "Theme helper methods");

#define ARRAYSIZE(a) ( sizeof(a) / sizeof(a[0]) )

HANDLE      g_hActCtx = INVALID_HANDLE_VALUE;
HINSTANCE   g_hinstCC = NULL;
extern BOOL g_fThemedPlatform;
struct THEMEINFO
{
    TCHAR * pchName;
    BOOL    fInit;
    HTHEME  hTheme;
};

static THEMEINFO g_aryThemeInfo[] =
{
    {_T("button"),              FALSE, NULL},
    {_T("edit"),                FALSE, NULL},
    {_T("scrollbar"),           FALSE, NULL},
    {_T("combobox"),            FALSE, NULL},
};

// The following functions are ported from shfusion.lib
// They help us load comctl32 version 6 so we theme
// things correctly.


//+------------------------------------------------------------------------
//
//  Function:   SHActivateContext
//
//  Synopsis:   Shell helper function: activates fusion context
//
//-------------------------------------------------------------------------

BOOL SHActivateContext(ULONG_PTR * pdwCookie)
{
    if (g_hActCtx != INVALID_HANDLE_VALUE)
        return ActivateActCtx(g_hActCtx, pdwCookie);

    return TRUE;        // Default to success in activation for down level.
}

//+------------------------------------------------------------------------
//
//  Function:   SHDeactivateContext
//
//  Synopsis:   Shell helper function: deactivates fusion context
//
//-------------------------------------------------------------------------

void SHDeactivateContext(ULONG_PTR dwCookie)
{
    if (dwCookie != 0)
        DeactivateActCtx(0, dwCookie);
}

//+------------------------------------------------------------------------
//
//  Function:   SHFusionLoadLibrary
//
//  Synopsis:   Shell helper function: loads the appropriate version of a 
//              the library as determined by g_hActCtx
//
//-------------------------------------------------------------------------

HMODULE SHFusionLoadLibrary(LPCTSTR lpLibFileName)
{
    HMODULE hmod = NULL;
    ENTERCONTEXT(NULL)
    hmod = LoadLibrary(lpLibFileName);
    LEAVECONTEXT

    return hmod;
}

//+------------------------------------------------------------------------
//
//  Function:   DelayLoadCC
//
//  Synopsis:   Shell helper function: Loads appropriate common controls
//
//-------------------------------------------------------------------------

BOOL DelayLoadCC()
{
    if (g_hinstCC == NULL)
    {
        g_hinstCC = SHFusionLoadLibrary(TEXT("comctl32.dll"));

        if (g_hinstCC == NULL)
        {
            SHFusionUninitialize();     // Unable to get v6, don't try to use a manifest
            g_hinstCC = LoadLibrary(TEXT("comctl32.dll"));
        }
    }
    return g_hinstCC != NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   SHFusionInitialize
//
//  Synopsis:   Shell helper function: activates fusioned common controls
//              if they're available
//
//-------------------------------------------------------------------------

BOOL SHFusionInitialize()
{
    
    if (g_hActCtx == INVALID_HANDLE_VALUE)
    {
        TCHAR szPath[MAX_PATH];

        if ( !Wrap_GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath)) )
        {
            return FALSE;
        }

        //GetSystemWindowsDirectory(szPath, ARRAYSIZE(szPath));
        //GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        //ensure there is enough space in the buffer 
        if (int(ARRAYSIZE(szPath))-lstrlen(szPath) <= lstrlen(TEXT("\\WindowsShell.manifest")))
        {
        	return FALSE;
        } 
        StrCat(szPath, TEXT("\\WindowsShell.manifest"));

        ACTCTX act;
        act.cbSize = sizeof(act);
        act.dwFlags = 0;
        act.lpSource = szPath;

        g_hActCtx = CreateActCtx(&act);
    }


#ifndef NOCOMCTL32
    DelayLoadCC();
#endif

    return g_hActCtx != INVALID_HANDLE_VALUE;
    
    //return FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   SHFusionUninitialize
//
//  Synopsis:   Shell helper function: releases the context created for use 
//              with fusioned common controls
//
//-------------------------------------------------------------------------

void SHFusionUninitialize()
{
    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        ReleaseActCtx(g_hActCtx);
        g_hActCtx = INVALID_HANDLE_VALUE;
    }
}



//+------------------------------------------------------------------------
//
//  Function:   GetThemeHandle
//
//  Synopsis:   Get Theme handle using its class id
//              If the Theme is not in cach, create the theme
//
//-------------------------------------------------------------------------

HTHEME
GetThemeHandle(HWND hwnd, THEMECLASSID id)
{
    DWORD  dwFlags = 0;

    if (id < THEME_FIRST || id > THEME_LAST)
        return NULL;

    if (g_aryThemeInfo[id].fInit)
        return g_aryThemeInfo[id].hTheme;
    
    if (id != THEME_SCROLLBAR)
        dwFlags |= OTD_FORCE_RECT_SIZING;

    g_aryThemeInfo[id].hTheme = OpenThemeDataEx(hwnd, g_aryThemeInfo[id].pchName, dwFlags);
    g_aryThemeInfo[id].fInit = TRUE;

    return g_aryThemeInfo[id].hTheme;
}

//+---------------------------------------------------------------
//
//  Member:     DeinitTheme
//
//  Synopsis:   Deinit Theme.
//
//---------------------------------------------------------------

void
DeinitTheme()
{
    int i;

    if (g_fThemedPlatform)
        SHFusionUninitialize();

    for (i = THEME_FIRST; i <= THEME_LAST; i++)
    {
        if (g_aryThemeInfo[i].hTheme)
        {
            IGNORE_HR(CloseThemeData(g_aryThemeInfo[i].hTheme));                   
        }
        g_aryThemeInfo[i].hTheme = NULL;
        g_aryThemeInfo[i].fInit = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\tearunix.cxx ===
//+------------------------------------------------------------------------
//
//  File:       utearoff.cxx
//
//  Contents:   Tear off interfaces.
//
//  History:
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

typedef HRESULT (FNQI)(void *pv, REFIID iid, void **ppv);
typedef ULONG   (FNAR)(void *pv);

void TearoffCheck()
{
    AssertSz( 0, "Tearoff table too small" );
}

typedef HRESULT (STDMETHODCALLTYPE *PFNQI)(TEAROFF_THIS, REFIID, void **);

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv);

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk);

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk);

typedef void (*PFNVOID)();

#define THUNK_EXTERN(n) EXTERN_C void TearoffThunk##n(TEAROFF_THIS, ...);

THUNK_EXTERN(0) // QI
THUNK_EXTERN(1) // ADDREF
THUNK_EXTERN(2) // RELEASE

THUNK_ARRAY_3_TO_15(EXTERN)
THUNK_ARRAY_16_AND_UP(EXTERN)

#define TEAROFFCHECK_THUNK NONVIRTUAL_METHOD(TearoffCheck, (TEAROFF_THIS))
#define THUNK_ADDRESS(n) NONVIRTUAL_METHOD(TearoffThunk##n, (TEAROFF_THIS))

NONVIRTUAL_VTABLE_ENTRY s_unixTearOffVtable[] = {
    NULL_METHOD,
    THUNK_ADDRESS(0)
    NONVIRTUAL_METHOD(PlainAddRef, (TEAROFF_THIS))
    NONVIRTUAL_METHOD(PlainRelease, (TEAROFF_THIS))
    THUNK_ARRAY_3_TO_15(ADDRESS)
    THUNK_ARRAY_16_AND_UP(ADDRESS)
#if DBG==1
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK
#endif
};

static void * s_pvCache1 = NULL;
static void * s_pvCache2 = NULL;

void DeinitTearOffCache()
{
    MemFree(s_pvCache1);
    MemFree(s_pvCache2);
}

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk)
{
    return ++pthunk->ulRef;
}

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk)
{
    WHEN_DBG(static long l = 0; l++;)

    Assert( pthunk->ulRef > 0 );

    if (--pthunk->ulRef == 0)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & METHOD_MASK( METHOD_RELEASE )) == 0)
        {
            CALL_VTBL_METHOD( pthunk->pvObject1, pthunk->apfnVtblObject1, 2 /*METHOD_RELEASE*/, (CALL_METHOD_THIS));
        }
        if (pthunk->pvObject2)
        {
            CALL_VTBL_METHOD( pthunk->pvObject2, pthunk->apfnVtblObject2, 2 /*METHOD_RELEASE*/, (CALL_METHOD_THIS));
        }

        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, pthunk );

        if (pthunk)
        {
            pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, pthunk );

            if (pthunk)
            {
                MemFree( pthunk );
            }
        }

        return 0;
    }

    return pthunk->ulRef;
}


//+------------------------------------------------------------------------
//
//  Function:   CreateTearOffTunk
//
//  Synopsis:   Create a tearoff interface thunk. The returned object
//              must be AddRef'ed by the caller.
//
//  Arguments:  pvObject    Delegate to this object using...
//              apfnObject    ...this array of pointers to member functions.
//              pUnkOuter   Delegate IUnknown methods to this object.
//              ppvThunk    The returned thunk.
//              pvObject2   Delegate to this object instead...
//              apfnObject2   ... this array of pointers to functions...
//              dwMask        ... when the index of the method call is
//                            marked in this mask.
//
//  Notes:      The basic implementation here consists of a thunk with
//              a pointer to two different objects.  If the second object
//              is NULL, it is assumed to be the first object.  This
//              is the logic of the thunks:
//
//                  i is the index of the method that is called.
//
//                  if (i < 16)
//                  {
//                      if (dwMask & 2^i)
//                      {
//                          Delegate to pvObject2 using apfnObject2
//                      }
//                  }
//                  Delegate to pvObject1 using apfnObject1
//
//-------------------------------------------------------------------------

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void *apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      pvObject2,
        void *      apfn2,
        DWORD       dwMask,
        const IID * const * apIID)
{
#   define ADD_REL_MASK (METHOD_MASK( METHOD_ADDREF ) || METHOD_MASK( METHOD_RELEASE ))

    TEAROFF_THUNK * pthunk;

    Assert(ppvThunk);
    Assert(apfn1);
    Assert((!pvObject2 && !apfn2) || (pvObject2 && apfn2));
    Assert(!(dwMask & 0xFFFF0000) && "Only 16 overrides allowed");
    Assert(!dwMask || (dwMask && pvObject2));
    Assert(!pUnkOuter || (dwMask == 0 && pvObject2 == 0));
    Assert((dwMask & ADD_REL_MASK) == 0 || ((dwMask & ADD_REL_MASK) == ADD_REL_MASK));

    if (pUnkOuter)
    {
        pvObject2 = pUnkOuter;
        apfn2 = *(void **)pUnkOuter;
        dwMask = METHOD_MASK( METHOD_QI );
    }

    pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, NULL);

    if (!pthunk)
    {
        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, NULL);

        if (!pthunk)
        {
            pthunk = (TEAROFF_THUNK *) MemAlloc(sizeof(TEAROFF_THUNK));

            MemSetName((pthunk, "Tear-Off Thunk - owner=%08x", pvObject1));
        }
    }

    if (!pthunk)
    {
        *ppvThunk = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    pthunk->papfnVtblThis = s_unixTearOffVtable;
    pthunk->ulRef = 0;
    pthunk->pvObject1 = pvObject1;
    pthunk->apfnVtblObject1 = apfn1;
    pthunk->pvObject2 = pvObject2;
    pthunk->apfnVtblObject2 = apfn2;
    pthunk->dwMask = dwMask;
    pthunk->apIID = apIID ? apIID : (const IID * const *)&g_Zero;

    if (pvObject1 && (dwMask & METHOD_MASK( METHOD_ADDREF )) == 0)
    {
        CALL_VTBL_METHOD( pthunk->pvObject1, pthunk->apfnVtblObject1, 1 /*METHOD_ADDREF*/, (CALL_METHOD_THIS));
    }
    if (pvObject2)
    {
        CALL_VTBL_METHOD( pthunk->pvObject2, pthunk->apfnVtblObject2, 1 /*METHOD_ADDREF*/, (CALL_METHOD_THIS));
    }
    *ppvThunk = pthunk;

    return S_OK;
}

// Short argument list version saves space in calling functions.

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk)
{
    return CreateTearOffThunk(
            pvObject1, 
            apfn1, 
            pUnkOuter, 
            ppvThunk, 
            NULL, 
            NULL, 
            0, 
            NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\timer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       Timer.cxx
//
//  Contents:   Class implementation for CTimerMan, CTimer,
//              and CTimerSink, which support non-Windows based timers
//              for better service and granularity.
//              Timer runs on separate thread, posting messages to main
//              window proc. Message is not WM_TIMER, however, so that
//              there won't be any delay in posting the message.
//              See Timers and Synchronization spec for details.
//
//  Created:    Dec. 5, 1996
//
//--------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TIMER_HXX_
#define X_TiMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

DeclareTag( tagExtTimer, "Timer trace", "Trace External Trident Timer" );
DeclareTag( tagExtTimerReentrant, "Timer reentrancy", "Test Timer code reentrancy" );
DeclareTag( tagExtTimerThrottle, "Timer Throttle", "Trace timer throttling" );

MtDefine(Timers, Mem, "Timer Manager")
MtDefine(CTimer, Timers, "CTimer")
MtDefine(CTimer_aryAdvises_pv, CTimer, "CTimer::_aryAdvises::_pv")
MtDefine(CTimerAdvise, Timers, "CTimerAdvise")
MtDefine(CTimerCtx, Timers, "CTimerCtx")
MtDefine(CTimerCtx_aryAdvises_pv, CTimerCtx, "CTimerCtx::_aryAdvises")
MtDefine(CTimerCtx_aryNamedTimers_pv, CTimerCtx, "CTimerCtx::_aryNamedTimers")
MtDefine(CTimerMan, Timers, "CTimerMan")
MtDefine(CTimerMan_aryTimerThreadAdvises_pv, CTimerMan, "CTimerMan::_aryTimerThreadAdvises::_pv")
MtDefine(CTimerSink, Timers, "CTimerSink")
MtDefine(CTimerSetRefTimer_arydw_pv, Locals, "CTimer::SetRefTimer arydw::_pv")

HRESULT VariantToTime(VARIANT *pvtime, DWORD *pdw)
{
    HRESULT hr = S_OK;

    Assert(pvtime);
    Assert(pdw);

    if (V_VT(pvtime) == VT_UI4)
    {
        *pdw = V_UI4(pvtime);
    }
    else
    {
        VARIANT vtimeOut;
        vtimeOut.vt = VT_EMPTY;
        hr = VariantChangeType(&vtimeOut, pvtime, 0, VT_UI4);
        if (SUCCEEDED(hr))
            *pdw = V_UI4(&vtimeOut);
    }
    RRETURN(hr);
}

#define DECLARE_VARIANT_INIT(name, dwInit)  \
    VARIANT name;           \
    VariantInit(&name);     \
    V_VT(&name) = VT_UI4;   \
    V_UI4(&name) = dwInit;

//+------------------------------------------------------------------------
//  Globals
//-------------------------------------------------------------------------

CGlobalCriticalSection    g_csTimerMan;
// CONSIDER: w/ g_pTimerMan, why have a _pTimerMan for each CTimerCtx?
CTimerMan          *g_pTimerMan = NULL;

HRESULT GetTimerManager( CTimerMan **ppTimerMan )
{
    HRESULT         hr = S_OK;

    USE_FAST_TASK_GLOBALS;

    // both writing and reading g_pTimerMan need to be in cs
    LOCK_SECTION(g_csTimerMan);

    if (FAST_TASK_GLOBAL(g_pTimerMan) == NULL)
    {
        FAST_TASK_GLOBAL(g_pTimerMan) = new CTimerMan;   // _ulRefs starts as 1

        if (FAST_TASK_GLOBAL(g_pTimerMan) == NULL)
            RRETURN(E_OUTOFMEMORY);

        hr = FAST_TASK_GLOBAL(g_pTimerMan)->Init();
        if (hr)
        {
            delete FAST_TASK_GLOBAL(g_pTimerMan);
            FAST_TASK_GLOBAL(g_pTimerMan) = NULL;
            goto Cleanup;
        }
    }
    else
    {
        FAST_TASK_GLOBAL(g_pTimerMan)->AddRef();
    }

    *ppTimerMan = FAST_TASK_GLOBAL(g_pTimerMan);

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   DeinitTimerCtx
//
//  Synopsis:   Delete Timer Context
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void
DeinitTimerCtx(THREADSTATE *pts)
{
    TraceTag((tagExtTimer, "DeinitTimerCtx"));
    Assert(pts);
    if ( pts->pTimerCtx )
    {
        pts->pTimerCtx->Release();
        pts->pTimerCtx = NULL;
    }
}

/******************************************************************************
                CTimerMan
******************************************************************************/

CTimerMan::CTimerMan()
    : CExecFT(_cs.GetPcs()), _aryTimerThreadAdvises(Mt(CTimerMan_aryTimerThreadAdvises_pv))
{
    Assert(!TASK_GLOBAL(g_pTimerMan));    // only one per process should exist
    _iFirstFree         = -1;
    _fIsLaunched        = FALSE;
    _fShutdown          = FALSE;
    _hevCheckAdvises    = NULL;
}

CTimerMan::~CTimerMan()
{
    TraceTag((tagExtTimer, "~CTimerMan"));
    TASK_GLOBAL(g_pTimerMan) = NULL;     // only one per process should exist
}


HRESULT
CTimerMan::Init()
{
    RRETURN(_cs.Init());
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation, with a twist. This object should
//              exist during the life time of the thread, but is also doled
//              out as a COM object. Therefore, pointers to the outside
//              world are ref counted, but not the internally used object,
//              which treats this as a regular class object (i.e. uses the
//              TLS macro to obtain object). This allows the secondary object
//              count to be correct during shutdown
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimerMan::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerService *)this, IUnknown)
        QI_INHERITS(this, ITimerService)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CreateTimer         [ITimerService]
//
//  Synopsis:   Creates a CTimer object
//
//  Arguments:  pReferenceTimer - Timer to base new timer off of. This is so
//                                the behavior of the new timer is effected
//                                by the reference timer. E.g., if reference
//                                timer is frozen, so will the new timer.
//                                Can be NULL, to use default timer.
//              ppNewTimer      - Returned timer.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_POINTER
//              E_INVALIDARG
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::CreateTimer( ITimer *pReferenceTimer, ITimer **ppNewTimer )
{
    CTimer *pTimer;
    HRESULT hr;

    TraceTag((tagExtTimer, "CTimerMan::CreateTimer"));

    if ( !ppNewTimer )
        RRETURN( E_POINTER );

    hr = THR(CreateCTimer( pReferenceTimer, &pTimer ));
    *ppNewTimer = (ITimer *)pTimer;
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     CreateCTimer
//
//  Synopsis:   Workshorse for CreateTimer and GetNamedTimer. 
//
//  Arguments:  pReferenceTimer - Timer to base new timer off of. This is so
//                                the behavior of the new timer is effected
//                                by the reference timer. E.g., if reference
//                                timer is frozen, so will the new timer.
//                                Can be NULL, to use default timer.
//              ppNewTimer      - Returned timer class object.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_POINTER
//              E_INVALIDARG
//
//  Note: Assumes that GetNamedTimer will call this with a NULL ref timer. 
//        Otherwise, CTimerCtx needs to be ensured regardless of RefTimer.
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::CreateCTimer( ITimer *pReferenceTimer, CTimer **ppNewTimer,
                         REFGUID rguidName )
{
    ITimer *pTmp = NULL;

    TraceTag((tagExtTimer, "CTimerMan::CreateCTimer"));
    Assert( ppNewTimer );

    *ppNewTimer = NULL;

    // make sure Timer is set up properly for this thread 
    // CTimerCtx handles all thread specific portions of the timer mgr
    THREADSTATE *pts = GetThreadState();
    if ( !pts->pTimerCtx )
    {
        pts->pTimerCtx = new CTimerCtx( this, _cs.GetPcs() );   // _ulRefs starts as 1
        if ( !pts->pTimerCtx )
            RRETURN( E_OUTOFMEMORY );
    }
    
    if ( pReferenceTimer )
    {
        pReferenceTimer->QueryInterface( IID_ITimer, (void **)&pTmp );
        if ( !pTmp )
            RRETURN( E_INVALIDARG );
        pTmp->Release();

        *ppNewTimer = new CTimer( pReferenceTimer, pts->pTimerCtx, _cs.GetPcs(), 
                                  rguidName );
    }
    else
    {
        *ppNewTimer = new CTimer( pts->pTimerCtx, pts->pTimerCtx, _cs.GetPcs(), 
                                  rguidName );
    }

	if ( NULL == *ppNewTimer )
        RRETURN( E_OUTOFMEMORY );

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     GetNamedTimer           [ITimerService]
//
//  Synopsis:   Returns a named timer. This enables several controls to obtain
//              the same timer without passing it back and forth among 
//              themselves. This allows easier synchronization among disparate
//              controls. Also, Trident will use a timer called "Draw" for
//              Trident painting, so controls can request that one if they
//              want to be synchronized with Trident's painting.
//
//  Arguments:  pszName         - Name of the timer to return. 
//              ppNewTimer      - Returned timer.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_POINTER
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::GetNamedTimer( REFGUID rguidName, ITimer **ppNewTimer)
{
    THREADSTATE        *pts = GetThreadState();
    CTimer             *pTimer = NULL;
    HRESULT             hr = S_OK;

    TraceTag((tagExtTimer, "CTimerMan::GetNamedTimer"));
    if ( !ppNewTimer )
        RRETURN( E_POINTER );

    if ( rguidName == GUID_NULL ) 
        RRETURN( E_INVALIDARG );

    EnterCriticalSection();

    *ppNewTimer = NULL;

    // check with current timers to see if we already have this one
    if ( pts->pTimerCtx )
    {
        hr = pts->pTimerCtx->GetNamedCTimer( rguidName, &pTimer );
        if ( SUCCEEDED(hr) )
        {
            *ppNewTimer = (ITimer *)pTimer;
            (*ppNewTimer)->AddRef();
            goto cleanup;
        }
    }

    // didn't find a timer by that name, so let's create a new one
    hr = THR(CreateCTimer( NULL, &pTimer, rguidName ));
    if ( FAILED(hr) )
        goto error;

    hr = THR(pts->pTimerCtx->AddNamedCTimer( rguidName, pTimer ));
    if ( FAILED(hr) )
        goto error;

    *ppNewTimer = (ITimer *)pTimer;

cleanup:
    LeaveCriticalSection();
    RRETURN(hr);
error:
    if ( pTimer )
        delete pTimer;
    goto cleanup;
}

//+----------------------------------------------------------------------------
//
//  Method:     SetNamedTimerReference      [ITimerService]
//
//  Synopsis:   Sets the reference timer for the named timer. All advises that
//              were on the existing reference timer for the named timer are
//              moved to the new reference timer.
//
//  Arguments:  pszName         - Name of the timer whose reference timer will 
//                                change
//              pTimer          - New reference timer
//
//  Returns:    S_OK
//              E_OUTOFMEMORY: either ran out of memory or hit the max
//                             allowed
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::SetNamedTimerReference( REFGUID rguidName, ITimer *pRefTimer )
{
    THREADSTATE        *pts = GetThreadState();
    CTimer             *pTimer = NULL;
    HRESULT             hr = S_OK;

    TraceTag((tagExtTimer, "CTimerMan::SetNamedTimerReference"));

    if ( !pts->pTimerCtx || 
         FAILED(pts->pTimerCtx->GetNamedCTimer( rguidName, &pTimer )) )
        RRETURN( E_INVALIDARG );

    if ( pTimer == pRefTimer )      // single-step circular ref check.
        RRETURN( E_INVALIDARG );    // Warning: does not check complete chain

    // avoid work if new ref timer is the same as existing ref timer.
    if ( pTimer->GetRefTimer() == pRefTimer || 
         (!pRefTimer && 
          pTimer->GetRefTimer() == static_cast<ITimer *>(pts->pTimerCtx)) )
        RRETURN( S_OK );

    if ( !pRefTimer )
        // reset to default ref clock
        pRefTimer = static_cast<ITimer *>(pts->pTimerCtx);

    // Get the timer to move its advises over
    hr = pTimer->SetRefTimer( pRefTimer );

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     AddAdvise
//
//  Synopsis:   Adds an advisement to the timer thread. Also sets cookie
//              to TimerAdvise passed in, using the array index.
//
//  Arguments:  pTimerAdvise - pointer of TimerAdvise to add
//              fRescheduling - TRUE if Adding the advise for next interval
//                              of a periodic advise
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::AddAdvise( CTimerAdvise *pTimerAdvise, CTimerCtx *pTimerCtx,
                      BOOL fRescheduling )
{
    HRESULT             hr = S_OK;
    PTIMERTHREADADVISE  pTTA;
    int                 index;

    Assert( pTimerAdvise && pTimerCtx );

    hr = EnsureTimerThread();
    if ( FAILED(hr) )
        goto error;

    EnterCriticalSection();
    TraceTag((tagExtTimer, "CTimerMan::AddAdvise %s", fRescheduling?"Rescheduling":" "));
    if ( fRescheduling )
    {
        // update advise
        DWORD index = pTimerAdvise->GetCookie()-1;      // convert back to index
        _aryTimerThreadAdvises[index].timeFire = pTimerAdvise->GetNextTick();
    }
    else
    {
        if ( _iFirstFree >= 0 )
        {
            // Free cells in the array point to the next free cell to use with
            // their NextFree element. -1 indicate there are no more free cells
            // within the array. A free cell is one which causes a discontinuity
            // between the first array element and the last one in use, i.e., the
            // tail end of the part of the array being used is not considered a
            // free cell. It is considered virgin array space to be appended onto.
            // _iFirstFree points to the first free cell in the list
            index = _iFirstFree;
            pTTA = &_aryTimerThreadAdvises[index];
            _iFirstFree = pTTA->NextFree;
        }
        else
        {
            index = _aryTimerThreadAdvises.Size();
            hr = THR(_aryTimerThreadAdvises.AppendIndirect(NULL, &pTTA));
        }

        if ( SUCCEEDED(hr) )
        {
            pTTA->timeFire = pTimerAdvise->GetNextTick();
            pTTA->timeExpire = pTimerAdvise->GetTimeMax();
            pTTA->NextFree = -1;
            pTTA->fIsFree = FALSE;
            pTTA->pTimerCtx = pTimerCtx;
            pTimerAdvise->SetCookie( index+1 );     // zero is an invalid cookie value
        }
    }
    LeaveCriticalSection();

    if ( FAILED(hr) )
        goto error;

cleanup:
    RRETURN(hr);
error:
    goto cleanup;

}

//+----------------------------------------------------------------------------
//
//  Method:     RemoveAdvise
//
//  Synopsis:   Removes an advisement from the array of advisement.
//
//  Arguments:  index - which one to remove
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::RemoveAdvise( int index )
{
    EnterCriticalSection();
    Assert( _aryTimerThreadAdvises.Size() > 0 );       // otherwise, we should have shut down
    Assert( index < _aryTimerThreadAdvises.Size() && index >= 0 );

    TraceTag((tagExtTimer, "CTimerMan::RemoveAdvise"));

    if ( !_aryTimerThreadAdvises[index].fIsFree )
    {
        _aryTimerThreadAdvises[index].fIsFree = TRUE;
        _aryTimerThreadAdvises[index].NextFree = _iFirstFree;
        _iFirstFree = index;
    }
    LeaveCriticalSection();
}

//+----------------------------------------------------------------------------
//
//  Method:     EnsureTimerThread
//
//  Synopsis:   Makes sure the Timer thread is up and running
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::EnsureTimerThread()
{
    HRESULT             hr = S_OK;

    // make sure timer thread is active
    if ( !_fIsLaunched )
    {
        TraceTag((tagExtTimer, "CTimerMan::EnsureTimerThread. Launching..."));

        EnterCriticalSection();
        if (!_fIsLaunched)
        {
            _hevCheckAdvises = CreateEventA( NULL, FALSE, FALSE, NULL );
            if ( !_hevCheckAdvises )
            {
                hr = GetLastError();
            }
            if (hr == S_OK)
            {
                hr = THR(Launch(FALSE));
            }
            if (hr == S_OK)
                _fIsLaunched = TRUE;
        }
        LeaveCriticalSection();
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//    Methods which run on the Timer Thread
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:     ThreadInit
//
//  Synopsis:   Initializes Event object used to signal timer thread
//
//  Arguments:  none
//
//  Returns:    result from CreateEvent
//
//-----------------------------------------------------------------------------
HRESULT
CTimerMan::ThreadInit( )
{
    TraceTag((tagExtTimer, "CTimerMan::ThreadInit"));

    // Name this thread for IceCAP
    NameThread("TimerMan");

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     ThreadExec
//
//  Synopsis:   Timer on separate thread, the real workhorse. The thread has
//              an event schedule, which is its own array of single shot advises.
//              Periodic timers should reschedule their advises to this thread
//              as they are processed by the TimerCtx on the UI threads.
//              This thread sleeps until the earliest advise should
//              be fired, or until there is something that changes its
//              scheduling queue. Each advise gets fired off, even if they occur
//              at the same time as other events. The signaling method
//              prevents undue notifications.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::ThreadExec( )
{
    DWORD              timeWait, timeNow;
    TIMERTHREADADVISE *pTTA;
    int                cTTA;

    TraceTag((tagExtTimer, "CTimerMan::ThreadExec"));
    Assert( _hevCheckAdvises );

    while ( !_fShutdown )
    {
        timeWait = INFINITE;

        // Get the next advise to fire off
        EnterCriticalSection();
        if ( _aryTimerThreadAdvises.Size() > 0 )
        {
            timeNow = GetCurrentTime();

            // loop through to see if we have any that can be fired off now.
            // and in the mean time keep track of the closest one to timeNow
            // that should be scheduled
            for ( cTTA=_aryTimerThreadAdvises.Size(), pTTA=_aryTimerThreadAdvises;
                  cTTA;
                  cTTA--, pTTA++)
            {
                if ( !(pTTA->fIsFree) )
                {
                    if ( pTTA->timeFire <= timeNow )
                    {
                        // fire off advise, even if it has expired to
                        // clear _aryAdvises of dead Advises
                        pTTA->pTimerCtx->Signal();
                    }
                    else
                    {
                        if ( pTTA->timeFire - timeNow < timeWait )
                        {
                            timeWait = pTTA->timeFire - timeNow;
                        }
                    }
                }
            }
        }
        LeaveCriticalSection();

        // wait until its either time to process the advise scheduled or until
        // the event has been set because _aryTimerThreadAdvises has changed
        WaitForSingleObject( _hevCheckAdvises, timeWait );
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     ThreadTerm
//
//  Synopsis:   Closes Event object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::ThreadTerm( )
{
    TraceTag((tagExtTimer, "CTimerMan::ThreadTerm"));
}

//+----------------------------------------------------------------------------
//
//  Method:     Passivate
//
//  Synopsis:   Frees all references held by our timer
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::Passivate( )
{
    TraceTag((tagExtTimer, "CTimerMan Passivate (Enter)"));

    Shutdown();
    super::Passivate();
    CloseEvent( _hevCheckAdvises );

    TraceTag((tagExtTimer, "CTimerMan Passivate (Leave)"));
}

//+----------------------------------------------------------------------------
//
//  Method:     Shutdown
//
//  Synopsis:   takes down timer thread
//
//  Arguments:  none
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerMan::Shutdown( )
{
    TraceTag((tagExtTimer, "CTimerMan Shutdown (Enter)"));

    _fShutdown = TRUE;
    if ( _hevCheckAdvises )
        SetEvent( _hevCheckAdvises );   // tell timer thread to shutdown
    super::Shutdown();

    TraceTag((tagExtTimer, "CTimerMan Shutdown (Leave)"));
}

/******************************************************************************
                CTimerCtx
******************************************************************************/
CTimerCtx::CTimerCtx( CTimerMan *pTimerMan, CRITICAL_SECTION *pcs )
    : CBaseFT(pcs)
    , _aryAdvises(Mt(CTimerCtx_aryAdvises_pv))
    , _aryNamedTimers(Mt(CTimerCtx_aryNamedTimers_pv))
{
    TraceTag((tagExtTimer, "CTimerCtx::CTimerCtx"));
    _pTimerMan =            pTimerMan;
    _pTimerMan->AddRef();
    _pts =                  GetThreadState();
    _cFreezes =             0;
    _fProcessingAdvise =    FALSE;
    _fPendingUnadvise =     FALSE;
    _fPosting =             FALSE;
    _fSetTimer =            FALSE;
    _fSignalManager =       FALSE;
    _uTimerID =             0;
    _aryAdvises.EnsureSize(3);
#if DBG==1
    _threadID =             GetCurrentThreadId();
#endif
}

CTimerCtx::~CTimerCtx()
{
    TraceTag((tagExtTimer, "CTimerCtx::~CTimerCtx"));
    Assert( _pTimerMan );
    TraceTag(( tagExtTimer, "~CTimerCtx deleting %d advises", _aryAdvises.Size() ));
    for ( int i=0; i<_aryAdvises.Size(); i++ )
    {
        delete _aryAdvises[i];
    }
    GWKillMethodCallEx( _pts, this, NULL, 0 );
    if ( _uTimerID )
        FormsKillTimer( this, _uTimerID );
    _pTimerMan->Release();

}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   The typical IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimerCtx::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimer *)this, IUnknown)
        QI_INHERITS(this, ITimer)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     Unadvise         [ITimer]
//
//  Synopsis:   Removes an advisement from the array of advisement by cookie.
//
//  Arguments:  dwCookie - cookie identifying which advise
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::Unadvise( DWORD dwCookie )
{
    HRESULT hr = E_INVALIDARG;
#if DBG==1
    // make sure unadvise is happening on the same thread timectx was created on
    Assert(_threadID == GetCurrentThreadId() );
#endif

    TraceTag((tagExtTimer, "CTimerCtx::Unadvise (Cookie=%d)", dwCookie));
    // loop thru to find cookie match. Cookie comes from CTimerMan, so cookies
    // may not be contiguous.
    int iArySize = _aryAdvises.Size();
    for ( int i=0; i<iArySize; i++ )
    {
        if ( _aryAdvises[i]->GetCookie() == dwCookie )
        {
            if ( _fProcessingAdvise )
            {
                _fPendingUnadvise = TRUE;
                _aryAdvises[i]->SetPendingDelete();
            }
            else
            {
                delete _aryAdvises[i];
                _aryAdvises.Delete(i);
                _pTimerMan->RemoveAdvise( dwCookie-1 );   // CTimerMan passes back index+1 as cookie
            }
            hr = S_OK;
            break;
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     Freeze (and Thaw)         [ITimer]
//
//  Synopsis:   Halts the flow of time for this timer. No events fire until
//              a freze is "thawed". Freezes can be nested. Must be matched
//              by a call that thaws the clock.
//
//  Arguments:  fFreeze - Whether to freeze or thaw the clock.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::Freeze( BOOL fFreeze )
{
    TraceTag((tagExtTimer, "CTimerCtx::Freeze %s", fFreeze?"On":"Off"));

    HRESULT hr = S_OK;

    if ( fFreeze )
    {
        if ( 0 == _cFreezes++ )
        {
            VARIANT v;
            VariantInit(&v);

            hr = GetTime(&v);
            Assert(SUCCEEDED(hr));
            Assert(V_VT(&v) == VT_UI4);
            _timeFrozen = V_UI4(&v);
        }
    }
    else if ( _cFreezes > 0 )
    {
        if ( 0 == --_cFreezes )
        {
            hr = ProcessAdvise();
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetTime                 [ITimer]
//
//  Synopsis:   returns the current time in milliseconds.
//
//  Arguments:  pTime - returned time
//
//  Returns:    S_OK
//              E_POINTER
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::GetTime( VARIANT *pvTime )
{
    TraceTag((tagExtTimer, "CTimerCtx::GetTime"));

    if ( !pvTime )
        RRETURN(E_POINTER);

    VariantClear(pvTime);

    V_VT(pvTime) = VT_UI4;
    if ( _cFreezes > 0 || _fProcessingAdvise )
        V_UI4(pvTime) = _timeFrozen;
    else
        V_UI4(pvTime) = ::GetCurrentTime();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     Advise
//
//  Synopsis:   Does the actual setting of the Advise. Parameter checks done
//              by other Advise* calls.
//
//  Arguments:  timeMin - event will not be fired before this time
//              timeMax - event will not be fired after this time (discarded)
//                        if set to zero (translated to TIME_MAX), this is 
//                        never discarded
//              timeInterval - the minimum time before the next event is fired
//              dwFlags - Hint Flags:
//                        TIMER_HINT_KEYFRAME -
//                        TIMER_HINT_INVALIDATE - Sink will cause a paint. Timer
//                                                should be frozen when container
//                                                paints, or at least event shouldn't
//                                                fire during a paint
//              pTimerSink - method to call when event fires
//              pdwCookie - cookie returned for call to Unadvise
//
//  Returns:    S_OK
//              E_POINTER
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              DISP_E_OVERFLOW
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::Advise( VARIANT vtimeMin, VARIANT vtimeMax, VARIANT vtimeInterval,
                      DWORD dwFlags, ITimerSink *pTimerSink, DWORD *pdwCookie )
{
    TraceTag((tagExtTimer, "CTimerCtx::Advise"));

    if ( !pTimerSink || !pdwCookie )
        RRETURN(E_POINTER);

    HRESULT             hr;
    CTimerAdvise       *pTA = NULL;


    DWORD timeMin, timeMax, timeInterval;

    hr = VariantToTime(&vtimeMin, &timeMin);
    if (FAILED(hr))
        RRETURN(hr);

    hr = VariantToTime(&vtimeMax, &timeMax);
    if (FAILED(hr))
        RRETURN(hr);
    //
    // REVIEW - michaelw: if someone uses a different type to pass in 0xffffffff
    //                    we really shouldn't treat it as MAX_TIME.
    if (timeMax == MAX_TIME)
        RRETURN(DISP_E_OVERFLOW);
    else if (timeMax == 0)
        timeMax = MAX_TIME;

    if (timeMax < timeMin)
        RRETURN(E_INVALIDARG);

    hr = VariantToTime(&vtimeInterval, &timeInterval);
    if (FAILED(hr))
        RRETURN(hr);

    // add advise to UI thread, which adds advise Timer-thread's list
    pTA = new CTimerAdvise( pTimerSink, timeMin, timeMax, timeInterval, dwFlags );
    if ( !pTA )
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = _aryAdvises.Append( pTA );
    if ( FAILED(hr) )
        goto error;

    // put this on the timer thread as well
    hr = _pTimerMan->AddAdvise( pTA, this );
    if ( FAILED(hr) )
        goto error;

    if ( _fProcessingAdvise )   
        _fSignalManager = TRUE;         // defer signalling to ProcessAdvise
    else
        _pTimerMan->SignalChanges();    // tell timerman to pick this up now

    *pdwCookie = pTA->GetCookie();
    TraceTag((tagExtTimer, "CTimerCtx::Advise cookie = %d", *pdwCookie));

cleanup:
    RRETURN(hr);

error:
    delete pTA;
    goto cleanup;

}

void
CTimerCtx::Signal()
{
    TraceTag((tagExtTimer, "CTimerCtx::Signal"));
    TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal"));
    if ( _fPosting || _cFreezes > 0 || _fSetTimer )
    {
#if DBG==1  
        if ( IsTagEnabled(tagExtTimerThrottle) ) {
            if(_fPosting)
                TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal Skipped, still posting the old one"));
            if(_cFreezes > 0)
                TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal Skipped, _cFreezes > 0"));
            if(_fSetTimer > 0)
                TraceTag((tagExtTimerThrottle, "CTimerCtx::Signal Skipped, _fSetTimer WM_TIMER has not arrived"));
        }
#endif
        return;
    }

    EnterCriticalSection();
    if ( _fProcessingAdvise )
    {
        TraceTag((tagExtTimerThrottle, "_fProcessingAdvise set, setting _fSetTime=TRUE"));
        _fSetTimer = TRUE;
        LeaveCriticalSection();
        return;
    }
    LeaveCriticalSection();

    TraceTag((tagExtTimer, "Signal got through"));
    TraceTag((tagExtTimerThrottle, "Signal got through"));
    _fPosting = TRUE;
    GWPostMethodCallEx( _pts, (void *)this,
                        ONCALL_METHOD(CTimerCtx, OnMethodCall, onmethodcall),
                        0, FALSE, "CTimerCtx::OnMethodCall");

}

//+----------------------------------------------------------------------------
//
//  Method:     OnMethodCall
//
//  Synopsis:   The Callback from the Global Window Proc after posting our
//              request. In turn, fires off OnTimer calls to clients who
//              have posted advises with this reference timer.
//
//  Arguments:  dwContext - not used
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerCtx::OnMethodCall( DWORD_PTR dwContext )
{
    TraceTag((tagExtTimer, "CTimerCtx::OnMethodCall"));
    _fPosting = FALSE;
    if ( _cFreezes > 0 )
        return;

    WHEN_DBG(HRESULT hr =) ProcessAdvise();
    Assert(SUCCEEDED(hr));
}

//+----------------------------------------------------------------------------
//
//  Method:     ProcessAdvise
//
//  Synopsis:   Goes through advises and sees if they should notify clients
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::ProcessAdvise()
{
    TraceTag((tagExtTimer, "CTimerCtx::ProcessAdvise"));

    DWORD timeNow, timeMax, timeSink, timeInt;
    BOOL fSetTimer;
    HRESULT hr;

    if ( _cFreezes > 0 )
        RRETURN(S_OK);

    if ( _fProcessingAdvise ) {
        // oh man, aux msg pump driving timer. Defer until later
        _fSignalManager = TRUE;
        RRETURN(S_OK);
    }

    VARIANT vtimeNow;
    VariantInit(&vtimeNow);
	
	hr = GetTime( &vtimeNow );
	if ( FAILED(hr) )
		RRETURN(hr);
	
    hr = VariantToTime( &vtimeNow, &timeNow );
    if ( FAILED(hr) )
        RRETURN(hr);

    _timeFrozen = timeNow;
    _fProcessingAdvise = TRUE;
    int i = _aryAdvises.Size()-1;
    while ( i >= 0)
    {
        CTimerAdvise *pTA = _aryAdvises[i];
        if ( (timeMax = pTA->GetTimeMax()) < timeNow )
        {
            _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );
            delete _aryAdvises[i];
            _aryAdvises.Delete(i);
        }
        else if ( (timeSink = pTA->GetNextTick()) <= timeNow )
        {
            if ( 0 == (timeInt = pTA->GetTimeInterval()) )
            {
                DECLARE_VARIANT_INIT(vtimeSink, timeSink);

                pTA->GetTimerSink()->OnTimer( vtimeSink );
#if DBG==1  
                if ( IsTagEnabled(tagExtTimerReentrant) ) {
                    // make like a modal dialog came up, or something
                    ProcessAdvise();
                }
#endif
                _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );
                delete _aryAdvises[i];  // trash advise if this was not periodic
                _aryAdvises.Delete(i);
            }
            else
            {
                // make sure we give the latest interval to the sink call
                timeSink += ((timeNow - timeSink)/timeInt) * timeInt;

                DECLARE_VARIANT_INIT(vtimeSink, timeSink);

                pTA->GetTimerSink()->OnTimer( vtimeSink );

                // schedule next period
                if ( MAX_TIME == timeMax || timeSink + timeInt < timeMax )
                {
                    // reset pTA in case memory moved from growing during OnTimer call 
                    CTimerAdvise *pTA = _aryAdvises[i];
                    pTA->SetNextTick( timeSink + timeInt );
                    _pTimerMan->AddAdvise( pTA, this, TRUE );
                    _fSignalManager = TRUE;
                }
                else
                {
                    _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );
                    delete _aryAdvises[i];  // trash it, advise expired
                    _aryAdvises.Delete(i);
                }
            }
        }
        i--;
    }

    // Process any Unadvises that came as a result of calling OnTimer on our sinks.
    if ( _fPendingUnadvise )
    {
        for ( i=_aryAdvises.Size()-1; i>=0; i-- )
        {
            if ( _aryAdvises[i]->GetPendingDelete() )
            {
                _pTimerMan->RemoveAdvise( _aryAdvises[i]->GetCookie()-1 );  // CTimerMan passes back index+1 as cookie
                delete _aryAdvises[i];
                _aryAdvises.Delete(i);
            }
        }
        _fPendingUnadvise = FALSE;
    }

    // Now it's time to tell the Timer Manager to wake up and notices the changes
    if ( _fSignalManager ) {
        _pTimerMan->SignalChanges();
        _fSignalManager = FALSE;
    }

    // If processing advises took longer than the interval in which we are 
    // notified to process the advises, then we need to yield to other msgs
    // in the Windows msg queue, so we'll set up a timer to let things happen
    EnterCriticalSection();
    fSetTimer =  _fSetTimer;
    _fProcessingAdvise = FALSE;
    LeaveCriticalSection();

    if ( fSetTimer )
    {
        hr = THR(FormsSetTimer( this, ONTICK_METHOD(CTimerCtx, TimerCallback, timercallback),
                 ++_uTimerID, 0 ));
        TraceTag((tagExtTimerThrottle, "Setting up Windows Timer, ID=%d", _uTimerID));
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     TimerCallback   
//
//  Synopsis:   Function Windows calls when processing a WM_Timer for CTimerCtx
//
//  Arguments:  uTimerID        - ID of Windows timer
//
//  Returns:    S_OK
//              E_FAIL          - no timer by this name
//
//-----------------------------------------------------------------------------
HRESULT BUGCALL
CTimerCtx::TimerCallback( UINT uTimerID )
{
    TraceTag((tagExtTimerThrottle, "TimerCallback _ID=%d  ID=%d", _uTimerID, uTimerID));
    Assert( _uTimerID == uTimerID );
    Verify(FormsKillTimer( this, uTimerID ) == S_OK);
    _fSetTimer = FALSE;
    _uTimerID = 0;
    return ProcessAdvise();
}

//+----------------------------------------------------------------------------
//
//  Method:     GetNamedCTimer
//
//  Synopsis:   Returns a named timer. 
//
//  Arguments:  rguidName       - GUID name of the timer to return. 
//              ppNewTimer      - Returned CTimer object.
//
//  Returns:    S_OK
//              E_FAIL          - no timer by this name
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::GetNamedCTimer( REFGUID rguidName, CTimer **ppNewTimer)
{
    TraceTag((tagExtTimer, "CTimerCtx::GetNamedCTimer"));
    Assert( ppNewTimer );

    *ppNewTimer = NULL;

    for ( int i=0; i<_aryNamedTimers.Size(); i++ ) 
    { 
        if ( _aryNamedTimers[i].guidName == rguidName )
        {
            *ppNewTimer = _aryNamedTimers[i].pTimer;
            return S_OK;
        }
    }
    return E_FAIL;
}

//+----------------------------------------------------------------------------
//
//  Method:     AddNamedCTimer
//
//  Synopsis:   Adds a timer and Name to the array of named timers
//
//  Arguments:  rguidName       - GUID name of the timer 
//              pTimer          - timer.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
CTimerCtx::AddNamedCTimer( REFGUID rguidName, CTimer *pTimer)
{
    PTIMERNAMEDTIMER pNT;
    HRESULT hr;

    TraceTag((tagExtTimer, "CTimerCtx::AddNamedCTimer"));
    Assert( pTimer );

    hr = THR(_aryNamedTimers.AppendIndirect(NULL, &pNT));
    if ( FAILED(hr) )
        RRETURN(hr);

    pNT->guidName = rguidName;
    pNT->pTimer = pTimer;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     RemoveNamedCTimer
//
//  Synopsis:   Removes the name and corresponding timer from the array of 
//              named timers
//
//  Arguments:  rguidName       - GUID name of the timer 
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimerCtx::RemoveNamedCTimer( REFGUID rguidName )
{
    TraceTag((tagExtTimer, "CTimerCtx::RemoveNamedCTimer"));

    for ( int i=_aryNamedTimers.Size()-1; i >= 0; i-- )
    {
        if ( _aryNamedTimers[i].guidName == rguidName )
        {
            _aryNamedTimers.Delete(i);
            break;
        }
    }
}

/******************************************************************************
                CTimer
******************************************************************************/
CTimer::CTimer( ITimer *pRefTimer, CTimerCtx *pTimerCtx, 
                CRITICAL_SECTION *pcs, REFGUID rguidName )
    : CBaseFT(pcs), _aryAdvises(Mt(CTimer_aryAdvises_pv))
{
    TraceTag((tagExtTimer, "CTimer::CTimer"));
    _dwCurrentCookie    = 1;
    _cFreezes           = 0; 
    _fProcessingAdvise  = FALSE; 
    _fPendingUnadvise   = FALSE;
    _pTimerSink         = NULL;
    _guidName           = rguidName;
    _pTimerCtx          = pTimerCtx;
    _pTimerCtx->AddRef();
    _pRefTimer          = pRefTimer;
    _pRefTimer->AddRef();
    IncrementObjectCount(&_dwObjCnt);
}

CTimer::~CTimer()
{
    TraceTag((tagExtTimer, "CTimer::~CTimer"));
    if ( _pTimerSink )                  // timer sink is on its own
    {
        _pTimerSink->_pTimer = NULL;
    }

    if ( GUID_NULL != _guidName ) 
        _pTimerCtx->RemoveNamedCTimer( _guidName );
    _pTimerCtx->Release();

    for ( int i=0; i<_aryAdvises.Size(); i++ )
    {
        _pRefTimer->Unadvise(_aryAdvises[i]->GetRefCookie());
        delete _aryAdvises[i];
    }
    _pRefTimer->Release();
    DecrementObjectCount(&_dwObjCnt);
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   class QueryInterface impl
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimer::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimer *)this, IUnknown)
        QI_INHERITS(this, ITimer)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     Unadvise         [ITimer]
//
//  Synopsis:   Removes a schedule event
//
//  Arguments:  dwCookie - cookie identifying which advise
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::Unadvise( DWORD dwCookie )
{
    TraceTag((tagExtTimer, "CTimer::Unadvise (Cookie=%d)", dwCookie));
    HRESULT hr = E_INVALIDARG;
    for ( int i=0; i<_aryAdvises.Size(); i++ )
    {
        if ( _aryAdvises[i]->GetCookie() == dwCookie )
        {
            if ( _fProcessingAdvise )
            {
                _fPendingUnadvise = TRUE;
                _aryAdvises[i]->SetPendingDelete();
            }
            else
            {
                RemoveAdvise( i );
            }
            hr = S_OK;
            break;
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     Freeze (and Thaw)         [ITimer]
//
//  Synopsis:   Halts the flow of time for this timer. No events fire until
//              a freze is "thawed". Freezes can be nested. Must be matched
//              by a call that thaws the clock.
//
//  Arguments:  fFreeze - Whether to freeze or thaw the clock.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::Freeze( BOOL fFreeze )
{
    TraceTag((tagExtTimer, "CTimer::Freeze"));

    HRESULT hr = S_OK;

    if ( fFreeze ) {
        if ( 0 == _cFreezes )
        {
            VARIANT vtimeNow;
            VariantInit(&vtimeNow);

            hr = _pRefTimer->GetTime( &vtimeNow );
            if (SUCCEEDED(hr))
            {
                hr = VariantToTime(&vtimeNow, &_timeFrozen);
                if (SUCCEEDED(hr))
                    _cFreezes++;
            }
        }
        else
            _cFreezes++;
    }
    else if ( _cFreezes > 0 )
    {
        if ( 0 == --_cFreezes )
        {
            hr = ProcessAdvise();
        }
    }
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetTime             [ITimer]
//
//  Synopsis:   returns the current time in miliseconds.
//
//  Arguments:  pTime - returned time
//
//  Returns:    S_OK
//              E_POINTER
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::GetTime( VARIANT *pvTime )
{
    TraceTag((tagExtTimer, "CTimer::GetTime"));
    if ( !pvTime )
        RRETURN( E_POINTER );

    if ( _fProcessingAdvise || _cFreezes > 0 )
    {
        VariantClear(pvTime);
        V_VT(pvTime) = VT_UI4;
        V_UI4(pvTime) = _timeFrozen;
        return( S_OK );
    }
    RRETURN(_pRefTimer->GetTime( pvTime ));
}

//+----------------------------------------------------------------------------
//
//  Method:     Advise
//
//  Synopsis:   Does the actual setting of the Advise. Parameter checks done
//              by other Advise* calls.
//
//  Arguments:  timeMin - event will not be fired before this time
//              timeMax - event will not be fired after this time (discarded)
//                        if set to zero (translated to MAX_TIME), this is 
//                        never discarded
//              timeInterval - the minimum time before the next event is fired
//              dwFlags - Hint Flags:
//                        TIMER_HINT_KEYFRAME -
//                        TIMER_HINT_INVALIDATE - Sink will cause a paint. Timer
//                                                should be frozen when container
//                                                paints, or at least event shouldn't
//                                                fire during a paint
//              pTimerSink - method to call when event fires
//              pdwCookie - cookie returned for call to Unadvise
//
//  Returns:    S_OK
//              E_POINTER
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              E_FAIL
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::Advise( VARIANT vtimeMin, VARIANT vtimeMax, VARIANT vtimeInterval, 
                   DWORD dwFlags, ITimerSink *pTimerSink, DWORD *pdwCookie )
{
    HRESULT         hr;
    CTimerAdvise   *pTA = NULL;
    DWORD           dwCookie;
    DWORD timeMin, timeMax, timeInterval;

    if ( !pTimerSink)
        RRETURN(E_POINTER);

    hr = VariantToTime(&vtimeMin, &timeMin);
    if (FAILED(hr))
        RRETURN(hr);

    hr = VariantToTime(&vtimeMax, &timeMax);
    if (FAILED(hr))
        RRETURN(hr);
    //
    // REVIEW - michaelw: if someone uses a different type to pass in 0xffffffff
    //                    we really shouldn't treat it as MAX_TIME.
    if (timeMax == MAX_TIME)
        RRETURN(DISP_E_OVERFLOW);
    else if (timeMax == 0)
        timeMax = MAX_TIME;

    if (timeMax < timeMin)
        RRETURN(E_INVALIDARG);

    hr = VariantToTime(&vtimeInterval, &timeInterval);
    if (FAILED(hr))
        RRETURN(hr);

    // create our sink object if not already there
    if ( !_pTimerSink )
    {
        _pTimerSink = new CTimerSink( this );
        if ( !_pTimerSink )
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    // create advise and add advise to our list
    pTA = new CTimerAdvise( pTimerSink, timeMin, timeMax, timeInterval, dwFlags );
    if ( !pTA )
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // ask reference timer to tell us when to process this advise
    hr = _pRefTimer->Advise(vtimeMin, vtimeMax, vtimeInterval, dwFlags, (ITimerSink *)_pTimerSink, &dwCookie);
    if ( FAILED(hr) )
        goto error;

    // add advisement to our own list
    hr = _aryAdvises.Append( pTA );
    if ( FAILED(hr) )
        goto error;

    // set cookies. Need separate cookies because ref timer can be switched midstream.
    pTA->SetRefCookie( dwCookie );
    pTA->SetCookie( _dwCurrentCookie );

    if ( pdwCookie )
        *pdwCookie = _dwCurrentCookie;
    _dwCurrentCookie++;

    TraceTag((tagExtTimer, "CTimer::Advise cookie = %d", *pdwCookie));

cleanup:
    RRETURN(hr);

error:
    TraceTag((tagExtTimer, "CTimer::Advise ERROR"));
    delete pTA;
    goto cleanup;

}

/*-------------------------------Helper Functions----------------------------*/

//+----------------------------------------------------------------------------
//
//  Method:     RemoveAdvise
//
//  Synopsis:   Removes an advisement from the array of advisement.
//
//  Arguments:  index - which one to remove
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
CTimer::RemoveAdvise( int index )
{
    TraceTag((tagExtTimer, "CTimer::RemoveAdvise"));
    Assert( index < _aryAdvises.Size() && index >= 0 );

    _pRefTimer->Unadvise( _aryAdvises[index]->GetRefCookie() );
    delete _aryAdvises[index];
    _aryAdvises.Delete(index);
}

//+----------------------------------------------------------------------------
//
//  Method:     ProcessAdvise
//
//  Synopsis:   Goes through advises and sees if they should notify clients
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
HRESULT
CTimer::ProcessAdvise()
{
    TraceTag((tagExtTimer, "CTimer::ProcessAdvise"));

    DWORD timeNow, timeMax, timeSink, timeInt;
    HRESULT hr;

    if ( _cFreezes > 0 )
        RRETURN(S_OK);

    VARIANT vtimeNow;
    VariantInit(&vtimeNow);
	
	hr = GetTime( &vtimeNow );
	if ( FAILED(hr) )
		RRETURN(hr);
	
    hr = VariantToTime( &vtimeNow, &timeNow );
    if ( FAILED(hr) )
        RRETURN(hr);

    _timeFrozen = timeNow;
    AddRef();                   // protect against releases to zero
    if(_fProcessingAdvise == TRUE)
    {
        goto done;
    }
    _fProcessingAdvise = TRUE;  // protect against unadvises

    // Check all advises
    int i = _aryAdvises.Size()-1;
    while ( i >= 0)
    {
        CTimerAdvise *pTA = _aryAdvises[i];
        if ( (timeMax = pTA->GetTimeMax()) < timeNow )
        {
            RemoveAdvise( i );
        }
        else if ( (timeSink = pTA->GetNextTick()) <= timeNow )
        {
            VARIANT vtimeSink;
            VariantInit(&vtimeSink);
            V_VT(&vtimeSink) = VT_UI4;

            if ( 0 == (timeInt = pTA->GetTimeInterval()) )
            {
                V_UI4(&vtimeSink) = timeSink;

                pTA->GetTimerSink()->OnTimer(vtimeSink);
                RemoveAdvise( i );      // trash advise if this was a one off
            }
            else
            {
                // make sure we give the latest interval to the sink call
                timeSink += ((timeNow - timeSink)/timeInt) * timeInt;
                V_UI4(&vtimeSink) = timeSink;

                pTA->GetTimerSink()->OnTimer( vtimeSink );

                // schedule next period
                if ( MAX_TIME == timeMax || timeSink + timeInt < timeMax )
                    (_aryAdvises[i])->SetNextTick( timeSink + timeInt );
                else
                    RemoveAdvise( i );      // trash it, advise expired
            }
        }
        i--;
    }
    _fProcessingAdvise = FALSE;

    // Process any Unadvises that came as a result of calling OnTimer on our sinks.
    if ( _fPendingUnadvise )
    {
        for ( i=_aryAdvises.Size()-1; i>=0; i-- )
        {
            if ( _aryAdvises[i]->GetPendingDelete() )
                RemoveAdvise( i );
        }
        _fPendingUnadvise = FALSE;
    }
done:
    Release();

    RRETURN(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Method:     SetRefTimer
//
//  Synopsis:   Set the reference timer. Advises on the old reference timer
//              are removed and replaced onto the new reference timer.
//
//  Arguments:  pRefTimer - new reference timer
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------

HRESULT
CTimer::SetRefTimer( ITimer *pRefTimer )
{
    CTimerAdvise    *pTA;
    DWORD           dwCookie;
    DWORD           timeOldRef, timeNewRef, timeDiff=0;
    DWORD           timeMin, timeMax;
    int             cAdvises = _aryAdvises.Size();
    CStackPtrAry<DWORD_PTR, 12> arydw(Mt(CTimerSetRefTimer_arydw_pv));
    HRESULT         hr;

    TraceTag((tagExtTimer, "CTimer::SetRefTimer: moving %d advises", cAdvises));

    pRefTimer->AddRef();
    Freeze( TRUE );

    // account for different starting points in reference timers
    VARIANT v;
    VariantInit(&v);
    hr = THR(pRefTimer->GetTime( &v ));
    if (FAILED(hr))
        goto error;

    hr = VariantToTime(&v, &timeNewRef);
    if (FAILED(hr))
        goto error;

    hr = GetTime(&v);
    if (FAILED(hr))
        goto error;

    hr = VariantToTime(&v, &timeOldRef);
    if (FAILED(hr))
        goto error;

    timeDiff = timeNewRef - timeOldRef;

    if ( cAdvises > 0 )
    {
        // first move all advises to new ref timer before trashing old one
        hr = THR(arydw.EnsureSize(cAdvises));
        if ( FAILED(hr) )
            goto error;

        int i;
        for ( i=0; i<cAdvises; i++ )
        {
            pTA = _aryAdvises[i];
            timeMin = pTA->GetTimeMin() + timeDiff;
            if ( pTA->GetTimeMax() != MAX_TIME )
                timeMax = pTA->GetTimeMax() + timeDiff;
            else 
                timeMax = 0;    // this is treated as MAX_TIME from the interface standpoint

            DECLARE_VARIANT_INIT(vtimeMin, timeMin);
            DECLARE_VARIANT_INIT(vtimeMax, timeMax);
            DECLARE_VARIANT_INIT(vtimeInterval, pTA->GetTimeInterval());

            hr = pRefTimer->Advise( vtimeMin, vtimeMax, vtimeInterval,
                                    pTA->GetHintFlags(),
                                    pTA->GetTimerSink(),
                                    &dwCookie);
            if ( FAILED(hr) )
                goto error;

            arydw[i] = dwCookie;
        }

        // everything safely on new ref timer, 
        // - get rid of advises on old timer, 
        // - adjust min and max time accordingly, 
        // - and expunge expired advises
        for ( i=cAdvises-1; i>=0; i-- )
        {
            pTA = _aryAdvises[i];

            _pRefTimer->Unadvise( pTA->GetRefCookie() );
            
            if ( 0 == arydw[i] )
            {
                delete _aryAdvises[i];
                _aryAdvises.Delete(i);
            }
            else
            {
                pTA->SetTimeMin( pTA->GetTimeMin() + timeDiff );
                if ( pTA->GetTimeMax() != MAX_TIME )
                    pTA->SetTimeMax( pTA->GetTimeMax() + timeDiff );
                pTA->SetRefCookie( (DWORD)arydw[i] );
            }
        }
    }
    _pRefTimer->Release();
    _pRefTimer = pRefTimer;     // already AddRef'ed above


cleanup:
    Freeze( FALSE );
    RRETURN(hr);

error:
    Assert( 0 && "Error in SetRefTimer" );
    pRefTimer->Release();
    goto cleanup;
}

/******************************************************************************
                CTimerSink
******************************************************************************/
CTimerSink::CTimerSink( CTimer *pTimer )
{
    TraceTag((tagExtTimer, "CTimerSink::CTimerSink"));
    _pTimer = pTimer;
    _ulRefs = 0;
}

CTimerSink::~CTimerSink( )
{
    TraceTag((tagExtTimer, "CTimerSink on it's way out!"));
    if ( _pTimer )
        _pTimer->_pTimerSink = NULL;
}

ULONG
CTimerSink::AddRef()
{
    return ++_ulRefs;
}

ULONG
CTimerSink::Release()
{
    TraceTag((tagExtTimer, "CTimerSink::Release(); New ref count = %d", _ulRefs-1));
    if ( 0 == --_ulRefs )
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CTimerSink::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerSink *)this, IUnknown)
        QI_INHERITS(this, ITimerSink)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     OnTimer             [ITimerSink]
//
//  Synopsis:   Get notified of an event which we requested through CTimer's
//              ITimer::Advise*
//
//  Arguments:  timeAdvie - the time that the advise was set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimerSink::OnTimer( VARIANT vtimeAdvise )
{
    TraceTag((tagExtTimer, "CTimerSink::OnTimer"));
    if ( _pTimer )
        _pTimer->ProcessAdvise();
    return S_OK;
}


/******************************************************************************
                CTimerAdvise
******************************************************************************/
CTimerAdvise::CTimerAdvise()
{
    memset( this, 0, sizeof(CTimerAdvise) );
}

CTimerAdvise::CTimerAdvise( ITimerSink *pTimerSink, DWORD timeMin, DWORD timeMax,
                            DWORD timeInterval, DWORD dwHintFlags )
{
    Assert( pTimerSink );
    _timeMin            = timeMin;
    _timeMax            = timeMax;
    _timeInterval       = timeInterval;
    _NextTick           = timeMin;
    _dwHintFlags        = dwHintFlags;
    _pTimerSink         = pTimerSink;
    _pTimerSink->AddRef();
    _dwCookie           = 0;
    _dwRefCookie        = 0;
    _fDeleteMe          = FALSE;

}

CTimerAdvise::~CTimerAdvise()
{
    int  i;
    i = _pTimerSink->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\thunks_c.h ===
// THUNK_C_<line number> ( <n> ), where linenum is 1-30 and n is 3-15

THUNK_GT_1
THUNK_GT_2
THUNK_GT_3
THUNK_GT_4
THUNK_GT_5
THUNK_GT_6
THUNK_GT_7
THUNK_GT_8
THUNK_GT_9

THUNK_C_1(3)
THUNK_C_2(3)
THUNK_C_3(3)
THUNK_C_4(3)
THUNK_C_5(3)
THUNK_C_6(3)
THUNK_C_7(3)
THUNK_C_8(3)
THUNK_C_9(3)
THUNK_C_10(3)
THUNK_C_11(3)
THUNK_C_12(3)
THUNK_C_13(3)
THUNK_C_14(3)
THUNK_C_15(3)
THUNK_C_16(3)
THUNK_C_17(3)
THUNK_C_18(3)
THUNK_C_19(3)
THUNK_C_20(3)
THUNK_C_21(3)
THUNK_C_22(3)
THUNK_C_23(3)
THUNK_C_24(3)
THUNK_C_25(3)
THUNK_C_26(3)
THUNK_C_27(3)
THUNK_C_28(3)
THUNK_C_29(3)
THUNK_C_30(3)
THUNK_C_1(4)
THUNK_C_2(4)
THUNK_C_3(4)
THUNK_C_4(4)
THUNK_C_5(4)
THUNK_C_6(4)
THUNK_C_7(4)
THUNK_C_8(4)
THUNK_C_9(4)
THUNK_C_10(4)
THUNK_C_11(4)
THUNK_C_12(4)
THUNK_C_13(4)
THUNK_C_14(4)
THUNK_C_15(4)
THUNK_C_16(4)
THUNK_C_17(4)
THUNK_C_18(4)
THUNK_C_19(4)
THUNK_C_20(4)
THUNK_C_21(4)
THUNK_C_22(4)
THUNK_C_23(4)
THUNK_C_24(4)
THUNK_C_25(4)
THUNK_C_26(4)
THUNK_C_27(4)
THUNK_C_28(4)
THUNK_C_29(4)
THUNK_C_30(4)
THUNK_C_1(5)
THUNK_C_2(5)
THUNK_C_3(5)
THUNK_C_4(5)
THUNK_C_5(5)
THUNK_C_6(5)
THUNK_C_7(5)
THUNK_C_8(5)
THUNK_C_9(5)
THUNK_C_10(5)
THUNK_C_11(5)
THUNK_C_12(5)
THUNK_C_13(5)
THUNK_C_14(5)
THUNK_C_15(5)
THUNK_C_16(5)
THUNK_C_17(5)
THUNK_C_18(5)
THUNK_C_19(5)
THUNK_C_20(5)
THUNK_C_21(5)
THUNK_C_22(5)
THUNK_C_23(5)
THUNK_C_24(5)
THUNK_C_25(5)
THUNK_C_26(5)
THUNK_C_27(5)
THUNK_C_28(5)
THUNK_C_29(5)
THUNK_C_30(5)
THUNK_C_1(6)
THUNK_C_2(6)
THUNK_C_3(6)
THUNK_C_4(6)
THUNK_C_5(6)
THUNK_C_6(6)
THUNK_C_7(6)
THUNK_C_8(6)
THUNK_C_9(6)
THUNK_C_10(6)
THUNK_C_11(6)
THUNK_C_12(6)
THUNK_C_13(6)
THUNK_C_14(6)
THUNK_C_15(6)
THUNK_C_16(6)
THUNK_C_17(6)
THUNK_C_18(6)
THUNK_C_19(6)
THUNK_C_20(6)
THUNK_C_21(6)
THUNK_C_22(6)
THUNK_C_23(6)
THUNK_C_24(6)
THUNK_C_25(6)
THUNK_C_26(6)
THUNK_C_27(6)
THUNK_C_28(6)
THUNK_C_29(6)
THUNK_C_30(6)
THUNK_C_1(7)
THUNK_C_2(7)
THUNK_C_3(7)
THUNK_C_4(7)
THUNK_C_5(7)
THUNK_C_6(7)
THUNK_C_7(7)
THUNK_C_8(7)
THUNK_C_9(7)
THUNK_C_10(7)
THUNK_C_11(7)
THUNK_C_12(7)
THUNK_C_13(7)
THUNK_C_14(7)
THUNK_C_15(7)
THUNK_C_16(7)
THUNK_C_17(7)
THUNK_C_18(7)
THUNK_C_19(7)
THUNK_C_20(7)
THUNK_C_21(7)
THUNK_C_22(7)
THUNK_C_23(7)
THUNK_C_24(7)
THUNK_C_25(7)
THUNK_C_26(7)
THUNK_C_27(7)
THUNK_C_28(7)
THUNK_C_29(7)
THUNK_C_30(7)
THUNK_C_1(8)
THUNK_C_2(8)
THUNK_C_3(8)
THUNK_C_4(8)
THUNK_C_5(8)
THUNK_C_6(8)
THUNK_C_7(8)
THUNK_C_8(8)
THUNK_C_9(8)
THUNK_C_10(8)
THUNK_C_11(8)
THUNK_C_12(8)
THUNK_C_13(8)
THUNK_C_14(8)
THUNK_C_15(8)
THUNK_C_16(8)
THUNK_C_17(8)
THUNK_C_18(8)
THUNK_C_19(8)
THUNK_C_20(8)
THUNK_C_21(8)
THUNK_C_22(8)
THUNK_C_23(8)
THUNK_C_24(8)
THUNK_C_25(8)
THUNK_C_26(8)
THUNK_C_27(8)
THUNK_C_28(8)
THUNK_C_29(8)
THUNK_C_30(8)
THUNK_C_1(9)
THUNK_C_2(9)
THUNK_C_3(9)
THUNK_C_4(9)
THUNK_C_5(9)
THUNK_C_6(9)
THUNK_C_7(9)
THUNK_C_8(9)
THUNK_C_9(9)
THUNK_C_10(9)
THUNK_C_11(9)
THUNK_C_12(9)
THUNK_C_13(9)
THUNK_C_14(9)
THUNK_C_15(9)
THUNK_C_16(9)
THUNK_C_17(9)
THUNK_C_18(9)
THUNK_C_19(9)
THUNK_C_20(9)
THUNK_C_21(9)
THUNK_C_22(9)
THUNK_C_23(9)
THUNK_C_24(9)
THUNK_C_25(9)
THUNK_C_26(9)
THUNK_C_27(9)
THUNK_C_28(9)
THUNK_C_29(9)
THUNK_C_30(9)
THUNK_C_1(10)
THUNK_C_2(10)
THUNK_C_3(10)
THUNK_C_4(10)
THUNK_C_5(10)
THUNK_C_6(10)
THUNK_C_7(10)
THUNK_C_8(10)
THUNK_C_9(10)
THUNK_C_10(10)
THUNK_C_11(10)
THUNK_C_12(10)
THUNK_C_13(10)
THUNK_C_14(10)
THUNK_C_15(10)
THUNK_C_16(10)
THUNK_C_17(10)
THUNK_C_18(10)
THUNK_C_19(10)
THUNK_C_20(10)
THUNK_C_21(10)
THUNK_C_22(10)
THUNK_C_23(10)
THUNK_C_24(10)
THUNK_C_25(10)
THUNK_C_26(10)
THUNK_C_27(10)
THUNK_C_28(10)
THUNK_C_29(10)
THUNK_C_30(10)
THUNK_C_1(11)
THUNK_C_2(11)
THUNK_C_3(11)
THUNK_C_4(11)
THUNK_C_5(11)
THUNK_C_6(11)
THUNK_C_7(11)
THUNK_C_8(11)
THUNK_C_9(11)
THUNK_C_10(11)
THUNK_C_11(11)
THUNK_C_12(11)
THUNK_C_13(11)
THUNK_C_14(11)
THUNK_C_15(11)
THUNK_C_16(11)
THUNK_C_17(11)
THUNK_C_18(11)
THUNK_C_19(11)
THUNK_C_20(11)
THUNK_C_21(11)
THUNK_C_22(11)
THUNK_C_23(11)
THUNK_C_24(11)
THUNK_C_25(11)
THUNK_C_26(11)
THUNK_C_27(11)
THUNK_C_28(11)
THUNK_C_29(11)
THUNK_C_30(11)
THUNK_C_1(12)
THUNK_C_2(12)
THUNK_C_3(12)
THUNK_C_4(12)
THUNK_C_5(12)
THUNK_C_6(12)
THUNK_C_7(12)
THUNK_C_8(12)
THUNK_C_9(12)
THUNK_C_10(12)
THUNK_C_11(12)
THUNK_C_12(12)
THUNK_C_13(12)
THUNK_C_14(12)
THUNK_C_15(12)
THUNK_C_16(12)
THUNK_C_17(12)
THUNK_C_18(12)
THUNK_C_19(12)
THUNK_C_20(12)
THUNK_C_21(12)
THUNK_C_22(12)
THUNK_C_23(12)
THUNK_C_24(12)
THUNK_C_25(12)
THUNK_C_26(12)
THUNK_C_27(12)
THUNK_C_28(12)
THUNK_C_29(12)
THUNK_C_30(12)
THUNK_C_1(13)
THUNK_C_2(13)
THUNK_C_3(13)
THUNK_C_4(13)
THUNK_C_5(13)
THUNK_C_6(13)
THUNK_C_7(13)
THUNK_C_8(13)
THUNK_C_9(13)
THUNK_C_10(13)
THUNK_C_11(13)
THUNK_C_12(13)
THUNK_C_13(13)
THUNK_C_14(13)
THUNK_C_15(13)
THUNK_C_16(13)
THUNK_C_17(13)
THUNK_C_18(13)
THUNK_C_19(13)
THUNK_C_20(13)
THUNK_C_21(13)
THUNK_C_22(13)
THUNK_C_23(13)
THUNK_C_24(13)
THUNK_C_25(13)
THUNK_C_26(13)
THUNK_C_27(13)
THUNK_C_28(13)
THUNK_C_29(13)
THUNK_C_30(13)
THUNK_C_1(14)
THUNK_C_2(14)
THUNK_C_3(14)
THUNK_C_4(14)
THUNK_C_5(14)
THUNK_C_6(14)
THUNK_C_7(14)
THUNK_C_8(14)
THUNK_C_9(14)
THUNK_C_10(14)
THUNK_C_11(14)
THUNK_C_12(14)
THUNK_C_13(14)
THUNK_C_14(14)
THUNK_C_15(14)
THUNK_C_16(14)
THUNK_C_17(14)
THUNK_C_18(14)
THUNK_C_19(14)
THUNK_C_20(14)
THUNK_C_21(14)
THUNK_C_22(14)
THUNK_C_23(14)
THUNK_C_24(14)
THUNK_C_25(14)
THUNK_C_26(14)
THUNK_C_27(14)
THUNK_C_28(14)
THUNK_C_29(14)
THUNK_C_30(14)
THUNK_C_1(15)
THUNK_C_2(15)
THUNK_C_3(15)
THUNK_C_4(15)
THUNK_C_5(15)
THUNK_C_6(15)
THUNK_C_7(15)
THUNK_C_8(15)
THUNK_C_9(15)
THUNK_C_10(15)
THUNK_C_11(15)
THUNK_C_12(15)
THUNK_C_13(15)
THUNK_C_14(15)
THUNK_C_15(15)
THUNK_C_16(15)
THUNK_C_17(15)
THUNK_C_18(15)
THUNK_C_19(15)
THUNK_C_20(15)
THUNK_C_21(15)
THUNK_C_22(15)
THUNK_C_23(15)
THUNK_C_24(15)
THUNK_C_25(15)
THUNK_C_26(15)
THUNK_C_27(15)
THUNK_C_28(15)
THUNK_C_29(15)
THUNK_C_30(15)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\tooltip.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       Tooltip.cxx
//
//  Contents:   Tooltip
//
//  Classes:    CTooltip
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#ifndef X_TOOLTIP_HXX_
#define X_TOOLTIP_HXX_
#include "tooltip.hxx"
#endif

#ifdef UNIX
#  include <windows.h>
#  include <mainwin.h>
#endif

DeclareTag(tagTooltip, "Tooltips", "Tooltip methods");
MtDefine(CTooltip, Utilities, "CTooltip")

//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::CTooltip
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------------

CTooltip::CTooltip()
{
    TraceTag((tagTooltip, "CTooltip::CTooltip"));
}

//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::~CTooltip
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------

CTooltip::~CTooltip()
{
    TraceTag((tagTooltip, "CTooltip::~CTooltip"));

    if (_hwnd != NULL)
    {
        // NOTE: the presence of some third party controls (see 6383)
        // kill the tooltip window ahead of time.  hence we are conservative
        // here by ensuring that the window still is one.
        Verify(!IsWindow(_hwnd) || DestroyWindow(_hwnd));
        _hwnd = NULL;
    }

}


//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::Init
//
//  Synopsis:   2nd phase constructor
//
//--------------------------------------------------------------------------

HRESULT
CTooltip::Init(HWND hwnd)
{
    HRESULT     hr = S_OK;
    BOOL        fTopMost = GetWindowExStyle(hwnd) & WS_EX_TOPMOST;

    TraceTag((tagTooltip, "CTooltip::Init"));

    InitCommonControls();

    //
    // we only use WS_EX_TOPMOST when trident is in a TOPMOST window
    //

    _hwnd = CreateWindowEx(
#ifdef UNIX
                WS_EX_MW_UNMANAGED_WINDOW,
#else
                fTopMost ? WS_EX_TOPMOST : 0,
#endif
                TOOLTIPS_CLASS,
                NULL,
                fTopMost ? WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP : TTS_NOPREFIX,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                10,
                10,
                hwnd,
                NULL,
                g_hInstCore,
                NULL);

    if (_hwnd == NULL)
    {
        TraceTag((tagTooltip, "CTooltip::Init failed (%x)", hwnd));
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    SendMessage(_hwnd, TTM_SETMAXTIPWIDTH, 0, (LPARAM) (INT) 3*g_uiDisplay.GetResolution().cx);

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::Show
//
//  Synopsis:   Displays the Tooltip.
//
//  Arguments:  szText      Text to display in the Tooltip
//              hwnd        Owner hwnd
//              msg         Message passed to tooltip for precessing
//              prc         Coords of rectangle in which the mouse
//                          should reside to display the Tooltip.  If the
//                          mouse moves out of this rect, the Tooltip will
//                          be brought down.
//              dwCookie    Any value that is used to identify a tooltip
//                          source.  If subsequent calls to FormsShowTooltip
//                          have the same dwCookie, the tooltip isn't
//                          redisplayed (avoiding flashing).  This value
//                          could be a pointer to the source's this ptr,
//                          an index, etc.
//              fRTL        COMPLEXSCRIPT flag indicating if the element
//                          lays out weak/neutral characters right to left
//
//--------------------------------------------------------------------------

void
CTooltip::Show(
    TCHAR * szText,
    HWND hwnd,
    MSG msg,
    RECT * prc,
    DWORD_PTR dwMarkupCookie,
    DWORD_PTR dwCookie,
    BOOL fRTL) // COMPLEXSCRIPT - text is right-to-left reading
{
    TraceTag((tagTooltip, "CTooltip::Show (_hwndOwner:%x; hwnd:%x; dwCookie:%x; msg:%x)", _hwndOwner, hwnd, dwCookie, msg.message));

    // If owner window is diffrent, 
    // create new tooltip window
    if (_hwndOwner != hwnd)
    {
        TraceTag((tagTooltip, "Creating new window _hwndOwner:%x; hwnd:%x; msg:%x", _hwndOwner, hwnd, msg.message));

        if (IsWindow(_hwnd))
            DestroyWindow(_hwnd);

        if (Init(hwnd) != S_OK)
            return;
    }

    // if tool source is different, cookie is different,
    // tooltip text is different, or rectangle is different,
    // delete old tool and create new tool.
    // NOTE: Since pElement is used as the cookie, and multiline elements
    // have disjoint rects, the tooltip will disappear between lines.
    // This doesn't look too annoying. (jbeda)
    if (   _hwndOwner != hwnd
        || _dwCookie != dwCookie 
        || _tcscmp(_cstrText, szText)
        || !EqualRect(prc, &_ti.rect))
    {
        if (_ti.cbSize == sizeof(_ti))
        {
#ifdef UNIX
            SendMessageA(_hwnd, TTM_DELTOOLA, 0, (LPARAM)&_ti);
#else
            SendMessage(_hwnd, TTM_DELTOOL, 0, (LPARAM)&_ti);
#endif
        }

        memset(&_ti, 0, sizeof(_ti));

        // Update text
        _cstrText.Set(szText, _tcslen(szText));

        _ti.cbSize = sizeof(_ti);
        _ti.uFlags = (fRTL ? TTF_RTLREADING | TTF_RIGHT : 0);
        _ti.hwnd = hwnd;
        _ti.uId = (UINT_PTR)dwCookie;
        _ti.rect.left = prc->left;
        _ti.rect.top = prc->top;
        _ti.rect.right = prc->right;
        _ti.rect.bottom = prc->bottom;

#ifdef UNIX
        _ti.lpszText = new char[_tcslen(szText) + 1];

        if ( NULL == _ti.lpszText )
            return;

        WideCharToMultiByte(CP_ACP, NULL, 
                            szText, -1, 
                            _ti.lpszText, _tcslen(szText), 
                            NULL, NULL);
        _ti.lpszText[_tcslen(szText)] = '\0';
        SendMessageA(_hwnd, TTM_ADDTOOLA, 0, (LPARAM)&_ti);

        delete []_ti.lpszText;
        _ti.lpszText = NULL;
#else
        _ti.lpszText = _cstrText;
        SendMessage(_hwnd, TTM_ADDTOOL, 0, (LPARAM)&_ti);
#endif
    }

    SendMessage(_hwnd, TTM_RELAYEVENT, 0, (LPARAM)&msg);
    SendMessage(_hwnd, TTM_ACTIVATE, (WPARAM) (BOOL) TRUE, 0);

    _hwndOwner      = hwnd;
    _dwMarkupCookie = dwMarkupCookie;
    _dwCookie       = dwCookie;
}


//+-------------------------------------------------------------------------
//
//  Method:     CTooltip::Hide
//
//  Synopsis:   Hides the Tooltip window.
//
//--------------------------------------------------------------------------

void
CTooltip::Hide(DWORD_PTR dwMarkupCookie /* = NULL */)
{
    if (!dwMarkupCookie || (_dwMarkupCookie == dwMarkupCookie) )
    {
        TraceTag((tagTooltip, "CTooltip::Hide"));
        SendMessage(_hwnd, TTM_ACTIVATE, (WPARAM) (BOOL) FALSE, 0);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   EnsureInit
//
//  Synopsis:   Static helper for initializing the tooltip code.
//
//--------------------------------------------------------------------------

static HRESULT
EnsureInit(void)
{
    THREADSTATE *   pts;
    HRESULT         hr = S_OK;

    pts = GetThreadState();

    if (pts->pTT == NULL)
    {
        pts->pTT = new CTooltip;
        if (!pts->pTT)
        {
            Assert(0 && "Failed to create Tooltip object.");
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     FormsShowTooltip
//
//  Synopsis:   Displays the Tooltip.
//
//  Arguments:  szText      Text to display in the Tooltip
//              hwnd        Owner hwnd
//              msg         Message passed to tooltip for precessing
//              prc         Coords of rectangle in which the mouse
//                          should reside to display the Tooltip.  If the
//                          mouse moves out of this rect, the Tooltip will
//                          be brought down.
//              dwCookie    Any value that is used to identify a tooltip
//                          source.  If subsequent calls to FormsShowTooltip
//                          have the same dwCookie, the tooltip isn't
//                          redisplayed (avoiding flashing).  This value
//                          could be a pointer to the source's this ptr,
//                          an index, etc.
//              fRTL        COMPLEXSCRIPT flag indicating if the element
//                          lays out weak/neutral characters right to left
//
//--------------------------------------------------------------------------

void
FormsShowTooltip(
    TCHAR * szText,
    HWND hwnd,
    MSG msg,
    RECT * prc,
    DWORD_PTR dwMarkupCookie,
    DWORD_PTR dwCookie,
    BOOL fRTL)
{
    HRESULT hr;

    hr = EnsureInit();
    if (hr)
        return;

    TLS(pTT)->Show(szText, hwnd, msg,  prc, dwMarkupCookie, dwCookie, fRTL);
}


//+-------------------------------------------------------------------------
//
//  Method:     FormsHideTooltip
//
//  Synopsis:   Forces the Tooltip to be brought down.
//
//  Arguments:  [fReset]    If true, cause the tooltip code to reset
//                          the cookie value.  Use FALSE, for example, when
//                          you dismiss the tooltip due to a click.  In this
//                          case you wouldn't want the tooltip to reappear
//                          if the mouse is still in the region.
//
//--------------------------------------------------------------------------

void
FormsHideTooltip(DWORD_PTR dwMarkupCookie /* = NULL */)
{
    if (TLS(pTT))
    {
        TLS(pTT)->Hide(dwMarkupCookie);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     FormsTooltipMessage
//
//  Synopsis:   Allows the tooltip code to dismiss the tooltip based on
//              a window message.  Centralizing the code here keeps clients
//              from having to remember the dismissal rules themselves.
//
//  Returns:    TRUE if the message type is one that would dismiss the
//              tooltip.
//
//--------------------------------------------------------------------------

BOOL
FormsTooltipMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHide = FALSE;

    switch (msg)
    {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:

    case WM_KEYUP:
    case WM_KEYDOWN:
    case WM_CONTEXTMENU:
#if !defined(UNIX)
    case WM_MOUSEWHEEL:
#endif 
        fHide = TRUE;
        break;

    case WM_SETCURSOR:
        switch (HIWORD(lParam))
        {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            fHide = TRUE;
            break;

        default:
            break;
        }

    default:
        break;
    }

    if (fHide)
    {
        TraceTag((tagTooltip, "FormsTooltipMessage (msg:%x)", msg));
        FormsHideTooltip();
    }

    return fHide;
}



//+-------------------------------------------------------------------------
//
//  Function:   DeinitTooltip
//
//--------------------------------------------------------------------------
void
DeinitTooltip(
    THREADSTATE *   pts)
{
    Assert(pts);

    if (pts->pTT)
    {
        delete pts->pTT;
        pts->pTT = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\triapi.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_TRIAPI_HXX_
#define X_TRIAPI_HXX_
#include "triapi.hxx"
#endif

MtDefine(CTridentAPI, ObjectModel, "CTridentAPI")


HRESULT InternalShowModalDialog( HTMLDLGINFO * pdlgInfo );

CTridentAPI::CTridentAPI()
{
    _ulRefs = 1;
}

STDMETHODIMP CTridentAPI::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr;
    
    if ((IID_IHostDialogHelper == riid) || (IID_IUnknown == riid))
    {
        *ppvObj = (IHostDialogHelper *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObj = NULL;
    }

    return hr;
}

STDMETHODIMP CTridentAPI::ShowHTMLDialog(
                                         HWND hwndParent,
                                         IMoniker *pMk,
                                         VARIANT *pvarArgIn,
                                         WCHAR *pchOptions,
                                         VARIANT *pvarArgOut,
                                         IUnknown *punkHost
                                         )
{
    HTMLDLGINFO dlginfo;
    VARIANT     varOptionStr;

    dlginfo.hwndParent = hwndParent;
    dlginfo.pmk = pMk;
    dlginfo.pvarArgIn = pvarArgIn;

    dlginfo.pvarOptions = &varOptionStr;
    V_BSTR(dlginfo.pvarOptions) = pchOptions;       // fake the variant.
    V_VT(dlginfo.pvarOptions) = VT_BSTR;

    dlginfo.pvarArgOut = pvarArgOut;
    dlginfo.fModeless = FALSE;
    dlginfo.punkHost = punkHost;


    // create modal and trusted dialog
    return InternalShowModalDialog( &dlginfo );  
}


//+------------------------------------------------------------------------
//
//  Function:   CreateTridentAPI
//
//  Synopsis:   Creates a new Trident API helper object to avoid lots of
//              pesky exports.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CreateTridentAPI(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    HRESULT hr;
    
    if (NULL == pUnkOuter)
    {
        CTridentAPI *pTriAPI = new CTridentAPI;

        *ppUnk = pTriAPI;

        hr = pTriAPI ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        *ppUnk = NULL;
        hr = CLASS_E_NOAGGREGATION;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\thunks_s.h ===
// THUNK_S_<line number> ( <n> ), where linenum is 1-20 and n is 16-199

THUNK_S_1(16)
THUNK_S_2(16)
THUNK_S_3(16)
THUNK_S_4(16)
THUNK_S_5(16)
THUNK_S_6(16)
THUNK_S_7(16)
THUNK_S_8(16)
THUNK_S_9(16)
THUNK_S_10(16)
THUNK_S_11(16)
THUNK_S_12(16)
THUNK_S_13(16)
THUNK_S_14(16)
THUNK_S_15(16)
THUNK_S_16(16)
THUNK_S_17(16)
THUNK_S_18(16)
THUNK_S_19(16)
THUNK_S_20(16)
THUNK_S_1(17)
THUNK_S_2(17)
THUNK_S_3(17)
THUNK_S_4(17)
THUNK_S_5(17)
THUNK_S_6(17)
THUNK_S_7(17)
THUNK_S_8(17)
THUNK_S_9(17)
THUNK_S_10(17)
THUNK_S_11(17)
THUNK_S_12(17)
THUNK_S_13(17)
THUNK_S_14(17)
THUNK_S_15(17)
THUNK_S_16(17)
THUNK_S_17(17)
THUNK_S_18(17)
THUNK_S_19(17)
THUNK_S_20(17)
THUNK_S_1(18)
THUNK_S_2(18)
THUNK_S_3(18)
THUNK_S_4(18)
THUNK_S_5(18)
THUNK_S_6(18)
THUNK_S_7(18)
THUNK_S_8(18)
THUNK_S_9(18)
THUNK_S_10(18)
THUNK_S_11(18)
THUNK_S_12(18)
THUNK_S_13(18)
THUNK_S_14(18)
THUNK_S_15(18)
THUNK_S_16(18)
THUNK_S_17(18)
THUNK_S_18(18)
THUNK_S_19(18)
THUNK_S_20(18)
THUNK_S_1(19)
THUNK_S_2(19)
THUNK_S_3(19)
THUNK_S_4(19)
THUNK_S_5(19)
THUNK_S_6(19)
THUNK_S_7(19)
THUNK_S_8(19)
THUNK_S_9(19)
THUNK_S_10(19)
THUNK_S_11(19)
THUNK_S_12(19)
THUNK_S_13(19)
THUNK_S_14(19)
THUNK_S_15(19)
THUNK_S_16(19)
THUNK_S_17(19)
THUNK_S_18(19)
THUNK_S_19(19)
THUNK_S_20(19)
THUNK_S_1(20)
THUNK_S_2(20)
THUNK_S_3(20)
THUNK_S_4(20)
THUNK_S_5(20)
THUNK_S_6(20)
THUNK_S_7(20)
THUNK_S_8(20)
THUNK_S_9(20)
THUNK_S_10(20)
THUNK_S_11(20)
THUNK_S_12(20)
THUNK_S_13(20)
THUNK_S_14(20)
THUNK_S_15(20)
THUNK_S_16(20)
THUNK_S_17(20)
THUNK_S_18(20)
THUNK_S_19(20)
THUNK_S_20(20)
THUNK_S_1(21)
THUNK_S_2(21)
THUNK_S_3(21)
THUNK_S_4(21)
THUNK_S_5(21)
THUNK_S_6(21)
THUNK_S_7(21)
THUNK_S_8(21)
THUNK_S_9(21)
THUNK_S_10(21)
THUNK_S_11(21)
THUNK_S_12(21)
THUNK_S_13(21)
THUNK_S_14(21)
THUNK_S_15(21)
THUNK_S_16(21)
THUNK_S_17(21)
THUNK_S_18(21)
THUNK_S_19(21)
THUNK_S_20(21)
THUNK_S_1(22)
THUNK_S_2(22)
THUNK_S_3(22)
THUNK_S_4(22)
THUNK_S_5(22)
THUNK_S_6(22)
THUNK_S_7(22)
THUNK_S_8(22)
THUNK_S_9(22)
THUNK_S_10(22)
THUNK_S_11(22)
THUNK_S_12(22)
THUNK_S_13(22)
THUNK_S_14(22)
THUNK_S_15(22)
THUNK_S_16(22)
THUNK_S_17(22)
THUNK_S_18(22)
THUNK_S_19(22)
THUNK_S_20(22)
THUNK_S_1(23)
THUNK_S_2(23)
THUNK_S_3(23)
THUNK_S_4(23)
THUNK_S_5(23)
THUNK_S_6(23)
THUNK_S_7(23)
THUNK_S_8(23)
THUNK_S_9(23)
THUNK_S_10(23)
THUNK_S_11(23)
THUNK_S_12(23)
THUNK_S_13(23)
THUNK_S_14(23)
THUNK_S_15(23)
THUNK_S_16(23)
THUNK_S_17(23)
THUNK_S_18(23)
THUNK_S_19(23)
THUNK_S_20(23)
THUNK_S_1(24)
THUNK_S_2(24)
THUNK_S_3(24)
THUNK_S_4(24)
THUNK_S_5(24)
THUNK_S_6(24)
THUNK_S_7(24)
THUNK_S_8(24)
THUNK_S_9(24)
THUNK_S_10(24)
THUNK_S_11(24)
THUNK_S_12(24)
THUNK_S_13(24)
THUNK_S_14(24)
THUNK_S_15(24)
THUNK_S_16(24)
THUNK_S_17(24)
THUNK_S_18(24)
THUNK_S_19(24)
THUNK_S_20(24)
THUNK_S_1(25)
THUNK_S_2(25)
THUNK_S_3(25)
THUNK_S_4(25)
THUNK_S_5(25)
THUNK_S_6(25)
THUNK_S_7(25)
THUNK_S_8(25)
THUNK_S_9(25)
THUNK_S_10(25)
THUNK_S_11(25)
THUNK_S_12(25)
THUNK_S_13(25)
THUNK_S_14(25)
THUNK_S_15(25)
THUNK_S_16(25)
THUNK_S_17(25)
THUNK_S_18(25)
THUNK_S_19(25)
THUNK_S_20(25)
THUNK_S_1(26)
THUNK_S_2(26)
THUNK_S_3(26)
THUNK_S_4(26)
THUNK_S_5(26)
THUNK_S_6(26)
THUNK_S_7(26)
THUNK_S_8(26)
THUNK_S_9(26)
THUNK_S_10(26)
THUNK_S_11(26)
THUNK_S_12(26)
THUNK_S_13(26)
THUNK_S_14(26)
THUNK_S_15(26)
THUNK_S_16(26)
THUNK_S_17(26)
THUNK_S_18(26)
THUNK_S_19(26)
THUNK_S_20(26)
THUNK_S_1(27)
THUNK_S_2(27)
THUNK_S_3(27)
THUNK_S_4(27)
THUNK_S_5(27)
THUNK_S_6(27)
THUNK_S_7(27)
THUNK_S_8(27)
THUNK_S_9(27)
THUNK_S_10(27)
THUNK_S_11(27)
THUNK_S_12(27)
THUNK_S_13(27)
THUNK_S_14(27)
THUNK_S_15(27)
THUNK_S_16(27)
THUNK_S_17(27)
THUNK_S_18(27)
THUNK_S_19(27)
THUNK_S_20(27)
THUNK_S_1(28)
THUNK_S_2(28)
THUNK_S_3(28)
THUNK_S_4(28)
THUNK_S_5(28)
THUNK_S_6(28)
THUNK_S_7(28)
THUNK_S_8(28)
THUNK_S_9(28)
THUNK_S_10(28)
THUNK_S_11(28)
THUNK_S_12(28)
THUNK_S_13(28)
THUNK_S_14(28)
THUNK_S_15(28)
THUNK_S_16(28)
THUNK_S_17(28)
THUNK_S_18(28)
THUNK_S_19(28)
THUNK_S_20(28)
THUNK_S_1(29)
THUNK_S_2(29)
THUNK_S_3(29)
THUNK_S_4(29)
THUNK_S_5(29)
THUNK_S_6(29)
THUNK_S_7(29)
THUNK_S_8(29)
THUNK_S_9(29)
THUNK_S_10(29)
THUNK_S_11(29)
THUNK_S_12(29)
THUNK_S_13(29)
THUNK_S_14(29)
THUNK_S_15(29)
THUNK_S_16(29)
THUNK_S_17(29)
THUNK_S_18(29)
THUNK_S_19(29)
THUNK_S_20(29)
THUNK_S_1(30)
THUNK_S_2(30)
THUNK_S_3(30)
THUNK_S_4(30)
THUNK_S_5(30)
THUNK_S_6(30)
THUNK_S_7(30)
THUNK_S_8(30)
THUNK_S_9(30)
THUNK_S_10(30)
THUNK_S_11(30)
THUNK_S_12(30)
THUNK_S_13(30)
THUNK_S_14(30)
THUNK_S_15(30)
THUNK_S_16(30)
THUNK_S_17(30)
THUNK_S_18(30)
THUNK_S_19(30)
THUNK_S_20(30)
THUNK_S_1(31)
THUNK_S_2(31)
THUNK_S_3(31)
THUNK_S_4(31)
THUNK_S_5(31)
THUNK_S_6(31)
THUNK_S_7(31)
THUNK_S_8(31)
THUNK_S_9(31)
THUNK_S_10(31)
THUNK_S_11(31)
THUNK_S_12(31)
THUNK_S_13(31)
THUNK_S_14(31)
THUNK_S_15(31)
THUNK_S_16(31)
THUNK_S_17(31)
THUNK_S_18(31)
THUNK_S_19(31)
THUNK_S_20(31)
THUNK_S_1(32)
THUNK_S_2(32)
THUNK_S_3(32)
THUNK_S_4(32)
THUNK_S_5(32)
THUNK_S_6(32)
THUNK_S_7(32)
THUNK_S_8(32)
THUNK_S_9(32)
THUNK_S_10(32)
THUNK_S_11(32)
THUNK_S_12(32)
THUNK_S_13(32)
THUNK_S_14(32)
THUNK_S_15(32)
THUNK_S_16(32)
THUNK_S_17(32)
THUNK_S_18(32)
THUNK_S_19(32)
THUNK_S_20(32)
THUNK_S_1(33)
THUNK_S_2(33)
THUNK_S_3(33)
THUNK_S_4(33)
THUNK_S_5(33)
THUNK_S_6(33)
THUNK_S_7(33)
THUNK_S_8(33)
THUNK_S_9(33)
THUNK_S_10(33)
THUNK_S_11(33)
THUNK_S_12(33)
THUNK_S_13(33)
THUNK_S_14(33)
THUNK_S_15(33)
THUNK_S_16(33)
THUNK_S_17(33)
THUNK_S_18(33)
THUNK_S_19(33)
THUNK_S_20(33)
THUNK_S_1(34)
THUNK_S_2(34)
THUNK_S_3(34)
THUNK_S_4(34)
THUNK_S_5(34)
THUNK_S_6(34)
THUNK_S_7(34)
THUNK_S_8(34)
THUNK_S_9(34)
THUNK_S_10(34)
THUNK_S_11(34)
THUNK_S_12(34)
THUNK_S_13(34)
THUNK_S_14(34)
THUNK_S_15(34)
THUNK_S_16(34)
THUNK_S_17(34)
THUNK_S_18(34)
THUNK_S_19(34)
THUNK_S_20(34)
THUNK_S_1(35)
THUNK_S_2(35)
THUNK_S_3(35)
THUNK_S_4(35)
THUNK_S_5(35)
THUNK_S_6(35)
THUNK_S_7(35)
THUNK_S_8(35)
THUNK_S_9(35)
THUNK_S_10(35)
THUNK_S_11(35)
THUNK_S_12(35)
THUNK_S_13(35)
THUNK_S_14(35)
THUNK_S_15(35)
THUNK_S_16(35)
THUNK_S_17(35)
THUNK_S_18(35)
THUNK_S_19(35)
THUNK_S_20(35)
THUNK_S_1(36)
THUNK_S_2(36)
THUNK_S_3(36)
THUNK_S_4(36)
THUNK_S_5(36)
THUNK_S_6(36)
THUNK_S_7(36)
THUNK_S_8(36)
THUNK_S_9(36)
THUNK_S_10(36)
THUNK_S_11(36)
THUNK_S_12(36)
THUNK_S_13(36)
THUNK_S_14(36)
THUNK_S_15(36)
THUNK_S_16(36)
THUNK_S_17(36)
THUNK_S_18(36)
THUNK_S_19(36)
THUNK_S_20(36)
THUNK_S_1(37)
THUNK_S_2(37)
THUNK_S_3(37)
THUNK_S_4(37)
THUNK_S_5(37)
THUNK_S_6(37)
THUNK_S_7(37)
THUNK_S_8(37)
THUNK_S_9(37)
THUNK_S_10(37)
THUNK_S_11(37)
THUNK_S_12(37)
THUNK_S_13(37)
THUNK_S_14(37)
THUNK_S_15(37)
THUNK_S_16(37)
THUNK_S_17(37)
THUNK_S_18(37)
THUNK_S_19(37)
THUNK_S_20(37)
THUNK_S_1(38)
THUNK_S_2(38)
THUNK_S_3(38)
THUNK_S_4(38)
THUNK_S_5(38)
THUNK_S_6(38)
THUNK_S_7(38)
THUNK_S_8(38)
THUNK_S_9(38)
THUNK_S_10(38)
THUNK_S_11(38)
THUNK_S_12(38)
THUNK_S_13(38)
THUNK_S_14(38)
THUNK_S_15(38)
THUNK_S_16(38)
THUNK_S_17(38)
THUNK_S_18(38)
THUNK_S_19(38)
THUNK_S_20(38)
THUNK_S_1(39)
THUNK_S_2(39)
THUNK_S_3(39)
THUNK_S_4(39)
THUNK_S_5(39)
THUNK_S_6(39)
THUNK_S_7(39)
THUNK_S_8(39)
THUNK_S_9(39)
THUNK_S_10(39)
THUNK_S_11(39)
THUNK_S_12(39)
THUNK_S_13(39)
THUNK_S_14(39)
THUNK_S_15(39)
THUNK_S_16(39)
THUNK_S_17(39)
THUNK_S_18(39)
THUNK_S_19(39)
THUNK_S_20(39)
THUNK_S_1(40)
THUNK_S_2(40)
THUNK_S_3(40)
THUNK_S_4(40)
THUNK_S_5(40)
THUNK_S_6(40)
THUNK_S_7(40)
THUNK_S_8(40)
THUNK_S_9(40)
THUNK_S_10(40)
THUNK_S_11(40)
THUNK_S_12(40)
THUNK_S_13(40)
THUNK_S_14(40)
THUNK_S_15(40)
THUNK_S_16(40)
THUNK_S_17(40)
THUNK_S_18(40)
THUNK_S_19(40)
THUNK_S_20(40)
THUNK_S_1(41)
THUNK_S_2(41)
THUNK_S_3(41)
THUNK_S_4(41)
THUNK_S_5(41)
THUNK_S_6(41)
THUNK_S_7(41)
THUNK_S_8(41)
THUNK_S_9(41)
THUNK_S_10(41)
THUNK_S_11(41)
THUNK_S_12(41)
THUNK_S_13(41)
THUNK_S_14(41)
THUNK_S_15(41)
THUNK_S_16(41)
THUNK_S_17(41)
THUNK_S_18(41)
THUNK_S_19(41)
THUNK_S_20(41)
THUNK_S_1(42)
THUNK_S_2(42)
THUNK_S_3(42)
THUNK_S_4(42)
THUNK_S_5(42)
THUNK_S_6(42)
THUNK_S_7(42)
THUNK_S_8(42)
THUNK_S_9(42)
THUNK_S_10(42)
THUNK_S_11(42)
THUNK_S_12(42)
THUNK_S_13(42)
THUNK_S_14(42)
THUNK_S_15(42)
THUNK_S_16(42)
THUNK_S_17(42)
THUNK_S_18(42)
THUNK_S_19(42)
THUNK_S_20(42)
THUNK_S_1(43)
THUNK_S_2(43)
THUNK_S_3(43)
THUNK_S_4(43)
THUNK_S_5(43)
THUNK_S_6(43)
THUNK_S_7(43)
THUNK_S_8(43)
THUNK_S_9(43)
THUNK_S_10(43)
THUNK_S_11(43)
THUNK_S_12(43)
THUNK_S_13(43)
THUNK_S_14(43)
THUNK_S_15(43)
THUNK_S_16(43)
THUNK_S_17(43)
THUNK_S_18(43)
THUNK_S_19(43)
THUNK_S_20(43)
THUNK_S_1(44)
THUNK_S_2(44)
THUNK_S_3(44)
THUNK_S_4(44)
THUNK_S_5(44)
THUNK_S_6(44)
THUNK_S_7(44)
THUNK_S_8(44)
THUNK_S_9(44)
THUNK_S_10(44)
THUNK_S_11(44)
THUNK_S_12(44)
THUNK_S_13(44)
THUNK_S_14(44)
THUNK_S_15(44)
THUNK_S_16(44)
THUNK_S_17(44)
THUNK_S_18(44)
THUNK_S_19(44)
THUNK_S_20(44)
THUNK_S_1(45)
THUNK_S_2(45)
THUNK_S_3(45)
THUNK_S_4(45)
THUNK_S_5(45)
THUNK_S_6(45)
THUNK_S_7(45)
THUNK_S_8(45)
THUNK_S_9(45)
THUNK_S_10(45)
THUNK_S_11(45)
THUNK_S_12(45)
THUNK_S_13(45)
THUNK_S_14(45)
THUNK_S_15(45)
THUNK_S_16(45)
THUNK_S_17(45)
THUNK_S_18(45)
THUNK_S_19(45)
THUNK_S_20(45)
THUNK_S_1(46)
THUNK_S_2(46)
THUNK_S_3(46)
THUNK_S_4(46)
THUNK_S_5(46)
THUNK_S_6(46)
THUNK_S_7(46)
THUNK_S_8(46)
THUNK_S_9(46)
THUNK_S_10(46)
THUNK_S_11(46)
THUNK_S_12(46)
THUNK_S_13(46)
THUNK_S_14(46)
THUNK_S_15(46)
THUNK_S_16(46)
THUNK_S_17(46)
THUNK_S_18(46)
THUNK_S_19(46)
THUNK_S_20(46)
THUNK_S_1(47)
THUNK_S_2(47)
THUNK_S_3(47)
THUNK_S_4(47)
THUNK_S_5(47)
THUNK_S_6(47)
THUNK_S_7(47)
THUNK_S_8(47)
THUNK_S_9(47)
THUNK_S_10(47)
THUNK_S_11(47)
THUNK_S_12(47)
THUNK_S_13(47)
THUNK_S_14(47)
THUNK_S_15(47)
THUNK_S_16(47)
THUNK_S_17(47)
THUNK_S_18(47)
THUNK_S_19(47)
THUNK_S_20(47)
THUNK_S_1(48)
THUNK_S_2(48)
THUNK_S_3(48)
THUNK_S_4(48)
THUNK_S_5(48)
THUNK_S_6(48)
THUNK_S_7(48)
THUNK_S_8(48)
THUNK_S_9(48)
THUNK_S_10(48)
THUNK_S_11(48)
THUNK_S_12(48)
THUNK_S_13(48)
THUNK_S_14(48)
THUNK_S_15(48)
THUNK_S_16(48)
THUNK_S_17(48)
THUNK_S_18(48)
THUNK_S_19(48)
THUNK_S_20(48)
THUNK_S_1(49)
THUNK_S_2(49)
THUNK_S_3(49)
THUNK_S_4(49)
THUNK_S_5(49)
THUNK_S_6(49)
THUNK_S_7(49)
THUNK_S_8(49)
THUNK_S_9(49)
THUNK_S_10(49)
THUNK_S_11(49)
THUNK_S_12(49)
THUNK_S_13(49)
THUNK_S_14(49)
THUNK_S_15(49)
THUNK_S_16(49)
THUNK_S_17(49)
THUNK_S_18(49)
THUNK_S_19(49)
THUNK_S_20(49)
THUNK_S_1(50)
THUNK_S_2(50)
THUNK_S_3(50)
THUNK_S_4(50)
THUNK_S_5(50)
THUNK_S_6(50)
THUNK_S_7(50)
THUNK_S_8(50)
THUNK_S_9(50)
THUNK_S_10(50)
THUNK_S_11(50)
THUNK_S_12(50)
THUNK_S_13(50)
THUNK_S_14(50)
THUNK_S_15(50)
THUNK_S_16(50)
THUNK_S_17(50)
THUNK_S_18(50)
THUNK_S_19(50)
THUNK_S_20(50)
THUNK_S_1(51)
THUNK_S_2(51)
THUNK_S_3(51)
THUNK_S_4(51)
THUNK_S_5(51)
THUNK_S_6(51)
THUNK_S_7(51)
THUNK_S_8(51)
THUNK_S_9(51)
THUNK_S_10(51)
THUNK_S_11(51)
THUNK_S_12(51)
THUNK_S_13(51)
THUNK_S_14(51)
THUNK_S_15(51)
THUNK_S_16(51)
THUNK_S_17(51)
THUNK_S_18(51)
THUNK_S_19(51)
THUNK_S_20(51)
THUNK_S_1(52)
THUNK_S_2(52)
THUNK_S_3(52)
THUNK_S_4(52)
THUNK_S_5(52)
THUNK_S_6(52)
THUNK_S_7(52)
THUNK_S_8(52)
THUNK_S_9(52)
THUNK_S_10(52)
THUNK_S_11(52)
THUNK_S_12(52)
THUNK_S_13(52)
THUNK_S_14(52)
THUNK_S_15(52)
THUNK_S_16(52)
THUNK_S_17(52)
THUNK_S_18(52)
THUNK_S_19(52)
THUNK_S_20(52)
THUNK_S_1(53)
THUNK_S_2(53)
THUNK_S_3(53)
THUNK_S_4(53)
THUNK_S_5(53)
THUNK_S_6(53)
THUNK_S_7(53)
THUNK_S_8(53)
THUNK_S_9(53)
THUNK_S_10(53)
THUNK_S_11(53)
THUNK_S_12(53)
THUNK_S_13(53)
THUNK_S_14(53)
THUNK_S_15(53)
THUNK_S_16(53)
THUNK_S_17(53)
THUNK_S_18(53)
THUNK_S_19(53)
THUNK_S_20(53)
THUNK_S_1(54)
THUNK_S_2(54)
THUNK_S_3(54)
THUNK_S_4(54)
THUNK_S_5(54)
THUNK_S_6(54)
THUNK_S_7(54)
THUNK_S_8(54)
THUNK_S_9(54)
THUNK_S_10(54)
THUNK_S_11(54)
THUNK_S_12(54)
THUNK_S_13(54)
THUNK_S_14(54)
THUNK_S_15(54)
THUNK_S_16(54)
THUNK_S_17(54)
THUNK_S_18(54)
THUNK_S_19(54)
THUNK_S_20(54)
THUNK_S_1(55)
THUNK_S_2(55)
THUNK_S_3(55)
THUNK_S_4(55)
THUNK_S_5(55)
THUNK_S_6(55)
THUNK_S_7(55)
THUNK_S_8(55)
THUNK_S_9(55)
THUNK_S_10(55)
THUNK_S_11(55)
THUNK_S_12(55)
THUNK_S_13(55)
THUNK_S_14(55)
THUNK_S_15(55)
THUNK_S_16(55)
THUNK_S_17(55)
THUNK_S_18(55)
THUNK_S_19(55)
THUNK_S_20(55)
THUNK_S_1(56)
THUNK_S_2(56)
THUNK_S_3(56)
THUNK_S_4(56)
THUNK_S_5(56)
THUNK_S_6(56)
THUNK_S_7(56)
THUNK_S_8(56)
THUNK_S_9(56)
THUNK_S_10(56)
THUNK_S_11(56)
THUNK_S_12(56)
THUNK_S_13(56)
THUNK_S_14(56)
THUNK_S_15(56)
THUNK_S_16(56)
THUNK_S_17(56)
THUNK_S_18(56)
THUNK_S_19(56)
THUNK_S_20(56)
THUNK_S_1(57)
THUNK_S_2(57)
THUNK_S_3(57)
THUNK_S_4(57)
THUNK_S_5(57)
THUNK_S_6(57)
THUNK_S_7(57)
THUNK_S_8(57)
THUNK_S_9(57)
THUNK_S_10(57)
THUNK_S_11(57)
THUNK_S_12(57)
THUNK_S_13(57)
THUNK_S_14(57)
THUNK_S_15(57)
THUNK_S_16(57)
THUNK_S_17(57)
THUNK_S_18(57)
THUNK_S_19(57)
THUNK_S_20(57)
THUNK_S_1(58)
THUNK_S_2(58)
THUNK_S_3(58)
THUNK_S_4(58)
THUNK_S_5(58)
THUNK_S_6(58)
THUNK_S_7(58)
THUNK_S_8(58)
THUNK_S_9(58)
THUNK_S_10(58)
THUNK_S_11(58)
THUNK_S_12(58)
THUNK_S_13(58)
THUNK_S_14(58)
THUNK_S_15(58)
THUNK_S_16(58)
THUNK_S_17(58)
THUNK_S_18(58)
THUNK_S_19(58)
THUNK_S_20(58)
THUNK_S_1(59)
THUNK_S_2(59)
THUNK_S_3(59)
THUNK_S_4(59)
THUNK_S_5(59)
THUNK_S_6(59)
THUNK_S_7(59)
THUNK_S_8(59)
THUNK_S_9(59)
THUNK_S_10(59)
THUNK_S_11(59)
THUNK_S_12(59)
THUNK_S_13(59)
THUNK_S_14(59)
THUNK_S_15(59)
THUNK_S_16(59)
THUNK_S_17(59)
THUNK_S_18(59)
THUNK_S_19(59)
THUNK_S_20(59)
THUNK_S_1(60)
THUNK_S_2(60)
THUNK_S_3(60)
THUNK_S_4(60)
THUNK_S_5(60)
THUNK_S_6(60)
THUNK_S_7(60)
THUNK_S_8(60)
THUNK_S_9(60)
THUNK_S_10(60)
THUNK_S_11(60)
THUNK_S_12(60)
THUNK_S_13(60)
THUNK_S_14(60)
THUNK_S_15(60)
THUNK_S_16(60)
THUNK_S_17(60)
THUNK_S_18(60)
THUNK_S_19(60)
THUNK_S_20(60)
THUNK_S_1(61)
THUNK_S_2(61)
THUNK_S_3(61)
THUNK_S_4(61)
THUNK_S_5(61)
THUNK_S_6(61)
THUNK_S_7(61)
THUNK_S_8(61)
THUNK_S_9(61)
THUNK_S_10(61)
THUNK_S_11(61)
THUNK_S_12(61)
THUNK_S_13(61)
THUNK_S_14(61)
THUNK_S_15(61)
THUNK_S_16(61)
THUNK_S_17(61)
THUNK_S_18(61)
THUNK_S_19(61)
THUNK_S_20(61)
THUNK_S_1(62)
THUNK_S_2(62)
THUNK_S_3(62)
THUNK_S_4(62)
THUNK_S_5(62)
THUNK_S_6(62)
THUNK_S_7(62)
THUNK_S_8(62)
THUNK_S_9(62)
THUNK_S_10(62)
THUNK_S_11(62)
THUNK_S_12(62)
THUNK_S_13(62)
THUNK_S_14(62)
THUNK_S_15(62)
THUNK_S_16(62)
THUNK_S_17(62)
THUNK_S_18(62)
THUNK_S_19(62)
THUNK_S_20(62)
THUNK_S_1(63)
THUNK_S_2(63)
THUNK_S_3(63)
THUNK_S_4(63)
THUNK_S_5(63)
THUNK_S_6(63)
THUNK_S_7(63)
THUNK_S_8(63)
THUNK_S_9(63)
THUNK_S_10(63)
THUNK_S_11(63)
THUNK_S_12(63)
THUNK_S_13(63)
THUNK_S_14(63)
THUNK_S_15(63)
THUNK_S_16(63)
THUNK_S_17(63)
THUNK_S_18(63)
THUNK_S_19(63)
THUNK_S_20(63)
THUNK_S_1(64)
THUNK_S_2(64)
THUNK_S_3(64)
THUNK_S_4(64)
THUNK_S_5(64)
THUNK_S_6(64)
THUNK_S_7(64)
THUNK_S_8(64)
THUNK_S_9(64)
THUNK_S_10(64)
THUNK_S_11(64)
THUNK_S_12(64)
THUNK_S_13(64)
THUNK_S_14(64)
THUNK_S_15(64)
THUNK_S_16(64)
THUNK_S_17(64)
THUNK_S_18(64)
THUNK_S_19(64)
THUNK_S_20(64)
THUNK_S_1(65)
THUNK_S_2(65)
THUNK_S_3(65)
THUNK_S_4(65)
THUNK_S_5(65)
THUNK_S_6(65)
THUNK_S_7(65)
THUNK_S_8(65)
THUNK_S_9(65)
THUNK_S_10(65)
THUNK_S_11(65)
THUNK_S_12(65)
THUNK_S_13(65)
THUNK_S_14(65)
THUNK_S_15(65)
THUNK_S_16(65)
THUNK_S_17(65)
THUNK_S_18(65)
THUNK_S_19(65)
THUNK_S_20(65)
THUNK_S_1(66)
THUNK_S_2(66)
THUNK_S_3(66)
THUNK_S_4(66)
THUNK_S_5(66)
THUNK_S_6(66)
THUNK_S_7(66)
THUNK_S_8(66)
THUNK_S_9(66)
THUNK_S_10(66)
THUNK_S_11(66)
THUNK_S_12(66)
THUNK_S_13(66)
THUNK_S_14(66)
THUNK_S_15(66)
THUNK_S_16(66)
THUNK_S_17(66)
THUNK_S_18(66)
THUNK_S_19(66)
THUNK_S_20(66)
THUNK_S_1(67)
THUNK_S_2(67)
THUNK_S_3(67)
THUNK_S_4(67)
THUNK_S_5(67)
THUNK_S_6(67)
THUNK_S_7(67)
THUNK_S_8(67)
THUNK_S_9(67)
THUNK_S_10(67)
THUNK_S_11(67)
THUNK_S_12(67)
THUNK_S_13(67)
THUNK_S_14(67)
THUNK_S_15(67)
THUNK_S_16(67)
THUNK_S_17(67)
THUNK_S_18(67)
THUNK_S_19(67)
THUNK_S_20(67)
THUNK_S_1(68)
THUNK_S_2(68)
THUNK_S_3(68)
THUNK_S_4(68)
THUNK_S_5(68)
THUNK_S_6(68)
THUNK_S_7(68)
THUNK_S_8(68)
THUNK_S_9(68)
THUNK_S_10(68)
THUNK_S_11(68)
THUNK_S_12(68)
THUNK_S_13(68)
THUNK_S_14(68)
THUNK_S_15(68)
THUNK_S_16(68)
THUNK_S_17(68)
THUNK_S_18(68)
THUNK_S_19(68)
THUNK_S_20(68)
THUNK_S_1(69)
THUNK_S_2(69)
THUNK_S_3(69)
THUNK_S_4(69)
THUNK_S_5(69)
THUNK_S_6(69)
THUNK_S_7(69)
THUNK_S_8(69)
THUNK_S_9(69)
THUNK_S_10(69)
THUNK_S_11(69)
THUNK_S_12(69)
THUNK_S_13(69)
THUNK_S_14(69)
THUNK_S_15(69)
THUNK_S_16(69)
THUNK_S_17(69)
THUNK_S_18(69)
THUNK_S_19(69)
THUNK_S_20(69)
THUNK_S_1(70)
THUNK_S_2(70)
THUNK_S_3(70)
THUNK_S_4(70)
THUNK_S_5(70)
THUNK_S_6(70)
THUNK_S_7(70)
THUNK_S_8(70)
THUNK_S_9(70)
THUNK_S_10(70)
THUNK_S_11(70)
THUNK_S_12(70)
THUNK_S_13(70)
THUNK_S_14(70)
THUNK_S_15(70)
THUNK_S_16(70)
THUNK_S_17(70)
THUNK_S_18(70)
THUNK_S_19(70)
THUNK_S_20(70)
THUNK_S_1(71)
THUNK_S_2(71)
THUNK_S_3(71)
THUNK_S_4(71)
THUNK_S_5(71)
THUNK_S_6(71)
THUNK_S_7(71)
THUNK_S_8(71)
THUNK_S_9(71)
THUNK_S_10(71)
THUNK_S_11(71)
THUNK_S_12(71)
THUNK_S_13(71)
THUNK_S_14(71)
THUNK_S_15(71)
THUNK_S_16(71)
THUNK_S_17(71)
THUNK_S_18(71)
THUNK_S_19(71)
THUNK_S_20(71)
THUNK_S_1(72)
THUNK_S_2(72)
THUNK_S_3(72)
THUNK_S_4(72)
THUNK_S_5(72)
THUNK_S_6(72)
THUNK_S_7(72)
THUNK_S_8(72)
THUNK_S_9(72)
THUNK_S_10(72)
THUNK_S_11(72)
THUNK_S_12(72)
THUNK_S_13(72)
THUNK_S_14(72)
THUNK_S_15(72)
THUNK_S_16(72)
THUNK_S_17(72)
THUNK_S_18(72)
THUNK_S_19(72)
THUNK_S_20(72)
THUNK_S_1(73)
THUNK_S_2(73)
THUNK_S_3(73)
THUNK_S_4(73)
THUNK_S_5(73)
THUNK_S_6(73)
THUNK_S_7(73)
THUNK_S_8(73)
THUNK_S_9(73)
THUNK_S_10(73)
THUNK_S_11(73)
THUNK_S_12(73)
THUNK_S_13(73)
THUNK_S_14(73)
THUNK_S_15(73)
THUNK_S_16(73)
THUNK_S_17(73)
THUNK_S_18(73)
THUNK_S_19(73)
THUNK_S_20(73)
THUNK_S_1(74)
THUNK_S_2(74)
THUNK_S_3(74)
THUNK_S_4(74)
THUNK_S_5(74)
THUNK_S_6(74)
THUNK_S_7(74)
THUNK_S_8(74)
THUNK_S_9(74)
THUNK_S_10(74)
THUNK_S_11(74)
THUNK_S_12(74)
THUNK_S_13(74)
THUNK_S_14(74)
THUNK_S_15(74)
THUNK_S_16(74)
THUNK_S_17(74)
THUNK_S_18(74)
THUNK_S_19(74)
THUNK_S_20(74)
THUNK_S_1(75)
THUNK_S_2(75)
THUNK_S_3(75)
THUNK_S_4(75)
THUNK_S_5(75)
THUNK_S_6(75)
THUNK_S_7(75)
THUNK_S_8(75)
THUNK_S_9(75)
THUNK_S_10(75)
THUNK_S_11(75)
THUNK_S_12(75)
THUNK_S_13(75)
THUNK_S_14(75)
THUNK_S_15(75)
THUNK_S_16(75)
THUNK_S_17(75)
THUNK_S_18(75)
THUNK_S_19(75)
THUNK_S_20(75)
THUNK_S_1(76)
THUNK_S_2(76)
THUNK_S_3(76)
THUNK_S_4(76)
THUNK_S_5(76)
THUNK_S_6(76)
THUNK_S_7(76)
THUNK_S_8(76)
THUNK_S_9(76)
THUNK_S_10(76)
THUNK_S_11(76)
THUNK_S_12(76)
THUNK_S_13(76)
THUNK_S_14(76)
THUNK_S_15(76)
THUNK_S_16(76)
THUNK_S_17(76)
THUNK_S_18(76)
THUNK_S_19(76)
THUNK_S_20(76)
THUNK_S_1(77)
THUNK_S_2(77)
THUNK_S_3(77)
THUNK_S_4(77)
THUNK_S_5(77)
THUNK_S_6(77)
THUNK_S_7(77)
THUNK_S_8(77)
THUNK_S_9(77)
THUNK_S_10(77)
THUNK_S_11(77)
THUNK_S_12(77)
THUNK_S_13(77)
THUNK_S_14(77)
THUNK_S_15(77)
THUNK_S_16(77)
THUNK_S_17(77)
THUNK_S_18(77)
THUNK_S_19(77)
THUNK_S_20(77)
THUNK_S_1(78)
THUNK_S_2(78)
THUNK_S_3(78)
THUNK_S_4(78)
THUNK_S_5(78)
THUNK_S_6(78)
THUNK_S_7(78)
THUNK_S_8(78)
THUNK_S_9(78)
THUNK_S_10(78)
THUNK_S_11(78)
THUNK_S_12(78)
THUNK_S_13(78)
THUNK_S_14(78)
THUNK_S_15(78)
THUNK_S_16(78)
THUNK_S_17(78)
THUNK_S_18(78)
THUNK_S_19(78)
THUNK_S_20(78)
THUNK_S_1(79)
THUNK_S_2(79)
THUNK_S_3(79)
THUNK_S_4(79)
THUNK_S_5(79)
THUNK_S_6(79)
THUNK_S_7(79)
THUNK_S_8(79)
THUNK_S_9(79)
THUNK_S_10(79)
THUNK_S_11(79)
THUNK_S_12(79)
THUNK_S_13(79)
THUNK_S_14(79)
THUNK_S_15(79)
THUNK_S_16(79)
THUNK_S_17(79)
THUNK_S_18(79)
THUNK_S_19(79)
THUNK_S_20(79)
THUNK_S_1(80)
THUNK_S_2(80)
THUNK_S_3(80)
THUNK_S_4(80)
THUNK_S_5(80)
THUNK_S_6(80)
THUNK_S_7(80)
THUNK_S_8(80)
THUNK_S_9(80)
THUNK_S_10(80)
THUNK_S_11(80)
THUNK_S_12(80)
THUNK_S_13(80)
THUNK_S_14(80)
THUNK_S_15(80)
THUNK_S_16(80)
THUNK_S_17(80)
THUNK_S_18(80)
THUNK_S_19(80)
THUNK_S_20(80)
THUNK_S_1(81)
THUNK_S_2(81)
THUNK_S_3(81)
THUNK_S_4(81)
THUNK_S_5(81)
THUNK_S_6(81)
THUNK_S_7(81)
THUNK_S_8(81)
THUNK_S_9(81)
THUNK_S_10(81)
THUNK_S_11(81)
THUNK_S_12(81)
THUNK_S_13(81)
THUNK_S_14(81)
THUNK_S_15(81)
THUNK_S_16(81)
THUNK_S_17(81)
THUNK_S_18(81)
THUNK_S_19(81)
THUNK_S_20(81)
THUNK_S_1(82)
THUNK_S_2(82)
THUNK_S_3(82)
THUNK_S_4(82)
THUNK_S_5(82)
THUNK_S_6(82)
THUNK_S_7(82)
THUNK_S_8(82)
THUNK_S_9(82)
THUNK_S_10(82)
THUNK_S_11(82)
THUNK_S_12(82)
THUNK_S_13(82)
THUNK_S_14(82)
THUNK_S_15(82)
THUNK_S_16(82)
THUNK_S_17(82)
THUNK_S_18(82)
THUNK_S_19(82)
THUNK_S_20(82)
THUNK_S_1(83)
THUNK_S_2(83)
THUNK_S_3(83)
THUNK_S_4(83)
THUNK_S_5(83)
THUNK_S_6(83)
THUNK_S_7(83)
THUNK_S_8(83)
THUNK_S_9(83)
THUNK_S_10(83)
THUNK_S_11(83)
THUNK_S_12(83)
THUNK_S_13(83)
THUNK_S_14(83)
THUNK_S_15(83)
THUNK_S_16(83)
THUNK_S_17(83)
THUNK_S_18(83)
THUNK_S_19(83)
THUNK_S_20(83)
THUNK_S_1(84)
THUNK_S_2(84)
THUNK_S_3(84)
THUNK_S_4(84)
THUNK_S_5(84)
THUNK_S_6(84)
THUNK_S_7(84)
THUNK_S_8(84)
THUNK_S_9(84)
THUNK_S_10(84)
THUNK_S_11(84)
THUNK_S_12(84)
THUNK_S_13(84)
THUNK_S_14(84)
THUNK_S_15(84)
THUNK_S_16(84)
THUNK_S_17(84)
THUNK_S_18(84)
THUNK_S_19(84)
THUNK_S_20(84)
THUNK_S_1(85)
THUNK_S_2(85)
THUNK_S_3(85)
THUNK_S_4(85)
THUNK_S_5(85)
THUNK_S_6(85)
THUNK_S_7(85)
THUNK_S_8(85)
THUNK_S_9(85)
THUNK_S_10(85)
THUNK_S_11(85)
THUNK_S_12(85)
THUNK_S_13(85)
THUNK_S_14(85)
THUNK_S_15(85)
THUNK_S_16(85)
THUNK_S_17(85)
THUNK_S_18(85)
THUNK_S_19(85)
THUNK_S_20(85)
THUNK_S_1(86)
THUNK_S_2(86)
THUNK_S_3(86)
THUNK_S_4(86)
THUNK_S_5(86)
THUNK_S_6(86)
THUNK_S_7(86)
THUNK_S_8(86)
THUNK_S_9(86)
THUNK_S_10(86)
THUNK_S_11(86)
THUNK_S_12(86)
THUNK_S_13(86)
THUNK_S_14(86)
THUNK_S_15(86)
THUNK_S_16(86)
THUNK_S_17(86)
THUNK_S_18(86)
THUNK_S_19(86)
THUNK_S_20(86)
THUNK_S_1(87)
THUNK_S_2(87)
THUNK_S_3(87)
THUNK_S_4(87)
THUNK_S_5(87)
THUNK_S_6(87)
THUNK_S_7(87)
THUNK_S_8(87)
THUNK_S_9(87)
THUNK_S_10(87)
THUNK_S_11(87)
THUNK_S_12(87)
THUNK_S_13(87)
THUNK_S_14(87)
THUNK_S_15(87)
THUNK_S_16(87)
THUNK_S_17(87)
THUNK_S_18(87)
THUNK_S_19(87)
THUNK_S_20(87)
THUNK_S_1(88)
THUNK_S_2(88)
THUNK_S_3(88)
THUNK_S_4(88)
THUNK_S_5(88)
THUNK_S_6(88)
THUNK_S_7(88)
THUNK_S_8(88)
THUNK_S_9(88)
THUNK_S_10(88)
THUNK_S_11(88)
THUNK_S_12(88)
THUNK_S_13(88)
THUNK_S_14(88)
THUNK_S_15(88)
THUNK_S_16(88)
THUNK_S_17(88)
THUNK_S_18(88)
THUNK_S_19(88)
THUNK_S_20(88)
THUNK_S_1(89)
THUNK_S_2(89)
THUNK_S_3(89)
THUNK_S_4(89)
THUNK_S_5(89)
THUNK_S_6(89)
THUNK_S_7(89)
THUNK_S_8(89)
THUNK_S_9(89)
THUNK_S_10(89)
THUNK_S_11(89)
THUNK_S_12(89)
THUNK_S_13(89)
THUNK_S_14(89)
THUNK_S_15(89)
THUNK_S_16(89)
THUNK_S_17(89)
THUNK_S_18(89)
THUNK_S_19(89)
THUNK_S_20(89)
THUNK_S_1(90)
THUNK_S_2(90)
THUNK_S_3(90)
THUNK_S_4(90)
THUNK_S_5(90)
THUNK_S_6(90)
THUNK_S_7(90)
THUNK_S_8(90)
THUNK_S_9(90)
THUNK_S_10(90)
THUNK_S_11(90)
THUNK_S_12(90)
THUNK_S_13(90)
THUNK_S_14(90)
THUNK_S_15(90)
THUNK_S_16(90)
THUNK_S_17(90)
THUNK_S_18(90)
THUNK_S_19(90)
THUNK_S_20(90)
THUNK_S_1(91)
THUNK_S_2(91)
THUNK_S_3(91)
THUNK_S_4(91)
THUNK_S_5(91)
THUNK_S_6(91)
THUNK_S_7(91)
THUNK_S_8(91)
THUNK_S_9(91)
THUNK_S_10(91)
THUNK_S_11(91)
THUNK_S_12(91)
THUNK_S_13(91)
THUNK_S_14(91)
THUNK_S_15(91)
THUNK_S_16(91)
THUNK_S_17(91)
THUNK_S_18(91)
THUNK_S_19(91)
THUNK_S_20(91)
THUNK_S_1(92)
THUNK_S_2(92)
THUNK_S_3(92)
THUNK_S_4(92)
THUNK_S_5(92)
THUNK_S_6(92)
THUNK_S_7(92)
THUNK_S_8(92)
THUNK_S_9(92)
THUNK_S_10(92)
THUNK_S_11(92)
THUNK_S_12(92)
THUNK_S_13(92)
THUNK_S_14(92)
THUNK_S_15(92)
THUNK_S_16(92)
THUNK_S_17(92)
THUNK_S_18(92)
THUNK_S_19(92)
THUNK_S_20(92)
THUNK_S_1(93)
THUNK_S_2(93)
THUNK_S_3(93)
THUNK_S_4(93)
THUNK_S_5(93)
THUNK_S_6(93)
THUNK_S_7(93)
THUNK_S_8(93)
THUNK_S_9(93)
THUNK_S_10(93)
THUNK_S_11(93)
THUNK_S_12(93)
THUNK_S_13(93)
THUNK_S_14(93)
THUNK_S_15(93)
THUNK_S_16(93)
THUNK_S_17(93)
THUNK_S_18(93)
THUNK_S_19(93)
THUNK_S_20(93)
THUNK_S_1(94)
THUNK_S_2(94)
THUNK_S_3(94)
THUNK_S_4(94)
THUNK_S_5(94)
THUNK_S_6(94)
THUNK_S_7(94)
THUNK_S_8(94)
THUNK_S_9(94)
THUNK_S_10(94)
THUNK_S_11(94)
THUNK_S_12(94)
THUNK_S_13(94)
THUNK_S_14(94)
THUNK_S_15(94)
THUNK_S_16(94)
THUNK_S_17(94)
THUNK_S_18(94)
THUNK_S_19(94)
THUNK_S_20(94)
THUNK_S_1(95)
THUNK_S_2(95)
THUNK_S_3(95)
THUNK_S_4(95)
THUNK_S_5(95)
THUNK_S_6(95)
THUNK_S_7(95)
THUNK_S_8(95)
THUNK_S_9(95)
THUNK_S_10(95)
THUNK_S_11(95)
THUNK_S_12(95)
THUNK_S_13(95)
THUNK_S_14(95)
THUNK_S_15(95)
THUNK_S_16(95)
THUNK_S_17(95)
THUNK_S_18(95)
THUNK_S_19(95)
THUNK_S_20(95)
THUNK_S_1(96)
THUNK_S_2(96)
THUNK_S_3(96)
THUNK_S_4(96)
THUNK_S_5(96)
THUNK_S_6(96)
THUNK_S_7(96)
THUNK_S_8(96)
THUNK_S_9(96)
THUNK_S_10(96)
THUNK_S_11(96)
THUNK_S_12(96)
THUNK_S_13(96)
THUNK_S_14(96)
THUNK_S_15(96)
THUNK_S_16(96)
THUNK_S_17(96)
THUNK_S_18(96)
THUNK_S_19(96)
THUNK_S_20(96)
THUNK_S_1(97)
THUNK_S_2(97)
THUNK_S_3(97)
THUNK_S_4(97)
THUNK_S_5(97)
THUNK_S_6(97)
THUNK_S_7(97)
THUNK_S_8(97)
THUNK_S_9(97)
THUNK_S_10(97)
THUNK_S_11(97)
THUNK_S_12(97)
THUNK_S_13(97)
THUNK_S_14(97)
THUNK_S_15(97)
THUNK_S_16(97)
THUNK_S_17(97)
THUNK_S_18(97)
THUNK_S_19(97)
THUNK_S_20(97)
THUNK_S_1(98)
THUNK_S_2(98)
THUNK_S_3(98)
THUNK_S_4(98)
THUNK_S_5(98)
THUNK_S_6(98)
THUNK_S_7(98)
THUNK_S_8(98)
THUNK_S_9(98)
THUNK_S_10(98)
THUNK_S_11(98)
THUNK_S_12(98)
THUNK_S_13(98)
THUNK_S_14(98)
THUNK_S_15(98)
THUNK_S_16(98)
THUNK_S_17(98)
THUNK_S_18(98)
THUNK_S_19(98)
THUNK_S_20(98)
THUNK_S_1(99)
THUNK_S_2(99)
THUNK_S_3(99)
THUNK_S_4(99)
THUNK_S_5(99)
THUNK_S_6(99)
THUNK_S_7(99)
THUNK_S_8(99)
THUNK_S_9(99)
THUNK_S_10(99)
THUNK_S_11(99)
THUNK_S_12(99)
THUNK_S_13(99)
THUNK_S_14(99)
THUNK_S_15(99)
THUNK_S_16(99)
THUNK_S_17(99)
THUNK_S_18(99)
THUNK_S_19(99)
THUNK_S_20(99)
THUNK_S_1(100)
THUNK_S_2(100)
THUNK_S_3(100)
THUNK_S_4(100)
THUNK_S_5(100)
THUNK_S_6(100)
THUNK_S_7(100)
THUNK_S_8(100)
THUNK_S_9(100)
THUNK_S_10(100)
THUNK_S_11(100)
THUNK_S_12(100)
THUNK_S_13(100)
THUNK_S_14(100)
THUNK_S_15(100)
THUNK_S_16(100)
THUNK_S_17(100)
THUNK_S_18(100)
THUNK_S_19(100)
THUNK_S_20(100)
THUNK_S_1(101)
THUNK_S_2(101)
THUNK_S_3(101)
THUNK_S_4(101)
THUNK_S_5(101)
THUNK_S_6(101)
THUNK_S_7(101)
THUNK_S_8(101)
THUNK_S_9(101)
THUNK_S_10(101)
THUNK_S_11(101)
THUNK_S_12(101)
THUNK_S_13(101)
THUNK_S_14(101)
THUNK_S_15(101)
THUNK_S_16(101)
THUNK_S_17(101)
THUNK_S_18(101)
THUNK_S_19(101)
THUNK_S_20(101)
THUNK_S_1(102)
THUNK_S_2(102)
THUNK_S_3(102)
THUNK_S_4(102)
THUNK_S_5(102)
THUNK_S_6(102)
THUNK_S_7(102)
THUNK_S_8(102)
THUNK_S_9(102)
THUNK_S_10(102)
THUNK_S_11(102)
THUNK_S_12(102)
THUNK_S_13(102)
THUNK_S_14(102)
THUNK_S_15(102)
THUNK_S_16(102)
THUNK_S_17(102)
THUNK_S_18(102)
THUNK_S_19(102)
THUNK_S_20(102)
THUNK_S_1(103)
THUNK_S_2(103)
THUNK_S_3(103)
THUNK_S_4(103)
THUNK_S_5(103)
THUNK_S_6(103)
THUNK_S_7(103)
THUNK_S_8(103)
THUNK_S_9(103)
THUNK_S_10(103)
THUNK_S_11(103)
THUNK_S_12(103)
THUNK_S_13(103)
THUNK_S_14(103)
THUNK_S_15(103)
THUNK_S_16(103)
THUNK_S_17(103)
THUNK_S_18(103)
THUNK_S_19(103)
THUNK_S_20(103)
THUNK_S_1(104)
THUNK_S_2(104)
THUNK_S_3(104)
THUNK_S_4(104)
THUNK_S_5(104)
THUNK_S_6(104)
THUNK_S_7(104)
THUNK_S_8(104)
THUNK_S_9(104)
THUNK_S_10(104)
THUNK_S_11(104)
THUNK_S_12(104)
THUNK_S_13(104)
THUNK_S_14(104)
THUNK_S_15(104)
THUNK_S_16(104)
THUNK_S_17(104)
THUNK_S_18(104)
THUNK_S_19(104)
THUNK_S_20(104)
THUNK_S_1(105)
THUNK_S_2(105)
THUNK_S_3(105)
THUNK_S_4(105)
THUNK_S_5(105)
THUNK_S_6(105)
THUNK_S_7(105)
THUNK_S_8(105)
THUNK_S_9(105)
THUNK_S_10(105)
THUNK_S_11(105)
THUNK_S_12(105)
THUNK_S_13(105)
THUNK_S_14(105)
THUNK_S_15(105)
THUNK_S_16(105)
THUNK_S_17(105)
THUNK_S_18(105)
THUNK_S_19(105)
THUNK_S_20(105)
THUNK_S_1(106)
THUNK_S_2(106)
THUNK_S_3(106)
THUNK_S_4(106)
THUNK_S_5(106)
THUNK_S_6(106)
THUNK_S_7(106)
THUNK_S_8(106)
THUNK_S_9(106)
THUNK_S_10(106)
THUNK_S_11(106)
THUNK_S_12(106)
THUNK_S_13(106)
THUNK_S_14(106)
THUNK_S_15(106)
THUNK_S_16(106)
THUNK_S_17(106)
THUNK_S_18(106)
THUNK_S_19(106)
THUNK_S_20(106)
THUNK_S_1(107)
THUNK_S_2(107)
THUNK_S_3(107)
THUNK_S_4(107)
THUNK_S_5(107)
THUNK_S_6(107)
THUNK_S_7(107)
THUNK_S_8(107)
THUNK_S_9(107)
THUNK_S_10(107)
THUNK_S_11(107)
THUNK_S_12(107)
THUNK_S_13(107)
THUNK_S_14(107)
THUNK_S_15(107)
THUNK_S_16(107)
THUNK_S_17(107)
THUNK_S_18(107)
THUNK_S_19(107)
THUNK_S_20(107)
THUNK_S_1(108)
THUNK_S_2(108)
THUNK_S_3(108)
THUNK_S_4(108)
THUNK_S_5(108)
THUNK_S_6(108)
THUNK_S_7(108)
THUNK_S_8(108)
THUNK_S_9(108)
THUNK_S_10(108)
THUNK_S_11(108)
THUNK_S_12(108)
THUNK_S_13(108)
THUNK_S_14(108)
THUNK_S_15(108)
THUNK_S_16(108)
THUNK_S_17(108)
THUNK_S_18(108)
THUNK_S_19(108)
THUNK_S_20(108)
THUNK_S_1(109)
THUNK_S_2(109)
THUNK_S_3(109)
THUNK_S_4(109)
THUNK_S_5(109)
THUNK_S_6(109)
THUNK_S_7(109)
THUNK_S_8(109)
THUNK_S_9(109)
THUNK_S_10(109)
THUNK_S_11(109)
THUNK_S_12(109)
THUNK_S_13(109)
THUNK_S_14(109)
THUNK_S_15(109)
THUNK_S_16(109)
THUNK_S_17(109)
THUNK_S_18(109)
THUNK_S_19(109)
THUNK_S_20(109)
THUNK_S_1(110)
THUNK_S_2(110)
THUNK_S_3(110)
THUNK_S_4(110)
THUNK_S_5(110)
THUNK_S_6(110)
THUNK_S_7(110)
THUNK_S_8(110)
THUNK_S_9(110)
THUNK_S_10(110)
THUNK_S_11(110)
THUNK_S_12(110)
THUNK_S_13(110)
THUNK_S_14(110)
THUNK_S_15(110)
THUNK_S_16(110)
THUNK_S_17(110)
THUNK_S_18(110)
THUNK_S_19(110)
THUNK_S_20(110)
THUNK_S_1(111)
THUNK_S_2(111)
THUNK_S_3(111)
THUNK_S_4(111)
THUNK_S_5(111)
THUNK_S_6(111)
THUNK_S_7(111)
THUNK_S_8(111)
THUNK_S_9(111)
THUNK_S_10(111)
THUNK_S_11(111)
THUNK_S_12(111)
THUNK_S_13(111)
THUNK_S_14(111)
THUNK_S_15(111)
THUNK_S_16(111)
THUNK_S_17(111)
THUNK_S_18(111)
THUNK_S_19(111)
THUNK_S_20(111)
THUNK_S_1(112)
THUNK_S_2(112)
THUNK_S_3(112)
THUNK_S_4(112)
THUNK_S_5(112)
THUNK_S_6(112)
THUNK_S_7(112)
THUNK_S_8(112)
THUNK_S_9(112)
THUNK_S_10(112)
THUNK_S_11(112)
THUNK_S_12(112)
THUNK_S_13(112)
THUNK_S_14(112)
THUNK_S_15(112)
THUNK_S_16(112)
THUNK_S_17(112)
THUNK_S_18(112)
THUNK_S_19(112)
THUNK_S_20(112)
THUNK_S_1(113)
THUNK_S_2(113)
THUNK_S_3(113)
THUNK_S_4(113)
THUNK_S_5(113)
THUNK_S_6(113)
THUNK_S_7(113)
THUNK_S_8(113)
THUNK_S_9(113)
THUNK_S_10(113)
THUNK_S_11(113)
THUNK_S_12(113)
THUNK_S_13(113)
THUNK_S_14(113)
THUNK_S_15(113)
THUNK_S_16(113)
THUNK_S_17(113)
THUNK_S_18(113)
THUNK_S_19(113)
THUNK_S_20(113)
THUNK_S_1(114)
THUNK_S_2(114)
THUNK_S_3(114)
THUNK_S_4(114)
THUNK_S_5(114)
THUNK_S_6(114)
THUNK_S_7(114)
THUNK_S_8(114)
THUNK_S_9(114)
THUNK_S_10(114)
THUNK_S_11(114)
THUNK_S_12(114)
THUNK_S_13(114)
THUNK_S_14(114)
THUNK_S_15(114)
THUNK_S_16(114)
THUNK_S_17(114)
THUNK_S_18(114)
THUNK_S_19(114)
THUNK_S_20(114)
THUNK_S_1(115)
THUNK_S_2(115)
THUNK_S_3(115)
THUNK_S_4(115)
THUNK_S_5(115)
THUNK_S_6(115)
THUNK_S_7(115)
THUNK_S_8(115)
THUNK_S_9(115)
THUNK_S_10(115)
THUNK_S_11(115)
THUNK_S_12(115)
THUNK_S_13(115)
THUNK_S_14(115)
THUNK_S_15(115)
THUNK_S_16(115)
THUNK_S_17(115)
THUNK_S_18(115)
THUNK_S_19(115)
THUNK_S_20(115)
THUNK_S_1(116)
THUNK_S_2(116)
THUNK_S_3(116)
THUNK_S_4(116)
THUNK_S_5(116)
THUNK_S_6(116)
THUNK_S_7(116)
THUNK_S_8(116)
THUNK_S_9(116)
THUNK_S_10(116)
THUNK_S_11(116)
THUNK_S_12(116)
THUNK_S_13(116)
THUNK_S_14(116)
THUNK_S_15(116)
THUNK_S_16(116)
THUNK_S_17(116)
THUNK_S_18(116)
THUNK_S_19(116)
THUNK_S_20(116)
THUNK_S_1(117)
THUNK_S_2(117)
THUNK_S_3(117)
THUNK_S_4(117)
THUNK_S_5(117)
THUNK_S_6(117)
THUNK_S_7(117)
THUNK_S_8(117)
THUNK_S_9(117)
THUNK_S_10(117)
THUNK_S_11(117)
THUNK_S_12(117)
THUNK_S_13(117)
THUNK_S_14(117)
THUNK_S_15(117)
THUNK_S_16(117)
THUNK_S_17(117)
THUNK_S_18(117)
THUNK_S_19(117)
THUNK_S_20(117)
THUNK_S_1(118)
THUNK_S_2(118)
THUNK_S_3(118)
THUNK_S_4(118)
THUNK_S_5(118)
THUNK_S_6(118)
THUNK_S_7(118)
THUNK_S_8(118)
THUNK_S_9(118)
THUNK_S_10(118)
THUNK_S_11(118)
THUNK_S_12(118)
THUNK_S_13(118)
THUNK_S_14(118)
THUNK_S_15(118)
THUNK_S_16(118)
THUNK_S_17(118)
THUNK_S_18(118)
THUNK_S_19(118)
THUNK_S_20(118)
THUNK_S_1(119)
THUNK_S_2(119)
THUNK_S_3(119)
THUNK_S_4(119)
THUNK_S_5(119)
THUNK_S_6(119)
THUNK_S_7(119)
THUNK_S_8(119)
THUNK_S_9(119)
THUNK_S_10(119)
THUNK_S_11(119)
THUNK_S_12(119)
THUNK_S_13(119)
THUNK_S_14(119)
THUNK_S_15(119)
THUNK_S_16(119)
THUNK_S_17(119)
THUNK_S_18(119)
THUNK_S_19(119)
THUNK_S_20(119)
THUNK_S_1(120)
THUNK_S_2(120)
THUNK_S_3(120)
THUNK_S_4(120)
THUNK_S_5(120)
THUNK_S_6(120)
THUNK_S_7(120)
THUNK_S_8(120)
THUNK_S_9(120)
THUNK_S_10(120)
THUNK_S_11(120)
THUNK_S_12(120)
THUNK_S_13(120)
THUNK_S_14(120)
THUNK_S_15(120)
THUNK_S_16(120)
THUNK_S_17(120)
THUNK_S_18(120)
THUNK_S_19(120)
THUNK_S_20(120)
THUNK_S_1(121)
THUNK_S_2(121)
THUNK_S_3(121)
THUNK_S_4(121)
THUNK_S_5(121)
THUNK_S_6(121)
THUNK_S_7(121)
THUNK_S_8(121)
THUNK_S_9(121)
THUNK_S_10(121)
THUNK_S_11(121)
THUNK_S_12(121)
THUNK_S_13(121)
THUNK_S_14(121)
THUNK_S_15(121)
THUNK_S_16(121)
THUNK_S_17(121)
THUNK_S_18(121)
THUNK_S_19(121)
THUNK_S_20(121)
THUNK_S_1(122)
THUNK_S_2(122)
THUNK_S_3(122)
THUNK_S_4(122)
THUNK_S_5(122)
THUNK_S_6(122)
THUNK_S_7(122)
THUNK_S_8(122)
THUNK_S_9(122)
THUNK_S_10(122)
THUNK_S_11(122)
THUNK_S_12(122)
THUNK_S_13(122)
THUNK_S_14(122)
THUNK_S_15(122)
THUNK_S_16(122)
THUNK_S_17(122)
THUNK_S_18(122)
THUNK_S_19(122)
THUNK_S_20(122)
THUNK_S_1(123)
THUNK_S_2(123)
THUNK_S_3(123)
THUNK_S_4(123)
THUNK_S_5(123)
THUNK_S_6(123)
THUNK_S_7(123)
THUNK_S_8(123)
THUNK_S_9(123)
THUNK_S_10(123)
THUNK_S_11(123)
THUNK_S_12(123)
THUNK_S_13(123)
THUNK_S_14(123)
THUNK_S_15(123)
THUNK_S_16(123)
THUNK_S_17(123)
THUNK_S_18(123)
THUNK_S_19(123)
THUNK_S_20(123)
THUNK_S_1(124)
THUNK_S_2(124)
THUNK_S_3(124)
THUNK_S_4(124)
THUNK_S_5(124)
THUNK_S_6(124)
THUNK_S_7(124)
THUNK_S_8(124)
THUNK_S_9(124)
THUNK_S_10(124)
THUNK_S_11(124)
THUNK_S_12(124)
THUNK_S_13(124)
THUNK_S_14(124)
THUNK_S_15(124)
THUNK_S_16(124)
THUNK_S_17(124)
THUNK_S_18(124)
THUNK_S_19(124)
THUNK_S_20(124)
THUNK_S_1(125)
THUNK_S_2(125)
THUNK_S_3(125)
THUNK_S_4(125)
THUNK_S_5(125)
THUNK_S_6(125)
THUNK_S_7(125)
THUNK_S_8(125)
THUNK_S_9(125)
THUNK_S_10(125)
THUNK_S_11(125)
THUNK_S_12(125)
THUNK_S_13(125)
THUNK_S_14(125)
THUNK_S_15(125)
THUNK_S_16(125)
THUNK_S_17(125)
THUNK_S_18(125)
THUNK_S_19(125)
THUNK_S_20(125)
THUNK_S_1(126)
THUNK_S_2(126)
THUNK_S_3(126)
THUNK_S_4(126)
THUNK_S_5(126)
THUNK_S_6(126)
THUNK_S_7(126)
THUNK_S_8(126)
THUNK_S_9(126)
THUNK_S_10(126)
THUNK_S_11(126)
THUNK_S_12(126)
THUNK_S_13(126)
THUNK_S_14(126)
THUNK_S_15(126)
THUNK_S_16(126)
THUNK_S_17(126)
THUNK_S_18(126)
THUNK_S_19(126)
THUNK_S_20(126)
THUNK_S_1(127)
THUNK_S_2(127)
THUNK_S_3(127)
THUNK_S_4(127)
THUNK_S_5(127)
THUNK_S_6(127)
THUNK_S_7(127)
THUNK_S_8(127)
THUNK_S_9(127)
THUNK_S_10(127)
THUNK_S_11(127)
THUNK_S_12(127)
THUNK_S_13(127)
THUNK_S_14(127)
THUNK_S_15(127)
THUNK_S_16(127)
THUNK_S_17(127)
THUNK_S_18(127)
THUNK_S_19(127)
THUNK_S_20(127)
THUNK_S_1(128)
THUNK_S_2(128)
THUNK_S_3(128)
THUNK_S_4(128)
THUNK_S_5(128)
THUNK_S_6(128)
THUNK_S_7(128)
THUNK_S_8(128)
THUNK_S_9(128)
THUNK_S_10(128)
THUNK_S_11(128)
THUNK_S_12(128)
THUNK_S_13(128)
THUNK_S_14(128)
THUNK_S_15(128)
THUNK_S_16(128)
THUNK_S_17(128)
THUNK_S_18(128)
THUNK_S_19(128)
THUNK_S_20(128)
THUNK_S_1(129)
THUNK_S_2(129)
THUNK_S_3(129)
THUNK_S_4(129)
THUNK_S_5(129)
THUNK_S_6(129)
THUNK_S_7(129)
THUNK_S_8(129)
THUNK_S_9(129)
THUNK_S_10(129)
THUNK_S_11(129)
THUNK_S_12(129)
THUNK_S_13(129)
THUNK_S_14(129)
THUNK_S_15(129)
THUNK_S_16(129)
THUNK_S_17(129)
THUNK_S_18(129)
THUNK_S_19(129)
THUNK_S_20(129)
THUNK_S_1(130)
THUNK_S_2(130)
THUNK_S_3(130)
THUNK_S_4(130)
THUNK_S_5(130)
THUNK_S_6(130)
THUNK_S_7(130)
THUNK_S_8(130)
THUNK_S_9(130)
THUNK_S_10(130)
THUNK_S_11(130)
THUNK_S_12(130)
THUNK_S_13(130)
THUNK_S_14(130)
THUNK_S_15(130)
THUNK_S_16(130)
THUNK_S_17(130)
THUNK_S_18(130)
THUNK_S_19(130)
THUNK_S_20(130)
THUNK_S_1(131)
THUNK_S_2(131)
THUNK_S_3(131)
THUNK_S_4(131)
THUNK_S_5(131)
THUNK_S_6(131)
THUNK_S_7(131)
THUNK_S_8(131)
THUNK_S_9(131)
THUNK_S_10(131)
THUNK_S_11(131)
THUNK_S_12(131)
THUNK_S_13(131)
THUNK_S_14(131)
THUNK_S_15(131)
THUNK_S_16(131)
THUNK_S_17(131)
THUNK_S_18(131)
THUNK_S_19(131)
THUNK_S_20(131)
THUNK_S_1(132)
THUNK_S_2(132)
THUNK_S_3(132)
THUNK_S_4(132)
THUNK_S_5(132)
THUNK_S_6(132)
THUNK_S_7(132)
THUNK_S_8(132)
THUNK_S_9(132)
THUNK_S_10(132)
THUNK_S_11(132)
THUNK_S_12(132)
THUNK_S_13(132)
THUNK_S_14(132)
THUNK_S_15(132)
THUNK_S_16(132)
THUNK_S_17(132)
THUNK_S_18(132)
THUNK_S_19(132)
THUNK_S_20(132)
THUNK_S_1(133)
THUNK_S_2(133)
THUNK_S_3(133)
THUNK_S_4(133)
THUNK_S_5(133)
THUNK_S_6(133)
THUNK_S_7(133)
THUNK_S_8(133)
THUNK_S_9(133)
THUNK_S_10(133)
THUNK_S_11(133)
THUNK_S_12(133)
THUNK_S_13(133)
THUNK_S_14(133)
THUNK_S_15(133)
THUNK_S_16(133)
THUNK_S_17(133)
THUNK_S_18(133)
THUNK_S_19(133)
THUNK_S_20(133)
THUNK_S_1(134)
THUNK_S_2(134)
THUNK_S_3(134)
THUNK_S_4(134)
THUNK_S_5(134)
THUNK_S_6(134)
THUNK_S_7(134)
THUNK_S_8(134)
THUNK_S_9(134)
THUNK_S_10(134)
THUNK_S_11(134)
THUNK_S_12(134)
THUNK_S_13(134)
THUNK_S_14(134)
THUNK_S_15(134)
THUNK_S_16(134)
THUNK_S_17(134)
THUNK_S_18(134)
THUNK_S_19(134)
THUNK_S_20(134)
THUNK_S_1(135)
THUNK_S_2(135)
THUNK_S_3(135)
THUNK_S_4(135)
THUNK_S_5(135)
THUNK_S_6(135)
THUNK_S_7(135)
THUNK_S_8(135)
THUNK_S_9(135)
THUNK_S_10(135)
THUNK_S_11(135)
THUNK_S_12(135)
THUNK_S_13(135)
THUNK_S_14(135)
THUNK_S_15(135)
THUNK_S_16(135)
THUNK_S_17(135)
THUNK_S_18(135)
THUNK_S_19(135)
THUNK_S_20(135)
THUNK_S_1(136)
THUNK_S_2(136)
THUNK_S_3(136)
THUNK_S_4(136)
THUNK_S_5(136)
THUNK_S_6(136)
THUNK_S_7(136)
THUNK_S_8(136)
THUNK_S_9(136)
THUNK_S_10(136)
THUNK_S_11(136)
THUNK_S_12(136)
THUNK_S_13(136)
THUNK_S_14(136)
THUNK_S_15(136)
THUNK_S_16(136)
THUNK_S_17(136)
THUNK_S_18(136)
THUNK_S_19(136)
THUNK_S_20(136)
THUNK_S_1(137)
THUNK_S_2(137)
THUNK_S_3(137)
THUNK_S_4(137)
THUNK_S_5(137)
THUNK_S_6(137)
THUNK_S_7(137)
THUNK_S_8(137)
THUNK_S_9(137)
THUNK_S_10(137)
THUNK_S_11(137)
THUNK_S_12(137)
THUNK_S_13(137)
THUNK_S_14(137)
THUNK_S_15(137)
THUNK_S_16(137)
THUNK_S_17(137)
THUNK_S_18(137)
THUNK_S_19(137)
THUNK_S_20(137)
THUNK_S_1(138)
THUNK_S_2(138)
THUNK_S_3(138)
THUNK_S_4(138)
THUNK_S_5(138)
THUNK_S_6(138)
THUNK_S_7(138)
THUNK_S_8(138)
THUNK_S_9(138)
THUNK_S_10(138)
THUNK_S_11(138)
THUNK_S_12(138)
THUNK_S_13(138)
THUNK_S_14(138)
THUNK_S_15(138)
THUNK_S_16(138)
THUNK_S_17(138)
THUNK_S_18(138)
THUNK_S_19(138)
THUNK_S_20(138)
THUNK_S_1(139)
THUNK_S_2(139)
THUNK_S_3(139)
THUNK_S_4(139)
THUNK_S_5(139)
THUNK_S_6(139)
THUNK_S_7(139)
THUNK_S_8(139)
THUNK_S_9(139)
THUNK_S_10(139)
THUNK_S_11(139)
THUNK_S_12(139)
THUNK_S_13(139)
THUNK_S_14(139)
THUNK_S_15(139)
THUNK_S_16(139)
THUNK_S_17(139)
THUNK_S_18(139)
THUNK_S_19(139)
THUNK_S_20(139)
THUNK_S_1(140)
THUNK_S_2(140)
THUNK_S_3(140)
THUNK_S_4(140)
THUNK_S_5(140)
THUNK_S_6(140)
THUNK_S_7(140)
THUNK_S_8(140)
THUNK_S_9(140)
THUNK_S_10(140)
THUNK_S_11(140)
THUNK_S_12(140)
THUNK_S_13(140)
THUNK_S_14(140)
THUNK_S_15(140)
THUNK_S_16(140)
THUNK_S_17(140)
THUNK_S_18(140)
THUNK_S_19(140)
THUNK_S_20(140)
THUNK_S_1(141)
THUNK_S_2(141)
THUNK_S_3(141)
THUNK_S_4(141)
THUNK_S_5(141)
THUNK_S_6(141)
THUNK_S_7(141)
THUNK_S_8(141)
THUNK_S_9(141)
THUNK_S_10(141)
THUNK_S_11(141)
THUNK_S_12(141)
THUNK_S_13(141)
THUNK_S_14(141)
THUNK_S_15(141)
THUNK_S_16(141)
THUNK_S_17(141)
THUNK_S_18(141)
THUNK_S_19(141)
THUNK_S_20(141)
THUNK_S_1(142)
THUNK_S_2(142)
THUNK_S_3(142)
THUNK_S_4(142)
THUNK_S_5(142)
THUNK_S_6(142)
THUNK_S_7(142)
THUNK_S_8(142)
THUNK_S_9(142)
THUNK_S_10(142)
THUNK_S_11(142)
THUNK_S_12(142)
THUNK_S_13(142)
THUNK_S_14(142)
THUNK_S_15(142)
THUNK_S_16(142)
THUNK_S_17(142)
THUNK_S_18(142)
THUNK_S_19(142)
THUNK_S_20(142)
THUNK_S_1(143)
THUNK_S_2(143)
THUNK_S_3(143)
THUNK_S_4(143)
THUNK_S_5(143)
THUNK_S_6(143)
THUNK_S_7(143)
THUNK_S_8(143)
THUNK_S_9(143)
THUNK_S_10(143)
THUNK_S_11(143)
THUNK_S_12(143)
THUNK_S_13(143)
THUNK_S_14(143)
THUNK_S_15(143)
THUNK_S_16(143)
THUNK_S_17(143)
THUNK_S_18(143)
THUNK_S_19(143)
THUNK_S_20(143)
THUNK_S_1(144)
THUNK_S_2(144)
THUNK_S_3(144)
THUNK_S_4(144)
THUNK_S_5(144)
THUNK_S_6(144)
THUNK_S_7(144)
THUNK_S_8(144)
THUNK_S_9(144)
THUNK_S_10(144)
THUNK_S_11(144)
THUNK_S_12(144)
THUNK_S_13(144)
THUNK_S_14(144)
THUNK_S_15(144)
THUNK_S_16(144)
THUNK_S_17(144)
THUNK_S_18(144)
THUNK_S_19(144)
THUNK_S_20(144)
THUNK_S_1(145)
THUNK_S_2(145)
THUNK_S_3(145)
THUNK_S_4(145)
THUNK_S_5(145)
THUNK_S_6(145)
THUNK_S_7(145)
THUNK_S_8(145)
THUNK_S_9(145)
THUNK_S_10(145)
THUNK_S_11(145)
THUNK_S_12(145)
THUNK_S_13(145)
THUNK_S_14(145)
THUNK_S_15(145)
THUNK_S_16(145)
THUNK_S_17(145)
THUNK_S_18(145)
THUNK_S_19(145)
THUNK_S_20(145)
THUNK_S_1(146)
THUNK_S_2(146)
THUNK_S_3(146)
THUNK_S_4(146)
THUNK_S_5(146)
THUNK_S_6(146)
THUNK_S_7(146)
THUNK_S_8(146)
THUNK_S_9(146)
THUNK_S_10(146)
THUNK_S_11(146)
THUNK_S_12(146)
THUNK_S_13(146)
THUNK_S_14(146)
THUNK_S_15(146)
THUNK_S_16(146)
THUNK_S_17(146)
THUNK_S_18(146)
THUNK_S_19(146)
THUNK_S_20(146)
THUNK_S_1(147)
THUNK_S_2(147)
THUNK_S_3(147)
THUNK_S_4(147)
THUNK_S_5(147)
THUNK_S_6(147)
THUNK_S_7(147)
THUNK_S_8(147)
THUNK_S_9(147)
THUNK_S_10(147)
THUNK_S_11(147)
THUNK_S_12(147)
THUNK_S_13(147)
THUNK_S_14(147)
THUNK_S_15(147)
THUNK_S_16(147)
THUNK_S_17(147)
THUNK_S_18(147)
THUNK_S_19(147)
THUNK_S_20(147)
THUNK_S_1(148)
THUNK_S_2(148)
THUNK_S_3(148)
THUNK_S_4(148)
THUNK_S_5(148)
THUNK_S_6(148)
THUNK_S_7(148)
THUNK_S_8(148)
THUNK_S_9(148)
THUNK_S_10(148)
THUNK_S_11(148)
THUNK_S_12(148)
THUNK_S_13(148)
THUNK_S_14(148)
THUNK_S_15(148)
THUNK_S_16(148)
THUNK_S_17(148)
THUNK_S_18(148)
THUNK_S_19(148)
THUNK_S_20(148)
THUNK_S_1(149)
THUNK_S_2(149)
THUNK_S_3(149)
THUNK_S_4(149)
THUNK_S_5(149)
THUNK_S_6(149)
THUNK_S_7(149)
THUNK_S_8(149)
THUNK_S_9(149)
THUNK_S_10(149)
THUNK_S_11(149)
THUNK_S_12(149)
THUNK_S_13(149)
THUNK_S_14(149)
THUNK_S_15(149)
THUNK_S_16(149)
THUNK_S_17(149)
THUNK_S_18(149)
THUNK_S_19(149)
THUNK_S_20(149)
THUNK_S_1(150)
THUNK_S_2(150)
THUNK_S_3(150)
THUNK_S_4(150)
THUNK_S_5(150)
THUNK_S_6(150)
THUNK_S_7(150)
THUNK_S_8(150)
THUNK_S_9(150)
THUNK_S_10(150)
THUNK_S_11(150)
THUNK_S_12(150)
THUNK_S_13(150)
THUNK_S_14(150)
THUNK_S_15(150)
THUNK_S_16(150)
THUNK_S_17(150)
THUNK_S_18(150)
THUNK_S_19(150)
THUNK_S_20(150)
THUNK_S_1(151)
THUNK_S_2(151)
THUNK_S_3(151)
THUNK_S_4(151)
THUNK_S_5(151)
THUNK_S_6(151)
THUNK_S_7(151)
THUNK_S_8(151)
THUNK_S_9(151)
THUNK_S_10(151)
THUNK_S_11(151)
THUNK_S_12(151)
THUNK_S_13(151)
THUNK_S_14(151)
THUNK_S_15(151)
THUNK_S_16(151)
THUNK_S_17(151)
THUNK_S_18(151)
THUNK_S_19(151)
THUNK_S_20(151)
THUNK_S_1(152)
THUNK_S_2(152)
THUNK_S_3(152)
THUNK_S_4(152)
THUNK_S_5(152)
THUNK_S_6(152)
THUNK_S_7(152)
THUNK_S_8(152)
THUNK_S_9(152)
THUNK_S_10(152)
THUNK_S_11(152)
THUNK_S_12(152)
THUNK_S_13(152)
THUNK_S_14(152)
THUNK_S_15(152)
THUNK_S_16(152)
THUNK_S_17(152)
THUNK_S_18(152)
THUNK_S_19(152)
THUNK_S_20(152)
THUNK_S_1(153)
THUNK_S_2(153)
THUNK_S_3(153)
THUNK_S_4(153)
THUNK_S_5(153)
THUNK_S_6(153)
THUNK_S_7(153)
THUNK_S_8(153)
THUNK_S_9(153)
THUNK_S_10(153)
THUNK_S_11(153)
THUNK_S_12(153)
THUNK_S_13(153)
THUNK_S_14(153)
THUNK_S_15(153)
THUNK_S_16(153)
THUNK_S_17(153)
THUNK_S_18(153)
THUNK_S_19(153)
THUNK_S_20(153)
THUNK_S_1(154)
THUNK_S_2(154)
THUNK_S_3(154)
THUNK_S_4(154)
THUNK_S_5(154)
THUNK_S_6(154)
THUNK_S_7(154)
THUNK_S_8(154)
THUNK_S_9(154)
THUNK_S_10(154)
THUNK_S_11(154)
THUNK_S_12(154)
THUNK_S_13(154)
THUNK_S_14(154)
THUNK_S_15(154)
THUNK_S_16(154)
THUNK_S_17(154)
THUNK_S_18(154)
THUNK_S_19(154)
THUNK_S_20(154)
THUNK_S_1(155)
THUNK_S_2(155)
THUNK_S_3(155)
THUNK_S_4(155)
THUNK_S_5(155)
THUNK_S_6(155)
THUNK_S_7(155)
THUNK_S_8(155)
THUNK_S_9(155)
THUNK_S_10(155)
THUNK_S_11(155)
THUNK_S_12(155)
THUNK_S_13(155)
THUNK_S_14(155)
THUNK_S_15(155)
THUNK_S_16(155)
THUNK_S_17(155)
THUNK_S_18(155)
THUNK_S_19(155)
THUNK_S_20(155)
THUNK_S_1(156)
THUNK_S_2(156)
THUNK_S_3(156)
THUNK_S_4(156)
THUNK_S_5(156)
THUNK_S_6(156)
THUNK_S_7(156)
THUNK_S_8(156)
THUNK_S_9(156)
THUNK_S_10(156)
THUNK_S_11(156)
THUNK_S_12(156)
THUNK_S_13(156)
THUNK_S_14(156)
THUNK_S_15(156)
THUNK_S_16(156)
THUNK_S_17(156)
THUNK_S_18(156)
THUNK_S_19(156)
THUNK_S_20(156)
THUNK_S_1(157)
THUNK_S_2(157)
THUNK_S_3(157)
THUNK_S_4(157)
THUNK_S_5(157)
THUNK_S_6(157)
THUNK_S_7(157)
THUNK_S_8(157)
THUNK_S_9(157)
THUNK_S_10(157)
THUNK_S_11(157)
THUNK_S_12(157)
THUNK_S_13(157)
THUNK_S_14(157)
THUNK_S_15(157)
THUNK_S_16(157)
THUNK_S_17(157)
THUNK_S_18(157)
THUNK_S_19(157)
THUNK_S_20(157)
THUNK_S_1(158)
THUNK_S_2(158)
THUNK_S_3(158)
THUNK_S_4(158)
THUNK_S_5(158)
THUNK_S_6(158)
THUNK_S_7(158)
THUNK_S_8(158)
THUNK_S_9(158)
THUNK_S_10(158)
THUNK_S_11(158)
THUNK_S_12(158)
THUNK_S_13(158)
THUNK_S_14(158)
THUNK_S_15(158)
THUNK_S_16(158)
THUNK_S_17(158)
THUNK_S_18(158)
THUNK_S_19(158)
THUNK_S_20(158)
THUNK_S_1(159)
THUNK_S_2(159)
THUNK_S_3(159)
THUNK_S_4(159)
THUNK_S_5(159)
THUNK_S_6(159)
THUNK_S_7(159)
THUNK_S_8(159)
THUNK_S_9(159)
THUNK_S_10(159)
THUNK_S_11(159)
THUNK_S_12(159)
THUNK_S_13(159)
THUNK_S_14(159)
THUNK_S_15(159)
THUNK_S_16(159)
THUNK_S_17(159)
THUNK_S_18(159)
THUNK_S_19(159)
THUNK_S_20(159)
THUNK_S_1(160)
THUNK_S_2(160)
THUNK_S_3(160)
THUNK_S_4(160)
THUNK_S_5(160)
THUNK_S_6(160)
THUNK_S_7(160)
THUNK_S_8(160)
THUNK_S_9(160)
THUNK_S_10(160)
THUNK_S_11(160)
THUNK_S_12(160)
THUNK_S_13(160)
THUNK_S_14(160)
THUNK_S_15(160)
THUNK_S_16(160)
THUNK_S_17(160)
THUNK_S_18(160)
THUNK_S_19(160)
THUNK_S_20(160)
THUNK_S_1(161)
THUNK_S_2(161)
THUNK_S_3(161)
THUNK_S_4(161)
THUNK_S_5(161)
THUNK_S_6(161)
THUNK_S_7(161)
THUNK_S_8(161)
THUNK_S_9(161)
THUNK_S_10(161)
THUNK_S_11(161)
THUNK_S_12(161)
THUNK_S_13(161)
THUNK_S_14(161)
THUNK_S_15(161)
THUNK_S_16(161)
THUNK_S_17(161)
THUNK_S_18(161)
THUNK_S_19(161)
THUNK_S_20(161)
THUNK_S_1(162)
THUNK_S_2(162)
THUNK_S_3(162)
THUNK_S_4(162)
THUNK_S_5(162)
THUNK_S_6(162)
THUNK_S_7(162)
THUNK_S_8(162)
THUNK_S_9(162)
THUNK_S_10(162)
THUNK_S_11(162)
THUNK_S_12(162)
THUNK_S_13(162)
THUNK_S_14(162)
THUNK_S_15(162)
THUNK_S_16(162)
THUNK_S_17(162)
THUNK_S_18(162)
THUNK_S_19(162)
THUNK_S_20(162)
THUNK_S_1(163)
THUNK_S_2(163)
THUNK_S_3(163)
THUNK_S_4(163)
THUNK_S_5(163)
THUNK_S_6(163)
THUNK_S_7(163)
THUNK_S_8(163)
THUNK_S_9(163)
THUNK_S_10(163)
THUNK_S_11(163)
THUNK_S_12(163)
THUNK_S_13(163)
THUNK_S_14(163)
THUNK_S_15(163)
THUNK_S_16(163)
THUNK_S_17(163)
THUNK_S_18(163)
THUNK_S_19(163)
THUNK_S_20(163)
THUNK_S_1(164)
THUNK_S_2(164)
THUNK_S_3(164)
THUNK_S_4(164)
THUNK_S_5(164)
THUNK_S_6(164)
THUNK_S_7(164)
THUNK_S_8(164)
THUNK_S_9(164)
THUNK_S_10(164)
THUNK_S_11(164)
THUNK_S_12(164)
THUNK_S_13(164)
THUNK_S_14(164)
THUNK_S_15(164)
THUNK_S_16(164)
THUNK_S_17(164)
THUNK_S_18(164)
THUNK_S_19(164)
THUNK_S_20(164)
THUNK_S_1(165)
THUNK_S_2(165)
THUNK_S_3(165)
THUNK_S_4(165)
THUNK_S_5(165)
THUNK_S_6(165)
THUNK_S_7(165)
THUNK_S_8(165)
THUNK_S_9(165)
THUNK_S_10(165)
THUNK_S_11(165)
THUNK_S_12(165)
THUNK_S_13(165)
THUNK_S_14(165)
THUNK_S_15(165)
THUNK_S_16(165)
THUNK_S_17(165)
THUNK_S_18(165)
THUNK_S_19(165)
THUNK_S_20(165)
THUNK_S_1(166)
THUNK_S_2(166)
THUNK_S_3(166)
THUNK_S_4(166)
THUNK_S_5(166)
THUNK_S_6(166)
THUNK_S_7(166)
THUNK_S_8(166)
THUNK_S_9(166)
THUNK_S_10(166)
THUNK_S_11(166)
THUNK_S_12(166)
THUNK_S_13(166)
THUNK_S_14(166)
THUNK_S_15(166)
THUNK_S_16(166)
THUNK_S_17(166)
THUNK_S_18(166)
THUNK_S_19(166)
THUNK_S_20(166)
THUNK_S_1(167)
THUNK_S_2(167)
THUNK_S_3(167)
THUNK_S_4(167)
THUNK_S_5(167)
THUNK_S_6(167)
THUNK_S_7(167)
THUNK_S_8(167)
THUNK_S_9(167)
THUNK_S_10(167)
THUNK_S_11(167)
THUNK_S_12(167)
THUNK_S_13(167)
THUNK_S_14(167)
THUNK_S_15(167)
THUNK_S_16(167)
THUNK_S_17(167)
THUNK_S_18(167)
THUNK_S_19(167)
THUNK_S_20(167)
THUNK_S_1(168)
THUNK_S_2(168)
THUNK_S_3(168)
THUNK_S_4(168)
THUNK_S_5(168)
THUNK_S_6(168)
THUNK_S_7(168)
THUNK_S_8(168)
THUNK_S_9(168)
THUNK_S_10(168)
THUNK_S_11(168)
THUNK_S_12(168)
THUNK_S_13(168)
THUNK_S_14(168)
THUNK_S_15(168)
THUNK_S_16(168)
THUNK_S_17(168)
THUNK_S_18(168)
THUNK_S_19(168)
THUNK_S_20(168)
THUNK_S_1(169)
THUNK_S_2(169)
THUNK_S_3(169)
THUNK_S_4(169)
THUNK_S_5(169)
THUNK_S_6(169)
THUNK_S_7(169)
THUNK_S_8(169)
THUNK_S_9(169)
THUNK_S_10(169)
THUNK_S_11(169)
THUNK_S_12(169)
THUNK_S_13(169)
THUNK_S_14(169)
THUNK_S_15(169)
THUNK_S_16(169)
THUNK_S_17(169)
THUNK_S_18(169)
THUNK_S_19(169)
THUNK_S_20(169)
THUNK_S_1(170)
THUNK_S_2(170)
THUNK_S_3(170)
THUNK_S_4(170)
THUNK_S_5(170)
THUNK_S_6(170)
THUNK_S_7(170)
THUNK_S_8(170)
THUNK_S_9(170)
THUNK_S_10(170)
THUNK_S_11(170)
THUNK_S_12(170)
THUNK_S_13(170)
THUNK_S_14(170)
THUNK_S_15(170)
THUNK_S_16(170)
THUNK_S_17(170)
THUNK_S_18(170)
THUNK_S_19(170)
THUNK_S_20(170)
THUNK_S_1(171)
THUNK_S_2(171)
THUNK_S_3(171)
THUNK_S_4(171)
THUNK_S_5(171)
THUNK_S_6(171)
THUNK_S_7(171)
THUNK_S_8(171)
THUNK_S_9(171)
THUNK_S_10(171)
THUNK_S_11(171)
THUNK_S_12(171)
THUNK_S_13(171)
THUNK_S_14(171)
THUNK_S_15(171)
THUNK_S_16(171)
THUNK_S_17(171)
THUNK_S_18(171)
THUNK_S_19(171)
THUNK_S_20(171)
THUNK_S_1(172)
THUNK_S_2(172)
THUNK_S_3(172)
THUNK_S_4(172)
THUNK_S_5(172)
THUNK_S_6(172)
THUNK_S_7(172)
THUNK_S_8(172)
THUNK_S_9(172)
THUNK_S_10(172)
THUNK_S_11(172)
THUNK_S_12(172)
THUNK_S_13(172)
THUNK_S_14(172)
THUNK_S_15(172)
THUNK_S_16(172)
THUNK_S_17(172)
THUNK_S_18(172)
THUNK_S_19(172)
THUNK_S_20(172)
THUNK_S_1(173)
THUNK_S_2(173)
THUNK_S_3(173)
THUNK_S_4(173)
THUNK_S_5(173)
THUNK_S_6(173)
THUNK_S_7(173)
THUNK_S_8(173)
THUNK_S_9(173)
THUNK_S_10(173)
THUNK_S_11(173)
THUNK_S_12(173)
THUNK_S_13(173)
THUNK_S_14(173)
THUNK_S_15(173)
THUNK_S_16(173)
THUNK_S_17(173)
THUNK_S_18(173)
THUNK_S_19(173)
THUNK_S_20(173)
THUNK_S_1(174)
THUNK_S_2(174)
THUNK_S_3(174)
THUNK_S_4(174)
THUNK_S_5(174)
THUNK_S_6(174)
THUNK_S_7(174)
THUNK_S_8(174)
THUNK_S_9(174)
THUNK_S_10(174)
THUNK_S_11(174)
THUNK_S_12(174)
THUNK_S_13(174)
THUNK_S_14(174)
THUNK_S_15(174)
THUNK_S_16(174)
THUNK_S_17(174)
THUNK_S_18(174)
THUNK_S_19(174)
THUNK_S_20(174)
THUNK_S_1(175)
THUNK_S_2(175)
THUNK_S_3(175)
THUNK_S_4(175)
THUNK_S_5(175)
THUNK_S_6(175)
THUNK_S_7(175)
THUNK_S_8(175)
THUNK_S_9(175)
THUNK_S_10(175)
THUNK_S_11(175)
THUNK_S_12(175)
THUNK_S_13(175)
THUNK_S_14(175)
THUNK_S_15(175)
THUNK_S_16(175)
THUNK_S_17(175)
THUNK_S_18(175)
THUNK_S_19(175)
THUNK_S_20(175)
THUNK_S_1(176)
THUNK_S_2(176)
THUNK_S_3(176)
THUNK_S_4(176)
THUNK_S_5(176)
THUNK_S_6(176)
THUNK_S_7(176)
THUNK_S_8(176)
THUNK_S_9(176)
THUNK_S_10(176)
THUNK_S_11(176)
THUNK_S_12(176)
THUNK_S_13(176)
THUNK_S_14(176)
THUNK_S_15(176)
THUNK_S_16(176)
THUNK_S_17(176)
THUNK_S_18(176)
THUNK_S_19(176)
THUNK_S_20(176)
THUNK_S_1(177)
THUNK_S_2(177)
THUNK_S_3(177)
THUNK_S_4(177)
THUNK_S_5(177)
THUNK_S_6(177)
THUNK_S_7(177)
THUNK_S_8(177)
THUNK_S_9(177)
THUNK_S_10(177)
THUNK_S_11(177)
THUNK_S_12(177)
THUNK_S_13(177)
THUNK_S_14(177)
THUNK_S_15(177)
THUNK_S_16(177)
THUNK_S_17(177)
THUNK_S_18(177)
THUNK_S_19(177)
THUNK_S_20(177)
THUNK_S_1(178)
THUNK_S_2(178)
THUNK_S_3(178)
THUNK_S_4(178)
THUNK_S_5(178)
THUNK_S_6(178)
THUNK_S_7(178)
THUNK_S_8(178)
THUNK_S_9(178)
THUNK_S_10(178)
THUNK_S_11(178)
THUNK_S_12(178)
THUNK_S_13(178)
THUNK_S_14(178)
THUNK_S_15(178)
THUNK_S_16(178)
THUNK_S_17(178)
THUNK_S_18(178)
THUNK_S_19(178)
THUNK_S_20(178)
THUNK_S_1(179)
THUNK_S_2(179)
THUNK_S_3(179)
THUNK_S_4(179)
THUNK_S_5(179)
THUNK_S_6(179)
THUNK_S_7(179)
THUNK_S_8(179)
THUNK_S_9(179)
THUNK_S_10(179)
THUNK_S_11(179)
THUNK_S_12(179)
THUNK_S_13(179)
THUNK_S_14(179)
THUNK_S_15(179)
THUNK_S_16(179)
THUNK_S_17(179)
THUNK_S_18(179)
THUNK_S_19(179)
THUNK_S_20(179)
THUNK_S_1(180)
THUNK_S_2(180)
THUNK_S_3(180)
THUNK_S_4(180)
THUNK_S_5(180)
THUNK_S_6(180)
THUNK_S_7(180)
THUNK_S_8(180)
THUNK_S_9(180)
THUNK_S_10(180)
THUNK_S_11(180)
THUNK_S_12(180)
THUNK_S_13(180)
THUNK_S_14(180)
THUNK_S_15(180)
THUNK_S_16(180)
THUNK_S_17(180)
THUNK_S_18(180)
THUNK_S_19(180)
THUNK_S_20(180)
THUNK_S_1(181)
THUNK_S_2(181)
THUNK_S_3(181)
THUNK_S_4(181)
THUNK_S_5(181)
THUNK_S_6(181)
THUNK_S_7(181)
THUNK_S_8(181)
THUNK_S_9(181)
THUNK_S_10(181)
THUNK_S_11(181)
THUNK_S_12(181)
THUNK_S_13(181)
THUNK_S_14(181)
THUNK_S_15(181)
THUNK_S_16(181)
THUNK_S_17(181)
THUNK_S_18(181)
THUNK_S_19(181)
THUNK_S_20(181)
THUNK_S_1(182)
THUNK_S_2(182)
THUNK_S_3(182)
THUNK_S_4(182)
THUNK_S_5(182)
THUNK_S_6(182)
THUNK_S_7(182)
THUNK_S_8(182)
THUNK_S_9(182)
THUNK_S_10(182)
THUNK_S_11(182)
THUNK_S_12(182)
THUNK_S_13(182)
THUNK_S_14(182)
THUNK_S_15(182)
THUNK_S_16(182)
THUNK_S_17(182)
THUNK_S_18(182)
THUNK_S_19(182)
THUNK_S_20(182)
THUNK_S_1(183)
THUNK_S_2(183)
THUNK_S_3(183)
THUNK_S_4(183)
THUNK_S_5(183)
THUNK_S_6(183)
THUNK_S_7(183)
THUNK_S_8(183)
THUNK_S_9(183)
THUNK_S_10(183)
THUNK_S_11(183)
THUNK_S_12(183)
THUNK_S_13(183)
THUNK_S_14(183)
THUNK_S_15(183)
THUNK_S_16(183)
THUNK_S_17(183)
THUNK_S_18(183)
THUNK_S_19(183)
THUNK_S_20(183)
THUNK_S_1(184)
THUNK_S_2(184)
THUNK_S_3(184)
THUNK_S_4(184)
THUNK_S_5(184)
THUNK_S_6(184)
THUNK_S_7(184)
THUNK_S_8(184)
THUNK_S_9(184)
THUNK_S_10(184)
THUNK_S_11(184)
THUNK_S_12(184)
THUNK_S_13(184)
THUNK_S_14(184)
THUNK_S_15(184)
THUNK_S_16(184)
THUNK_S_17(184)
THUNK_S_18(184)
THUNK_S_19(184)
THUNK_S_20(184)
THUNK_S_1(185)
THUNK_S_2(185)
THUNK_S_3(185)
THUNK_S_4(185)
THUNK_S_5(185)
THUNK_S_6(185)
THUNK_S_7(185)
THUNK_S_8(185)
THUNK_S_9(185)
THUNK_S_10(185)
THUNK_S_11(185)
THUNK_S_12(185)
THUNK_S_13(185)
THUNK_S_14(185)
THUNK_S_15(185)
THUNK_S_16(185)
THUNK_S_17(185)
THUNK_S_18(185)
THUNK_S_19(185)
THUNK_S_20(185)
THUNK_S_1(186)
THUNK_S_2(186)
THUNK_S_3(186)
THUNK_S_4(186)
THUNK_S_5(186)
THUNK_S_6(186)
THUNK_S_7(186)
THUNK_S_8(186)
THUNK_S_9(186)
THUNK_S_10(186)
THUNK_S_11(186)
THUNK_S_12(186)
THUNK_S_13(186)
THUNK_S_14(186)
THUNK_S_15(186)
THUNK_S_16(186)
THUNK_S_17(186)
THUNK_S_18(186)
THUNK_S_19(186)
THUNK_S_20(186)
THUNK_S_1(187)
THUNK_S_2(187)
THUNK_S_3(187)
THUNK_S_4(187)
THUNK_S_5(187)
THUNK_S_6(187)
THUNK_S_7(187)
THUNK_S_8(187)
THUNK_S_9(187)
THUNK_S_10(187)
THUNK_S_11(187)
THUNK_S_12(187)
THUNK_S_13(187)
THUNK_S_14(187)
THUNK_S_15(187)
THUNK_S_16(187)
THUNK_S_17(187)
THUNK_S_18(187)
THUNK_S_19(187)
THUNK_S_20(187)
THUNK_S_1(188)
THUNK_S_2(188)
THUNK_S_3(188)
THUNK_S_4(188)
THUNK_S_5(188)
THUNK_S_6(188)
THUNK_S_7(188)
THUNK_S_8(188)
THUNK_S_9(188)
THUNK_S_10(188)
THUNK_S_11(188)
THUNK_S_12(188)
THUNK_S_13(188)
THUNK_S_14(188)
THUNK_S_15(188)
THUNK_S_16(188)
THUNK_S_17(188)
THUNK_S_18(188)
THUNK_S_19(188)
THUNK_S_20(188)
THUNK_S_1(189)
THUNK_S_2(189)
THUNK_S_3(189)
THUNK_S_4(189)
THUNK_S_5(189)
THUNK_S_6(189)
THUNK_S_7(189)
THUNK_S_8(189)
THUNK_S_9(189)
THUNK_S_10(189)
THUNK_S_11(189)
THUNK_S_12(189)
THUNK_S_13(189)
THUNK_S_14(189)
THUNK_S_15(189)
THUNK_S_16(189)
THUNK_S_17(189)
THUNK_S_18(189)
THUNK_S_19(189)
THUNK_S_20(189)
THUNK_S_1(190)
THUNK_S_2(190)
THUNK_S_3(190)
THUNK_S_4(190)
THUNK_S_5(190)
THUNK_S_6(190)
THUNK_S_7(190)
THUNK_S_8(190)
THUNK_S_9(190)
THUNK_S_10(190)
THUNK_S_11(190)
THUNK_S_12(190)
THUNK_S_13(190)
THUNK_S_14(190)
THUNK_S_15(190)
THUNK_S_16(190)
THUNK_S_17(190)
THUNK_S_18(190)
THUNK_S_19(190)
THUNK_S_20(190)
THUNK_S_1(191)
THUNK_S_2(191)
THUNK_S_3(191)
THUNK_S_4(191)
THUNK_S_5(191)
THUNK_S_6(191)
THUNK_S_7(191)
THUNK_S_8(191)
THUNK_S_9(191)
THUNK_S_10(191)
THUNK_S_11(191)
THUNK_S_12(191)
THUNK_S_13(191)
THUNK_S_14(191)
THUNK_S_15(191)
THUNK_S_16(191)
THUNK_S_17(191)
THUNK_S_18(191)
THUNK_S_19(191)
THUNK_S_20(191)
THUNK_S_1(192)
THUNK_S_2(192)
THUNK_S_3(192)
THUNK_S_4(192)
THUNK_S_5(192)
THUNK_S_6(192)
THUNK_S_7(192)
THUNK_S_8(192)
THUNK_S_9(192)
THUNK_S_10(192)
THUNK_S_11(192)
THUNK_S_12(192)
THUNK_S_13(192)
THUNK_S_14(192)
THUNK_S_15(192)
THUNK_S_16(192)
THUNK_S_17(192)
THUNK_S_18(192)
THUNK_S_19(192)
THUNK_S_20(192)
THUNK_S_1(193)
THUNK_S_2(193)
THUNK_S_3(193)
THUNK_S_4(193)
THUNK_S_5(193)
THUNK_S_6(193)
THUNK_S_7(193)
THUNK_S_8(193)
THUNK_S_9(193)
THUNK_S_10(193)
THUNK_S_11(193)
THUNK_S_12(193)
THUNK_S_13(193)
THUNK_S_14(193)
THUNK_S_15(193)
THUNK_S_16(193)
THUNK_S_17(193)
THUNK_S_18(193)
THUNK_S_19(193)
THUNK_S_20(193)
THUNK_S_1(194)
THUNK_S_2(194)
THUNK_S_3(194)
THUNK_S_4(194)
THUNK_S_5(194)
THUNK_S_6(194)
THUNK_S_7(194)
THUNK_S_8(194)
THUNK_S_9(194)
THUNK_S_10(194)
THUNK_S_11(194)
THUNK_S_12(194)
THUNK_S_13(194)
THUNK_S_14(194)
THUNK_S_15(194)
THUNK_S_16(194)
THUNK_S_17(194)
THUNK_S_18(194)
THUNK_S_19(194)
THUNK_S_20(194)
THUNK_S_1(195)
THUNK_S_2(195)
THUNK_S_3(195)
THUNK_S_4(195)
THUNK_S_5(195)
THUNK_S_6(195)
THUNK_S_7(195)
THUNK_S_8(195)
THUNK_S_9(195)
THUNK_S_10(195)
THUNK_S_11(195)
THUNK_S_12(195)
THUNK_S_13(195)
THUNK_S_14(195)
THUNK_S_15(195)
THUNK_S_16(195)
THUNK_S_17(195)
THUNK_S_18(195)
THUNK_S_19(195)
THUNK_S_20(195)
THUNK_S_1(196)
THUNK_S_2(196)
THUNK_S_3(196)
THUNK_S_4(196)
THUNK_S_5(196)
THUNK_S_6(196)
THUNK_S_7(196)
THUNK_S_8(196)
THUNK_S_9(196)
THUNK_S_10(196)
THUNK_S_11(196)
THUNK_S_12(196)
THUNK_S_13(196)
THUNK_S_14(196)
THUNK_S_15(196)
THUNK_S_16(196)
THUNK_S_17(196)
THUNK_S_18(196)
THUNK_S_19(196)
THUNK_S_20(196)
THUNK_S_1(197)
THUNK_S_2(197)
THUNK_S_3(197)
THUNK_S_4(197)
THUNK_S_5(197)
THUNK_S_6(197)
THUNK_S_7(197)
THUNK_S_8(197)
THUNK_S_9(197)
THUNK_S_10(197)
THUNK_S_11(197)
THUNK_S_12(197)
THUNK_S_13(197)
THUNK_S_14(197)
THUNK_S_15(197)
THUNK_S_16(197)
THUNK_S_17(197)
THUNK_S_18(197)
THUNK_S_19(197)
THUNK_S_20(197)
THUNK_S_1(198)
THUNK_S_2(198)
THUNK_S_3(198)
THUNK_S_4(198)
THUNK_S_5(198)
THUNK_S_6(198)
THUNK_S_7(198)
THUNK_S_8(198)
THUNK_S_9(198)
THUNK_S_10(198)
THUNK_S_11(198)
THUNK_S_12(198)
THUNK_S_13(198)
THUNK_S_14(198)
THUNK_S_15(198)
THUNK_S_16(198)
THUNK_S_17(198)
THUNK_S_18(198)
THUNK_S_19(198)
THUNK_S_20(198)
THUNK_S_1(199)
THUNK_S_2(199)
THUNK_S_3(199)
THUNK_S_4(199)
THUNK_S_5(199)
THUNK_S_6(199)
THUNK_S_7(199)
THUNK_S_8(199)
THUNK_S_9(199)
THUNK_S_10(199)
THUNK_S_11(199)
THUNK_S_12(199)
THUNK_S_13(199)
THUNK_S_14(199)
THUNK_S_15(199)
THUNK_S_16(199)
THUNK_S_17(199)
THUNK_S_18(199)
THUNK_S_19(199)
THUNK_S_20(199)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\wraprect.cxx ===
//
// Trident 16 bit source only.
//
// Provides wrappers for some common GID Apis that take long rectangles in 32bit
// world and take small rectangles in 16bit world.

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

void    WINAPI ClientToScreen(HWND hwnd, POINTL FAR* lpp)
{
    ClientToScreen(hwnd, (CPointAutoconvert) lpp);
}

void    WINAPI ScreenToClient(HWND hwnd, POINTL FAR* lpp)
{
    ScreenToClient(hwnd, (CPointAutoconvert) lpp);
}

void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINTL FAR* lppt, UINT cpt)
{
    CPointAutoconvertArray aryPts(lppt, cpt);
    MapWindowPoints(hwndFrom, hwndTo, aryPts, cpt);
}

HWND    WINAPI WindowFromPoint(POINTL ptl)
{
    POINTword pt={ptl.x, ptl.y};
    return WindowFromPoint(pt);
}

HWND    WINAPI ChildWindowFromPoint(HWND hwnd, POINTL ptl)
{
    POINTword pt={ptl.x, ptl.y};
    return ChildWindowFromPoint(hwnd, pt);
}

void    WINAPI GetCursorPos(POINTL FAR* lpp)
{
    // could save stack space and actually use lpp, but I won't!
    POINTword pt;
    GetCursorPos(&pt);
    lpp->x = pt.x;
    lpp->y = pt.y;
}

void    WINAPI GetCaretPos(POINTL FAR* lpp)
{
    POINTword pt;
    GetCaretPos(&pt);
    lpp->x = pt.x;
    lpp->y = pt.y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\unixtearoff.cxx ===
//+------------------------------------------------------------------------
//
//  File:       utearoff.cxx
//
//  Contents:   Tear off interfaces.
//
//  History:
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include <cdutil.hxx>
#include <tearoff.hxx>

typedef HRESULT (FNQI)(void *pv, REFIID iid, void **ppv);
typedef ULONG   (FNAR)(void *pv);

void TearoffCheck()
{
    AssertSz( 0, "Tearoff table too small" );
}

typedef HRESULT (STDMETHODCALLTYPE *PFNQI)(TEAROFF_THIS, REFIID, void **);

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv);

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk);

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk);

typedef void (*PFNVOID)();

#define THUNK_EXTERN(n) EXTERN_C void TearoffThunk##n(TEAROFF_THIS, ...);

THUNK_EXTERN(0) // QI
THUNK_EXTERN(1) // ADDREF
THUNK_EXTERN(2) // RELEASE

THUNK_ARRAY_3_TO_15(EXTERN)
THUNK_ARRAY_16_AND_UP(EXTERN)

#define TEAROFFCHECK_THUNK NONVIRTUAL_METHOD(TearoffCheck, (TEAROFF_THIS))
#define THUNK_ADDRESS(n) NONVIRTUAL_METHOD(TearoffThunk##n, (TEAROFF_THIS))
#define THUNK_PLAIN_ADDRESS(n) ((PLAINPFNTEAROFF)&TearoffThunk##n),

typedef void (CVoid::*PMETHOD)();
#define VTBL_METHOD(apfnVtbl,i) (((PMETHOD *)apfnVtbl)[i+1])

#if defined(UNIX) && defined(hp700)
PLAINPFNTEAROFF g_unixTearOffThunkTable[] = {
    THUNK_PLAIN_ADDRESS(0)
    THUNK_PLAIN_ADDRESS(1)
    THUNK_PLAIN_ADDRESS(2)
    THUNK_ARRAY_3_TO_15(PLAIN_ADDRESS)
    THUNK_ARRAY_16_AND_UP(PLAIN_ADDRESS)
};
#endif
 
NONVIRTUAL_VTABLE_ENTRY s_unixTearOffVtable[] = {
    NULL_METHOD,
//    THUNK_ADDRESS(0)
    NONVIRTUAL_METHOD(PlainQueryInterface, (TEAROFF_THIS, REFIID, void**))
    NONVIRTUAL_METHOD(PlainAddRef, (TEAROFF_THIS))
    NONVIRTUAL_METHOD(PlainRelease, (TEAROFF_THIS))
    THUNK_ARRAY_3_TO_15(ADDRESS)
    THUNK_ARRAY_16_AND_UP(ADDRESS)
#if DBG==1
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK  
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK  TEAROFFCHECK_THUNK
    TEAROFFCHECK_THUNK
#endif
};

static void * s_pvCache1 = NULL;
static void * s_pvCache2 = NULL;

HRESULT STDMETHODCALLTYPE
PlainQueryInterface(TEAROFF_THUNK * pthunk, REFIID iid, void **ppv)
{
	void *pv;
    const void *apfnVtbl;
    IID const * const * ppIID;

    for (ppIID = pthunk->apIID; *ppIID; ppIID++)
    {
        if (**ppIID == iid)
        {
            *ppv = pthunk;
            pthunk->ulRef += 1;
            return S_OK;
        }
    }

    if (pthunk->dwMask & 1)
    {
        pv = pthunk->pvObject2;
        apfnVtbl = pthunk->apfnVtblObject2;
    }
    else
    {
        pv = pthunk->pvObject1;
        apfnVtbl = pthunk->apfnVtblObject1;
    }

    return CALL_METHOD(pv, VTBL_METHOD(apfnVtbl,METHOD_QI), (iid, ppv));
}

void DeinitTearOffCache()
{
    MemFree(s_pvCache1);
    MemFree(s_pvCache2);
}

ULONG STDMETHODCALLTYPE
PlainAddRef (TEAROFF_THUNK * pthunk)
{
    return ++pthunk->ulRef;
}

ULONG STDMETHODCALLTYPE
PlainRelease (TEAROFF_THUNK * pthunk)
{
    WHEN_DBG(static long l = 0; l++;)

    Assert( pthunk->ulRef > 0 );

    if (--pthunk->ulRef == 0)
    {
        if (pthunk->pvObject1 && (pthunk->dwMask & METHOD_MASK( METHOD_RELEASE )) == 0)
        {
            CALL_METHOD(pthunk->pvObject1, VTBL_METHOD(pthunk->apfnVtblObject1,METHOD_RELEASE), ());            
        }
        if (pthunk->pvObject2)
        {
            CALL_METHOD(pthunk->pvObject2, VTBL_METHOD(pthunk->apfnVtblObject2,METHOD_RELEASE), ());            
        }

        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1,  pthunk );

        if (pthunk)
        {
            pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2,  pthunk );

            if (pthunk)
            {
                MemFree( pthunk );
            }
        }

        return 0;
    }

    return pthunk->ulRef;
}

//+------------------------------------------------------------------------
//
//  Function:   CreateTearOffTunk
//
//  Synopsis:   Create a tearoff interface thunk. The returned object
//              must be AddRef'ed by the caller.
//
//  Arguments:  pvObject    Delegate to this object using...
//              apfnObject    ...this array of pointers to member functions.
//              pUnkOuter   Delegate IUnknown methods to this object.
//              ppvThunk    The returned thunk.
//              pvObject2   Delegate to this object instead...
//              apfnObject2   ... this array of pointers to functions...
//              dwMask        ... when the index of the method call is
//                            marked in this mask.
//
//  Notes:      The basic implementation here consists of a thunk with
//              a pointer to two different objects.  If the second object
//              is NULL, it is assumed to be the first object.  This
//              is the logic of the thunks:
//
//                  i is the index of the method that is called.
//
//                  if (i < 16)
//                  {
//                      if (dwMask & 2^i)
//                      {
//                          Delegate to pvObject2 using apfnObject2
//                      }
//                  }
//                  Delegate to pvObject1 using apfnObject1
//
//-------------------------------------------------------------------------

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void *apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
        void *      pvObject2,
        void *      apfn2,
        DWORD       dwMask,
        const IID * const * apIID,
		void *		appropdescsInVtblOrder)
{
#   define ADD_REL_MASK (METHOD_MASK( METHOD_ADDREF ) || METHOD_MASK( METHOD_RELEASE ))

    TEAROFF_THUNK * pthunk;

    Assert(ppvThunk);
    Assert(apfn1);
    Assert((!pvObject2 && !apfn2) || (pvObject2 && apfn2));
    Assert(!(dwMask & 0xFFFF0000) && "Only 16 overrides allowed");
    Assert(!dwMask || (dwMask && pvObject2));
    Assert(!pUnkOuter || (dwMask == 0 && pvObject2 == 0));
    Assert((dwMask & ADD_REL_MASK) == 0 || ((dwMask & ADD_REL_MASK) == ADD_REL_MASK));

    if (pUnkOuter)
    {
        pvObject2 = pUnkOuter;
        apfn2 = *(void **)pUnkOuter;
        dwMask = METHOD_MASK( METHOD_QI );
    }

    pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache1, NULL);

    if (!pthunk)
    {
        pthunk = (TEAROFF_THUNK *) InterlockedExchangePointer(&s_pvCache2, NULL);

        if (!pthunk)
        {
            pthunk = (TEAROFF_THUNK *) _MemAlloc(sizeof(TEAROFF_THUNK));

            MemSetName((pthunk, "Tear-Off Thunk - owner=%08x", pvObject1));
        }
    }

    if (!pthunk)
    {
        *ppvThunk = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    pthunk->papfnVtblThis = s_unixTearOffVtable;
    pthunk->ulRef = 0;
    pthunk->pvObject1 = pvObject1;
    pthunk->apfnVtblObject1 = apfn1;
    pthunk->pvObject2 = pvObject2;
    pthunk->apfnVtblObject2 = apfn2;
    pthunk->dwMask = dwMask;
    pthunk->apIID = apIID ? apIID : (const IID * const *)&g_Zero;
	pthunk->apVtblPropDesc = appropdescsInVtblOrder;

    if (pvObject1 && (dwMask & METHOD_MASK( METHOD_ADDREF )) == 0)
    {
        CALL_METHOD(pthunk->pvObject1, VTBL_METHOD(pthunk->apfnVtblObject1,METHOD_ADDREF), ());
    }
    if (pvObject2)
    {
        CALL_METHOD(pthunk->pvObject2, VTBL_METHOD(pthunk->apfnVtblObject2,METHOD_ADDREF), ());
    }
    *ppvThunk = pthunk;

    return S_OK;
}

// Short argument list version saves space in calling functions.

HRESULT
CreateTearOffThunk(
        void *      pvObject1,
        const void * apfn1,
        IUnknown *  pUnkOuter,
        void **     ppvThunk,
		void *	    appropdescsInVtblOrder)
{
    return CreateTearOffThunk(
            pvObject1, 
            apfn1, 
            pUnkOuter, 
            ppvThunk, 
            NULL, 
            NULL, 
            0, 
            NULL,
			appropdescsInVtblOrder);
}

HRESULT
InstallTearOffObject(void * pvthunk, void * pvObject, void *apfn, DWORD dwMask)
{
    TEAROFF_THUNK *pthunk = (TEAROFF_THUNK*)pvthunk;

    // This assert is for the asm code that decodes the thunk
    // Since TEAROFF_THUNK is only defined in this file, I
    // call this here.  If this changes a lot of stuff needs
    // to be changed with it.  (jbeda)
    Assert(offsetof(TEAROFF_THUNK, pvObject2) == 20);

    Assert(pthunk);
    Assert(!pthunk->pvObject2);
    Assert(!pthunk->apfnVtblObject2);
    Assert(!pthunk->dwMask);

    pthunk->pvObject2 = pvObject;
    pthunk->apfnVtblObject2 = apfn;
    pthunk->dwMask = dwMask;

    if (pvObject)
    {
        CALL_METHOD(pvObject, VTBL_METHOD(apfn,1), ());
    }

    return S_OK;
}

// Add this to improve the Trident performance.
extern "C" MwFastGetCursorPos(POINT *pt);
BOOL GetCursorPos(LPPOINT pt)
{
    MwFastGetCursorPos(pt);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\vmem.cxx ===
//+------------------------------------------------------------------------
//
//  File:       vmem.cxx
//
//  Contents:   Strict memory allocation utilities
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_VMEM_HXX_
#define X_VMEM_HXX_
#include "vmem.hxx"
#endif

//
// VMem allocates memory using the operating system's low-level virtual allocator. It arranges for an
// allocation to start at the very beginning of a page, with a non-accessable page just before it,
// or for it to end at the very end of a page, with a non-accessible page just after it.  The idea is
// to catch memory overwrites quickly.
//
// The layout of an allocation is as follows:
//
//  +--- page VMEMINFO structure
//  |
//  |                 +--- pv if using front-side-strict memory allocations
//  |                 |
//  |                 |                   +--- filled with pattern to detect back-side overwrite
//  v                 v                   v
// +--------+--------+--------+--------+--------+--------+
// |VMEMINFO|   NO   |[User's memory area]XXXXXX|   NO   |
// |        | ACCESS |XXXXXX[User's memory area]| ACCESS |
// +--------+--------+--------+--------+--------+--------+
//                    ^     ^
//                    |     +--- pv if using back-side-strict memory allocations
//                    |
//                    +--- filled with pattern to detect front-side overwrite
//
//

#if defined(SPARC)
#define PAGE_SIZE       8192
#else
#define PAGE_SIZE       4096
#endif

DWORD
VMemQueryProtect(void * pv, DWORD cb)
{
    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQuery(pv, &mbi, sizeof(mbi));
    return (mbi.Protect ? mbi.Protect : mbi.AllocationProtect);
}

VMEMINFO *
VMemIsValid(void * pv)
{
    VMEMINFO * pvmi;
    BYTE * pb;
    UINT cb;

    if (pv == NULL)
    {
        return NULL;
    }

    pvmi = (VMEMINFO *)(((DWORD_PTR)pv & ~(PAGE_SIZE - 1)) - PAGE_SIZE * 2);

    if (VMemQueryProtect(pvmi, PAGE_SIZE) != PAGE_READONLY)
    {
        AssertSz(FALSE, "VMemIsValid - VMEMINFO page is not marked READONLY");
        return NULL;
    }

    if (pv != pvmi->pv)
    {
        AssertSz(FALSE, "VMemIsValid - VMEMINFO doesn't point back to pv");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE, PAGE_SIZE) != PAGE_NOACCESS)
    {
        AssertSz(FALSE, "VMemIsValid - can't detect first no-access page");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2, pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2) != PAGE_READWRITE)
    {
        AssertSz(FALSE, "VMemIsValid - user memory block is not all writable");
        return NULL;
    }

    if (pvmi->cbFill1)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2;
        cb = pvmi->cbFill1;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x1A)
            {
                AssertSz(FALSE, "VMemIsValid - detected user memory pre-data overwrite");
                return NULL;
            }
        }
    }

    if (pvmi->cbFill2)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb;
        cb = pvmi->cbFill2;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x3A)
            {
                AssertSz(FALSE, "VMemIsValid - detected user memory post-data overwrite");
                return NULL;
            }
        }
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2, PAGE_SIZE) != PAGE_NOACCESS)
    {
        AssertSz(FALSE, "VMemIsValid - can't detect second no-access page");
        return NULL;
    }

    return(pvmi);
}

void *
VMemAlloc(size_t cb, DWORD dwFlags, void * pvUser)
{
    void * pv1, * pv2, * pv3;
    size_t cbUser, cbPage;
    DWORD dwOldProtect;
    VMEMINFO * pvmi;

    if (cb == 0)
    {
        cb = 1;
    }

    if (    (dwFlags & VMEM_BACKSIDESTRICT)
        &&  (dwFlags & VMEM_BACKSIDEALIGN8))
        cbUser = (cb + 7) & ~7;
    else
        cbUser = cb;

    cbPage = (cbUser + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

	pv1 = VirtualAlloc(0, cbPage + PAGE_SIZE * 3, MEM_RESERVE, PAGE_NOACCESS);

    if (pv1 == NULL)
    {
        return(NULL);
    }

	pv2 = VirtualAlloc(pv1, PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

    if (pv2 == NULL)
    {
        return(NULL);
    }

    pvmi          = (VMEMINFO *)pv2;
    pvmi->cb      = cb;
    pvmi->dwFlags = dwFlags;
    pvmi->pvUser  = pvUser;

    pv3 = VirtualAlloc((BYTE *)pv1 + PAGE_SIZE * 2, cbPage, MEM_COMMIT, PAGE_READWRITE);

    if (pv3 == NULL)
    {
        return(NULL);
    }

    if (dwFlags & VMEM_BACKSIDESTRICT)
    {
        pvmi->cbFill1 = cbPage - cbUser;
        pvmi->cbFill2 = cbUser - cb;
    }
    else
    {
        pvmi->cbFill1 = 0;
        pvmi->cbFill2 = cbPage - cbUser;
    }

    Assert(pvmi->cbFill1 + cb + pvmi->cbFill2 == cbPage);

    if (pvmi->cbFill1)
    {
        memset((BYTE *)pv3, 0x1A, pvmi->cbFill1);
    }

    memset((BYTE *)pv3 + pvmi->cbFill1, 0x2A, cb);

    if (pvmi->cbFill2)
    {
        memset((BYTE *)pv3 + pvmi->cbFill1 + cb, 0x3A, pvmi->cbFill2);
    }

    pvmi->pv = (BYTE *)pv3 + pvmi->cbFill1;

    VirtualProtect(pv1, PAGE_SIZE, PAGE_READONLY, &dwOldProtect);

    Assert(VMemIsValid(pvmi->pv));

    return(pvmi->pv);
}

void *
VMemAllocClear(size_t cb, DWORD dwFlags, void * pvUser)
{
    void * pv = VMemAlloc(cb, dwFlags, pvUser);

    if (pv)
    {
        memset(pv, 0, cb);
    }

    return(pv);
}

HRESULT
VMemRealloc(void ** ppv, size_t cb, DWORD dwFlags, void * pvUser)
{
    if (cb == 0)
    {
        VMemFree(*ppv);
        return S_OK;
    }
    else if (*ppv == NULL)
    {
        *ppv = VMemAlloc(cb, dwFlags, pvUser);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }
    else
    {
        void *     pvOld    = *ppv;
        VMEMINFO * pvmiOld  = VMemIsValid(pvOld);
        void *     pvNew;

        if (pvmiOld == NULL)
        {
            return E_OUTOFMEMORY;
        }

        pvNew = VMemAlloc(cb, dwFlags, pvUser);

        if (pvNew == NULL)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(pvNew, pvOld, min(cb, pvmiOld->cb));

        VMemFree(pvOld);

        *ppv = pvNew;
        return S_OK;
    }
}

void
VMemFree(void * pv)
{
    VMEMINFO * pvmi = VMemIsValid(pv);

    if (pvmi)
    {
        Verify(VirtualFree(pvmi, 0, MEM_RELEASE));
    }
}

size_t
VMemGetSize(void * pv)
{
    VMEMINFO * pvmi = VMemIsValid(pv);
    return(pvmi ? pvmi->cb : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\wndclass.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       wndclass.cxx
//
//  Contents:   Window class utilities
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

static ATOM s_aatomWndClass[WNDCLASS_MAXTYPE];
const TCHAR aszWndClassNames[WNDCLASS_MAXTYPE][32] = {_T("Hidden"),
                                                      _T("Server"),
                                                      _T("TridentDlgFrame"),
                                                      _T("Overlay"),
                                                      _T("TridentCmboBx"),
                                                      _T("TridentLstBox"),
                                                      _T("ActiveMovie") };

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void 
SetWndClassAtom( UINT uIndex, ATOM atomWndClass)
{
    s_aatomWndClass[uIndex] = atomWndClass;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
ATOM
GetWndClassAtom(UINT uIndex)
{
    return s_aatomWndClass[uIndex];
}

//+---------------------------------------------------------------------------
//
//  Function:   Register window class
//
//  Synopsis:   Register a window class.
//
//  Arguments:  wndClassType Type of the window class
//              pfnWndProc   The window procedure.
//              style        Window style flags.
//              pstrBase     Base class name, can be null.
//              ppfnBase     Base class window proc, can be null.
//              patom        Name of registered class.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
RegisterWindowClass(
    UINT      wndClassType,
    LRESULT   (CALLBACK *pfnWndProc)(HWND, UINT, WPARAM, LPARAM),
    UINT      style,
    TCHAR *   pstrBase,
    WNDPROC * ppfnBase,
    HICON     hIconSm /* = NULL */ )
{
    TCHAR       achClass[64];
    WNDCLASSEX  wc;
    ATOM        atom;

    LOCK_GLOBALS;           // Guard access to globals (the passed atom and the atom array)

    // In case another thread registered before this one, we should return with success code
    // although we don't register in here.
    if (GetWndClassAtom(wndClassType))
        return S_OK;

    Verify(OK(Format(0,
            achClass,
            ARRAY_SIZE(achClass),
            _T("Internet Explorer_<0s>"),
            aszWndClassNames[wndClassType])));

    if (pstrBase)
    {
        wc.cbSize = sizeof(wc);

        if (!GetClassInfoEx(NULL, pstrBase, &wc))
            goto Error;

        *ppfnBase = wc.lpfnWndProc;
    }
    else
    {
        memset(&wc, 0, sizeof(wc));
//        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    }

    wc.cbSize = sizeof(wc);
    wc.lpfnWndProc = (WNDPROC)pfnWndProc;
    wc.lpszClassName = achClass;
    wc.style |= style;
    wc.hInstance = g_hInstCore;
    wc.hIconSm = hIconSm;
#ifdef _MAC
    if (g_fJapanSystem)
    {
        wc.cbWndExtra = sizeof(HIMC);
    } 
#endif

    atom = RegisterClassEx(&wc);
    if (!atom)
        goto Error;

#if defined(_MAC)
    atom = GlobalAddAtom(achClass);
#endif

    // set the entry in the array
    SetWndClassAtom(wndClassType, atom);

    return S_OK;

Error:
    DWORD dwErr = GetLastWin32Error();
    AssertSz(FALSE, "Could not register window class");
    RRETURN(dwErr);
}

#if DBG == 1
extern int g_lSecondaryObjCountCallers[15];
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DeinitWindowClasses
//
//  Synopsis:   Unregister any window classes we have registered.
//
//----------------------------------------------------------------------------

void
DeinitWindowClasses()
{
    int nIndex = WNDCLASS_MAXTYPE;
    
    while (--nIndex >= 0)
    {
#if !defined(_MAC)
        if (GetWndClassAtom(nIndex))
        {
            if (UnregisterClass((TCHAR *)(DWORD_PTR)GetWndClassAtom(nIndex), g_hInstCore))
            {
                // since we unregistered, the value can go now.
                SetWndClassAtom(nIndex, NULL);
            }
#if DBG == 1
            else
            {
                DWORD dwErr;

                dwErr = GetLastWin32Error();

                AssertSz((g_lSecondaryObjCountCallers[9] > 1), "Unable to unregister window class");
            }
#endif
        }
#else
        TCHAR szClassName[255];
        Verify(GlobalGetAtomName(s_aatomWndClass[nIndex], szClassName, sizeof(szClassName)));
        if (UnregisterClass(szClassName, g_hInstCore))
        {
            SetWndClassAtom(nIndex, NULL);
        }
        GlobalDeleteAtom(s_aatomWndClass[nIndex]);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\unix\teartest.cxx ===
#include <stdio.h>

#define EMPTY_CVOID
#ifdef EMPTY_CVOID

class CVoid
{
    virtual void _dummy()=0;
};

/*
(/ms/SUNWspro/bin/dbx) examine pd /20
0xefffe040:	 0x000213e0 0x00000001 0x00000002 0x000213b8
0xefffe050:	 0x00000003 0x00010a50 0x00000001 0xefffe0bc
0xefffe060:	 0xefffe0c4 0x00021000 0x00000000 0x00000000
0xefffe070:	 0x00000000 0x00000000 0x00000000 0x00000000
0xefffe080:	 0x00000000 0x00000000 0x00000000 0x00000000
(/ms/SUNWspro/bin/dbx) examine 0x213b8 /40
0x000213b8: __0dECDerG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010b78
0x000213c8: __0dECDerG__vtbl+0x0010:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x000213d8: __0dECDerG__vtbl+0x0020:	 0x00000000 0x00010d38 0x00000000 0x00000000 <-- *this
0x000213e8: __0dECDerG__vtbl+0x0030:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x000213f8: __0dFCBaseG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010e00
0x00021408: __0dFCBaseG__vtbl+0x0010:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x00021418: __0dFCBaseG__vtbl+0x0020:	 0x00000000 0x00021340 0x00000000 0x00000000
0x00021428: __0dFCBaseG__vtbl+0x0030:	 0x00000000 0x00010cf0 0x00000000 0x00010ca8
0x00021438: __0dEIUnkG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00021340
0x00021448: __0dEIUnkG__vtbl+0x0010:	 0x00000000 0x00021340 0x00000000 0x00000000
(/ms/SUNWspro/bin/dbx) examine 0x10b78
0x00010b78: ~CDer       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10cf0
0x00010cf0: a       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10ca8
0x00010ca8: b       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10d38
0x00010d38: c       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10e00
0x00010e00: ~CBase       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx)
*/

#else

class CVoid
{
    virtual void _dummy() {}
};

/*
(/ms/SUNWspro/bin/dbx) examine 0x2142c /40
0x0002142c: __0dECDerG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010ca8
0x0002143c: __0dECDerG__vtbl+0x0010:	 0x00000000 0x00010b78 0x00000000 0x00010d10
0x0002144c: __0dECDerG__vtbl+0x0020:	 0x00000000 0x00010cc8 0x00000000 0x00010d58
0x0002145c: __0dECDerG__vtbl+0x0030:	 0x00000000 0x00000000 0xfffc0000 0x00010d10
0x0002146c: __0dECDerG__vtbl+0x0040:	 0xfffc0000 0x00010cc8 0x00000000 0x00000000
0x0002147c: __0dFCBaseG__vtbl+0x0008:	 0x00000000 0x00010ca8 0x00000000 0x00010e38
0x0002148c: __0dFCBaseG__vtbl+0x0018:	 0x00000000 0x00010d10 0x00000000 0x00010cc8
0x0002149c: __0dFCBaseG__vtbl+0x0028:	 0x00000000 0x000213b0 0x00000000 0x00000000
0x000214ac: __0dFCBaseG__vtbl+0x0038:	 0xfffc0000 0x00010d10 0xfffc0000 0x00010cc8
0x000214bc: __0dFCVoidG__vtbl       :	 0x00000000 0x00000000 0x00000000 0x00010ca8
(/ms/SUNWspro/bin/dbx) examine 0x10ca8
0x00010ca8: _dummy       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10b78
0x00010b78: ~CDer       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10d10
0x00010d10: a       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10cc8
0x00010cc8: b       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) examine 0x10d58
0x00010d58: c       :	 0x9de3bfa0
(/ms/SUNWspro/bin/dbx) 
*/

#endif

class IUnk
{
public:
    virtual void ia() = 0;
    virtual void ib() = 0;
};

class IPrivUnk
{
public:
    virtual void a() = 0;
    virtual void b() = 0;
};


class CBase : public CVoid, IPrivUnk
{
public:

typedef void (CBase::*PFNTEAROFF)(void);

static PFNTEAROFF s_tearoff[];

public:
    int _a;
    int _b;

    CBase() : _a(1), _b(2) {}
    virtual ~CBase() {}

    virtual void a(){ printf ("%d\n", _a); }
    virtual void b(){ printf ("%d\n", _b); }

    virtual void c() = 0;

private:
    virtual void _dummy(){}
};

class CDer : public CBase
{
public:
    int _c;

    CDer() : _c(3) {}
    virtual ~CDer() {}

    virtual void c(){ printf ("%d\n", _c); }
};

void done(CDer *pd, CVoid *pv, CVoid *pvv, IUnk* pi)
{
    pi->ia();
    ((CBase*)pv)->a();

    printf ("Done\n");
}

CBase::PFNTEAROFF CBase::s_tearoff[] = { (PFNTEAROFF) (void(CVoid::*)())a };

int main()
{
    CDer d;
    done(&d, (CVoid*)&d, (CVoid*)(void*)&d, (IUnk*)&d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\unix\hp700\thunks.s ===
//----------------------------------------------------------------------------
 //
 // File:     thunks.S
 //
 // Contains: Assembly code for the PARISC - hand tuned from a generated .S file
 //
 //----------------------------------------------------------------------------

//#include <tearoff.hxx>



#define this        %r26
#define sp          %r30

#define offset      %r19
#define vtbl        %r20
#define index       %r21
#define dwMask      %r19         // CAREFULL!!! same as offset....
#define pfn         %r22

 //
 // Here's the layout of the 'this' object
 //
 // offset  value
 //
 //     0   don't care
 //     4   don't care
 //     8   don't care
 //     12  pvObject1's this
 //     16  pvObject1's function table
 //     20  pvObject2's this
 //     24  pvObject2's function table
 //     28  mask to decide whether to use Object 1 or 2
 //     32  index of method into vtbl
 //  Note:   Look in unixtearoff.cxx for latest structure definition
 //

#define off_pvObject1           12
#define off_pvObjectVtbl1       16
#define off_pvObject2           20
#define off_dwMask              28
#define off_dwN			32

#define objvtblDelta           (off_pvObjectVtbl1 - off_pvObject1)

 //----------------------------------------------------------------------------
//----------------------------------------------------------------------------

#define COMPLETE_THUNK(n)                                                                           !\
L$CompleteThunk##n                                                                                  !\
    LDH     ((8*(n+1))+0)(vtbl), offset                 /* offset = vtbl[n].offset */               !\
    EXTRS   offset,31,16,offset                                                                     !\
    LDW     ((8*(n+1))+4)(vtbl), pfn                    /* pfn = vtbl[n].pfn */                     !\
    LDH     ((8*(n+1))+2)(vtbl), index                  /* index = vtbl[n].realVtblIndex */         !\
    EXTRS   index,31,16,index                                                                       !\
                                                                                                    !\
    COMB,<= index,0,L$NonVirtual##n                     /* if ( index <= 0 ) goto NonVirtual */     !\
    NOP                                                                                             !\
                                                                                                    !\
/* Virtual */                                                                                       !\
    ADD     this,pfn,this                               /* this += (vtbl_offset)pfn */              !\
    LDW     0(this),vtbl                                /* vtbl = *this */                          !\
    SUB     this,pfn,this                               /* this -= (vtbl_offset)pfn */              !\
                                                                                                    !\
    SH3ADD  index,vtbl,vtbl                             /* vtbl += index * sizeof(VTBLENTRY) */     !\
                                                                                                    !\
    ADD     offset,this,this                            /* this += offset */                        !\
    LDW     4(vtbl), pfn                                /* pfn = vtbl->pfn */                       !\
    LDH     0(vtbl), offset                             /* offset = vtbl->offset */                 !\
                                                                                                    !\
L$NonVirtual##n                                                                                     !\
    ADD     offset,this,this                            /* this += offset; */                       !\
    LDWS    2(pfn), %r19                                                                            !\
    LDWS    -2(pfn),pfn                                                                             !\
    LDSID   (pfn), vtbl                                                                             !\
    MTSP    vtbl, %sr0                                                                              !\
    BE      0(%sr0,pfn)                                 /* func(); */                               !\
    NOP


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define THUNK_IMPLEMENT_SIMPLE(n)                \
! .SPACE $TEXT$                                  \
! .SUBSPA $CODE$                                 \
! .EXPORT TearoffThunk##n                        \
                                                !\
TearoffThunk##n                                 !\
                                                !\
        ADDI    n, %r0, %r28                    !\
        LDO     off_dwN(this), dwMask           !\
        STW     %r28, 0(dwMask)                 !\
        COPY    this, %r28                      !\
                                                !\
        LDW     off_pvObjectVtbl1(this),vtbl    !\
        LDW     off_pvObject1(this),this        !\
                                                !\
        COMPLETE_THUNK(n)                       !\



//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define THUNK_IMPLEMENT_COMPARE(n)               \
! .SPACE $TEXT$                                  \
! .SUBSPA $CODE$                                 \
! .EXPORT TearoffThunk##n                        \
                                                !\
TearoffThunk##n                                 !\
        ADDI    n, %r0, %r28                    !\
        LDO     off_dwN(this), dwMask           !\
        STW     %r28, 0(dwMask)                 !\
        COPY    this, %r28                      !\
                                                !\
        LDW          28(this), dwMask           !\
        EXTRS,>=   dwMask,31-n,1,%r0            !\
        LDO          8(this),this               !\
                                                !\
        LDW     off_pvObjectVtbl1(this),vtbl    !\
        LDW     off_pvObject1(this),this        !\
                                                !\
        COMPLETE_THUNK(n)                       !\

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define THUNK_IMPLEMENT_CRASH(n)                 \
! .SPACE $TEXT$                                  \
! .SUBSPA $CODE$                                 \
! .EXPORT TearoffThunk##n                        \
                                                !\
TearoffThunk##n                                 !\
        ADDI    0, %r0, %r28                    !\
        STW     %r28, 0(%r28)                   

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
        .SPACE  $TEXT$
        .SUBSPA $CODE$,QUAD=0,ALIGN=4,ACCESS=0x2c,CODE_ONLY,SORT=24

        .EXPORT doThunk__12CMethodThunkFv,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkFv

        .EXPORT doThunk__12CMethodThunkFPve,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,ARGW2=GR,ARGW3=GR,RTNVAL=GR
doThunk__12CMethodThunkFPve

        .EXPORT doThunk__12CMethodThunkFie,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR,ARGW2=GR,ARGW3=GR,RTNVAL=GR
doThunk__12CMethodThunkFie

        .EXPORT doThunk__12CMethodThunkFR16TextContextEvent,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkFR16TextContextEvent

        .EXPORT doThunk__12CMethodThunkFPFP6HWND__UiT2l_le,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkFPFP6HWND__UiT2l_le

        .EXPORT doThunk__12CMethodThunkF5_GUIDe,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
doThunk__12CMethodThunkF5_GUIDe

        STW     %r2,-0x18(%r30)                             /* store the return address */
        LDW     4(this),vtbl                 
        LDW     0(this),this                
        LDO     -8(vtbl),vtbl
        BL      L$CompleteThunk0,%r0
        NOP


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
        .SPACE  $TEXT$
        .SUBSPA $CODE$
        .EXPORT _GetTearoff,ENTRY,PRIV_LEV=3 //,NO_RELOCATION,LONG_RETURN
_GetTearoff
        BV      %r0(%r2)
        NOP


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//
//      Define IUnknown thunks (0 - 2) only used by unixtearoff.cxx (simple)
//      Define the thunks from 3 to 15 (compare thunks)
//      Define the thunks from 16 onwards (simple thunks)
//


THUNK_IMPLEMENT_COMPARE(0)
THUNK_IMPLEMENT_SIMPLE(1)
THUNK_IMPLEMENT_SIMPLE(2)

//THUNK_IMPLEMENT_CRASH(3)
THUNK_IMPLEMENT_COMPARE(3)
THUNK_IMPLEMENT_COMPARE(4)
THUNK_IMPLEMENT_COMPARE(5)
THUNK_IMPLEMENT_COMPARE(6)
THUNK_IMPLEMENT_COMPARE(7)
THUNK_IMPLEMENT_COMPARE(8)
THUNK_IMPLEMENT_COMPARE(9)
THUNK_IMPLEMENT_COMPARE(10)
THUNK_IMPLEMENT_COMPARE(11)
THUNK_IMPLEMENT_COMPARE(12)
THUNK_IMPLEMENT_COMPARE(13)
THUNK_IMPLEMENT_COMPARE(14)
THUNK_IMPLEMENT_COMPARE(15)

THUNK_IMPLEMENT_SIMPLE(16)
THUNK_IMPLEMENT_SIMPLE(17)
THUNK_IMPLEMENT_SIMPLE(18)
THUNK_IMPLEMENT_SIMPLE(19)
THUNK_IMPLEMENT_SIMPLE(20)
THUNK_IMPLEMENT_SIMPLE(21)
THUNK_IMPLEMENT_SIMPLE(22)
THUNK_IMPLEMENT_SIMPLE(23)
THUNK_IMPLEMENT_SIMPLE(24)
THUNK_IMPLEMENT_SIMPLE(25)
THUNK_IMPLEMENT_SIMPLE(26)
THUNK_IMPLEMENT_SIMPLE(27)
THUNK_IMPLEMENT_SIMPLE(28)
THUNK_IMPLEMENT_SIMPLE(29)
THUNK_IMPLEMENT_SIMPLE(30)
THUNK_IMPLEMENT_SIMPLE(31)
THUNK_IMPLEMENT_SIMPLE(32)
THUNK_IMPLEMENT_SIMPLE(33)
THUNK_IMPLEMENT_SIMPLE(34)
THUNK_IMPLEMENT_SIMPLE(35)
THUNK_IMPLEMENT_SIMPLE(36)
THUNK_IMPLEMENT_SIMPLE(37)
THUNK_IMPLEMENT_SIMPLE(38)
THUNK_IMPLEMENT_SIMPLE(39)
THUNK_IMPLEMENT_SIMPLE(40)
THUNK_IMPLEMENT_SIMPLE(41)
THUNK_IMPLEMENT_SIMPLE(42)
THUNK_IMPLEMENT_SIMPLE(43)
THUNK_IMPLEMENT_SIMPLE(44)
THUNK_IMPLEMENT_SIMPLE(45)
THUNK_IMPLEMENT_SIMPLE(46)
THUNK_IMPLEMENT_SIMPLE(47)
THUNK_IMPLEMENT_SIMPLE(48)
THUNK_IMPLEMENT_SIMPLE(49)
THUNK_IMPLEMENT_SIMPLE(50)
THUNK_IMPLEMENT_SIMPLE(51)
THUNK_IMPLEMENT_SIMPLE(52)
THUNK_IMPLEMENT_SIMPLE(53)
THUNK_IMPLEMENT_SIMPLE(54)
THUNK_IMPLEMENT_SIMPLE(55)
THUNK_IMPLEMENT_SIMPLE(56)
THUNK_IMPLEMENT_SIMPLE(57)
THUNK_IMPLEMENT_SIMPLE(58)
THUNK_IMPLEMENT_SIMPLE(59)
THUNK_IMPLEMENT_SIMPLE(60)
THUNK_IMPLEMENT_SIMPLE(61)
THUNK_IMPLEMENT_SIMPLE(62)
THUNK_IMPLEMENT_SIMPLE(63)
THUNK_IMPLEMENT_SIMPLE(64)
THUNK_IMPLEMENT_SIMPLE(65)
THUNK_IMPLEMENT_SIMPLE(66)
THUNK_IMPLEMENT_SIMPLE(67)
THUNK_IMPLEMENT_SIMPLE(68)
THUNK_IMPLEMENT_SIMPLE(69)
THUNK_IMPLEMENT_SIMPLE(70)
THUNK_IMPLEMENT_SIMPLE(71)
THUNK_IMPLEMENT_SIMPLE(72)
THUNK_IMPLEMENT_SIMPLE(73)
THUNK_IMPLEMENT_SIMPLE(74)
THUNK_IMPLEMENT_SIMPLE(75)
THUNK_IMPLEMENT_SIMPLE(76)
THUNK_IMPLEMENT_SIMPLE(77)
THUNK_IMPLEMENT_SIMPLE(78)
THUNK_IMPLEMENT_SIMPLE(79)
THUNK_IMPLEMENT_SIMPLE(80)
THUNK_IMPLEMENT_SIMPLE(81)
THUNK_IMPLEMENT_SIMPLE(82)
THUNK_IMPLEMENT_SIMPLE(83)
THUNK_IMPLEMENT_SIMPLE(84)
THUNK_IMPLEMENT_SIMPLE(85)
THUNK_IMPLEMENT_SIMPLE(86)
THUNK_IMPLEMENT_SIMPLE(87)
THUNK_IMPLEMENT_SIMPLE(88)
THUNK_IMPLEMENT_SIMPLE(89)
THUNK_IMPLEMENT_SIMPLE(90)
THUNK_IMPLEMENT_SIMPLE(91)
THUNK_IMPLEMENT_SIMPLE(92)
THUNK_IMPLEMENT_SIMPLE(93)
THUNK_IMPLEMENT_SIMPLE(94)
THUNK_IMPLEMENT_SIMPLE(95)
THUNK_IMPLEMENT_SIMPLE(96)
THUNK_IMPLEMENT_SIMPLE(97)
THUNK_IMPLEMENT_SIMPLE(98)
THUNK_IMPLEMENT_SIMPLE(99)
THUNK_IMPLEMENT_SIMPLE(100)
THUNK_IMPLEMENT_SIMPLE(101)
THUNK_IMPLEMENT_SIMPLE(102)
THUNK_IMPLEMENT_SIMPLE(103)
THUNK_IMPLEMENT_SIMPLE(104)
THUNK_IMPLEMENT_SIMPLE(105)
THUNK_IMPLEMENT_SIMPLE(106)
THUNK_IMPLEMENT_SIMPLE(107)
THUNK_IMPLEMENT_SIMPLE(108)
THUNK_IMPLEMENT_SIMPLE(109)
THUNK_IMPLEMENT_SIMPLE(110)
THUNK_IMPLEMENT_SIMPLE(111)
THUNK_IMPLEMENT_SIMPLE(112)
THUNK_IMPLEMENT_SIMPLE(113)
THUNK_IMPLEMENT_SIMPLE(114)
THUNK_IMPLEMENT_SIMPLE(115)
THUNK_IMPLEMENT_SIMPLE(116)
THUNK_IMPLEMENT_SIMPLE(117)
THUNK_IMPLEMENT_SIMPLE(118)
THUNK_IMPLEMENT_SIMPLE(119)
THUNK_IMPLEMENT_SIMPLE(120)
THUNK_IMPLEMENT_SIMPLE(121)
THUNK_IMPLEMENT_SIMPLE(122)
THUNK_IMPLEMENT_SIMPLE(123)
THUNK_IMPLEMENT_SIMPLE(124)
THUNK_IMPLEMENT_SIMPLE(125)
THUNK_IMPLEMENT_SIMPLE(126)
THUNK_IMPLEMENT_SIMPLE(127)
THUNK_IMPLEMENT_SIMPLE(128)
THUNK_IMPLEMENT_SIMPLE(129)
THUNK_IMPLEMENT_SIMPLE(130)
THUNK_IMPLEMENT_SIMPLE(131)
THUNK_IMPLEMENT_SIMPLE(132)
THUNK_IMPLEMENT_SIMPLE(133)
THUNK_IMPLEMENT_SIMPLE(134)
THUNK_IMPLEMENT_SIMPLE(135)
THUNK_IMPLEMENT_SIMPLE(136)
THUNK_IMPLEMENT_SIMPLE(137)
THUNK_IMPLEMENT_SIMPLE(138)
THUNK_IMPLEMENT_SIMPLE(139)
THUNK_IMPLEMENT_SIMPLE(140)
THUNK_IMPLEMENT_SIMPLE(141)
THUNK_IMPLEMENT_SIMPLE(142)
THUNK_IMPLEMENT_SIMPLE(143)
THUNK_IMPLEMENT_SIMPLE(144)
THUNK_IMPLEMENT_SIMPLE(145)
THUNK_IMPLEMENT_SIMPLE(146)
THUNK_IMPLEMENT_SIMPLE(147)
THUNK_IMPLEMENT_SIMPLE(148)
THUNK_IMPLEMENT_SIMPLE(149)
THUNK_IMPLEMENT_SIMPLE(150)
THUNK_IMPLEMENT_SIMPLE(151)
THUNK_IMPLEMENT_SIMPLE(152)
THUNK_IMPLEMENT_SIMPLE(153)
THUNK_IMPLEMENT_SIMPLE(154)
THUNK_IMPLEMENT_SIMPLE(155)
THUNK_IMPLEMENT_SIMPLE(156)
THUNK_IMPLEMENT_SIMPLE(157)
THUNK_IMPLEMENT_SIMPLE(158)
THUNK_IMPLEMENT_SIMPLE(159)
THUNK_IMPLEMENT_SIMPLE(160)
THUNK_IMPLEMENT_SIMPLE(161)
THUNK_IMPLEMENT_SIMPLE(162)
THUNK_IMPLEMENT_SIMPLE(163)
THUNK_IMPLEMENT_SIMPLE(164)
THUNK_IMPLEMENT_SIMPLE(165)
THUNK_IMPLEMENT_SIMPLE(166)
THUNK_IMPLEMENT_SIMPLE(167)
THUNK_IMPLEMENT_SIMPLE(168)
THUNK_IMPLEMENT_SIMPLE(169)
THUNK_IMPLEMENT_SIMPLE(170)
THUNK_IMPLEMENT_SIMPLE(171)
THUNK_IMPLEMENT_SIMPLE(172)
THUNK_IMPLEMENT_SIMPLE(173)
THUNK_IMPLEMENT_SIMPLE(174)
THUNK_IMPLEMENT_SIMPLE(175)
THUNK_IMPLEMENT_SIMPLE(176)
THUNK_IMPLEMENT_SIMPLE(177)
THUNK_IMPLEMENT_SIMPLE(178)
THUNK_IMPLEMENT_SIMPLE(179)
THUNK_IMPLEMENT_SIMPLE(180)
THUNK_IMPLEMENT_SIMPLE(181)
THUNK_IMPLEMENT_SIMPLE(182)
THUNK_IMPLEMENT_SIMPLE(183)
THUNK_IMPLEMENT_SIMPLE(184)
THUNK_IMPLEMENT_SIMPLE(185)
THUNK_IMPLEMENT_SIMPLE(186)
THUNK_IMPLEMENT_SIMPLE(187)
THUNK_IMPLEMENT_SIMPLE(188)
THUNK_IMPLEMENT_SIMPLE(189)
THUNK_IMPLEMENT_SIMPLE(190)
THUNK_IMPLEMENT_SIMPLE(191)
THUNK_IMPLEMENT_SIMPLE(192)
THUNK_IMPLEMENT_SIMPLE(193)
THUNK_IMPLEMENT_SIMPLE(194)
THUNK_IMPLEMENT_SIMPLE(195)
THUNK_IMPLEMENT_SIMPLE(196)
THUNK_IMPLEMENT_SIMPLE(197)
THUNK_IMPLEMENT_SIMPLE(198)
THUNK_IMPLEMENT_SIMPLE(199)

.END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\amd64\thunks.asm ===
;----------------------------------------------------------------------------
;
; File:     thunks.asm
;
; Contains: Assembly code for the AMD64. Implements the dynamic vtable stuff
;           and the tearoff code.
;
;----------------------------------------------------------------------------

include ksamd64.inc

offsetof_pvObject1 equ 24
offsetof_pvObject2 equ 40
offsetof_apfn equ 32
offsetof_mask equ 56
offsetof_n equ 60

;----------------------------------------------------------------------------
;
;  Function:  GetTearoff
;
;  Synopsis:  This function returns the tearoff thunk pointer stored in
;             the temp register r11. This should be called first thing from
;             the C++ functions that handles calls to torn-off interfaces
;
;  N.B. Warning - This method of passing the tearoff pointer in a volatile
;       register is unreliable. If the callee allocates more than a page of
;       memory, then check stack (__chkstk) will be called. Check stack
;       destroys all volatile registers.
;
;----------------------------------------------------------------------------

        LEAF_ENTRY _GetTearoff, _TEXT$00

        mov     rax, r11                ; set tearoff pointer
        ret                             ; return

        LEAF_END _GetTearoff, _TEXT$00

;----------------------------------------------------------------------------
;
;  Function:  TearOffCompareThunk
;
;  Synopsis:  The "handler" function that handles calls to torn-off interfaces
;
;  Notes:     Delegates to methods in the function pointer array held by
;             the CTearOffThunk class
;
;----------------------------------------------------------------------------

COMPARE_THUNK macro Number

        LEAF_ENTRY TearoffThunk&Number, _TEXT$00

        mov     r11, rcx                ; save tearoff pointer
        mov     eax, offsetof_pvObject1 ; assume first object
        test    dword ptr offsetof_mask[rcx], 1 SHL &Number ; test if mask bit set
        jz      short @f                ; if z, use first object
        mov     eax, offsetof_pvObject2 ; set for second object
@@:     mov     dword ptr offsetof_n[rcx], &Number ; set index of called method
        mov     rcx, [rcx][rax]         ; set 'this" pointer
        mov     rax, 8[rcx][rax]        ; get function array address
        jmp     qword ptr (8 * &Number)[rax] ; jump to function

        LEAF_END TearoffThunk&Number, _TEXT$00

        endm

;
; Generate compare thunks 3 - 15.
;

index = 3

        rept    (15 - 3 + 1)

        COMPARE_THUNK %index

index = index + 1

        endm

;----------------------------------------------------------------------------
;
;  Function:  CallTearOffSimpleThunk
;
;  Synopsis:  The "handler" function that handles calls to torn-off interfaces
;
;  Notes:     Delegates to methods in the function pointer array held by
;             the CTearOffThunk class
;
;----------------------------------------------------------------------------

SIMPLE_THUNK macro Number

        LEAF_ENTRY TearoffThunk&Number, _TEXT$00

        mov     r11, rcx                ; save tearoff pointer
        mov     dword ptr offsetof_n[rcx], &Number ; set index of called method
        mov     rax, offsetof_apfn[rcx] ; get function array address
        mov     rcx, offsetof_pvObject1[rcx] ; get object address
        jmp     qword ptr (8 * &Number)[rax] ; jump to function

        LEAF_END TearoffThunk&Number, _TEXT$00

        endm

;
; Generate simple thunks 16 - 199.
;

index = 16

        rept    (199 - 16 + 1)

        SIMPLE_THUNK %index

index = index + 1

        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\unix\sparc\thunks.s ===
/*
 //----------------------------------------------------------------------------
 //
 // File:     thunks.S
 //
 // Contains: Assembly code for the Sparc. Implements the dynamic vtable stuff
 //           and the tearoff code.
 //
 //----------------------------------------------------------------------------
*/

/* //#include <tearoff.hxx> */
#include "thunks_c.h"

#define this        %i0

#define vtbl        %l0
#define offset      %l1
#define pfn         %l2
#define index       %l3
#define dwMask      %l4
#define dwN	    %l5

/*
 //
 // Here's the layout of the 'this' object in $i0
 //
 // offset  value
 //
 //     0   don't care
 //     4   don't care
 //     8   don't care
 //     12  pvObject1's this
 //     16  pvObject1's function table
 //     20  pvObject2's this
 //     24  pvObject2's function table
 //     28  mask to decide whether to use Object 1 or 2
 //     32  index of method into vtbl
 //  Note:   Look in unixtearoff.cxx for latest structure definition
 //
*/

#define off_pvObject1           12
#define off_pvObjectVtbl1       16
#define off_pvObject2           20
#define off_dwMask              28
#define off_dwN			32

#define objvtblDelta           (off_pvObjectVtbl1 - off_pvObject1)
    
/*
 //----------------------------------------------------------------------------
 // Function:  _GetTearoff
 // 
 // Synopsis:  return the value left in global register (the pthunk pointer)
 //
 // Notes:     This pthunk pointer is left by THUNK_IMPLEMENT_COMARE 
 //            or THUNK_IMPLEMENT_SIMPLE
 //
 //----------------------------------------------------------------------------
*/
    .global _GetTearoff 
    .type   _GetTearoff,2

_GetTearoff:
    retl             
    mov %g2, %o0
 
/*
 //----------------------------------------------------------------------------
 //
 //  Function:  CompleteThunk
 //
 //  Synopsis:  Finishes up the complex and simple thunk handlers
 //
 //  Notes:     Modifies the this pointer and jumps to the corresponding virtual
 //             or non-virtual method.
 //
 //----------------------------------------------------------------------------
*/

#define COMPLETE_THUNK(n)                                                                       \
                                                                                                \
    .global cat(CompleteThunk,n);                                                               \
                                                                                                \
cat(CompleteThunk,n):                                                                           \
    ldsh    [vtbl + 8*(n+1)], offset;                   /* offset = vtbl[n].offset */           \
    lduw    [vtbl + 8*(n+1) + 4], pfn;                  /* pfn = vtbl[n].pfn */                 \
    ldsh    [vtbl + 8*(n+1) + 2], index;                /* index = vtbl[n].realVtblIndex */     \
                                                                                                \
    cmp     index,0;                                    /* if ( index == 0 ) */                 \
    beq       cat(NonVirtual,n);                        /*   goto NonVirtual; */                \
    nop;                                                                                        \
                                                                                                \
/* Virtual */                                                                                   \
    add     this,pfn,this;                              /* this += (vtbl_offset)pfn */          \
    lduw    [this],vtbl;                                /* vtbl = *this */                      \
    sub     this,pfn,this;                              /* this -= (vtbl_offset)pfn */          \
                                                                                                \
    sll     index,3,index;                              /* index *= sizeof(VTBLENTRY) */        \
    add     index,vtbl,vtbl;                            /* vtbl += index */                     \
                                                                                                \
    add     offset,this,this;                           /* this += offset */                    \
    lduw    [vtbl + 4], pfn;                            /* pfn = vtbl->pfn */                   \
    ldsh    [vtbl], offset;                             /* offset = vtbl->offset */             \
                                                                                                \
cat(NonVirtual,n):                                                                              \
    add     offset,this,this;                           /* this += offset; */                   \
    jmp     pfn;                                        /* func(); */                           \
    restore;


/*
 //----------------------------------------------------------------------------
 //
 //  Function:  TearOffCompareThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------
*/


#define THUNK_IMPLEMENT_COMPARE(n)                                                                                      \
                                                                                                                        \
    /* No frame */                                                                                                      \
    /* No prologue */                                                                                                   \
                                                                                                                        \
    .global cat(TearoffThunk,n);                                                                                        \
    .type   cat(TearoffThunk,n),2;                                                                                      \
                                                                                                                        \
cat(TearoffThunk,n):                                                                                                    \
    save    %sp,-64,%sp;                                                                                                \
    mov     this, %g2;                                  /* save this -> %g2      */                                     \
    mov     n,  dwN;                                                                                                    \
    stw     dwN, [this+off_dwN];                                                                                        \
    lduw    [this+off_dwMask], dwMask;                  /* dwMask = this->dwMask */                                     \
    srl     dwMask, n, dwMask;                          /* dwMask >>= n; */                                             \
    btst    1, dwMask;                                  /* if (! (dwMask & 1 )) */                                      \
    be        cat(Object1_,n);                          /*   goto Object1_n; */                                         \
    nop;                                                                                                                \
                                                                                                                        \
    add     off_pvObject2-off_pvObject1, this, this;    /* this += &pvObject2 - &pvObject1; */                          \
                                                        /* This boosts the following 2 instructions from pvObject1 */   \
                                                        /* and apfnVtblObject1 to the corresponding 2nd values */       \
cat(Object1_,n):                                                                                                        \
    lduw    [this + off_pvObject1 + objvtblDelta], vtbl;/* vtbl = *(this + offset(TEAROFF_THUNK, apfnVtblObject1) */    \
    lduw    [this + off_pvObject1], this;               /* this += offset(TEAROFF_THUNK, pvObject1 ) */                 \
                                                                                                                        \
    COMPLETE_THUNK(n)

/*
 //----------------------------------------------------------------------------
 //
 //  Function:  CallTearOffSimpleThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------
*/

#define THUNK_IMPLEMENT_SIMPLE(n)                                                               \
                                                                                                \
    /* No frame */                                                                              \
    /* No prologue */                                                                           \
                                                                                                \
    .global cat(TearoffThunk,n);                                                                \
    .type   cat(TearoffThunk,n),2;                                                              \
                                                                                                \
cat(TearoffThunk,n):                                                                            \
    save    %sp,-64,%sp;                                                                        \
    mov     this, %g2;                                                                          \
    mov     n, dwN;                                                                             \
    stw     dwN, [this + off_dwN];                                                              \
    lduw    [this + off_pvObject1 + objvtblDelta], vtbl;/* vtbl = this->apfnVtblObject1 */      \
    lduw    [this + off_pvObject1], this;               /* this = this->pvObject1 */            \
                                                                                                \
    COMPLETE_THUNK(n)


/*
//
//      Define IUnknown thunks (0 - 2) only used by unixtearoff.cxx (simple)
//      Define the thunks from 3 to 15 (compare thunks)
//      Define the thunks from 16 onwards (simple thunks)
//
*/

THUNK_IMPLEMENT_SIMPLE(0)
THUNK_IMPLEMENT_SIMPLE(1)
THUNK_IMPLEMENT_SIMPLE(2)

THUNK_ARRAY_3_TO_15(IMPLEMENT_COMPARE)

THUNK_ARRAY_16_AND_UP(IMPLEMENT_SIMPLE)


/*
 //----------------------------------------------------------------------------
 //
 //  Function:  CMethodThunk::doThunk implementations
 //
 //  Synopsis:  The thunk that calls class method pointers correctly.
 //
 //  Notes:  The CMethodThunk struct has at offsets:
 //
 //                 0 : this
 //                 4 : vtbl method pointer
 //
 //          Also, we call CompleteThunk0 to complete our call.  However,
 //          it always skips 8 bytes to get to the first vtable method so
 //          we substract 8 from the vtbl method poner before calling in.
 //
 //----------------------------------------------------------------------------
*/

    .global doThunk
    .type   doThunk,2
               
    .global __0fMCMethodThunkHdoThunkPve
    .type   __0fMCMethodThunkHdoThunkPve,2

    .global __0fMCMethodThunkHdoThunkie
    .type   __0fMCMethodThunkHdoThunkie,2

    .global __0fMCMethodThunkHdoThunkv
    .type   __0fMCMethodThunkHdoThunkv,2

    .global __0fMCMethodThunkHdoThunk6F_GUIDe
    .type   __0fMCMethodThunkHdoThunk6F_GUIDe,2

    .global __0fMCMethodThunkHdoThunkR6QTextContextEvent
    .type   __0fMCMethodThunkHdoThunkR6QTextContextEvent,2

doThunk:
__0fMCMethodThunkHdoThunkR6QTextContextEvent:
__0fMCMethodThunkHdoThunkie:
__0fMCMethodThunkHdoThunkv:
__0fMCMethodThunkHdoThunk6F_GUIDe:
__0fMCMethodThunkHdoThunkPve:
    save    %sp,-64,%sp
    lduw    [this +4], vtbl    /* vtbl = this->pfnMethod */
    lduw    [this], this       /* this = this->pObject */

    ba      CompleteThunk0
    dec     8, vtbl            /* vtbl = vtbl - sizeof(VTABLE_ENTRY) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\wutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       wutils.cxx
//
//  Contents:   Windows helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

DeclareTagOther(tagCombineRects,    "Combine Rects",        "CombineRects status")

//+----------------------------------------------------------------------------
//
//  Function:   CombineRectsAggressive
//
//  Synopsis:   Given an array of non-overlapping rectangles sorted top-to-bottom,
//              left-to-right combine them agressively, where there may
//              be some extra area create (but not too much).
//
//  Arguments:  pcRects     - Number of RECTs passed
//              arc         - Array of RECTs
//
//  Returns:    pcRects - Count of combined RECTs
//              arc     - Array of combined RECTs
//
//  NOTE: 1) RECTs must be sorted top-to-bottom, left-to-right and cannot be overlapping
//        2) arc is not reduced in size, the unused entries at the end are ignored
//
//-----------------------------------------------------------------------------
void
CombineRectsAggressive(int *pcRects, RECT *arc)
{
    int cRects;
    int iDest, iSrc=0;
    int cTemp=0;
    int aryTemp[MAX_INVAL_RECTS]; // touching rects to the right and bottom of rect iDest
    int aryWhichComb[MAX_INVAL_RECTS];  // index matches arc, value is which 
                                        // combined rect the invalid rect belongs
                                        // to. Zero = not set yet.
    int cCombined, marker, index, index2;
    int areaCombined, aryArea[MAX_INVAL_RECTS];
    RECT arcCombined[MAX_INVAL_RECTS];      // accumulates combined rects from arc
    
    
    Assert(pcRects);
    Assert(arc);
    
    // If there are no RECTs to combine, return immediately
    if (*pcRects <= 1)
        return;
    
#if DBG==1
    int areaOrig=0, areaNew=0;
    if ( IsTagEnabled(tagCombineRects) )
    {
        for (iDest=0; iDest < *pcRects; iDest++)
        {
            areaOrig += (arc[iDest].right - arc[iDest].left) * 
                        (arc[iDest].bottom - arc[iDest].top);
        }
    }
#endif // DBG==1
    
    // Combine rects aggressively. Touching rects are combined together,
    // which may make our final regions include areas that wasn't in 
    // the original list of rects. 
    memset( aryWhichComb, 0, sizeof(aryWhichComb) ); 
    memset( aryArea, 0, sizeof(aryArea) );
    cCombined = 0;
    for (iDest=0, cRects = *pcRects; iDest < cRects; iDest++)
    {
        // Combine abutting rects. Iterate through the array of rects 
        // (arranged from top-to-bottom, left-to-right) and enumerate 
        // those that touch to the right and bottom. Since this misses
        // those touching to the right and upwards we keep a list of 
        // which original rect belongs to which rect that is going to be 
        // passed back. As touching rects are accumulated, we check to 
        // see if any of these already belong to a rect that is going to 
        // be passed back. If it is, we add the ones currently being 
        // accumulated to that one.
        cTemp = 0;
        marker = cCombined + 1;
        aryTemp[cTemp++] = iDest;
        if ( aryWhichComb[iDest] > 0 )
            marker = aryWhichComb[iDest];
        
        for ( iSrc=iDest+1; 
        arc[iDest].bottom > arc[iSrc].top && 
            iSrc < cRects; iSrc++ )
        {
            Assert(arc[iDest].right <= arc[iSrc].left);
            if ( arc[iDest].right == arc[iSrc].left )
            {
                // I don't think this ever happens. but just in case it 
                // does this will do the right thing
                Assert( 0 && "Horizontal abutting invalid rects" );
                if ( aryWhichComb[iSrc] > 0 )
                    marker = aryWhichComb[iSrc];
                aryTemp[cTemp++] = iSrc;
            }
        }
        
        // Check rects below for abuttment. 
        for ( ; arc[iDest].bottom == arc[iSrc].top && 
            arc[iDest].right > arc[iSrc].left && 
            iSrc < cRects; iSrc++ )
        {
            if ( arc[iDest].left < arc[iSrc].right )
            {
                if ( aryWhichComb[iSrc] > 0 )
                    marker = aryWhichComb[iSrc];
                aryTemp[cTemp++] = iSrc;
            }
        }
        
        if ( cCombined + 1 == marker )
        {
            // this group of invalid rects doesn't combine with any 
            // existing rect that is going to be returned. Start a one
            arcCombined[cCombined] = arc[iDest];
            cCombined++;
        }
        
        // Add all rects accumulated on this pass to the rect that will be passed back.
        index = marker - 1;
        while ( --cTemp >= 0 )
        {
            index2 = aryTemp[cTemp];
            if ( aryWhichComb[index2] != marker )
            {
                aryWhichComb[index2] = marker;
                arcCombined[index].left    = min( arcCombined[index].left,   arc[index2].left );
                arcCombined[index].top     = min( arcCombined[index].top,    arc[index2].top );
                arcCombined[index].right   = max( arcCombined[index].right,  arc[index2].right );
                arcCombined[index].bottom  = max( arcCombined[index].bottom, arc[index2].bottom );
                aryArea[index] += (arc[index2].right - arc[index2].left) * 
                                  (arc[index2].bottom - arc[index2].top);
            }
        }
    }
    
    // check to make sure each rect meets the fitness criteria
    // don't want to be creating excessively large non-invalid
    // regions to draw
    cRects = cCombined;
    for ( index=0, marker=1; index<cCombined; index++, marker++ )
    {
        areaCombined = (arcCombined[index].right - arcCombined[index].left) *
                       (arcCombined[index].bottom - arcCombined[index].top);
        if ( areaCombined > 1000 && areaCombined > 3*aryArea[index] )
        {
            // scrap combined rect and fall back on just combining
            // areas that will not create any extra space.
#if DBG==1
            TraceTag((tagCombineRects, "EXTRA AREA TOO BIG! Inval area:%d, Extra Area:%d", 
                     aryArea[index], areaCombined-aryArea[index]));
#endif
            int index3=cRects, count=0;
            for ( index2=0; index2<*pcRects; index2++ )
            {
                if ( marker == aryWhichComb[index2] )
                {
                    arcCombined[index3++] = arc[index2];
                    count++;
                }
            }
#if DBG==1
            TraceTag((tagCombineRects, "Sending in %d rects.", count ));
#endif
            CombineRects( &count, &(arcCombined[cRects]));
#if DBG==1
            TraceTag((tagCombineRects, "Got back %d rects.", count ));
#endif
            cRects += count-1;
            memmove( &arcCombined[index], &arcCombined[index+1], 
                     (cRects-index)*sizeof(arcCombined[0]) );
            memmove( &aryArea[index], &aryArea[index+1], 
                     (cRects-index)*sizeof(aryArea[0]) );
            cCombined--;
            index--;
        }
    }
    
    
    // Weed out rects that may now be totally enclosed by the extra 
    // region gain in combining rects.
    for ( iSrc=cRects-1; iSrc>=0; iSrc-- )
    {   
        for ( iDest=0; iDest<cRects; iDest++ )
        {
            if ( arcCombined[iSrc].left   >= arcCombined[iDest].left  &&
                 arcCombined[iSrc].top    >= arcCombined[iDest].top   &&
                 arcCombined[iSrc].right  <= arcCombined[iDest].right &&
                 arcCombined[iSrc].bottom <= arcCombined[iDest].bottom &&
                 iDest != iSrc )
            {
#if DBG==1
                TraceTag((tagCombineRects, "Weeding out rect %d (total rects=%d)", 
                         iSrc, cRects ));
#endif
                memmove( &(arcCombined[iSrc]), &(arcCombined[iSrc+1]), 
                        (cRects-1-iSrc)*sizeof(arcCombined[0]) );
                cRects--;
                break;
            }
        }
    }
    // set output vars
    memmove( arc, arcCombined, cRects*sizeof(arc[0]) );
    *pcRects = cRects;
    

#if DBG==1
        if ( IsTagEnabled(tagCombineRects) )
        {
            // statistics for combining rects
            for (iDest=0; iDest < cRects; iDest++)
            {
                areaNew += (arc[iDest].right - arc[iDest].left) * (arc[iDest].bottom - arc[iDest].top);
            }
            TraceTag((tagCombineRects, "Previous # rects:%d, New # rects:%d", *pcRects, cRects ));
            TraceTag((tagCombineRects, "Excess drawing area: %d pixels, %d %% growth in the region", 
                                        areaNew-areaOrig, (100*(areaNew-areaOrig))/areaOrig));
            if ( areaNew-areaOrig < 0 )
                TraceTag((tagCombineRects, "Didn't draw something we should have??"));
        }
#endif // DBG==1

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   CombineRects
//
//  Synopsis:   Given an array of non-overlapping rectangles sorted top-to-bottom,
//              left-to-right combine them such that they create no extra area.
//
//  Arguments:  pcRects     - Number of RECTs passed
//              arc         - Array of RECTs
//
//  Returns:    pcRects - Count of combined RECTs
//              arc     - Array of combined RECTs
//
//  NOTE: 1) RECTs must be sorted top-to-bottom, left-to-right and cannot be overlapping
//        2) arc is not reduced in size, the unused entries at the end are ignored
//
//-----------------------------------------------------------------------------
void
CombineRects(int *pcRects, RECT *arc)
{
    int cRects;
    int iDest, iSrc=0;


    Assert(pcRects);
    Assert(arc);

    // If there are no RECTs to combine, return immediately
    if (*pcRects <= 1)
        return;

    // Combine RECTs of similar shape with adjoining boundaries
    for (iDest=0, cRects=*pcRects-1; iDest < cRects; iDest++)
    {
        // First, combine left-to-right those RECTs with the same top and bottom
        // (Since the array is sorted top-to-bottom, left-to-right, adjoining RECTs
        //  with the same top and bottom will be contiguous in the array. As a result,
        //  the loop only needs to continue looking at elements until one is found whose
        //  top or bottom coordinates do not match, or whose left edge is not adjoining.)
        for (iSrc=iDest+1;
            iSrc <= cRects && arc[iDest].top    == arc[iSrc].top    &&
                              arc[iDest].bottom == arc[iSrc].bottom &&
                              arc[iDest].right  >= arc[iSrc].left;
            iSrc++)
        {
            arc[iDest].right = arc[iSrc].right;
        }

        // If RECTs were combined, shift those remaining downward and adjust the total count
        if ((iSrc-1) > iDest)
        {
            cRects -= iSrc - iDest - 1;
            memmove(&arc[iDest+1], &arc[iSrc], cRects*sizeof(arc[0]));
        }

        // Next, combine top-to-bottom those RECTs whose bottoms and tops meet
        // (Again, since the array is sorted top-to-bottom, left-to-right, RECTs which share
        //  the left and right coordinates and touch bottom-to-top may not be next to one
        //  another in the array. The loop must scan until it founds an element whose top
        //  or left edge exceeds that of the destination RECT. It will skip elements whose
        //  tops occur above the bottom of the destination or which occur left of the
        //  destination. It will combine elements, one at a time, which touch bottom-to-top
        //  and have matching left/right coordinates.)
        for (iSrc=iDest+1; iSrc <= cRects; )
        {
            if (arc[iDest].bottom < arc[iSrc].top)
                break;

            else if (arc[iDest].bottom == arc[iSrc].top)
            {
                if (arc[iDest].left < arc[iSrc].left)
                    break;

                else if (arc[iDest].left  == arc[iSrc].left &&
                         arc[iDest].right == arc[iSrc].right)
                {
                    arc[iDest].bottom = arc[iSrc].bottom;
                    memmove(&arc[iSrc], &arc[iSrc+1], (cRects-iSrc)*sizeof(arc[0]));
                    cRects--;
                    continue;
                }
            }

            iSrc++;
        }
    }

    // Adjust the returned number RECTs
    *pcRects = cRects + 1;
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   BoundingRectl
//
//  Synopsis:   Returns a rectangle that bounds the two rectangled.  Unlike UnionRectl,
//              this function correctly computes a bounding rectangle when one of the
//              rectangles is just a point (has 0 width and height).
//
//  Arguments:  [prclDst]   - resulting RECTL
//              [prclSrc1]  - input RECTL
//              [prclSrc2]  - input RECTL
//
//  Returns:    TRUE if the result is not an empty RECTL
//              FALSE if the result is an empty RECTL
//----------------------------------------------------------------------------

BOOL BoundingRectl(RECTL *prclDst, const RECTL *prclSrc1, const RECTL *prclSrc2)
{
    prclDst->left = min(prclSrc1->left, prclSrc2->left);
    prclDst->top = min(prclSrc1->top, prclSrc2->top);
    prclDst->right = max(prclSrc1->right, prclSrc2->right);
    prclDst->bottom = max(prclSrc1->bottom, prclSrc2->bottom);
    return prclDst->right - prclDst->left + prclDst->bottom - prclDst->top;
}

//+---------------------------------------------------------------------------
//
//  Function:   NextEventTime
//
//  Synopsis:   Returns a value which can be use to determine when a given
//              number of milliseconds has passed.
//
//  Arguments:  [ulDelta] -- Number of milliseconds after which IsTimePassed
//                           will return TRUE.
//
//  Returns:    A timer value.  Guaranteed not to be zero.
//
//  Notes:      Due to the algorithm used in IsTimePassed, [ulDelta] cannot
//              be greater than ULONG_MAX/2.
//
//----------------------------------------------------------------------------

ULONG
NextEventTime(ULONG ulDelta)
{
    ULONG ulCur;
    ULONG ulRet;

    Assert(ulDelta < ULONG_MAX/2);

    ulCur = GetTickCount();

    if ((ULONG_MAX - ulCur) < ulDelta)
        ulRet = ulDelta - (ULONG_MAX - ulCur);
    else
        ulRet = ulCur + ulDelta;

    if (ulRet == 0)
        ulRet = 1;

    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsTimePassed
//
//  Synopsis:   Returns TRUE if the current time is later than the given time.
//
//  Arguments:  [ulTime] -- Timer value returned from NextEventTime().
//
//  Returns:    TRUE if the current time is later than the given time.
//
//----------------------------------------------------------------------------

BOOL
IsTimePassed(ULONG ulTime)
{
    ULONG ulCur = GetTickCount();

    if ((ulCur > ulTime) && (ulCur - ulTime < ULONG_MAX/2))
        return TRUE;

    return FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CCurs::CCurs
//
//  Synopsis:   Constructor.  Loads the specified cursor and pushes it
//              on top of the cursor stack.  If the cursor id matches a
//              standard Windows cursor, then the cursor is loaded from
//              the system.  Otherwise, the cursor is loaded from this
//              instance.
//
//  Arguments:  idr - The resource id
//
//-------------------------------------------------------------------------
CCurs::CCurs(LPCTSTR idr)
{
    _hcrsOld = SetCursorIDC(idr);
    _hcrs    = GetCursor();
}



//+------------------------------------------------------------------------
//
//  Member:     CCurs::~CCurs
//
//  Synopsis:   Destructor.  Pops the cursor specified in the constructor
//              off the top of the cursor stack.  If the active cursor has
//              changed in the meantime, through some other mechanism, then
//              the old cursor is not restored.
//
//-------------------------------------------------------------------------
CCurs::~CCurs( )
{
    if (GetCursor() == _hcrs)
    {
        ShowCursor(FALSE);
        SetCursor(_hcrsOld);
        ShowCursor(TRUE);
    }
}



//+------------------------------------------------------------------------
//
//  Function:   SetCursorIDC
//
//  Synopsis:   Set the cursor.  If the cursor id matches a standard
//              Windows cursor, then the cursor is loaded from the system.
//              Otherwise, the cursor is loaded from this instance.
//
//  Arguments:  idr - IDC_xxx from Windows.
//
//-------------------------------------------------------------------------

// This is done to avoid messiness of changing WINVER to 0x0500
#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

HCURSOR
SetCursorIDC(LPCTSTR idr, HCURSOR hCurNew/*=NULL*/ )
{
    HCURSOR hcursor, hcurRet;

    if ( ! hCurNew )
    {
        // No support for loading cursor by string id.
        Assert(IS_INTRESOURCE(idr));

        // If IDC_HYPERLINK is specified, lets use the windows
        // hand cursor in NT5 and memphis (44417)
        if(g_dwPlatformVersion >= 0x050000 &&
           idr == MAKEINTRESOURCE(IDC_HYPERLINK))
        {
            idr = IDC_HAND;
        }

        // We assume that if it's greater than IDC_ARROW,
        // then it's a system cursor.

        hcursor = LoadCursorA(
            // UNIXTODO (DWORD)idr should be changed to remove the high order 
            // WORD as for some unix platforms this may not be 0.
            ((DWORD_PTR)idr >= (DWORD_PTR)IDC_ARROW) ? NULL : g_hInstCore,
            (char *)idr);
        // NOTE (lmollico): cursors are in mshtml.dll

        // NOTE: (jbeda) If we were looking for IDC_HAND and didn't get it, 
        // try for IDC_HYPERLINK.  This shouldn't be necessary once memphis
        // implements the hand cursor but I'm leaving it here as a safety
        // precation

#if DBG == 1
        if ( ! hcursor )
        {
            DWORD err = GetLastError();
            TraceTag((tagError,"Error:%d", err));
        }
#endif
        if(!hcursor && idr == IDC_HAND)
        {
            idr = MAKEINTRESOURCE(IDC_HYPERLINK);
            hcursor = LoadCursorA(g_hInstCore, (char *)idr);
            // NOTE (lmollico): cursors are in mshtml.dll
        }

        Assert(hcursor && "Failed to load cursor");
    }
    else
        hcursor = hCurNew;
        
    hcurRet = GetCursor();
    if (   hcursor
        && hcurRet != hcursor
       )
    {
        // NOTE(sujalp): The windows SetCursor() call here has an *ugly* flash
        // in the incorrect position when the cursor's are changing. (Bug29467).
        // (This might be related to windows first showing the new cursor and then
        // setting its hotspot). To avoid this flash, we hide the cursor just
        // before changing the cursor and we enable it after changing the cursor.
        ShowCursor(FALSE);
        hcurRet = SetCursor(hcursor);
        ShowCursor(TRUE);
    }

    return hcurRet;
}


//  NOTE: This routine will be needed when Win95 fixes their bug
//          which prevents us from using LoadLibraryEx(.....,AS_DATAFILE)
//          to load the resource DLL.

#if NEVER
//+---------------------------------------------------------------
//
//  Function:   FormsCreateDialogParam
//
//  Synopsis:   Wraps the Windows API for CreateDialogParam, accounts for
//              the code/resource DLL split.
//
//
//  Arguments:  [hinst] -- instance of the module with the resource
//              [lpstrId] -- the identifier of the RCDATA resource
//              [hWndParent] -- hwnd of the parent window of the dialog box
//              [lpDialogFunc] -- the dialog proc
//              [dwInitParam] -- the initialization param to be passed to WM_DIALOGINIT
//
//  Returns:    the hwnd of the dialog box if successful, NULL otherwise
//
//  Notes:      This is an experimental implementation, it tosses the global
//              handle to the template immediately.
//
//----------------------------------------------------------------

HWND FormsCreateDialogParam(HINSTANCE hInstResource,
                            LPCTSTR  lpstrId,
                            HWND  hWndParent,
                            DLGPROC  lpDialogFunc,
                            LPARAM  dwInitParam)
{
    LPCDLGTEMPLATE  lpTemplate;
    HWND hwnd;

    lpTemplate = (LPCDLGTEMPLATE)GetResource(hInstResource,lpstrId,RT_DIALOG,NULL);
    hwnd = CreateDialogIndirectParam(g_hInstCore, lpTemplate,hWndParent, lpDialogFunc,  dwInitParam);

    return hwnd;
}


//+---------------------------------------------------------------
//
//  Function:   GetChildWindowRect
//
//  Synopsis:   Gets the rectangle of the child window in
//              its parent window coordinates
//
//  Arguments:  hwndChild   The child window
//              prc         The rectangle to fill with child's coordinates
//
//  Notes:      This function gets the screen coordinates of the child
//              then maps them into the client coordinates of its parent.
//
//----------------------------------------------------------------

void
GetChildWindowRect(HWND hwndChild, LPRECT prc)
{
    HWND hwndParent;

    // get the screen coordinates of the child window
    GetWindowRect(hwndChild, prc);

    // get the parent window of the child
    if ((hwndParent = GetParent(hwndChild)) != NULL)
    {
        ScreenToClient(hwndParent, (POINT *)&prc->left);
        ScreenToClient(hwndParent, (POINT *)&prc->right);
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   VBShiftState
//
//  Synopsis:   Helper function, returns shift state for KeyDown/KeyUp events
//
//  Arguments:  (none)
//
//  Returns:    USHORT
//
//  Notes:      This function maps the keystate supplied by Windows to
//              1, 2 and 4 (which are numbers from VB)
//
//----------------------------------------------------------------------------

short
VBShiftState()
{
    short sKeyState = 0;

    if (GetKeyState(VK_SHIFT) & 0x8000)
        sKeyState |= VB_SHIFT;

    if (GetKeyState(VK_CONTROL) & 0x8000)
        sKeyState |= VB_CONTROL;

    if (GetKeyState(VK_MENU) & 0x8000)
        sKeyState |= VB_ALT;

    return sKeyState;
}

short
VBShiftState(DWORD grfKeyState)
{
    short sKeyState = 0;

    if (grfKeyState & MK_SHIFT)
        sKeyState |= VB_SHIFT;

    if (grfKeyState & MK_CONTROL)
        sKeyState |= VB_CONTROL;

    if (grfKeyState & MK_ALT)
        sKeyState |= VB_ALT;

    return sKeyState;
}

//+---------------------------------------------------------------------------
//
//  Function:   VBButtonState
//
//  Synopsis:   Helper function, returns button state for Mouse events
//
//  Arguments:  w -- word containing mouse ButtonState
//
//  Returns:    short
//
//  Notes:      This function maps the buttonstate supplied by Windows to
//              1, 2 and 4 (which are numbers from VB)
//
//----------------------------------------------------------------------------

short
VBButtonState(WPARAM w)
{
    short sButtonState = 0;

    if (w & MK_LBUTTON)
        sButtonState |= VB_LBUTTON;
    if (w & MK_RBUTTON)
        sButtonState |= VB_RBUTTON;
    if (w & MK_MBUTTON)
        sButtonState |= VB_MBUTTON;

    return sButtonState;
}

//+------------------------------------------------------------------------
//
//  Function:   UpdateChildTree
//
//  Synopsis:   Calls UpdateWindow for a window, then recursively calls
//              UpdateWindow its children.
//
//  Arguments:  [hWnd]      Window to update, along with its children
//
//-------------------------------------------------------------------------
void
UpdateChildTree(HWND hWnd)
{
    //
    // The RedrawWindow call seems to miss the hWnd you actually pass in, or
    // else doesn't validate the update region after it has been redrawn, thus
    // the need for the UpdateWindow() call.
    //
    if (hWnd)
    {
        UpdateWindow(hWnd);
        RedrawWindow(hWnd,
                     (GDIRECT *)NULL,
                     NULL,
                     RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INTERNALPAINT
                    );
    }
}


#ifdef NEVER
//+------------------------------------------------------------------------
//
//  Function:  InClientArea
//
//  Synopsis:   Checks if point is within a hWnd's client area.
//
//  Arguments:  [hWnd]      Window handle
//              [pt]        a point
//
//-------------------------------------------------------------------------

BOOL
InClientArea(POINTL pt, HWND hWnd)
{
    RECT rc;
    ::GetClientRect(hWnd, &rc);

    ClientToScreen(hWnd, (POINT *) &rc.left);
    ClientToScreen(hWnd, (POINT *) &rc.right);

    return ::PtInRect(&rc,  (POINT&) pt);

}


//+----------------------------------------------------------------------------
//
//  Function:   IsWindowActive
//
//  Synopsis:   Determines if an HWND is active or not
//
//              The window is considered active when the following conditions
//              are met:
//                  a) The HWND is the active window for the thread or
//                     is a child of the active window
//                     (If another thread owns the active window, then
//                      GetActiveWindow on this thread will return NULL)
//                  b) The HWND has focus or is a child of the window
//                     which has focus
//                     (Again, if window with focus resides on another thread
//                      this GetFocus will return NULL)
//
//              These conditions are the closest analogy to what occurs when a
//              frame window receives either WM_ACTIVATE or WM_MDIACTIVATE
//
//  Arguments:  [hwnd] - Window handle to check
//
//  Returns:    TRUE if active, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
IsWindowActive(
    HWND    hwnd)
{
    HWND    hwndActive = GetActiveWindow();
    HWND    hwndFocus  = GetFocus();

    return (hwndActive &&
            hwndFocus  &&
            (hwndActive == hwnd || IsChild(hwndActive, hwnd)) &&
            (hwndFocus == hwnd  || IsChild(hwnd, hwndFocus)));
}


//+----------------------------------------------------------------------------
//
//  Function:   IsWindowPopup
//
//  Synopsis:   Returns TRUE if the passed HWND is contained within a window
//              that has WS_POPUP set
//
//  Arguments:  [hwnd] - Window handle to check
//
//  Returns:    TRUE if contained in a popup window, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
IsWindowPopup(
    HWND    hwnd)
{
    while (hwnd && !(GetWindowLong(hwnd, GWL_STYLE) & WS_POPUP))
        hwnd = GetParent(hwnd);

    return hwnd != NULL;
}
#endif // NEVER

//+----------------------------------------------------------------------------
//
//  Function:   GetOwningMDIChild
//
//  Synopsis:   Return the HWND of the MDI child which contains the passed
//              HWND
//
//  Arguments:  [hwnd] - Window handle for which to retrieve owning MDI child
//
//  Returns:    HWND of MDI child (if it exists), NULL otherwise
//
//-----------------------------------------------------------------------------
HWND
GetOwningMDIChild(
    HWND    hwnd)
{
    HWND    hwndMDIChild = hwnd;

    while (hwndMDIChild &&
           !(::GetWindowLong(hwndMDIChild, GWL_EXSTYLE) & WS_EX_MDICHILD))
    {
        hwndMDIChild = ::GetParent(hwndMDIChild);
    }

    return hwndMDIChild;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetOwnerOfParent
//
//  Synopsis:   Return the outer most owner/parent HWND of the given window
//              HWND
//
//  Arguments:  [hwnd] - Window handle for which to retrieve its owner
//
//  Returns:    HWND of its outer most owner/parent, itself otherwise
//
//-----------------------------------------------------------------------------
HWND
GetOwnerOfParent(HWND hwnd)
{
    HWND    hwndOwner = hwnd;
    HWND    hwndParent;

    Assert(hwnd);

    // Get outer most parent
    do
    {
        hwndParent = ::GetParent(hwndOwner);
        if (hwndParent)
        {
            hwndOwner = hwndParent;
        }
    } while (hwndParent);

    Assert(hwndOwner);

    // Get its owner
    hwndParent = ::GetWindow(hwndOwner, GW_OWNER);
    if (hwndParent)
    {
        hwndOwner = hwndParent;
    }

    return hwndOwner;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\ia64\thunks.s ===
//----------------------------------------------------------------------------
 //
 // File:     thunks.s
 //
 // Contains: Assembly code for the Alpha. Implements the dynamic vtable stuff
 //           and the tearoff code.
 //
 // NOTE!!: This file (after preprocessing) is what would normally be passed
 //         to ASAXP.EXE, the Alpha assembler.  Unfortunately that causes the
 //         assembler to GPF.  Instead the preprocessed version is hand-edited
 //         to replace all semicolons with newlines, remove all unnecessary
 //         spaces and replace all macros.
 //
 //----------------------------------------------------------------------------


#include "ksia64.h"


//
// These must be kept in sync with TEAROFF_THUNK structure offsets
//

#define offsetof_papfnVtblThis		0x00
#define offsetof_ulRef				0x08
#define offsetof_apIID				0x10		// pointer is 8 byte aligned
#define offsetof_pvObject1			0x18
#define offsetof_apfnVtblObject1	0x20
#define offsetof_pvObject2			0x28
#define offsetof_apfnVtblObject2	0x30
#define offsetof_dwMask				0x38
#define offsetof_n					0x3C
#define offsetof_apVtblPropDesc		0x40

#define ptr_width                   0x8



 //----------------------------------------------------------------------------
 //
 //  Function:  TearOffCompareThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //  In:		Pointer to TEAROFF_THUNK
 //----------------------------------------------------------------------------


#define THUNK_C_1(n)    LEAF_ENTRY(TearoffThunk##n)
#define THUNK_C_2(n)		add		t3 = offsetof_dwMask, a0		        /* pointer to mask */
#define THUNK_C_3(n)        add     t7 = r0, a0                             /* store the tearoff ptr in t7 */
#define THUNK_C_4(n)        add     t8 = offsetof_n, a0                     /* pointer to vtbl index */
#define THUNK_C_5(n)		;;
#define THUNK_C_6(n)		ld4		t4 = [t3]                               /* get mask */
#define THUNK_C_7(n)		add		t5 = offsetof_pvObject2, a0             /* pointer to pvObject2 */
#define THUNK_C_8(n)		add     t6 = offsetof_pvObject1, a0             /* pointer to pvObject1 */
#define THUNK_C_9(n)		;;
#define THUNK_C_10(n)       mov     t9 = n
#define THUNK_C_11(n)		tbit.nz	pt0, pt1 = t4, n                        /* see if we are using pvObject2 */ 
#define THUNK_C_12(n)       ;;
#define THUNK_C_13(n)       st4     [t8] = t9                               /* save the vtbl index */
#define THUNK_C_14(n) (pt0) mov     t3 = t5                                 /* pvObject2 */
#define THUNK_C_15(n) (pt1) mov     t3 = t6                                 /* pvObject1 */
#define THUNK_C_16(n)       ;;
#define THUNK_C_17(n)       ld8     a0 = [t3], ptr_width                    /* this->_pvObject goes to param 1*/
#define THUNK_C_18(n)       ;;       
#define THUNK_C_19(n)       ld8     t3 = [t3]                               /* ptr to apfnVtblObj */
#define THUNK_C_20(n)       ;;
#define THUNK_C_21(n)       shladd     t5 = t9, 3, t3                       /* increment by index * ptr size */
#define THUNK_C_22(n)       ;;
#define THUNK_C_23(n)       ld8     t4 = [t5]                               /* Get function pointer */
#define THUNK_C_24(n)       ;;
#define THUNK_C_25(n)       ld8     t5 = [t4], ptr_width                    /* Get pointer to code */ 
#define THUNK_C_26(n)       ;;
#define THUNK_C_27(n)       ld8     gp = [t4]                               /* Get GP pointer */    
#define THUNK_C_28(n)       mov     bt0 = t5
#define THUNK_C_29(n)       br.cond.sptk    bt0                             /* jump to the function */
#define THUNK_C_30(n)   LEAF_EXIT(TearoffThunk##n)


 //----------------------------------------------------------------------------
 //
 //  Function:  GetTearoff
 //
 //  Synopsis:  This function returns the tearoff thunk pointer stored in
 //             the temp register t7. This should be called first thing from
 //             the C++ functions that handles calls to torn-off interfaces
 //
 //----------------------------------------------------------------------------

#define THUNK_GT_1		LEAF_ENTRY(_GetTearoff)
#define THUNK_GT_2			add		v0 = r0, t7       /* place tearoff ptr in return reg */
#define THUNK_GT_3			br.ret.sptk b0
#define THUNK_GT_4		LEAF_EXIT(_GetTearoff)
#define THUNK_GT_5
#define THUNK_GT_6
#define THUNK_GT_7
#define THUNK_GT_8
#define THUNK_GT_9


//
//      Define the thunks from 3 to 15 (these are compare thunks)
//

#include "..\thunks_c.h"

 //----------------------------------------------------------------------------
 //
 //  Function:  CallTearOffSimpleThunk
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------



#define THUNK_S_1(n)    LEAF_ENTRY(TearoffThunk##n)
#define THUNK_S_2(n)        mov     t9 = n                                  /* We need n in a register */       
#define THUNK_S_3(n)        add     t4 = offsetof_apfnVtblObject1, a0       /* this->apfnVtblObject */
#define THUNK_S_4(n)        add     t3 = offsetof_pvObject1, a0             /* this->pObject */ 
#define THUNK_S_5(n)        ;;
#define THUNK_S_6(n)        ld8     t3 = [t3]                               /* Get pObject */
#define THUNK_S_7(n)        ld8     t4 = [t4]                               /* apfnVtblObject */
#define THUNK_S_8(n)        add     t5 = offsetof_n, a0                     /* this->n */
#define THUNK_S_9(n)        ;;
#define THUNK_S_10(n)       shladd  t4 = t9, 3, t4                          /* get function ptr address */
#define THUNK_S_11(n)       mov     t7 = a0                                 /* Save tearoff in t7 */
#define THUNK_S_12(n)       st4     [t5] = t9                               /* Save the index */
#define THUNK_S_13(n)       ;;
#define THUNK_S_14(n)       mov     a0 = t3                                 /* pObject goes to param 1 */
#define THUNK_S_15(n)       ld8     t4 = [t4] ;;                            /* Get function pointer. */
#define THUNK_S_16(n)       ld8     t5 = [t4], ptr_width ;;                 /* get code pointer */
#define THUNK_S_17(n)       ld8     gp = [t4]                               /* get GP pointer */
#define THUNK_S_18(n)       mov     bt0 = t5
#define THUNK_S_19(n)      br.cond.sptk    bt0                              /* jump to the function */
#define THUNK_S_20(n)    LEAF_EXIT(TearoffThunk##n)


//
//      Define the thunks from 16 onwards (these are simple thunks)
//

#include "..\thunks_s.h"

// .set macro
// .set reorder
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\unix\sparc\thunks_c.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       tearoff.hxx
//
//  Contents:   Tearoff Interface Utilities
//
//----------------------------------------------------------------------------


#ifndef _TEAROFF_HXX_
#define _TEAROFF_HXX_

#ifdef __STDC__
#define cat(a,b)        a##b
#else
#define cat(a,b)        a/**/b
#endif

#if defined(UNIX) && defined(_HPUX_SOURCE)
#define THUNK_ARRAY_3_TO_15(x) \
 THUNK_##x(3)   THUNK_##x(4)   THUNK_##x(5)   THUNK_##x(6)   THUNK_##x(7)   THUNK_##x(8)   THUNK_##x(9)   THUNK_##x(10)  THUNK_##x(11)  THUNK_##x(12)  THUNK_##x(13)  \
 THUNK_##x(14)  THUNK_##x(15)
    
#define THUNK_ARRAY_16_AND_UP(x) \
THUNK_##x(16)  THUNK_##x(17)  THUNK_##x(18)  THUNK_##x(19)  THUNK_##x(20)  THUNK_##x(21)  THUNK_##x(22)  THUNK_##x(23)  THUNK_##x(24)  \
THUNK_##x(25)  THUNK_##x(26)  THUNK_##x(27)  THUNK_##x(28)  THUNK_##x(29)  THUNK_##x(30)  THUNK_##x(31)  THUNK_##x(32)  THUNK_##x(33)  THUNK_##x(34)  THUNK_##x(35)  \
THUNK_##x(36)  THUNK_##x(37)  THUNK_##x(38)  THUNK_##x(39)  THUNK_##x(40)  THUNK_##x(41)  THUNK_##x(42)  THUNK_##x(43)  THUNK_##x(44)  THUNK_##x(45)  THUNK_##x(46)  \
THUNK_##x(47)  THUNK_##x(48)  THUNK_##x(49)  THUNK_##x(50)  THUNK_##x(51)  THUNK_##x(52)  THUNK_##x(53)  THUNK_##x(54)  THUNK_##x(55)  THUNK_##x(56)  THUNK_##x(57)  \
THUNK_##x(58)  THUNK_##x(59)  THUNK_##x(60)  THUNK_##x(61)  THUNK_##x(62)  THUNK_##x(63)  THUNK_##x(64)  THUNK_##x(65)  THUNK_##x(66)  THUNK_##x(67)  THUNK_##x(68)  \
THUNK_##x(69)  THUNK_##x(70)  THUNK_##x(71)  THUNK_##x(72)  THUNK_##x(73)  THUNK_##x(74)  THUNK_##x(75)  THUNK_##x(76)  THUNK_##x(77)  THUNK_##x(78)  THUNK_##x(79)  \
THUNK_##x(80)  THUNK_##x(81)  THUNK_##x(82)  THUNK_##x(83)  THUNK_##x(84)  THUNK_##x(85)  THUNK_##x(86)  THUNK_##x(87)  THUNK_##x(88)  THUNK_##x(89)  THUNK_##x(90)  \
THUNK_##x(91)  THUNK_##x(92)  THUNK_##x(93)  THUNK_##x(94)  THUNK_##x(95)  THUNK_##x(96)  THUNK_##x(97)  THUNK_##x(98)  THUNK_##x(99)  THUNK_##x(100) THUNK_##x(101) \
THUNK_##x(102) THUNK_##x(103) THUNK_##x(104) THUNK_##x(105) THUNK_##x(106) THUNK_##x(107) THUNK_##x(108) THUNK_##x(109) THUNK_##x(110) THUNK_##x(111) THUNK_##x(112) \
THUNK_##x(113) THUNK_##x(114) THUNK_##x(115) THUNK_##x(116) THUNK_##x(117) THUNK_##x(118) THUNK_##x(119) THUNK_##x(120) THUNK_##x(121) THUNK_##x(122) THUNK_##x(123) \
THUNK_##x(124) THUNK_##x(125) THUNK_##x(126) THUNK_##x(127) THUNK_##x(128) THUNK_##x(129) THUNK_##x(130) THUNK_##x(131) THUNK_##x(132) THUNK_##x(133) THUNK_##x(134) \
THUNK_##x(135) THUNK_##x(136) THUNK_##x(137) THUNK_##x(138) THUNK_##x(139) THUNK_##x(140) THUNK_##x(141) THUNK_##x(142) THUNK_##x(143) THUNK_##x(144) THUNK_##x(145) \
THUNK_##x(146) THUNK_##x(147) THUNK_##x(148) THUNK_##x(149) THUNK_##x(150) THUNK_##x(151) THUNK_##x(152) THUNK_##x(153) THUNK_##x(154) THUNK_##x(155) THUNK_##x(156) \
THUNK_##x(157) THUNK_##x(158) THUNK_##x(159) THUNK_##x(160) THUNK_##x(161) THUNK_##x(162) THUNK_##x(163) THUNK_##x(164) THUNK_##x(165) THUNK_##x(166) THUNK_##x(167) \
THUNK_##x(168) THUNK_##x(169) THUNK_##x(170) THUNK_##x(171) THUNK_##x(172) THUNK_##x(173) THUNK_##x(174) THUNK_##x(175) THUNK_##x(176) THUNK_##x(177) THUNK_##x(178) \
THUNK_##x(179) THUNK_##x(180) THUNK_##x(181) THUNK_##x(182) THUNK_##x(183) THUNK_##x(184) THUNK_##x(185) THUNK_##x(186) THUNK_##x(187) THUNK_##x(188) THUNK_##x(189) \
THUNK_##x(190) THUNK_##x(191) THUNK_##x(192) THUNK_##x(193) THUNK_##x(194) THUNK_##x(195) THUNK_##x(196) THUNK_##x(197) THUNK_##x(198) THUNK_##x(199)        
#else
#define THUNK_ARRAY_3_TO_15(x) \
 cat(THUNK_,x)(3)   cat(THUNK_,x)(4)   cat(THUNK_,x)(5)   cat(THUNK_,x)(6)   cat(THUNK_,x)(7)   cat(THUNK_,x)(8)   cat(THUNK_,x)(9)   cat(THUNK_,x)(10)  cat(THUNK_,x)(11)  cat(THUNK_,x)(12)  cat(THUNK_,x)(13)  \
 cat(THUNK_,x)(14)  cat(THUNK_,x)(15)
    
#define THUNK_ARRAY_16_AND_UP(x) \
cat(THUNK_,x)(16)  cat(THUNK_,x)(17)  cat(THUNK_,x)(18)  cat(THUNK_,x)(19)  cat(THUNK_,x)(20)  cat(THUNK_,x)(21)  cat(THUNK_,x)(22)  cat(THUNK_,x)(23)  cat(THUNK_,x)(24)  \
cat(THUNK_,x)(25)  cat(THUNK_,x)(26)  cat(THUNK_,x)(27)  cat(THUNK_,x)(28)  cat(THUNK_,x)(29)  cat(THUNK_,x)(30)  cat(THUNK_,x)(31)  cat(THUNK_,x)(32)  cat(THUNK_,x)(33)  cat(THUNK_,x)(34)  cat(THUNK_,x)(35)  \
cat(THUNK_,x)(36)  cat(THUNK_,x)(37)  cat(THUNK_,x)(38)  cat(THUNK_,x)(39)  cat(THUNK_,x)(40)  cat(THUNK_,x)(41)  cat(THUNK_,x)(42)  cat(THUNK_,x)(43)  cat(THUNK_,x)(44)  cat(THUNK_,x)(45)  cat(THUNK_,x)(46)  \
cat(THUNK_,x)(47)  cat(THUNK_,x)(48)  cat(THUNK_,x)(49)  cat(THUNK_,x)(50)  cat(THUNK_,x)(51)  cat(THUNK_,x)(52)  cat(THUNK_,x)(53)  cat(THUNK_,x)(54)  cat(THUNK_,x)(55)  cat(THUNK_,x)(56)  cat(THUNK_,x)(57)  \
cat(THUNK_,x)(58)  cat(THUNK_,x)(59)  cat(THUNK_,x)(60)  cat(THUNK_,x)(61)  cat(THUNK_,x)(62)  cat(THUNK_,x)(63)  cat(THUNK_,x)(64)  cat(THUNK_,x)(65)  cat(THUNK_,x)(66)  cat(THUNK_,x)(67)  cat(THUNK_,x)(68)  \
cat(THUNK_,x)(69)  cat(THUNK_,x)(70)  cat(THUNK_,x)(71)  cat(THUNK_,x)(72)  cat(THUNK_,x)(73)  cat(THUNK_,x)(74)  cat(THUNK_,x)(75)  cat(THUNK_,x)(76)  cat(THUNK_,x)(77)  cat(THUNK_,x)(78)  cat(THUNK_,x)(79)  \
cat(THUNK_,x)(80)  cat(THUNK_,x)(81)  cat(THUNK_,x)(82)  cat(THUNK_,x)(83)  cat(THUNK_,x)(84)  cat(THUNK_,x)(85)  cat(THUNK_,x)(86)  cat(THUNK_,x)(87)  cat(THUNK_,x)(88)  cat(THUNK_,x)(89)  cat(THUNK_,x)(90)  \
cat(THUNK_,x)(91)  cat(THUNK_,x)(92)  cat(THUNK_,x)(93)  cat(THUNK_,x)(94)  cat(THUNK_,x)(95)  cat(THUNK_,x)(96)  cat(THUNK_,x)(97)  cat(THUNK_,x)(98)  cat(THUNK_,x)(99)  cat(THUNK_,x)(100) cat(THUNK_,x)(101) \
cat(THUNK_,x)(102) cat(THUNK_,x)(103) cat(THUNK_,x)(104) cat(THUNK_,x)(105) cat(THUNK_,x)(106) cat(THUNK_,x)(107) cat(THUNK_,x)(108) cat(THUNK_,x)(109) cat(THUNK_,x)(110) cat(THUNK_,x)(111) cat(THUNK_,x)(112) \
cat(THUNK_,x)(113) cat(THUNK_,x)(114) cat(THUNK_,x)(115) cat(THUNK_,x)(116) cat(THUNK_,x)(117) cat(THUNK_,x)(118) cat(THUNK_,x)(119) cat(THUNK_,x)(120) cat(THUNK_,x)(121) cat(THUNK_,x)(122) cat(THUNK_,x)(123) \
cat(THUNK_,x)(124) cat(THUNK_,x)(125) cat(THUNK_,x)(126) cat(THUNK_,x)(127) cat(THUNK_,x)(128) cat(THUNK_,x)(129) cat(THUNK_,x)(130) cat(THUNK_,x)(131) cat(THUNK_,x)(132) cat(THUNK_,x)(133) cat(THUNK_,x)(134) \
cat(THUNK_,x)(135) cat(THUNK_,x)(136) cat(THUNK_,x)(137) cat(THUNK_,x)(138) cat(THUNK_,x)(139) cat(THUNK_,x)(140) cat(THUNK_,x)(141) cat(THUNK_,x)(142) cat(THUNK_,x)(143) cat(THUNK_,x)(144) cat(THUNK_,x)(145) \
cat(THUNK_,x)(146) cat(THUNK_,x)(147) cat(THUNK_,x)(148) cat(THUNK_,x)(149) cat(THUNK_,x)(150) cat(THUNK_,x)(151) cat(THUNK_,x)(152) cat(THUNK_,x)(153) cat(THUNK_,x)(154) cat(THUNK_,x)(155) cat(THUNK_,x)(156) \
cat(THUNK_,x)(157) cat(THUNK_,x)(158) cat(THUNK_,x)(159) cat(THUNK_,x)(160) cat(THUNK_,x)(161) cat(THUNK_,x)(162) cat(THUNK_,x)(163) cat(THUNK_,x)(164) cat(THUNK_,x)(165) cat(THUNK_,x)(166) cat(THUNK_,x)(167) \
cat(THUNK_,x)(168) cat(THUNK_,x)(169) cat(THUNK_,x)(170) cat(THUNK_,x)(171) cat(THUNK_,x)(172) cat(THUNK_,x)(173) cat(THUNK_,x)(174) cat(THUNK_,x)(175) cat(THUNK_,x)(176) cat(THUNK_,x)(177) cat(THUNK_,x)(178) \
cat(THUNK_,x)(179) cat(THUNK_,x)(180) cat(THUNK_,x)(181) cat(THUNK_,x)(182) cat(THUNK_,x)(183) cat(THUNK_,x)(184) cat(THUNK_,x)(185) cat(THUNK_,x)(186) cat(THUNK_,x)(187) cat(THUNK_,x)(188) cat(THUNK_,x)(189) \
cat(THUNK_,x)(190) cat(THUNK_,x)(191) cat(THUNK_,x)(192) cat(THUNK_,x)(193) cat(THUNK_,x)(194) cat(THUNK_,x)(195) cat(THUNK_,x)(196) cat(THUNK_,x)(197) cat(THUNK_,x)(198) cat(THUNK_,x)(199)        

#endif // UNIX
#endif //_TEAROFF_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\dbglite\dbglite.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       dbglite.c
//
//  Contents:   functions for debug lite version of mshtml.dll
//
//----------------------------------------------------------------------------

#if DBG == 1

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef tagError
#undef tagError
#endif

#ifdef tagAssertExit
#undef tagAssertExit
#endif

#define tagNull     ((TAG) 0)

//
//  Global variables
//
TAG     tagDefault                  = TRUE;
TAG     tagError                    = TRUE;
TAG     tagWarn_                    = FALSE;
TAG     tagAssertExit               = FALSE;
TAG     tagThrd_                    = FALSE;
TAG     tagMemoryStrict_            = FALSE;
TAG     tagMemoryStrictTail_        = FALSE;
TAG     tagMemoryStrictAlign_       = FALSE;
TAG     tagOLEWatchvar_             = FALSE;
TAG     tagPerf_                    = FALSE;

BOOL    g_fBreakOnAssert            = TRUE;


//+------------------------------------------------------------------------
//
//  Function:   AssertImpl
//
//  Synopsis:   Function called for all asserts.  Outputs szMessage to
//              standart output
//
//  Arguments:
//              szFile
//              iLine
//              szMessage
//
//-------------------------------------------------------------------------

BOOL
AssertImpl(char const * szFile, int iLine, char const * szMessage)
{
    OutputDebugStringA("MSHTML: ");
    OutputDebugStringA(szMessage);
    OutputDebugStringA("\n");
    return g_fBreakOnAssert;
}


BOOL
IsFullDebug(void)
{
    return FALSE;
}

void AssertThreadDisable(BOOL fDisable)
{
}

void TaggedTraceCallers(TAG tag, int iStart, int cTotal)
{
}

TAG FindTag(char * szTagDesc)
{
    return 0;
}

size_t DbgPreAlloc(size_t cbRequest)
{
    return cbRequest;
}


void * DbgPostAlloc(void *pv)
{
    return pv;
}

void * DbgPreFree(void *pv)
{
    return pv;
}

void DbgPostFree(void)
{
}

size_t DbgPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    *ppv = pvRequest;
    return cbRequest;
}

void * DbgPostRealloc(void *pv)
{
    return pv;
}

void * DbgPreGetSize(void *pvRequest)
{
    return pvRequest;
}

size_t DbgPostGetSize(size_t cb)
{
    return cb;
}

void * DbgPreDidAlloc(void *pvRequest)
{
    return pvRequest;
}

BOOL DbgPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

void DbgRegisterMallocSpy(void)
{
}

void DbgRevokeMallocSpy(void)
{
}

void DbgMemoryTrackDisable(BOOL fDisable)
{
}

void DbgMemoryBlockTrackDisable(void * pv)
{
}

void TraceMemoryLeaks()
{
}

BOOL ValidateInternalHeap()
{
    return TRUE;
}

int GetTotalAllocated(void)
{
    return 0;
}

void DbgDumpProcessHeaps()
{
}

void * __cdecl DbgMemSetName(void *pvRequest, char * szFmt, ...)
{
    return pvRequest;
}

char * DbgMemGetName(void *pvRequest)
{
    return NULL;
}

void
DbgSetTopUrl(LPWSTR pstrUrl)
{
}

void SetSimFailCounts(int firstFailure, int cInterval)
{
}

void ShowSimFailDlg(void)
{
}

TAG TagError( void )
{
    return tagError;
}

TAG TagAssertExit( void )
{
    return tagAssertExit;
}

TAG TagWarning( void )
{
    return tagWarn_;
}

TAG TagThread( void )
{
    return tagThrd_;
}

TAG TagMemoryStrict( void )
{
    return tagMemoryStrict_;
}

TAG TagMemoryStrictTail( void )
{
    return tagMemoryStrictTail_;
}

TAG TagMemoryStrictAlign( void )
{
    return tagMemoryStrictAlign_;
}

TAG TagOLEWatch( void )
{
    return tagOLEWatchvar_;
}

TAG TagPerf( void )
{
    return tagPerf_;
}

BOOL IsTagEnabled(TAG tag)
{
    return  tag;
}

BOOL SetDiskFlag (TAG tag, BOOL fSendToDisk)
{
    return FALSE;
}

BOOL SetBreakFlag (TAG tag, BOOL fBreak)
{
    return FALSE;
}

BOOL EnableTag( TAG tag, BOOL fEnable )
{
    return FALSE;
}

#undef TraceEnter
void TraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

void TraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

BOOL __cdecl TaggedTrace(TAG tag, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl TaggedTraceEx(TAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL EXPORT WINAPI TaggedTraceListEx(TAG tag,
                                     USHORT usFlags,
                                     CHAR * szFmt,
                                     va_list valMarker)
{
    int         cch;
    CHAR        achBuf[4096];

    if (tag)
    {
        cch = wsprintfA(
                achBuf,
                szFmt,
                valMarker);

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");
    }

    return FALSE;
}

TAG TagRegisterTrace( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    return tagNull;
}

TAG TagRegisterOther( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    return tagNull;
}

void DbgTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv)
{
}

void DoTracePointsDialog( BOOL fWait )
{
}

void RestoreDefaultDebugState( void )
{
}

int GetFailCount( )
{
    return INT_MIN;
}

extern "C" long TraceFailL(long errExpr,
                           long errTest,
                           BOOL fIgnore,
                           LPSTR pstrExpr,
                           LPSTR pstrFile,
                           int line)
{
    return errExpr;
}

extern "C" long TraceWin32L(long errExpr,
                            long errTest,
                            BOOL fIgnore,
                            LPSTR pstrExpr,
                            LPSTR pstrFile,
                            int line)
{
    return errExpr;
}

extern "C" HRESULT TraceHR(HRESULT hrTest,
                           BOOL fIgnore,
                           LPSTR pstrExpr,
                           LPSTR pstrFile,
                           int line)
{
    return hrTest;
}

extern "C" HRESULT TraceOLE(HRESULT hrTest,
                            BOOL fIgnore,
                            LPSTR pstrExpr,
                            LPSTR pstrFile,
                            int line,
                            LPVOID lpsite)
{
    return hrTest;
}

HRESULT EXPORT CDECL CheckAndReturnResult(HRESULT hr,
                                        BOOL    fTrace,
                                        LPSTR   pstrFile,
                                        UINT    line,
                                        int     cHResult,
                                        ...)
{
    return hr;
}

void OpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize)
{
}

void OpenMemoryMonitor()
{
}

void OpenLogFile(LPCSTR szFName)
{
}

HRESULT WsClear(HANDLE hProcess)
{
    return S_OK;
}

HRESULT WsTakeSnapshot(HANDLE hProcess)
{
    return S_OK;
}

BSTR WsGetModule(long row)
{
    return NULL;
}

BSTR WsGetSection(long row)
{
    return NULL;
}

long WsSize(long row)
{
    return 0;
}

long WsCount()
{
    return 0;
}

long WsTotal()
{
    return 0;
}

HRESULT WsStartDelta(HANDLE hProcess)
{
    return S_OK;
}

long WsEndDelta(HANDLE hProcess)
{
    return -1;
}

void WINAPI InitStackSpew(BOOL * pfEnabled, DWORD * pdwSpew)
{
    Assert( pfEnabled && pdwSpew );
    pfEnabled = FALSE;
}

#endif  //  DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\allocspy.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       allocspy.cxx
//
//  Contents:   IMallocSpy implementation.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_VMEM_HXX_
#define X_VMEM_HXX_
#include "vmem.hxx"
#endif

#include "vmem.cxx"

static PERFMETERTAG g_mtSpy = 0;

class CMallocSpy : public IMallocSpy
{
public:

    CMallocSpy();

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IMallocSpy methods

    STDMETHOD_(SIZE_T, PreAlloc)(SIZE_T cbRequest);
    STDMETHOD_(void *, PostAlloc)(void *pvActual);
    STDMETHOD_(void *, PreFree)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(void,   PostFree)(BOOL fSpyed);
    STDMETHOD_(SIZE_T, PreRealloc)(void *pvRequest, SIZE_T cbRequest, void **ppvActual, BOOL fSpyed);
    STDMETHOD_(void *, PostRealloc)(void *pvActual, BOOL fSpyed);
    STDMETHOD_(void *, PreGetSize)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(SIZE_T, PostGetSize)(SIZE_T cbActual, BOOL fSpyed);
    STDMETHOD_(void *, PreDidAlloc)(void *pvRequest, BOOL fSpyed);
    STDMETHOD_(BOOL,   PostDidAlloc)(void *pvRequest, BOOL fSpyed, BOOL fActual);
    STDMETHOD_(void,   PreHeapMinimize)();
    STDMETHOD_(void,   PostHeapMinimize)();

    ULONG               _ulRef;
    BOOL                _fStrict;
    DWORD               _dwFlags;
    BOOL                _fMeter;
};

void EnterSpyAlloc()
{
    EnsureThreadState();
    DBGTHREADSTATE * pts = DbgGetThreadState();
    pts->fSpyAlloc += 1;
    pts->mtSpy = pts->mtSpyUser ? pts->mtSpyUser : g_mtSpy;
}

void LeaveSpyAlloc()
{
    TLS(fSpyAlloc) -= 1;
}

struct SPYBLK
{
    PERFMETERTAG mt;
};

size_t
SpyPreAlloc(size_t cbRequest)
{
    EnsureThreadState();
    TLS(cbRequest) = cbRequest;
    return sizeof(SPYBLK);
}

void *
SpyPostAlloc(void * pvActual, DWORD dwFlags)
{
    EnsureThreadState();
    SPYBLK * psb = (SPYBLK *)pvActual;
    size_t cbRequest = TLS(cbRequest);
    void * pvRequest;

    if (!psb)
        return NULL;

    pvRequest = VMemAlloc(cbRequest, dwFlags, psb);

    if (pvRequest)
    {
        psb->mt = TLS(mtSpy);
        DbgExMtAdd(psb->mt, 1, cbRequest);
    }

    return(pvRequest);
}

void *
SpyPreFree(void * pvRequest)
{
    if (!pvRequest)
        return NULL;

    VMEMINFO * pvmi = VMemIsValid(pvRequest);
    SPYBLK * psb = NULL;

    AssertSz(pvmi, "SpyPreFree - can't find supposedly allocated block");

    if (pvmi)
    {
        psb = (SPYBLK *)pvmi->pvUser;
        DbgExMtAdd(psb->mt, -1, -(LONG_PTR)pvmi->cb);
        VMemFree(pvRequest);
    }

    return(psb);
}

void
SpyPostFree(void)
{
}

size_t
SpyPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    EnsureThreadState();
    size_t          cb;
    DBGTHREADSTATE *pts  = DbgGetThreadState();

    pts->cbRequest = cbRequest;
    pts->pvRequest = pvRequest;

    if (pvRequest == NULL)
    {
        *ppv = NULL;
        cb = sizeof(SPYBLK);
    }
    else if (cbRequest == 0)
    {
        *ppv = SpyPreFree(pvRequest);
        cb = 0;
    }
    else
    {
        VMEMINFO * pvmi = VMemIsValid(pvRequest);

        if (pvmi)
        {
            *ppv = pvmi->pvUser;
            cb = sizeof(SPYBLK);
        }
        else    // Something very, very wrong. just don't crash.
        {
            AssertSz(pvmi, "SpyPreRealloc - can't find supposedly allocated block");
            cb = 0;
        }
    }

    return cb;
}

void *
SpyPostRealloc(void * pvActual, DWORD dwFlags)
{
    EnsureThreadState();
    DBGTHREADSTATE *pts         = DbgGetThreadState();
    void *          pvRequest   = pts->pvRequest;
    size_t          cbRequest   = pts->cbRequest;
    void *          pvReturn    = NULL;

    if (pvRequest == NULL)
    {
        pvReturn = SpyPostAlloc(pvActual, dwFlags);
    }
    else if (pts->cbRequest == 0)
    {
        Assert(pvActual == NULL);
        pvReturn = NULL;
    }
    else if (pvActual)
    {
        VMEMINFO *  pvmi = VMemIsValid(pvRequest);
        LONG        lVal = cbRequest - pvmi->cb;
        SPYBLK *    psb  = (SPYBLK *)pvActual;

        if (VMemRealloc(&pvRequest, cbRequest, dwFlags, psb) == S_OK)
        {
            DbgExMtAdd(psb->mt, 0, lVal);
            pvReturn = pvRequest;
        }
    }

    return pvReturn;
}

void *
SpyPreGetSize(void *pvRequest)
{
    EnsureThreadState();
    TLS(pvRequest) = pvRequest;
    VMEMINFO * pvmi = VMemIsValid(pvRequest);
    return pvmi ? pvmi->pvUser : NULL;
}

size_t
SpyPostGetSize(size_t cb)
{
    EnsureThreadState();
    DBGTHREADSTATE * pts = DbgGetThreadState();
    return pts->pvRequest ? VMemIsValid(pts->pvRequest)->cb : 0;
}

void *
SpyPreDidAlloc(void *pvRequest)
{
    return(VMemIsValid(pvRequest));
}

BOOL
SpyPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

struct MTRBLK
{
    LONG            cb;
    PERFMETERTAG    mt;
};

size_t
MtrPreAlloc(size_t cbRequest)
{
    EnsureThreadState();
    TLS(cbRequest) = cbRequest;
    return(sizeof(MTRBLK) + cbRequest);
}

void *
MtrPostAlloc(void * pvActual)
{
    EnsureThreadState();
    MTRBLK * pmb = (MTRBLK *)pvActual;

    if (!pmb)
        return NULL;

    pmb->cb = TLS(cbRequest);
    pmb->mt = TLS(mtSpy);

    DbgExMtAdd(pmb->mt, 1, pmb->cb);

    return(pmb + 1);
}

void *
MtrPreFree(void * pvRequest)
{
    if (!pvRequest)
        return NULL;

    MTRBLK * pmb = (MTRBLK *)pvRequest - 1;

    DbgExMtAdd(pmb->mt, -1, -(LONG_PTR)pmb->cb);

    return(pmb);
}

void
MtrPostFree(void)
{
}

size_t
MtrPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    EnsureThreadState();
    size_t          cb;
    DBGTHREADSTATE *pts = DbgGetThreadState();

    pts->cbRequest = cbRequest;
    pts->pvRequest = pvRequest;

    if (pvRequest == NULL)
    {
        *ppv = NULL;
        cb   = sizeof(MTRBLK) + cbRequest;
    }
    else if (cbRequest == 0)
    {
        *ppv = MtrPreFree(pvRequest);
        cb   = 0;
    }
    else
    {
        *ppv = (MTRBLK *)pvRequest - 1;
        cb   = sizeof(MTRBLK) + cbRequest;
    }

    return cb;
}

void *
MtrPostRealloc(void * pvActual)
{
    EnsureThreadState();
    void *          pvReturn;
    DBGTHREADSTATE *pts = DbgGetThreadState();
    MTRBLK *        pmb = pvActual ? (MTRBLK *)pvActual : NULL;

    if (pts->pvRequest == NULL)
    {
        pvReturn = MtrPostAlloc(pvActual);
    }
    else if (pts->cbRequest == 0)
    {
        Assert(pvActual == NULL);
        pvReturn = NULL;
    }
    else
    {
        if (pvActual == NULL)
        {
            pvReturn = NULL;
        }
        else
        {
            DbgExMtAdd(pmb->mt, 0, (pts->cbRequest - pmb->cb));

            pmb->cb = pts->cbRequest;

            pvReturn = pmb + 1;
        }
    }

    return pvReturn;
}

void *
MtrPreGetSize(void *pvRequest)
{
    return pvRequest ? (MTRBLK *)pvRequest - 1 : NULL;
}

size_t
MtrPostGetSize(size_t cb)
{
    return(cb ? cb - sizeof(MTRBLK) : 0);
}

void *
MtrPreDidAlloc(void *pvRequest)
{
    return(pvRequest ? (MTRBLK *)pvRequest - 1 : NULL);
}

BOOL
MtrPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

inline
CMallocSpy::CMallocSpy()
{
    _ulRef = 0;
}


STDMETHODIMP
CMallocSpy::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IMallocSpy)
    {
        *ppv = (IMallocSpy *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CMallocSpy::AddRef()
{
    return InterlockedIncrement((LONG *)&_ulRef);
}

STDMETHODIMP_(ULONG)
CMallocSpy::Release()
{
    return InterlockedDecrement((LONG *)&_ulRef);
}

STDMETHODIMP_(SIZE_T)
CMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    ULONG ul;

    EnterSpyAlloc();

    if (_fStrict)
        ul = SpyPreAlloc(cbRequest);
    else if (_fMeter)
        ul = MtrPreAlloc(cbRequest);
    else
        ul = DbgExPreAlloc(cbRequest);

    LeaveSpyAlloc();

    return ul;
}

STDMETHODIMP_(void *)
CMallocSpy::PostAlloc(void *pvActual)
{
    void * pv;

    EnterSpyAlloc();

    if (_fStrict)
        pv = SpyPostAlloc(pvActual, _dwFlags);
    else if (_fMeter)
        pv = MtrPostAlloc(pvActual);
    else
        pv = DbgExPostAlloc(pvActual);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(void *)
CMallocSpy::PreFree(void *pvRequest, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvRequest;
    else if (_fStrict)
        pv = SpyPreFree(pvRequest);
    else if (_fMeter)
        pv = MtrPreFree(pvRequest);
    else
        pv = DbgExPreFree(pvRequest);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(void)
CMallocSpy::PostFree(BOOL fSpyed)
{
    EnterSpyAlloc();

    if (fSpyed)
    {
        if (_fStrict)
            SpyPostFree();
        else if (_fMeter)
            MtrPostFree();
        else
            DbgExPostFree();
    }

    LeaveSpyAlloc();
}

STDMETHODIMP_(SIZE_T)
CMallocSpy::PreRealloc(
    void *pvRequest,
    SIZE_T cbRequest,
    void **ppvActual,
    BOOL fSpyed)
{
    SIZE_T cb;

    EnterSpyAlloc();

    if (!fSpyed)
    {
        *ppvActual = pvRequest;
        cb = cbRequest;
    }
    else if (_fStrict)
        cb = SpyPreRealloc(pvRequest, cbRequest, ppvActual);
    else if (_fMeter)
        cb = MtrPreRealloc(pvRequest, cbRequest, ppvActual);
    else
        cb = DbgExPreRealloc(pvRequest, cbRequest, ppvActual);

    LeaveSpyAlloc();

    return cb;
}

STDMETHODIMP_(void *)
CMallocSpy::PostRealloc(void *pvActual, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvActual;
    else if (_fStrict)
        pv = SpyPostRealloc(pvActual, _dwFlags);
    else if (_fMeter)
        pv = MtrPostRealloc(pvActual);
    else
        pv = DbgExPostRealloc(pvActual);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(void *)
CMallocSpy::PreGetSize(void *pvRequest, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvRequest;
    else if (_fStrict)
        pv = SpyPreGetSize(pvRequest);
    else if (_fMeter)
        pv = MtrPreGetSize(pvRequest);
    else
        pv = DbgExPreGetSize(pvRequest);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(SIZE_T)
CMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    SIZE_T cb;

    EnterSpyAlloc();

    if (!fSpyed)
        cb = cbActual;
    else if (_fStrict)
        cb = SpyPostGetSize(cbActual);
    else if (_fMeter)
        cb = MtrPostGetSize(cbActual);
    else
        cb = DbgExPostGetSize(cbActual);

    LeaveSpyAlloc();

    return cb;
}

STDMETHODIMP_(void *)
CMallocSpy::PreDidAlloc(void *pvRequest, BOOL fSpyed)
{
    void * pv;

    EnterSpyAlloc();

    if (!fSpyed)
        pv = pvRequest;
    else if (_fStrict)
        pv = SpyPreDidAlloc(pvRequest);
    else if (_fMeter)
        pv = MtrPreDidAlloc(pvRequest);
    else
        pv = DbgExPreDidAlloc(pvRequest);

    LeaveSpyAlloc();

    return pv;
}

STDMETHODIMP_(BOOL)
CMallocSpy::PostDidAlloc(void *pvRequest, BOOL fSpyed, BOOL fActual)
{
    BOOL f;

    EnterSpyAlloc();

    if (!fSpyed)
        f = fActual;
    else if (_fStrict)
        f = SpyPostDidAlloc(pvRequest, fActual);
    else if (_fMeter)
        f = MtrPostDidAlloc(pvRequest, fActual);
    else
        f = DbgExPostDidAlloc(pvRequest, fActual);

    LeaveSpyAlloc();

    return f;
}

STDMETHODIMP_(void)
CMallocSpy::PreHeapMinimize()
{
}

STDMETHODIMP_(void)
CMallocSpy::PostHeapMinimize()
{
}

static CMallocSpy sSpy;


void * WINAPI
DbgExGetMallocSpy()
{
    EnsureThreadState();
#ifdef PERFMETER
    if (g_mtSpy == 0)
        g_mtSpy = DbgExMtRegister("mtCoTaskMem", "mtWorkingSet", "CoTaskMemAlloc");
#endif
#if defined(RETAILBUILD) && defined(PERFTAGS) && !defined(PERFMETER)
    static int g_tgCoMemoryStrict = DbgExPerfRegister("tgCoMemoryStrict", "!Memory", "Use VMem for CoTaskMemAlloc");
    sSpy._fStrict = IsPerfEnabled(g_tgCoMemoryStrict);
    sSpy._dwFlags = (GetPrivateProfileIntA("perftags", "tgMemoryStrictHead", FALSE, "mshtmdbg.ini") ? 0 : VMEM_BACKSIDESTRICT) |
                    (GetPrivateProfileIntA("perftags", "tgMemoryStrictAlign", FALSE, "mshtmdbg.ini") ? VMEM_BACKSIDEALIGN8 : 0);
#else
    sSpy._fStrict = DbgExIsTagEnabled(tagCoMemoryStrict);
    sSpy._dwFlags = (DbgExIsTagEnabled(tagMemoryStrictTail) ? VMEM_BACKSIDESTRICT : 0) |
                    (DbgExIsTagEnabled(tagMemoryStrictAlign) ? VMEM_BACKSIDEALIGN8 : 0);
#endif
#if defined(RETAILBUILD) && defined(PERFMETER)
    sSpy._fMeter = !sSpy._fStrict;
#else
    sSpy._fMeter = FALSE;
#endif

    return((IMallocSpy *)&sSpy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\dbgstk.cxx ===
#error "@@@ This file is nuked"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       assert.cxx
//
//  Contents:   Assertion stuff
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

static LONG g_cAssertThreadDisable = 0;
void SpitSzToDisk(CHAR * sz);


#ifndef _MAC

extern HMODULE g_hModule;

int  DoAssertDialog(MBOT *pmbot);

//+---------------------------------------------------------------------------
//
//  Function:   InitMBOT
//
//  Synopsis:   Initializes some data in the MBOT struct, like module name
//              stacktrace, etc.
//
//  Arguments:  [pmbot]      -- Pointer to struct to initialize
//
//----------------------------------------------------------------------------

void
InitMBOT(MBOT *pmbot)
{
    char   achModuleName[MAX_PATH];
    char * pszModuleName;
    DWORD  dwEip[50];

    memset(pmbot, 0, sizeof(pmbot));

    pmbot->tid = GetCurrentThreadId();
    pmbot->pid = GetCurrentProcessId();

#ifndef _MAC
    if (GetModuleFileNameA(g_hModule, achModuleName, MAX_PATH))
#else
    char  achAppLoc[MAX_PATH];

    if (GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc))
        && !GetFileTitleA(achAppLoc,achModuleName,ARRAY_SIZE(achModuleName)) )
#endif
    {
        pszModuleName = strrchr(achModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = achModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    strcpy(pmbot->achModule, pszModuleName);

    if (!g_cAssertThreadDisable && DbgExIsTagEnabled(tagAssertStacks))
    {
        pmbot->cSym = GetStackBacktrace(3, 50, dwEip, pmbot->asiSym);
    }
    else
    {
        pmbot->cSym = 0;
    }

    GetTopURLForThread(pmbot->tid, pmbot->achTopUrl);

    pmbot->id = IDCANCEL;

    pmbot->szTitle = "Trident/MSHTML Assert";
}

//+---------------------------------------------------------------------------
//
//  Function:   StringFromMBOT
//
//  Synopsis:   Fills a string with a textual representation of information
//              in an MBOT struct
//
//  Arguments:  [pmbot]      --  MBOT to represent
//              [pch]        --  Buffer to put text into.
//              [fShortSyms] --  If TRUE, only SHORT_SYM_COUNT symbols are
//                               used.
//
//----------------------------------------------------------------------------

void
StringFromMBOT(MBOT *pmbot, char * pch, BOOL fShortSyms)
{
    int i;
    int cSyms = pmbot->cSym;

    if (fShortSyms && (cSyms > SHORT_SYM_COUNT))
    {
        cSyms = SHORT_SYM_COUNT;
    }

    wsprintfA(pch, "Assert Failed: Process: %s PID:%x TID:%x\r\nFile: %s (%d)\r\nTop Url: %s\r\n%s",
            pmbot->achModule,
            pmbot->pid,
            pmbot->tid,
            pmbot->szFile,
            pmbot->dwLine,
            pmbot->achTopUrl,
            pmbot->szMessage);

    if (cSyms)
    {
        char achSymbol[200];

        strcat(pch, "\r\n\r\nStacktrace:\r\n");

        for (i = 0; i < cSyms; i++)
        {
            wsprintfA(achSymbol, "   %-11s %s\r\n",
                      pmbot->asiSym[i].achModule,
                      pmbot->asiSym[i].achSymbol);
            strcat(pch, achSymbol);
        }
    }
}

//+------------------------------------------------------------
//
// Function:    MessageBoxOnThreadFn
//
// Synopsis:    ThreadMain function for MessageBoxOnThread.
//
//-------------------------------------------------------------

DWORD WINAPI
MessageBoxOnThreadFn(MBOT *pmbot)
{
#if 0
    char ach[MAX_PATH * 3];

    StringFromMBOT(pmbot, ach, TRUE);

    pmbot->id = MessageBoxA(NULL,
                            ach,
                            pmbot->szTitle,
                            pmbot->dwFlags);
#endif

    pmbot->id = DoAssertDialog(pmbot);

    if (pmbot->id == 0)
        pmbot->dwErr = GetLastError();

    return(0);
}

//+------------------------------------------------------------
//
// Function:    MessageBoxOnThread
//
// Synopsis:
//
//-------------------------------------------------------------

int MessageBoxOnThread(MBOT *pmbot)
{
    THREAD_HANDLE  hThread;
    DWORD   dwThread;

    if (g_cAssertThreadDisable)
    {
        // Flush all user input to prevent auto-closing of this message box
        MSG msg;
        for (int n = 0; n < 100; ++n)
            PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

        MessageBoxOnThreadFn(pmbot);
    }
    else
    {
        hThread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)MessageBoxOnThreadFn,
                pmbot,
                0,
                &dwThread);
        if (!hThread)
        {
            // Flush all user input to prevent auto-closing of this message box
            MSG msg;
            for (int n = 0; n < 100; ++n)
                PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

            MessageBoxOnThreadFn(pmbot);
        }
        else
        {
            WaitForSingleObject(hThread, INFINITE);
            CloseThread(hThread);
        }
    }

    if (pmbot->id == 0)
        SetLastError(pmbot->dwErr);

    return(pmbot->id);
}

#endif // !MAC

//
// Bookmark array that can set and retrieve a mark on a (filename, line) pair
// Removing a bookmark is not implemented here
//
#pragma auto_inline(off)
#pragma inline_depth(0)

template <int _cMax>
class CDbgBookmarkArray
{
protected:
    int _cUsed;         // used entries
    int _rgcrc[_cMax];  // the array

    //+------------------------------------------------------------
    //
    // Function:    CrcAddInt
    //
    // Synopsis:    Add an integer to CRC
    //
    //-------------------------------------------------------------
    int CrcAddInt(unsigned int crc, unsigned int i)
    {
        return (crc ^ i) * 16807 % 0x7fffffff;
    }

    //+------------------------------------------------------------
    //
    // Function:    CrcFromSz
    //
    // Synopsis:    Compute CRC for a string.
    //
    //-------------------------------------------------------------
    int CrcFromSz(const char *rgb)
    {
        int crc = 0;
        while (*rgb)
            crc = CrcAddInt(crc, *rgb++);

        return crc;
    }

    //+------------------------------------------------------------
    //
    // Function:    CrcFromFileLine
    //
    // Synopsis:    Compute CRC for (filename, line).
    //
    //-------------------------------------------------------------
    int CrcFromFileLine(const char *szFile, int iLine)
    {
        return CrcAddInt(CrcFromSz(szFile), iLine);
    }

public:
    //+------------------------------------------------------------
    //
    // Function:    IsMarked
    //
    // Synopsis:    returns TRUE if there is a bookmark at (file, line).
    //
    //-------------------------------------------------------------
    BOOL IsMarked(const char *szFile, int iLine)
    {
        int crc = CrcFromFileLine(szFile, iLine);
        for (int i = 0; i < _cUsed; i++)
            {
            if (_rgcrc[i] == crc)
                return TRUE;
            }
        return FALSE;
    }

    //+------------------------------------------------------------
    //
    // Function:    Mark
    //
    // Synopsis:    Set bookmark at (file, line)
    //
    //-------------------------------------------------------------
    BOOL Mark(const char *szFile, int iLine)
    {
        if (_cUsed >= _cMax || IsMarked(szFile, iLine))
            return TRUE;

        _rgcrc[_cUsed++] = CrcFromFileLine(szFile, iLine);

        return FALSE;
    }
};

//
// Array of disabled asserts.
// No, you can't disable more than 1000 asserts.
//
CDbgBookmarkArray<1000> rgbmkDisabledAsserts;
BOOL _fDisableAllAsserts = FALSE;


//+------------------------------------------------------------
//
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      pmbot --  Structure containing assert information
//
// Returns:
//      IDCANCEL --     User selected the BREAK  button
//      IDOK     --     User selected the IGNORE button
//
//-------------------------------------------------------------

int
PopUpError(MBOT *pmbot)
{
    int  id  = IDOK;

#if defined(UNIX)
    printf( "[ Assert failed. Calling DebugBreak ]" );
    DebugBreak();
#else
    id = MessageBoxOnThread(pmbot);
#endif

    if (id == IDOK && (GetAsyncKeyState(VK_CONTROL) & 0x8000))
        {
        if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
            {
            // ctrl+shift+Ignore - disable all asserts
            _fDisableAllAsserts = TRUE;
            }
        else
            {
            // ctrl+Ignore - disable this one assert
            rgbmkDisabledAsserts.Mark(pmbot->szFile, pmbot->dwLine);
            }
        }

    return id;
#if 0
    pmbot->dwFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                     MB_ICONEXCLAMATION | MB_OKCANCEL;

// MACTODO Mac MessageBox function fails with the following message:
//  Scratch DC already in use (wlmdc-1319)
#ifndef _MAC
    id = MessageBoxOnThread(pmbot);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (!id && GetLastError() == ERROR_ACCESS_DENIED)
    {
        //
        // Retry this one with the SERVICE_NOTIFICATION flag on.  That
        // should get us to the right desktop.
        //
        pmbot->dwFlags = MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                         MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL;

        id = MessageBoxOnThread(pmbot);
    }
#endif
    return id;

#endif
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExAssertImpl
//
//  Synopsis:   Function called for all asserts.  Checks value, tracing
//              and/or popping up a message box if the condition is
//              FALSE.
//
//  Arguments:
//              szFile
//              iLine
//              szMessage
//
//-------------------------------------------------------------------------

BOOL WINAPI
DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage)
{
    MBOT  mbot;
    char  ach[2048];
    DWORD cbWrite;

    EnsureThreadState();

    InitMBOT(&mbot);

    mbot.szFile    = szFile;
    mbot.dwLine    = iLine;
    mbot.szMessage = szMessage;

    StringFromMBOT(&mbot, ach, TRUE);

    //  Send the assert text to the debug terminal.

    TraceTag((tagError, "%s", ach));
    SpitSzToDisk(ach);

    //
    // Write to STDOUT. Used by the DRTDaemon process to relay information
    // back to the build machine. We ignore any errors.
    //
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
              ach,
              strlen(ach),
              &cbWrite,
              NULL);

    FlushFileBuffers(GetStdHandle(STD_OUTPUT_HANDLE));

    if (DbgExIsTagEnabled(tagAssertExit))
    {
        g_fAbnormalProcessTermination = TRUE;

        // If not in process attach or detach, then try to
        // shut the process down.

        if (g_cAssertThreadDisable == 0)
        {
            TerminateProcess(GetCurrentProcess(), 1);
        }
        else
        {
            static char *s_pszExitCode = "\nPROCESS_EXIT_CODE=1";

            // Since we can't set our process exit code by calling
            // TerminateProcess, we have to tell the DRTDaemon that we've
            // failed another way.

            WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
                      s_pszExitCode,
                      strlen(s_pszExitCode),
                      &cbWrite,
                      NULL);

            FlushFileBuffers(GetStdHandle(STD_OUTPUT_HANDLE));
        }

        return FALSE;
    }

    // Check if this occurrance has been manually disabled
    if (_fDisableAllAsserts || rgbmkDisabledAsserts.IsMarked(szFile, iLine))
        return FALSE;

    //  If appropriate, pop up an assert dialog for the user.  Note
    //    that we return TRUE (thereby causing an int 3 break) only
    //    if we pop up the dialog and the user hits Cancel.

    return DbgExIsTagEnabled(tagAssertPop) && (PopUpError(&mbot) == IDCANCEL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExAssertThreadDisable
//
//  Synopsis:   Disables or Enables assert message box spinning a thread.
//
//  Arguments:  [fDisable] -- TRUE if assert on thread should be disabled.
//                            FALSE to re-enable it.
//
//  Returns:    void
//
//  Notes:      Multiple calls giving TRUE require the same amount of calls
//              giving FALSE before assert on thread is actually re-enabled.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExAssertThreadDisable(BOOL fDisable)
{
    if (fDisable)
        InterlockedIncrement(&g_cAssertThreadDisable);
    else
        InterlockedDecrement(&g_cAssertThreadDisable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\dbgalloc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dbgalloc.cxx
//
//  Contents:   Debug allocation routines and leak tracing
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#if !defined(UNIX) || !defined(_HPUX_SOURCE)

#ifndef X_TYPEINFO_H_
#define X_TYPEINFO_H_
#include <typeinfo.h>
#endif

#endif // !UNIX

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

ExternTag(tagLeaksExpected);
ExternTag(tagMemTrace);
ExternTag(tagHexDumpLeaks);
ExternTag(tagNoLeakAssert);

#define HEADFOOTGUARDSIZE 16
static BYTE  FILL_CLEAN;
static BYTE  FILL_DEAD;
static BYTE  FILL_HEAD_GUARD;
static BYTE  FILL_FOOT_GUARD;
static BYTE  g_abHeadGuardFill[HEADFOOTGUARDSIZE];
static BYTE  g_abFootGuardFill[HEADFOOTGUARDSIZE];


extern BOOL g_fOSIsNT;
LONG g_cCoTrackDisable = 0;

// We read from the ini file a block size.  We will then only
// keep stack info for blocks of that size.  -2 means that
// we haven't looked at the ini file yet and -1 means track
// all block sizes -- allowing us to track 0 size allocations.
// (will this ever happen?)
static LONG g_lStackTrackSize = -2;

void ReadFillBytes()
{
    FILL_CLEAN      = (BYTE)GetPrivateProfileIntA("Memory", "FillClean", 0x9D, "mshtmdbg.ini");
    FILL_DEAD       = (BYTE)GetPrivateProfileIntA("Memory", "FillDead",  0xAD, "mshtmdbg.ini");
    FILL_HEAD_GUARD = (BYTE)GetPrivateProfileIntA("Memory", "HeadGuard", 0xBD, "mshtmdbg.ini");
    FILL_FOOT_GUARD = (BYTE)GetPrivateProfileIntA("Memory", "FootGuard", 0xCD, "mshtmdbg.ini");

    memset( g_abHeadGuardFill, FILL_HEAD_GUARD, HEADFOOTGUARDSIZE);
    memset( g_abFootGuardFill, FILL_FOOT_GUARD, HEADFOOTGUARDSIZE);
}

#undef SNDMSG
#define SNDMSG ::SendMessageA

void TraceLeak(TRACETAG tag, HANDLE * phFile, char * pch, BOOL fOpenFile)
{
    TraceTag((tag, "%s", pch));

    if (*phFile == INVALID_HANDLE_VALUE && fOpenFile)
    {
        *phFile = CreateFileA("c:\\leakdump.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (*phFile != INVALID_HANDLE_VALUE)
    {
        _lwrite((HFILE)(DWORD_PTR)*phFile, pch, lstrlenA(pch));
        _lwrite((HFILE)(DWORD_PTR)*phFile, "\r\n", 2);
    }
}

void DumpHex(HANDLE hFile, BYTE *pb, UINT cb, DWORD_PTR dwAddr)
{
        BYTE *  pbRow;
        BYTE    b;
        UINT    cbRow;
        int             i;
    char    ach[256], *pch;

        while (cb > 0)
        {
        pch = ach;
        ach[0] = 0;

        pch += wsprintfA(pch, "   %08lX: ", (DWORD)dwAddr);
                pbRow = pb;
                cbRow = (cb > 16) ? 16 : cb;
                for (i = 0; i < 16; ++i)
                {
                        if (cbRow > 0)
                        {
                                b = *pbRow++;
                                --cbRow;
                                pch += wsprintfA(pch, "%02X ", b);
                        }
                        else
                                pch += wsprintfA(pch, "   ");
                        if (i == 7) pch += wsprintfA(pch, " ");
                }
                pch += wsprintfA(pch, "  ");
                pbRow = pb;
                cbRow = (cb > 16) ? 16 : cb;
                for (i = 0; i < 16; ++i)
                {
                        if (cbRow > 0)
                        {
                                b = *pbRow++;
                                --cbRow;
                        }
                        else
                                b = 32;

                        if (b > 31 && b < 127)
                                pch += wsprintfA(pch, "%c", b);
                        else
                                pch += wsprintfA(pch, ".");

                        if (i == 7) pch += wsprintfA(pch, " ");
                }
                cbRow = (cb > 16) ? 16 : cb;
                pb   += cbRow;
                cb   -= cbRow;
        TraceLeak(tagHexDumpLeaks, &hFile, ach, FALSE);
        dwAddr += cbRow;
        }
}

//+------------------------------------------------------------------------
//
//  Prefix struct stuck at the beginning of every allocated block.
//  Keeps track of all allocated blocks, plus saves a stack trace
//  from the allocation
//
//-------------------------------------------------------------------------


struct DBGALLOCHDR
{
    DBGALLOCHDR *   pdbgahPrev;
    DBGALLOCHDR *   pdbgahNext;
    DWORD           dwEip[STACK_WALK_DEPTH];
    DWORD           iAllocated;
    DWORD           tid;
    size_t          cbRequest;
    BOOL            fSymbols;
    BOOL            fLeaked;
    BOOL            fCoFlag;
    PERFMETERTAG    mt;
    size_t          cbHeader;
    char            szName[64];
    BYTE            adwGuard[HEADFOOTGUARDSIZE];
};


//+------------------------------------------------------------------------
//
//  Suffix struct stuck after the end of every allocated block.  Filled
//  with a known pattern to help detect pointers walking outside their
//  block.
//
//-------------------------------------------------------------------------

struct DBGALLOCFOOT
{
    BYTE           adwGuard[HEADFOOTGUARDSIZE];
};


inline size_t
ActualSizeFromRequestSize(size_t cb, BOOL fSymbols)
{
    return cb + sizeof(DBGALLOCHDR) + sizeof(DBGALLOCFOOT) +
           ((fSymbols) ? STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO) : 0);
}


inline size_t
RequestSizeFromActualSize(size_t cb, BOOL fSymbols)
{
    return cb - sizeof(DBGALLOCHDR) - sizeof(DBGALLOCFOOT) -
           ((fSymbols) ? STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO) : 0);
}


inline void *
RequestFromActual(DBGALLOCHDR * pdbgah)
{
    return pdbgah + 1;
}

inline void *
ClientFromActual(DBGALLOCHDR * pdbgah)
{
    return (BYTE *)RequestFromActual(pdbgah) + pdbgah->cbHeader;
}

inline DBGALLOCHDR *
ActualFromRequest(void * pv)
{
    return ((DBGALLOCHDR *) pv) - 1;
}


inline DBGALLOCFOOT *
FooterFromBlock(DBGALLOCHDR * pdbgah)
{
    return (DBGALLOCFOOT *)
            (((BYTE *) pdbgah) + sizeof(DBGALLOCHDR) + pdbgah->cbRequest);
}

inline INET_SYMBOL_INFO *
SymbolsFromBlock(DBGALLOCHDR *pdbgah)
{
    return (INET_SYMBOL_INFO *)
            (((BYTE *) pdbgah) + sizeof(DBGALLOCHDR) +
                                 sizeof(DBGALLOCFOOT) +
                                 pdbgah->cbRequest);
}

//+------------------------------------------------------------------------
//
//  Globals
//
//-------------------------------------------------------------------------

size_t g_cbTotalAllocated  = 0; // Total bytes current allocated.
size_t g_cbMaxAllocated = 0;    // Peak allocation size.
ULONG g_cAllocated = 0;         // Total number of allocations.

//
// Grep for a DWORD:
// If g_pvMemSearch is found inside a block, it is displayed with a 'F'.
//

void *g_pvMemSearch;


//
//  Allocation list is kept in a doubly-linked ring; this is the root
//  block in the ring.
//

DBGALLOCHDR g_dbgahRoot =
    {
        &g_dbgahRoot,
        &g_dbgahRoot,
        { 0, 0, 0, 0, 0 },
        0,
        (DWORD)-1
    };

//+---------------------------------------------------------------------------
//
//  Function:   DbgTraceAlloc
//
//  Synopsis:   Traces the result of an allocation or free
//
//  Arguments:
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void DbgTraceAlloc(char * szTag, size_t cbAlloc, size_t cbFree)
{
    if (DbgExIsTagEnabled(tagMemTrace) && (cbAlloc || cbFree))
    {
        if (cbAlloc && cbFree)
        {
            TraceTag((tagMemTrace, "%s +%5d -%5d = [%7d]", szTag, cbAlloc,
                cbFree, g_cbTotalAllocated));
        }
        else if (cbAlloc)
        {
            TraceTag((tagMemTrace, "%s +%5d        = [%7d]", szTag, cbAlloc,
                g_cbTotalAllocated));
        }
        else
        {
            TraceTag((tagMemTrace, "%s        -%5d = [%7d]", szTag, cbFree,
                g_cbTotalAllocated));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExMemoryTrackDisable
//
//  Synopsis:   Disables or Enables memory leak tracking. Allocations that
//              occur while tracking is disabled will never be reported as
//              leaks, even if they are.
//
//  Arguments:  [fDisable] -- TRUE if tracking should be disabled. FALSE to
//                            re-enable it.
//
//  Returns:    void
//
//  Notes:      Multiple calls giving TRUE require the same amount of calls
//              giving FALSE before tracking is actually re-enabled.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExMemoryTrackDisable(BOOL fDisable)
{
    EnsureThreadState();
    if (fDisable)
    {
        TLS(cTrackDisable)++;
    }
    else
    {
        Assert(TLS(cTrackDisable) > 0);

        TLS(cTrackDisable)--;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExCoMemoryTrackDisable
//
//  Synopsis:   Disables or Enables Co memory leak tracking. Allocations that
//              occur while tracking is disabled will never be reported as
//              leaks, even if they are.
//
//  Arguments:  [fDisable] -- TRUE if tracking should be disabled. FALSE to
//                            re-enable it.
//
//  Returns:    void
//
//  Notes:      Multiple calls giving TRUE require the same amount of calls
//              giving FALSE before tracking is actually re-enabled.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExCoMemoryTrackDisable(BOOL fDisable)
{
    if (fDisable)
    {
        InterlockedIncrement(&g_cCoTrackDisable);
    }
    else
    {
        InterlockedDecrement(&g_cCoTrackDisable);
    }
}

void WINAPI
DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt)
{
    if (pvRequest)
    {
        DBGALLOCHDR * pdbgah = ActualFromRequest(pvRequest);
        pdbgah->cbHeader = cb;
        pdbgah->mt = mt;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRunTimeType
//
//  Synopsis:   Returns the type of the object stored in the block.  If
//              it cannot be determined, the empty string is returned.
//
//  Arguments:  [fDisable] -- TRUE if tracking should be disabled. FALSE to
//                            re-enable it.
//
//  Returns:    char *
//
//----------------------------------------------------------------------------

#pragma warning(disable: 4541)

class CType
{
    virtual MethodFoo() { return 0; }
};

char *
GetRunTimeType(LPVOID pv)
{
    CType * pType = (CType *)pv;
    char * psz = NULL;
    static char achBuf[256];
   
    //
    // The typeid operator will throw an exception or blow up if the memory
    // doesn't point to an object.
    //
#ifndef NO_RTTI
    __try
    {
        psz = const_cast<char*>(typeid(*pType).name());
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        psz = NULL;
    }
    __endexcept
#else
      psz = NULL; // Added only for this #ifdef
#endif

    if (psz == NULL || IsBadStringPtrA(psz, 1024))
        return("");

    // Remove "class " wherever it occurs
        
    strncpy(achBuf, psz, ARRAY_SIZE(achBuf));
    achBuf[ARRAY_SIZE(achBuf)-1] = NULL;        

    for (;;)
    {
        char * szClass = strstr(achBuf, "class ");

        if (szClass == NULL)
            break;

        memmove(szClass, szClass + 6, lstrlenA(szClass + 6) + 1);
    }

    return(achBuf);
}

//+------------------------------------------------------------------------
//
//  Function:   BlockIsValid
//
//  Synopsis:   Returns TRUE iff the block's guard structures are valid.
//
//  Arguments:  [pdbgah]
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
BlockIsValid(DBGALLOCHDR * pdbgah)
{
    DBGALLOCFOOT *  pdbgft;

    // Put all of this in a __try/__except block as someone might
    // pass us garbage.

    __try
    {
        Assert(sizeof(pdbgah->adwGuard) == sizeof(g_abHeadGuardFill));
        if (memcmp(pdbgah->adwGuard,
                g_abHeadGuardFill,
                sizeof(g_abHeadGuardFill)))
            return FALSE;

        pdbgft = FooterFromBlock(pdbgah);
        Assert(sizeof(pdbgft->adwGuard) == sizeof(g_abFootGuardFill));
        if (memcmp(pdbgft->adwGuard,
                g_abFootGuardFill,
                sizeof(g_abFootGuardFill)))
            return FALSE;
    }
    // Make sure int3s get through
    __except (GetExceptionCode() == STATUS_BREAKPOINT ? EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPreGetSize
//
//  Synopsis:   Hook called before memory get-size function
//
//  Arguments:  pvRequest  Request pointer
//
//  Returns:    Actual pointer.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPreGetSize(void *pvRequest)
{
    EnsureThreadState();
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());
    TLS(pvRequest) = pvRequest;
    return (pvRequest) ? ActualFromRequest(pvRequest) : NULL;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPostGetSize
//
//  Synopsis:   Hook called after memory get-size function
//
//  Arguments:  cb  Actual size.
//
//  Returns:    Request Size.
//
//-------------------------------------------------------------------------

size_t WINAPI
DbgExPostGetSize(size_t cb)
{
    DBGTHREADSTATE *   pts;
    pts = DbgGetThreadState();
    return (pts->pvRequest) ? ActualFromRequest(pts->pvRequest)->cbRequest : 0;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPreAlloc
//
//  Synopsis:   Hook called before memory allocation function.
//
//  Arguments:  cb      Request size.
//
//  Returns:    Actual size to allocate.
//
//-------------------------------------------------------------------------

size_t WINAPI
DbgExPreAlloc(size_t cbRequest)
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());
    EnsureThreadState();
    TLS(cbRequest) = cbRequest;

    if (AreSymbolsEnabled())
    {
        if (g_lStackTrackSize == -2)
        {
            g_lStackTrackSize = GetPrivateProfileIntA("SymbolLeakTrack", "Size", -1, "mshtmdbg.ini");

            if (g_lStackTrackSize != -1)
                g_lStackTrackSize += 8; // sizeof(MTMEMBLK);

            if (g_lStackTrackSize < -1)
                g_lStackTrackSize = -1;
        }

        TLS(fSymbols) = (g_lStackTrackSize == -1 || (size_t)g_lStackTrackSize == cbRequest);
    }
    else
        TLS(fSymbols) = FALSE;

    return ActualSizeFromRequestSize(cbRequest, TLS(fSymbols));
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPostAlloc
//
//  Synopsis:   Hook called after memory allocation function.
//
//  Arguments:  pv      Pointer to actual allocation.
//
//  Returns:    Pointer requested allocation.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPostAlloc(void *pv)
{
    DBGTHREADSTATE *   pts;
    DBGALLOCHDR *   pdbgah;
    DBGALLOCFOOT *  pdbgft;

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    pts = DbgGetThreadState();

    pdbgah = (DBGALLOCHDR *)pv;
    if (!pdbgah)
        return NULL;

    DbgTraceAlloc("A", pts->cbRequest, 0);

    //  Keep track of total amount of memory allocated
    pdbgah->cbRequest = pts->cbRequest;
    pdbgah->cbHeader  = 0;
    pdbgah->fSymbols  = pts->fSymbols;
    pdbgah->fLeaked   = (pts->cTrackDisable > 0) ||
                        (pts->fSpyAlloc && g_cCoTrackDisable > 0);
    pdbgah->fCoFlag   = pts->fSpyAlloc;
    pdbgah->mt        = pdbgah->fCoFlag ? pts->mtSpy : 0;

    if (pdbgah->fCoFlag && pdbgah->mt)
    {
        DbgExMtAdd(pdbgah->mt, +1, pts->cbRequest);
    }

    //  Note the thread which made the allocation
    pdbgah->tid = GetCurrentThreadId();

    if (pdbgah->fSymbols)
    {
        //  Snapshot stack
        GetStackBacktrace(3 + (pts->fSpyAlloc ? 2 : 0),
                          ARRAY_SIZE(pdbgah->dwEip),
                          pdbgah->dwEip,
                          SymbolsFromBlock(pdbgah));
    }
    else
    {
        pdbgah->dwEip[0] = NULL;
    }

    // Default the name to the empty string

    pdbgah->szName[0] = 0;

    //  Fill in guard blocks
    Assert(sizeof(pdbgah->adwGuard) == sizeof(g_abHeadGuardFill));
    memcpy(pdbgah->adwGuard, g_abHeadGuardFill, sizeof(g_abHeadGuardFill));
    pdbgft = FooterFromBlock(pdbgah);
    Assert(sizeof(pdbgft->adwGuard) == sizeof(g_abFootGuardFill));
    memcpy(pdbgft->adwGuard, g_abFootGuardFill, sizeof(g_abFootGuardFill));

    // Update globals.

    {
        LOCK_GLOBALS;

        g_cbTotalAllocated += pts->cbRequest;
        if (g_cbMaxAllocated < g_cbTotalAllocated)
            g_cbMaxAllocated = g_cbTotalAllocated;

        //  Keep track of allocation number.
        pdbgah->iAllocated = g_cAllocated++;

        //  Hook into allocated blocks chain
        pdbgah->pdbgahPrev = &g_dbgahRoot;
        pdbgah->pdbgahNext = g_dbgahRoot.pdbgahNext;
        g_dbgahRoot.pdbgahNext->pdbgahPrev = pdbgah;
        g_dbgahRoot.pdbgahNext = pdbgah;
    }

    pv = RequestFromActual(pdbgah);

    //  TODO we should modify this to a changing, yet predictable pattern.
    //  Fill logical block with clean byte
    memset(pv, FILL_CLEAN, pts->cbRequest);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pv;
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExPreFree
//
//  Synopsis:   Hook called before memory free function.
//
//  Arguments:  pv  Pointer to request allocation.
//
//  Returns:    Pointer to actual allocation.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPreFree(void *pv)
{
    DBGALLOCHDR *   pdbgah;

    EnsureThreadState();
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    if (!pv)
        return NULL;

    pdbgah = ActualFromRequest(pv);

    Assert(BlockIsValid(pdbgah));

    {
        // Keep scope of locked globals to a minimum.  There's a
        // potential for deadlock if the assert above fires with
        // locked globals.

        LOCK_GLOBALS;

        pdbgah->pdbgahPrev->pdbgahNext = pdbgah->pdbgahNext;
        pdbgah->pdbgahNext->pdbgahPrev = pdbgah->pdbgahPrev;

        g_cbTotalAllocated -= pdbgah->cbRequest;
    }

    DbgTraceAlloc("F", 0, pdbgah->cbRequest);

    if (pdbgah->fCoFlag && pdbgah->mt)
    {
        DbgExMtAdd(pdbgah->mt, -1, -(LONG_PTR)pdbgah->cbRequest);
    }

    //  Fill entire block (including debug additions) with fill dead
    memset(pdbgah,
           FILL_DEAD,
           ActualSizeFromRequestSize(pdbgah->cbRequest, pdbgah->fSymbols));

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pdbgah;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExPostFree
//
//  Synopsis:   Hook called after memory free function.
//
//-------------------------------------------------------------------------

void WINAPI
DbgExPostFree(void)
{
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExPreRealloc
//
//  Synopsis:   Hook called before memory reallocation function.
//
//  Arguments:  pv  Pointer to the request allocation.
//              cb  New requested size.
//              ppv Pointer to the actual allocation.
//
//  Returns:    New actual size.
//
//-------------------------------------------------------------------------

size_t WINAPI
DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    size_t          cb;
    DBGTHREADSTATE *   pts;
    DBGALLOCHDR *   pdbgah = ActualFromRequest(pvRequest);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());
    EnsureThreadState();

    pts = DbgGetThreadState();

    pts->cbRequest = cbRequest;
    pts->pvRequest = pvRequest;

    if (pvRequest == NULL)
    {
        *ppv = NULL;
        cb = ActualSizeFromRequestSize(cbRequest, pdbgah->fSymbols);
    }
    else if (cbRequest == 0)
    {
        *ppv = DbgExPreFree(pvRequest);
        cb = 0;
    }
    else
    {
        Assert(BlockIsValid(pdbgah));

        // copy tail data now; it will be invalid later on a shrinking realloc
        if (pdbgah->fSymbols)
        {
            memcpy(pts->aSymbols, SymbolsFromBlock(pdbgah),
                   STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO));
        }

        {
            LOCK_GLOBALS;

            pdbgah->pdbgahPrev->pdbgahNext = pdbgah->pdbgahNext;
            pdbgah->pdbgahNext->pdbgahPrev = pdbgah->pdbgahPrev;

            g_cbTotalAllocated -= pdbgah->cbRequest;
        }

        *ppv = pdbgah;
        cb = ActualSizeFromRequestSize(cbRequest, pdbgah->fSymbols);
    }

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return cb;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExPostRealloc
//
//  Synopsis:   Hook called after the memory allocation function
//
//  Arguments:  pv  Pointer to the actual allocation.
//
//  Returns:    Pointer to the requested allocation.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPostRealloc(void *pv)
{
    void *          pvReturn;
    DBGTHREADSTATE *   pts;
    DBGALLOCHDR *   pdbgah;
    DBGALLOCFOOT *  pdbgft;

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    pts = DbgGetThreadState();

    if (pts->pvRequest == NULL)
    {
        pvReturn = DbgExPostAlloc(pv);
    }
    else if (pts->cbRequest == 0)
    {
        Assert(pv == NULL);
        pvReturn = NULL;
    }
    else
    {
        LOCK_GLOBALS;

        if (pv == NULL)
        {

            // The realloc failed.  Hook the the block back
            // into the list.

            Assert(pts->pvRequest);
            pdbgah = ActualFromRequest(pts->pvRequest);

            pdbgah->pdbgahPrev = &g_dbgahRoot;
            pdbgah->pdbgahNext = g_dbgahRoot.pdbgahNext;
            g_dbgahRoot.pdbgahNext->pdbgahPrev = pdbgah;
            g_dbgahRoot.pdbgahNext = pdbgah;

            g_cbTotalAllocated += pts->cbRequest;
            if (g_cbMaxAllocated < g_cbTotalAllocated)
                g_cbMaxAllocated = g_cbTotalAllocated;

            pvReturn = NULL;
        }
        else
        {
            pdbgah = (DBGALLOCHDR *)pv;

            DbgTraceAlloc("R", pts->cbRequest, pdbgah->cbRequest);

            if (pdbgah->fCoFlag && pdbgah->mt)
            {
                DbgExMtAdd(pdbgah->mt, 0, (pts->cbRequest - pdbgah->cbRequest));
            }

            //  Keep track of total amount of memory allocated
            pdbgah->cbRequest = pts->cbRequest;
            g_cbTotalAllocated += pts->cbRequest;
            if (g_cbMaxAllocated < g_cbTotalAllocated)
                g_cbMaxAllocated = g_cbTotalAllocated;

            //  Hook into allocated blocks chain
            pdbgah->pdbgahPrev = &g_dbgahRoot;
            pdbgah->pdbgahNext = g_dbgahRoot.pdbgahNext;
            g_dbgahRoot.pdbgahNext->pdbgahPrev = pdbgah;
            g_dbgahRoot.pdbgahNext = pdbgah;

            if (pdbgah->fSymbols)
            {
                // recall saved symbols
                memcpy(SymbolsFromBlock(pdbgah), pts->aSymbols,
                       STACK_WALK_DEPTH * sizeof(INET_SYMBOL_INFO));
            }

            //  Fill in guard blocks
            pdbgft = FooterFromBlock(pdbgah);
            Assert(sizeof(pdbgft->adwGuard) == sizeof(g_abFootGuardFill));
            memcpy(pdbgft->adwGuard, g_abFootGuardFill, sizeof(g_abFootGuardFill));

            pvReturn = RequestFromActual(pdbgah);
        }
    }

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pvReturn;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgPreDidAlloc
//
//  Synopsis:   Hook called before memory did allocate function.
//
//  Arguments:  pv  Pointer to the requested allocation.
//
//  Returns:    Pointer to the actual allocatino.
//
//-------------------------------------------------------------------------

void * WINAPI
DbgExPreDidAlloc(void *pvRequest)
{
    return ActualFromRequest(pvRequest);
}

//+------------------------------------------------------------------------
//
//  Function:   DbgPreDidAlloc
//
//  Synopsis:   Hook called after memory did allocate function.
//
//  Arguments:  pvRequest Pointer to the requested allocation.
//              fActual   Actual return value for the block
//
//  Returns:    Did we allocate this block?.
//
//-------------------------------------------------------------------------

BOOL WINAPI
DbgExPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return fActual;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExMemSetName
//
//  Synopsis:   Sets the descriptive name of a memory block
//
//  Arguments:  pv  Pointer to the requested allocation
//
//  Returns:    Pointer to the requested allocation
//
//-------------------------------------------------------------------------
void * __cdecl
DbgExMemSetName(void *pvRequest, char * szFmt, ...)
{
    va_list va;
    void * pv;

    va_start(va, szFmt);
    pv = DbgExMemSetNameList(pvRequest, szFmt, va);
    va_end(va);

    return(pv);
}

void * WINAPI
DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list va)
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    DBGALLOCHDR * pdbgah = ActualFromRequest(pvRequest);

    char szBuf[1024];

    if (!BlockIsValid(pdbgah))
        return pvRequest;

    if (pvRequest)
    {
        wvsprintfA(szBuf, szFmt, va);

        szBuf[ARRAY_SIZE(pdbgah->szName) - 1] = 0;
        lstrcpyA(pdbgah->szName, szBuf);
    }

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    return pvRequest;
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExMemGetName
//
//  Synopsis:   Gets the descriptive name of a memory block
//
//  Arguments:  pv  Pointer to the requested allocation
//
//  Returns:    Pointer to the requested allocation
//
//-------------------------------------------------------------------------

char * WINAPI
DbgExMemGetName(void *pvRequest)
{
    return(ActualFromRequest(pvRequest)->szName);
}

//+------------------------------------------------------------------------
//
//  Function:   DbgSetAutoLeak
//
//  Synopsis:   Tests the contents of the block to determine if it is
//              known to have been leaked.  If so, turns on the fLeaked flag.
//
//  Arguments:  pv  Pointer to the requested allocation
//
//  Returns:    Pointer to the requested allocation
//
//-------------------------------------------------------------------------

void DbgSetAutoLeak(DBGALLOCHDR * pdbgah)
{
    return;

#if 0 // For example ...
    size_t cbClient = pdbgah->cbRequest - pdbgah->cbHeader;

    if (pdbgah->fLeaked || cbClient < 5 || cbClient > 32)
        return;

    if (    memcmp(ClientFromActual(pdbgah), "image/", 6) == 0
        ||  memcmp(ClientFromActual(pdbgah), "text/", 5) == 0
        ||  memcmp(ClientFromActual(pdbgah), "application/", 12) == 0)
    {
        pdbgah->fLeaked = TRUE;
    }
#endif
}

//+------------------------------------------------------------------------
//
//  Function:   DbgExTraceMemoryLeaks
//
//  Synopsis:   Traces all allocated blocks, along with stack backtraces
//              from their allocation, to tagLeaks.
//
//-------------------------------------------------------------------------

void WINAPI
DbgExTraceMemoryLeaks()
{
    DBGALLOCHDR *   pdbgah;
#ifndef _MAC
    int             i;
    INET_SYMBOL_INFO *   psi;
    CHAR            achSymbol[256];
#endif
    int             iPass;
    int             acLeaks[4] = { 0, 0, 0, 0 };
    BOOL            fLeakBanner;
    TRACETAG        tag;
    char            achBuf[512];
    HANDLE          hFile = INVALID_HANDLE_VALUE;

    EnsureThreadState();

    LOCK_GLOBALS;

    for (iPass = 0; iPass < 2; ++iPass)
    {
        fLeakBanner = FALSE;
        tag = iPass == 0 ? tagLeaks : tagLeaksExpected;

        for (pdbgah = g_dbgahRoot.pdbgahNext;
             pdbgah != &g_dbgahRoot;
             pdbgah = pdbgah->pdbgahNext)
        {
            if (iPass == 0)
            {
                DbgSetAutoLeak(pdbgah);
            }

            if (!!pdbgah->fLeaked == (iPass == 0))
                continue;

            if (!fLeakBanner)
            {
                fLeakBanner = TRUE;

                wsprintfA(achBuf, "---------- Leaked Memory Blocks %s----------",
                    iPass == 0 ? "" : "(Expected) ");

                if (DbgExIsTagEnabled(tag))
                {
                    TraceLeak(tag, &hFile, achBuf, TRUE);
                }
            }

            if (DbgExIsTagEnabled(tag))
            {
                wsprintfA(achBuf, "%c%c p=0x%08x  cb=%-4d #=%-4d TID:0x%x %s",
                        pdbgah->fCoFlag ? 'C' : ' ',
                        pdbgah->fLeaked ? 'L' : ' ',
                        ClientFromActual(pdbgah),
                        pdbgah->cbRequest - pdbgah->cbHeader,
                        pdbgah->iAllocated,
                        pdbgah->tid,
                        pdbgah->szName);

                TraceLeak(tag, &hFile, achBuf, TRUE);

                if (pdbgah->mt)
                {
                    wsprintfA(achBuf, "   %s (%s)", DbgExMtGetName(pdbgah->mt), DbgExMtGetDesc(pdbgah->mt));
                    TraceLeak(tag, &hFile, achBuf, TRUE);
                }

                psi = (pdbgah->fSymbols) ? SymbolsFromBlock(pdbgah) : NULL;

                for (i = 0; i < ARRAY_SIZE(pdbgah->dwEip); i++)
                {
                    if (!pdbgah->dwEip[i])
                        break;

                    GetStringFromSymbolInfo(pdbgah->dwEip[i],
                                            (psi) ? psi + i : NULL,
                                            achSymbol);

                    if (achSymbol[0])
                    {
                        wsprintfA(achBuf, " %s", achSymbol);
                        TraceLeak(tag, &hFile, achBuf, TRUE);
                    }
                }

                if (hFile != INVALID_HANDLE_VALUE || DbgExIsTagEnabled(tagHexDumpLeaks))
                {
                    ULONG cb = pdbgah->cbRequest - pdbgah->cbHeader;

                    if (cb > 4096)
                        cb = 4096;

                    DumpHex(hFile, (BYTE *)ClientFromActual(pdbgah), cb, (DWORD_PTR)ClientFromActual(pdbgah));
                }
            }

            if (pdbgah->fCoFlag)
                acLeaks[iPass + 2]++;
            else
                acLeaks[iPass]++;
        }
    }

    wsprintfA(achBuf, "%d+%d leaks (plus %d+%d expected), total size %d, peak size %d",
            acLeaks[0], acLeaks[2], acLeaks[1], acLeaks[3],
            g_cbTotalAllocated, g_cbMaxAllocated);
    TraceLeak(tagNull, &hFile, achBuf, FALSE);


    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    //
    // Don't fire the assert if the exit-on-assert flag is on - calling
    // TerminateProcess when we're already shutting down the process causes
    // Win95 to blow up.
    //
    if (!DbgExIsTagEnabled(tagNoLeakAssert))
    {
        char achMsg[512];

        wsprintfA(achMsg, "Memory Leaked! %d+%d block%s (plus %d+%d expected)\n(Leaks were dumped to c:\\leakdump.txt so there is no excuse to ignore this message!)",
            acLeaks[0], acLeaks[2], (acLeaks[0] + acLeaks[2] == 1) ? "" : "s",
            acLeaks[1], acLeaks[3]);

        AssertSz(acLeaks[0] + acLeaks[2] == 0, achMsg);
    }
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExValidateInternalHeap
//
//  Synopsis:   Cruises through the heap, validating each allocated
//              block.  Any invalid blocks are traced to tagLeaks.
//              Function returns TRUE iff all blocks are valid.
//
//-------------------------------------------------------------------------

BOOL WINAPI
DbgExValidateInternalHeap()
{
    DBGALLOCHDR *   pdbgah;
    int             i;
    BOOL            fHeapValid  = TRUE;
    CHAR            achSymbol[256];
    INET_SYMBOL_INFO    *psi;

    EnsureThreadState();

    LOCK_GLOBALS;

    for (pdbgah = g_dbgahRoot.pdbgahNext;
         pdbgah != &g_dbgahRoot;
         pdbgah = pdbgah->pdbgahNext)
    {
        if (!BlockIsValid(pdbgah))
        {
            if (fHeapValid && !AreSymbolsEnabled())
            {
                TraceTag((tagLeaks, ""));

                TraceTag((tagLeaks, "Symbol loading is not enabled. Turn on the '!Symbols'"));
                TraceTag((tagLeaks, "   tag to enable it and then restart your application. Make sure"));
                TraceTag((tagLeaks, "   imagehlp.dll and mspdb41.dll are on your path."));
                TraceTag((tagLeaks, "See the Forms3 Development Handbook, Tips, Tip04 for details.\n"));
            }

            fHeapValid = FALSE;

            TraceTag((
                    tagLeaks,
                    "Invalid block at 0x%08x  Size:%-4d Alloc #:%-4d TID:0x%x",
                    ClientFromActual(pdbgah),
                    pdbgah->cbRequest - pdbgah->cbHeader,
                    pdbgah->iAllocated,
                    pdbgah->tid));

            if (DbgExIsTagEnabled(tagLeaks))
            {
                psi = (pdbgah->fSymbols) ? SymbolsFromBlock(pdbgah) : NULL;

                for (i = 0; i < ARRAY_SIZE(pdbgah->dwEip); i++)
                {
                    if (!pdbgah->dwEip[i])
                        break;

                    GetStringFromSymbolInfo(pdbgah->dwEip[i],
                                            (psi) ? psi + i : NULL,
                                            achSymbol);

                    TraceTag((tagLeaks, "%s", achSymbol));
                }
            }
        }
    }

#if !defined(_MAC)
    //
    // Then, check the system's process heap.
    //
    if (fHeapValid && g_fOSIsNT)
    {
        //
        // If running under a debugger, this call will generate a breakpoint
        // and print information to the debugger if the heap is corrupt.
        //
        EnterCriticalSection(&g_csHeapHack);
        fHeapValid = HeapValidate(GetProcessHeap(), 0, NULL);
        LeaveCriticalSection(&g_csHeapHack);
    }
#endif

    // check

    return fHeapValid;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExMemoryBlockTrackDisable
//
//  Synopsis:   Disables memory leak tracking for a previously allocated block.
//
//  Arguments:  [pvRequest] -- The allocated memory block
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void WINAPI
DbgExMemoryBlockTrackDisable(void * pv)
{
    DBGALLOCHDR * pdbgah;
    DBGALLOCHDR * pdbgahT;

    EnsureThreadState();

    if (!pv)
        return;

    LOCK_GLOBALS;

    pdbgahT = ActualFromRequest(pv);

    for (pdbgah = g_dbgahRoot.pdbgahNext;
         pdbgah != &g_dbgahRoot;
         pdbgah = pdbgah->pdbgahNext)
    {
        if (pdbgah == pdbgahT)
        {
            pdbgah->fLeaked = TRUE;
            return;
        }
    }

    TraceTag((tagLeaks, "DbgExMemoryBlockTrackDisable: Block not found: %08lX\n", pv));
}

// Heap Monitor ---------------------------------------------------------------

/* We have no bitmaps in our owner-drawn controls, but  */
/* if we did, these constants would need to be updated. */

#define BMWIDTH             0
#define BMHEIGHT            0
#define NUMBMPS             0

typedef DBGALLOCHDR DBGAH, * PDBGAH;

/* Function Prototypes */

/* Heap Monitor Dialog Thread and Dialog Proc */

DWORD WINAPI
HeapMonitorThread(LPVOID lpv);

INT_PTR WINAPI
HeapMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/* Command and Support Routines for the HeapMonDlgProc */

void    BltIcon(HWND hWnd);
void    SetWindowTitle(HWND hWnd, LPSTR lpcText);
void    RefreshHeapView(HWND hWnd);
void    SetSumSelection(void);
void    BlockListNotify(WORD wNotify, HWND  hWnd);

BOOL    FBlockStillValid(PDBGAH pdbgah);

void    MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
int     CompareItem(UINT idCtl, LPCOMPAREITEMSTRUCT pcis);
void    DrawItem(WORD wId, LPDRAWITEMSTRUCT pdis);
void    OutTextFormat(WORD wId, LPDRAWITEMSTRUCT pdis);
void    SetRGBValues(void);

/* Memory Block Editor Dialog Proc and Support Routines */

INT_PTR WINAPI
BlockDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void    FormatBlockRow(LPSTR psz, LPBYTE lpbRow, LPBYTE lpbHead, UINT cb, LPBYTE pbReal);
void    OutBlockRowFormat(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah);
void    DrawBlockRow(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah);
void    SetBlockEditData(HWND hWnd, PDBGAH pdbgah);

//  Global Data

HWND        ghWnd           = NULL;
HWND        ghBlockWnd      = NULL;
HICON       ghIcon          = NULL;
HBRUSH      ghbrBkgnd       = NULL;
UINT        idSort          = IDC_SORTADDRESS;
UINT        idDataType      = IDC_BYTE;
BOOL        fDlgUp          = FALSE;
BOOL        g_fShowMeters   = FALSE;

//  Globals used by the Owner-Draw code.

DWORD       rgbWindowColor  = 0xFF000000;    // variables for the current
DWORD       rgbHiliteColor  = 0xFF000000;    // system color settings.
DWORD       rgbWindowText   = 0xFF000000;    // on a WM_SYSCOLORCHANGE
DWORD       rgbHiliteText   = 0xFF000000;    // we check to see if we need
DWORD       rgbGrayText     = 0xFF000000;    // to reload our bitmap.
DWORD       rgbDDWindow     = 0xFF000000;    //
DWORD       rgbDDHilite     = 0xFF000000;    // 0xFF000000 is an invalid RGB

//  Tabs for the Block List - Address  AllocNum  Size  Description

//  Tabs for Memory Block Edit

//  hdc to hold listbox bitmaps (for speed)

HDC     hdcMemory = 0;

/* Memory browsing threads */
DWORD   WINAPI  DoBrowseThread(LPVOID lpParam);
DWORD   WINAPI  DoMemStats(LPVOID lpParam);


void WINAPI DoMemoryBrowse(HINSTANCE phInst, HWND phWnd, DWORD dwProcess);


void WINAPI
DbgExOpenMemoryMonitor()
{
    if (fDlgUp)
    {
        ShowWindow(ghWnd, SW_RESTORE);
        SetForegroundWindow(ghWnd);
    }
    else
    {
        DWORD dwThreadId;
        THREAD_HANDLE hThread;

        hThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0,
            (LPTHREAD_START_ROUTINE)HeapMonitorThread,
            NULL, 0, &dwThreadId);

        CloseThread(hThread);
    }
}

/*
 -  HeapMonitorThread
 -
 *  Purpose:
 *      This thread is here for the sole purpose of putting up a
 *      dialog who gets messages on this threads time slice.
 */

DWORD WINAPI HeapMonitorThread(LPVOID lpv)
{
    ghbrBkgnd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    ghIcon = LoadIconA(g_hinstMain, MAKEINTRESOURCEA(IIC_ICONIC));

    DialogBoxA(g_hinstMain, MAKEINTRESOURCEA(IDD_HEAPMON), NULL, HeapMonDlgProc);

    DeleteObject(ghbrBkgnd);

    return 0;
}


/*
 -  FBlockStillValid
 -
 *  Purpose:
 *      Searches for the specified block in the specified heaps.
 *      This must be done before using a pdbgah object since they
 *      are used and added/removed on two different threads.
 */

BOOL FBlockStillValid(PDBGAH pdbgah)
{
    PDBGAH pdbgahT = pdbgah;

    for (pdbgah = g_dbgahRoot.pdbgahNext;
         pdbgah != &g_dbgahRoot;
         pdbgah = pdbgah->pdbgahNext)
    {
        if (pdbgah == pdbgahT)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


#define PvPlhblkEnd(pdbgah)     ((LPBYTE)RequestFromActual(pdbgah) + (pdbgah)->cbRequest - 1)

/*
 -  RefreshHeapView
 -
 *  Purpose:
 *      This updates our currently displayed heap.  Does all the calculations
 *      and fills in all the edit controls on the HeapMon dialog.
 */

void RefreshHeapView(HWND hWnd)
{
    char    szOutBuff[128];
    ULONG   cLive = 0;
    PDBGAH  pdbgah;
    ULONG   cbLive = 0;
    LONG    idxTop;

    LOCK_GLOBALS;

    idxTop = SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_GETTOPINDEX, 0, 0L);

    SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_RESETCONTENT, 0, 0L);

    pdbgah = g_dbgahRoot.pdbgahNext;

    while (pdbgah != &g_dbgahRoot)
    {
        DbgSetAutoLeak(pdbgah);
        cLive++;
        cbLive += (ULONG)(pdbgah->cbRequest - pdbgah->cbHeader);
        SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_ADDSTRING, 0, (LPARAM)pdbgah);
        pdbgah = pdbgah->pdbgahNext;
    }

    if (idxTop != CB_ERR)
        SendDlgItemMessageA(hWnd, IDC_BLOCKLIST, LB_SETTOPINDEX, (WPARAM)idxTop, 0L);

    wsprintfA(szOutBuff, "%7ld Bytes in %ld Blocks", cbLive, cLive);
    SetDlgItemTextA(hWnd, IDE_LIVEBLOCK, szOutBuff);

    SetSumSelection();
}

/*
 -  BlockListNotify
 -
 *  Purpose:
 *      We capture double click notifications on the block list and
 *      bring up a hex editor (that is read-only) for the memory in
 *      that block.  A nasty side effect of this is that we grab the
 *      critical section on the heap before putting up the dialog and
 *      we don't release it until we return from the dialog.  We have
 *      to do this to prevent the memory from going away out from under
 *      us.
 */

void BlockListNotify(WORD wNotify, HWND  hWnd)
{
    LONG    idx;
    PDBGAH  pdbgah = NULL;
    PDBGAH  pdbgahCopy = NULL;
    ULONG   cb;
    BOOL    fDoDialog = FALSE;

    if (wNotify == LBN_DBLCLK)
    {
        idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);

        if (idx != CB_ERR)
            pdbgah = (PDBGAH)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
        if ((LONG_PTR)pdbgah == (LONG_PTR)CB_ERR)
            goto ret;

        if (!(GetAsyncKeyState(VK_CONTROL) & 0x8000))
        {
            {
                LOCK_GLOBALS;

                if (FBlockStillValid(pdbgah))
                {
                    cb = ActualSizeFromRequestSize(pdbgah->cbRequest, pdbgah->fSymbols);
                    pdbgahCopy = (PDBGAH)LocalAlloc(LPTR, cb);

                    if (pdbgahCopy != NULL)
                    {
                        memcpy(pdbgahCopy, pdbgah, cb);
                        *(DWORD_PTR *)pdbgahCopy->adwGuard = (DWORD_PTR)ClientFromActual(pdbgah);
                        fDoDialog = TRUE;
                    }
                }
            }

            if (fDoDialog)
            {
                DialogBoxParamA(g_hinstMain,
                        MAKEINTRESOURCEA(IDD_BLOCKEDIT),
                        hWnd, BlockDlgProc, (LPARAM)pdbgahCopy);

                LocalFree((HGLOBAL)pdbgahCopy);
            }
        }
        else
        {
            idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);

            if (idx != CB_ERR)
                pdbgah = (PDBGAH)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
            if ((LONG_PTR)pdbgah == (LONG_PTR)CB_ERR)
                goto ret;

            g_pvMemSearch = ClientFromActual(pdbgah);

            RefreshHeapView(ghWnd);
        }
    }
    else if (wNotify == LBN_SELCHANGE)
    {
        SetSumSelection();
    }

ret:
    return;
}


/*
 -  SetWindowTitle
 -
 *  Purpose:
 *      Updates the dialog window title to include the process
 *      on whose behalf we were invoked.
 */

void SetWindowTitle(HWND hWnd, LPSTR lpcText)
{
    LPSTR   pszModule;
    char    szTitle[80];
    char    szModule[MAX_PATH];

    if(!GetModuleFileNameA(NULL, szModule, MAX_PATH))
    {
        Assert(FALSE);
        return;
    }

    pszModule = (LPSTR)(szModule + lstrlenA(szModule));

    while (*pszModule-- != '\\') ;

    pszModule += 2;

    CharUpperBuffA(pszModule, lstrlenA(pszModule));

    wsprintfA(szTitle, lpcText, pszModule);
    SetWindowTextA(hWnd, szTitle);
}


/*
 -  BltIcon
 -
 *  Purpose:
 *      BitBlts a bitmap in the client area of the dialog when the dialog
 *      is minimized (IsIconic).  This is to get around a Windows limitation
 *      of not being able to associate an icon with a dialog.
 */

void BltIcon(HWND hWnd)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT rc;

    hdc = BeginPaint(hWnd, &ps);

    if (hdc)
    {
        GetClientRect(hWnd, &rc);
        FillRect(hdc, &rc, ghbrBkgnd);
        DrawIcon(hdc, 0, 0, ghIcon);
    }

    EndPaint(hWnd, &ps);
}

/*
 -  HeapMonDlgProc
 -
 *  Purpose:
 *      This function (which only executes on Win32 in debug builds) is
 *      used to monitor heap usage on the any heap created by glheap.  We
 *      will attempt to calculate total heap usage, heap fragmentation,
 *      and percentage per heap of total allocations.
 */

INT_PTR WINAPI
HeapMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghWnd = hWnd;
            CheckRadioButton(hWnd, IDC_SORTCFLAG, IDC_SORTSIZE, idSort);
            SetRGBValues();
            SetWindowTitle(hWnd, "Heap Monitor - %s");
            fDlgUp = TRUE;
            RefreshHeapView(hWnd);
            ShowWindow(hWnd, SW_SHOW);
            break;

        case WM_SYSCOLORCHANGE:
            SetRGBValues();
            RefreshHeapView(hWnd);
            break;

        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            DrawItem((WORD)(((LPDRAWITEMSTRUCT)lParam)->CtlID),
                    (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_COMPAREITEM:
            return CompareItem((UINT)wParam, (COMPAREITEMSTRUCT *)lParam);

        case WM_PAINT:
            if (IsIconic(hWnd))
                BltIcon(hWnd);

            return FALSE;

        case WM_ERASEBKGND:
            return IsIconic(hWnd);

        case WM_CLOSE:
            if (ghBlockWnd)
                SendMessageA(ghBlockWnd, WM_CLOSE, 0, 0L);
            fDlgUp = FALSE;
            return EndDialog(hWnd, 0);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_REFRESH:
                    RefreshHeapView(hWnd);
                    break;

                case IDC_VIRTUAL:
                    DoMemoryBrowse(g_hinstMain, hWnd, GetCurrentProcessId());
                    break;

                case IDC_DUMPHEAPS:
                    DbgExDumpProcessHeaps();
                    break;

                case IDC_SORTCFLAG:
                case IDC_SORTTYPE:
                case IDC_SORTNAME:
                case IDC_SORTADDRESS:
                case IDC_SORTALLOC:
                case IDC_SORTSIZE:
                    idSort = GET_WM_COMMAND_ID(wParam, lParam);
                    CheckRadioButton(hWnd, IDC_SORTCFLAG, IDC_SORTSIZE, idSort);
                    RefreshHeapView(hWnd);
                    break;

                case IDC_BLOCKLIST:
                    BlockListNotify(GET_WM_COMMAND_CMD(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam));
                    break;

                case IDC_SHOWMETERS:
                    g_fShowMeters = !!IsDlgButtonChecked(hWnd, IDC_SHOWMETERS);
                    RefreshHeapView(hWnd);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*
 -  MeasureItem
 -
 *  Purpose:
 *      Returns the height of the system font since that's what we draw with.
 *
 *  Parameters:
 *      hwnd        hwnd of dialog
 *      pmis        measureitemstruct from WM_MEASUREITEM call
 */

void MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis)
{
    HDC         hDC = GetDC(hwnd);
    HANDLE      hFont;
    TEXTMETRICA tm;

    if (hDC)
    {
        hFont = GetStockObject(SYSTEM_FONT);

        hFont = SelectObject(hDC, hFont);
        GetTextMetricsA(hDC, &tm);
        SelectObject(hDC, hFont);
        ReleaseDC(hwnd, hDC);

        pmis->itemHeight = tm.tmHeight;
    }
    else
        pmis->itemHeight = 0;
}

/*
 -  CompareItem
 -
 *  Purpose:
 *      Based on the specified sort order, we evaluate the two blocks
 *      handed to us.  We return -1 if the first one goes before the
 *      second one, zero if they are equal (never happens), and 1 if
 *      the first one goes after the second one.  We apply a secondary
 *      sort to the 2 fields that could potentially be equal: Name &
 *      Size.  The secondary sort is on ulAllocNum which is always
 *      unique.  This just in: we now do a desending sort on Size and
 *      AllocNum since the user is most likely interested in seeing the
 *      largest blocks or the most recently allocated blocks at the top.
 */
int CompareItem(UINT idCtl, LPCOMPAREITEMSTRUCT pcis)
{
    INT_PTR iOrder = 0, i1, i2;
    PDBGAH  pdbgah1, pdbgah2;
    char    achType[1024];

    if (idCtl != IDC_BLOCKLIST)
        goto ret;

    {
        LOCK_GLOBALS;

        pdbgah1 = (PDBGAH)pcis->itemData1;
        pdbgah2 = (PDBGAH)pcis->itemData2;

        if (!FBlockStillValid(pdbgah1) || !FBlockStillValid(pdbgah2))
            goto ret;

        switch (idSort)
        {
            case IDC_SORTCFLAG:
                i1 = ((!!pdbgah1->fCoFlag) << 1) + !!pdbgah1->fLeaked;
                i2 = ((!!pdbgah2->fCoFlag) << 1) + !!pdbgah2->fLeaked;
                iOrder = i1 - i2;
                break;

            case IDC_SORTTYPE:
                if (g_fShowMeters)
                    iOrder = lstrcmpA(DbgExMtGetName(pdbgah1->mt), DbgExMtGetName(pdbgah2->mt));
                else
                {
                    lstrcpynA(achType, GetRunTimeType(ClientFromActual(pdbgah1)), ARRAY_SIZE(achType));
                    iOrder = lstrcmpA(achType, GetRunTimeType(ClientFromActual(pdbgah2)));
                }
                break;

            case IDC_SORTNAME:
                if (g_fShowMeters)
                    iOrder = lstrcmpA(DbgExMtGetDesc(pdbgah1->mt), DbgExMtGetDesc(pdbgah2->mt));
                else
                    iOrder = lstrcmpA(pdbgah1->szName, pdbgah2->szName);
                break;

            case IDC_SORTADDRESS:
                iOrder = (INT_PTR)ClientFromActual(pdbgah1) - (INT_PTR)ClientFromActual(pdbgah2);
                break;

            case IDC_SORTSIZE:
                iOrder =    ((int)pdbgah2->cbRequest - (int)pdbgah2->cbHeader)
                         -  ((int)pdbgah1->cbRequest - (int)pdbgah1->cbHeader);
                break;
        }

        if (iOrder == 0)
        {
            iOrder = (int)pdbgah2->iAllocated - (int)pdbgah1->iAllocated;
        }

        if (iOrder < 0)
            iOrder = -1;
        else if (iOrder > 0)
            iOrder = 1;
        else
            iOrder = 0;
    }

ret:
    return (int)iOrder;
}

/*
 -  DrawItem
 -
 *  Purpose:
 *      Handles WM_DRAWITEM for both Heap combo-box and Block List.
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message.
 */

VOID DrawItem(WORD wId, LPDRAWITEMSTRUCT pdis)
{
    COLORREF    crText = 0, crBack = 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if(pdis->itemState & ODS_SELECTED)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        // parse and spit out bmps and text
        OutTextFormat(wId, pdis);

        // Restore original colors if we changed them above.
        if(pdis->itemState & ODS_SELECTED)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}


/*
 -  OutTextFormat
 -
 *  Purpose:
 *      Used to format and 'TextOut' both Heap combo-box items and
 *      Block List items.  Parsing evaluates the string as follows:
 *      otherwise, outtext the line
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        from DrawItem from WM_DRAWITEM msg
 */

void OutTextFormat(WORD wId, LPDRAWITEMSTRUCT pdis)
{
    char szItem[512];

    LOCK_GLOBALS;

    if (wId == IDC_HEAPLIST)
    {
        wsprintfA(szItem, "%s", "Process Heap");
        ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                    ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, szItem, lstrlenA(szItem), NULL);
    }
    else if (wId == IDC_BLOCKLIST)
    {
        PDBGAH  pdbgah  = (PDBGAH)pdis->itemData;
        BOOL    fFound  = FALSE;
        BOOL    fSearch = FALSE;

        if (FBlockStillValid(pdbgah))
        {
            if (g_pvMemSearch)
            {
                int    cb  = pdbgah->cbRequest - pdbgah->cbHeader;
                void **ppv = (void**)ClientFromActual(pdbgah);

                if (ppv == (void**)g_pvMemSearch)
                    fSearch = TRUE;

                while (cb >= sizeof(void*))
                {
                    if (*ppv == g_pvMemSearch)
                    {
                        fFound = TRUE;
                        break;
                    }
                    cb -= sizeof(void*);
                    ppv++;
                }
            }
            wsprintfA(szItem, "%c%c%c%c%7ld %8lX %6ld %-32.32s %s",
                pdbgah->fCoFlag ? 'C' : ' ',
                pdbgah->fLeaked ? 'L' : ' ',
                fFound          ? 'F' : ' ',
                fSearch         ? '>' : ' ',
                pdbgah->iAllocated,
                ClientFromActual(pdbgah),
                pdbgah->cbRequest - pdbgah->cbHeader,
                g_fShowMeters ? DbgExMtGetName(pdbgah->mt) : GetRunTimeType(ClientFromActual(pdbgah)),
                g_fShowMeters ? DbgExMtGetDesc(pdbgah->mt) : pdbgah->szName);

            ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                        ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, szItem, lstrlenA(szItem), NULL);
        }
    }
}


/*
 -  SetRGBValues
 -
 *  Purpose:
 *      To set various system colors in static variables.  Called at
 *      init time and when system colors change.
 */

VOID SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}


/*
 -  SetSumSelection
 -
 *  Purpose:
 *      Calcualtes to total size of the blocks selected in the Block
 *      List list-box (which is a multi-selction listbox).
 */

void SetSumSelection(void)
{
    int     i;
    int     *rgIdx = NULL;
    LONG    cSel;
    size_t  cbTotal = 0;
    char    szBuff[64];
    PDBGAH  pdbgah;

    LOCK_GLOBALS;

    cSel = SendDlgItemMessageA(ghWnd, IDC_BLOCKLIST, LB_GETSELCOUNT, 0, 0L);

    if (cSel > 0)
    {
        rgIdx = (int *)LocalAlloc(LPTR, cSel*sizeof(int));
        cSel = 0;
        if (rgIdx)
            cSel = SendDlgItemMessageA(ghWnd, IDC_BLOCKLIST, LB_GETSELITEMS, cSel, (LPARAM)rgIdx);
    }

    // Note that rgIdx must be non-null if cSel > 0
    for (i = 0; i < cSel; i++)
    {
        pdbgah = (PDBGAH)SendDlgItemMessageA(ghWnd, IDC_BLOCKLIST,
                LB_GETITEMDATA, rgIdx[i], 0L);

        if (FBlockStillValid(pdbgah))
            cbTotal += pdbgah->cbRequest - pdbgah->cbHeader;
    }

    if (cbTotal == 0)
        szBuff[0] = 0;
    else
        wsprintfA(szBuff, "%7ld Bytes Selected", cbTotal);
    SetDlgItemTextA(ghWnd, IDE_SUMSEL, szBuff);

    if (rgIdx)
    {
        LocalFree((HGLOBAL)rgIdx);
    }
}

/*
 -  FormatBlockRow
 -
 *  Purpose:
 *      Converts the 16 bytes following the memory address at lpbRow
 *      as 4 hex DWORDs, or 8 hex WORDs, or 16 hex BYTEs and as 16
 *      printable characters.  A string is than constructed as follows:
 *
 *      ADDRESS \t DWORD1 \t DWORD2 \t DWORD3 \t DWORD4 \t CH1 \t ... \t CH16
 *  or
 *      ADDRESS \t WORD1  \t WORD2  \t ...    \t WORD8  \t CH1 \t ... \t CH16
 *  or
 *      ADDRESS \t BYTE1  \t BYTE2  \t ...    \t BYTE16 \t CH1 \t ... \t CH16
 *
 *      This string is then output to the list box in the BlockEditDlg.
 */

void FormatBlockRow(LPSTR psz, BYTE * pbRow, BYTE * pbBase, UINT cbRequest, BYTE * pbReal)
{
    UINT   cbRow = min((UINT)16, (UINT)(cbRequest - (pbRow - pbBase)));
    UINT   cbLine;
    BYTE * pb;
    UINT   ib, ich;
    int    c;

    psz += wsprintfA(psz, "%08lX [+%04lX] ", pbReal + (pbRow - pbBase), pbRow - pbBase);

    if (idDataType == IDC_DWORD)
        cbLine = (8*4) + 3;
    else if (idDataType == IDC_WORD)
        cbLine = (4*8) + 7;
    else
        cbLine = (2*16) + 15;

    memset(psz, ' ', cbLine);

    for (ib = 0, pb = pbRow; ib < cbRow; ++ib, ++pb)
    {
        if (idDataType == IDC_DWORD)
            ich = 2*(3 - (ib%4)) + 9*(ib/4);
        else if (idDataType == IDC_WORD)
            ich = 2*(1 - (ib%2)) + 5*(ib/2);
        else
            ich = 3*ib;

        c = (*pb & 0xF);
        psz[ich+1] = (char) (c + ((c < 10) ? '0' : ('A' - 10)));
        c = (*pb & 0xF0) >> 4;
        psz[ich] = (char) (c + ((c < 10) ? '0' : ('A' - 10)));
    }

    psz += cbLine;
    memset(psz, ' ', 2 + 16);
    psz += 2;

    psz[16] = 0;

    for (ib = 0, pb = pbRow; ib < cbRow; ++ib, ++pb)
    {
        if (*pb > 31 && *pb < 128)
            *psz++ = *pb;
        else
            *psz++ = '.';
    }
}


/*
 -  OutBlockRowFormat
 -
 *  Purpose:
 *      Used to format and 'TextOut' the items in the Block Memory
 *      Edit list-box.  Parsing evaluates the string as follows:
 *      otherwise, outtext the line
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        from DrawItem from WM_DRAWITEM msg
 *      pdbgah      Pointer to the block we are editing
 */

void OutBlockRowFormat(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah)
{
    char szItem[256];

    if (wId != IDC_BE_MEMORY)
        return;

    FormatBlockRow(szItem, (LPBYTE)pdis->itemData,
            (LPBYTE)(pdbgah + 1) + pdbgah->cbHeader,
            pdbgah->cbRequest - pdbgah->cbHeader,
            (LPBYTE)(*(DWORD_PTR *)pdbgah->adwGuard));

    //  Draw the text
    ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
        ETO_OPAQUE, &pdis->rcItem, szItem, lstrlenA(szItem), NULL);
}


/*
 -  DrawBlockRow
 -
 *  Purpose:
 *      Handles WM_DRAWITEM for a row in the Block Memory Edit list-box.
 *
 *  Parameters:
 *      wId         Control Id of the control we are drawing into
 *      pdis        LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message.
 *      pdbgah      Pointer to the block we are editing
 */

void DrawBlockRow(WORD wId, LPDRAWITEMSTRUCT pdis, PDBGAH pdbgah)
{
    COLORREF    crText = 0, crBack = 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if(pdis->itemState & ODS_SELECTED)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        // parse and spit out bmps and text
        OutBlockRowFormat(wId, pdis, pdbgah);

        // Restore original colors if we changed them above.
        if(pdis->itemState & ODS_SELECTED)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}


/*
 -  SetBlockEditData
 -
 *  Purpose:
 *      Fills in all the fields on the Block Memory Edit dialog.  Adds
 *      data items to the owner-drawn memory list-box.  Data items are
 *      pointers into every 16 bytes of the memory in the block.  The
 *      owner-draw code then formats each data item in a human readable
 *      format much like a memory window in a debugger.
 *
 *  NOTE:
 *      The initialization of lpb is (pdbgah + 1) instead of
 *      RequestFromActual(pdbgah) because this is not the real block, it is a
 *      copy of the real block and the data is appended to the end of
 *      this copy (see BlockListNotify() function).  THIS IS BY DESIGN!
 */

void SetBlockEditData(HWND hWnd, PDBGAH pdbgah)
{
    UINT    i;
    char    szOutBuff[1024];
    ULONG   cb = pdbgah->cbRequest - pdbgah->cbHeader;
    LPBYTE  lpb = (LPBYTE)(pdbgah + 1) + pdbgah->cbHeader;
    LPBYTE  lpbEnd;
    LPSTR   pszType;

    SendDlgItemMessageA(hWnd, IDC_BE_MEMORY, LB_RESETCONTENT, 0, 0L);
    SendDlgItemMessageA(hWnd, IDC_CALLSTACK, LB_RESETCONTENT, 0, 0L);

    pszType = GetRunTimeType(ClientFromActual(pdbgah));

    if (*pszType == 0 && *pdbgah->szName == 0)
        wsprintfA(szOutBuff, "Memory - 0x%08lX", pdbgah->adwGuard[0]);
    else
        wsprintfA(szOutBuff, "Memory - %s%s%s", pszType, pszType ? " " : "",
            pdbgah->szName);
    SetWindowTextA(hWnd, szOutBuff);

    if (DbgExIsTagEnabled(tagLeaks))
    {
        INET_SYMBOL_INFO * psi = (pdbgah->fSymbols) ? SymbolsFromBlock(pdbgah) : NULL;
        CHAR achSymbol[256];

        for (i = 0; i < ARRAY_SIZE(pdbgah->dwEip); i++)
        {
            if (!pdbgah->dwEip[i])
                break;

            GetStringFromSymbolInfo(pdbgah->dwEip[i],
                                    (psi) ? psi + i : NULL,
                                    achSymbol);

            LPSTR psz = achSymbol;

            while (*psz == ' ')
                ++psz;

            SendDlgItemMessageA(hWnd, IDC_CALLSTACK, LB_ADDSTRING, 0, (LPARAM)psz);
        }
    }

    for (lpbEnd = lpb + cb; lpb < lpbEnd; lpb += 16)
        SendDlgItemMessageA(hWnd, IDC_BE_MEMORY, LB_ADDSTRING, 0, (LPARAM)lpb);
}

/*
 -  BlockDlgProc
 -
 *  Purpose:
 *      This is the dialog procedure for the Block Memory Edit dialog
 *      box.  This dialog displays a block of memory much like a
 *      debugger would.  This is a read-only display of the memory.
 */

INT_PTR WINAPI
BlockDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PDBGAH   pdbgah;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghBlockWnd = hWnd;
            pdbgah = (PDBGAH)lParam;
            CheckRadioButton(hWnd, IDC_DWORD, IDC_BYTE, idDataType);
            SetBlockEditData(hWnd, pdbgah);
            break;

        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            DrawBlockRow((WORD)(((LPDRAWITEMSTRUCT)lParam)->CtlID),
                    (LPDRAWITEMSTRUCT)lParam, pdbgah);
            break;

        case WM_CLOSE:
            ghBlockWnd = NULL;
            EndDialog(hWnd, 0);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_DWORD:
                case IDC_WORD:
                case IDC_BYTE:
                    idDataType = LOWORD(wParam);
                    CheckRadioButton(hWnd, IDC_DWORD, IDC_BYTE, idDataType);
                    SetBlockEditData(hWnd, pdbgah);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


void    ViewBlock(HWND phWnd, LPVOID lpcBlock)
{
    DialogBoxParamA(g_hinstMain,
            MAKEINTRESOURCEA(IDD_BLOCKEDIT),
            phWnd, BlockDlgProc, (LPARAM) lpcBlock);
}

// Virtual Memory Browser -----------------------------------------------------

struct LONGDATA
{
   DWORD dwValue;
   LPCSTR szText;
};

#ifndef MEM_IMAGE
#define SEC_FILE           0x800000
#define SEC_IMAGE         0x1000000
#define SEC_RESERVE       0x4000000
#define SEC_COMMIT        0x8000000
#define SEC_NOCACHE      0x10000000
#define MEM_IMAGE         SEC_IMAGE
#endif

#define TABLEENTRY(Prefix, Value)        Prefix##Value, #Value

LONGDATA PageFlags[] = {
   TABLEENTRY(PAGE_, NOACCESS),
   TABLEENTRY(PAGE_, READONLY),
   TABLEENTRY(PAGE_, READWRITE),
   TABLEENTRY(PAGE_, WRITECOPY),
   TABLEENTRY(PAGE_, EXECUTE),
   TABLEENTRY(PAGE_, EXECUTE_READ),
   TABLEENTRY(PAGE_, EXECUTE_READWRITE),
   TABLEENTRY(PAGE_, EXECUTE_WRITECOPY),
   TABLEENTRY(PAGE_, GUARD),
   TABLEENTRY(PAGE_, NOCACHE),
   TABLEENTRY(0, 0)
};

LONGDATA MemFlags[] = {
   TABLEENTRY(MEM_, COMMIT),
   TABLEENTRY(MEM_, RESERVE),
   TABLEENTRY(MEM_, DECOMMIT),
   TABLEENTRY(MEM_, RELEASE),
   TABLEENTRY(MEM_, FREE),
   TABLEENTRY(MEM_, PRIVATE),
   TABLEENTRY(MEM_, MAPPED),
   TABLEENTRY(MEM_, TOP_DOWN),
   TABLEENTRY(MEM_, IMAGE),
   TABLEENTRY(0, 0)
};

#define COLS        16


extern DWORD   rgbWindowColor;
extern DWORD   rgbHiliteColor;
extern DWORD   rgbWindowText;
extern DWORD   rgbHiliteText;
extern DWORD   rgbGrayText;
extern DWORD   rgbDDWindow;
extern DWORD   rgbDDHilite;

int         tabs[COLS];
HANDLE      hProcess;

void    ViewBlock(HWND phWnd, LPVOID lpcBlock);
extern  void SetRGBValues(VOID);

int         cols[COLS] = {70, 13, 70, 11, 11, 11, 11, 65, 11, 11, 11, 11, 11, 65, 80, 92};

/////////////////////////////////////////////////////////////


LPCSTR GetAllocFlagStr(DWORD dwFlag)
{
    static char sszBuffer[20];

    sszBuffer[0] = '\0';

    if (dwFlag & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE))
        lstrcatA(sszBuffer, "R");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "W");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "X");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "C");
    else
        lstrcatA(sszBuffer, ".");

    return sszBuffer;
}

LPCSTR GetCurrentFlagStr(DWORD dwFlag)
{
    static char sszBuffer[20];

    sszBuffer[0] = '\0';

    if (dwFlag & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE))
        lstrcatA(sszBuffer, "R");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "W");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "X");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
        lstrcatA(sszBuffer, "C");
    else
        lstrcatA(sszBuffer, ".");

    lstrcatA(sszBuffer, "\t");

    if (dwFlag & (PAGE_GUARD))
        lstrcatA(sszBuffer, "G");
    else
        lstrcatA(sszBuffer, ".");

    return sszBuffer;
}


LPCSTR GetStateStr (DWORD dwFlag)
{
   if (dwFlag == MEM_COMMIT) return "C";
   if (dwFlag == MEM_RESERVE) return "R";
   if (dwFlag == MEM_FREE) return "F";

   return "?";
}


LPCSTR  GetFlagStr(DWORD dwFlag)
{
    if (dwFlag == MEM_PRIVATE) return "Private";
    if (dwFlag == MEM_MAPPED) return "Mapped";
    if (dwFlag == MEM_TOP_DOWN) return "Top Down";
    if (dwFlag == MEM_IMAGE) return "Image";

    return "Unknown";
}


/*
 * IsGlobalLocalHeap
 *
 *  Takes a Base Address of a chunk of memory, returns TRUE if this Base
 *  is in a Local or Global heap
 *
 */

UINT IsGlobalLocalHeap(LPVOID   lpBaseAddress)
{
    if (lpBaseAddress == GetProcessHeap())
        return 1;

    return 0;
}

/////////////////////////////////////////////////////////////

void ConstructMemInfoLine (PMEMORY_BASIC_INFORMATION pMBI,
   LPSTR szLine) {

   LPCSTR sz;

   // BaseAddress
   wsprintfA(szLine, "%08X\t", pMBI->BaseAddress);

   // State
   wsprintfA(strchr(szLine, 0), "%s\t", GetStateStr(pMBI->State));

   // AllocationBase
   if ((pMBI->BaseAddress != pMBI->AllocationBase) && pMBI->State != MEM_FREE)
        wsprintfA(strchr(szLine, 0), "%08X\t", pMBI->AllocationBase);
    else
        lstrcatA(szLine, "\t");

   // AllocationProtect
   if (pMBI->State != MEM_FREE)
      sz = GetAllocFlagStr(pMBI->AllocationProtect);
   else
      sz = "\t\t\t";

   wsprintfA(strchr(szLine, 0), "%s\t", sz);

   // RegionSize
   wsprintfA(strchr(szLine, 0), "%05lX\t",
      pMBI->RegionSize / 4096);


   // Protect
   if ((pMBI->State != MEM_FREE) &&
       (pMBI->State != MEM_RESERVE))
   {
      sz = GetCurrentFlagStr(pMBI->Protect);
   }
   else
      sz = "\t\t\t\t";

   wsprintfA(strchr(szLine, 0), "%s\t", sz);

   // Type
   if (pMBI->State != MEM_FREE)
   {
      sz = GetFlagStr(pMBI->Type);
   }
   else
      sz = "";

   wsprintfA(strchr(szLine, 0), "%s", sz);
}

UINT        IsAppBasedOk(PMEMORY_BASIC_INFORMATION pMBI, LPSTR lpText, HANDLE hProc)
{
    UINT                        iRet = 0;
    LPBYTE                      lpBase;
    PIMAGE_DOS_HEADER           dosHeader;
    PIMAGE_NT_HEADERS           pNTHeader;
    PIMAGE_SECTION_HEADER       pSection;
    PIMAGE_SECTION_HEADER       pEData = NULL;
    PIMAGE_EXPORT_DIRECTORY     pExport;
    LPBYTE                      lpMyBase;
    char                        lsDLLName[256];

    lpBase = (LPBYTE)pMBI->AllocationBase;

    lpMyBase = (LPBYTE)VirtualAlloc(NULL, pMBI->RegionSize, MEM_COMMIT, PAGE_READWRITE);
    if (!lpMyBase)
        return 0;

    if (ReadProcessMemory(hProc, lpBase, lpMyBase, pMBI->RegionSize, NULL))
    {
        dosHeader = (PIMAGE_DOS_HEADER) lpMyBase;

        if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE)
        {
            pNTHeader = (PIMAGE_NT_HEADERS) (lpMyBase + dosHeader->e_lfanew);
            if (!IsBadReadPtr(pNTHeader, sizeof(IMAGE_NT_HEADERS)) && (pNTHeader->Signature == IMAGE_NT_SIGNATURE))
            {
                UINT        liI;

                /* Are we at the right base? */
                if (pNTHeader->OptionalHeader.ImageBase != (ULONG_PTR) lpBase)
                    iRet = 2;
                else
                    iRet = 1;

                lstrcatA(lpText, "\t");
                pSection = IMAGE_FIRST_SECTION(pNTHeader);
                for (liI = 0; liI < pNTHeader->FileHeader.NumberOfSections; liI++)
                {
                    if (    lstrlenA((char *)pSection->Name) == 6
                        &&  !lstrcmpA(".edata", (char *)pSection->Name))
                        pEData = pSection;

                    if ((lpBase + pSection->VirtualAddress) == pMBI->BaseAddress)
                    {
                        char        lsTemp[16];

                        wsprintfA(lsTemp, "%-8.8s", pSection->Name);
                        lstrcatA(lpText, lsTemp);
                    }

                    pSection++;
                }


                /* Is this a DLL? */
                if (pEData)
                {

                    pExport = (PIMAGE_EXPORT_DIRECTORY)
                        VirtualAlloc(NULL,
                            sizeof(IMAGE_EXPORT_DIRECTORY),
                            MEM_COMMIT, PAGE_READWRITE);

                    if (pExport != NULL)
                    {
                        ReadProcessMemory(hProc,
                            (lpBase + pEData->VirtualAddress),
                            pExport,
                            sizeof(IMAGE_EXPORT_DIRECTORY),
                            NULL);

                        ReadProcessMemory(hProc,
                            (lpBase + pExport->Name),
                            lsDLLName,
                            256,
                            NULL);

                        lstrcatA(lpText, "\t");
                        lstrcatA(lpText, lsDLLName);

                        if (iRet == 2)
                        {
                            wsprintfA(lsDLLName, "\t(%08lX)", pNTHeader->OptionalHeader.ImageBase);
                            lstrcatA(lpText, lsDLLName);
                        }

                        VirtualFree(pExport, 0, MEM_RELEASE);
                    }

                }



            }

        }
    }

    VirtualFree(lpMyBase, 0, MEM_RELEASE);

    return iRet;
}


void    SetTheColour(LPDRAWITEMSTRUCT lpdis, PMEMORY_BASIC_INFORMATION pMBI, LPSTR  lpText)
{
    UINT        iHeapType;

    if (pMBI->State == MEM_FREE)
    {
        SetTextColor(lpdis->hDC, GetSysColor(COLOR_BTNFACE));
        return;
    }

    if (pMBI->State == MEM_RESERVE)
    {
        PMEMORY_BASIC_INFORMATION   pNext = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lpdis->hwndItem, lpdis->itemID + 1);
        if ((((ULONG_PTR)pNext) != (ULONG_PTR)(-1)) && (pNext->Protect & PAGE_GUARD))
        {
            SetTextColor(lpdis->hDC, RGB(0, 0, 128));   // Stack
            return;
        }
    }

    if (pMBI->State == MEM_COMMIT)
    {
        UINT        iIsApp;

        if (pMBI->Protect & PAGE_GUARD)
        {
            SetTextColor(lpdis->hDC, RGB(0, 0, 128));   // Stack
            return;
        }
        else
        {
            PMEMORY_BASIC_INFORMATION   pPrev = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lpdis->hwndItem, lpdis->itemID - 1);
            if (pPrev->Protect & PAGE_GUARD)
            {
                SetTextColor(lpdis->hDC, RGB(0, 0, 128));   // Stack
                return;
            }
        }

        iIsApp = IsAppBasedOk(pMBI, lpText, hProcess);

        if (iIsApp == 1)
        {
            SetTextColor(lpdis->hDC, RGB(0, 128, 0));   // Image
            return;
        }
        else if (iIsApp == 2)
        {
            SetTextColor(lpdis->hDC, RGB(255, 0, 0));   // Image based badly
            return;
        }
    }

    iHeapType = IsGlobalLocalHeap(pMBI->AllocationBase);
    if (iHeapType == 1)
    {
        SetTextColor(lpdis->hDC, RGB(255, 0, 255)); // Our Heaps - Magenta
        return;
    }
    else if (iHeapType == 2)
    {
        SetTextColor(lpdis->hDC, RGB(0, 255, 255)); // Our Debug Heaps - Cyan
        return;
    }


    SetTextColor(lpdis->hDC, GetSysColor(COLOR_BTNTEXT));
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawEntireItem(LPDRAWITEMSTRUCT, int)                      *
 *                                                                          *
 ****************************************************************************/
VOID APIENTRY DrawEntireItem(
        LPDRAWITEMSTRUCT        lpdis,
        INT                     inflate)
{
    char     szLine[300];
    COLORREF crText = 0, crBack = 0;

    /* Draw line here */
    if (lpdis->itemState & ODS_SELECTED)
    {
        // Select the appropriate text colors
        crText = SetTextColor(lpdis->hDC, rgbHiliteText);
        crBack = SetBkColor(lpdis->hDC, rgbHiliteColor);
    }
    memset(szLine, ' ', sizeof(szLine) - 1);
    TextOutA(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, szLine, sizeof(szLine));

    if (lpdis->itemState & ODS_SELECTED)
    {
        SetTextColor(lpdis->hDC, crText);
        SetBkColor(lpdis->hDC,   crBack);
    }

    ConstructMemInfoLine((PMEMORY_BASIC_INFORMATION) lpdis->itemData, szLine);

    SetTheColour(lpdis, (PMEMORY_BASIC_INFORMATION) lpdis->itemData, szLine);
    if (lpdis->itemState & ODS_SELECTED)
    {
        // Select the appropriate text colors
        crText = SetTextColor(lpdis->hDC, rgbHiliteText);
        crBack = SetBkColor(lpdis->hDC, rgbHiliteColor);
    }

    TabbedTextOutA(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, szLine, lstrlenA(szLine), COLS, tabs, 0);

    // Restore original colors if we changed them above.
    if (lpdis->itemState & ODS_SELECTED)
    {
        SetTextColor(lpdis->hDC, crText);
        SetBkColor(lpdis->hDC,   crBack);
    }
}


LPSTR       ReverseString(LPSTR  lpcString)
{
    LPSTR   lpcEnd = lpcString + lstrlenA(lpcString) / 2;
    LPSTR   lpcStart;
    char    lcChar;

    lpcStart = lpcEnd - !(lstrlenA(lpcString) % 2);

    while (*lpcEnd)
    {
        lcChar = *lpcStart;
        *lpcStart = *lpcEnd;
        *lpcEnd = lcChar;

        lpcStart--;
        lpcEnd++;
    }

    return(lpcString);
}


LPSTR       DoCommas(DWORD      dwVal)
{
    static  char    szTemp[20];
    UINT            iDigitCount = 0;
    UINT            iCharCount = 0;

    while (dwVal)
    {
        szTemp[iCharCount++] = (char) ((dwVal % 10) + '0');
        iDigitCount++;
        dwVal /= 10;
        if (dwVal && ((iDigitCount % 3) == 0))
            szTemp[iCharCount++] = ',';
    }

    szTemp[iCharCount] = '\0';
    return ReverseString(szTemp);
}


void            RemoveTabs(LPSTR lpcTabbed, LPSTR lpcNoTab)
{
    UINT        iTabs = 0;
    UINT        iCharsSinceLast = 0;

    while (*lpcTabbed)
    {
        if (*lpcTabbed == '\t')
        {
            UINT        iCharsToTab = (cols[iTabs] / 4);

            if (iCharsToTab > iCharsSinceLast)
                iCharsToTab -= iCharsSinceLast;
            else
                iCharsToTab = 1;

            while (iCharsToTab--)
                *lpcNoTab++ = ' ';

            iTabs++;
            iCharsSinceLast = 0;
        }
        else
        {
            *lpcNoTab++ = *lpcTabbed;
            iCharsSinceLast++;
        }

        lpcTabbed++;
    }
    *lpcNoTab = '\0';
}

void    WINAPI  DumpMemoryList(HWND phList)
{
    OFSTRUCT        ofFile;
    char            szMemLine[300];
    char            szMemLineNoTabs[350];
    HFILE           lhFile;
    UINT            liLines = ListBox_GetCount(phList);
    UINT            liI;
    DWORD_PTR       itemData;

    lhFile = OpenFile("c:\\virtual.dmp", &ofFile, OF_CREATE);

    AssertSz(lhFile != NULL, "Failed to open file.");
    if (lhFile != NULL)
    {
        for (liI = 0; liI < liLines; liI++)
        {
            itemData = ListBox_GetItemData(phList, liI);

            ConstructMemInfoLine((PMEMORY_BASIC_INFORMATION) itemData, szMemLine);
            IsAppBasedOk((PMEMORY_BASIC_INFORMATION) itemData, szMemLine, hProcess);

            RemoveTabs(szMemLine, szMemLineNoTabs);

            _lwrite((HFILE) lhFile, szMemLineNoTabs, lstrlenA(szMemLineNoTabs));
            _lwrite((HFILE) lhFile, "\r\n", 2);
        }

        _lclose(lhFile);
    }
}


BOOL    WINAPI MemBrowseProc(HWND phDlg, UINT puMessage, WPARAM pwParam, LPARAM plParam)
{
    static DWORD    dwProcessID;

    switch (puMessage)
    {

        case WM_INITDIALOG:
            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                                    TRUE, plParam);

            SetWindowTitle(phDlg, "Virtual Memory Viewer - %s");
            SendMessageA(phDlg, WM_COMMAND, GET_WM_COMMAND_MPS(0, 0, ID_REFRESH));
            break;

        case WM_DRAWITEM:
            {
                LPDRAWITEMSTRUCT    lpdis;

                /* Get pointer to the DRAWITEMSTRUCT */
                lpdis = (LPDRAWITEMSTRUCT) plParam;

                if ((ODA_FOCUS & lpdis->itemAction) || (ODS_FOCUS & lpdis->itemState))
                    DrawFocusRect(lpdis->hDC, &lpdis->rcItem);
                else
                    DrawEntireItem(lpdis, -2);

                /* Return TRUE meaning that we processed this message. */
                return(TRUE);
            }
            break;

        case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT lpmis;
                lpmis = (LPMEASUREITEMSTRUCT) plParam;

                /* All the items are the same height since the list box style is
                 * LBS_OWNERDRAWFIXED
                 */
                lpmis->itemHeight = 16;
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(pwParam, plParam))
            {
                case ID_REFRESH:
                    {
                        ULONG ulTotalMem = 0, ulCodeMem = 0, ulDataMem = 0;
                        ULONG ulReserveMem = 0, ulReadOnly = 0, ulReadWrite = 0;

                        dwProcessID = plParam;

                        {
                           MEMORY_BASIC_INFORMATION     MemoryBasicInfo;
                           PMEMORY_BASIC_INFORMATION    lpMem;
                           PVOID lpAddress = 0;
                           char szLine[200];
                           int          cols[COLS] = {70, 13, 70, 11, 11, 11, 11, 65, 11, 11, 11, 11, 11, 65, 80, 92};
                           HWND         lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);
                           UINT         i, j, nCol = 0;

                            for (i = 0; i < COLS; i++)
                            {
                                tabs[i] = 5 + nCol + cols[i];
                                nCol += cols[i] + 5;
                            }

                            /* Free up the list memory */
                            i = ListBox_GetCount(lhList);
                            for (j = 0; j < i; j++)
                            {
                                lpMem = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, j);
                                LocalFree(lpMem);
                            }

                            ListBox_ResetContent(lhList);

                            ListBox_SetTabStops(lhList, 6, &tabs);

                           // Walk the virtual address space, adding
                           // entries to the list box.

                           do {
                              int x = VirtualQueryEx(hProcess, lpAddress, &MemoryBasicInfo,
                                 sizeof(MemoryBasicInfo));

                              if (x != sizeof(MemoryBasicInfo)) {
                                 // Attempt to walk beyond the range
                                 // that Windows NT allows.
                                 break;
                              }

                              szLine[0] = '\0';
                              lpMem = (PMEMORY_BASIC_INFORMATION)LocalAlloc(LMEM_FIXED, sizeof(MEMORY_BASIC_INFORMATION));
                              if (lpMem == NULL)
                              {
                                  AssertSz (0, "Insufficient memory for debugging.");
                                  continue;
                              }

                              *lpMem = MemoryBasicInfo;

                              // Construct the line to be displayed, and
                              // add it to the list box.

                              if (MemoryBasicInfo.State != MEM_FREE)
                              {
                                  if (MemoryBasicInfo.State == MEM_RESERVE)
                                      ulReserveMem += (ULONG)MemoryBasicInfo.RegionSize;
                                  else
                                  {
                                      if (IsAppBasedOk(lpMem, szLine, hProcess))
                                          ulCodeMem += (ULONG)MemoryBasicInfo.RegionSize;
                                      else
                                          ulDataMem += (ULONG)MemoryBasicInfo.RegionSize;

                                      ulTotalMem += (ULONG)MemoryBasicInfo.RegionSize;
                                  }

                                  if (MemoryBasicInfo.Protect & (PAGE_READONLY | PAGE_EXECUTE_READ))
                                      ulReadOnly += (ULONG)MemoryBasicInfo.RegionSize;
                                  else
                                      if (MemoryBasicInfo.Protect & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY))
                                          ulReadWrite += (ULONG)MemoryBasicInfo.RegionSize;
                              }

                              ListBox_AddString(lhList, (ULONG_PTR)lpMem);

                              // Get the address of the next region to test.
                              lpAddress = ((BYTE *) MemoryBasicInfo.BaseAddress) +
                                 MemoryBasicInfo.RegionSize;

                           } while (MemoryBasicInfo.RegionSize >= (4 * 1024));

                           wsprintfA(szLine, "%s", DoCommas(ulTotalMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_TOTALMEM), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulCodeMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_CODEMEM), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulDataMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_DATAMEM), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulReserveMem));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_RESERVEMEM), szLine);

                           wsprintfA(szLine, "%s", DoCommas(ulReadOnly));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_READONLY), szLine);
                           wsprintfA(szLine, "%s", DoCommas(ulReadWrite));
                           SetWindowTextA(GetDlgItem(phDlg, IDC_READWRITE), szLine);
                        }
                    }
                    break;

                case ID_ADD:
                    {
                        int     liItemList[700];
                        HWND    lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);
                        int     liItems = ListBox_GetSelCount(lhList);
                        int     liI;
                        ULONG   ulSize = 0;
                        char    szText[150];

                        if (liItems)
                        {
                            ListBox_GetSelItems(lhList, liItems < 700 ? liItems : 700, liItemList);

                            for (liI = 0; liI < (liItems < 700 ? liItems : 700); liI++)
                            {
                                PMEMORY_BASIC_INFORMATION   pInfo;

                                pInfo = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, liItemList[liI]);
                                ulSize += (ULONG)pInfo->RegionSize;
                            }

                            wsprintfA(szText, "%ld (%08lX) bytes", ulSize, ulSize);
                            MessageBoxA(phDlg, szText, "Add Memory", MB_OK);
                        }
                    }
                    break;

                case ID_VIEW:
                    {
                        int     liItemList[1];
                        HWND    lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);
                        int     liItems = ListBox_GetSelCount(lhList);

                        if (liItems && (liItems == 1))
                        {
                            PMEMORY_BASIC_INFORMATION   pInfo;
                            ListBox_GetSelItems(lhList, 1, liItemList);

                            pInfo = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, liItemList[0]);

                            if (pInfo->State == MEM_COMMIT)
                            {
                                PDBGAH  pdbgahCopy;
                                ULONG   cb;

                                /* Construct a 4K pseudo Local block to pass to memory viewer */
                                cb = ActualSizeFromRequestSize(4000, FALSE);
                                pdbgahCopy = (PDBGAH) LocalAlloc(LPTR, cb);

                                if (pdbgahCopy != NULL)
                                {
                                    memset(pdbgahCopy, 0, cb);
                                    lstrcpyA(pdbgahCopy->szName, "Virtual Page");
                                    pdbgahCopy->cbRequest = 4000;

                                    ReadProcessMemory(hProcess,
                                        pInfo->BaseAddress,
                                        RequestFromActual(pdbgahCopy),
                                        4000,
                                        NULL);

                                    ViewBlock(phDlg, pdbgahCopy);
                                    LocalFree(pdbgahCopy);
                                }
                                else
                                    AssertSz(0, "Insufficient memory to debug.");
                            }
                            else
                                MessageBoxA(phDlg, "Only commited memory may be viewed", "View Memory", MB_OK);
                        }
                        else
                            MessageBoxA(phDlg, "Only one memory block may be viewed at a time", "View Memory", MB_OK);

                    }
                    break;

                case ID_DUMP:
                    DumpMemoryList(GetDlgItem(phDlg, IDC_TRACE_LIST));
                    MessageBoxA(phDlg, "Virtual Memory list dumped to 'C:\\VIRTUAL.DMP'", "Dump Memory", MB_OK);
                    break;

                case IDOK:
                case IDCANCEL:
                {
                    PMEMORY_BASIC_INFORMATION   lpMem;
                    UINT                        i, j;
                    HWND                        lhList = GetDlgItem(phDlg, IDC_TRACE_LIST);

                    /* Free up the list memory */
                    i = ListBox_GetCount(lhList);
                    for (j = 0; j < i; j++)
                    {
                        lpMem = (PMEMORY_BASIC_INFORMATION) ListBox_GetItemData(lhList, j);
                        LocalFree(lpMem);
                    }

                    EndDialog(phDlg, 0);
                    break;
                }
            }
            break;

        default: return FALSE; break;
    }
    return TRUE;
}


void WINAPI DoMemoryBrowse(HINSTANCE phInst, HWND phWnd, DWORD dwProcess)
{
    static BOOL     fInDialog = FALSE;

    if (!fInDialog)
    {
        fInDialog = TRUE;
        SetRGBValues();
        DialogBoxParamA(phInst, MAKEINTRESOURCEA(BROWSE_DLG), phWnd, (DLGPROC) MemBrowseProc, dwProcess);
        fInDialog = FALSE;
    }
}


DWORD   WINAPI  DoBrowseThread(LPVOID lpParam)
{
    Sleep(2000);
    DoMemoryBrowse(NULL, NULL, GetCurrentProcessId());
    return 0;
}


void        GetMemStats(LPSTR   lpcLine, HANDLE hProc)
{
    ULONG                       ulTotalMem = 0, ulCodeMem = 0, ulDataMem = 0;
    ULONG                       ulReserveMem = 0;
    MEMORY_BASIC_INFORMATION    MemoryBasicInfo;
    PVOID                       lpAddress = 0;
    char                        szTemp[250];

    // Walk the virtual address space, adding
    // entries to the list box.

    do
    {

        int x = VirtualQueryEx(hProc, lpAddress, &MemoryBasicInfo,
             sizeof(MemoryBasicInfo));

        szTemp[0] = '\0';
        if (x != sizeof(MemoryBasicInfo))
        {
             // Attempt to walk beyond the range
             // that Windows NT allows.
             break;
        }

        // Construct the line to be displayed, and
        // add it to the list box.

        if (MemoryBasicInfo.State != MEM_FREE)
        {
            if (MemoryBasicInfo.State == MEM_RESERVE)
                ulReserveMem += (ULONG)MemoryBasicInfo.RegionSize;
            else
            {
                if (IsAppBasedOk(&MemoryBasicInfo, szTemp, hProc))
                    ulCodeMem += (ULONG)MemoryBasicInfo.RegionSize;
                else
                    ulDataMem += (ULONG)MemoryBasicInfo.RegionSize;

                ulTotalMem += (ULONG)MemoryBasicInfo.RegionSize;
            }
        }

        // Get the address of the next region to test.
        lpAddress = ((BYTE *) MemoryBasicInfo.BaseAddress) +
             MemoryBasicInfo.RegionSize;

    } while (lpAddress != 0);

    wsprintfA(lpcLine, "%lu, %lu, %lu, %lu", ulTotalMem, ulCodeMem, ulDataMem, ulReserveMem);
}

#pragma warning(disable:4702)   //  Unreachable code below
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD   WINAPI  DoMemStats(LPVOID lpParam)
{
    char        szLogFile[256];
    OFSTRUCT        ofFile;
    char            szMemLine[300];
    HFILE           lhFile;
    HANDLE          lhHFile;
    HANDLE      hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                                    TRUE, GetCurrentProcessId());


    wsprintfA(szLogFile, "c:\\%08lX.MEM", GetCurrentProcessId());

    lhFile = OpenFile(szLogFile, &ofFile, OF_CREATE);
    AssertSz(lhFile != NULL, "Failed to open log file.");
    _lwrite(lhFile, "Total,Code,Data,Reserve\r\n", 25);
    _lclose(lhFile);

    for (;;)
    {
        GetMemStats(szMemLine, hProc);

        lhHFile = CreateFileA(szLogFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
        AssertSz(lhHFile != NULL, "Failed to open log file.");
        SetFilePointer(lhHFile, 0, NULL, FILE_END);
        _lwrite((HFILE) (DWORD_PTR)lhHFile, szMemLine, lstrlenA(szMemLine));
        _lwrite((HFILE) (DWORD_PTR)lhHFile, "\r\n", 2);

        CloseHandle(lhHFile);
        Sleep(10000);       // 10 second pause
    }
    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

#pragma warning(default:4702)   // re-enable

// ----------------------------------------------------------------------------

void __cdecl hprintf(HANDLE hfile, char * pchFmt, ...)
{
    char    ach[2048];
    UINT    cb;
    DWORD   dw;
    va_list vl;

    va_start(vl, pchFmt);
    cb = wvsprintfA(ach, pchFmt, vl);
    va_end(vl);

    WriteFile(hfile, ach, cb, &dw, NULL);
}

void  WINAPI
DbgExDumpProcessHeaps()
{
    HANDLE hfile;
    HANDLE ah[256];
    DWORD i, cHeaps, dwBusyTotal = 0, dwFreeTotal = 0;

#ifdef UNIX
    CHAR szHeapDumpFile[] = "heapdump.txt";
#else
    CHAR szHeapDumpFile[] = "\\heapdump.txt";
#endif

    cHeaps = GetProcessHeaps(ARRAY_SIZE(ah), ah);

    hfile = CreateFileA(szHeapDumpFile, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        return;

    for (i = 0; i < cHeaps; ++i)
    {
        PROCESS_HEAP_ENTRY he;
        DWORD dwFree = 0, dwBusy = 0;

        memset(&he, 0, sizeof(he));

        hprintf(hfile, "+++ Heap %08lX %s\r\n\r\n", ah[i],
            ah[i] == GetProcessHeap() ? "(Process Heap)" : "");

        while (HeapWalk(ah[i], &he))
        {
            if (he.wFlags & PROCESS_HEAP_REGION)
            {
                hprintf(hfile, "R %08lX [%ld] (cb=%ld+%ld, c/r=%ld/%ld, "
                    "f/l=%08lX/%08lX)\r\n", he.lpData, he.iRegionIndex,
                    he.cbData, he.cbOverhead, he.Region.dwCommittedSize,
                    he.Region.dwUnCommittedSize, he.Region.lpFirstBlock,
                    he.Region.lpLastBlock);
            }
            else if (he.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE)
            {
                hprintf(hfile, "U %08lX [%ld] (cb=%ld+%ld)\r\n",
                    he.lpData, he.iRegionIndex, he.cbData, he.cbOverhead);
            }
            else
            {
                hprintf(hfile, "%c %08lX %6ld (+%ld) [%ld]",
                    (he.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) ? 'M' :
                    (he.wFlags & PROCESS_HEAP_ENTRY_DDESHARE) ? 'S' :
                    (he.wFlags & PROCESS_HEAP_ENTRY_BUSY) ? ' ' : 'F',
                    he.lpData, he.cbData, he.cbOverhead, he.iRegionIndex);

                if (he.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE)
                    hprintf(hfile, " (hMem=%08lX)", he.Block.hMem);

                if (he.wFlags & PROCESS_HEAP_ENTRY_BUSY)
                    dwBusy += he.cbData;
                else
                    dwFree += he.cbData;

                hprintf(hfile, "\r\n");
            }
        }

        hprintf(hfile, "\r\nTotal of %ld bytes allocated (%ld free)\r\n\r\n",
            dwBusy, dwFree);

        dwBusyTotal += dwBusy;
        dwFreeTotal += dwFree;
    }

    hprintf(hfile, "Grand total of %ld bytes allocated (%ld free)\r\n",
        dwBusyTotal, dwFreeTotal);

    CloseHandle(hfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\ffail.cxx ===
//+---------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//  
//  File:       ffail.cxx
//  
//  Contents:   Debug functions that you don't want to step into in
//              the debugger.  This module is compiled without the /Zi flag.
//  
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

BOOL g_fJustFailed;

//+---------------------------------------------------------------------------
//  
//  Function:   DbgExFFail
//  
//  Synopsis:   Fails if count of fails is positive and evenly divides
//              interval count.
//  
//----------------------------------------------------------------------------


BOOL WINAPI
DbgExFFail()
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    // NOTE (garybu) Fail count should be per thread. Turn off crit sect for speed.
    // LOCK_GLOBALS;

    g_fJustFailed = (++g_cFFailCalled < 0) ? FALSE : ! (g_cFFailCalled % g_cInterval);
    return g_fJustFailed;
}



//+---------------------------------------------------------------------------
//  
//  Function:   JustFailed
//  
//  Synopsis:   Returns result of last call to FFail
//  
//----------------------------------------------------------------------------

BOOL
JustFailed()
{
    return g_fJustFailed;
}



//+------------------------------------------------------------------------
//  
//  Function:   DbgExGetFailCount
//  
//  Synopsis:   Returns the number of failure points that have been
//              passed since the last failure count reset
//  
//  Returns:    int
//  
//-------------------------------------------------------------------------

int WINAPI
DbgExGetFailCount()
{
    // NOTE (garybu) Fail count should be per thread. Turn off crit sect for speed.
    // LOCK_GLOBALS;

    Assert(g_firstFailure >= 0);
    return g_cFFailCalled + ((g_firstFailure != 0) ? g_firstFailure : INT_MIN);
}

// used for assert to fool the compiler

DWORD g_dwFALSE = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\debugui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:       debugui.cxx
//
//  Contents:   User interface for trace tags dialog
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

// private typedefs
typedef int TMC;

// private function prototypes
VOID    EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty);
WORD    TagFromSelection(HWND hwndDlg, TMC tmc);
BOOL    CALLBACK DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam);

//  Debug UI Globals
//
void    SetRGBValues(void);

extern DWORD       rgbWindowColor;
extern DWORD       rgbHiliteColor;
extern DWORD       rgbWindowText;
extern DWORD       rgbHiliteText;
extern DWORD       rgbGrayText;
extern DWORD       rgbDDWindow;
extern DWORD       rgbDDHilite;

HBITMAP g_hbmpCheck = NULL;
HDC     g_hdcCheck  = NULL;

#define TAG_STRBUF_SIZE  80

//
//  Identifies the type of TAG with which the current modal dialog is
//  dealing.
//

//+-------------------------------------------------------------------------
//
//  Function:   TraceTagDlgThread
//
//  Synopsis:   Thread entry point for trace tag dialog.  Keeps caller
//              of DbgExDoTracePointsDialog from blocking.
//
//--------------------------------------------------------------------------

DWORD
TraceTagDlgThread(void * pv)
{
    int     r;

    EnsureThreadState();

    r = DialogBoxA(g_hinstMain, "TRCAST", NULL, (DLGPROC)DlgTraceEtc);
    if (r == -1)
    {
        MessageBoxA(NULL, "Couldn't create trace tag dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD) r;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgExDoTracePointsDialog
//
//  Synopsis:   Brings up and processes trace points dialog.  Any changes
//              made by the user are copied to the current debug state.
//
//  Arguments:  [fWait] -- If TRUE, this function will not return until the
//                         dialog has been closed.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExDoTracePointsDialog( BOOL fWait )
{
    THREAD_HANDLE          hThread = NULL;
#ifndef _MAC
    DWORD           idThread;
#endif

    EnsureThreadState();

    if (fWait)
    {
        TraceTagDlgThread(NULL);
    }
    else
    {
#ifndef _MAC
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TraceTagDlgThread, NULL, 0, &idThread);
#else
#pragma message("   DEBUGUI.cxx CreateThread")
Assert (0 && "  DEBUGUI.cxx CreateThread");
#endif
        if (hThread == NULL)
        {
            MessageBoxA(NULL,
                       "Couldn't create trace tag dialog thread",
                       "Error",
                       MB_OK | MB_ICONSTOP);
        }
#ifndef _MAC
        else
        {
            CloseThread(hThread);
        }
#endif
    }
}


/*
 *    FFillDebugListbox
 *
 *    Purpose:
 *        Initializes Windows debug listboxes by adding the correct strings
 *        to the listbox for the current dialog type.  This is only called
 *        once in the Windows interface when the dialog is initialized.
 *
 *    Parameters:
 *        hwndDlg    Handle to parent dialog box.
 *
 *    Returns:
 *        TRUE    if function is successful, FALSE otherwise.
 */
BOOL CALLBACK
FFillDebugListbox(HWND hwndDlg)
{
    TRACETAG tag;
    LRESULT  lresult;
    TGRC *   ptgrc;
    HWND     hwndListbox;

    // Get the listbox handle
    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    // Make sure it's clean
    SendMessageA(hwndListbox, CB_RESETCONTENT, 0, 0);

    // Enter tags into the listbox
    for (tag = tagMin; tag < tagMac; tag++)
    {
        // If tag is of correct type, enter the string for it.
        if (mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc = mptagtgrc + tag;

            lresult = SendMessageA(hwndListbox, CB_ADDSTRING, 0, tag);

            if (lresult == CB_ERR || lresult == CB_ERRSPACE)
                return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TextFromTag
//
//  Synopsis:   Returns the string that should be displayed in the dialog
//              for a given tag.
//
//----------------------------------------------------------------------------

void
TextFromTag(TGRC *ptgrc, char *psz, int cch)
{
    _snprintf(psz, cch, "%-17.17s  %s", ptgrc->szOwner, ptgrc->szDescrip);
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawTraceItem
//
//  Synopsis:   Draws a list item in the combobox.
//
//----------------------------------------------------------------------------

VOID
DrawTraceItem(LPDRAWITEMSTRUCT pdis)
{
    TGRC *    ptgrc;
    COLORREF  crText = 0, crBack = 0;
    char      achBuf[TAG_STRBUF_SIZE];
    int       size;
    BOOL      fSelected = (pdis->itemState & ODS_SELECTED) != 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if (fSelected)
        {
            // Select the appropriate text colors
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        ptgrc = mptagtgrc + pdis->itemData;

        TextFromTag(ptgrc, achBuf, sizeof(achBuf));

        size = pdis->rcItem.bottom - pdis->rcItem.top - 1;

        ExtTextOutA(pdis->hDC,
                    pdis->rcItem.left + size,
                    pdis->rcItem.top+1,
                    ETO_OPAQUE|ETO_CLIPPED,
                    &pdis->rcItem,
                    achBuf,
                    lstrlenA(achBuf),
                    NULL);

        if (ptgrc->fEnabled)
        {
            BitBlt(pdis->hDC,
                   pdis->rcItem.left,
                   pdis->rcItem.top+1,
                   size,
                   size,
                   g_hdcCheck,
                   0,
                   0,
                   SRCCOPY);
        }

        // Restore original colors if we changed them above.
        if(fSelected)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}

//+---------------------------------------------------------------------------
//
//  Function:   CompareTraceItem
//
//  Synopsis:   Compare two items in the listbox for sorting.
//
//----------------------------------------------------------------------------

BOOL
CompareTraceItem(LPCOMPAREITEMSTRUCT pcis)
{
    int    retVal = 0;
    TGRC * ptgrc1 = NULL;
    TGRC * ptgrc2 = NULL;
    char * psz1, *psz2;
    char   achBuf[TAG_STRBUF_SIZE];
    int    cch = -1;

    if (pcis->itemID1 != -1)
    {
        Assert((TRACETAG)pcis->itemData1 > tagNull && (TRACETAG)pcis->itemData1 <= tagMac);

        ptgrc1 = mptagtgrc + pcis->itemData1;
        psz1   = ptgrc1->szOwner;
    }
    else
    {
        //
        // This is used when the user types into the textbox.
        //
        GetWindowTextA(pcis->hwndItem, achBuf, sizeof(achBuf));

        psz1 = achBuf;

        cch = lstrlenA(psz1);
    }

    if ((TRACETAG)pcis->itemData2 > tagNull && (TRACETAG)pcis->itemData2 <= tagMac)
    {
        ptgrc2 = mptagtgrc + pcis->itemData2;
        psz2   = ptgrc2->szOwner;
    }
    else
    {
        psz2 = ""; // Shouldn't get here - just don't crash if we do.
    }

    if (   ptgrc1
        && ptgrc2
        && ptgrc1->TestFlag(TGRC_FLAG_SORTFIRST) !=
           ptgrc2->TestFlag(TGRC_FLAG_SORTFIRST))
    {
        retVal = ptgrc1->TestFlag(TGRC_FLAG_SORTFIRST) ? -1 : 1;
    }
    else
    {
        retVal = CompareStringA(LOCALE_USER_DEFAULT,
                                NORM_IGNORECASE,
                                psz1, cch,
                                psz2, cch) - 2;

        if (retVal == 0 && ptgrc1 && ptgrc2)
        {
            retVal = CompareStringA(LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    ptgrc1->szDescrip, -1,
                                    ptgrc2->szDescrip, -1) - 2;

        }
    }

    return (BOOL)retVal;
}

/*
 *    FDlgTraceEtc
 *
 *    Purpose:
 *        Dialog procedure for Trace Points and Asserts dialogs.
 *        Keeps the state of the checkboxes identical to
 *        the state of the currently selected TAG in the listbox.
 *
 *    Parameters:
 *        hwndDlg    Handle to dialog window
 *        wm        SDM dialog message
 *        wparam
 *        lparam    Long parameter
 *
 *    Returns:
 *        TRUE if the function processed this message, FALSE if not.
 */
BOOL CALLBACK
DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam)
{
    DBGTHREADSTATE *   pts = DbgGetThreadState();
    TRACETAG        tag;
    TGRC *          ptgrc;
    DWORD           wNew;
    BOOL            fEnable;        // enable all
    TGRC_FLAG       tf;
    BOOL            fTrace;
    HWND            hwndListBox;
    BOOL            fInvalidate = FALSE;

    switch (wm)
    {
    default:
        return FALSE;
        break;

    case WM_INITDIALOG:
        pts->fDirtyDlg = FALSE;

        if (!FFillDebugListbox(hwndDlg))
        {
            MessageBoxA(hwndDlg,
                "Error initializing listbox. Cannot display dialog.",
                "Trace/Assert Dialog", MB_OK);
            EndButton(hwndDlg, 0, FALSE);
            break;
        }

        hwndListBox = GetDlgItem(hwndDlg, tmcListbox);
        Assert(hwndListBox);
        SetRGBValues();
        SendMessageA(hwndListBox, CB_SETCURSEL, 0, 0);
        SendMessageA(
                hwndDlg,
                WM_COMMAND,
                GET_WM_COMMAND_MPS(tmcListbox, hwndListBox, CBN_SELCHANGE));


        SetForegroundWindow(hwndDlg);

        if (!g_hdcCheck)
        {
            HDC hdc = GetDC(NULL);
            g_hdcCheck = CreateCompatibleDC(hdc);
            ReleaseDC(NULL, hdc);
        }

        if (!g_hbmpCheck)
        {
            Assert(g_hdcCheck);

            g_hbmpCheck = (HBITMAP)LoadImageA(NULL,
                                              (LPCSTR)OBM_CHECK,
                                              IMAGE_BITMAP,
                                              0, 0,
                                              LR_LOADTRANSPARENT);

            SelectObject(g_hdcCheck, g_hbmpCheck);
        }

        break;

    case WM_SYSCOLORCHANGE:
        SetRGBValues();
        InvalidateRect(hwndDlg, NULL, FALSE);
        break;

    case WM_DRAWITEM:
        if (GET_WM_COMMAND_ID(wparam, lparam) == tmcListbox)
        {
            DrawTraceItem((DRAWITEMSTRUCT*)lparam);
        }
        return TRUE;

    case WM_COMPAREITEM:
        if (GET_WM_COMMAND_ID(wparam, lparam) == tmcListbox)
        {
            return CompareTraceItem((COMPAREITEMSTRUCT*)lparam);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wparam, lparam))
        {
        case tmcOk:
        case tmcCancel:
            EndButton(hwndDlg, GET_WM_COMMAND_ID(wparam, lparam), pts->fDirtyDlg);
            break;

        case tmcEnableAll:
        case tmcDisableAll:
            pts->fDirtyDlg = TRUE;

            fEnable = FALSE;
            if (GET_WM_COMMAND_ID(wparam, lparam) == tmcEnableAll)
                fEnable = TRUE;

            for (tag = tagMin; tag < tagMac; tag++)
            {
                    mptagtgrc[tag].fEnabled = fEnable;
            }

            tag = TagFromSelection(hwndDlg, tmcListbox);

            CheckDlgButton(hwndDlg, tmcEnabled, fEnable);

            fInvalidate = TRUE;

            break;

        case tmcListbox:
            // Need to check for CBN_EDITCHANGE also, because this seems to cause
            // the selection in listbox to change - especially when it is made empty.
            if (GET_WM_COMMAND_CMD(wparam, lparam) == CBN_EDITCHANGE)
            {
                // Post the message because the selection change seems to be delayed
                PostMessageA(
                    hwndDlg,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(tmcListbox,
                            GetDlgItem(hwndDlg, tmcListbox),
                            CBN_SELCHANGE));
                break;
            }

            if (GET_WM_COMMAND_CMD(wparam, lparam) != CBN_SELCHANGE
                && GET_WM_COMMAND_CMD(wparam, lparam) != CBN_DBLCLK)
                break;

            tag = TagFromSelection(hwndDlg, tmcListbox);

            if (tag == tagNull) // possible if the editbox is empty
            {
                // disable all checkboxes
                EnableWindow(GetDlgItem(hwndDlg, tmcEnabled),  FALSE);
                EnableWindow(GetDlgItem(hwndDlg, tmcDisk),  FALSE);
                EnableWindow(GetDlgItem(hwndDlg, tmcBreak), FALSE);
                break;
            }

            // re-enable it always just in case we disabled it previously
            EnableWindow(GetDlgItem(hwndDlg, tmcEnabled),  TRUE);

            ptgrc = mptagtgrc + tag;

            {
                char achBuf[TAG_STRBUF_SIZE];

                TextFromTag(ptgrc, achBuf, sizeof(achBuf));

                SetWindowTextA(GetDlgItem(hwndDlg, tmcListbox), achBuf);
            }

            if (GET_WM_COMMAND_CMD(wparam, lparam) == CBN_DBLCLK)
            {
                ptgrc->fEnabled = !ptgrc->fEnabled;
                pts->fDirtyDlg = TRUE;
                fInvalidate = TRUE;
            }

            CheckDlgButton(hwndDlg, tmcEnabled, ptgrc->fEnabled);
            CheckDlgButton(hwndDlg, tmcDisk, ptgrc->TestFlag(TGRC_FLAG_DISK));
            CheckDlgButton(hwndDlg, tmcBreak, ptgrc->TestFlag(TGRC_FLAG_BREAK));
            fTrace = (ptgrc->tgty == tgtyTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcDisk),  fTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcBreak), fTrace);
            break;

        case tmcEnabled:
        case tmcDisk:
        case tmcBreak:
            pts->fDirtyDlg = TRUE;
            fInvalidate = TRUE;

            tag = TagFromSelection(hwndDlg, tmcListbox);
            ptgrc = mptagtgrc + tag;

            wNew = IsDlgButtonChecked(hwndDlg, GET_WM_COMMAND_ID(wparam, lparam));

            if (GET_WM_COMMAND_ID(wparam, lparam) == tmcEnabled)
            {
                ptgrc->fEnabled = wNew;
            }
            else
            {
                switch (GET_WM_COMMAND_ID(wparam, lparam))
                {
            case tmcDisk:
                    tf = TGRC_FLAG_DISK;
                break;

                case tmcBreak:
                    tf = TGRC_FLAG_BREAK;
                    break;

                default:
                    Assert(0 && "Logic error in DlgTraceEtc");
                    tf = (TGRC_FLAG) 0;
                break;
                }

                ptgrc->SetFlagValue(tf, wNew);
            }
        }

        if (fInvalidate)
        {
            InvalidateRect(GetDlgItem(hwndDlg, tmcListbox), NULL, FALSE);
        }

        break;
    }

    return TRUE;
}


/*
 *    EndButton
 *
 *    Purpose:
 *        Does necessary processing when either OK or Cancel is pressed in
 *        any of the debug dialogs.  If OK is pressed, the debug state is
 *        saved if dirty.  If Cancel is hit, the debug state is restored if
 *        dirty.
 *
 *    In Windows, the EndDialog function must also be called.
 *
 *    Parameters:
 *        tmc        tmc of the button pressed, either tmcOk or tmcCancel.
 *        fDirty    indicates if the debug state has been modified.
 */
void
EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty)
{
    if (fDirty)
    {
        if (tmc == tmcOk)
            SaveDefaultDebugState();
        else
            DbgExRestoreDefaultDebugState();
    }

    DeleteDC(g_hdcCheck);
    DeleteObject(g_hbmpCheck);

    g_hdcCheck = NULL;
    g_hbmpCheck = NULL;

    EndDialog(hwndDlg, tmc == tmcOk);

    return;
}


/*
 *    TagFromSelection
 *
 *    Purpose:
 *        Isolation function for dialog procedures to eliminate a bunch of
 *         ifdef's everytime the index of the selection in the current listbox
 *        is requried.
 *
 *     Parameters:
 *        tmc        ID value of the listbox.
 *
 *     Returns:
 *        ctag for the currently selected listbox item.
 */

WORD
TagFromSelection(HWND hwndDlg, TMC tmc)
{
    HWND    hwndListbox;
    LRESULT lresult;

    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    lresult = SendMessageA(hwndListbox, CB_GETCURSEL, 0, 0);

    // the selection can be -ve if the editbox is empty !
    if (lresult == CB_ERR)
        return tagNull;

    Assert(lresult >= 0);
    lresult = SendMessageA(hwndListbox, CB_GETITEMDATA, lresult, 0);
    Assert(tagMin <= lresult && lresult < tagMac);
    return (WORD) lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\assertui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       assertui.cxx
//
//  Contents:   Assert Dialog implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------------------
//
// MYDLGTEMPLATE, MYDLGITEMTEMPLATE
//
// Structures containing additional necessary information for the dialog
// template
//
//----------------------------------------------------------------------------

#include "pshpack2.h" // It provides the pack(2) feature.

struct MYDLGTEMPLATE : DLGTEMPLATE
{
    WCHAR wMenu;       // Must be 0
    WCHAR wClass;      // Must be 0
    WCHAR achTitle[2]; // Must be DWORD aligned
};

struct MYDLGITEMTEMPLATE : DLGITEMTEMPLATE
{
    WCHAR wClassLen;   // Must be -1
    WCHAR wClassType;
    WCHAR achInitText[2];
};

#include "poppack.h" // It provides the pack() feature.

//+---------------------------------------------------------------------------
//
//  DLGITEM_ID
//
//  IDs for all the controls in the dialog
//
//----------------------------------------------------------------------------

enum DLGITEM_ID
{
    DI_PROCESSNAME = 0,
    DI_PROCESSID,
    DI_FILE,
    DI_LINE,
    DI_MESSAGE,
    DI_IGNORE,
    DI_BREAK,
    DI_CLIPBOARD,
    DI_ICON,
    DI_STACKMSG,
    DI_MODULEBASE,
    DI_FUNCBASE   = DI_MODULEBASE + SHORT_SYM_COUNT,
    DI_MAX        = DI_FUNCBASE   + SHORT_SYM_COUNT
};

#define STYLE_STATICDEFAULT WS_VISIBLE | SS_LEFTNOWORDWRAP | SS_NOPREFIX | \
                            WS_CHILD


#define DLGITEM_STATIC 0x0082
#define DLGITEM_BUTTON 0x0080

void StringFromMBOT(MBOT *pmbot, char * pch, BOOL fShortSyms);

//+---------------------------------------------------------------------------
//
// Inline function that returns a DWORD aligned pointer to a MYDLGITEMTEMPLATE
// based on the end of the previous one. [pb] should be the achInitText
// pointer, with the string already set. If [fAddExtra] is TRUE, it accounts
// for the "creation data" element by skipping over it (it must already have
// been set to zero).
//
//----------------------------------------------------------------------------

inline MYDLGITEMTEMPLATE *
GetNextItem(BYTE * pb, BOOL fAddExtra = TRUE)
{
    pb = pb + ((wcslen((WCHAR*)pb) + 1) * sizeof(WCHAR)) + ((fAddExtra)
                                                               ? sizeof(WORD)
                                                               : 0);

    // The following DWORD aligns the returned pointer

    return (MYDLGITEMTEMPLATE *)(((ULONG_PTR)pb + 3) & ~(3));
}

//+---------------------------------------------------------------------------
//
// wsprintf function that always returns output in Unicode, even on Win95
//
//----------------------------------------------------------------------------
void __cdecl
my_wsprintf(WCHAR *pchBuf, CHAR *pchFmt, ...)
{
    extern BOOL g_fOSIsNT;

    va_list valMarker;

    va_start(valMarker, pchFmt);

    // wvsprintfW is not implemented on Win95 - blaugh!
    if (g_fOSIsNT)
    {
        WCHAR achFmt[100];

        wsprintfW(achFmt, _T("%hs"), pchFmt);

        wvsprintfW(pchBuf, achFmt, valMarker);
    }
    else
    {
        CHAR achBuf[1024];

        wvsprintfA(achBuf, pchFmt, valMarker);

        MultiByteToWideChar(CP_ACP, 0, achBuf, -1, pchBuf, 256);
    }

    va_end(valMarker);
}
//+---------------------------------------------------------------------------
//
//  Function:   DlgAssert
//
//  Synopsis:   DialogProc for the assert dialog
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgAssert(HWND hwndDlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        {
            EnsureThreadState();

            TLS(pmbot) = (MBOT *)lparam;

            HICON hIcon = LoadIconA(NULL, (LPSTR)IDI_EXCLAMATION);
            SendDlgItemMessageA(hwndDlg,
                                DI_ICON,
                                STM_SETICON,
                                (WPARAM)hIcon,
                                (LPARAM)0);

#if 0
            for (int i = DI_PROCESSNAME; i < DI_MESSAGE; i++)
            {
                SendDlgItemMessageA(hwndDlg,
                                    i,
                                    WM_SETFONT,
                                    (WPARAM)GetStockObject(SYSTEM_FIXED_FONT),
                                    (LPARAM)0);
            }
#endif

            // This call to PlaySound is too flaky to use - during DllMain
            // calls it fails to return and in general doesn't always work on
            // NT 4.0.
            // PlaySoundA("SystemExclamation", NULL, SND_ALIAS | SND_NODEFAULT);
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wparam, lparam))
        {
        case DI_CLIPBOARD:
            {
                HGLOBAL hGlobal;
                char    achBuf[4096];

                StringFromMBOT(TLS(pmbot), achBuf, FALSE);
                hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                                      strlen(achBuf) + 2);

                if (hGlobal)
                {
                    char * pch = (char *)GlobalLock(hGlobal);
                    strcpy(pch, achBuf);
                    GlobalUnlock(hGlobal);

                    OpenClipboard(hwndDlg);
                    EmptyClipboard();
                    SetClipboardData(CF_TEXT, hGlobal);
                    CloseClipboard();
                }

            }
            break;

        case DI_IGNORE:
            EndDialog(hwndDlg, IDOK);
            break;

        case DI_BREAK:
        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoAssertDialog
//
//  Synopsis:   Creates an assert dialog (described below)
//
//  Arguments:  [pmbot] -- Pointer to assert information
//
//  Returns:    IDOK if user selected "Ignore", IDCANCEL for "Break"
//
//  The dialog looks like this:
//
//       ------------------------------------------------------------
//       |                                                          |
//       |  ICON    Process: <exename>            <Process ID Info> |
//       |          File: <filename>              Line: <line #>    |
//       |                                                          |
//       |                          <message>                       |
//       |                                                          |
//       |   Stacktrace: (Not displayed if not present)             |
//       |       <module>  <symbol>                                 |
//       |          .         .                                     |
//       |          .         .                                     |
//       |                                                          |
//       |          [Ignore]       [Copy Text]     [Break]          |
//       |                                                          |
//       ------------------------------------------------------------
//
//     Each section of text is a separate static control, whose ID is taken
//     from the DLGITEM_ID enum. Each control has a corresponding
//     MYDLGITEMTEMPLATE structure, which is filled in with the appropriate
//     initial text, position, and style information. The dialog is dynamically
//     sized to fit the message and stacktrace as appropriate. The Copy Text
//     button causes the text of the assert plus an extended stacktrace to
//     be copied to the clipboard.
//
//----------------------------------------------------------------------------

// The following distance and size values are all in "character widths" or
// "character heights", not dialog units, except as noted.

static int CX_LEFT_EDGE = 7; // Left edge to start of 1st two lines
static int CY_TOP      =  1; // Top to first line
static int CY_DELTA    =  1; // Vertical distance between lines
static int CX_BUFFER   =  3; // Minimum Horiz. spacing between two textboxes.
                             //  Also used to space text from the right edge
                             //  of the dialog.
static int CX_BUTTON   = 42; // Width of the buttons  (in dialog units)
static int CY_BUTTON   = 14; // Height of the buttons (in dialog units)

static int CX_MODULE = (CX_LEFT_EDGE + 3); // Left edge to <module> text
static int CX_SYMBOL = (CX_MODULE + 12);   // Left edge to <symbol> text

// The following is the maximum number of characters we allow on a single line
// for the message displayed in the dialog.
#define CX_MAX_WIDTH  100


int
DoAssertDialog(MBOT *pmbot)
{
    BYTE               abBuf[4096];     // Buffer for storing dialog template
    MYDLGTEMPLATE *    pDlgTmplt;
    MYDLGITEMTEMPLATE *pIT[30] = { 0 }; // Max number of controls in dialog=30
    MYDLGITEMTEMPLATE *pITCur;
    DWORD              dwWidth;
    int                i;

    memset(abBuf, 0, sizeof(abBuf));

    // --- Main Dialog Template

    pDlgTmplt = (MYDLGTEMPLATE*)abBuf;

    pDlgTmplt->style = WS_VISIBLE | WS_POPUP | WS_BORDER | WS_CAPTION | WS_POPUP |
                       DS_CENTER | DS_NOFAILCREATE | //DS_FIXEDSYS |
                       DS_SETFOREGROUND;

    my_wsprintf(pDlgTmplt->achTitle, "%hs", pmbot->szTitle);

    // --- Process Name label

    pITCur = pIT[DI_PROCESSNAME] = GetNextItem((BYTE*)(pDlgTmplt->achTitle), FALSE);

    my_wsprintf(pITCur->achInitText, "Process: %hs", pmbot->achModule);

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->x          = (short)CX_LEFT_EDGE;
    pITCur->y          = (short)CY_TOP;
    pITCur->cx         = (short)(wcslen(pITCur->achInitText) + CX_BUFFER);
    pITCur->cy         = 1;
    pITCur->id         = DI_PROCESSNAME;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- Process and Thread ID label

    pITCur = pIT[DI_PROCESSID] = GetNextItem((BYTE*)(pITCur->achInitText));

    if (pmbot->tid < 0xFFFF)
    {
        my_wsprintf(pITCur->achInitText,
                    "PID: %x  TID: %x",
                    pmbot->pid,
                    pmbot->tid);
    }
    else
    {
        my_wsprintf(pITCur->achInitText, "TID: %x", pmbot->tid);
    }

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->y          = (short)CY_TOP;
    pITCur->cx         = (short)wcslen(pITCur->achInitText);
    pITCur->cy         = 1;
    pITCur->id         = DI_PROCESSID;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- File Name label

    pITCur = pIT[DI_FILE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "File: %hs", pmbot->szFile);

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->x          = (short)CX_LEFT_EDGE;
    pITCur->y          = (short)(CY_TOP + CY_DELTA);
    pITCur->cx         = (short)(wcslen(pITCur->achInitText) + CX_BUFFER);
    pITCur->cy         = 1;
    pITCur->id         = DI_FILE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- Line Number label

    pITCur = pIT[DI_LINE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "Line: %u", pmbot->dwLine);

    pITCur->style      = STYLE_STATICDEFAULT;
    pITCur->y          = (short)(CY_TOP + CY_DELTA);
    pITCur->cx         = (short)wcslen(pITCur->achInitText);
    pITCur->cy         = 1;
    pITCur->id         = DI_LINE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // -- Compute width of dialog. This is done by finding the longest line
    //    of the first three lines in the dialog. The message can never
    //    contribute more than CX_MAX_WIDTH characters to this calculation
    //    because if it's longer than that then we wrap it onto multiple lines.

    dwWidth = max(pIT[DI_PROCESSNAME]->cx, pIT[DI_FILE]->cx) +
              max(pIT[DI_PROCESSID]->cx,   pIT[DI_LINE]->cx);

    // Do signed arithmetic to catch a negative result
    i = strlen(pmbot->szMessage) - CX_LEFT_EDGE;

    if ((i > (int)dwWidth) && (i < CX_MAX_WIDTH))
    {
        dwWidth = min(i, CX_MAX_WIDTH);
    }

    // Make sure the buttons fit.
    if ((dwWidth + CX_LEFT_EDGE) < (DWORD)(4 * (CX_BUTTON/4)))
    {
        dwWidth = 4 * (CX_BUTTON/4) + CX_BUFFER;
    }

    // Set the overall dialog width, and position the two controls in the upper
    // right corner.

    pDlgTmplt->cx = (short)(dwWidth + CX_LEFT_EDGE + CX_BUFFER);
    pIT[DI_PROCESSID]->x = (short)(dwWidth + CX_LEFT_EDGE - pIT[DI_PROCESSID]->cx);
    pIT[DI_LINE]->x = pIT[DI_PROCESSID]->x;

    // --- Message label

    pITCur = pIT[DI_MESSAGE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "%hs", pmbot->szMessage);

    pITCur->style      = WS_VISIBLE | WS_CHILD | SS_CENTER | SS_NOPREFIX;
    pITCur->x          = 1;
    pITCur->y          = (short)(CY_TOP + (CY_DELTA * 3));
    pITCur->cx         = (short)(dwWidth + CX_LEFT_EDGE);
    pITCur->cy         = (short)(wcslen(pITCur->achInitText) / dwWidth + 1);
    pITCur->id         = DI_MESSAGE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    // --- Ignore Button (default)
    //
    // The order of these buttons determines the tab order!

    pITCur = pIT[DI_IGNORE] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "&Ignore");

    pITCur->style      = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_CENTER |
                         BS_VCENTER | BS_DEFPUSHBUTTON;
    pITCur->x          = (short)((pDlgTmplt->cx / 2) - (2 * (CX_BUTTON/4)));
    pITCur->cx         = (short)CX_BUTTON;
    pITCur->cy         = (short)CY_BUTTON;
    pITCur->id         = DI_IGNORE;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_BUTTON;

    // --- Copy To Clipboard Button

    pITCur = pIT[DI_CLIPBOARD] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "&Copy Text");

    pITCur->style      = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_CENTER |
                         BS_VCENTER | BS_PUSHBUTTON;
    pITCur->x          = (short)((pDlgTmplt->cx / 2) - (CX_BUTTON / 8));
    pITCur->cx         = (short)CX_BUTTON;
    pITCur->cy         = (short)CY_BUTTON;
    pITCur->id         = DI_CLIPBOARD;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_BUTTON;

    // --- Break Button

    pITCur = pIT[DI_BREAK] = GetNextItem((BYTE*)(pITCur->achInitText));

    my_wsprintf(pITCur->achInitText, "&Break");

    pITCur->style      = WS_VISIBLE | WS_TABSTOP | WS_CHILD | BS_CENTER |
                         BS_VCENTER | BS_PUSHBUTTON;
    pITCur->x          = (short)((pDlgTmplt->cx / 2) + (CX_BUTTON/4));
    pITCur->cx         = (short)CX_BUTTON;
    pITCur->cy         = (short)CY_BUTTON;
    pITCur->id         = IDCANCEL; // So escape key works
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_BUTTON;

    // --- Icon

    pITCur = pIT[DI_ICON] = GetNextItem((BYTE*)(pITCur->achInitText));

    pITCur->achInitText[0] = L'\0'; // Icon is set in WM_INITDIALOG

    pITCur->style      = WS_VISIBLE | WS_CHILD | SS_ICON;
    pITCur->x          = 2;
    pITCur->y          = 1;
    pITCur->cx         = 0;
    pITCur->cy         = 0;
    pITCur->id         = DI_ICON;
    pITCur->wClassLen  = 0xFFFF;
    pITCur->wClassType = DLGITEM_STATIC;

    pDlgTmplt->cdit = 9; // Total of all controls so far

    //
    // --- Add Stacktrace information if available
    //
    if (pmbot->cSym)
    {
        int cSyms, j, ypos, id;

        // --- Stacktrace label

        pITCur = pIT[DI_STACKMSG] = GetNextItem((BYTE*)(pITCur->achInitText));

        my_wsprintf(pITCur->achInitText, "StackTrace:");

        pITCur->style      = STYLE_STATICDEFAULT;
        pITCur->y          = (short)(pIT[DI_MESSAGE]->y + pIT[DI_MESSAGE]->cy + CY_DELTA);
        pITCur->x          = (short)CX_LEFT_EDGE;
        pITCur->cx         = (short)wcslen(pITCur->achInitText);
        pITCur->cy         = 1;
        pITCur->id         = DI_STACKMSG;
        pITCur->wClassLen  = 0xFFFF;
        pITCur->wClassType = DLGITEM_STATIC;

        pDlgTmplt->cdit++;

        cSyms = min(pmbot->cSym, SHORT_SYM_COUNT);
        ypos  = pITCur->y + pITCur->cy;

        // --- Modules and symbols

        for (i=0; i < cSyms; i++)
        {
            for (j=0; j < 2; j++)
            {
                id = (j) ? (DI_MODULEBASE+i) : (DI_FUNCBASE+i);

                pITCur = pIT[id] = GetNextItem((BYTE*)(pITCur->achInitText));

                my_wsprintf(pITCur->achInitText,
                            "%hs",
                            (j)
                              ? pmbot->asiSym[i].achModule
                              : pmbot->asiSym[i].achSymbol);

                pITCur->style      = STYLE_STATICDEFAULT;
                pITCur->x          = (short)((j) ? CX_MODULE : CX_SYMBOL);
                pITCur->y          = (short)ypos;
                pITCur->cx         = (short)wcslen(pITCur->achInitText);
                pITCur->cy         = 1;
                pITCur->id         = (short)id;
                pITCur->wClassLen  = 0xFFFF;
                pITCur->wClassType = DLGITEM_STATIC;

                pDlgTmplt->cdit++;
            }

            ypos += pITCur->cy;
        }
    }

    // --- Convert coordinates from character widths to dialog units (char * 4
    // in X direction, char * 8 in Y direction)

    pDlgTmplt->cx  *= 4;

    for (i = 0; i < DI_MAX; i++)
    {
        pITCur = pIT[i];
        if (pITCur)
        {
            pITCur->x *= 4;
            pITCur->y *= 8;

            if (pITCur->wClassType != DLGITEM_BUTTON)
            {
                // Button cx's and cy's are already in dialog units.
                pITCur->cx *= 4;
                pIT[i]->cy *= 8;
            }
        }
    }

    //
    // Position the buttons vertically now that all text is added
    //
    if (pmbot->cSym)
    {
        i = DI_MODULEBASE + min(pmbot->cSym, SHORT_SYM_COUNT) - 1;
    }
    else
    {
        i = DI_MESSAGE;
    }

    pIT[DI_IGNORE]->y = (short)(pIT[i]->y + pIT[i]->cy + (8*CY_DELTA));
    pIT[DI_BREAK]->y  = (short)(pIT[DI_CLIPBOARD]->y = pIT[DI_IGNORE]->y);

    // Compute the overall height of the dialog
    pDlgTmplt->cy = (short)(pIT[DI_IGNORE]->y + pIT[DI_IGNORE]->cy + (8*CY_DELTA));

    // -- Let's create this thing!
    DLGTEMPLATE *dlgTemplate = (DLGTEMPLATE *)abBuf;

    pmbot->id = DialogBoxIndirectParamA(
                                        g_hinstMain,
                                        dlgTemplate,
                                        NULL,
                                        DlgAssert,
                                        (LPARAM)pmbot);

    return pmbot->id;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       debug.cxx
//
//  Contents:   Shell debugging functionality
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_MAPICODE_H_
#define X_MAPICODE_H_
#include <mapicode.h>
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_DOCOBJ_H_
#define X_DOCOBJ_H_
#include <docobj.h>
#endif

#ifdef UNIX // IEUNIX: it should be in objbase.h. Here to prevent build break.
#ifndef X_URLMON_H_
#define X_URLMON_H_
#include <urlmon.h>
#endif
#endif // UNIX

HRESULT UnLoadPSAPI();

//  Globals

#ifdef _MAC
BOOL    fEnableMacCheckHeap = TRUE;
#endif

typedef BOOL (WINAPI * PFNDLLMAIN)(HANDLE, DWORD, LPVOID);

HMODULE                 g_hModule          = NULL;
HINSTANCE               g_hinstMain        = NULL;
HANDLE                  g_hProcess         = NULL;
HANDLE                  g_rgDllHandle[8];
PFNDLLMAIN              g_rgDllMain[8];

BOOL                    g_fAbnormalProcessTermination = FALSE;
BOOL                    g_fOutputToConsole = FALSE;
BOOL                    g_fDetached        = FALSE;

CRITICAL_SECTION        g_csTrace;
CRITICAL_SECTION        g_csResDlg;
CRITICAL_SECTION        g_csDebug;
CRITICAL_SECTION        g_csHeapHack;
CRITICAL_SECTION        g_csSpy;

DWORD                   g_dwTls = (DWORD) -1;

static DBGTHREADSTATE *    s_pts;

static HANDLE           s_hFileLog         = INVALID_HANDLE_VALUE;

//  TAGS and stuff

/*
 *  Number of TAG's registered so far.
 *
 */
TRACETAG tagMac;


/*
 *  Mapping from TAG's to information about them.  Entries
 *  0...tagMac-1 are valid.
 */
TGRC    mptagtgrc[tagMax];


TRACETAG     tagDefault                  = tagNull;
TRACETAG     tagError                    = tagNull;
TRACETAG     tagWarn                     = tagNull;
TRACETAG     tagAssertPop                = tagNull;
TRACETAG     tagAssertExit               = tagNull;
TRACETAG     tagAssertStacks             = tagNull;
TRACETAG     tagTestFailures             = tagNull;
TRACETAG     tagTestFailuresIgnore       = tagNull;
TRACETAG     tagRRETURN                  = tagNull;
TRACETAG     tagValidate                 = tagNull;
TRACETAG     tagLeaks                    = tagNull;
TRACETAG     tagLeaksExpected            = tagNull;
TRACETAG     tagSymbols                  = tagNull;
TRACETAG     tagSpySymbols               = tagNull;
TRACETAG     tagTrackItf                 = tagNull;
TRACETAG     tagTrackItfVerbose          = tagNull;
TRACETAG     tagThrd                     = tagNull;
TRACETAG     tagMemoryStrict_            = tagNull;
TRACETAG     tagCoMemoryStrict_          = tagNull;
TRACETAG     tagMemoryStrictTail_        = tagNull;
TRACETAG     tagMemoryStrictAlign_       = tagNull;
TRACETAG     tagOLEWatchvar              = tagNull;
TRACETAG     tagMemTrace                 = tagNull;
TRACETAG     tagPerf_                    = tagNull;
TRACETAG     tagTraceCalls               = tagNull;
TRACETAG     tagHexDumpLeaks             = tagNull;
TRACETAG     tagNoLeakAssert             = tagNull;
TRACETAG     tagMagic                    = tagNull;
TRACETAG     tagStackSpew                = tagNull;

#ifndef _MAC
#define SZ_NEWLINE "\r\n"
#else
#define SZ_NEWLINE "\n"
#endif

static CHAR szStateFileExt[]    = ".tag";
static CHAR szDbgOutFileExt[]   = ".log";
static CHAR szStateFileName[]   = "HTMLPad.dbg";
static CHAR szDbgOutFileName[]  = "HTMLPad.log";


CHAR    rgchTraceTagBuffer[1024] = { 0 };

void    DllProcessAttach(HINSTANCE hinstance);
void    DllProcessDetach();
const   LPTSTR GetHResultName(HRESULT r);
TRACETAG TagRegisterSomething(
        TGTY tgty, CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);
BOOL    SendTagToDisk(TRACETAG tag, BOOL fSendToDisk);
VOID    SpitSzToDisk(CHAR * sz);
void    SetSortFirstFlag (TRACETAG tag);


extern void PerfProcessAttach();
extern void PerfProcessDetach();
extern void MeterProcessAttach();
extern void MeterProcessDetach();
extern void ReadFillBytes();

static double FloatPointUsed()
{
    double foo = 10.0 * 20.0;
    return foo;
}

#ifdef UNIX
extern "C"
#endif
BOOL
DllMain(HANDLE hinst, DWORD dwReason, LPVOID lpReason)
{

    DbgExAssertThreadDisable(TRUE);

    // KGallo - This is to ensure we get floating point loaded in to the
    // system so our printf can print doubles.  If you do not reference a
    // floating point operation in your code anywhere then you will
    // not get floating point support.
    // It also cannot be in unreachable code since this will be
    // removed by the compiler

    FloatPointUsed();

#if defined(UNIX)
    // IEUNIX Take out use of threads for the assert dialog
    DbgExAssertThreadDisable(TRUE);
#endif

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DllProcessAttach((HINSTANCE)hinst);
        PerfProcessAttach();
        MeterProcessAttach();
        ReadFillBytes();
        break;

    case DLL_THREAD_DETACH:
        DllThreadDetach(DbgGetThreadState());
        break;

    case DLL_PROCESS_DETACH:
        g_fDetached = TRUE;
        DllProcessDetach();
        MeterProcessDetach();
        PerfProcessDetach();
        break;
    }

    DbgExAssertThreadDisable(FALSE);

    return TRUE;
}

HRESULT
DllThreadAttach()
{
    DBGTHREADSTATE *   pts;

    // Allocate directly from the heap, rather than through new, since new
    // requires that the DBGTHREADSTATE is established
    pts = (DBGTHREADSTATE *)LocalAlloc(LMEM_FIXED, sizeof(DBGTHREADSTATE));
    if (!pts)
    {
        Assert("Debug Thread initialization failed");
        return E_OUTOFMEMORY;
    }

    memset(pts, 0, sizeof(DBGTHREADSTATE));

    {
        LOCK_GLOBALS;

        pts->ptsNext = s_pts;
        if (s_pts)
            s_pts->ptsPrev = pts;
        s_pts = pts;
    }

    TlsSetValue(g_dwTls, pts);

    return S_OK;
}

void
DllThreadDetach(DBGTHREADSTATE *pts)
{
    DBGTHREADSTATE **  ppts;

    if (!pts)
        return;

    LOCK_GLOBALS;

    for (ppts = &s_pts; *ppts && *ppts != pts; ppts = &((*ppts)->ptsNext));
    if (*ppts)
    {
        *ppts = pts->ptsNext;
        if (pts->ptsNext)
        {
            pts->ptsNext->ptsPrev = pts->ptsPrev;
        }
    }

   LocalFree(pts);
}

void
DllProcessAttach(HINSTANCE hinst)
{
    static struct
    {
        TRACETAG *  ptag;
        TGTY        tgty;
        LPSTR       pszClass;
        LPSTR       pszDescr;
        BOOL        fEnabled;
    }
    g_ataginfo[] =
    {
        &tagDefault,                tgtyTrace,  "Debug",
            "General debug output",                             TRUE,
        &tagAssertPop,              tgtyOther,  "Assert",
            "Popups on asserts",                                TRUE,
        &tagAssertExit,             tgtyOther,  "Assert",
            "Exit on asserts",                                  FALSE,
        &tagAssertStacks,           tgtyOther,  "Assert",
            "Stacktraces on asserts",                           TRUE,
        &tagValidate,               tgtyOther,  "Memory",
            "Aggressive memory validation",                     FALSE,
        &tagLeaks,                  tgtyTrace,  "Memory",
            "Memory Leaks",                                     TRUE,
        &tagLeaksExpected,          tgtyTrace,  "Memory",
            "Memory Leaks (Expected)",                          FALSE,
        &tagMemoryStrict_,          tgtyOther,  "Memory",
            "Use VMem for MemAlloc",                            FALSE,
        &tagCoMemoryStrict_,        tgtyOther,  "Memory",
            "Use VMem for CoTaskMemAlloc",                      FALSE,
        &tagMemoryStrictTail_,      tgtyOther,  "Memory",
            "VMem strict at end (vs beginning)",                TRUE,
        &tagMemoryStrictAlign_,     tgtyOther,  "Memory",
            "VMem pad to quadword at end",                      FALSE,
        &tagMemTrace,               tgtyOther,  "Memory",
            "Trace Memory Allocations",                         FALSE,
        &tagSymbols,                tgtyTrace,  "Memory",
            "Leaks: Stacktraces & symbols",                     FALSE,
        &tagSpySymbols,             tgtyTrace,  "Memory",
            "Leaks: Stacktraces & symbols for CoTaskMemAlloc",  FALSE,
        &tagHexDumpLeaks,           tgtyTrace,  "Memory",
            "Leaks: Hexdump contents of blocks",                FALSE,
        &tagNoLeakAssert,           tgtyTrace,  "Memory",
            "Leaks: Don't assert on leaks",                     FALSE,
        &tagStackSpew,              tgtyOther,  "Memory",
            "Stack Spew: Fill stack with known value",          TRUE,
        &tagError,                  tgtyTrace,  "Trace",
            "Errors",                                           TRUE,
        &tagWarn,                   tgtyTrace,  "Trace",
            "Warnings",                                         FALSE,
        &tagTestFailures,           tgtyTrace,  "Trace",
            "THR",                                              FALSE,
        &tagTestFailuresIgnore,     tgtyTrace,  "Trace",
            "IGNORE_HR",                                        FALSE,
        &tagRRETURN,                tgtyTrace,  "Trace",
            "RRETURN",                                          FALSE,
        &tagTraceCalls,             tgtyTrace,  "Trace",
            "Trace all THR calls",                              FALSE,
        &tagTrackItf,               tgtyTrace,  "Track",
            "Interface watch",                                  FALSE,
        &tagTrackItfVerbose,        tgtyOther,  "Track",
            "Verbose trace on interface watch",                 FALSE,
        &tagThrd,                   tgtyTrace,  "Thread",
            "Thread related tracing",                           FALSE,
        &tagOLEWatchvar,            tgtyTrace,  "Trace",
            "All calls to OCX interfaces",                      FALSE,
        &tagPerf_,                  tgtyTrace,  "Perf",
            "Perf and size killers",                            FALSE,
        &tagMagic,                  tgtyTrace,  "Magic",
            "Trace imagehlp.dll failures",                      FALSE,
};


    TGRC *  ptgrc;
    char    szLogPath[MAX_PATH];
    int     i;

#ifndef  _MAC
    InitializeCriticalSection(&g_csTrace);
    InitializeCriticalSection(&g_csResDlg);
    InitializeCriticalSection(&g_csDebug);
    InitializeCriticalSection(&g_csHeapHack);
    InitializeCriticalSection(&g_csSpy);
#endif

    g_dwTls = TlsAlloc();
    if (g_dwTls == (DWORD)(-1))
    {
        DbgExAssertThreadDisable(FALSE);
        return;
    }

    EnsureThreadState();

    g_hinstMain = hinst;

    // don't want windows to put up message box on INT 24H errors.
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Initialize simulated failures
    DbgExSetSimFailCounts(0, 1);

    // Initialize TAG array

    tagMac = tagMin;

    // enable tagNull at end of DbgExRestoreDefaultDebugState
    ptgrc = mptagtgrc + tagNull;
    ptgrc->tgty = tgtyNull;
    ptgrc->fEnabled = FALSE;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->szOwner = "dgreene";
    ptgrc->szDescrip = "NULL";

    for (i = 0; i < ARRAY_SIZE(g_ataginfo); i++)
    {
        *g_ataginfo[i].ptag = TagRegisterSomething(
                g_ataginfo[i].tgty,
                g_ataginfo[i].pszClass,
                g_ataginfo[i].pszDescr,
                g_ataginfo[i].fEnabled);

        SetSortFirstFlag(*g_ataginfo[i].ptag);
    }

    g_hProcess = GetCurrentProcess();

    if (GetEnvironmentVariableA("TRIDENT_LOGPATH", szLogPath, MAX_PATH))
    {
        DbgExOpenLogFile(szLogPath);
    }

    MagicInit();
    DbgExRestoreDefaultDebugState();
}

void
DllProcessDetach(void)
{
    TRACETAG    tag;
    TGRC *      ptgrc;
    int         i;

    EnsureThreadState();

    for (i = 0; i < ARRAY_SIZE(g_rgDllHandle); ++i)
    {
        if (g_rgDllHandle[i] != NULL && g_rgDllMain[i] != NULL)
        {
            g_rgDllMain[i](g_rgDllHandle[i], DLL_PROCESS_DETACH, NULL);
        }
    }

    if (!g_fAbnormalProcessTermination)
    {
        DbgExTraceMemoryLeaks();
    }

    // Close the debug output file
    if (s_hFileLog != INVALID_HANDLE_VALUE)
    {
        char achBuf[128];

        wsprintfA(achBuf, "<<<<< End logging" SZ_NEWLINE);
        SpitSzToDisk(achBuf);
        CloseHandle(s_hFileLog);
        s_hFileLog = INVALID_HANDLE_VALUE;
    }

    // Free the tag strings if not already done
    for (tag = tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            GlobalFreePtr(ptgrc->szOwner);
            ptgrc->szOwner = NULL;
            GlobalFreePtr(ptgrc->szDescrip);
            ptgrc->szDescrip = NULL;
        }
    }

    //    Set flags to FALSE.  Need to separate from loop above so that
    //    final memory leak trace tag can work.

    for (tag=tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc->fEnabled = FALSE;
            ptgrc->ClearFlag(TGRC_FLAG_VALID);
        }
    }

    MagicDeinit();

    if (g_dwTls != (DWORD)(-1))
    {
        while (s_pts)
            DllThreadDetach(s_pts);
        TlsFree(g_dwTls);
    }

    // Unload PSAPI.DLL
    UnLoadPSAPI();

#ifndef _MAC
    DeleteCriticalSection(&g_csTrace);
    DeleteCriticalSection(&g_csResDlg);
    DeleteCriticalSection(&g_csDebug);
    DeleteCriticalSection(&g_csHeapHack);
    DeleteCriticalSection(&g_csSpy);
#endif
}


/*
 *  FReadDebugState
 *
 *  Purpose:
 *      Read the debug state information file whose name is given by the
 *      string szDebugFile.  Set up the tag records accordingly.
 *
 *  Parameters:
 *      szDebugFile     Name of debug file to read
 *
 *  Returns:
 *      TRUE if file was successfully read; FALSE otherwise.
 *
 */

BOOL
FReadDebugState( CHAR * szDebugFile )

{
    HANDLE      hfile = NULL;
    TGRC        tgrc;
    TGRC *      ptgrc;
    TRACETAG    tag;
    INT         cchOwner;
    CHAR        rgchOwner[MAX_PATH];
    INT         cchDescrip;
    CHAR        rgchDescrip[MAX_PATH];
    BOOL        fReturn = FALSE;
    DWORD       cRead;

#ifdef UNIX
    CHAR *pszSlash = strrchr(szDebugFile, '/');
    hfile = INVALID_HANDLE_VALUE;

    if ( pszSlash )
    {
        strcpy( szDebugFile, pszSlash+1 );
        hfile = CreateFileA(szDebugFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            (HANDLE) NULL);
    }
#else
    hfile = CreateFileA(szDebugFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
#endif

    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (;;)
        {
            if (!ReadFile(hfile, &tgrc, sizeof(TGRC), &cRead, NULL))
                break;

            if (cRead == 0)
                break;

            if (!ReadFile(hfile, &cchOwner, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchOwner <= sizeof(rgchOwner));
            if (!ReadFile(hfile, rgchOwner, cchOwner, &cRead, NULL))
                goto ErrorReturn;

            if (!ReadFile(hfile, &cchDescrip, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchDescrip <= sizeof(rgchDescrip));
            if (!ReadFile(hfile, rgchDescrip, cchDescrip, &cRead, NULL))
                goto ErrorReturn;

            ptgrc = mptagtgrc + tagMin;
            for (tag = tagMin; tag < tagMac; tag++)
            {
                if (ptgrc->TestFlag(TGRC_FLAG_VALID) &&
                    !strcmp(rgchOwner, ptgrc->szOwner) &&
                    !strcmp(rgchDescrip, ptgrc->szDescrip))
                {
                    if (!ptgrc->TestFlag(TGRC_FLAG_INITED))
                    {
                        Assert(tgrc.TestFlag(TGRC_FLAG_VALID));

                        ptgrc->fEnabled = tgrc.fEnabled;
                        ptgrc->ulBitFlags = tgrc.ulBitFlags;

                        // Only read each tag once
                        ptgrc->SetFlag(TGRC_FLAG_INITED);
                    }
                    break;
                }

                ptgrc++;
            }
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);

Exit:
    return fReturn;
}

/*
 *  FWriteDebugState
 *
 *  Purpose:
 *      Writes the current state of the Debug Module to the file
 *      name given.  The saved state can be restored later by calling
 *      FReadDebugState.
 *
 *  Parameters:
 *      szDebugFile     Name of the file to create and write the debug
 *                      state to.
 *
 *  Returns:
 *      TRUE if file was successfully written; FALSE otherwise.
 */
BOOL
FWriteDebugState( CHAR * szDebugFile )
{
    HANDLE      hfile = NULL;
    TRACETAG    tag;
    UINT        cch;
    TGRC *      ptgrc;
    BOOL        fReturn = FALSE;
    DWORD       cWrite;

#ifdef UNIX
    CHAR *pszSlash = strrchr(szDebugFile, '/');
    hfile = INVALID_HANDLE_VALUE;

    if ( pszSlash )
    {
        strcpy( szDebugFile, pszSlash+1 );
        hfile = CreateFileA(szDebugFile,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            (HANDLE) NULL);
    }
#else
    hfile = CreateFileA(szDebugFile,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
#endif

    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (tag = tagMin; tag < tagMac; tag++)
        {
            ptgrc = mptagtgrc + tag;

            if (!ptgrc->TestFlag(TGRC_FLAG_VALID))
                continue;

            Assert(ptgrc->szOwner);
            Assert(ptgrc->szDescrip);

            if (!WriteFile(hfile, ptgrc, sizeof(TGRC), &cWrite, NULL))
                goto ErrorReturn;

            // SZ fields will be overwritten when read back

            cch = strlen(ptgrc->szOwner) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szOwner, cch, &cWrite, NULL))
                goto ErrorReturn;

            cch = strlen(ptgrc->szDescrip) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szDescrip, cch, &cWrite, NULL))
                goto ErrorReturn;
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);
    DeleteFileA(szDebugFile);

Exit:
    return fReturn;
}


//+------------------------------------------------------------------------
//
//  Function:   SaveDefaultDebugState
//
//  Synopsis:   Saves the debug state of the executing program to a file
//              of the same name, substituting the ".tag" suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void
SaveDefaultDebugState( void )
{
    CHAR    rgch[MAX_PATH] = "";

    if (g_hinstMain)
    {
#ifndef _MAC
        UINT cch = (UINT) GetModuleFileNameA(g_hModule, rgch, sizeof(rgch));
#ifdef UNIX
        strcat(rgch, szStateFileExt);
#else
        Assert(rgch[cch - 4] == '.');
        strcpy(&rgch[cch - 4], szStateFileExt);
#endif
#else
        CHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitleA(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FWriteDebugState(rgch);
}


//+------------------------------------------------------------------------
//
//  Function:   DbgExRestoreDefaultDebugState
//
//  Synopsis:   Restores the debug state for the executing program from
//              the state file of the same name, substituting the ".tag"
//              suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void WINAPI
DbgExRestoreDefaultDebugState()
{
    CHAR    rgch[MAX_PATH] = "";

    EnsureThreadState();

    if (g_hinstMain)
    {
#if defined(_MAC)
        CHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitleA(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);

#elif defined(UNIX)
        UINT cch = (UINT) GetModuleFileNameA(NULL, rgch, sizeof(rgch));
        strcat(rgch, szStateFileExt);

#else
        UINT cch = (UINT) GetModuleFileNameA(NULL, rgch, sizeof(rgch));
        Assert(rgch[cch - 4] == '.');
        strcpy(&rgch[cch - 4], szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FReadDebugState(rgch);

    mptagtgrc[tagNull].fEnabled = TRUE;
}

TRACETAG WINAPI
DbgExFindTag(char * szTagDesc)
{
    Assert(szTagDesc);
    for (TRACETAG i = tagMin; i < tagMac; i++)
    {
        if (mptagtgrc[i].szDescrip && strlen(mptagtgrc[i].szDescrip))
        {
            if (!_stricmp(mptagtgrc[i].szDescrip, szTagDesc))
            {
                return i;
            }
        }
    }

    return 0;
}

/*
 *  DbgExIsTagEnabled
 *
 *  Purpose:
 *      Returns a boolean value indicating whether the given TAG
 *      has been enabled or disabled by the user.
 *
 *  Parameters:
 *      tag     The TAG to check
 *
 *  Returns:
 *      TRUE    if the TAG has been enabled.
 *      FALSE   if the TAG has been disabled.
 */

BOOL WINAPI
DbgExIsTagEnabled(TRACETAG tag)
{
    return  mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID) &&
            mptagtgrc[tag].fEnabled;
}


/*
 *  DbgExEnableTag
 *
 *  Purpose:
 *      Sets or resets the TAG value given.  Allows code to enable or
 *      disable TAG'd assertions and trace switches.
 *
 *  Parameters:
 *      tag         The TAG to enable or disable
 *      fEnable     TRUE if TAG should be enabled, FALSE if it should
 *                  be disabled.
 *  Returns:
 *      old state of tag (TRUE if tag was enabled, otherwise FALSE)
 *
 */

BOOL WINAPI
DbgExEnableTag(TRACETAG tag, BOOL fEnable)
{
    BOOL    fOld;

    EnsureThreadState();
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].fEnabled;
    mptagtgrc[tag].fEnabled = fEnable;
    mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_INITED;
    return fOld;
}

void SetSortFirstFlag (TRACETAG tag)
{
    EnsureThreadState();

    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));

    mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_SORTFIRST;
}

BOOL WINAPI
DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk)
{
    BOOL fOld;

    EnsureThreadState();
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].ulBitFlags;
    if (fSendToDisk) mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_DISK;
    else mptagtgrc[tag].ulBitFlags &= ~TGRC_FLAG_DISK;
    return fOld;
}

BOOL WINAPI
DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak)
{
    BOOL fOld;

    EnsureThreadState();
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].ulBitFlags;
    if (fBreak) mptagtgrc[tag].ulBitFlags |= TGRC_FLAG_BREAK;
    else mptagtgrc[tag].ulBitFlags &= ~TGRC_FLAG_BREAK;
    return fOld;
}

void
SpitSzToDisk(char *pch)
{
    DWORD cWrite;

    if (s_hFileLog != INVALID_HANDLE_VALUE && pch && *pch)
    {
        WriteFile(s_hFileLog, pch, strlen(pch), &cWrite, NULL);
        FlushFileBuffers(s_hFileLog);
    }
}

/*
 *  TagRegisterSomething
 *
 *  Purpose:
 *      Does actual work of allocating TAG, and initializing TGRC.
 *      The owner and description strings are duplicated from the
 *      arguments passed in.
 *
 *  Parameters:
 *      tgty        Tag type to register.
 *      szOwner     Owner.
 *      szDescrip   Description.
 *
 *  Returns:
 *      New TAG, or tagNull if none is available.
 */

TRACETAG
TagRegisterSomething(
        TGTY    tgty,
        CHAR *  szOwner,
        CHAR *  szDescrip,
        BOOL    fEnabled)
{
    TRACETAG tag;
    TRACETAG tagNew         = tagNull;
    TGRC *  ptgrc;
    CHAR *  szOwnerDup      = NULL;
    CHAR *  szDescripDup    = NULL;
    UINT    cb;
    BOOL    fSortFirst = FALSE;

    if (szOwner[0] == '!')
    {
        fSortFirst = TRUE;
        szOwner++;
    }

    for (tag = tagMin, ptgrc = mptagtgrc + tag; tag < tagMac;
            tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            if(!(strcmp(szOwner, ptgrc->szOwner) ||
                strcmp(szDescrip, ptgrc->szDescrip)))
            {
                return tag;
            }
        }
        else if (tagNew == tagNull)
            tagNew= tag;
    }

    // Make duplicate copies.

    Assert(szOwner);
    Assert(szDescrip);
    cb = strlen(szOwner) + 1;

    // we use LocalAlloc here instead of new so
    // we don't interfere with leak reporting because of the
    // dependency between the debug library and the
    // leak reporting code (i.e., don't touch this --Erik)

    szOwnerDup = (LPSTR) GlobalAllocPtr(GMEM_MOVEABLE, cb);

    if (szOwnerDup == NULL)
    {
        goto Error;
    }

    strcpy(szOwnerDup, szOwner);

    cb = strlen(szDescrip) + 1;
    szDescripDup = (LPSTR) GlobalAllocPtr(GMEM_MOVEABLE, cb);

    if (szDescripDup == NULL)
    {
        goto Error;
    }

    strcpy(szDescripDup, szDescrip);

    if (tagNew == tagNull)
    {
        if (tagMac >= tagMax)
        {
#ifdef  NEVER
            AssertSz(FALSE, "Too many tags registered already!");
#endif
            Assert(FALSE);
            return tagNull;
        }

        tag = tagMac++;
    }
    else
        tag = tagNew;

    ptgrc = mptagtgrc + tag;

    ptgrc->fEnabled = fEnabled;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->tgty = tgty;
    ptgrc->szOwner = szOwnerDup;
    ptgrc->szDescrip = szDescripDup;

    if (fSortFirst)
    {
        ptgrc->ulBitFlags |= TGRC_FLAG_SORTFIRST;
    }

    return tag;

Error:
    if (szOwnerDup)
        GlobalFree((HGLOBAL)szOwnerDup);

    if (szDescripDup)
        GlobalFree((HGLOBAL)szDescripDup);

    return tagNull;
}


/*
 *  DeregisterTag
 *
 *  Purpose:
 *      Deregisters tag, removing it from tag table.
 *
 *  Parameters:
 *      tag     Tag to deregister.
 */

void
DeregisterTag(TRACETAG tag)
{
    //  don't allow deregistering the tagNull entry
    //  but exit gracefully
    if (!tag)
        return;

    Assert(tag < tagMac);
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));

    mptagtgrc[tag].fEnabled = FALSE;
    mptagtgrc[tag].ClearFlag(TGRC_FLAG_VALID);
    GlobalFree((HGLOBAL)mptagtgrc[tag].szOwner);
    mptagtgrc[tag].szOwner = NULL;
    GlobalFree((HGLOBAL)mptagtgrc[tag].szDescrip);
    mptagtgrc[tag].szDescrip = NULL;
}


/*
 *  DbgExTagRegisterTrace
 *
 *  Purpose:
 *      Registers a class of trace points, and returns an identifying
 *      TAG for that class.
 *
 *  Parameters:
 *      szOwner     The email name of the developer writing the code
 *                  that registers the class.
 *      szDescrip   A short description of the class of trace points.
 *                  For instance: "All calls to PvAlloc() and HvFree()"
 *
 *  Returns:
 *      TAG identifying class of trace points, to be used in calls to
 *      the trace routines.
 */

TRACETAG WINAPI
DbgExTagRegisterTrace( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    EnsureThreadState();
    return TagRegisterSomething(tgtyTrace, szOwner, szDescrip, fEnabled);
}



TRACETAG
DbgExTagRegisterOther( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    EnsureThreadState();
    return TagRegisterSomething(tgtyOther, szOwner, szDescrip, fEnabled);
}



TRACETAG WINAPI
DbgExTagError()
{
    EnsureThreadState();
    return tagError;
}

TRACETAG WINAPI
DbgExTagAssertExit()
{
    EnsureThreadState();
    return tagAssertExit;
}

TRACETAG WINAPI
DbgExTagAssertStacks()
{
    EnsureThreadState();
    return tagAssertStacks;
}

TRACETAG WINAPI
DbgExTagWarning()
{
    EnsureThreadState();
    return tagWarn;
}

TRACETAG WINAPI
DbgExTagThread()
{
    EnsureThreadState();
    return tagThrd;
}

TRACETAG WINAPI
DbgExTagMemoryStrict()
{
    EnsureThreadState();
    return tagMemoryStrict_;
}

TRACETAG WINAPI
DbgExTagCoMemoryStrict()
{
    EnsureThreadState();
    return tagCoMemoryStrict_;
}

TRACETAG WINAPI
DbgExTagMemoryStrictTail()
{
    EnsureThreadState();
    return tagMemoryStrictTail_;
}

TRACETAG WINAPI
DbgExTagMemoryStrictAlign()
{
    EnsureThreadState();
    return tagMemoryStrictAlign_;
}

TRACETAG WINAPI
DbgExTagOLEWatch()
{
    EnsureThreadState();
    return tagOLEWatchvar;
}

TRACETAG WINAPI
DbgExTagPerf()
{
    EnsureThreadState();
    return tagPerf_;
}

/*
 *  DbgExTaggedTrace
 *
 *  Purpose:
 *      Uses the given format string and parameters to render a
 *      string into a buffer.  The rendered string is sent to the
 *      destination indicated by the given tag, or sent to the bit
 *      bucket if the tag is disabled.
 *
 *  Arguments:
 *      tag     Identifies the tag group
 *      szFmt   Format string for _snprintf (qqv)
 */

BOOL __cdecl
DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...)
{
    BOOL    f;

    EnsureThreadState();

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = DbgExTaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl
DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    BOOL    f;

    EnsureThreadState();

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = DbgExTaggedTraceListEx(tag, usFlags, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL WINAPI
DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker)
{
    static CHAR szFmtOwner[] = "%s %s: ";
    TGRC *      ptgrc;
    int         cch;
    int         cchCopied;
    int         iIndent;
    DBGTHREADSTATE *pts;
    CHAR        achBuf[4096];

    EnsureThreadState();

    pts = DbgGetThreadState();

    if (tag == tagNull)
        ptgrc = mptagtgrc + tagDefault;
    else
        ptgrc = mptagtgrc + tag;

    if (!ptgrc->fEnabled)
        return FALSE;

    LOCK_TRACE;

    Assert(ptgrc->TestFlag(TGRC_FLAG_VALID));

    // indenting

    cch = 0;

    if (usFlags & TAG_INDENT)
        pts->iIndent++;

    iIndent = min(pts->iIndent, 64);

    if (usFlags & TAG_OUTDENT)
        pts->iIndent--;

    if (iIndent > 0)
    {
        memset(achBuf, ' ', iIndent);
        achBuf[iIndent-1] = (usFlags & TAG_INDENT ? '+' : usFlags & TAG_OUTDENT ? '-' : ' ');
        cch += iIndent;
    }

    // tag name

    if (!(usFlags & TAG_NONAME))
    {
        cch += _snprintf(
                achBuf + cch,
                ARRAY_SIZE(achBuf) - cch,
                szFmtOwner,
                "TRI",
                ptgrc->szOwner);
    }

    cchCopied = hrvsnprintf(
                       achBuf + cch,
                       ARRAY_SIZE(achBuf) - cch,
                       szFmt,
                       valMarker);

    if ( cchCopied == -1 ) {
        cch = ARRAY_SIZE(achBuf) - ARRAY_SIZE(SZ_NEWLINE);
    } else {
        cch += cchCopied;
    }

    if (!(usFlags & TAG_NONEWLINE))
        strcpy(achBuf+cch, SZ_NEWLINE);

    if (ptgrc->TestFlag(TGRC_FLAG_DISK))
    {
        SpitSzToDisk(achBuf);
    }

    if ((usFlags & TAG_USECONSOLE) || g_fOutputToConsole)
    {
       printf(achBuf);
    }

    if (!(usFlags & TAG_USECONSOLE))
    {
        OutputDebugStringA(achBuf);
    }

    if (ptgrc->TestFlag(TGRC_FLAG_BREAK))
    {
        AssertSz(FALSE, ptgrc->szDescrip);
    }

    return FALSE;
}

void WINAPI
DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal)
{
    INET_SYMBOL_INFO      asiSym[32];
    DWORD            dwEip[32];
    int              i;
    int              c;
    CHAR             achSymbol[256];

    EnsureThreadState();

    if (!DbgExIsTagEnabled(tag))
        return;

    if (cTotal > ARRAY_SIZE(dwEip))
        cTotal = ARRAY_SIZE(dwEip);

    c = GetStackBacktrace(iStart + 3, cTotal, dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);
        DbgExTaggedTraceEx(tag, TAG_NONAME, "%s", achSymbol);
    }
}


//+---------------------------------------------------------------
//
//  Function:   GetHResultName
//
//  Synopsis:   Returns a printable string for the given hresult
//
//  Arguments:  [scode] -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

const LPTSTR
GetHResultName(HRESULT r)
{
    LPTSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = _T(#sc); break;

#define CASE_SCODE2(sc,sc2)  \
        case sc: lpstr = _T(#sc) _T("/") _T(#sc2); break;

    switch (r) {
        /* Generic SCODEs */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)

        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_ACCESSDENIED)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_PENDING)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_UNEXPECTED)

        /* SCODEs from all files in alphabetical order */
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(CLASS_E_CLASSNOTAVAILABLE)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(CLASS_E_NOTLICENSED)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE2(CONNECT_E_ADVISELIMIT,SELFREG_E_CLASS)
        CASE_SCODE(CONNECT_E_CANNOTCONNECT)
        CASE_SCODE2(CONNECT_E_NOCONNECTION,PERPROP_E_NOPAGEAVAILABLE/SELFREG_E_TYPELIB)
        CASE_SCODE(CONNECT_E_OVERRIDDEN)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_BAD_PATH)
        CASE_SCODE(CO_E_BAD_SERVER_NAME)
        CASE_SCODE(CO_E_CANT_REMOTE)
        CASE_SCODE(CO_E_CLASS_CREATE_FAILED)
        CASE_SCODE(CO_E_CLSREG_INCONSISTENT)
        CASE_SCODE(CO_E_CREATEPROCESS_FAILURE)
        CASE_SCODE(CO_E_IIDREG_INCONSISTENT)
        CASE_SCODE(CO_E_INIT_CLASS_CACHE)
        CASE_SCODE(CO_E_INIT_MEMORY_ALLOCATOR)
        CASE_SCODE(CO_E_INIT_ONLY_SINGLE_THREADED)
        CASE_SCODE(CO_E_INIT_RPC_CHANNEL)
        CASE_SCODE(CO_E_INIT_SCM_EXEC_FAILURE)
        CASE_SCODE(CO_E_INIT_SCM_FILE_MAPPING_EXISTS)
        CASE_SCODE(CO_E_INIT_SCM_MAP_VIEW_OF_FILE)
        CASE_SCODE(CO_E_INIT_SCM_MUTEX_EXISTS)
        CASE_SCODE(CO_E_INIT_SHARED_ALLOCATOR)
        CASE_SCODE(CO_E_INIT_TLS)
        CASE_SCODE(CO_E_INIT_TLS_CHANNEL_CONTROL)
        CASE_SCODE(CO_E_INIT_TLS_SET_CHANNEL_CONTROL)
        CASE_SCODE(CO_E_INIT_UNACCEPTED_USER_ALLOCATOR)
        CASE_SCODE(CO_E_LAUNCH_PERMSSION_DENIED)
        CASE_SCODE(CO_E_OBJSRV_RPC_FAILURE)
        CASE_SCODE(CO_E_OLE1DDE_DISABLED)
        CASE_SCODE(CO_E_RELEASED)
        CASE_SCODE(CO_E_REMOTE_COMMUNICATION_FAILURE)
        CASE_SCODE(CO_E_RUNAS_CREATEPROCESS_FAILURE)
//        CASE_SCODE(CO_E_RUNAS_INCOMPATIBLE)
        CASE_SCODE(CO_E_RUNAS_LOGON_FAILURE)
        CASE_SCODE(CO_E_RUNAS_SYNTAX)
        CASE_SCODE(CO_E_SCM_ERROR)
        CASE_SCODE(CO_E_SCM_RPC_FAILURE)
        CASE_SCODE(CO_E_SERVER_EXEC_FAILURE)
        CASE_SCODE(CO_E_SERVER_START_TIMEOUT)
        CASE_SCODE(CO_E_SERVER_STOPPING)
        CASE_SCODE(CO_E_START_SERVICE_FAILURE)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_S_NOTALLINTERFACES)
        CASE_SCODE(CTL_E_BADFILEMODE)
        CASE_SCODE(CTL_E_BADFILENAME)
        CASE_SCODE(CTL_E_BADFILENAMEORNUMBER)
        CASE_SCODE(CTL_E_BADRECORDLENGTH)
        CASE_SCODE(CTL_E_BADRECORDNUMBER)
        CASE_SCODE(CTL_E_CANTSAVEFILETOTEMP)
        CASE_SCODE(CTL_E_DEVICEIOERROR)
        CASE_SCODE(CTL_E_DEVICEUNAVAILABLE)
        CASE_SCODE(CTL_E_DISKFULL)
        CASE_SCODE(CTL_E_DISKNOTREADY)
        CASE_SCODE(CTL_E_DIVISIONBYZERO)
        CASE_SCODE(CTL_E_FILEALREADYEXISTS)
        CASE_SCODE(CTL_E_FILEALREADYOPEN)
        CASE_SCODE(CTL_E_FILENOTFOUND)
        CASE_SCODE(CTL_E_GETNOTSUPPORTED)
        CASE_SCODE(CTL_E_GETNOTSUPPORTEDATRUNTIME)
        CASE_SCODE(CTL_E_ILLEGALFUNCTIONCALL)
        CASE_SCODE(CTL_E_INVALIDCLIPBOARDFORMAT)
        CASE_SCODE(CTL_E_INVALIDFILEFORMAT)
        CASE_SCODE(CTL_E_INVALIDPATTERNSTRING)
        CASE_SCODE(CTL_E_INVALIDPICTURE)
        CASE_SCODE(CTL_E_INVALIDPROPERTYARRAYINDEX)
        CASE_SCODE(CTL_E_INVALIDPROPERTYVALUE)
        CASE_SCODE(CTL_E_INVALIDUSEOFNULL)
        CASE_SCODE(CTL_E_NEEDPROPERTYARRAYINDEX)
        CASE_SCODE(CTL_E_OUTOFMEMORY)
        CASE_SCODE(CTL_E_OUTOFSTACKSPACE)
        CASE_SCODE(CTL_E_OUTOFSTRINGSPACE)
        CASE_SCODE(CTL_E_OVERFLOW)
        CASE_SCODE(CTL_E_PATHFILEACCESSERROR)
        CASE_SCODE(CTL_E_PATHNOTFOUND)
        CASE_SCODE(CTL_E_PERMISSIONDENIED)
        CASE_SCODE(CTL_E_PRINTERERROR)
        CASE_SCODE(CTL_E_PROPERTYNOTFOUND)
        CASE_SCODE(CTL_E_REPLACEMENTSTOOLONG)
        CASE_SCODE(CTL_E_SEARCHTEXTNOTFOUND)
        CASE_SCODE(CTL_E_SETNOTPERMITTED)
        CASE_SCODE(CTL_E_SETNOTSUPPORTED)
        CASE_SCODE(CTL_E_SETNOTSUPPORTEDATRUNTIME)
        CASE_SCODE(CTL_E_TOOMANYFILES)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(DISP_E_ARRAYISLOCKED)
        CASE_SCODE(DISP_E_BADCALLEE)
        CASE_SCODE(DISP_E_BADINDEX)
        CASE_SCODE(DISP_E_BADPARAMCOUNT)
        CASE_SCODE(DISP_E_BADVARTYPE)
        CASE_SCODE(DISP_E_EXCEPTION)
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)
        CASE_SCODE(DISP_E_NONAMEDARGS)
        CASE_SCODE(DISP_E_NOTACOLLECTION)
        CASE_SCODE(DISP_E_OVERFLOW)
        CASE_SCODE(DISP_E_PARAMNOTFOUND)
        CASE_SCODE(DISP_E_PARAMNOTOPTIONAL)
        CASE_SCODE(DISP_E_TYPEMISMATCH)
        CASE_SCODE(DISP_E_UNKNOWNINTERFACE)
        CASE_SCODE(DISP_E_UNKNOWNLCID)
        CASE_SCODE(DISP_E_UNKNOWNNAME)
//        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)      // same as OLECMDERR_E_DISABLED
//        CASE_SCODE(DRAGDROP_E_INVALIDHWND)            // same as OLECMDERR_E_NOHELP
//        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)          // same as OLECMDERR_E_NOTSUPPORTED
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE2(DRAGDROP_S_DROP,HLINK_S_DONTHIDE)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_TYMED)
//        CASE_SCODE(HLINK_S_DONTHIDE)                  // same as DRAGDROP_S_DROP
        CASE_SCODE(INET_E_AUTHENTICATION_REQUIRED)
        CASE_SCODE(INET_E_CANNOT_CONNECT)
        CASE_SCODE(INET_E_CANNOT_INSTANTIATE_OBJECT)
        CASE_SCODE(INET_E_CANNOT_LOAD_DATA)
        CASE_SCODE(INET_E_CONNECTION_TIMEOUT)
        CASE_SCODE(INET_E_DATA_NOT_AVAILABLE)
        CASE_SCODE(INET_E_DOWNLOAD_FAILURE)
        CASE_SCODE(INET_E_INVALID_REQUEST)
        CASE_SCODE(INET_E_INVALID_URL)
        CASE_SCODE(INET_E_NO_SESSION)
        CASE_SCODE(INET_E_NO_VALID_MEDIA)
        CASE_SCODE(INET_E_OBJECT_NOT_FOUND)
        CASE_SCODE(INET_E_RESOURCE_NOT_FOUND)
        CASE_SCODE(INET_E_SECURITY_PROBLEM)
        CASE_SCODE(INET_E_UNKNOWN_PROTOCOL)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(MAPI_E_AMBIGUOUS_RECIP)
//        CASE_SCODE(MAPI_E_BAD_CHARWIDTH)
        CASE_SCODE(MAPI_E_BAD_COLUMN)
        CASE_SCODE(MAPI_E_BAD_VALUE)
        CASE_SCODE(MAPI_E_BUSY)
//        CASE_SCODE(MAPI_E_CALL_FAILED)
        CASE_SCODE(MAPI_E_CANCEL)
        CASE_SCODE(MAPI_E_COLLISION)
        CASE_SCODE(MAPI_E_COMPUTED)
        CASE_SCODE(MAPI_E_CORRUPT_DATA)
        CASE_SCODE(MAPI_E_CORRUPT_STORE)
        CASE_SCODE(MAPI_E_DECLINE_COPY)
        CASE_SCODE(MAPI_E_DISK_ERROR)
//        CASE_SCODE(MAPI_E_END_OF_SESSION)
        CASE_SCODE(MAPI_E_EXTENDED_ERROR)
        CASE_SCODE(MAPI_E_FAILONEPROVIDER)
        CASE_SCODE(MAPI_E_FOLDER_CYCLE)
        CASE_SCODE(MAPI_E_HAS_FOLDERS)
        CASE_SCODE(MAPI_E_HAS_MESSAGES)
//        CASE_SCODE(MAPI_E_INTERFACE_NOT_SUPPORTED)
        CASE_SCODE(MAPI_E_INVALID_BOOKMARK)
        CASE_SCODE(MAPI_E_INVALID_ENTRYID)
        CASE_SCODE(MAPI_E_INVALID_OBJECT)
//        CASE_SCODE(MAPI_E_INVALID_PARAMETER)
        CASE_SCODE(MAPI_E_INVALID_TYPE)
//        CASE_SCODE(MAPI_E_LOGON_FAILED)
//        CASE_SCODE(MAPI_E_MISSING_REQUIRED_COLUMN)
        CASE_SCODE(MAPI_E_NETWORK_ERROR)
        CASE_SCODE(MAPI_E_NON_STANDARD)
        CASE_SCODE(MAPI_E_NOT_ENOUGH_DISK)
//        CASE_SCODE(MAPI_E_NOT_ENOUGH_MEMORY)
        CASE_SCODE(MAPI_E_NOT_ENOUGH_RESOURCES)
        CASE_SCODE(MAPI_E_NOT_FOUND)
        CASE_SCODE(MAPI_E_NOT_INITIALIZED)
        CASE_SCODE(MAPI_E_NOT_IN_QUEUE)
        CASE_SCODE(MAPI_E_NOT_ME)
//        CASE_SCODE(MAPI_E_NO_ACCESS)
        CASE_SCODE(MAPI_E_NO_RECIPIENTS)
//        CASE_SCODE(MAPI_E_NO_SUPPORT)
        CASE_SCODE(MAPI_E_NO_SUPPRESS)
        CASE_SCODE(MAPI_E_OBJECT_CHANGED)
        CASE_SCODE(MAPI_E_OBJECT_DELETED)
//        CASE_SCODE(MAPI_E_SESSION_LIMIT)
        CASE_SCODE(MAPI_E_STRING_TOO_LONG)
        CASE_SCODE(MAPI_E_SUBMITTED)
        CASE_SCODE(MAPI_E_TABLE_EMPTY)
        CASE_SCODE(MAPI_E_TABLE_TOO_BIG)
        CASE_SCODE(MAPI_E_TIMEOUT)
        CASE_SCODE(MAPI_E_TOO_BIG)
        CASE_SCODE(MAPI_E_TOO_COMPLEX)
        CASE_SCODE(MAPI_E_TYPE_NO_SUPPORT)
        CASE_SCODE(MAPI_E_UNABLE_TO_ABORT)
        CASE_SCODE(MAPI_E_UNABLE_TO_COMPLETE)
        CASE_SCODE(MAPI_E_UNCONFIGURED)
        CASE_SCODE(MAPI_E_UNEXPECTED_ID)
        CASE_SCODE(MAPI_E_UNEXPECTED_TYPE)
//        CASE_SCODE(MAPI_E_UNKNOWN_ENTRYID)
        CASE_SCODE(MAPI_E_UNKNOWN_FLAGS)
        CASE_SCODE(MAPI_E_USER_CANCEL)
//        CASE_SCODE(MAPI_E_VERSION)
        CASE_SCODE(MAPI_E_WAIT)
        CASE_SCODE(MAPI_W_APPROX_COUNT)
        CASE_SCODE(MAPI_W_CANCEL_MESSAGE)
        CASE_SCODE(MAPI_W_ERRORS_RETURNED)
        CASE_SCODE(MAPI_W_NO_SERVICE)
        CASE_SCODE(MAPI_W_PARTIAL_COMPLETION)
        CASE_SCODE(MAPI_W_POSITION_CHANGED)
        CASE_SCODE(MEM_E_INVALID_LINK)
        CASE_SCODE(MEM_E_INVALID_ROOT)
        CASE_SCODE(MEM_E_INVALID_SIZE)
        CASE_SCODE(MK_E_ENUMERATION_FAILED)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_NOPREFIX)
        CASE_SCODE(MK_E_NOSTORAGE)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(NTE_BAD_ALGID)
        CASE_SCODE(NTE_BAD_DATA)
        CASE_SCODE(NTE_BAD_FLAGS)
        CASE_SCODE(NTE_BAD_HASH)
        CASE_SCODE(NTE_BAD_HASH_STATE)
        CASE_SCODE(NTE_BAD_KEY)
        CASE_SCODE(NTE_BAD_KEYSET)
        CASE_SCODE(NTE_BAD_KEYSET_PARAM)
        CASE_SCODE(NTE_BAD_KEY_STATE)
        CASE_SCODE(NTE_BAD_LEN)
        CASE_SCODE(NTE_BAD_PROVIDER)
        CASE_SCODE(NTE_BAD_PROV_TYPE)
        CASE_SCODE(NTE_BAD_PUBLIC_KEY)
        CASE_SCODE(NTE_BAD_SIGNATURE)
        CASE_SCODE(NTE_BAD_TYPE)
        CASE_SCODE(NTE_BAD_UID)
        CASE_SCODE(NTE_BAD_VER)
        CASE_SCODE(NTE_DOUBLE_ENCRYPT)
        CASE_SCODE(NTE_EXISTS)
        CASE_SCODE(NTE_FAIL)
        CASE_SCODE(NTE_KEYSET_ENTRY_BAD)
        CASE_SCODE(NTE_KEYSET_NOT_DEF)
        CASE_SCODE(NTE_NOT_FOUND)
        CASE_SCODE(NTE_NO_KEY)
        CASE_SCODE(NTE_NO_MEMORY)
//        CASE_SCODE(NTE_OP_OK)                         // same as S_OK
        CASE_SCODE(NTE_PERM)
        CASE_SCODE(NTE_PROVIDER_DLL_FAIL)
        CASE_SCODE(NTE_PROV_DLL_NOT_FOUND)
        CASE_SCODE(NTE_PROV_TYPE_ENTRY_BAD)
        CASE_SCODE(NTE_PROV_TYPE_NOT_DEF)
        CASE_SCODE(NTE_PROV_TYPE_NO_MATCH)
        CASE_SCODE(NTE_SIGNATURE_FILE_BAD)
        CASE_SCODE(NTE_SYS_ERR)
        CASE_SCODE(OLECMDERR_E_CANCELED)
        CASE_SCODE2(OLECMDERR_E_DISABLED,DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE2(OLECMDERR_E_NOHELP,DRAGDROP_E_INVALIDHWND)
        CASE_SCODE2(OLECMDERR_E_NOTSUPPORTED,DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(OLECMDERR_E_UNKNOWNGROUP)
        CASE_SCODE(OLEOBJ_E_INVALIDVERB)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CANTCONVERT)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOSTORAGE)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOT_INPLACEACTIVE)
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_USEREG)
//        CASE_SCODE(PERPROP_E_NOPAGEAVAILABLE)         // same as CONNECT_E_NOCONNECTION
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(RPC_E_ACCESS_DENIED)
        CASE_SCODE(RPC_E_ATTEMPTED_MULTITHREAD)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CALL_COMPLETE)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CANTCALLOUT_AGAIN)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_ININPUTSYNCCALL)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CHANGED_MODE)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
        CASE_SCODE(RPC_E_DISCONNECTED)
        CASE_SCODE(RPC_E_FAULT)
        CASE_SCODE(RPC_E_INVALIDMETHOD)
        CASE_SCODE(RPC_E_INVALID_CALLDATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_INVALID_EXTENSION)
        CASE_SCODE(RPC_E_INVALID_HEADER)
        CASE_SCODE(RPC_E_INVALID_IPID)
        CASE_SCODE(RPC_E_INVALID_OBJECT)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_NOT_REGISTERED)
        CASE_SCODE(RPC_E_NO_GOOD_SECURITY_PACKAGES)
        CASE_SCODE(RPC_E_OUT_OF_RESOURCES)
        CASE_SCODE(RPC_E_REMOTE_DISABLED)
        CASE_SCODE(RPC_E_RETRY)
        CASE_SCODE(RPC_E_SERVERCALL_REJECTED)
        CASE_SCODE(RPC_E_SERVERCALL_RETRYLATER)
        CASE_SCODE(RPC_E_SERVERFAULT)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_DIED)
        CASE_SCODE(RPC_E_SERVER_DIED_DNE)
        CASE_SCODE(RPC_E_SYS_CALL_FAILED)
        CASE_SCODE(RPC_E_THREAD_NOT_INIT)
        CASE_SCODE(RPC_E_TOO_LATE)
        CASE_SCODE(RPC_E_UNEXPECTED)
        CASE_SCODE(RPC_E_UNSECURE_CALL)
        CASE_SCODE(RPC_E_VERSION_MISMATCH)
        CASE_SCODE(RPC_E_WRONG_THREAD)
        CASE_SCODE(RPC_S_CALLPENDING)
        CASE_SCODE(RPC_S_WAITONTIMER)
//        CASE_SCODE(SELFREG_E_CLASS)                   // same as CONNECT_E_ADVISELIMIT
//        CASE_SCODE(SELFREG_E_TYPELIB)                 // same as CONNECT_E_NOCONNECTION
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_BADBASEADDRESS)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_DOCFILECORRUPT)
        CASE_SCODE(STG_E_EXTANTMARSHALLINGS)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_INCOMPLETE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_NOTFILEBASEDSTORAGE)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_PROPSETMISMATCHED)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_SHAREREQUIRED)
        CASE_SCODE(STG_E_SHAREVIOLATION)
        CASE_SCODE(STG_E_TERMINATED)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_S_BLOCK)
        CASE_SCODE(STG_S_CONVERTED)
        CASE_SCODE(STG_S_MONITORING)
        CASE_SCODE(STG_S_RETRYNOW)
        CASE_SCODE(TRUST_E_ACTION_UNKNOWN)
        CASE_SCODE(TRUST_E_PROVIDER_UNKNOWN)
        CASE_SCODE(TRUST_E_SUBJECT_FORM_UNKNOWN)
        CASE_SCODE(TRUST_E_SUBJECT_NOT_TRUSTED)
        CASE_SCODE(TYPE_E_AMBIGUOUSNAME)
        CASE_SCODE(TYPE_E_BADMODULEKIND)
        CASE_SCODE(TYPE_E_BUFFERTOOSMALL)
        CASE_SCODE(TYPE_E_CANTCREATETMPFILE)
        CASE_SCODE(TYPE_E_CANTLOADLIBRARY)
        CASE_SCODE(TYPE_E_CIRCULARTYPE)
        CASE_SCODE(TYPE_E_DLLFUNCTIONNOTFOUND)
        CASE_SCODE(TYPE_E_DUPLICATEID)
        CASE_SCODE(TYPE_E_ELEMENTNOTFOUND)
        CASE_SCODE(TYPE_E_INCONSISTENTPROPFUNCS)
        CASE_SCODE(TYPE_E_INVALIDID)
        CASE_SCODE(TYPE_E_INVALIDSTATE)
        CASE_SCODE(TYPE_E_INVDATAREAD)
        CASE_SCODE(TYPE_E_IOERROR)
        CASE_SCODE(TYPE_E_LIBNOTREGISTERED)
        CASE_SCODE(TYPE_E_NAMECONFLICT)
        CASE_SCODE(TYPE_E_OUTOFBOUNDS)
        CASE_SCODE(TYPE_E_QUALIFIEDNAMEDISALLOWED)
        CASE_SCODE(TYPE_E_REGISTRYACCESS)
        CASE_SCODE(TYPE_E_SIZETOOBIG)
        CASE_SCODE(TYPE_E_TYPEMISMATCH)
        CASE_SCODE(TYPE_E_UNDEFINEDTYPE)
        CASE_SCODE(TYPE_E_UNKNOWNLCID)
        CASE_SCODE(TYPE_E_UNSUPFORMAT)
        CASE_SCODE(TYPE_E_WRONGTYPEKIND)
        CASE_SCODE(VIEW_E_DRAW)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)

        default:
            lpstr = _T("UNKNOWN SCODE");
    }

#undef CASE_SCODE
#undef CASE_SCODE2

    return lpstr;
}



//+---------------------------------------------------------------------------
//
//  Function:   hrvsnprintf
//
//  Synopsis:   Prints a string to a buffer, interpreting %hr as a
//              format string for an HRESULT.
//
//  Arguments:  [achBuf]    -- The buffer to print into.
//              [cchBuf]    -- The size of the buffer.
//              [pstrFmt]   -- The format string.
//              [valMarker] -- List of arguments to format string.
//
//  Returns:    Number of characters printed to the buffer not including
//              the terminating NULL.  In case of buffer overflow, returns
//              -1.
//
//  Modifies:   [achBuf]
//
//----------------------------------------------------------------------------

int
hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker)
{
    static char achFmtHR[] = "<%ls (0x%lx)>";
    static char achHRID[] = "%hr";

    char            achFmt[1024];
    int             cch;
    int             cchTotal;
    char *          lpstr;
    char *          lpstrLast;
    int             cFormat;
    HRESULT         hrVA;

    // We stomp on the string, so copy to writeable memory.

    strcpy(achFmt, pstrFmt);

    //
    // Scan for %hr tokens.  If found, print the corresponding
    // hresult into the buffer.
    //

    cch = 0;
    cchTotal = 0;
    cFormat = 0;
    lpstrLast = achFmt;
    lpstr = achFmt;
    while (*lpstr)
    {
        if (*lpstr != '%')
        {
            lpstr++;
        }
        else if (lpstr[1] == '%')
        {
            lpstr += 2;
        }
        else if (strncmp(lpstr, achHRID, ARRAY_SIZE(achHRID) - 1))
        {
            cFormat++;
            lpstr++;
        }
        else
        {
            //
            // Print format string up to the hresult.
            //

            * lpstr = 0;
            cch = _vsnprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    lpstrLast,
                    valMarker);
            * lpstr = '%';
            if (cch == -1)
                break;

            cchTotal += cch;

            //
            // Advance valMarker for each printed format.
            //

            while (cFormat-- > 0)
            {
                //
                // NOTE (adams): Won't work for floats, as their stack size
                // is not four bytes.
                //

                va_arg(valMarker, void *);
            }

            //
            // Print hresult into buffer.
            //

            hrVA = va_arg(valMarker, HRESULT);
            cch = _snprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    achFmtHR,
                    GetHResultName(hrVA),
                    hrVA);
            if (cch == -1)
                break;

            cchTotal += cch;
            lpstr += ARRAY_SIZE(achHRID) - 1;
            lpstrLast = lpstr;
        }
    }

    if (cch != -1)
    {
        cch = _vsnprintf(
                achBuf + cchTotal,
                cchBuf - cchTotal,
                lpstrLast,
                valMarker);
    }

    return (cch == -1) ? -1 : cchTotal + cch;
}


// This function uses ANSII strings so I use C RTL functions for string manipulation
// instead of the _t... fucntions
void WINAPI
DbgExOpenLogFile(LPCSTR szFName)
{
    char    rgch[MAX_PATH];

#ifdef _MAC
    DWORD dwCt = 0x74747874;  // 'ttxt'
    DWORD dwFtype = 0x54455854; // 'TEXT'
    DWORD dwOldct, dwOldftype;

    dwOldct = SetDefaultCreatorType(dwCt);
    dwOldftype = SetDefaultFileType(dwFtype);
#endif

    if(szFName == NULL || strlen(szFName) == 0)
    {
        // log file name or path is not specified, we must use the default ones
        if (g_hinstMain)
        {
            // Get program path and file name and replace the extension with the
            // log file extension
#ifndef _MAC
            UINT    cch = (UINT) GetModuleFileNameA(g_hModule, rgch, sizeof(rgch));
#ifdef UNIX
            strcat(rgch, szDbgOutFileExt);
#else
            Assert(rgch[cch - 4] == '.');
            strcpy(&rgch[cch - 4], szDbgOutFileExt);
#endif
#else
            CHAR   achAppLoc[MAX_PATH];
            DWORD   dwRet;
            short   iRet;

            dwRet = GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc));
            Assert (dwRet != 0);

            iRet = GetFileTitleA(achAppLoc,rgch,sizeof(rgch));
            Assert(iRet == 0);

            strcat (rgch, szDbgOutFileExt);
#endif
        }
        else
        {
            // Use the dewfault file name in default directory
            strcpy(rgch, szDbgOutFileName);
        }

    }
    else
    {

        // check, and if file name is not specified in the command line append the
        // default log file name to the specified path
        int nLen = strlen(szFName);

        strncpy(rgch, szFName, sizeof(rgch) / sizeof(rgch[0]) - 1);
        rgch[sizeof(rgch) / sizeof(rgch[0]) - 1] = 0;

        if(szFName[nLen - 1] == '\\')
        {
            strcat(rgch, szDbgOutFileName);
        }

    }

    s_hFileLog = CreateFileA(rgch, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS,
        0, (HANDLE) NULL);

    if (s_hFileLog != INVALID_HANDLE_VALUE)
    {
        wsprintfA(rgch, ">>>>> Start logging" SZ_NEWLINE);
        SetFilePointer(s_hFileLog, 0, NULL, FILE_END);
        SpitSzToDisk(rgch);
    }
    else
    {
        char msg[200];
        _snprintf(msg, sizeof(msg) / sizeof(msg[0]), "Cannot create the log file \"%s\"" SZ_NEWLINE, rgch);
        MessageBoxA(NULL, msg, "Error", MB_OK);
    }

#ifdef _MAC
        SetDefaultCreatorType(dwOldct);
        SetDefaultFileType(dwOldftype);
#endif
}

DWORD WINAPI
DbgExGetVersion()
{
    return(g_fDetached ? 0 : MSHTMDBG_API_VERSION);
}

BOOL WINAPI
DbgExIsFullDebug()
{
    return(TRUE);
}

BOOL WINAPI
DbgExGetChkStkFill(DWORD * pdwFill)
{
    *pdwFill = GetPrivateProfileIntA("chkstk", "fill", 0xCCCCCCCC, "mshtmdbg.ini");
    return(DbgExIsTagEnabled(tagStackSpew));
}

void WINAPI
DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
    int i;

    for (i = 0; i < ARRAY_SIZE(g_rgDllHandle); ++i)
    {
        if (pfnDllMain == NULL)
        {
            if (g_rgDllHandle[i] == hDllHandle)
            {
                g_rgDllHandle[i] = NULL;
                g_rgDllMain[i] = NULL;
                break;
            }
        }
        else
        {
            if (g_rgDllHandle[i] == NULL)
            {
                g_rgDllHandle[i] = hDllHandle;
                g_rgDllMain[i] = pfnDllMain;
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\meter.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:       meter.cxx
//
//  Contents:   Performance metering
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#include <stddef.h>
#endif

void __cdecl hprintf(HANDLE hfile, char * pchFmt, ...);

CRITICAL_SECTION    g_csMeter;
static BOOL         g_fBringToFront = FALSE;
static HWND         ghWnd           = NULL;
static HBRUSH       ghbrBkgnd       = NULL;
static HANDLE       ghThread        = NULL;
static BOOL         fDlgUp          = FALSE;
static DWORD        rgbWindowColor  = 0xFF000000;    // variables for the current
static DWORD        rgbHiliteColor  = 0xFF000000;    // system color settings.
static DWORD        rgbWindowText   = 0xFF000000;    // on a WM_SYSCOLORCHANGE
static DWORD        rgbHiliteText   = 0xFF000000;    // we check to see if we need
static DWORD        rgbGrayText     = 0xFF000000;    // to reload our bitmap.
static DWORD        rgbDDWindow     = 0xFF000000;    //
static DWORD        rgbDDHilite     = 0xFF000000;    // 0xFF000000 is an invalid RGB
static BOOL         g_fEnabled      = FALSE;
static BOOL         g_fAutoDump     = FALSE;
static BOOL         g_fAutoOpen     = FALSE;
static BOOL         g_fAutoDelete   = TRUE;
static BOOL         g_fSimpleDump   = TRUE;
static DWORD        g_dwItemCount   = 0;
static DWORD        g_cRefresh      = 0;
static BOOL         g_fLogging      = FALSE;
static LONG         g_lMtAddTrap    = 0;
static BOOL         g_fIntervalOOM  = FALSE;
static BOOL         g_fAllOOM       = TRUE;
static BOOL         g_fBreakOnOOM   = FALSE;
static DWORD        g_dwOOMCount    = 0;
static DWORD        g_dwOOMCycle    = 0;

struct MTAG
{
    MTAG *  pmtagNext;
    MTAG *  pmtagParent;
    char *  pchTag;
    char *  pchOwner;
    char *  pchDesc;
    LONG    lCntExc;
    LONG_PTR lValExc;
    LONG    lCntInc;
    LONG_PTR lValInc;
    DWORD   dwFlags;
    char    ach[1];
};

struct LENT
{
    FILETIME    ft;
    LONG        lCnt;
    LONG        lVal;
    MTAG *      pmtag;
};

#define LBLKENT     8192

struct LBLK
{
    LBLK *  plblkNext;
    LONG    cEnt;
    LENT    rglent[LBLKENT];
};

#define MTF_HASCHILDREN         0x00000001
#define MTF_VALUESDIRTY         0x00000002
#define MTF_EXCLVALUESDIRTY     0x00000004
#define MTF_COLLAPSED           0x00000008
#define MTF_BREAKPOINTEXCL      0x00000010
#define MTF_BREAKPOINTINCL      0x00000020
#define MTF_SIMOUTOFMEMEXCL     0x00000040
#define MTF_SIMOUTOFMEMINCL     0x00000080

#define MTAG_MAXDESCSIZE        40

MTAG *  g_pmtagHead;
LBLK *  g_plblkHead;
LBLK *  g_plblkTail;
LONG    g_cLogEntry;
LONG    g_cMTagByName;
MTAG ** g_aMTagByName;
LONG    g_cMTagOrphanByParent;
MTAG ** g_aMTagOrphanByParent;

int
MTagCompareName(void * pv1, void *pv2)
{
    return(lstrcmpA(((MTAG *)pv1)->pchTag, (char *)pv2));
}

int
MTagCompareOwner(void * pv1, void * pv2)
{
    return(lstrcmpA(((MTAG *)pv1)->pchOwner, (char *)pv2));
}

BOOL
FindPtrArray(LONG * pcCount, void * pAry, int (*pfnCmp)(void *, void *), void * pvArg, int * piLocFind)
{
    int     iEntLow, iEntHigh, iEntMid, c;
    void ** ppvAry = *(void ***)pAry;
    void *  pvMid;
    BOOL    fResult;

    iEntLow  = 0;
    fResult  = FALSE;
    iEntHigh = *pcCount - 1;

    while (iEntLow <= iEntHigh)
    {
        iEntMid = (iEntLow + iEntHigh) >> 1;
        pvMid  = ppvAry[iEntMid];
        c = pfnCmp(pvMid, pvArg);
        if (c == 0)
        {
            iEntLow = iEntMid;
            fResult = TRUE;
            break;
        }
        else if (c < 0)
            iEntLow = iEntMid + 1;
        else
            iEntHigh = iEntMid - 1;
    }

    *piLocFind = iEntLow;
    return(fResult);
}

void
InsPtrArray(LONG * pcCount, void * ppvAry, int iIns, void * pvIns)
{
    if ((*pcCount & 255) == 0 && (*pcCount || *(void **)ppvAry == NULL))
    {
        void * pvNew = (void *)LocalAlloc(LMEM_FIXED, (*pcCount + 256) * sizeof(void *));

        if (pvNew == NULL)
            return;

        memcpy(pvNew, *(void **)ppvAry, *pcCount * sizeof(void *));

        if (*(void **)ppvAry)
            LocalFree(*(void **)ppvAry);

        *(void **)ppvAry = pvNew;
    }

    void ** ppvIns = *(void ***)ppvAry + iIns;

    memmove(ppvIns + 1, ppvIns, (*pcCount - iIns) * sizeof(void *));
    *ppvIns = pvIns;
    *pcCount += 1;
}

void
DelPtrArray(LONG * pcCount, void * ppvAry, int iDel, int cDel)
{
    void ** ppvDel = *(void ***)ppvAry + iDel;
    memmove(ppvDel, ppvDel + cDel, (*pcCount - (iDel + cDel)) * sizeof(void *));
    *pcCount -= cDel;
}

BOOL
FindMTagByName(char * pchName, int * piLoc)
{
    return(FindPtrArray(&g_cMTagByName, &g_aMTagByName, MTagCompareName, pchName, piLoc));
}

void
InsMTagByName(int iLocIns, MTAG * pmtagIns)
{
    InsPtrArray(&g_cMTagByName, &g_aMTagByName, iLocIns, pmtagIns);
}

BOOL
FindMTagOrphanByParent(char * pchOwner, BOOL fFirst, int * piLoc)
{
    BOOL fFound = FindPtrArray(&g_cMTagOrphanByParent, &g_aMTagOrphanByParent, MTagCompareOwner, pchOwner, piLoc);

    if (fFound && fFirst)
    {
        while (*piLoc > 0)
        {
            MTAG * pmtag = g_aMTagOrphanByParent[*piLoc - 1];

            if (lstrcmpA(pchOwner, pmtag->pchOwner) != 0)
                break;

            *piLoc -= 1;
        }
    }

    return(fFound);
}

void
InsMTagOrphan(MTAG * pmtagIns)
{
    int iLocIns;
    FindMTagOrphanByParent(pmtagIns->pchOwner, FALSE, &iLocIns);
    InsPtrArray(&g_cMTagOrphanByParent, &g_aMTagOrphanByParent, iLocIns, pmtagIns);
}

void
DelMTagOrphanRange(int iLocDel, int cLocDel)
{
    DelPtrArray(&g_cMTagOrphanByParent, &g_aMTagOrphanByParent, iLocDel, cLocDel);
}

LENT *
GetLogEntry()
{
    LBLK * plblk = g_plblkTail;

    if (!plblk || plblk->cEnt == LBLKENT)
    {
        plblk = (LBLK *)LocalAlloc(LMEM_FIXED, sizeof(LBLK));

        if (plblk == NULL)
        {
            return(NULL);
        }

        plblk->plblkNext = NULL;
        plblk->cEnt      = 0;

        if (g_plblkTail)
            g_plblkTail->plblkNext = plblk;
        if (g_plblkHead == NULL)
            g_plblkHead = plblk;

        g_plblkTail = plblk;
    }

    g_cLogEntry += 1;

    return(&plblk->rglent[plblk->cEnt++]);
}

PERFMETERTAG WINAPI
DbgExMtRegister(char * szTag, char * szOwner, char * szDesc)
{
    int cbTag   = lstrlenA(szTag) + 1;
    int cbOwner = lstrlenA(szOwner) + 1;
    int cbDesc  = lstrlenA(szDesc) + 1;
    MTAG * pmtag = NULL, * pmtagT, * pmtagP;
    int iLoc, cLoc;

    EnterCriticalSection(&g_csMeter);

    if (!FindMTagByName(szTag, &iLoc))
    {
        pmtag = (MTAG *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, offsetof(MTAG, ach) + cbTag + cbOwner + cbDesc);
        if (pmtag == NULL)
        {
            AssertSz(0, "Insufficient memory to debug.");
            LeaveCriticalSection(&g_csMeter);
            return (PERFMETERTAG)pmtag;
        }

        pmtag->pmtagNext    = g_pmtagHead;
        g_pmtagHead         = pmtag;
        pmtag->pchTag       = pmtag->ach;
        pmtag->pchOwner     = pmtag->ach + cbTag;
        pmtag->pchDesc      = pmtag->pchOwner + cbOwner;

        lstrcpyA(pmtag->pchTag, szTag);
        lstrcpyA(pmtag->pchOwner, szOwner);
        lstrcpyA(pmtag->pchDesc, szDesc);

        InsMTagByName(iLoc, pmtag);

        if (FindMTagByName(szOwner, &iLoc))
        {
            pmtagT = g_aMTagByName[iLoc];

            AssertSz(pmtag != pmtagT, "Infinite loop in Meters");
            pmtag->pmtagParent = pmtagT;

            if (!(pmtagT->dwFlags & MTF_HASCHILDREN))
            {
                pmtagT->dwFlags |= MTF_HASCHILDREN|MTF_COLLAPSED;
            }
        }
        else
        {
            InsMTagOrphan(pmtag);
        }

        if (FindMTagOrphanByParent(szTag, TRUE, &iLoc))
        {
            for (cLoc = 0; iLoc < g_cMTagOrphanByParent; ++iLoc, ++cLoc)
            {
                pmtagT = g_aMTagOrphanByParent[iLoc];

                if (lstrcmpA(pmtagT->pchOwner, szTag) == 0)
                {
                    AssertSz(pmtagT != pmtag, "Infinite loop in Meters");

                    pmtagT->pmtagParent = pmtag;
                    pmtag->dwFlags |= MTF_HASCHILDREN|MTF_COLLAPSED;

                    if (pmtagT->lCntInc || pmtagT->lValInc)
                    {
                        for (pmtagP = pmtag; pmtagP; pmtagP = pmtagP->pmtagParent)
                        {
                            pmtagP->lCntInc += pmtagT->lCntInc;
                            pmtagP->lValInc += pmtagT->lValInc;
                            pmtagP->dwFlags |= MTF_VALUESDIRTY;
                        }
                    }
                }
                else
                {
                    break;
                }
            }

            DelMTagOrphanRange(iLoc - cLoc, cLoc);
        }
    }
    else
    {
        pmtag = g_aMTagByName[iLoc];
    }

    if (ghWnd)
    {
        g_cRefresh = 3;
    }

    LeaveCriticalSection(&g_csMeter);

    return((PERFMETERTAG)pmtag);
}

void WINAPI
DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
    BOOL fBreak = FALSE;

    if (    (g_lMtAddTrap > 0 && lVal > g_lMtAddTrap)
        ||  (g_lMtAddTrap < 0 && lVal < g_lMtAddTrap))
    {
        fBreak = TRUE;
    }

    if (mt)
    {
        EnterCriticalSection(&g_csMeter);

        MTAG * pmtag = (MTAG *)mt;
        LENT * plent = g_fLogging ? GetLogEntry() : NULL;

        if (plent)
        {
            FILETIME ft;

            GetSystemTimeAsFileTime(&ft);
            FileTimeToLocalFileTime(&ft, &plent->ft);

            plent->pmtag = pmtag;
            plent->lCnt  = lCnt;
            plent->lVal  = lVal;
        }

        if (pmtag->dwFlags & MTF_BREAKPOINTEXCL)
        {
            fBreak = TRUE;
        }

        pmtag->lCntExc += lCnt;
        pmtag->lValExc += lVal;
        pmtag->dwFlags |= MTF_EXCLVALUESDIRTY;

        for (; pmtag; pmtag = pmtag->pmtagParent)
        {
            if (pmtag->dwFlags & MTF_BREAKPOINTINCL)
            {
                fBreak = TRUE;
            }

            pmtag->lCntInc += lCnt;
            pmtag->lValInc += lVal;
            pmtag->dwFlags |= MTF_VALUESDIRTY;
        }

        LeaveCriticalSection(&g_csMeter);
    }

    if (fBreak && !(GetAsyncKeyState(VK_CONTROL) & 0x8000))
    {
        DebugBreak();
    }
}

void WINAPI
DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
    if (mt)
    {
        EnterCriticalSection(&g_csMeter);

        MTAG * pmtag = (MTAG *)mt;

        lVal = lVal < 0 ? 0 : lVal - pmtag->lValExc;
        lCnt = lCnt < 0 ? 0 : lCnt - pmtag->lCntExc;

        DbgExMtAdd(mt, lCnt, lVal);

        LeaveCriticalSection(&g_csMeter);
    }
}

BOOL WINAPI
DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue)
{
    BOOL fResult = FALSE;
    BOOL fTagged = FALSE;

    if (mt)
    {
        EnterCriticalSection(&g_csMeter);

        MTAG *pmtag = (MTAG *)mt;

        if (pmtag->dwFlags & MTF_SIMOUTOFMEMEXCL)
        {
            fTagged = TRUE;
        }

        for (; pmtag && !fTagged; pmtag = pmtag->pmtagParent)
        {
            if (pmtag->dwFlags & MTF_SIMOUTOFMEMINCL)
                fTagged = TRUE;
        }

        if (    g_fIntervalOOM && g_fAllOOM && ++g_dwOOMCount % g_dwOOMCycle == 0
            ||  g_fIntervalOOM && !g_fAllOOM && fTagged && ++g_dwOOMCount % g_dwOOMCycle == 0
            ||  !g_fIntervalOOM && fTagged)
        {
            char ach[512];
            wsprintfA(ach, "MSHTMDBG: Failing memory allocation for %s (%s)\r\n",
                      ((MTAG *)mt)->pchTag, ((MTAG *)mt)->pchDesc);
            OutputDebugStringA(ach);
            fResult = TRUE;
        }

        LeaveCriticalSection(&g_csMeter);
    }

    if (g_fBreakOnOOM && fResult)
        DebugBreak();

    return fResult;
}

char * WINAPI
DbgExMtGetName(PERFMETERTAG mt)
{
    return(mt ? ((MTAG *)mt)->pchTag : "");
}

char * WINAPI
DbgExMtGetDesc(PERFMETERTAG mt)
{
    return(mt ? ((MTAG *)mt)->pchDesc : "");
}

PERFMETERTAG WINAPI
DbgExMtLookupMeter(char * szTag)
{
    MTAG * pmtag = NULL;
    int iLoc;

    EnterCriticalSection(&g_csMeter);

    if (FindMTagByName(szTag, &iLoc))
    {
        pmtag = g_aMTagByName[iLoc];
    }

    LeaveCriticalSection(&g_csMeter);

    return((PERFMETERTAG)pmtag);
}

long WINAPI
DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive)
{
    if (mt)
    {
        return fExclusive ? ((MTAG *)mt)->lCntExc : ((MTAG *)mt)->lCntInc;
    }

    return 0;
}

long WINAPI
DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive)
{
    if (mt)
    {
        return fExclusive ? ((MTAG *)mt)->lValExc : ((MTAG *)mt)->lValInc;
    }

    return 0;
}

// Meter Monitor Window -------------------------------------------------------

DWORD WINAPI    MeterMonitorThread(LPVOID lpv);

INT_PTR WINAPI  MeterMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void            SetWindowTitle(HWND hWnd, LPSTR lpcText);
static void     RefreshView(HWND hWnd);
static void     MeterListNotify(WORD wNotify, HWND  hWnd);

void            MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
static void     DrawItem(LPDRAWITEMSTRUCT pdis);
static void     OutTextFormat(LPDRAWITEMSTRUCT pdis);
static void     SetRGBValues(void);

void
MtDoOpenMonitor(BOOL fBringToFront)
{
    if (!ghThread)
    {
        EnterCriticalSection(&g_csMeter);

        if (!ghThread)
        {
            DWORD dwThreadId=NULL;

            fDlgUp = TRUE;
            g_fBringToFront = fBringToFront;

            ghThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0,
                (LPTHREAD_START_ROUTINE)MeterMonitorThread,
                NULL, 0, &dwThreadId);
            AssertSz(dwThreadId, "Failed to create debug thread.");
        }

        LeaveCriticalSection(&g_csMeter);
    }
    else if (fBringToFront && ghWnd)
    {
        ShowWindow(ghWnd, SW_SHOWNORMAL);
        BringWindowToTop(ghWnd);
    }
}

void WINAPI
DbgExMtOpenMonitor()
{
    MtDoOpenMonitor(TRUE);
}

DWORD WINAPI
MeterMonitorThread(LPVOID)
{
    ghbrBkgnd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));

    DialogBoxA(g_hinstMain, MAKEINTRESOURCEA(IDD_PERFMETER), NULL, MeterMonDlgProc);

    DeleteObject(ghbrBkgnd);
    CloseHandle(ghThread);
    ghThread = NULL;

    return 0;
}

int __cdecl MTagCompareDesc(const void * pv1, const void * pv2)
{
    MTAG * pmt1 = *(MTAG **)pv1;
    MTAG * pmt2 = *(MTAG **)pv2;
    return(lstrcmpA(pmt1->pchDesc, pmt2->pchDesc));
}

int __cdecl MTagCompareTag(const void * pv1, const void * pv2)
{
    MTAG * pmt1 = *(MTAG **)pv1;
    MTAG * pmt2 = *(MTAG **)pv2;
    return(lstrcmpA(pmt1->pchTag, pmt2->pchTag));
}

void
PopulateList(HWND hWnd, MTAG * pmtagPar)
{
    MTAG * apmtag[512], *pmtag, ** ppmtag;
    UINT   cpmtag = 0;

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        if (    pmtag->pmtagParent == pmtagPar
            &&  cpmtag < ARRAY_SIZE(apmtag))
        {
            apmtag[cpmtag++] = pmtag;
        }
    }

    if (cpmtag > 0)
    {
        qsort(apmtag, cpmtag, sizeof(MTAG *), MTagCompareDesc);

        for (ppmtag = apmtag; cpmtag > 0; --cpmtag, ++ppmtag)
        {
            g_dwItemCount += 1;
            SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_ADDSTRING, 0, (LPARAM)*ppmtag);

            if (g_dwItemCount != (DWORD)SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_GETCOUNT, 0, 0))
            {
                g_dwItemCount -= 1;
            }

            if (((*ppmtag)->dwFlags & (MTF_HASCHILDREN|MTF_COLLAPSED)) == MTF_HASCHILDREN)
            {
                g_dwItemCount += 1;
                SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_ADDSTRING, 0, (LPARAM)*ppmtag | 1L);
                PopulateList(hWnd, *ppmtag);
            }
        }
    }
}

void
DumpTag(HANDLE hfile, MTAG * pmtag, BOOL fExcl)
{
    LONG lCnt = fExcl ? pmtag->lCntExc : pmtag->lCntInc;
    LONG lVal = fExcl ? pmtag->lValExc : pmtag->lValInc;

    hprintf(hfile, "%s%s\t%s\t\"%s%s\"\t%ld\t%ld\r\n",
        pmtag->pchTag, fExcl ? "_excl" : "",
        fExcl ? pmtag->pchTag : pmtag->pchOwner,
        pmtag->pchDesc, fExcl ? " (Excl)" : "",
        lCnt, lVal);
}

void
DumpList(HANDLE hfile, MTAG * pmtagPar)
{
    MTAG *  apmtag[512], *pmtag, ** ppmtag;
    UINT    cpmtag = 0;

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        if (    pmtag->pmtagParent == pmtagPar
            &&  cpmtag < ARRAY_SIZE(apmtag))
        {
            apmtag[cpmtag++] = pmtag;
        }
    }

    if (cpmtag > 0)
    {
        qsort(apmtag, cpmtag, sizeof(MTAG *), MTagCompareTag);

        for (ppmtag = apmtag; cpmtag > 0; --cpmtag, ++ppmtag)
        {
            if ((*ppmtag)->lCntInc == 0 && (*ppmtag)->lValInc == 0)
                continue;

            DumpTag(hfile, *ppmtag, FALSE);

            if ((*ppmtag)->dwFlags & MTF_HASCHILDREN)
            {
                if ((*ppmtag)->lCntExc || (*ppmtag)->lValExc)
                {
                    DumpTag(hfile, *ppmtag, TRUE);
                }

                DumpList(hfile, *ppmtag);
            }
        }
    }
}

void WINAPI
MtLogClear()
{
    EnterCriticalSection(&g_csMeter);

    LBLK *  plblk = g_plblkHead;
    LBLK *  plblkNext;

    for (; plblk; plblk = plblkNext)
    {
        plblkNext = plblk->plblkNext;
        LocalFree(plblk);
    }

    g_plblkHead = NULL;
    g_plblkTail = NULL;
    g_cLogEntry = 0;

    LeaveCriticalSection(&g_csMeter);
}

void
DumpLog(HANDLE hfile)
{
    LBLK *  plblk = g_plblkHead;
    LENT *  plent;
    LONG    cEnt;
    LONG    lValSum = 0;

    for (; plblk; plblk = plblk->plblkNext)
    {
        for (cEnt = plblk->cEnt, plent = plblk->rglent; cEnt > 0; --cEnt, ++plent)
        {
            MTAG *      pmtag = plent->pmtag;
            SYSTEMTIME  st;

            FileTimeToSystemTime(&plent->ft, &st);

            lValSum += plent->lVal;

            hprintf(hfile, "%02d:%02d:%02d.%03d\t%s\t\"%s\"\t%ld\t%ld\t%ld\r\n",
                st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,
                pmtag->pchTag, pmtag->pchDesc, plent->lCnt, plent->lVal, lValSum);
        }
    }
}

void WINAPI
DbgExMtLogDump(LPSTR pchFile)
{
    FILETIME ft1, ft2;
    SYSTEMTIME st;

    EnterCriticalSection(&g_csMeter);

    HANDLE hfile = INVALID_HANDLE_VALUE;

    hfile = CreateFileA(pchFile, GENERIC_WRITE,
                FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        goto ret;

    SetFilePointer(hfile, 0, NULL, FILE_BEGIN);
    SetEndOfFile(hfile);
    GetSystemTimeAsFileTime(&ft1);
    FileTimeToLocalFileTime(&ft1, &ft2);
    FileTimeToSystemTime(&ft2, &st);
    hprintf(hfile, "PerfMeters Snapshot (%02d/%02d/%02d %02d:%02d:%02d)\r\n\r\n",
        st.wMonth, st.wDay, st.wYear % 100, st.wHour, st.wMinute, st.wSecond);
    DumpList(hfile, NULL);
    hprintf(hfile, "\r\n\r\nPerfMeters Log\r\n\r\n");
    DumpLog(hfile);

ret:
    if (hfile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hfile);
    }

    LeaveCriticalSection(&g_csMeter);
}

static void
RefreshView(HWND hWnd)
{
    EnterCriticalSection(&g_csMeter);
    SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_RESETCONTENT, 0, 0L);
    g_dwItemCount = 0;
    PopulateList(hWnd, NULL);
    LeaveCriticalSection(&g_csMeter);
}

static
void MtSetOOM( HWND hWndList )
{
    LONG    idx;
    MTAG *  pmtag;
    BOOL    fExcl;
    RECT    rc;

    idx = SendMessageA(hWndList, LB_GETCURSEL, 0, 0L);
    if (idx == CB_ERR)
        return;

    pmtag = (MTAG *)SendMessageA(hWndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
    if (!pmtag || pmtag == (MTAG *)CB_ERR)
        return;

    fExcl = !!(((DWORD_PTR)pmtag) & 1L);
    pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

    EnterCriticalSection(&g_csMeter);

    pmtag->dwFlags ^= (fExcl ? MTF_SIMOUTOFMEMEXCL : MTF_SIMOUTOFMEMINCL);

    LeaveCriticalSection(&g_csMeter);

    if (SendMessageA(hWndList, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        RedrawWindow(hWndList, &rc, NULL, RDW_INVALIDATE);
}

static
void MtClearAllOOM()
{
    MTAG  *pmtag;
    HWND   hWndList = GetDlgItem(ghWnd, IDC_TAGLIST);

    EnterCriticalSection(&g_csMeter);

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        pmtag->dwFlags &= ~(MTF_SIMOUTOFMEMEXCL | MTF_SIMOUTOFMEMINCL);
    }

    LeaveCriticalSection(&g_csMeter);

    LONG idxTop = SendMessageA(hWndList, LB_GETTOPINDEX, 0, 0);
    LONG idxSel = SendMessageA(hWndList, LB_GETCURSEL, 0, 0);
    RefreshView(ghWnd);
    SendMessageA(hWndList, LB_SETTOPINDEX, (WPARAM)idxTop, 0);
    SendMessageA(hWndList, LB_SETCURSEL, (WPARAM)idxSel, 0);
}

static
void PushOOMState()
{
    CheckDlgButton( ghWnd, IDC_USEINTERVALOOM, g_fIntervalOOM ? BST_CHECKED : BST_UNCHECKED );
    CheckDlgButton( ghWnd, g_fAllOOM ? IDC_ALLMEM : IDC_MARKEDMEM , BST_CHECKED );

    {
        TCHAR   ach[16];

        ach[ARRAY_SIZE(ach) - 1] = '\0';
        _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_dwOOMCycle);
        Edit_SetText(GetDlgItem(ghWnd, IDC_OOMINTERVAL), ach);
    }
}

static
void MtSetBreak( HWND hWndList )
{
    LONG    idx;
    MTAG *  pmtag;
    BOOL    fExcl;
    RECT    rc;

    idx = SendMessageA(hWndList, LB_GETCURSEL, 0, 0L);
    if (idx == CB_ERR)
        return;

    pmtag = (MTAG *)SendMessageA(hWndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
    if (!pmtag || pmtag == (MTAG *)CB_ERR)
        return;

    fExcl = !!(((DWORD_PTR)pmtag) & 1L);
    pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

    pmtag->dwFlags ^= (fExcl ? MTF_BREAKPOINTEXCL : MTF_BREAKPOINTINCL);

    if (SendMessageA(hWndList, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        RedrawWindow(hWndList, &rc, NULL, RDW_INVALIDATE);
}

static
void MtClearAllBreaks()
{
    MTAG  *pmtag;
    HWND   hWndList = GetDlgItem(ghWnd, IDC_TAGLIST);

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        pmtag->dwFlags &= ~(MTF_BREAKPOINTEXCL | MTF_BREAKPOINTINCL);
    }

    LONG idxTop = SendMessageA(hWndList, LB_GETTOPINDEX, 0, 0);
    LONG idxSel = SendMessageA(hWndList, LB_GETCURSEL, 0, 0);
    RefreshView(ghWnd);
    SendMessageA(hWndList, LB_SETTOPINDEX, (WPARAM)idxTop, 0);
    SendMessageA(hWndList, LB_SETCURSEL, (WPARAM)idxSel, 0);
}

static
void TagListNotify(WORD wNotify, HWND hWnd)
{
    LONG    idx;
    MTAG *  pmtag;
    BOOL    fExcl;

    if (wNotify == LBN_DBLCLK)
    {
        idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);
        if (idx == CB_ERR)
            return;

        pmtag = (MTAG *)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
        if (!pmtag || pmtag == (MTAG *)CB_ERR)
            return;

        fExcl = !!(((DWORD_PTR)pmtag) & 1L);
        pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

        if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
        {
            MtSetBreak( hWnd );
        }
        else if (!fExcl && (pmtag->dwFlags & MTF_HASCHILDREN))
        {
            LONG idxTop = SendMessageA(hWnd, LB_GETTOPINDEX, 0, 0);
            pmtag->dwFlags ^= MTF_COLLAPSED;
            RefreshView(ghWnd);
            SendMessageA(hWnd, LB_SETTOPINDEX, (WPARAM)idxTop, 0);
        }
    }
}

static
void MtMeterClearChildren(MTAG * pmtag)
{
    for (MTAG * pmtagT = g_pmtagHead; pmtagT; pmtagT = pmtagT->pmtagNext)
    {
        if (pmtagT->pmtagParent == pmtag)
        {
            DWORD dwFlags = pmtagT->dwFlags & (MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
            pmtagT->dwFlags &= ~(MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
            DbgExMtAdd((PERFMETERTAG)pmtagT, -pmtagT->lCntExc, -pmtagT->lValExc);
            pmtagT->dwFlags |= dwFlags;

            if (pmtagT->lCntInc || pmtag->lValInc)
            {
                MtMeterClearChildren(pmtagT);
            }
        }
    }
}

static
void MtMeterClear()
{
    HWND    hwndList = GetDlgItem(ghWnd, IDC_TAGLIST);
    LONG    idx;
    MTAG *  pmtag;

    idx = SendMessageA(hwndList, LB_GETCURSEL, 0, 0L);
    if (idx == CB_ERR)
        return;

    pmtag = (MTAG *)SendMessageA(hwndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
    if (!pmtag || pmtag == (MTAG *)CB_ERR)
        return;

    pmtag = (MTAG *)((DWORD_PTR)pmtag & ~1L);

    DWORD dwFlags = pmtag->dwFlags & (MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
    pmtag->dwFlags &= ~(MTF_BREAKPOINTINCL | MTF_BREAKPOINTEXCL);
    DbgExMtAdd((PERFMETERTAG)pmtag, -pmtag->lCntExc, -pmtag->lValExc);
    pmtag->dwFlags |= dwFlags;

    if (pmtag->lCntInc || pmtag->lValInc)
    {
        MtMeterClearChildren(pmtag);
    }
}

static
void OnTimer(HWND hwnd)
{
    EnterCriticalSection(&g_csMeter);

    HWND hwndList = GetDlgItem(hwnd, IDC_TAGLIST);
    LONG idx = SendMessageA(hwndList, LB_GETTOPINDEX, 0, 0);
    LONG idxBase = idx;
    RECT rc;

    if (g_cRefresh > 0 && --g_cRefresh == 0)
    {
        RefreshView(hwnd);
    }
    else
    {
        while (SendMessageA(hwndList, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        {
            MTAG *      pmtag;
            BOOL        fExcl;
            DWORD_PTR   dwItemData = SendMessageA(hwndList, LB_GETITEMDATA, (WPARAM)idx, 0L);
            DWORD       dwDirtyFlag;

            pmtag = (MTAG *)(dwItemData & ~1L);
            fExcl = !!(dwItemData & 1L);
            dwDirtyFlag = fExcl ? MTF_EXCLVALUESDIRTY : MTF_VALUESDIRTY;

            if (pmtag && pmtag != (MTAG *)CB_ERR)
            {
                if (pmtag->dwFlags & dwDirtyFlag)
                {
                    pmtag->dwFlags &= ~dwDirtyFlag;
                    RedrawWindow(hwndList, &rc, NULL, RDW_INVALIDATE);
                }
            }
            idx += 1;

            if ((idx-idxBase) > 50)
            {
                break;
            }
        }

        {
            TCHAR   ach[16];

            ach[ARRAY_SIZE(ach) - 1] = '\0';
            _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_dwOOMCount);
            Static_SetText(GetDlgItem(ghWnd, IDC_OOMCOUNT), ach);
        }
    }

    LeaveCriticalSection(&g_csMeter);
}

static
void ExpandCollapseAll(BOOL fExpand )
{
    MTAG  *pmtag;

    EnterCriticalSection(&g_csMeter);

    for (pmtag = g_pmtagHead; pmtag; pmtag = pmtag->pmtagNext)
    {
        if (pmtag->dwFlags & MTF_HASCHILDREN)
        {
            if (fExpand)
                pmtag->dwFlags &= ~MTF_COLLAPSED;
            else
                pmtag->dwFlags |= MTF_COLLAPSED;
        }
    }

    LeaveCriticalSection(&g_csMeter);

    RefreshView(ghWnd);
}

INT_PTR WINAPI
MeterMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghWnd = hWnd;
            RefreshView(ghWnd);
            SetRGBValues();
            SetWindowTitle(hWnd, "PerfMeters - %s");
            SetWindowTitle(GetDlgItem(hWnd, IDC_STARTSTOP), g_fLogging ? "&Stop Log" : "&Start Log");
            ShowWindow(hWnd, g_fBringToFront ? SW_SHOWNORMAL : SW_SHOWMINNOACTIVE);
            SetTimer(hWnd, 1001, 1000, NULL);

            PushOOMState();
            break;

        case WM_SYSCOLORCHANGE:
            SetRGBValues();
            g_cRefresh = 3;
            break;

        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            DrawItem((LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_PAINT:
            return FALSE;

        case WM_ERASEBKGND:
            return IsIconic(hWnd);

        case WM_QUERYENDSESSION:
            PostMessageA(hWnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            fDlgUp = FALSE;
            KillTimer(ghWnd, 1001);
            return EndDialog(hWnd, 0);

        case WM_TIMER:
            OnTimer(ghWnd);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_TAGLIST:
                    TagListNotify(HIWORD(wParam), (HWND)lParam);
                    break;

                case IDC_CLEARLOG:
                    MtLogClear();
                    break;

                case IDC_STARTSTOP:
                    SetWindowTitle((HWND)lParam, g_fLogging ? "&Start Log" : "&Stop Log");
                    g_fLogging = !g_fLogging;
                    break;

                case IDC_REFRESH:
                    g_cRefresh = 3;
                    break;

                case IDC_DUMPLOG:
                    DbgExMtLogDump("\\perfmetr.log");
                    break;

                case IDC_CLEARMETER:
                    MtMeterClear();
                    break;

                case IDC_BREAKMETER:
                    MtSetBreak( GetDlgItem(ghWnd, IDC_TAGLIST) );
                    break;

                case IDC_CLEARBREAK:
                    MtClearAllBreaks();
                    break;

                case IDC_OOMMETER:
                    MtSetOOM( GetDlgItem(ghWnd, IDC_TAGLIST) );
                    break;

                case IDC_CLEAROOM:
                    MtClearAllOOM();
                    break;

                case IDC_ALLMEM:
                    g_fAllOOM = IsDlgButtonChecked( ghWnd, IDC_ALLMEM ) == BST_CHECKED;
                    break;

                case IDC_MARKEDMEM:
                    g_fAllOOM = IsDlgButtonChecked( ghWnd, IDC_MARKEDMEM ) != BST_CHECKED;
                    break;

                case IDC_USEINTERVALOOM:
                    g_fIntervalOOM = IsDlgButtonChecked( ghWnd, IDC_USEINTERVALOOM ) == BST_CHECKED;
                    break;

                case IDC_BREAKOOM:
                    g_fBreakOnOOM = IsDlgButtonChecked( ghWnd, IDC_BREAKOOM ) == BST_CHECKED;
                    break;

                case IDC_OOMINTERVAL:
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        TCHAR   ach[16];

                        EnterCriticalSection(&g_csMeter);

                        Edit_GetText(GetDlgItem(ghWnd, IDC_OOMINTERVAL), ach, ARRAY_SIZE(ach));
                        g_dwOOMCycle = _ttoi(ach);

                        if (g_dwOOMCycle == 0)
                            g_dwOOMCycle = 1;

                        LeaveCriticalSection(&g_csMeter);
                    }
                    break;

                case IDC_EXPANDALL:
                    ExpandCollapseAll( TRUE );
                    break;

                case IDC_COLLAPSEALL:
                    ExpandCollapseAll( FALSE );
                    break;

                default:
                    return FALSE;
            }
            break;
        default:
            return FALSE;
    }

    return TRUE;
}

static char achSpaces[] = "                                                                ";

char *
GetSpaces(int n)
{
    return(&achSpaces[sizeof(achSpaces) - n]);
}

COLORREF
BkColorFromLevel(int cLevel, HDC hdc)
{
    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        static COLORREF rgcr_pal[] = {
            0x20FFFFFF,
            0x2000FFFF,
            0x20F0CAA6,
            0x2000FF00,
            0x20C0C0C0
        };

        cLevel /= 2;
        cLevel %= 5;

        return(rgcr_pal[cLevel]);
    }
    else
    {
        static COLORREF rgcr_nopal[] = {
            0x20FFFFFF,
            0x20FFE0E0,
            0x20E0FFFF,
            0x20FFE0FF,
            0x20E0FFE0,
            0x20E0E0FF,
            0x20FFFFE0,
            0x20FFFF40,
            0x20E0E0E0
        };

        cLevel /= 2;
        cLevel %= 9;

        return(rgcr_nopal[cLevel]);
    }
}

char * CommaIze(LONG lVal, char * pszBuf)
{
    char ach[32];
    char * pszSrc = ach;
    char * pszDst = pszBuf;
    int c;

    wsprintfA(ach, "%ld", lVal);

    if (*pszSrc == '-')
    {
        *pszDst++ = *pszSrc++;
    }

    c = lstrlenA(pszSrc);

    while (*pszSrc)
    {
        *pszDst++ = *pszSrc++;
        c--;

        if (c && (c % 3) == 0)
        {
            *pszDst++ = ',';
        }
    }

    *pszDst = 0;

    return(pszBuf);
}

void DrawItem(LPDRAWITEMSTRUCT pdis)
{
    char ach[256];
    char achDesc[256];
    int cchDesc;
    COLORREF crText = 0, crBack = 0;
    int cLevel = 0;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        MTAG * pmtag = (MTAG *)(pdis->itemData & ~1L);
        BOOL fChildren  = !!(pmtag->dwFlags & MTF_HASCHILDREN);
        BOOL fForceExcl = !!(pdis->itemData & 1L);

        for (MTAG * pmtagT = pmtag->pmtagParent; pmtagT; pmtagT = pmtagT->pmtagParent)
        {
            cLevel += 2;
        }

        if (fForceExcl)
        {
            cLevel += 2;
        }

        cchDesc = lstrlenA(pmtag->pchDesc);

        if (cchDesc > sizeof(achDesc) - 1 - sizeof(" (Excl)"))
            cchDesc = sizeof(achDesc) - 1 - sizeof(" (Excl)");
        memcpy(achDesc, pmtag->pchDesc, cchDesc);

        if (fForceExcl)
            memcpy(achDesc + cchDesc, " (Excl)", 8);
        else
            achDesc[cchDesc] = 0;

        wsprintfA(ach, "%c%c %s%c%-54s",
            (pmtag->dwFlags & (fForceExcl ? MTF_BREAKPOINTEXCL : MTF_BREAKPOINTINCL)) ? 'B' : ' ',
            (pmtag->dwFlags & (fForceExcl ? MTF_SIMOUTOFMEMEXCL : MTF_SIMOUTOFMEMINCL)) ? 'O' : ' ',
            GetSpaces(cLevel),
            (fForceExcl || !fChildren) ? ' ' : (pmtag->dwFlags & MTF_COLLAPSED) ? '+' : '-',
            achDesc);

        LONG lCnt = (fForceExcl || !fChildren) ? pmtag->lCntExc : pmtag->lCntInc;
        LONG lVal = (fForceExcl || !fChildren) ? pmtag->lValExc : pmtag->lValInc;

        char achBuf1[32];
        char achBuf2[32];
        char achBuf3[32];

        wsprintfA(&ach[56], " %11s [%6s] %11s", CommaIze(lCnt, achBuf1),
            CommaIze(lCnt == 0 ? 0 : lVal / lCnt, achBuf2), CommaIze(lVal, achBuf3));

        if (pdis->itemState & ODS_SELECTED)
        {
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
            ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, ach, lstrlenA(ach), NULL);
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC, crBack);
        }
        else
        {
            crBack = SetBkColor(pdis->hDC, BkColorFromLevel(cLevel, pdis->hDC));
            ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
                ETO_CLIPPED|ETO_OPAQUE, &pdis->rcItem, ach, lstrlenA(ach), NULL);
            SetBkColor(pdis->hDC, crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}

static void SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}

void
MeterProcessAttach()
{
    InitializeCriticalSection(&g_csMeter);

#if defined(RETAILBUILD) && defined(PERFMETER)
    g_fAutoOpen = TRUE;
#endif

    g_fAutoOpen = GetPrivateProfileIntA("perfmeter", "AutoOpen", g_fAutoOpen, "mshtmdbg.ini");
    g_fLogging = GetPrivateProfileIntA("perfmeter", "AutoLog", FALSE, "mshtmdbg.ini");
    g_fAutoDump = GetPrivateProfileIntA("perfmeter", "AutoDump", FALSE, "mshtmdbg.ini");

    g_fIntervalOOM = GetPrivateProfileIntA("perfmeter", "OutOfMemory", FALSE, "mshtmdbg.ini");
    g_dwOOMCycle = GetPrivateProfileIntA("perfmeter", "OutOfMemoryCycle", 500, "mshtmdbg.ini");

    if (g_dwOOMCycle == 0)
        g_dwOOMCycle = 1;

    if (g_fAutoOpen)
    {
        MtDoOpenMonitor(FALSE);
    }
}

void
MeterProcessDetach()
{
    if (g_fAutoDump)
        DbgExMtLogDump("\\perfmetr.log");
    if (ghWnd)
        SendMessageA(ghWnd, WM_CLOSE, 0, 0);
    DWORD dwTickEnd = GetTickCount() + 5000;
    while (ghThread && GetTickCount() < dwTickEnd)
        Sleep(50);
    DeleteCriticalSection(&g_csMeter);

    for (MTAG * pmtag = g_pmtagHead; pmtag; pmtag = g_pmtagHead)
    {
        g_pmtagHead = pmtag->pmtagNext;
        LocalFree(pmtag);
    }

    for (LBLK * plblk = g_plblkHead; plblk; plblk = g_plblkHead)
    {
        g_plblkHead = plblk->plblkNext;
        LocalFree(plblk);
    }

    if (g_aMTagByName)
    {
        LocalFree(g_aMTagByName);
    }

    if (g_aMTagOrphanByParent)
    {
        LocalFree(g_aMTagOrphanByParent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\iwatch.cxx ===
//+---------------------------------------------------------------------
//
//  File:       iwatch.cxx
//
//  Contents:   Interface wrapper for method invocation traces
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include <hlink.h>
#endif

#ifndef X_DOCOBJ_H_
#define X_DOCOBJ_H_
#include <docobj.h>
#endif

static ULONG g_ulSSN;
static ULONG g_ulNestingLevel = 0;
static TCHAR g_szNULL[] = _T("(null)");     // string output for null string ptr

#define OUTPUTSTR(s)(s ? (s) : g_szNULL)	// wsprintf chokes on null string ptrs

#define INDENT_NESTING \
    TraceTagEx((tagTrackItfVerbose, TAG_NONEWLINE, "%*s", g_ulNestingLevel*4, "")); \
    InterlockedIncrement((LONG *)&g_ulNestingLevel)

#define INDENT_NESTING2 \
    TraceTagEx((tagTrackItfVerbose, TAG_NONEWLINE, "%*s", g_ulNestingLevel*4, ""));

#undef TRETURN
#define TRETURN(hr) \
    {                                                    \
        HRESULT hr2 = hr;                                \
        InterlockedDecrement((LONG *)&g_ulNestingLevel); \
        INDENT_NESTING2;                                 \
        TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%hr", hr2)); \
        SRETURN(hr2);                                    \
    }

typedef void (*PFNVOID)();

#define TAG_FLAGS  (TAG_NONAME | TAG_NONEWLINE)


//+---------------------------------------------------------------
//
//  Function:   GetIIDName
//
//----------------------------------------------------------------


EXTERN_C const GUID IID_IDispatchEx;
EXTERN_C const GUID IID_IInternetHostSecurityManager;
EXTERN_C const GUID IID_IPersistHistory;
EXTERN_C const GUID IID_ITargetContainer;

static const char *
GetIIDName(REFIID iid)
{

#define CASE_IID(itf) if (IID_##itf == iid) return #itf;

    CASE_IID(IDispatchEx)
    CASE_IID(IInternetHostSecurityManager)
    CASE_IID(IPersistHistory)
    CASE_IID(ITargetContainer)
    CASE_IID(IAdviseSink)
    CASE_IID(IAdviseSink2)
    CASE_IID(IBindCtx)
    CASE_IID(IClassFactory)
    CASE_IID(IOleParentUndoUnit)
    CASE_IID(IConnectionPoint)
    CASE_IID(IConnectionPointContainer)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IDataObject)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IDispatch)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IEnumCallback)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumString)
    CASE_IID(IEnumUnknown)
    CASE_IID(IExternalConnection)
    CASE_IID(ILockBytes)
    CASE_IID(IMarshal)
    CASE_IID(IOleCommandTarget)
    CASE_IID(IOleDocument)
    CASE_IID(IOleDocumentView)
    CASE_IID(IOleDocumentSite)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IOleCache)
    CASE_IID(IOleCache2)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleContainer)
    CASE_IID(IOleControl)
    CASE_IID(IOleControlSite)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IOleInPlaceObjectWindowless)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IOleInPlaceSiteWindowless)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleLink)
    CASE_IID(IOleManager)
    CASE_IID(IOleObject)
    CASE_IID(IOlePresObj)
    CASE_IID(IOleWindow)
    CASE_IID(IParseDisplayName)
    CASE_IID(IPerPropertyBrowsing)
    CASE_IID(IPersist)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistStream)
    CASE_IID(IPersistStreamInit)
    CASE_IID(IPersistPropertyBag)
    CASE_IID(IProvideClassInfo)
    CASE_IID(IQuickActivate)
    CASE_IID(IRunnableObject)
    CASE_IID(IServiceProvider)
    CASE_IID(ISpecifyPropertyPages)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    CASE_IID(IUnknown)
    CASE_IID(IOleUndoUnit)
    CASE_IID(IOleUndoManager)
    CASE_IID(IViewObject)
    CASE_IID(IViewObject2)
    CASE_IID(IViewObjectEx)
#undef CASE_IID

    // The following is not thread safe.  The only bad thing that can
    // happen is that we get bogus debug output. It's not worth fixing.

    static char ach[32];
    wsprintfA(ach, "%08x", iid.Data1);
    return ach;
}

//---------------------------------------------------------------
//
//  Class:      CTrack
//
//---------------------------------------------------------------

class CTrack
{
public:

    void * __cdecl operator new(size_t cb);
    void __cdecl operator delete(void *pv);

    CTrack(IUnknown *pUnk, REFIID iid, char *pch, BOOL fTrackOnQI);

    virtual ~CTrack();

    ULONG STDMETHODCALLTYPE AddRef();

    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppv);

    ULONG       _ulRefs;
    ULONG       _ulSSN;
    char *      _pch;
    BOOL        _fTrackOnQI;
    IUnknown *  _pUnk;          // ASM code below relies on this being the last member in the class!
};


inline void * __cdecl 
CTrack::operator new(size_t cb)
{
    return DbgExPostAlloc(malloc(DbgExPreAlloc(cb))); 
}

inline void __cdecl 
CTrack::operator delete(void *pv)
{
    free(DbgExPreFree(pv)); 
    DbgExPostFree(); 
}

CTrack::CTrack(IUnknown *pUnk, REFIID iid, char *pch, BOOL fTrackOnQI)
{
    _ulRefs = 1;
    _pUnk = pUnk;
    _ulSSN = g_ulSSN++;
    _pch = pch;
    _fTrackOnQI = fTrackOnQI;

    DbgExMemSetName(this, "TI %s p=%08x ssn=%d id=%s", pch, _pUnk, _ulSSN, GetIIDName(iid));
}

CTrack::~CTrack()
{ 
	_pUnk->Release(); 
}

ULONG STDMETHODCALLTYPE 
CTrack::Release()
{
    if (InterlockedDecrement((long *)&_ulRefs) == 0)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

ULONG STDMETHODCALLTYPE 
CTrack::AddRef()
{ 
    return InterlockedIncrement((long *)&_ulRefs); 
}

HRESULT STDMETHODCALLTYPE 
CTrack::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr;
    
    hr = _pUnk->QueryInterface(iid, ppv);
    if (_fTrackOnQI)
    {
        DbgExTrackItf(iid, _pch, TRUE, ppv);
    }
    return hr;
}

#define BEGIN_TRACK(itf)\
class C##itf : public CTrack, public I##itf {\
public:\
    static IUnknown * Create(IUnknown *pUnk, char *pch, BOOL fTrackOnQI) { return new C##itf(pUnk, pch, fTrackOnQI); } \
    I##itf *_p; \
    C##itf(IUnknown *pUnk, char *pch, BOOL fTrackOnQI) : CTrack(pUnk, IID_I##itf, pch, fTrackOnQI), _p((I##itf *)pUnk) { } \
    ULONG STDMETHODCALLTYPE AddRef() { return CTrack::AddRef(); } \
    ULONG STDMETHODCALLTYPE Release() { return CTrack::Release(); } \
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppv) { return CTrack::QueryInterface(iid, ppv); } \

#define END_TRACK() };

//---------------------------------------------------------------
//
//  Class:      CWrapArg
//
//---------------------------------------------------------------

class CWrapArg
{
public:
    CWrapArg(CTrack *pTrack, REFIID iid, void **ppv);
    ~CWrapArg();
    IUnknown ** _ppUnk;
};

CWrapArg::CWrapArg(CTrack *pTrack, REFIID iid, void **ppv)
{
    _ppUnk = (IUnknown **)ppv;
    if (*_ppUnk)
    {
        (*_ppUnk)->AddRef();
        DbgExTrackItf(iid, pTrack->_pch, TRUE, ppv);
    }
}

CWrapArg::~CWrapArg()
{
    if (*_ppUnk)
    {
        (*_ppUnk)->Release();
    }
}

//---------------------------------------------------------------
//
//  IOleObject
//
//---------------------------------------------------------------

BEGIN_TRACK(OleObject)

HRESULT STDMETHODCALLTYPE
SetClientSite(LPOLECLIENTSITE pClientSite)
{
    //CWrapArg arg(this, IID_IOleClientSite, (void **)&pClientSite);

    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetClientSite\n", _pch));
    TRETURN(_p->SetClientSite(pClientSite));
}

HRESULT STDMETHODCALLTYPE
GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClientSite\n", _pch));
    TRETURN(_p->GetClientSite(ppClientSite));
}

HRESULT STDMETHODCALLTYPE
SetHostNames(LPCOLESTR szCntrApp, LPCOLESTR szCntrObj)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetHostNames(%ls,%ls)\n",
            _pch,
            OUTPUTSTR(szCntrApp),
            OUTPUTSTR(szCntrObj)));

    TRETURN(_p->SetHostNames(szCntrApp, szCntrObj));
}

HRESULT STDMETHODCALLTYPE
Close(DWORD reserved)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Close(%lu)\n", _pch, reserved));
    TRETURN(_p->Close(reserved));
}

HRESULT STDMETHODCALLTYPE
SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetMoniker\n", _pch));
    TRETURN(_p->SetMoniker(dwWhichMoniker, pmk));
}

HRESULT STDMETHODCALLTYPE
GetMoniker(DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER FAR* ppmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMoniker\n", _pch));
    TRETURN(_p->GetMoniker(dwAssign, dwWhichMoniker, ppmk));
}

HRESULT STDMETHODCALLTYPE
InitFromData(LPDATAOBJECT pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitFromData\n", _pch));
    TRETURN(_p->InitFromData(pDataObject, fCreation, dwReserved));
}

HRESULT STDMETHODCALLTYPE
GetClipboardData(DWORD dwReserved,
        LPDATAOBJECT FAR* ppDataObject)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClipboardData\n", _pch));
    TRETURN(_p->GetClipboardData(dwReserved, ppDataObject));
}

HRESULT STDMETHODCALLTYPE
DoVerb(LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPos)
{

    static char * apszVerbs[] = {
                                  "OLEIVERB_PRIMARY", //            (0L)
                                  "OLEIVERB_SHOW",    //            (-1L)
                                  "OLEIVERB_OPEN",    //            (-2L)
                                  "OLEIVERB_HIDE",    //            (-3L)
                                  "OLEIVERB_UIACTIVATE", //         (-4L)
                                  "OLEIVERB_INPLACEACTIVATE", //    (-5L)
                                  "OLEIVERB_DISCARDUNDOSTATE" //    (-6L)
                                };
    RECT rc = { 0 };

    INDENT_NESTING;

    if (lprcPos)
        rc = *lprcPos;

    if ((iVerb > 0) || (-iVerb > ARRAY_SIZE(apszVerbs)))
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DoVerb(%ld,,,,,%s), pPos=(%d,%d,%d,%d)\n",
                    _pch, iVerb, ((lprcPos) ? "pPos" : "(null)"),
                    rc.left, rc.top, rc.right, rc.bottom
                    ));
    }
    else
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DoVerb(%s,,,,,%s), pPos=(%d,%d,%d,%d)\n",
                    _pch, apszVerbs[-iVerb], ((lprcPos) ? "pPos" : NULL),
                    rc.left, rc.top, rc.right, rc.bottom
                    ));
    }

    TRETURN(_p->DoVerb(iVerb,
            lpmsg,
            pActiveSite,
            lindex,
            hwndParent,
            lprcPos));
}

HRESULT STDMETHODCALLTYPE
EnumVerbs(LPENUMOLEVERB FAR* ppenum)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumVerbs\n", _pch));
    TRETURN(_p->EnumVerbs(ppenum));
}

HRESULT STDMETHODCALLTYPE
Update()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Update\n", _pch));
    TRETURN(_p->Update());
}

HRESULT STDMETHODCALLTYPE
IsUpToDate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsUpToDate\n", _pch));
    TRETURN(_p->IsUpToDate());
}

HRESULT STDMETHODCALLTYPE
GetUserClassID(CLSID FAR* pClsid)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetUserClassID\n", _pch));
    TRETURN(_p->GetUserClassID(pClsid));
}

HRESULT STDMETHODCALLTYPE
GetUserType(DWORD dwFormOfType, LPOLESTR FAR* ppch)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetUserType\n", _pch));
    TRETURN(_p->GetUserType(dwFormOfType, ppch));
}

HRESULT STDMETHODCALLTYPE
SetExtent(DWORD dwDrawAspect, SIZEL * lpsizel)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetExtent(%d, (cx=%d,cy=%d))\n",
                _pch, dwDrawAspect, lpsizel->cx, lpsizel->cy));
    TRETURN(_p->SetExtent(dwDrawAspect, lpsizel));
}

HRESULT STDMETHODCALLTYPE
GetExtent(DWORD dwDrawAspect, SIZEL * lpsizel)
{
    HRESULT hr;

    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetExtent\n", _pch));

    hr = _p->GetExtent(dwDrawAspect, lpsizel);

    InterlockedDecrement((LONG *)&g_ulNestingLevel);
    INDENT_NESTING2;
    TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%s::GetExtent Returning cx=%d,cy=%d, %hr.",
                _pch, lpsizel->cx, lpsizel->cy, hr));
    SRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
Advise(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Advise\n", _pch));
    TRETURN(_p->Advise(pAdvSink, pdwConnection));
}

HRESULT STDMETHODCALLTYPE
Unadvise(DWORD dwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Unadvise\n", _pch));
    TRETURN(_p->Unadvise(dwConnection));
}

HRESULT STDMETHODCALLTYPE
EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumAdvise\n", _pch));
    TRETURN(_p->EnumAdvise(ppenumAdvise));
}

HRESULT STDMETHODCALLTYPE
GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMiscStatus\n", _pch));
    TRETURN(_p->GetMiscStatus(dwAspect, pdwStatus));
}

HRESULT STDMETHODCALLTYPE
SetColorScheme(LPLOGPALETTE lpLogpal)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetColorScheme\n", _pch));
    TRETURN(_p->SetColorScheme(lpLogpal));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleClientSite
//
//---------------------------------------------------------------

BEGIN_TRACK(OleClientSite)

HRESULT STDMETHODCALLTYPE
SaveObject()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SaveObject\n", _pch));
    TRETURN(_p->SaveObject());
}

HRESULT STDMETHODCALLTYPE
GetMoniker(DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER FAR* ppmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMoniker\n", _pch));
    TRETURN(_p->GetMoniker(dwAssign, dwWhichMoniker, ppmk));
}

HRESULT STDMETHODCALLTYPE
GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetContainer\n", _pch));
    TRETURN(_p->GetContainer(ppContainer));
}

HRESULT STDMETHODCALLTYPE
ShowObject()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ShowObject\n", _pch));
    TRETURN(_p->ShowObject());
}

HRESULT STDMETHODCALLTYPE
OnShowWindow(BOOL fShow)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnShowWindow\n", _pch));
    TRETURN(_p->OnShowWindow(fShow));
}

HRESULT STDMETHODCALLTYPE
RequestNewObjectLayout ()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestNewObjectLayout\n", _pch));
    TRETURN(_p->RequestNewObjectLayout());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceSiteWindowless
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceSiteWindowless)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND * lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
CanInPlaceActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::CanInPlaceActivate\n", _pch));
    TRETURN(_p->CanInPlaceActivate());
}

HRESULT STDMETHODCALLTYPE
OnInPlaceActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceActivate\n", _pch));
    TRETURN(_p->OnInPlaceActivate());
}

HRESULT STDMETHODCALLTYPE
OnInPlaceActivateEx(BOOL *pf, DWORD dw)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceActivate\n", _pch));
    TRETURN(_p->OnInPlaceActivateEx(pf, dw));
}

HRESULT STDMETHODCALLTYPE
RequestUIActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestUIActivate\n", _pch));
    TRETURN(_p->RequestUIActivate());
}

HRESULT STDMETHODCALLTYPE
OnUIActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnUIActivate\n", _pch));
    TRETURN(_p->OnUIActivate());
}

HRESULT STDMETHODCALLTYPE
GetWindowContext(
                    LPOLEINPLACEFRAME *    lplpFrame,
                    LPOLEINPLACEUIWINDOW * lplpDoc,
                    LPRECT                 lprcPosRect,
                    LPRECT                 lprcClipRect,
                    LPOLEINPLACEFRAMEINFO  lpFrameInfo)
{
    HRESULT hr;

    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindowContext\n", _pch));

    hr = _p->GetWindowContext(
                    lplpFrame,
                    lplpDoc,
                    lprcPosRect,
                    lprcClipRect,
                    lpFrameInfo);

    InterlockedDecrement((LONG *)&g_ulNestingLevel);
    INDENT_NESTING2;
    if (lprcPosRect && lprcClipRect)
    {
        TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%s::GetWindowContext Returning "
                    "Pos=(%d,%d,%d,%d), Clip=(%d,%d,%d,%d) %hr.",
                    _pch,
                    lprcPosRect->left, lprcPosRect->top,
                    lprcPosRect->right, lprcPosRect->bottom,
                    lprcClipRect->left, lprcClipRect->top,
                    lprcClipRect->right, lprcClipRect->bottom,
                    hr));
    }
    else
    {
        TraceTagEx((tagTrackItfVerbose, TAG_NONAME, "%s::GetWindowContext Returning "
                    "Pos=(null), Clip=(null) %hr.", _pch, hr));
    }

    SRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
Scroll(SIZE extent)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Scroll\n", _pch));
    TRETURN(_p->Scroll(extent));
}

HRESULT STDMETHODCALLTYPE
OnUIDeactivate(BOOL fUndoable)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnUIDeactivate\n", _pch));
    TRETURN(_p->OnUIDeactivate(fUndoable));
}

HRESULT STDMETHODCALLTYPE
OnInPlaceDeactivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceDeactivate\n", _pch));
    TRETURN(_p->OnInPlaceDeactivate());
}

HRESULT STDMETHODCALLTYPE
OnInPlaceDeactivateEx(BOOL f)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnInPlaceDeactivateEx\n", _pch));
    TRETURN(_p->OnInPlaceDeactivateEx(f));
}

HRESULT STDMETHODCALLTYPE
DiscardUndoState()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DiscardUndoState\n", _pch));
    TRETURN(_p->DiscardUndoState());
}

HRESULT STDMETHODCALLTYPE
DeactivateAndUndo()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DeactivateAndUndo\n", _pch));
    TRETURN(_p->DeactivateAndUndo());
}

HRESULT STDMETHODCALLTYPE
OnPosRectChange(LPCRECT lprcPosRect)
{
    INDENT_NESTING;
    if (lprcPosRect)
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnPosRectChange -- "
                    "Pos=(%d,%d,%d,%d)\n",
                    _pch,
                    lprcPosRect->left, lprcPosRect->top,
                    lprcPosRect->right, lprcPosRect->bottom
                    ));
    }
    else
    {
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnPosRectChange -- "
                    "Pos=(null)\n", _pch));
    }
    TRETURN(_p->OnPosRectChange(lprcPosRect));
}

HRESULT STDMETHODCALLTYPE
CanWindowlessActivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::CanWindowlessActivate\n", _pch));
    TRETURN(_p->CanWindowlessActivate());
}

HRESULT STDMETHODCALLTYPE
GetCapture()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetCapture\n", _pch));
    TRETURN(_p->GetCapture());
}

HRESULT STDMETHODCALLTYPE
SetCapture(BOOL fCapture)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetCapture\n", _pch));
    TRETURN(_p->SetCapture(fCapture));
}

HRESULT STDMETHODCALLTYPE
GetFocus()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetFocus\n", _pch));
    TRETURN(_p->GetFocus());
}

HRESULT STDMETHODCALLTYPE
SetFocus(BOOL fFocus)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetFocus\n", _pch));
    TRETURN(_p->SetFocus(fFocus));
}

HRESULT STDMETHODCALLTYPE
OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnDefWindowMessage\n", _pch));
    TRETURN(_p->OnDefWindowMessage(msg, wParam, lParam, plResult));
}

HRESULT STDMETHODCALLTYPE
GetDC(LPCRECT prc, DWORD dwFlags, HDC * phDC)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetFocus\n", _pch));
    TRETURN(_p->GetDC(prc, dwFlags, phDC));
}

HRESULT STDMETHODCALLTYPE
ReleaseDC(HDC hdc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ReleaseDC\n", _pch));
    TRETURN(_p->ReleaseDC(hdc));
}

HRESULT STDMETHODCALLTYPE
InvalidateRect(LPCRECT prc, BOOL fErase)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InvalidateRect\n", _pch));
    TRETURN(_p->InvalidateRect(prc, fErase));
}

HRESULT STDMETHODCALLTYPE
InvalidateRgn(HRGN hrgn, BOOL fErase)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InvalidateRgn\n", _pch));
    TRETURN(_p->InvalidateRgn(hrgn, fErase));
}

HRESULT STDMETHODCALLTYPE
ScrollRect(int dx, int dy, LPCRECT lprcScroll, LPCRECT lprcClip)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ScrollRect\n", _pch));
    TRETURN(_p->ScrollRect(dx, dy, lprcScroll, lprcClip));
}

HRESULT STDMETHODCALLTYPE
AdjustRect(LPRECT prc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::AdjustRect\n", _pch));
    TRETURN(_p->AdjustRect(prc));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IDataObject
//
//---------------------------------------------------------------

BEGIN_TRACK(DataObject)

HRESULT STDMETHODCALLTYPE
GetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetData\n", _pch));
    TRETURN(_p->GetData(pformatetc, pmedium));
}

HRESULT STDMETHODCALLTYPE
GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetDataHere\n", _pch));
    TRETURN(_p->GetDataHere(pformatetc, pmedium));
}

HRESULT STDMETHODCALLTYPE
QueryGetData(LPFORMATETC pformatetc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::QueryGetData\n", _pch));
    TRETURN(_p->QueryGetData(pformatetc));
}

HRESULT STDMETHODCALLTYPE
GetCanonicalFormatEtc(LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetCanonicalFormat\n", _pch));
    TRETURN(_p->GetCanonicalFormatEtc(pformatetc, pformatetcOut));
}

HRESULT STDMETHODCALLTYPE
SetData(LPFORMATETC pformatetc,
        STGMEDIUM FAR *pmedium, BOOL fRelease)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetData\n", _pch));
    TRETURN(_p->SetData(pformatetc, pmedium, fRelease));
}

HRESULT STDMETHODCALLTYPE
EnumFormatEtc(DWORD dwDirection,
        LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumFormatEtc\n", _pch));
    TRETURN(_p->EnumFormatEtc(dwDirection, ppenumFormatEtc));
}

HRESULT STDMETHODCALLTYPE
DAdvise(FORMATETC FAR* pFormatetc, DWORD advf,
        LPADVISESINK pAdvSink, DWORD FAR* pdwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DAdvise\n", _pch));
    TRETURN(_p->DAdvise(pFormatetc, advf, pAdvSink, pdwConnection));
}

HRESULT STDMETHODCALLTYPE
DUnadvise(DWORD dwConnection)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::DUnadvise\n", _pch));
    TRETURN(_p->DUnadvise(dwConnection));
}

HRESULT STDMETHODCALLTYPE
EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumDAdvise\n", _pch));
    TRETURN(_p->EnumDAdvise(ppenumAdvise));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IViewObject
//
//---------------------------------------------------------------

BEGIN_TRACK(ViewObject)

HRESULT STDMETHODCALLTYPE
Draw(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR), ULONG_PTR dwContinue)
{
    INDENT_NESTING;
    RECTL  rc = { 0 }, rcBounds = { 0 };

    if (lprectl)
        rc = *lprectl;

    if (lprcWBounds)
        rcBounds = *lprcWBounds;

    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Draw -- rc=(%d,%d,%d,%d), "
                "rcBounds=(%d,%d,%d,%d)\n", _pch,
                rc.left, rc.top, rc.right, rc.bottom,
                rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom));

    TRETURN(_p->Draw(dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev,
            hdcDraw,
            lprectl,
            lprcWBounds,
            pfnContinue,
            dwContinue));
}

HRESULT STDMETHODCALLTYPE
GetColorSet(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        LPLOGPALETTE FAR* ppColorSet)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetColorSet\n", _pch));
    TRETURN(_p->GetColorSet(dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev,
            ppColorSet));
}

HRESULT STDMETHODCALLTYPE
Freeze(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DWORD FAR* pdwFreeze)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Freeze\n", _pch));
    TRETURN(_p->Freeze(dwDrawAspect, lindex, pvAspect, pdwFreeze));
}

HRESULT STDMETHODCALLTYPE
Unfreeze(DWORD dwFreeze)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Unfreeze\n", _pch));
    TRETURN(_p->Unfreeze(dwFreeze));
}

HRESULT STDMETHODCALLTYPE
SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetAdvise\n", _pch));
    TRETURN(_p->SetAdvise(aspects, advf, pAdvSink));
}

HRESULT STDMETHODCALLTYPE
GetAdvise(DWORD FAR* pAspects,
        DWORD FAR* pAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetAdvise\n", _pch));
    TRETURN(_p->GetAdvise(pAspects, pAdvf, ppAdvSink));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistStorage
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistStorage)


HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
InitNew(LPSTORAGE pStg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitNew\n", _pch));
    TRETURN(_p->InitNew(pStg));
}

HRESULT STDMETHODCALLTYPE
Load(LPSTORAGE pStg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(stg)\n", _pch));
    TRETURN(_p->Load(pStg));
}

HRESULT STDMETHODCALLTYPE
Save(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(stg,)\n", _pch));
    TRETURN(_p->Save(pStg, fSameAsLoad));
}

HRESULT STDMETHODCALLTYPE
SaveCompleted(LPSTORAGE pStg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SaveCompleted(stg)\n", _pch));
    TRETURN(_p->SaveCompleted(pStg));
}

HRESULT STDMETHODCALLTYPE
HandsOffStorage()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::HandsOffStorage\n", _pch));
    TRETURN(_p->HandsOffStorage());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistFile
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistFile)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(%ls,)\n", _pch, OUTPUTSTR(lpszFileName)));
    TRETURN(_p->Load(lpszFileName, grfMode));
}

HRESULT STDMETHODCALLTYPE
Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(%ls,)\n", _pch, OUTPUTSTR(lpszFileName)));
    TRETURN(_p->Save(lpszFileName, fRemember));
}

HRESULT STDMETHODCALLTYPE
SaveCompleted(LPCOLESTR lpszFileName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SaveCompleted(%ls)\n", _pch, OUTPUTSTR(lpszFileName)));
    TRETURN(_p->SaveCompleted(lpszFileName));
}

HRESULT STDMETHODCALLTYPE
GetCurFile (LPOLESTR FAR * ppstrFile)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetCurFile\n", _pch));
    TRETURN(_p->GetCurFile(ppstrFile));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistStream
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistStream)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
Load(IStream * pStrm)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(strm)\n", _pch));
    TRETURN(_p->Load(pStrm));
}

HRESULT STDMETHODCALLTYPE
Save(IStream * pStrm, BOOL fClearDirty)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(strm,)\n", _pch));
    TRETURN(_p->Save(pStrm, fClearDirty));
}

HRESULT STDMETHODCALLTYPE
GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetSizeMax\n", _pch));
    TRETURN(_p->GetSizeMax(pcbSize));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistStreamInit
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistStreamInit)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
IsDirty()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsDirty\n", _pch));
    TRETURN(_p->IsDirty());
}

HRESULT STDMETHODCALLTYPE
Load(IStream * pStrm)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(strm)\n", _pch));
    TRETURN(_p->Load(pStrm));
}

HRESULT STDMETHODCALLTYPE
Save(IStream * pStrm, BOOL fClearDirty)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(strm,)\n", _pch));
    TRETURN(_p->Save(pStrm, fClearDirty));
}

HRESULT STDMETHODCALLTYPE
GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetSizeMax\n", _pch));
    TRETURN(_p->GetSizeMax(pcbSize));
}

HRESULT STDMETHODCALLTYPE
InitNew()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitNew [Stream]\n", _pch));
    TRETURN(_p->InitNew());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IPersistPropertyBag
//
//---------------------------------------------------------------

BEGIN_TRACK(PersistPropertyBag)

HRESULT STDMETHODCALLTYPE
GetClassID(LPCLSID lpClassID)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetClassID\n", _pch));
    TRETURN(_p->GetClassID(lpClassID));
}

HRESULT STDMETHODCALLTYPE
InitNew()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InitNew [PropertyBag]\n", _pch));
    TRETURN(_p->InitNew());
}

HRESULT STDMETHODCALLTYPE
Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrLog)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Load(propbag)\n", _pch));
    TRETURN(_p->Load(pPropBag, pErrLog));
}

HRESULT STDMETHODCALLTYPE
Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Save(propbag,)\n", _pch));
    TRETURN(_p->Save(pPropBag, fClearDirty, fSaveAllProperties));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceObject
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceObject)


HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
InPlaceDeactivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InPlaceDeactivate\n", _pch));
    TRETURN(_p->InPlaceDeactivate());
}

HRESULT STDMETHODCALLTYPE
UIDeactivate()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::UIDeactivate\n", _pch));
    TRETURN(_p->UIDeactivate());
}

HRESULT STDMETHODCALLTYPE
SetObjectRects(LPCRECT lprcPos, LPCRECT lprcVisRect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetObjectRects(pPos,pClip) Pos=(%d,%d,%d,%d), Clip=(%d,%d,%d,%d)\n",
                _pch,
                lprcPos->left, lprcPos->top, lprcPos->right, lprcPos->bottom,
                lprcVisRect->left, lprcVisRect->top, lprcVisRect->right, lprcVisRect->bottom
                ));
    TRETURN(_p->SetObjectRects(lprcPos, lprcVisRect));
}

HRESULT STDMETHODCALLTYPE
ReactivateAndUndo()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ReactivateAndUndo\n", _pch));
    TRETURN(_p->ReactivateAndUndo());
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleControl
//
//---------------------------------------------------------------

BEGIN_TRACK(OleControl)

HRESULT STDMETHODCALLTYPE
GetControlInfo(CONTROLINFO * pCI)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetControlInfo\n", _pch));
    TRETURN(_p->GetControlInfo(pCI));
}

HRESULT STDMETHODCALLTYPE
OnMnemonic(LPMSG pMsg)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnMnemonic\n", _pch));
    TRETURN(_p->OnMnemonic(pMsg));
}

HRESULT STDMETHODCALLTYPE
OnAmbientPropertyChange(DISPID dispid)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnAmbientPropertyChange\n", _pch));
    TRETURN(_p->OnAmbientPropertyChange(dispid));
}

HRESULT STDMETHODCALLTYPE
FreezeEvents(BOOL fFreeze)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::FreezeEvents(%s)\n", _pch,
               ((fFreeze) ? "TRUE" : "FALSE")));
    TRETURN(_p->FreezeEvents(fFreeze));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceActiveObject
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceActiveObject)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
TranslateAccelerator(LPMSG lpmsg)
{
    return _p->TranslateAccelerator(lpmsg);
}

HRESULT STDMETHODCALLTYPE
OnFrameWindowActivate(BOOL fActivate)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnFrameWindowActivate\n", _pch));
    TRETURN(_p->OnFrameWindowActivate(fActivate));
}

HRESULT STDMETHODCALLTYPE
OnDocWindowActivate(BOOL fActivate)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnDocWindowActivate\n", _pch));
    TRETURN(_p->OnDocWindowActivate(fActivate));
}

HRESULT STDMETHODCALLTYPE
ResizeBorder(LPCRECT lprc,
        LPOLEINPLACEUIWINDOW pUIWindow,
        BOOL fFrameWindow)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ResizeBorder\n", _pch));
    TRETURN(_p->ResizeBorder(lprc, pUIWindow, fFrameWindow));
}

HRESULT STDMETHODCALLTYPE
EnableModeless(BOOL fEnable)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnableModeless\n", _pch));
    TRETURN(_p->EnableModeless(fEnable));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceFrame
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceFrame)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
GetBorder(LPRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetBorder\n", _pch));
    TRETURN(_p->GetBorder(lprect));
}

HRESULT STDMETHODCALLTYPE
RequestBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestBorderSpace\n", _pch));
    TRETURN(_p->RequestBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetBorderSpace\n", _pch));
    TRETURN(_p->SetBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetActiveObject(LPOLEINPLACEACTIVEOBJECT lpActiveObject,
            LPCOLESTR lpszObjName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetActiveObject\n", _pch));
    TRETURN(_p->SetActiveObject(lpActiveObject, lpszObjName));
}

HRESULT STDMETHODCALLTYPE
InsertMenus(HMENU hmenuShared,
        LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::InsertMenus\n", _pch));
    TRETURN(_p->InsertMenus(hmenuShared, lpMenuWidths));
}

HRESULT STDMETHODCALLTYPE
SetMenu(HMENU hmenuShared,
        HOLEMENU holemenu,
        HWND hwndActiveObject)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetMenu\n", _pch));
    TRETURN(_p->SetMenu(hmenuShared, holemenu, hwndActiveObject));
}

HRESULT STDMETHODCALLTYPE
RemoveMenus(HMENU hmenuShared)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RemoveMenus\n", _pch));
    TRETURN(_p->RemoveMenus(hmenuShared));
}

HRESULT STDMETHODCALLTYPE
SetStatusText(LPCOLESTR lpszStatusText)
{
    return _p->SetStatusText(lpszStatusText);
}

HRESULT STDMETHODCALLTYPE
EnableModeless(BOOL fEnable)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnableModeless\n", _pch));
    TRETURN(_p->EnableModeless(fEnable));
}

HRESULT STDMETHODCALLTYPE
TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    return _p->TranslateAccelerator(lpmsg, wID);
}

END_TRACK()

//---------------------------------------------------------------
//
//  IOleInPlaceUIWindow
//
//---------------------------------------------------------------

BEGIN_TRACK(OleInPlaceUIWindow)

HRESULT STDMETHODCALLTYPE
GetWindow(HWND FAR* lphwnd)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetWindow\n", _pch));
    TRETURN(_p->GetWindow(lphwnd));
}

HRESULT STDMETHODCALLTYPE
ContextSensitiveHelp(BOOL fEnterMode)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::ContextSensitiveHelp\n", _pch));
    TRETURN(_p->ContextSensitiveHelp(fEnterMode));
}

HRESULT STDMETHODCALLTYPE
GetBorder(LPRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetBorder\n", _pch));
    TRETURN(_p->GetBorder(lprect));
}

HRESULT STDMETHODCALLTYPE
RequestBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::RequestBorderSpace\n", _pch));
    TRETURN(_p->RequestBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetBorderSpace(LPCRECT lprect)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetBorderSpace\n", _pch));
    TRETURN(_p->SetBorderSpace(lprect));
}

HRESULT STDMETHODCALLTYPE
SetActiveObject(LPOLEINPLACEACTIVEOBJECT lpActiveObject,
            LPCOLESTR lpszObjName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetActiveObject\n", _pch));
    TRETURN(_p->SetActiveObject(lpActiveObject, lpszObjName));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IAdviseSink
//
//---------------------------------------------------------------

BEGIN_TRACK(AdviseSink)

void STDMETHODCALLTYPE
OnDataChange(FORMATETC FAR* pFormatetc,
        STGMEDIUM FAR* pStgmed)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnDataChange\n", _pch));
    _p->OnDataChange(pFormatetc, pStgmed);
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnViewChange(DWORD dwAspects, LONG lindex)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnViewChange\n", _pch));
    _p->OnViewChange(dwAspects, lindex);
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnRename(LPMONIKER pmk)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnRename\n", _pch));
    _p->OnRename(pmk);
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnSave()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnSave\n", _pch));
    _p->OnSave();
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

void STDMETHODCALLTYPE
OnClose()
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::OnClose\n", _pch));
    _p->OnClose();
    InterlockedDecrement((LONG *)&g_ulNestingLevel);
}

END_TRACK()


//---------------------------------------------------------------
//
//  IOleItemContainer
//
//---------------------------------------------------------------

BEGIN_TRACK(OleItemContainer)


HRESULT STDMETHODCALLTYPE
ParseDisplayName(LPBC pbc,
        LPOLESTR lpszDisplayName,
        ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS,
                   "%s::ParseDisplayName(,%ls,,)\n",
                   _pch,
                   OUTPUTSTR(lpszDisplayName)));

    TRETURN(_p->ParseDisplayName(pbc, lpszDisplayName, pchEaten, ppmkOut));
}

HRESULT STDMETHODCALLTYPE
EnumObjects(DWORD grfFlags,
        LPENUMUNKNOWN FAR* ppenumUnknown)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::EnumObjects\n", _pch));
    TRETURN(_p->EnumObjects(grfFlags, ppenumUnknown));
}

HRESULT STDMETHODCALLTYPE
LockContainer(BOOL fLock)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::LockContainer\n", _pch));
    TRETURN(_p->LockContainer(fLock));
}


HRESULT STDMETHODCALLTYPE
GetObject(LPOLESTR lpszItem,
        DWORD dwSpeedNeeded,
        LPBINDCTX pbc,
        REFIID iid, 
        LPVOID FAR* ppvObject)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetObject(%ls,,,,)\n", _pch, OUTPUTSTR(lpszItem)));
    TRETURN(_p->GetObject(lpszItem, dwSpeedNeeded, pbc, iid,  ppvObject));
}

HRESULT STDMETHODCALLTYPE
GetObjectStorage(LPOLESTR lpszItem,
        LPBINDCTX pbc,
        REFIID iid, 
        LPVOID FAR* ppvStorage)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetStorage(%ls,,,)\n", _pch, OUTPUTSTR(lpszItem)));
    TRETURN(_p->GetObjectStorage(lpszItem, pbc, iid,  ppvStorage));
}

HRESULT STDMETHODCALLTYPE
IsRunning(LPOLESTR lpszItem)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::IsRunning(%ls)\n", _pch, OUTPUTSTR(lpszItem)));
    TRETURN(_p->IsRunning(lpszItem));
}

END_TRACK()


//---------------------------------------------------------------
//
//  IOleCommandTarget
//
//---------------------------------------------------------------

BEGIN_TRACK(OleCommandTarget)

HRESULT STDMETHODCALLTYPE
QueryStatus(
            const GUID * pguidCmdGroup,
            ULONG cCmds,
            MSOCMD rgCmds[],
            MSOCMDTEXT * pcmdtext)
{
    INDENT_NESTING;

    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::QueryStatus(group %s, [",
        _pch, pguidCmdGroup ? "non-null" : "NULL"));
    ULONG i;
    for (i=0; i<cCmds; i++)
        TraceTagEx((tagTrackItfVerbose, TAG_FLAGS,
                       " %d",rgCmds[i].cmdID));
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, " ])\n"));

    TRETURN(_p->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
}

HRESULT STDMETHODCALLTYPE
Exec(
            const GUID * pguidCmdGroup,
            DWORD nCmdID,
            DWORD nCmdexecopt,
            VARIANTARG * pvarargIn,
            VARIANTARG * pvarargOut)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Exec(group %s, cmd %d, opts %x)\n",
        _pch, pguidCmdGroup ? "non-null" : "NULL", nCmdID, nCmdexecopt));

    TRETURN(_p->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IHlinkTarget
//
//---------------------------------------------------------------

BEGIN_TRACK(HlinkTarget)

HRESULT STDMETHODCALLTYPE
SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::SetBrowseContext\n", _pch));
    TRETURN(_p->SetBrowseContext(pihlbc));
}

HRESULT STDMETHODCALLTYPE
GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetBrowseContext\n", _pch));
    TRETURN(_p->GetBrowseContext(ppihlbc));
}

HRESULT STDMETHODCALLTYPE
Navigate(DWORD grfHLNF, LPCWSTR wzJumpLocation)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::Navigate(grfHLNF=%x, location=%ls)\n", _pch,
        grfHLNF, OUTPUTSTR(wzJumpLocation)));
    TRETURN(_p->Navigate(grfHLNF, wzJumpLocation));
}

HRESULT STDMETHODCALLTYPE
GetMoniker(LPCWSTR wzLocation, DWORD dwAssign, IMoniker **ppimkLocation)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetMoniker(dwAssign=%x, location=%ls)\n", _pch,
        dwAssign, OUTPUTSTR(wzLocation)));
    TRETURN(_p->GetMoniker(wzLocation, dwAssign, ppimkLocation));
}

HRESULT STDMETHODCALLTYPE
GetFriendlyName(LPCWSTR wzLocation, LPWSTR *pwzFriendlyName)
{
    INDENT_NESTING;
    TraceTagEx((tagTrackItfVerbose, TAG_FLAGS, "%s::GetFriendlyName(location=%ls)\n", _pch,
        OUTPUTSTR(wzLocation)));
    TRETURN(_p->GetFriendlyName(wzLocation, pwzFriendlyName));
}

END_TRACK()

//---------------------------------------------------------------
//
//  IUnknown
//
//---------------------------------------------------------------

#if defined(_M_IX86)

class CUnknownTrack : public CTrack
{   
public:

    CUnknownTrack(IUnknown *p, REFIID iid, char *pch, BOOL fTrackOnQI);
    void *_apfnVTbl;
};

#define THUNK_IMPL(n)\
void __declspec(naked) TrackThunk##n()\
{                                           \
    /* this = thisArg                   */  \
    __asm mov eax, [esp + 4]                \
    /* pUnkObject = this->_p            */  \
    __asm mov ecx, [eax - 4]                \
    /* thisArg = pvObject               */  \
    __asm mov [esp + 4], ecx                \
    /* vtbl = punkObject->vtbl          */  \
    __asm mov ecx, [ecx]                    \
    /* pfn = vtbl[n]                    */  \
    __asm mov ecx, [ecx + (4 * n)]          \
    /* jump....                         */  \
    __asm jmp ecx                           \
}


#define THUNK_ADDR(n) &TrackThunk##n,

static ULONG STDMETHODCALLTYPE
UnknownTrackAddRef(void *pv)
{
    return ((CUnknownTrack *)((BYTE *)pv - offsetof(CUnknownTrack, _apfnVTbl)))->AddRef();
}

static ULONG STDMETHODCALLTYPE
UnknownTrackRelease(void *pv)
{
    return ((CUnknownTrack *)((BYTE *)pv - offsetof(CUnknownTrack, _apfnVTbl)))->Release();
}

static HRESULT STDMETHODCALLTYPE
UnknownTrackQueryInterface(void *pv, REFIID iid, void **ppv)
{
    return ((CUnknownTrack *)((BYTE *)pv - offsetof(CUnknownTrack, _apfnVTbl)))->QueryInterface(iid, ppv);
}

#define THUNK_IT(x) \
THUNK_##x(3)   THUNK_##x(4)   THUNK_##x(5)   THUNK_##x(6)   THUNK_##x(7)   THUNK_##x(8)   THUNK_##x(9)   THUNK_##x(10)  THUNK_##x(11)  THUNK_##x(12)  THUNK_##x(13)  \
THUNK_##x(14)  THUNK_##x(15)  THUNK_##x(16)  THUNK_##x(17)  THUNK_##x(18)  THUNK_##x(19)  THUNK_##x(20)  THUNK_##x(21)  THUNK_##x(22)  THUNK_##x(23)  THUNK_##x(24)  \
THUNK_##x(25)  THUNK_##x(26)  THUNK_##x(27)  THUNK_##x(28)  THUNK_##x(29)  THUNK_##x(30)  THUNK_##x(31)  THUNK_##x(32)  THUNK_##x(33)  THUNK_##x(34)  THUNK_##x(35)  \
THUNK_##x(36)  THUNK_##x(37)  THUNK_##x(38)  THUNK_##x(39)  THUNK_##x(40)  THUNK_##x(41)  THUNK_##x(42)  THUNK_##x(43)  THUNK_##x(44)  THUNK_##x(45)  THUNK_##x(46)  \
THUNK_##x(47)  THUNK_##x(48)  THUNK_##x(49)  THUNK_##x(50)  THUNK_##x(51)  THUNK_##x(52)  THUNK_##x(53)  THUNK_##x(54)  THUNK_##x(55)  THUNK_##x(56)  THUNK_##x(57)  \
THUNK_##x(58)  THUNK_##x(59)  THUNK_##x(60)  THUNK_##x(61)  THUNK_##x(62)  THUNK_##x(63)  THUNK_##x(64)  THUNK_##x(65)  THUNK_##x(66)  THUNK_##x(67)  THUNK_##x(68)  \
THUNK_##x(69)  THUNK_##x(70)  THUNK_##x(71)  THUNK_##x(72)  THUNK_##x(73)  THUNK_##x(74)  THUNK_##x(75)  THUNK_##x(76)  THUNK_##x(77)  THUNK_##x(78)  THUNK_##x(79)  \
THUNK_##x(80)  THUNK_##x(81)  THUNK_##x(82)  THUNK_##x(83)  THUNK_##x(84)  THUNK_##x(85)  THUNK_##x(86)  THUNK_##x(87)  THUNK_##x(88)  THUNK_##x(89)  THUNK_##x(90)  \
THUNK_##x(91)  THUNK_##x(92)  THUNK_##x(93)  THUNK_##x(94)  THUNK_##x(95)  THUNK_##x(96)  THUNK_##x(97)  THUNK_##x(98)  THUNK_##x(99)  THUNK_##x(100) THUNK_##x(101) \
THUNK_##x(102) THUNK_##x(103) THUNK_##x(104) THUNK_##x(105) THUNK_##x(106) THUNK_##x(107) THUNK_##x(108) THUNK_##x(109) THUNK_##x(110) THUNK_##x(111) THUNK_##x(112) \
THUNK_##x(113) THUNK_##x(114) THUNK_##x(115) THUNK_##x(116) THUNK_##x(117) THUNK_##x(118) THUNK_##x(119) THUNK_##x(120) THUNK_##x(121) THUNK_##x(122) THUNK_##x(123) \
THUNK_##x(124) THUNK_##x(125) THUNK_##x(126) THUNK_##x(127) THUNK_##x(128) THUNK_##x(129) THUNK_##x(130) THUNK_##x(131) THUNK_##x(132) THUNK_##x(133) THUNK_##x(134) \
THUNK_##x(135) THUNK_##x(136) THUNK_##x(137) THUNK_##x(138) THUNK_##x(139) THUNK_##x(140) THUNK_##x(141) THUNK_##x(142) THUNK_##x(143) THUNK_##x(144) THUNK_##x(145) \
THUNK_##x(146) THUNK_##x(147) THUNK_##x(148) THUNK_##x(149) THUNK_##x(150) THUNK_##x(151) THUNK_##x(152) THUNK_##x(153) THUNK_##x(154) THUNK_##x(155) THUNK_##x(156) \
THUNK_##x(157) THUNK_##x(158) THUNK_##x(159) THUNK_##x(160) THUNK_##x(161) THUNK_##x(162) THUNK_##x(163) THUNK_##x(164) THUNK_##x(165) THUNK_##x(166) THUNK_##x(167) \
THUNK_##x(168) THUNK_##x(169) THUNK_##x(170) THUNK_##x(171) THUNK_##x(172) THUNK_##x(173) THUNK_##x(174) THUNK_##x(175) THUNK_##x(176) THUNK_##x(177) THUNK_##x(178) \
THUNK_##x(179) THUNK_##x(180) THUNK_##x(181) THUNK_##x(182) THUNK_##x(183) THUNK_##x(184) THUNK_##x(185) THUNK_##x(186) THUNK_##x(187) THUNK_##x(188) THUNK_##x(189) \
THUNK_##x(190) THUNK_##x(191) THUNK_##x(192) THUNK_##x(193) THUNK_##x(194) THUNK_##x(195) THUNK_##x(196) THUNK_##x(197) THUNK_##x(198) THUNK_##x(199)

THUNK_IT(IMPL)

static void (*s_apfnVtbl[])() =
{
    PFNVOID(&UnknownTrackQueryInterface ),
    PFNVOID(&UnknownTrackAddRef ),
    PFNVOID(&UnknownTrackRelease ),
    THUNK_IT(ADDR)
};

CUnknownTrack::CUnknownTrack(IUnknown *p, REFIID iid, char *pch, BOOL fTrackOnQI) : 
    CTrack(p, iid, pch, fTrackOnQI), 
    _apfnVTbl(s_apfnVtbl) 
{ 
}

#endif

//+---------------------------------------------------------------
//
//  g_aIIDtoFN
//
//----------------------------------------------------------------

static struct 
{
    const IID *pIID;
    IUnknown * (*pfnCreate)(IUnknown *, char *, BOOL);
}
g_aIIDtoFN[] = 
{
    { &IID_IOleObject, COleObject::Create }, 
    { &IID_IParseDisplayName, COleItemContainer::Create }, 
    { &IID_IOleContainer, COleItemContainer::Create }, 
    { &IID_IOleItemContainer, COleItemContainer::Create }, 
    { &IID_IOleClientSite, COleClientSite::Create }, 
    { &IID_IOleInPlaceSite, COleInPlaceSiteWindowless::Create }, 
    { &IID_IOleInPlaceSiteWindowless, COleInPlaceSiteWindowless::Create }, 
    { &IID_IDataObject, CDataObject::Create }, 
    { &IID_IViewObject, CViewObject::Create }, 
    { &IID_IPersist, CPersistStorage::Create }, 
    { &IID_IPersistStorage, CPersistStorage::Create }, 
    { &IID_IPersistFile, CPersistFile::Create }, 
    { &IID_IPersistStream, CPersistStream::Create }, 
    { &IID_IPersistStreamInit, CPersistStreamInit::Create }, 
    { &IID_IPersistPropertyBag, CPersistPropertyBag::Create }, 
    { &IID_IOleInPlaceObject, COleInPlaceObject::Create }, 
    { &IID_IOleControl, COleControl::Create }, 
	{ &IID_IOleInPlaceActiveObject, COleInPlaceActiveObject::Create }, 
	{ &IID_IOleInPlaceFrame, COleInPlaceFrame::Create }, 
	{ &IID_IOleInPlaceUIWindow, COleInPlaceUIWindow::Create }, 
	{ &IID_IOleCommandTarget, COleCommandTarget::Create }, 
	{ &IID_IHlinkTarget, CHlinkTarget::Create }, 
};

//+---------------------------------------------------------------
//
//  Function:   DbgExTrackItf
//
//  Synopsis:   Wraps an interface pointer for the purpose of
//              tracing the method calls on that pointer
//
//  Arguments:  iid The interface of the pointer
//              pch A string prefix to use in the trace output
//              ppv  The pointer to the interface. Updated on return.
//
//----------------------------------------------------------------

void WINAPI
DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv)
{
    
    if (     
           *ppv == NULL
        || !(DbgExIsTagEnabled(tagTrackItf) || DbgExIsTagEnabled(tagTrackItfVerbose)) 
        || iid == IID_IUnknown 
#if defined(_M_IX86)
        || (void *)s_apfnVtbl == **(void ***)ppv
#endif
        )
    {
        return;
    }

    for (int i = ARRAY_SIZE(g_aIIDtoFN); --i >= 0; )
    {
        if (iid == *g_aIIDtoFN[i].pIID)
            break;
    }

    if (i < 0)
    {
#if defined(_M_IX86)
        CUnknownTrack * pUnknownTrack = new CUnknownTrack((IUnknown *)*ppv, iid, pch, fTrackOnQI);
        if (pUnknownTrack)
            *ppv = &pUnknownTrack->_apfnVTbl;
#endif
    }
    else
    {
        void *pv = g_aIIDtoFN[i].pfnCreate((IUnknown *)*ppv, pch, fTrackOnQI);
        if (pv)
            *ppv = pv;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\magic.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       magic.cxx
//
//  Contents:   Stack backtracing functions
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IMAGEHLP_H_
#define X_IMAGEHLP_H_
#include <imagehlp.h>
#endif

//$ WIN64: Needs to use 64-bit APIs for ImageHelp

BOOL       g_fLoadedImageHlp = FALSE;
HINSTANCE  g_hinstImageHlp   = NULL;
BOOL       g_fOSIsNT         = FALSE;

ExternTag(tagMagic);

//
// Critical Section used to serialize access to imagehlp.dll
//
void TestStackTrace(void);

// Function Pointers to APIs in IMAGEHLP.DLL. Loaded dynamically.
//
typedef LPAPI_VERSION (__stdcall *pfnImgHlp_ImagehlpApiVersionEx)(
    LPAPI_VERSION AppVersion
    );

typedef BOOL (__stdcall *pfnImgHlp_StackWalk)(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetModuleInfo)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    );

typedef LPVOID (__stdcall *pfnImgHlp_SymFunctionTableAccess)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetSymFromAddr)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PDWORD              pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    );

typedef BOOL (__stdcall *pfnImgHlp_SymInitialize)(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     fInvadeProcess
    );

typedef BOOL (__stdcall *pfnImgHlp_SymLoadModule)(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );

typedef DWORD (__stdcall *pfnImgHlp_SymSetOptions)(
    IN  DWORD           SymOptions
    );

pfnImgHlp_ImagehlpApiVersionEx    _ImagehlpApiVersionEx;
pfnImgHlp_StackWalk               _StackWalk;
pfnImgHlp_SymGetModuleInfo        _SymGetModuleInfo;
pfnImgHlp_SymFunctionTableAccess  _SymFunctionTableAccess;
pfnImgHlp_SymGetSymFromAddr       _SymGetSymFromAddr;
pfnImgHlp_SymInitialize           _SymInitialize;
pfnImgHlp_SymLoadModule           _SymLoadModule;
pfnImgHlp_SymSetOptions           _SymSetOptions;


struct IMGHLPFN_LOAD
{
    LPSTR   pszFnName;
    LPVOID * ppvfn;
};

IMGHLPFN_LOAD ailFuncList[] =
{
    { "ImagehlpApiVersionEx",   (LPVOID*)&_ImagehlpApiVersionEx },
    { "StackWalk",              (LPVOID*)&_StackWalk },
    { "SymGetModuleInfo",       (LPVOID*)&_SymGetModuleInfo },
    { "SymFunctionTableAccess", (LPVOID*)&_SymFunctionTableAccess },
    { "SymGetSymFromAddr",      (LPVOID*)&_SymGetSymFromAddr },
    { "SymInitialize",          (LPVOID*)&_SymInitialize },
    { "SymLoadModule",          (LPVOID*)&_SymLoadModule },
    { "SymSetOptions",          (LPVOID*)&_SymSetOptions },
};


//+---------------------------------------------------------------------------
//
//  Function:   MagicInit
//
//  Synopsis:   Initializes the symbol loading code.
//
//----------------------------------------------------------------------------

void
MagicInit(void)
{
    OSVERSIONINFOA ovi;
    API_VERSION    AppVersion = { 4, 0, API_VERSION_NUMBER, 0 };
    PSTR           pszModPath;
    char           achBuf[MAX_PATH*3];
    char           achBuf2[MAX_PATH];
    char        *  pch;

    int i;

    TraceTag((tagMagic, "MagicInit: Starting."));

    //
    // Get what operating system we're on.
    //
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    Verify(GetVersionExA(&ovi));

    g_fOSIsNT = (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT);

    //
    // Try to load imagehlp.dll
    //
    g_hinstImageHlp = LoadLibraryA("imagehlp.dll");

    if (!g_hinstImageHlp)
    {
        TraceTag((tagWarning, "IMAGEHLP.DLL could not be loaded."));

        return;
    }

    //
    // Try to get the API entrypoints in imagehlp.dll
    //
    for (i=0; i < ARRAY_SIZE(ailFuncList); i++)
    {
        *(ailFuncList[i].ppvfn) = GetProcAddress(g_hinstImageHlp,
                                                 ailFuncList[i].pszFnName);
        if (!*(ailFuncList[i].ppvfn))
        {
            return;
        }
    }

    LPAPI_VERSION papiver = _ImagehlpApiVersionEx(&AppVersion);

    //
    // Verify that imagehlp.dll is a version we're compatible with.
    //
    // (jbeda) It looks like Millinium is returning NULL here (?)
    if (!papiver || (papiver->Revision < 6) || (papiver->Revision > 9))
    {
        TraceTag((tagError, "IMAGEHLP.DLL version mismatch or NULL returned from _ImagehlpApiVersionEx"));
        return;
    }

    g_fLoadedImageHlp = TRUE;


    //
    // ImageHlp doesn't look it very good places for the symbols by default,
    // so here we construct two paths based on where this DLL is located. We
    // set the symbol search path to:
    //
    //       "<dllpath>;<dllpath>\symbols\retail\dll;<windir>\symbols\dll"
    //
    pszModPath = NULL;
    achBuf[0] = 0;

    if (GetModuleFileNameA(g_hinstMain, achBuf, sizeof(achBuf)))
    {
        pch = strrchr(achBuf, '\\');
        if (pch)
        {
            *pch = '\0';
        }

        strcat(achBuf, ";");

        strncat(achBuf, achBuf, strlen(achBuf)-1);

        strcat(achBuf, "\\symbols\\retail\\dll");

        pszModPath = achBuf;
    }

    if (GetWindowsDirectoryA(achBuf2, MAX_PATH))
    {
        strcat(achBuf, ";");
        strcat(achBuf, achBuf2);
        strcat(achBuf, "\\symbols\\dll");
        pszModPath = achBuf;
    }

    _SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);

    //
    // Initialize imagehlp.dll
    //
    TraceTag((tagMagic, "Symbol search path is %s", pszModPath));
    if (!_SymInitialize(g_hProcess, pszModPath, FALSE))
    {
        g_fLoadedImageHlp = FALSE;
    }

    // TestStackTrace();

    TraceTag((tagMagic, "MagicInit: Returning."));

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   MagicDeinit
//
//  Synopsis:   Cleans up for the symbol loading code.
//
//----------------------------------------------------------------------------

void
MagicDeinit(void)
{
    if (g_hinstImageHlp)
    {
        FreeLibrary(g_hinstImageHlp);

        g_hinstImageHlp   = NULL;
        g_fLoadedImageHlp = FALSE;
    }
}

//
// WARNING -- All the functions between here and GetStackBactrace should
// not be called from outside this file! Otherwise this code will not be
// reentrant!
//

//+---------------------------------------------------------------------------
//
//  Function:   AreSymbolsEnabled
//
//  Synopsis:   Returns TRUE if symbols are enabled.
//
//----------------------------------------------------------------------------

BOOL
AreSymbolsEnabled(void)
{
    return (    g_fLoadedImageHlp
            &&  (   DbgExIsTagEnabled(tagSymbols)
                ||  (   DbgExIsTagEnabled(tagSpySymbols)
                    &&  DbgGetThreadState()
                    &&  TLS(fSpyAlloc))));
}

DWORD
LoadModuleFromVMemData(HANDLE hProcess, DWORD dwAddr)
{
    MEMORY_BASIC_INFORMATION mbi;
    char                     achFile[MAX_PATH] = {0};
    DWORD                    cch = 0;

    if (VirtualQueryEx(hProcess, (LPVOID)(DWORD_PTR)dwAddr, &mbi, sizeof(mbi)))
    {
        if (!g_fOSIsNT || (mbi.Type & MEM_IMAGE))
        {
            cch = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase,
                                     achFile,
                                     MAX_PATH);

            TraceTag((tagMagic, "Module Filename is %s", achFile));

            // Ignore the return code since we can't do anything with it.
            if (!_SymLoadModule(hProcess,
                           NULL,
                           ((cch) ? achFile : NULL),
                           NULL,
                           (DWORD)(DWORD_PTR)mbi.AllocationBase,
                           0))
            {
                TraceTag((tagMagic, "SymLoadModule failed with %d", GetLastError()));
            }
            else
            {
                TraceTag((tagMagic, "SymLoadModule succeeded"));
            }

            return (DWORD)(DWORD_PTR)mbi.AllocationBase;
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FillSymbolInfo
//
//  Synopsis:   Fills in a INET_SYMBOL_INFO struct
//
//  Arguments:  [psi]    -- INET_SYMBOL_INFO to fill
//              [dwAddr] -- Address to get symbols of.
//
//----------------------------------------------------------------------------

void
FillSymbolInfo(INET_SYMBOL_INFO *psi, DWORD dwAddr)
{
    union {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };
    CHAR * pszSymbol = NULL;
    IMAGEHLP_MODULE  mi;
    BOOL             fFoundModule = TRUE;

    Assert(psi);

    memset(psi, 0, sizeof(INET_SYMBOL_INFO));

    if (!g_fLoadedImageHlp)
    {
        TraceTag((tagMagic, "ImageHlp not loaded! Bailing out of FillSymbolInfo"));
        return;
    }

    memset(&mi, 0, sizeof(mi));
    mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
    {
        TraceTag((tagMagic, "SymGetModuleInfo failed with %d", GetLastError()));
        //
        // Attempt to load the module here if it hasn't been loaded yet.
        //
        // We do it twice because SymGetModuleInfo seems to not always get it
        // the first time! - WHY? (lylec)
        //
        LoadModuleFromVMemData(g_hProcess, dwAddr);
        LoadModuleFromVMemData(g_hProcess, dwAddr);

        if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
        {
            TraceTag((tagMagic, "SymGetModuleInfo failed AGAIN with %d", GetLastError()));

            strncpy(psi->achModule, "<no module>", sizeof(psi->achModule)-1);

            fFoundModule = FALSE;
        }
    }

    if (fFoundModule)
    {
        psi->achModule[0] = '[';
        strncpy(&psi->achModule[1], mi.ModuleName, sizeof(psi->achModule)-3);
        strcat(psi->achModule, "]");

        TraceTag((tagMagic, "SymGetModuleInfo returned module %s", psi->achModule));
    }

    sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    sym.MaxNameLength = 255;

    if (_SymGetSymFromAddr(g_hProcess, dwAddr, &psi->dwOffset, &sym))
    {
        pszSymbol = sym.Name;
    }
    else
    {
        TraceTag((tagMagic, "SymGetSymFromAddr failed with %d", GetLastError()));
        pszSymbol = "<no symbol>";
    }

    strncpy(psi->achSymbol, pszSymbol, ARRAY_SIZE(psi->achSymbol)-1);
}

//+---------------------------------------------------------------------------
//
//  Helpers for imagehlp's StackWalk API.
//
//----------------------------------------------------------------------------

LPVOID
FormsFunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddr)
{
    return _SymFunctionTableAccess( hProcess, dwPCAddr );
}


//+---------------------------------------------------------------------------
//
//  Function:   FormsGetModuleBase
//
//  Synopsis:   Retrieves the base address of the module containing the given
//              virtual address.
//
//  Arguments:  [hProcess]      -- Process
//              [ReturnAddress] -- Virtual address to get base of.
//
//  Notes:      If the module information for the given module has not yet
//              been loaded, then it is loaded.
//
//----------------------------------------------------------------------------

DWORD_PTR
FormsGetModuleBase(HANDLE hProcess, DWORD_PTR ReturnAddress)
{
    IMAGEHLP_MODULE ModuleInfo;
    DWORD           dwBaseAddr;

    memset(&ModuleInfo, 0, sizeof(IMAGEHLP_MODULE));
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (_SymGetModuleInfo(hProcess, ReturnAddress, &ModuleInfo))
    {
        dwBaseAddr = ModuleInfo.BaseOfImage;
    }
    else
    {
        dwBaseAddr = LoadModuleFromVMemData(hProcess, ReturnAddress);
    }

    return dwBaseAddr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStackBacktrace
//
//  Synopsis:   Gets a stacktrace of the current stack, including symbols.
//
//  Arguments:  [ifrStart] -- How many stack elements to skip before starting.
//              [cfrTotal] -- How many elements to trace after starting
//              [pdwEip]   -- Array to be filled with stack addresses.
//              [psiSym]   -- This array is filled with symbol information.
//                             It should be big enough to hold cfrTotal elts.
//                             If NULL, no symbol information is stored.
//
//  Returns:    Number of elements actually retrieved.
//
//----------------------------------------------------------------------------

int
GetStackBacktrace(int             ifrStart,
                  int             cfrTotal,
                  DWORD *         pdwEip,
                  INET_SYMBOL_INFO *   psiSymbols)
{
    HANDLE        hThread;
    CONTEXT       context;
    STACKFRAME    stkfrm;
    DWORD         dwMachType;
    int           i;
    DWORD       * pdw        = pdwEip;
    INET_SYMBOL_INFO * psi        = psiSymbols;
    BOOL          fNeedLeave = TRUE;

    EnsureThreadState();

    TraceTag((tagMagic, "Entering GetStackBacktrace"));

    memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

    if (psiSymbols)
    {
        memset(psiSymbols, 0, cfrTotal * sizeof(INET_SYMBOL_INFO));
    }

    if (!g_fLoadedImageHlp)
    {
        TraceTag((tagMagic, "ImageHlp not loaded! Bailing out of GetStackBacktrace!"));

        return 0;
    }

    hThread  = GetCurrentThread();

#if !defined(UNIX) && !defined(_M_IA64)                    // UNIXTODO will something similar be needed ?
    context.ContextFlags = CONTEXT_FULL;
#endif

    // Officially, GetThreadContext can't be called on the running thread.
    if (GetThreadContext(hThread, &context))
    {
        memset(&stkfrm, 0, sizeof(STACKFRAME));

#if defined(_M_IX86)
        dwMachType = IMAGE_FILE_MACHINE_I386;

#if 0
        DWORD         dwEIP;
        DWORD         dwESP;
        DWORD         dwEBP;

        _asm
        {
                // Hack getting EIP into a register
                call label
        label:
                // Pop EIP into EAX
                pop eax
                // Store EIP into dwEIP
                mov [dwEIP], eax    ;
                mov [dwEBP], ebp        ; Move EBP into dwEBP
                mov [dwESP], esp        ; Move ESP into dwESP
        }

        // Initialize the STACKFRAME structure
        stkfrm.AddrPC.Offset    = dwEIP;
        stkfrm.AddrPC.Mode      = AddrModeFlat;
        stkfrm.AddrStack.Offset = dwESP;
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = dwEBP;
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#else
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter
        stkfrm.AddrPC.Mode      = AddrModeFlat;
        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#endif
#elif defined(_M_AMD64)
        dwMachType              = IMAGE_FILE_MACHINE_AMD64;
        stkfrm.AddrPC.Offset    = context.Rip;  // Program Counter
        stkfrm.AddrPC.Mode      = AddrModeFlat;
#elif defined(UNIX)
        dwMachType              = (DWORD) -1; // IEUNIX fill in correctly
        stkfrm.AddrPC.Offset    = 0; // IEUNIX fill in correctly
        stkfrm.AddrPC.Mode      = AddrModeFlat;
#elif defined(_M_IA64)
        dwMachType              = IMAGE_FILE_MACHINE_IA64;
        stkfrm.AddrPC.Offset    = 0; //$WIN64 (IA64) Which is the program counter register?
        stkfrm.AddrPC.Mode      = AddrModeFlat;
#else
#error("Unknown Target Machine");
#endif

        //
        // We have to use a critical section because MSPDB50.DLL (and
        // maybe imagehlp.dll) is not reentrant and simultaneous calls
        // to StackWalk cause it to tromp on its own memory.
        //
        EnterCriticalSection(&g_csHeapHack);

        // Check this again just in case another thread failed and caused
        // imagehlp.dll to be unloaded.

        if (!g_fLoadedImageHlp)
        {
            return 0;
        }

        __try
        {
            for (i = 0; i < ifrStart + cfrTotal; i++)
            {
                if (!_StackWalk(dwMachType,
                                g_hProcess,
                                hThread,
                                &stkfrm,
                                &context,
                                NULL,
                                FormsFunctionTableAccess,
                                FormsGetModuleBase,
                                NULL))
                {
                    break;
                }

                if (i >= ifrStart)
                {
                    *pdw++ = stkfrm.AddrPC.Offset;

                    if (psi)
                    {
                        FillSymbolInfo(psi++, stkfrm.AddrPC.Offset);
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Something blew up. This can happen if someone asserts during
            // process cleanup or just because things are hosed. In this case
            // we empty our return data, unload imagehlp.dll so we don't try
            // any of this again, and return 0.
            //
            memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

            if (psiSymbols)
            {
                memset(psiSymbols, 0, cfrTotal * sizeof(INET_SYMBOL_INFO));
            }

            // Block anyone else from using imagehlp.

            g_fLoadedImageHlp = FALSE;

            LeaveCriticalSection(&g_csHeapHack);

            fNeedLeave = FALSE;

            // This deletes the critical section
            MagicDeinit();

            pdw = pdwEip; // Will cause us to return 0
        }
        __endexcept
    }

    if (fNeedLeave)
    {
        LeaveCriticalSection(&g_csHeapHack);
    }

    return pdw - pdwEip;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromSymbolInfo
//
//  Synopsis:   Returns a string from an INET_SYMBOL_INFO
//
//  Arguments:  [dwAddr]    -- Memory Address corresponding to [psi]
//              [psi]       -- Pointer to INET_SYMBOL_INFO. Can be NULL.
//              [pszString] -- Place to put string
//
//----------------------------------------------------------------------------

void
GetStringFromSymbolInfo(DWORD dwAddr, INET_SYMBOL_INFO *psi, CHAR *pszString)
{
    if (psi)
    {

        wsprintfA(pszString,
                 "  %08x  %-11hs %hs + 0x%x",
                 dwAddr,
                 (psi->achModule[0]) ? psi->achModule : "<no module>",
                 (psi->achSymbol[0]) ? psi->achSymbol : "<no symbol>",
                 psi->dwOffset);
    }
    else
    {
        wsprintfA(pszString, "  %08x <symbols not available>", dwAddr);
    }
}

void WINAPI
DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf)
{
    INET_SYMBOL_INFO     si;
    char            ach[512];

    ach[0] = 0;

    FillSymbolInfo(&si, (DWORD)(DWORD_PTR)pvAddr);
    GetStringFromSymbolInfo((DWORD)(DWORD_PTR)pvAddr, &si, ach);
    strncpy(pszBuf, ach, cchBuf - 1);
    pszBuf[cchBuf - 1] = 0;
}

//
// Get stack trace, starting from frame iStart, and at most cTotal frames
//
// Results are returned in pvBuffer as array of
//      { DWORD dwAddress, char achModule[cchModule + 1], char achSymbol[cchSymbol + 1] }
//
// Stack trace depth is arbitrary limited at 100
//
int WINAPI
DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol)
{
    INET_SYMBOL_INFO asiSym[100];
    DWORD            dwEip[100];
    int              i;
    int              c = 0;
    int              cchMaxCopyModule = min(ARRAY_SIZE(asiSym[i].achModule), cchModule);
    int              cchMaxCopySymbol = min(ARRAY_SIZE(asiSym[i].achSymbol), cchSymbol);

    EnsureThreadState();

    // limit symbol lengths
    if (cTotal > ARRAY_SIZE(dwEip))
        cTotal = ARRAY_SIZE(dwEip);

    if (cTotal > (int) (cbBuffer / (sizeof(DWORD) + sizeof(char) * (cchModule + 1 + cchSymbol + 1)))) 
        cTotal = (int) (cbBuffer / (sizeof(DWORD) + sizeof(char) * (cchModule + 1 + cchSymbol + 1)));

    memset(pbBuffer, 0, cbBuffer);

    //
    // get the stack
    //
    c = GetStackBacktrace(iStart + 3, cTotal, dwEip, asiSym);

    // Copy stack to caller's buffer
    for (i = 0; i < c; i++)
    {
        *((DWORD *)pbBuffer) = dwEip[i];
        pbBuffer += sizeof(DWORD);

        // GetStackBacktrace puts square brackets around module name. Remove.
        char * pchModuleName     = asiSym[i].achModule + 1;
        char * pchModuleNameLim  = strchr(pchModuleName, ']');
        int    cchCopyModuleName = pchModuleNameLim
                                 ? min(pchModuleNameLim - pchModuleName, cchMaxCopyModule)
                                 : cchMaxCopyModule;
        
        strncpy((char *)pbBuffer, pchModuleName, cchCopyModuleName);
        pbBuffer += cchModule + 1;
        
        strncpy((char *)pbBuffer, asiSym[i].achSymbol, cchMaxCopySymbol);
        pbBuffer += cchSymbol + 1;
    }

    return c;
}


// -----------------
//
// Stacktrace Testing Code
//
// -----------------

int
Alpha(int n, int cdw, DWORD * pdw, INET_SYMBOL_INFO *psi)
{
    int     c;

    if (n > 0)
    {
        c = Alpha(n - 1, cdw, pdw, psi);
    }
    else
    {
        c = GetStackBacktrace(1, cdw, pdw, psi);
    }

    return c;
}


class CBeta
{
public:
    void        Foo(void);
    STDMETHOD(Bar) (int x, int y);
};

void
CBeta::Foo( )
{
    Bar(1, 2);
}

STDMETHODIMP
CBeta::Bar(int x, int y)
{
    int              i;
    int              c;
    DWORD            dwEip[8];
    INET_SYMBOL_INFO      asiSym[8];
    CHAR             achSymbol[256];

    TraceTag((0, "CBeta::Bar"));

    c = GetStackBacktrace(1, ARRAY_SIZE(dwEip), dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);

        TraceTag((0, "%s", achSymbol));
    }

    return S_OK;
}


void
TestStackTrace( )
{
    int              i;
    int              c;
    DWORD            dwEip[8];
    INET_SYMBOL_INFO      asiSym[8];
    CBeta            Beta;
    CHAR             achSymbol[256];

    static BOOL  fRepeat = FALSE;

    if (fRepeat)
    {
        return;
    }

    fRepeat = TRUE;

    TraceTag((0, "GetStackBacktrace"));

    c = GetStackBacktrace(1, ARRAY_SIZE(dwEip), dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);

        TraceTag((0, "%s", achSymbol));
    }

    TraceTag((0, "Alpha(3)"));

    c = Alpha(3, ARRAY_SIZE(dwEip), dwEip, asiSym);
    for (i = 0; i < c; i++)
    {
        GetStringFromSymbolInfo(dwEip[i], &asiSym[i], achSymbol);

        TraceTag((0, "%s", achSymbol));
    }

    Beta.Foo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       resource.h
//
//  History:    10-06-93   ErikGav   Created
//
//----------------------------------------------------------------------------


#define tmcOk                   IDOK
#define tmcCancel               IDCANCEL
#define tmcStatic               -1
#define tmcListbox              101
#define tmcEnabled              102
#define tmcDisk                 103
#define tmcBreak                105
#define tmcEnableAll            107
#define tmcDisableAll           108

// Simulate failure dialog resources
#define IDD_SIMFAIL                 200
#define ID_LBLFAIL                  201
#define ID_TXTFAIL                  202
#define ID_LBLINTERVAL              203
#define ID_TXTINTERVAL              204
#define ID_LBLCOUNT                 205
#define ID_TXTCOUNT                 206
#define ID_BTNRESET                 207
#define ID_BTNNEVER                 208
#define ID_BTNUPDATE                209

/* Control Ids for the two dialogs - HeapMon & BlockEdit */
 
#define IDD_HEAPMON                 1000
#define IDG_HEADER                  1010
#define IDT_ALLOCNUM                1020
#define IDT_LIVEBLOCK               1030
#define IDT_FRAGIDX                 1040
#define IDE_ALLOCNUM                1050
#define IDE_LIVEBLOCK               1060
#define IDE_FRAGIDX                 1070
#define IDT_VIRTUAL                 1080
#define IDT_FILL                    1090
#define IDE_BLOCKS                  1100
#define IDT_BLOCKS                  1110
#define IDC_REFRESH                 1120
#define IDC_CLOSE                   1130
#define IDC_FILEDUMP                1140
#define IDE_FILEDUMP                1150
#define IDC_BLOCKLIST               1160
#define IDE_LIVEMEMORY              1200
#define IDG_SORTBY                  1210
#define IDC_SORTCFLAG               1220
#define IDC_SORTTYPE                1221
#define IDC_SORTNAME                1222
#define IDC_SORTADDRESS             1230
#define IDC_SORTALLOC               1240
#define IDC_SORTSIZE                1250
#define IDT_LIVEMEMORY              1260
#define IDT_RANGELOW                1280
#define IDE_RANGELOW                1270
#define IDT_RANGEHIGH               1310
#define IDE_RANGEHIGH               1290
#define IDT_RANGEEXTENT             1330
#define IDE_RANGEEXTENT             1300
#define IDC_SUMSEL                  1190
#define IDE_SUMSEL                  1320
#define IDC_HEAPLIST                1170
#define IDT_HEAPNAME                1180
#define IDC_VIRTUAL					1400
#define IDC_LOAD_SYMBOLS			1410
#define IDC_DUMPHEAPS               1411

#define IDD_BLOCKEDIT               2000
#define IDT_BE_ADDRESS              2010
#define IDT_BE_ALLOCNUM             2030
#define IDT_BE_SIZE                 2040
#define IDE_BE_ADDRESS              2050
#define IDE_BE_ALLOCNUM             2070
#define IDE_BE_SIZE                 2080
#define IDC_BE_MEMORY               2100
#define IDG_DATATYPE                2090
#define IDC_DWORD                   2110
#define IDC_WORD                    2120
#define IDC_BYTE                    2130
#define IDT_CALLSTACK               2170
#define IDC_CALLSTACK               2180

#define IDB_ICONIC					3000
#define IIC_ICONIC					3010

#define BROWSE_DLG					3000
#define IDC_TRACE_LIST				3001
#define ID_ADD						3002
#define ID_VIEW						3003
#define ID_REFRESH					3004
#define IDC_TOTALMEM                1000
#define IDC_CODEMEM                 1001
#define IDC_DATAMEM                 1002
#define IDC_RESERVEMEM              1003
#define IDC_READONLY                1004
#define IDC_READWRITE               1005
#define IDC_STATIC                  -1
#define ID_DUMP						3005

/* Perftags */

#define IDD_PERFTAGS                9700
#define IDC_TAGLIST                 9702
#define IDC_ENABLEALL               9703
#define IDC_DISABLEALL              9704
#define IDC_CLEARLOG                9705
#define IDC_DUMPLOG                 9706
#define IDC_DELETELOG               9707
//was:  IDC_REFRESH                 9708
#define IDC_STARTSTOP               9709
#define IDC_CLEARMETER              9710
#define IDC_BREAKMETER              9711
#define IDC_OOMMETER                9712
#define IDC_USEINTERVALOOM          9713
#define IDC_OOMINTERVAL             9714
#define IDC_ALLMEM                  9715
#define IDC_MARKEDMEM               9716
#define IDC_OOMCOUNT                9717
#define IDC_BREAKOOM                9718
#define IDC_EXPANDALL               9719
#define IDC_COLLAPSEALL             9720
#define IDC_CLEAROOM                9721
#define IDC_CLEARBREAK              9722

#define IDD_PERFMETER               9800

#define IDC_SHOWMETERS              9802
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\simfail.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simfail.cxx
//
//  Contents:   Simulated failure testing.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

// Timer used to update Count display.
const UINT ID_TIMER = 1;

// Interval of update, in milliseconds.
const UINT TIMER_INTERVAL = 500;

// Number of times FFail is called after g_cfirstFailure is hit.
int     g_cFFailCalled;

// Number of success calls before first failure.  If 0, all calls successful.
int     g_firstFailure;

// Interval to repeat failures after first failure.
int     g_cInterval = 1;

// User defined error for simulated win32 failures.
const DWORD ERR_SIMWIN32 = 0x0200ABAB;

// Handle of simulated failures dialog.
HWND    g_hwndSimFailDlg;

DWORD WINAPI SimFailDlgThread(LPVOID lpThreadParameter);
extern "C" LRESULT CALLBACK SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam );

//+---------------------------------------------------------------------------
//
//  Function:   ResetFailCount
//
//  Synopsis:   Resets the count of calls to FFail.
//
//----------------------------------------------------------------------------

void
ResetFailCount()
{
    LOCK_GLOBALS;
    Assert(g_firstFailure >= 0);
    g_cFFailCalled = (g_firstFailure != 0) ? -g_firstFailure : INT_MIN;
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExSetSimFailCounts
//
//  Synopsis:   Sets the parameters for simulated failures, and resets the
//              count of failures.
//
//  Arguments:  [firstFailure] -- Number of successes - 1 before first failure.
//                                If 0, simulated failures are turned off.
//                                If -1, parameter is ignored.
//
//              [cInterval]    -- Interval at which success are repeated.
//                                If 0, set to 1.
//                                If -1, parameter is ignored.
//
//  Notes:      To reset the count of failures,
//              call DbgExSetSimFailCounts(-1, -1).
//
//----------------------------------------------------------------------------

void WINAPI
DbgExSetSimFailCounts(int firstFailure, int cInterval)
{
    EnsureThreadState();

    LOCK_GLOBALS;

    if (firstFailure >= 0)
    {
        g_firstFailure = firstFailure;
    }

    if (cInterval > 0)
    {
        g_cInterval = cInterval;
    }
    else if (cInterval == 0)
    {
        g_cInterval = 1;
    }

    ResetFailCount();
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExShowSimFailDlg
//
//  Synopsis:   Displays the simulated failures dialog in a separate thread.
//
//----------------------------------------------------------------------------

void WINAPI
DbgExShowSimFailDlg()
{
#ifndef _MAC
    THREAD_HANDLE  hThread = NULL;
    ULONG   idThread;

    EnsureThreadState();

    LOCK_RESDLG;

    if (g_hwndSimFailDlg)
    {
        BringWindowToTop(g_hwndSimFailDlg);
    }
    else
    {
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SimFailDlgThread, NULL, 0, &idThread);
        if (!hThread)
        {
            TraceTag((tagError, "CreateThread failed DbgExShowSimFailDlg"));
            goto Cleanup;
        }

        CloseThread(hThread);
    }
Cleanup:
    ;
#else
    SimFailDlgThread(NULL);
#endif      // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgThread
//
//  Synopsis:   Creates the simulated failures dialog and runs a message loop
//              until the dialog is closed.
//
//----------------------------------------------------------------------------

DWORD WINAPI
SimFailDlgThread(LPVOID lpThreadParameter)
{
#ifndef _MAC
    MSG         msg;

    EnsureThreadState();

    g_hwndSimFailDlg = CreateDialog(
            g_hinstMain,
            MAKEINTRESOURCE(IDD_SIMFAIL),
            NULL,
            (DLGPROC) SimFailDlgProc);

    if (!g_hwndSimFailDlg)
    {
        TraceTag((tagError, "CreateDialogA failed in SimFailDlgEntry"));
        return (DWORD) -1;
    }

    SetWindowPos(
            g_hwndSimFailDlg,
            HWND_TOP,
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

    while (GetMessage((LPMSG) &msg, (HWND) NULL, 0, 0))
    {
        if (!g_hwndSimFailDlg || (!IsDialogMessage(g_hwndSimFailDlg, &msg)))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
#else
    int r;
    r = DialogBox(g_hinstMain, MAKEINTRESOURCE(IDD_SIMFAIL),
                                    NULL, (DLGPROC) SimFailDlgProc);
    if (r == -1)
    {
        MessageBoxA(NULL, "TRI Couldn't create sim failures dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD) g_hwndSimFailDlg;
#endif  // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateTextControls
//
//  Synopsis:   Updates the FirstFail and FailInterval text controls.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateTextControls(HWND hwnd)
{
#ifndef _MACUNICODE
    TCHAR   ach[16];

    LOCK_GLOBALS;
    ach[ARRAY_SIZE(ach) - 1] = '\0';
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_firstFailure);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTFAIL), ach);
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_cInterval);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach);
#else
    CHAR   ach[16];

    _snprintf(ach, ARRAY_SIZE(ach), ("%d"), g_firstFailure);
    SetWindowTextA((GetDlgItem(hwnd, ID_TXTFAIL)), ach);
    _snprintf(ach, ARRAY_SIZE(ach), ("%d"), g_cInterval);
    SetWindowTextA((GetDlgItem(hwnd, ID_TXTINTERVAL)), ach);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateCount
//
//  Synopsis:   Updates the count text control.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateCount(HWND hwnd)
{
#ifndef _MACUNICODE
    TCHAR   ach[16];
    
    ach[ARRAY_SIZE(ach) - 1] = '\0';
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), DbgExGetFailCount());
    Edit_SetText(GetDlgItem(hwnd, ID_TXTCOUNT), ach);
#else
    CHAR   ach[16];

    _snprintf(ach, ARRAY_SIZE(ach), ("%d"), DbgExGetFailCount());
    SetWindowTextA(GetDlgItem(hwnd, ID_TXTCOUNT), ach);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateValues
//
//  Synopsis:   Sets the simulated failure counts with values from the
//              dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateValues(HWND hwnd)
{
    int     firstFail;
    int     cInterval;
#ifndef _MACUNICODE
    TCHAR   ach[16];
    LOCK_GLOBALS;

    Edit_GetText(GetDlgItem(hwnd, ID_TXTFAIL), ach, ARRAY_SIZE(ach));
    firstFail = _ttoi(ach);

    Edit_GetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach, ARRAY_SIZE(ach));
    cInterval = _ttoi(ach);
#else
    CHAR   ach[16];
    GetWindowTextA(GetDlgItem(hwnd, ID_TXTFAIL), ach, ARRAY_SIZE(ach));
    firstFail = atoi(ach);

    GetWindowTextA(GetDlgItem(hwnd, ID_TXTINTERVAL), ach, ARRAY_SIZE(ach));
    cInterval = atoi(ach);
#endif
    if (firstFail < 0)
    {
        firstFail = 0;
    }
    if (g_cInterval <= 0)
    {
        cInterval = 1;
    }

    DbgExSetSimFailCounts(firstFail, cInterval);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnInitDialog
//
//  Synopsis:   Initializes the dialog.
//
//----------------------------------------------------------------------------

BOOL
SimFailDlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, ID_TXTFAIL), 9);
    Edit_LimitText(GetDlgItem(hwnd, ID_TXTINTERVAL), 9);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
    SetTimer(hwnd, ID_TIMER, TIMER_INTERVAL, NULL);
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnCommand
//
//  Synopsis:   Handles button clicks.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify != BN_CLICKED)
        return;

    switch (id)
    {
    case ID_BTNUPDATE:
        SimFailDlg_UpdateValues(hwnd);
        break;

    case ID_BTNNEVER:
        DbgExSetSimFailCounts(0, 1);
        SimFailDlg_UpdateTextControls(hwnd);
        SimFailDlg_UpdateCount(hwnd);
        break;

    case ID_BTNRESET:
        ResetFailCount();
        SimFailDlg_UpdateCount(hwnd);
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnTimer
//
//  Synopsis:   Updates the failure count.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnTimer(HWND hwnd, UINT id)
{
    Assert(id == ID_TIMER);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnClose
//
//  Synopsis:   Closes the dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnClose(HWND hwnd)
{
    Verify(DestroyWindow(g_hwndSimFailDlg));
    g_hwndSimFailDlg = NULL;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnDestroy
//
//  Synopsis:   Cleans up.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnDestroy(HWND hwnd)
{
    g_hwndSimFailDlg = NULL;
    KillTimer(hwnd, ID_TIMER);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgProc
//
//  Synopsis:   Dialog proc for simulated failures dialog.
//
//----------------------------------------------------------------------------

extern "C"
LRESULT CALLBACK
SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, SimFailDlg_OnInitDialog);
        return TRUE;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hwnd, wParam, lParam, SimFailDlg_OnCommand);
        return TRUE;

    case WM_TIMER:
        HANDLE_WM_TIMER(hwnd, wParam, lParam, SimFailDlg_OnTimer);
        return TRUE;

    case WM_CLOSE:
        HANDLE_WM_CLOSE(hwnd, wParam, lParam, SimFailDlg_OnClose);
        return TRUE;

    case WM_DESTROY:
        HANDLE_WM_DESTROY(hwnd, wParam, lParam, SimFailDlg_OnDestroy);
        return TRUE;
    }

    return FALSE;
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceFailL
//
//  Synopsis:   Traces failures.  Enable tagTestFailures to see trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

LONG_PTR WINAPI
DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TRI TFAIL: Failure of \"%s\" at %s:%d <%d>",
        "TRI TFAIL: Simulated failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_FAIL: Failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_FAIL: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    DbgExTraceExit(pstrExpr, pstrFile, line);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    TraceTagEx((
            fIgnore ? tagTestFailuresIgnore : tagTestFailures,
            TAG_NONAME,
            aapstr[fIgnore ? 1 : 0][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            (LONG)errExpr));

    return errExpr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceWin32L
//
//  Synopsis:   Traces Win32 failures, displaying the value of GetLastError if
//              the failure is not simulated.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

LONG_PTR WINAPI
DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TRI TW32: Failure of \"%s\" at %s:%d <%d> GetLastError=<%d>",
        "TRI TW32: Simulated failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_W32: Failure of \"%s\" at %s:%d <%d>",
        "TRI IGNORE_W32: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    DbgExTraceExit(pstrExpr, pstrFile, line);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    if (JustFailed())
    {
        SetLastError(ERR_SIMWIN32);
    }

    TraceTagEx((
            fIgnore ? tagTestFailuresIgnore : tagTestFailures,
            TAG_NONAME,
            aapstr[fIgnore ? 1 : 0][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            (LONG)errExpr,
            GetLastError()));

    return errExpr;
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceHR
//
//  Synopsis:   Traces HRESULT failures.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [hrTest]   -- The expression to test.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

HRESULT WINAPI
DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    static LPSTR aapstr[2][2] =
    {
        "TRI THR: Failure of \"%s\" at %s:%d %hr",
        "TRI THR: Simulated failure of \"%s\" at %s:%d %hr",
        "TRI IGNORE_HR: Failure of \"%s\" at %s:%d %hr",
        "TRI IGNORE_HR: Simulated failure of \"%s\" at %s:%d %hr",
    };

    // Assert if we get one of the following errors.
    // The caller is doing something wrong if it gets one.

    static long ahrEvil[] = 
    {
        RPC_E_CANTPOST_INSENDCALL,
        RPC_E_CANTCALLOUT_INASYNCCALL,
        RPC_E_CANTCALLOUT_INEXTERNALCALL,
        RPC_E_CANTCALLOUT_AGAIN,
        RPC_E_CANTCALLOUT_ININPUTSYNCCALL,
        RPC_E_WRONG_THREAD,
        RPC_E_THREAD_NOT_INIT,
    };

    DbgExTraceExit(pstrExpr, pstrFile, line);

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    if (SUCCEEDED(hrTest))
        return hrTest;
    
    TraceTagEx((
            fIgnore ? tagTestFailuresIgnore : tagTestFailures,
            TAG_NONAME,
            aapstr[fIgnore ? 1 : 0][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            hrTest));

    for (int i = ARRAY_SIZE(ahrEvil); --i >= 0;)
    {
        if (hrTest == ahrEvil[i])
            Assert(0 && "Unexpected error code encoutered.");
    }

    if ( fIgnore ) {
        // Added if statement to be able to put a breakpoint
        // for failing THRs but not IGNOREHRs
        return hrTest;
    }

    return hrTest;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceEnter
//
//  Synopsis:   Traces entrace to a THR-wrapped function call
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

void WINAPI
DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
//
//  THIS IS DEBUG TRACE CODE
//  To enter the call wrapped by THR, step out and back in. (VC Shift-F11, F11)
//
    TraceTagEx((
            tagTraceCalls,
            TAG_NONAME | TAG_INDENT,
            "TRI THR Enter \"%s\" at %s:%d",
            pstrExpr,
            pstrFile,
            line));
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceExit
//
//  Synopsis:   Traces exit from a THR-wrapped function call
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

void WINAPI
DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    TraceTagEx((
            tagTraceCalls,
            TAG_NONAME | TAG_OUTDENT,
            "TRI THR Exit  \"%s\" at %s:%d",
            pstrExpr,
            pstrFile,
            line));
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgExTraceOLE
//
//  Synopsis:   Traces OLE interface calls. Enable tagOLEWatch to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in f3debug.h instead.
//
//  Arguments:  [hrTest]   -- The expression to test.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

HRESULT WINAPI
DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite)
{
    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

	// Note that in the case of failure an imbedded call to the TRH() macro
	// performs the trace dump.
    if (FAILED(hrTest))
        return hrTest;

    TraceTagEx((
            tagOLEWatch,
            TAG_NONAME,
            "TRI THR_OLE:\"%s\" returns %hr at %s:%d site 0x%x",
            pstrExpr,
            hrTest,
            pstrFile,
            line,
			lpsite));

    return hrTest;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgExCheckAndReturnResultList
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure, and asserts
//              if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [pstrFile]  -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                                  being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes
//                               or failure SCODES that should not be traced.
//              [...]       -- list of HRESULTS.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
// HRESULTs passed in should either be permitted success codes, permitted
// non-OLE error codes, or expected OLE error codes.  Expected OLE error codes
// prevent a warning from being printed to the debugger, while the rest cause
// asserts if they're not given as an argument.
//
// An OLE error code has a facility not equal to FACILITY_ITF or is equal to
// FACILITY_ITF and the code is less than the current maximum value used.
//
//----------------------------------------------------------------------------

HRESULT __cdecl
DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...)
{
    HRESULT hrResult;
    va_list va;

    va_start(va, cHResult);
    hrResult = DbgExCheckAndReturnResultList(hr, fTrace, pstrFile, line, cHResult, va);
    va_end(va);

    return(hrResult);
}

HRESULT WINAPI
DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list va)
{
    BOOL    fOLEError;
    BOOL    fOLEDBError;
    BOOL    fOKReturnCode;
    int     i;
    HRESULT hrArg;

    Verify(!DbgExIsTagEnabled(tagValidate) || DbgExValidateInternalHeap());

    //
    //  These xxx_E_LAST hresults are the highest-valued ones in FACILITY_ITF
    //  currently (at the time of coding).  These asserts should alert us if
    //  the numbers change, and our usage of CONNECT_E_LAST is no longer valid.
    //
    Assert(HRESULT_CODE(CONNECT_E_LAST) == HRESULT_CODE(SELFREG_E_LAST));
    Assert(HRESULT_CODE(CONNECT_E_LAST) == HRESULT_CODE(PERPROP_E_LAST));

    //
    // Check if code is a permitted error or success.
    //

    fOLEError = (hr < 0 &&
                 (HRESULT_FACILITY(hr) != FACILITY_ITF ||
                  HRESULT_CODE(hr) < HRESULT_CODE(CONNECT_E_LAST)));

    // Codes 0x0e00-0x0eff are reserved for the OLE DB group of
    // interfaces.  (So sayeth <oledberr.h>)
    fOLEDBError = HRESULT_FACILITY(hr) == FACILITY_ITF &&
                    0x0E00 <= HRESULT_CODE(hr) && HRESULT_CODE(hr) <= 0x0EFF;
    
    fOKReturnCode = ((cHResult == -1) || fOLEError || fOLEDBError || (hr == S_OK));

    if (cHResult > 0)
    {
        for (i = 0; i < cHResult; i++)
        {
            hrArg = va_arg(va, HRESULT);
            if (hr == hrArg)
            {
                fOKReturnCode = TRUE;

                if (fOLEError)
                    fTrace = FALSE;

                break;
            }
        }
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
        TraceTag((
                tagError,
                "%s:%d returned unpermitted HRESULT %hr",
                pstrFile,
                line,
                hr));
        AssertLocSz(hr <= 0, pstrFile, line,
                    "An unpermitted success code was returned.");
        AssertLocSz(!(HRESULT_FACILITY(hr) == FACILITY_ITF && HRESULT_CODE(hr) >= 0x0200), pstrFile, line,
                    "An unpermitted FACILITY_ITF HRESULT was returned.");
    }

    //
    // Warn on error result.
    //

    if (fTrace && FAILED(hr))
    {
        TraceTagEx((
                tagRRETURN,
                TAG_NONAME,
                "RRETURN: %s:%d returned %hr",
                pstrFile,
                line,
                hr));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\othrthrd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       othrthrd.cxx
//
//  Contents:   Contains utilities that utilize the THREADSTATE data inside
//              MSHTML.DLL.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

void WINAPI
DbgExSetTopUrl(LPWSTR pstrUrl)
{
    WideCharToMultiByte(CP_ACP,
                        0,
                        pstrUrl,
                        -1,
                        TLS(achTopUrl),
                        TOPURL_LENGTH,
                        NULL,
                        NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTopURLForThread
//
//  Synopsis:   Returns the URL of the document in the given thread. For
//              multiple document threads (like a frameset) the topmost one
//              is returned.
//
//  Arguments:  [tid] -- Thread ID desired
//              [psz] -- Pre-allocated buffer to put URL into.
//
//  Returns:    HRESULT, S_FALSE if url cannot be obtained.
//
//  Notes:      Will put "<not available>" in the output string if it cannot
//              be obtained. On an error, [psz] will be empty. Assumes
//              that psz is a buffer of size TOPURL_LENGTH
//
//----------------------------------------------------------------------------

char * szNotAvail = "<not available>";

HRESULT
GetTopURLForThread(DWORD tid, char * psz)
{
    char * pszTop = TLS(achTopUrl);

    if (*pszTop == '\0')
    {
        strcpy(psz, szNotAvail);
        return S_FALSE;
    }
    else
    {
        strcpy(psz, pszTop);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\perftags.cxx ===
//+------------------------------------------------------------------------
//
//  File:       perftags.cxx
//
//  Contents:   Utilities for measuring perf
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#include <stddef.h>
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

struct LOGENTRY
{
    LOGENTRY *  pleNext;
    __int64     t;
    void *      pvObject;
    DWORD       dwThread;
    char        ach[1024];
};

struct LOGBLOCK
{
    LOGBLOCK *  plbNext;
    char        ach[8192];
};

struct LTAG
{
    BOOL    fEnabled;       // This must be first!
    LTAG *   ptagNext;
    char *  pchTag;
    char *  pchOwner;
    char *  pchDesc;
    char    ach[1];
};

extern HINSTANCE  g_hinstMain;
static LTAG *      g_ptagHead = NULL;
static LOGBLOCK * g_plbHead = NULL;
static LOGBLOCK * g_plbTail = NULL;
static LOGENTRY * g_plePrev = NULL;
static LOGENTRY * g_pleNext = NULL;
static UINT       g_cbLeft  = 0;
static UINT       g_nRuntimeAllocations = 0;
CRITICAL_SECTION  g_csLog;
static HWND     ghWnd           = NULL;
static HBRUSH   ghbrBkgnd       = NULL;
static HANDLE   ghThread        = NULL;
static BOOL     fDlgUp          = FALSE;
static DWORD    rgbWindowColor  = 0xFF000000;    // variables for the current
static DWORD    rgbHiliteColor  = 0xFF000000;    // system color settings.
static DWORD    rgbWindowText   = 0xFF000000;    // on a WM_SYSCOLORCHANGE
static DWORD    rgbHiliteText   = 0xFF000000;    // we check to see if we need
static DWORD    rgbGrayText     = 0xFF000000;    // to reload our bitmap.
static DWORD    rgbDDWindow     = 0xFF000000;    //
static DWORD    rgbDDHilite     = 0xFF000000;    // 0xFF000000 is an invalid RGB
static BOOL     g_fEnabled      = FALSE;
static BOOL     g_fAutoDump     = FALSE;
static BOOL     g_fAutoOpen     = FALSE;
static BOOL     g_fAutoDelete   = TRUE;
static BOOL     g_fSimpleDump   = TRUE;
static BOOL     g_fOverwriteDump= FALSE;
static char     g_achDumpFile[MAX_PATH]   = "";

void __cdecl hprintf(HANDLE hfile, char * pchFmt, ...);
#undef MemAlloc
#define MemAlloc(cb)    LocalAlloc(LMEM_FIXED, (cb))
#undef MemFree
#define MemFree(pv)     LocalFree(pv)
void DbgExPerfEnable(BOOL fEnable);


PERFTAG WINAPI
DbgExPerfRegister(char * szTag, char * szOwner, char * szDesc)
{
    EnterCriticalSection(&g_csLog);

    int cbTag   = lstrlenA(szTag) + 1;
    int cbOwner = lstrlenA(szOwner) + 1;
    int cbDesc  = lstrlenA(szDesc) + 1;
    LTAG * ptag  = (LTAG *)MemAlloc(offsetof(LTAG, ach) + cbTag + cbOwner + cbDesc);
    char * pch  = ptag->ach;

    if (!ptag)
        return NULL;

    ptag->ptagNext = g_ptagHead;
    ptag->fEnabled = (BYTE)!!GetPrivateProfileIntA("perftags", szTag, FALSE, "mshtmdbg.ini");

    ptag->pchTag = pch;
    lstrcpyA(pch, szTag);
    pch += cbTag;
    
    ptag->pchOwner = pch;
    lstrcpyA(pch, szOwner);
    pch += cbOwner;

    ptag->pchDesc = pch;
    lstrcpyA(pch, szDesc);

    g_ptagHead = ptag;

    LeaveCriticalSection(&g_csLog);

    if (ghWnd)
    {
        PostMessageA(ghWnd, WM_COMMAND, IDC_REFRESH, 0);
    }

    return((PERFTAG)ptag);
}

void WINAPI
DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list va)
{
    LOGENTRY    le;
    UINT        cb;

    if (!tag || !((LTAG *)tag)->fEnabled || !g_fEnabled)
        return;

    le.pleNext = NULL;
    le.pvObject = pvObj;
    le.dwThread = GetCurrentThreadId();

    cb = wvsprintfA(le.ach, pchFmt, va);
 
    cb = (cb + offsetof(LOGENTRY, ach) + 1);
    cb = (cb + 7) & ~7;

    EnterCriticalSection(&g_csLog);

    QueryPerformanceCounter((LARGE_INTEGER *)&le.t);

    if (cb > g_cbLeft)
    {
        LOGBLOCK * plb = (LOGBLOCK *)MemAlloc(sizeof(LOGBLOCK));

        if (plb == NULL)
            goto ret;

        plb->plbNext = NULL;

        if (g_plbTail)
        {
            g_plbTail->plbNext = plb;
            g_plbTail = plb;
        }
        else
        {
            g_plbHead = g_plbTail = plb;
        }

        g_pleNext = (LOGENTRY *)plb->ach;
        g_cbLeft  = sizeof(plb->ach);
        g_nRuntimeAllocations++;
    }

    if (g_plePrev)
        g_plePrev->pleNext = g_pleNext;

    g_plePrev = g_pleNext;
    g_pleNext = (LOGENTRY *)((BYTE *)g_plePrev + cb);
    g_cbLeft -= cb;
    memcpy(g_plePrev, &le, cb);

ret:
    LeaveCriticalSection(&g_csLog);
}

void __cdecl
DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...)
{
    va_list va;
    va_start(va, pchFmt);
    DbgExPerfLogFnList(tag, pvObj, pchFmt, va);
    va_end(va);
}

int __cdecl PerfLogCompareTime(const void * pv1, const void * pv2)
{
    __int64 t1 = (*(LOGENTRY **)pv1)->t;
    __int64 t2 = (*(LOGENTRY **)pv2)->t;
    return((t1 < t2) ? -1 : (t1 > t2) ? 1 : 0);
}

int __cdecl PerfLogCompareThread(const void * pv1, const void * pv2)
{
    DWORD dw1 = (*(LOGENTRY **)pv1)->dwThread;
    DWORD dw2 = (*(LOGENTRY **)pv2)->dwThread;
    return((dw1 < dw2) ? -1 : (dw1 > dw2) ? 1 : PerfLogCompareTime(pv1, pv2));
}

int __cdecl PerfLogCompareObject(const void * pv1, const void * pv2)
{
    DWORD_PTR dw1 = (DWORD_PTR)(*(LOGENTRY **)pv1)->pvObject;
    DWORD_PTR dw2 = (DWORD_PTR)(*(LOGENTRY **)pv2)->pvObject;
    return((dw1 < dw2) ? -1 : (dw1 > dw2) ? 1 : PerfLogCompareTime(pv1, pv2));
}

static void PerfLogDumpRange(HANDLE hfile, LOGENTRY ** pple, UINT cle)
{
    __int64 tmin = (*pple)->t, tfrq, tnext;
    LOGENTRY * ple;
    int cLevel = 0;
    int cbLog = 0, cbDelta;
    
    QueryPerformanceFrequency((LARGE_INTEGER *)&tfrq);

    hprintf(hfile, " TID         Time       Len      Object\r\n");

    for (; cle > 0; --cle, ++pple)
    {
        ple = *pple;
        tnext = (cle > 1) ? (*(pple + 1))->t : ple->t;

        hprintf(hfile, "%8lX %7ld.%02ld (%6ld.%02ld) %8lX ",
            ple->dwThread,
            (LONG)((ple->t - tmin) * 1000 / tfrq),
            (LONG)((ple->t - tmin) * 100000 / tfrq) % 100,
            (LONG)((tnext - ple->t) * 1000 / tfrq),
            (LONG)((tnext - ple->t) * 100000 / tfrq) % 100,
            ple->pvObject);

        if (ple->ach[0] == '-' && cLevel > 0)
            cLevel -= 1;

        for (int i = 0; i < cLevel; ++i)
            hprintf(hfile, "  ");

        hprintf(hfile, "%s\r\n", ple->ach);

        if (ple->ach[0] == '+')
            cLevel += 1;

        cbDelta = offsetof(LOGENTRY, ach) + lstrlenA(ple->ach) + 1; 
        cbDelta = (cbDelta + 7) & ~7;
        cbLog += cbDelta;
    }

    hprintf(hfile, "Log took %d bytes in %d runtime allocations\r\n\r\n", cbLog, g_nRuntimeAllocations);
}

char * GetPerfLogPath(char * pch)
{
    return lstrcpyA( pch, g_achDumpFile );
}

void WINAPI
DbgExPerfDump()
{
    EnterCriticalSection(&g_csLog);

    LOGENTRY *  pleHead = g_plbHead ? (LOGENTRY *)g_plbHead->ach : NULL;
    LOGENTRY *  ple, **pple;
    int         cle = 0;
    LOGENTRY ** rgple;
    char        achLog[MAX_PATH];
    HANDLE      hfile = CreateFileA(GetPerfLogPath(achLog), GENERIC_WRITE,
        FILE_SHARE_READ, NULL, g_fOverwriteDump ? CREATE_ALWAYS : OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        goto ret;

    SetFilePointer(hfile, 0, NULL, FILE_END);

    for (ple = pleHead; ple; ple = ple->pleNext)
    {
        cle += 1;
    }

    if (cle == 0)
    {
        CloseHandle(hfile);
        goto ret;
    }

    rgple = (LOGENTRY **)MemAlloc(cle * sizeof(LOGENTRY *));
    if (!rgple)
    {
        CloseHandle(hfile);
        goto ret;
    }

    for (ple = pleHead, pple = rgple; ple; ple = ple->pleNext, ++pple)
    {
        *pple = ple;
    }

    if (g_fSimpleDump)
    {
        hprintf(hfile, "+++ All Entries (as captured)\r\n\r\n");
        PerfLogDumpRange(hfile, rgple, cle);
    }
    else
    {
        int i;

        qsort(rgple, cle, sizeof(LOGENTRY *), PerfLogCompareTime);

        hprintf(hfile, "+++ All Entries\r\n\r\n");

        PerfLogDumpRange(hfile, rgple, cle);

        qsort(rgple, cle, sizeof(LOGENTRY *), PerfLogCompareThread);

        for (i = 0, pple = rgple; i < cle; ++i, ++pple)
        {
            LOGENTRY ** ppleBeg = pple;
            ple = *pple;

            for (++pple, ++i; i < cle; ++i, ++pple)
            {
                if ((*pple)->dwThread != ple->dwThread)
                    break;
            }

            if (pple - ppleBeg != cle)
            {
                hprintf(hfile, "+++ Entries On Thread %lX\r\n\r\n", ple->dwThread);

                PerfLogDumpRange(hfile, ppleBeg, pple - ppleBeg);
            }

            i -= 1;
            pple -= 1;
        }

        qsort(rgple, cle, sizeof(LOGENTRY *), PerfLogCompareObject);

        for (i = 0, pple = rgple; i < cle; ++i, ++pple)
        {
            LOGENTRY ** ppleBeg = pple;
            ple = *pple;

            for (++pple, ++i; i < cle; ++i, ++pple)
            {
                if ((*pple)->pvObject != ple->pvObject)
                    break;
            }

            if (pple - ppleBeg != cle)
            {
                hprintf(hfile, "+++ Entries On Object %lX\r\n\r\n", ple->pvObject);
                PerfLogDumpRange(hfile, ppleBeg, pple - ppleBeg);
            }

            i -= 1;
            pple -= 1;
        }
    }

    hprintf(hfile, "------------------------------------------------------------------------------\r\n\r\n");

    CloseHandle(hfile);

    MemFree(rgple);

    DbgExPerfClear();

ret:
    LeaveCriticalSection(&g_csLog);
}

void WINAPI
DbgExPerfClear()
{
    LOGBLOCK * plb, * plbNext;

    EnterCriticalSection(&g_csLog);

    for (plb = g_plbHead, plbNext = NULL; plb; plb = plbNext)
    {
        plbNext = plb->plbNext;
        MemFree(plb);
    }

    g_plbHead = NULL;
    g_plbTail = NULL;
    g_plePrev = NULL;
    g_pleNext = NULL;
    g_cbLeft  = 0;

    LeaveCriticalSection(&g_csLog);
}

//+---------------------------------------------------------------------------
//  Perf Monitor
//----------------------------------------------------------------------------

DWORD WINAPI
PerfMonitorThread(LPVOID lpv);

INT_PTR WINAPI
PerfMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void    SetWindowTitle(HWND hWnd, LPSTR lpcText);
void    RefreshView(HWND hWnd);
void    SetSumSelection(void);
void    TagListNotify(WORD wNotify, HWND  hWnd);

void    MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
int     CompareItem(LPCOMPAREITEMSTRUCT pcis);
void    DrawItem(LPDRAWITEMSTRUCT pdis);
void    OutTextFormat(LPDRAWITEMSTRUCT pdis);
static void SetRGBValues(void);

//  Global Data

void WINAPI
DbgExPerfTags()
{
    EnterCriticalSection(&g_csLog);

    if (!ghThread)
    {
        DWORD dwThreadId;

        fDlgUp = TRUE;

        ghThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL, 0,
            (LPTHREAD_START_ROUTINE)PerfMonitorThread,
            NULL, 0, &dwThreadId);
    }

    LeaveCriticalSection(&g_csLog);
}

DWORD WINAPI PerfMonitorThread(LPVOID)
{
    ghbrBkgnd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));

    DialogBoxA(g_hinstMain, MAKEINTRESOURCEA(IDD_PERFTAGS), NULL, PerfMonDlgProc);

    DeleteObject(ghbrBkgnd);
	ghThread = NULL;
    
    return 0;
}

void RefreshView(HWND hWnd)
{
    SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_RESETCONTENT, 0, 0L);

    for (LTAG * ptag = g_ptagHead; ptag; ptag = ptag->ptagNext)
    {
        SendDlgItemMessageA(hWnd, IDC_TAGLIST, LB_ADDSTRING, 0, (LPARAM)ptag);
    }

    SetWindowTitle(GetDlgItem(hWnd, IDC_STARTSTOP), g_fEnabled ? "Start" : "Stop");
}

void TagListNotify(WORD wNotify, HWND hWnd)
{
    LONG    idx;
    LTAG *   ptag;
    RECT    rc;
    
    if (wNotify == LBN_DBLCLK)
    {
        idx = SendMessageA(hWnd, LB_GETCURSEL, 0, 0L);
        if (idx == CB_ERR)
            return;

        ptag = (LTAG *)SendMessageA(hWnd, LB_GETITEMDATA, (WPARAM)idx, 0L);
        if (ptag == (LTAG *)CB_ERR)
            return;
        
        ptag->fEnabled = !ptag->fEnabled;

        WritePrivateProfileStringA("perftags", ptag->pchTag,
            ptag->fEnabled ? "1" : "0", "mshtmdbg.ini");

        if (SendMessageA(hWnd, LB_GETITEMRECT, (WPARAM)idx, (LPARAM)&rc) != LB_ERR)
        {
            RedrawWindow(hWnd, &rc, NULL, RDW_INVALIDATE);
        }
    }
}

INT_PTR WINAPI
PerfMonDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char    achLog[MAX_PATH];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            ghWnd = hWnd;
            SetRGBValues();
            SetWindowTitle(hWnd, "PerfTags - %s");
            RefreshView(hWnd);
            ShowWindow(hWnd, SW_SHOWMINNOACTIVE);
            break;

        case WM_SYSCOLORCHANGE:
            SetRGBValues();
            RefreshView(hWnd);
            break;
            
        case WM_MEASUREITEM:
            MeasureItem(hWnd, (LPMEASUREITEMSTRUCT)lParam);
            break;
            
        case WM_DRAWITEM:
            DrawItem((LPDRAWITEMSTRUCT)lParam);
            break;
            
        case WM_COMPAREITEM:
            return CompareItem((COMPAREITEMSTRUCT *)lParam);
            
        case WM_PAINT:
            return FALSE;

        case WM_ERASEBKGND:
            return IsIconic(hWnd);

        case WM_QUERYENDSESSION:
            PostMessageA(hWnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            fDlgUp = FALSE;
            return EndDialog(hWnd, 0);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {                       
                case IDC_TAGLIST:
                    TagListNotify(HIWORD(wParam), (HWND)lParam);
                    break;

                case IDC_ENABLEALL:
                case IDC_DISABLEALL:
                {
                    for (LTAG * ptag = g_ptagHead; ptag; ptag = ptag->ptagNext)
                    {
                        if (ptag->fEnabled != !!(LOWORD(wParam) == IDC_ENABLEALL))
                        {
                            ptag->fEnabled = !ptag->fEnabled;
                            WritePrivateProfileStringA("perftags", ptag->pchTag,
                                ptag->fEnabled ? "1" : "0", "mshtmdbg.ini");
                        }
                    }

                    RefreshView(ghWnd);
                    break;
                }

                case IDC_CLEARLOG:
                    DbgExPerfClear();
                    break;

                case IDC_DUMPLOG:
                    DbgExPerfDump();
                    break;

                case IDC_DELETELOG:
                    DeleteFileA(GetPerfLogPath(achLog));
                    break;

                case IDC_REFRESH:
                    RefreshView(ghWnd);
                    break;

                case IDC_STARTSTOP:
                    DbgExPerfEnable( !g_fEnabled );
                    break;

                default:
                    return FALSE;
            }
            break;
        default:
            return FALSE;
    }
    
    return TRUE;
}

int CompareItem(LPCOMPAREITEMSTRUCT pcis)
{
    LTAG * ptag1 = (LTAG *)pcis->itemData1;
    LTAG * ptag2 = (LTAG *)pcis->itemData2;
    int iCmp;
    
    iCmp = lstrcmpA(ptag1->pchOwner, ptag2->pchOwner);

    if (iCmp == 0)
        iCmp = lstrcmpA(ptag1->pchDesc, ptag2->pchDesc);

    if (iCmp < 0)
        iCmp = -1;
    else if (iCmp > 0)
        iCmp = 1;

    return(iCmp);
}

void DrawItem(LPDRAWITEMSTRUCT pdis)
{
    char ach[1024];
    COLORREF crText = 0, crBack = 0;
    LTAG * ptag = (LTAG *)pdis->itemData;

    if((int)pdis->itemID < 0)
        return;

    if((ODA_DRAWENTIRE | ODA_SELECT) & pdis->itemAction)
    {
        if(pdis->itemState & ODS_SELECTED)
        {
            crText = SetTextColor(pdis->hDC, rgbHiliteText);
            crBack = SetBkColor(pdis->hDC, rgbHiliteColor);
        }

        wsprintfA(ach, " %s %-14s %s", ptag->fEnabled ? "[X]" : "[ ]",
            ptag->pchOwner, ptag->pchDesc);

        ExtTextOutA(pdis->hDC, pdis->rcItem.left, pdis->rcItem.top + 1,
            ETO_OPAQUE | ETO_CLIPPED, &pdis->rcItem, ach, lstrlenA(ach), NULL);

        // Restore original colors if we changed them above.
        if(pdis->itemState & ODS_SELECTED)
        {
            SetTextColor(pdis->hDC, crText);
            SetBkColor(pdis->hDC,   crBack);
        }
    }

    if((ODA_FOCUS & pdis->itemAction) || (ODS_FOCUS & pdis->itemState))
        DrawFocusRect(pdis->hDC, &pdis->rcItem);
}

static void SetRGBValues(VOID)
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}

void
PerfProcessAttach()
{
    InitializeCriticalSection(&g_csLog);
    g_fAutoDump   = GetPrivateProfileIntA("perftags", "AutoDump", FALSE, "mshtmdbg.ini");
    g_fAutoOpen   = GetPrivateProfileIntA("perftags", "AutoOpen", FALSE, "mshtmdbg.ini");
    g_fAutoDelete = GetPrivateProfileIntA("perftags", "AutoDelete", TRUE, "mshtmdbg.ini");
    g_fSimpleDump = GetPrivateProfileIntA("perftags", "SimpleDump", TRUE, "mshtmdbg.ini");
    g_fOverwriteDump = GetPrivateProfileIntA("perftags", "OverwriteDump", FALSE, "mshtmdbg.ini");
    GetPrivateProfileStringA("perftags", "DumpFile", "", g_achDumpFile, MAX_PATH, "mshtmdbg.ini");

    if (g_achDumpFile[0] == '\0')
    {
        char    szModule[MAX_PATH];
        char *  pszModule;

        GetModuleFileNameA(NULL, szModule, MAX_PATH);
    
        pszModule = (LPSTR)(szModule + lstrlenA(szModule));
    
        while (*pszModule-- != '\\') ;

        pszModule += 2;
    
        CharUpperBuffA(pszModule, lstrlenA(pszModule));
    
        wsprintfA(g_achDumpFile, "\\%s-%lX.log", pszModule, GetCurrentProcessId());
    }

    {
        int cbPreAllocLog = GetPrivateProfileIntA("perftags", "PreAllocLog", 0, "mshtmdbg.ini");
        if (cbPreAllocLog)
        {
            LOGBLOCK * plb = (LOGBLOCK *)MemAlloc(offsetof(LOGBLOCK, ach) + cbPreAllocLog);

            if (plb)
            {
                plb->plbNext = NULL;

                g_plbHead = g_plbTail = plb;

                g_pleNext = (LOGENTRY *)plb->ach;
                g_cbLeft  = cbPreAllocLog;
            }
        }
    }

    if (g_fAutoDump)
        g_fEnabled = TRUE;
    if (g_fAutoOpen)
        DbgExPerfTags();
}

void
PerfProcessDetach()
{
    if (g_fAutoDump)
    {
        if (g_fAutoDelete)
        {
            char achLog[MAX_PATH];
            DeleteFileA(GetPerfLogPath(achLog));
        }

        DbgExPerfDump();
    }
    if (ghWnd)
        SendMessageA(ghWnd, WM_CLOSE, 0, 0);
    DWORD dwTickEnd = GetTickCount() + 5000;
    while (ghThread && GetTickCount() < dwTickEnd)
		Sleep(50);

    DbgExPerfClear();
    
    for (LTAG * ptag = g_ptagHead; ptag; ptag = g_ptagHead)
    {
        g_ptagHead = ptag->ptagNext;
        MemFree(ptag);
    }

    DeleteCriticalSection(&g_csLog);
}

char * WINAPI
DbgExDecodeMessage(UINT msg)
{
    static char szBuf[12];

    *szBuf = '\0';
    
    switch (msg)
    {
        case WM_NULL:               return(" WM_NULL");
        case WM_CREATE:             return(" WM_CREATE");
        case WM_DESTROY:            return(" WM_DESTROY");
        case WM_MOVE:               return(" WM_MOVE");
        case WM_SIZE:               return(" WM_SIZE");
        case WM_ACTIVATE:           return(" WM_ACTIVATE");
        case WM_SETFOCUS:           return(" WM_SETFOCUS");
        case WM_KILLFOCUS:          return(" WM_KILLFOCUS");
        case WM_ENABLE:             return(" WM_ENABLE");
        case WM_SETREDRAW:          return(" WM_SETREDRAW");
        case WM_SETTEXT:            return(" WM_SETTEXT");
        case WM_GETTEXT:            return(" WM_GETTEXT");
        case WM_GETTEXTLENGTH:      return(" WM_GETTEXTLENGTH");
        case WM_PAINT:              return(" WM_PAINT");
        case WM_CLOSE:              return(" WM_CLOSE");
        case WM_QUERYENDSESSION:    return(" WM_QUERYENDSESSION");
        case WM_QUERYOPEN:          return(" WM_QUERYOPEN");
        case WM_ENDSESSION:         return(" WM_ENDSESSION");
        case WM_QUIT:               return(" WM_QUIT");
        case WM_ERASEBKGND:         return(" WM_ERASEBKGND");
        case WM_SYSCOLORCHANGE:     return(" WM_SYSCOLORCHANGE");
        case WM_SHOWWINDOW:         return(" WM_SHOWWINDOW");
        case WM_WININICHANGE:       return(" WM_WININICHANGE");
        case WM_DEVMODECHANGE:      return(" WM_DEVMODECHANGE");
        case WM_ACTIVATEAPP:        return(" WM_ACTIVATEAPP");
        case WM_FONTCHANGE:         return(" WM_FONTCHANGE");
        case WM_TIMECHANGE:         return(" WM_TIMECHANGE");
        case WM_CANCELMODE:         return(" WM_CANCELMODE");
        case WM_SETCURSOR:          return(" WM_SETCURSOR");
        case WM_MOUSEACTIVATE:      return(" WM_MOUSEACTIVATE");
        case WM_CHILDACTIVATE:      return(" WM_CHILDACTIVATE");
        case WM_QUEUESYNC:          return(" WM_QUEUESYNC");
        case WM_GETMINMAXINFO:      return(" WM_GETMINMAXINFO");
        case WM_PAINTICON:          return(" WM_PAINTICON");
        case WM_ICONERASEBKGND:     return(" WM_ICONERASEBKGND");
        case WM_NEXTDLGCTL:         return(" WM_NEXTDLGCTL");
        case WM_SPOOLERSTATUS:      return(" WM_SPOOLERSTATUS");
        case WM_DRAWITEM:           return(" WM_DRAWITEM");
        case WM_MEASUREITEM:        return(" WM_MEASUREITEM");
        case WM_DELETEITEM:         return(" WM_DELETEITEM");
        case WM_VKEYTOITEM:         return(" WM_VKEYTOITEM");
        case WM_CHARTOITEM:         return(" WM_CHARTOITEM");
        case WM_SETFONT:            return(" WM_SETFONT");
        case WM_GETFONT:            return(" WM_GETFONT");
        case WM_SETHOTKEY:          return(" WM_SETHOTKEY");
        case WM_GETHOTKEY:          return(" WM_GETHOTKEY");
        case WM_QUERYDRAGICON:      return(" WM_QUERYDRAGICON");
        case WM_COMPAREITEM:        return(" WM_COMPAREITEM");
        case WM_COMPACTING:         return(" WM_COMPACTING");
        case WM_COMMNOTIFY:         return(" WM_COMMNOTIFY");
        case WM_WINDOWPOSCHANGING:  return(" WM_WINDOWPOSCHANGING");
        case WM_WINDOWPOSCHANGED:   return(" WM_WINDOWPOSCHANGED");
        case WM_POWER:              return(" WM_POWER");
        case WM_COPYDATA:           return(" WM_COPYDATA");
        case WM_CANCELJOURNAL:      return(" WM_CANCELJOURNAL");
        case WM_NOTIFY:             return(" WM_NOTIFY");
        case WM_INPUTLANGCHANGEREQUEST: return(" WM_INPUTLANGCHANGEREQUEST");
        case WM_INPUTLANGCHANGE:    return(" WM_INPUTLANGCHANGE");
        case WM_TCARD:              return(" WM_TCARD");
        case WM_HELP:               return(" WM_HELP");
        case WM_USERCHANGED:        return(" WM_USERCHANGED");
        case WM_NOTIFYFORMAT:       return(" WM_NOTIFYFORMAT");
        case WM_CONTEXTMENU:        return(" WM_CONTEXTMENU");
        case WM_STYLECHANGING:      return(" WM_STYLECHANGING");
        case WM_STYLECHANGED:       return(" WM_STYLECHANGED");
        case WM_DISPLAYCHANGE:      return(" WM_DISPLAYCHANGE");
        case WM_GETICON:            return(" WM_GETICON");
        case WM_SETICON:            return(" WM_SETICON");
        case WM_NCCREATE:           return(" WM_NCCREATE");
        case WM_NCDESTROY:          return(" WM_NCDESTROY");
        case WM_NCCALCSIZE:         return(" WM_NCCALCSIZE");
        case WM_NCHITTEST:          return(" WM_NCHITTEST");
        case WM_NCPAINT:            return(" WM_NCPAINT");
        case WM_NCACTIVATE:         return(" WM_NCACTIVATE");
        case WM_GETDLGCODE:         return(" WM_GETDLGCODE");
        case WM_SYNCPAINT:          return(" WM_SYNCPAINT");
        case WM_NCMOUSEMOVE:        return(" WM_NCMOUSEMOVE");
        case WM_NCLBUTTONDOWN:      return(" WM_NCLBUTTONDOWN");
        case WM_NCLBUTTONUP:        return(" WM_NCLBUTTONUP");
        case WM_NCLBUTTONDBLCLK:    return(" WM_NCLBUTTONDBLCLK");
        case WM_NCRBUTTONDOWN:      return(" WM_NCRBUTTONDOWN");
        case WM_NCRBUTTONUP:        return(" WM_NCRBUTTONUP");
        case WM_NCRBUTTONDBLCLK:    return(" WM_NCRBUTTONDBLCLK");
        case WM_NCMBUTTONDOWN:      return(" WM_NCMBUTTONDOWN");
        case WM_NCMBUTTONUP:        return(" WM_NCMBUTTONUP");
        case WM_NCMBUTTONDBLCLK:    return(" WM_NCMBUTTONDBLCLK");
        case WM_KEYDOWN:            return(" WM_KEYDOWN");
        case WM_KEYUP:              return(" WM_KEYUP");
        case WM_CHAR:               return(" WM_CHAR");
        case WM_DEADCHAR:           return(" WM_DEADCHAR");
        case WM_SYSKEYDOWN:         return(" WM_SYSKEYDOWN");
        case WM_SYSKEYUP:           return(" WM_SYSKEYUP");
        case WM_SYSCHAR:            return(" WM_SYSCHAR");
        case WM_SYSDEADCHAR:        return(" WM_SYSDEADCHAR");
        case WM_IME_STARTCOMPOSITION:   return(" WM_IME_STARTCOMPOSITION");
        case WM_IME_ENDCOMPOSITION: return(" WM_IME_ENDCOMPOSITION");
        case WM_IME_COMPOSITION:    return(" WM_IME_COMPOSITION");
        case WM_INITDIALOG:         return(" WM_INITDIALOG");
        case WM_COMMAND:            return(" WM_COMMAND");
        case WM_SYSCOMMAND:         return(" WM_SYSCOMMAND");
        case WM_TIMER:              return(" WM_TIMER");
        case WM_HSCROLL:            return(" WM_HSCROLL");
        case WM_VSCROLL:            return(" WM_VSCROLL");
        case WM_INITMENU:           return(" WM_INITMENU");
        case WM_INITMENUPOPUP:      return(" WM_INITMENUPOPUP");
        case WM_MENUSELECT:         return(" WM_MENUSELECT");
        case WM_MENUCHAR:           return(" WM_MENUCHAR");
        case WM_ENTERIDLE:          return(" WM_ENTERIDLE");
        case WM_CTLCOLORMSGBOX:     return(" WM_CTLCOLORMSGBOX");
        case WM_CTLCOLOREDIT:       return(" WM_CTLCOLOREDIT");
        case WM_CTLCOLORLISTBOX:    return(" WM_CTLCOLORLISTBOX");
        case WM_CTLCOLORBTN:        return(" WM_CTLCOLORBTN");
        case WM_CTLCOLORDLG:        return(" WM_CTLCOLORDLG");
        case WM_CTLCOLORSCROLLBAR:  return(" WM_CTLCOLORSCROLLBAR");
        case WM_CTLCOLORSTATIC:     return(" WM_CTLCOLORSTATIC");
        case WM_MOUSEMOVE:          return(" WM_MOUSEMOVE");
        case WM_LBUTTONDOWN:        return(" WM_LBUTTONDOWN");
        case WM_LBUTTONUP:          return(" WM_LBUTTONUP");
        case WM_LBUTTONDBLCLK:      return(" WM_LBUTTONDBLCLK");
        case WM_RBUTTONDOWN:        return(" WM_RBUTTONDOWN");
        case WM_RBUTTONUP:          return(" WM_RBUTTONUP");
        case WM_RBUTTONDBLCLK:      return(" WM_RBUTTONDBLCLK");
        case WM_MBUTTONDOWN:        return(" WM_MBUTTONDOWN");
        case WM_MBUTTONUP:          return(" WM_MBUTTONUP");
        case WM_MBUTTONDBLCLK:      return(" WM_MBUTTONDBLCLK");
        case WM_MOUSEWHEEL:         return(" WM_MOUSEWHEEL");
        case WM_PARENTNOTIFY:       return(" WM_PARENTNOTIFY");
        case WM_ENTERMENULOOP:      return(" WM_ENTERMENULOOP");
        case WM_EXITMENULOOP:       return(" WM_EXITMENULOOP");
        case WM_NEXTMENU:           return(" WM_NEXTMENU");
        case WM_SIZING:             return(" WM_SIZING");
        case WM_CAPTURECHANGED:     return(" WM_CAPTURECHANGED");
        case WM_MOVING:             return(" WM_MOVING");
        case WM_POWERBROADCAST:     return(" WM_POWERBROADCAST");
        case WM_DEVICECHANGE:       return(" WM_DEVICECHANGE");
        case WM_MDICREATE:          return(" WM_MDICREATE");
        case WM_MDIDESTROY:         return(" WM_MDIDESTROY");
        case WM_MDIACTIVATE:        return(" WM_MDIACTIVATE");
        case WM_MDIRESTORE:         return(" WM_MDIRESTORE");
        case WM_MDINEXT:            return(" WM_MDINEXT");
        case WM_MDIMAXIMIZE:        return(" WM_MDIMAXIMIZE");
        case WM_MDITILE:            return(" WM_MDITILE");
        case WM_MDICASCADE:         return(" WM_MDICASCADE");
        case WM_MDIICONARRANGE:     return(" WM_MDIICONARRANGE");
        case WM_MDIGETACTIVE:       return(" WM_MDIGETACTIVE");
        case WM_MDISETMENU:         return(" WM_MDISETMENU");
        case WM_ENTERSIZEMOVE:      return(" WM_ENTERSIZEMOVE");
        case WM_EXITSIZEMOVE:       return(" WM_EXITSIZEMOVE");
        case WM_DROPFILES:          return(" WM_DROPFILES");
        case WM_MDIREFRESHMENU:     return(" WM_MDIREFRESHMENU");
        case WM_IME_SETCONTEXT:     return(" WM_IME_SETCONTEXT");
        case WM_IME_NOTIFY:         return(" WM_IME_NOTIFY");
        case WM_IME_CONTROL:        return(" WM_IME_CONTROL");
        case WM_IME_COMPOSITIONFULL:    return(" WM_IME_COMPOSITIONFULL");
        case WM_IME_SELECT:         return(" WM_IME_SELECT");
        case WM_IME_CHAR:           return(" WM_IME_CHAR");
        case WM_IME_KEYDOWN:        return(" WM_IME_KEYDOWN");
        case WM_IME_KEYUP:          return(" WM_IME_KEYUP");
        case WM_MOUSEHOVER:         return(" WM_MOUSEHOVER");
        case WM_MOUSELEAVE:         return(" WM_MOUSELEAVE");
        case WM_CUT:                return(" WM_CUT");
        case WM_COPY:               return(" WM_COPY");
        case WM_PASTE:              return(" WM_PASTE");
        case WM_CLEAR:              return(" WM_CLEAR");
        case WM_UNDO:               return(" WM_UNDO");
        case WM_RENDERFORMAT:       return(" WM_RENDERFORMAT");
        case WM_RENDERALLFORMATS:   return(" WM_RENDERALLFORMATS");
        case WM_DESTROYCLIPBOARD:   return(" WM_DESTROYCLIPBOARD");
        case WM_DRAWCLIPBOARD:      return(" WM_DRAWCLIPBOARD");
        case WM_PAINTCLIPBOARD:     return(" WM_PAINTCLIPBOARD");
        case WM_VSCROLLCLIPBOARD:   return(" WM_VSCROLLCLIPBOARD");
        case WM_SIZECLIPBOARD:      return(" WM_SIZECLIPBOARD");
        case WM_ASKCBFORMATNAME:    return(" WM_ASKCBFORMATNAME");
        case WM_CHANGECBCHAIN:      return(" WM_CHANGECBCHAIN");
        case WM_HSCROLLCLIPBOARD:   return(" WM_HSCROLLCLIPBOARD");
        case WM_QUERYNEWPALETTE:    return(" WM_QUERYNEWPALETTE");
        case WM_PALETTEISCHANGING:  return(" WM_PALETTEISCHANGING");
        case WM_PALETTECHANGED:     return(" WM_PALETTECHANGED");
        case WM_HOTKEY:             return(" WM_HOTKEY");
        case WM_PRINT:              return(" WM_PRINT");
        case WM_PRINTCLIENT:        return(" WM_PRINTCLIENT");
        case WM_USER:               return(" WM_USER");
        case WM_USER+1:             return(" WM_USER+1");
        case WM_USER+2:             return(" WM_USER+2");
        case WM_USER+3:             return(" WM_USER+3");
        case WM_USER+4:             return(" WM_USER+4");
        default:
            wsprintfA(szBuf, "0x%x", msg);
            break;
    }

    return(szBuf);
}

void 
DbgExPerfEnable( BOOL fEnable )
{
    EnterCriticalSection(&g_csLog);

    g_fEnabled = !g_fEnabled;
    if (ghWnd)
    {
        PostMessageA(ghWnd, WM_COMMAND, IDC_REFRESH, 0);
    }

    LeaveCriticalSection(&g_csLog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\viewer.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       view.cxx
//
//  Contents:   IViewObject viewer.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

typedef HRESULT (WINAPI * PFNOLEDRAW)(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds);
typedef void (WINAPI * PFNRELEASESTGMEDIUM)(LPSTGMEDIUM pstgmed);
PFNOLEDRAW g_pfnOleDraw = NULL;
PFNRELEASESTGMEDIUM g_pfnReleaseStgMedium = NULL;

PFNOLEDRAW
GetPfnOleDraw()
{
    if (g_pfnOleDraw == NULL)
    {
        g_pfnOleDraw = (PFNOLEDRAW)GetProcAddress(GetModuleHandleA("ole32.dll"), "OleDraw");
        Assert(g_pfnReleaseStgMedium);
    }
    return(g_pfnOleDraw);
}

PFNRELEASESTGMEDIUM
GetPfnReleaseStgMedium()
{
    if (g_pfnReleaseStgMedium == NULL)
    {
        g_pfnReleaseStgMedium = (PFNRELEASESTGMEDIUM)GetProcAddress(GetModuleHandleA("ole32.dll"), "ReleaseStgMedium");
        Assert(g_pfnReleaseStgMedium);
    }
    return(g_pfnReleaseStgMedium);
}

#define IDM_REFRESH 20

enum
{
    TYPE_VIEW,
    TYPE_METAFILE,
    TYPE_ENHMETAFILE
};

static struct
{
    int         type;
    DWORD       dwAspect;
    int         mm;
} s_aModeInfo[] = {
    // Elements in this array correspond to the menu items in f3debug.rc
    { 0 },
    { TYPE_VIEW,        DVASPECT_CONTENT, MM_TEXT },
    { TYPE_VIEW,        DVASPECT_CONTENT, MM_ANISOTROPIC },
    { TYPE_VIEW,        DVASPECT_ICON,    MM_TEXT },
    { TYPE_VIEW,        DVASPECT_ICON,    MM_ANISOTROPIC },
    { TYPE_METAFILE,    DVASPECT_CONTENT, 0 },
    { TYPE_METAFILE,    DVASPECT_ICON,    0 },
    { TYPE_ENHMETAFILE, DVASPECT_CONTENT, 0 },
    { TYPE_ENHMETAFILE, DVASPECT_ICON,    0 },
};

static BOOL s_fWndClassRegistered = FALSE;
static SIZE s_sizePixelsPerInch;
static FORMATETC s_FormatEtcMetaFile =
    { (CLIPFORMAT) CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT };

class CViewer : public IAdviseSink2
{
public:

    CViewer();
    ~CViewer();

    // IUnknown methods

    STDMETHOD(QueryInterface) (REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IAdviseSink methods

    void STDMETHODCALLTYPE OnDataChange(
            FORMATETC FAR* pFormatetc,
            STGMEDIUM FAR* pStgmed);
    void STDMETHODCALLTYPE OnViewChange(
            DWORD dwAspect, LONG lindex);
    void STDMETHODCALLTYPE OnRename(LPMONIKER pmk);
    void STDMETHODCALLTYPE OnSave();
    void STDMETHODCALLTYPE OnClose();
    void STDMETHODCALLTYPE OnLinkSrcChange(IMoniker * pmk);

    // New methods

    void OnButtonDown(POINTS pts);
    void OnPaint();
    void OnCommand(int idm);
    void DrawMetaFile(HDC hdc, RECT *prc, DWORD dwApsect);
    void DrawEnhMetaFile(HDC hdc, RECT *prc, DWORD dwAspect);
    void DrawView(HDC hdc, RECT *prc, DWORD dwAspect, int mm);

    ULONG           _ulRef;
    HWND            _hwnd;
    IDataObject *   _pDO;
    IViewObject *   _pVO;
    int             _cDataChange;
    int             _idmMode;
    DWORD           _dwCookie;
};

CViewer::CViewer()
{
    _ulRef = 0;
    _hwnd  = NULL;
    _pDO  = NULL;
    _cDataChange = 0;
    _idmMode = 1;
    _dwCookie = 0;
}

CViewer::~CViewer()
{
    _ulRef = 256;

    if (_pDO)
    {
        if (_dwCookie)
        {
            _pDO->DUnadvise(_dwCookie);
            _dwCookie = 0;
        }
        _pDO->Release();
        _pDO = NULL;
    }

    if (_pVO)
    {
        _pVO->SetAdvise(DVASPECT_CONTENT, 0, NULL);
        _pVO->Release();
        _pVO = 0;
    }

    if (_hwnd)
    {
        SetWindowLongPtr(_hwnd, GWLP_USERDATA, 0);
        Verify(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
}

STDMETHODIMP
CViewer::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown ||
            iid == IID_IAdviseSink2 ||
            iid == IID_IAdviseSink)
    {
        *ppv = (IAdviseSink2 *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CViewer::AddRef()
{
    return _ulRef += 1;
}

STDMETHODIMP_(ULONG)
CViewer::Release()
{
    _ulRef -= 1;
    if (_ulRef == 0)
    {
        delete this;
        return 0;
    }
    return _ulRef;
}

STDMETHODIMP_(void)
CViewer::OnDataChange(FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
    _cDataChange += 1;
    InvalidateRect(_hwnd, 0, FALSE);
}

STDMETHODIMP_(void)
CViewer::OnViewChange(DWORD dwAspects, LONG lindex)
{
    InvalidateRect(_hwnd, 0, FALSE);
}

STDMETHODIMP_(void)
CViewer::OnRename(LPMONIKER pmk)
{
}

STDMETHODIMP_(void)
CViewer::OnSave()
{
}

STDMETHODIMP_(void)
CViewer::OnClose()
{
}

STDMETHODIMP_(void)
CViewer::OnLinkSrcChange(IMoniker * pmk)
{
}

void
CViewer::OnCommand(int idm)
{
    switch (idm)
    {
    case IDM_REFRESH:
        InvalidateRect(_hwnd, NULL, TRUE);
        break;

    default:

        if (idm >= 1 && idm < ARRAY_SIZE(s_aModeInfo))
        {
            _idmMode = idm;
            InvalidateRect(_hwnd, NULL, TRUE);
        }
        break;
    }
}

void
CViewer::OnButtonDown(POINTS pts)
{
    POINT pt = { pts.x, pts.y };
    HMENU hmenu;
    HMENU hmenuSub;
    int   idm;

    hmenu = LoadMenuA(g_hinstMain, "ViewerMenu");
    if (hmenu)
    {
        ClientToScreen(_hwnd, &pt);
        hmenuSub = GetSubMenu(hmenu, 0);
        if (hmenuSub)
        {
            for (idm = 0; idm < ARRAY_SIZE(s_aModeInfo); idm++)
            {
                CheckMenuItem(hmenuSub,
                              idm,
                              (_idmMode == idm) ?
                              MF_BYCOMMAND|MF_CHECKED :
                              MF_BYCOMMAND|MF_UNCHECKED);
            }
#ifndef _MAC
            TrackPopupMenu(hmenuSub, TPM_LEFTALIGN | TPM_LEFTBUTTON,
#else
            TrackPopupMenu(hmenuSub, 0,
#endif
                           pt.x, pt.y, 0, _hwnd, NULL);
        }
        DestroyMenu(hmenu);
    }
}

void
CViewer::DrawView(HDC hdc, RECT *prc, DWORD dwAspect, int mm)
{
    HRESULT       hr;

    if (mm == MM_ANISOTROPIC)
    {
        // himetric
        LPtoDP(hdc, (POINT *)prc, 2);
        SetMapMode(hdc, mm);
        SetWindowExtEx(hdc, 2540, 2540, NULL);
        SetViewportExtEx(hdc,
                GetDeviceCaps(hdc, LOGPIXELSX),
                GetDeviceCaps(hdc, LOGPIXELSY), NULL);
        DPtoLP(hdc, (POINT *)prc, 2);
    }

#ifndef _MAC
    hr = (*GetPfnOleDraw())(_pVO, dwAspect, hdc, prc);
#else
	hr = _pVO->Draw(	 dwAspect,-1,0,0,0, hdc, (LPRECTL)prc, 0,0,0);
#endif
}

void
CViewer::DrawMetaFile(HDC hdc, RECT *prc, DWORD dwApsect)
{
    HRESULT         hr;
    STGMEDIUM       medium;
    METAFILEPICT *  pPict;
    FORMATETC       fmtetc =
        { CF_METAFILEPICT, NULL, dwApsect, -1, TYMED_MFPICT };

    memset(&medium, 0, sizeof(medium));

    hr = _pDO->GetData(&fmtetc, &medium);
    if (FAILED(hr))
        goto Cleanup;

    // STGFIX: t-gpease 8-13-97
    Assert(medium.tymed == TYMED_HGLOBAL);

    pPict = (METAFILEPICT *)GlobalLock(medium.hGlobal);

    SetMapMode(hdc, MM_ANISOTROPIC);
    SetWindowExtEx(hdc, pPict->xExt, pPict->yExt, NULL);
    SetViewportExtEx(hdc, prc->right - prc->left, prc->bottom - prc->top, NULL);
    // SetWindowExtEx(hdc, pPict->xExt, pPict->yExt, NULL);
    PlayMetaFile(hdc, pPict->hMF);

Cleanup:
    (*GetPfnReleaseStgMedium())(&medium);
}

void
CViewer::DrawEnhMetaFile(HDC hdc, RECT *prc, DWORD dwApsect)
{
#ifndef _MAC
    HRESULT         hr;
    STGMEDIUM       medium;
    FORMATETC       fmtetc =
        { CF_ENHMETAFILE, NULL, dwApsect, -1, TYMED_ENHMF };

    memset(&medium, 0, sizeof(medium));

    hr = _pDO->GetData(&fmtetc, &medium);
    if (FAILED(hr))
        goto Cleanup;
    PlayEnhMetaFile(hdc, medium.hEnhMetaFile, prc);

Cleanup:
    (*GetPfnReleaseStgMedium())(&medium);
#endif
}

void
CViewer::OnPaint()
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    char achMode[128];
    char achTitle[128];
    HMENU hmenu;
    HMENU hmenuSub;

    hmenu = LoadMenuA(g_hinstMain, "ViewerMenu");
    if (hmenu)
    {
        hmenuSub = GetSubMenu(hmenu, 0);
        if (hmenuSub)
            GetMenuStringA(hmenuSub, _idmMode, achMode, sizeof(achMode), MF_BYCOMMAND);
        DestroyMenu(hmenu);
    }
    wsprintfA(achTitle, "%s %d", achMode, _cDataChange);
    SetWindowTextA(_hwnd, achTitle);

    GetClientRect(_hwnd, &rc);
    hdc = ::BeginPaint(_hwnd, &ps);

    switch (s_aModeInfo[_idmMode].type)
    {
    case TYPE_VIEW:
        DrawView(
                hdc,
                &rc,
                s_aModeInfo[_idmMode].dwAspect,
                s_aModeInfo[_idmMode].mm);
        break;

    case TYPE_METAFILE:
        DrawMetaFile(
                hdc,
                &rc,
                s_aModeInfo[_idmMode].dwAspect);
        break;

    case TYPE_ENHMETAFILE:
        DrawEnhMetaFile(
                hdc,
                &rc,
                s_aModeInfo[_idmMode].dwAspect);
        break;
    }

    SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    EndPaint(_hwnd, &ps);
}

LRESULT CALLBACK
ViewerWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CViewer *pViewer;

    if (msg == WM_NCCREATE)
    {
        pViewer = (CViewer *) ((LPCREATESTRUCTW)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pViewer);
        pViewer->_hwnd = hwnd;
    }
    else
    {
        pViewer = (CViewer *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    if (pViewer)
    {
        switch (msg)
        {
        case WM_ERASEBKGND:
            if (s_aModeInfo[pViewer->_idmMode].dwAspect == DVASPECT_CONTENT)
                return TRUE;
            break;
            
        case WM_COMMAND:
            pViewer->OnCommand(GET_WM_COMMAND_ID(wParam, lParam));
            return 0;

        case WM_RBUTTONDOWN:
            pViewer->OnButtonDown(MAKEPOINTS(lParam));
            return 0;

        case WM_PAINT:
            pViewer->OnPaint();
            return 0;

        case WM_NCDESTROY:
            pViewer->_hwnd = NULL;
            delete pViewer;
            break;
        }
    }

    return DefWindowProcA(hwnd, msg, wParam, lParam);
}

void WINAPI 
DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize)
{
    CViewer *           pViewer = NULL;
    IOleObject *        pObj = NULL;
    IOleClientSite *    pClientSite = NULL;
    IOleInPlaceSite *   pIPSite = NULL;
    IOleInPlaceFrame *  pIPFrame = NULL;
    IOleInPlaceUIWindow * pIPWin = NULL;
    OLEINPLACEFRAMEINFO FI;
    RECT            rcPos;
    RECT            rcClip;
    WNDCLASSA       wc;
    HRESULT         hr;
    SIZEL           sizel;
    SIZE            size;
    HDC             hdc;

    EnsureThreadState();

    pViewer = new CViewer;
    if (!pViewer)
        goto Error;

    {   LOCK_GLOBALS;

        if (!s_fWndClassRegistered)
        {
            hdc = GetDC(NULL);
            if (!hdc)
                goto Error;

            s_sizePixelsPerInch.cx = GetDeviceCaps(hdc, LOGPIXELSX);
            s_sizePixelsPerInch.cy = GetDeviceCaps(hdc, LOGPIXELSY);

            ReleaseDC(NULL, hdc);

            memset(&wc, 0, sizeof(wc));
            wc.style = CS_HREDRAW | CS_VREDRAW;
            wc.lpfnWndProc = ViewerWndProc;
            wc.hInstance = g_hinstMain;
            wc.lpszClassName = "F3Viewer";
            wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + 1);

            if (RegisterClassA(&wc) == 0)
                goto Error;

            s_fWndClassRegistered = TRUE;
        }
    }

    hr = pUnk->QueryInterface(IID_IDataObject, (void **)&pViewer->_pDO);
    if (hr)
        goto Error;

    hr = pUnk->QueryInterface(IID_IViewObject, (void **)&pViewer->_pVO);
    if (FAILED(hr))
        goto Error;

    hr = pUnk->QueryInterface(IID_IOleObject, (void **)&pObj);
    if (hr)
        goto Error;

    hr = pObj->GetClientSite(&pClientSite);
    if (hr)
        goto Error;

    hr = pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **) &pIPSite);
    if (hr)
        goto Error;

    hr = pIPSite->GetWindowContext(
            &pIPFrame,
            &pIPWin,
            &rcPos,
            &rcClip,
            &FI);
    if (hr)
        goto Error;

    GetWindowRect(FI.hwndFrame, &rcPos);

    if (fUseFrameSize)
    {
        size.cx = rcPos.right - rcPos.left;
        size.cy = rcPos.bottom - rcPos.top;
    }
    else
    {
        RECT    rcClient;
        GetClientRect(FI.hwndFrame, &rcClient);

        hr = pObj->GetExtent(DVASPECT_CONTENT, &sizel);
        if (hr)
            goto Error;                
        size.cx = MulDiv(sizel.cx, s_sizePixelsPerInch.cx, 2540) + 
                (rcPos.right - rcPos.left) - (rcClient.right - rcClient.left);
        size.cy = MulDiv(sizel.cy, s_sizePixelsPerInch.cy, 2540) +
                (rcPos.bottom - rcPos.top) - (rcClient.bottom - rcClient.top);
    }

    if (CreateWindowExA(
            0,
            "F3Viewer",
            "IViewObject",
            WS_OVERLAPPEDWINDOW | WS_VISIBLE,
            rcPos.left,
            rcPos.bottom,
            size.cx,
            size.cy,
            hwndOwner,
            NULL,
            g_hinstMain,
            pViewer) == 0)
        goto Error;

    hr = pViewer->_pDO->DAdvise(
            &s_FormatEtcMetaFile,
            ADVF_NODATA,
            pViewer,
            &pViewer->_dwCookie);
    if (hr)
        goto Error;

    hr = pViewer->_pVO->SetAdvise(DVASPECT_CONTENT, 0, pViewer);
    if (hr)
        goto Error;

Cleanup:
    if (pObj)
        pObj->Release();
    if (pClientSite)
        pClientSite->Release();
    if (pIPSite)
        pIPSite->Release();
    if (pIPFrame)
        pIPFrame->Release();
    if (pIPWin)
        pIPWin->Release();
    return;

Error:
    delete pViewer;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\_f3debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       _f3debug.h
//
//  Contents:   Misc internal debug definitions.
//
//----------------------------------------------------------------------------

//
// Shared macros
//

typedef void *  PV;
typedef char    CHAR;

#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))

#ifdef tagError
#undef tagError
#endif

#ifdef tagAssertExit
#undef tagAssertExit
#endif

#ifdef tagAssertStacks
#undef tagAssertStacks
#endif

#define tagNull     ((TRACETAG) 0)
#define tagMin      ((TRACETAG) 1)
#define tagMax      ((TRACETAG) 1024)


/*
 *  TGTY
 *
 *  Tag type.  Possible values:
 *
 *      tgtyTrace       Trace points
 *      tgtyOther       Other TAG'd switch
 */

typedef int TGTY;

#define tgtyNull    0
#define tgtyTrace   1
#define tgtyOther   2

/*
 *  Flags in TGRC that are written to disk.
 */

enum TGRC_FLAG
{
    TGRC_FLAG_VALID     =  0x00000001,
    TGRC_FLAG_DISK      =  0x00000002,
    TGRC_FLAG_BREAK     =  0x00000008,
    TGRC_FLAG_SORTFIRST =  0x00000010,
    TGRC_FLAG_INITED    =  0x00000020,
#ifdef _MAC
    TGRC_FLAG_MAX =     LONG_MAX    // needed to force enum to be dword
#endif

};

#define TGRC_DEFAULT_FLAGS (TGRC_FLAG_VALID)

/*
 *  TGRC
 *
 *  Tag record.  Gives the current state of a particular TAG.
 *  This includes enabled status, owner and description, and
 *  tag type.
 *
 */

struct TGRC
{
    /* For trace points, enabled means output will get sent */
    /* to screen or disk.  For native/pcode switching, enabled */
    /* means the native version will get called. */

    BOOL    fEnabled;

    DWORD   ulBitFlags;     /* Flags */
    CHAR *  szOwner;        /* Strings passed at init ... */
    CHAR *  szDescrip;
    TGTY    tgty;           /* TAG type */

    BOOL    TestFlag(TGRC_FLAG mask)
                { return (ulBitFlags & mask) != 0; }
    void    SetFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags |= mask; }
    void    ClearFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags &= ~mask; }
    void    SetFlagValue(TGRC_FLAG mask, BOOL fValue)
                { fValue ? SetFlag(mask) : ClearFlag(mask); }
};

struct INET_SYMBOL_INFO
{
    DWORD       dwOffset;
    char        achModule[12];  // Lengths are arbitrary.
    char        achSymbol[51];
};

#ifdef PRODUCT_96
#define STACK_WALK_DEPTH  5
#else
#define STACK_WALK_DEPTH  12
#endif

/*
 * MBOT
 *
 * Used by the assert code for passing information to the assert dialog
 *
 */

#define TOPURL_LENGTH 200

struct MBOT
{
    const char * szMessage;
    const char * szTitle;
    const char * szFile;
    char         achModule[50];
    char         achTopUrl[TOPURL_LENGTH];
    DWORD        dwLine;
    DWORD        pid;
    DWORD        tid;

    INET_SYMBOL_INFO  asiSym[50];
    int          cSym;

    // DWORD        dwFlags;
    int          id;
    DWORD        dwErr;
};

// This constant is used to determine the number of symbols we use to print to
// the debugger and dialog for an assert.

#define SHORT_SYM_COUNT 5


/*
 *  DBGTHREADSTATE
 *
 *  Per-thread globals
 *
 */
struct DBGTHREADSTATE      // tag: pts
{
    DBGTHREADSTATE *   ptsNext;
    DBGTHREADSTATE *   ptsPrev;

    // Add globals below
    void *          pvRequest;              // Last pointer seen by pre-hook function.
    size_t          cbRequest;              // Last size seen by pre-hook function.
    BOOL            fSymbols;               // Last AreSymbolsEnabled() by pre-hook function.
    int             cTrackDisable;          // Disable memory tracking count/flag
    int             cCoTrackDisable;        // Disable Co memory tracking count/flag
    int             iIndent;                // Indent for trace tags
    BOOL            fDirtyDlg;              // Debug UI dirty dialog flag
    BOOL            fSpyRegistered;         // IMallocSpy registered
    BOOL            fSpyAlloc;              // Allocation is from IMallocSpy
    PERFMETERTAG    mtSpy;                  // Meter to use for IMallocSpy
    PERFMETERTAG    mtSpyUser;              // Custom meter to use for IMallocSpy
    INET_SYMBOL_INFO     aSymbols[STACK_WALK_DEPTH]; // stored symbols for realloc
    MBOT *          pmbot;                      // Used by assert dialog
    char            achTopUrl[TOPURL_LENGTH];   // Unicode string containing the
                                                //   topmost URL of the current
                                                //   page for this thread.
};

HRESULT DllThreadAttach();
void    DllThreadDetach(DBGTHREADSTATE * pts);

inline HRESULT EnsureThreadState()
{
    extern DWORD    g_dwTls;
    if (!TlsGetValue(g_dwTls))
        return DllThreadAttach();
    return S_OK;
}

inline DBGTHREADSTATE * DbgGetThreadState()
{
    extern DWORD    g_dwTls;
    return (DBGTHREADSTATE *)TlsGetValue(g_dwTls);
}

#undef TLS
#define TLS(x)      (DbgGetThreadState()->x)

/*
 *  CLockGlobals, CLockTrace, CLockResDlg
 *
 *  Classes which automatically lock/unlock global state
 *
 */
#ifndef _MAC
extern CRITICAL_SECTION     g_csTrace;
extern CRITICAL_SECTION     g_csResDlg;
extern CRITICAL_SECTION     g_csDebug;
extern CRITICAL_SECTION     g_csHeapHack;
extern CRITICAL_SECTION     g_csSpy;

class CLockGlobal       // tag: glock
{
public:
    CLockGlobal()   { EnterCriticalSection(&g_csDebug); }
    ~CLockGlobal()  { LeaveCriticalSection(&g_csDebug); }
};

class CLockTrace        // tag: tlock
{
public:
    CLockTrace()   { EnterCriticalSection(&g_csTrace); }
    ~CLockTrace()  { LeaveCriticalSection(&g_csTrace); }
};

class CLockResDlg       // tag: rlock
{
public:
    CLockResDlg()   { EnterCriticalSection(&g_csResDlg); }
    ~CLockResDlg()  { LeaveCriticalSection(&g_csResDlg); }
};

#undef LOCK_GLOBALS
#define LOCK_GLOBALS    CLockGlobal glock
#define LOCK_TRACE      CLockTrace  tlock
#define LOCK_RESDLG     CLockResDlg rlock
#else
#define LOCK_GLOBALS
#define LOCK_TRACE
#define LOCK_RESDLG
#endif


//
// Shared globals
//
extern BOOL                 g_fInit;
extern HINSTANCE            g_hinstMain;
extern HANDLE               g_hProcess;
extern TGRC                 mptagtgrc[];

ExternTag(tagMac);
ExternTag(tagError);
ExternTag(tagAssertPop);
ExternTag(tagAssertExit);
ExternTag(tagAssertStacks);
ExternTag(tagTestFailures);
ExternTag(tagTestFailuresIgnore);
ExternTag(tagRRETURN);
ExternTag(tagTraceCalls);
ExternTag(tagLeaks);
ExternTag(tagValidate);
ExternTag(tagSymbols);
ExternTag(tagSpySymbols);
ExternTag(tagTrackItf);
ExternTag(tagTrackItfVerbose);
ExternTag(tagOLEWatch);  // trace all OLE interface calls made.

extern int  g_cFFailCalled;
extern int  g_firstFailure;
extern int  g_cInterval;
extern BOOL g_fOSIsNT;
extern BOOL g_fAbnormalProcessTermination;

//
//  Shared function prototypes
//

// IEUNIX uses C++ compiler and the following func.
// And need to convert the following to C type to fix build break.
#ifdef UNIX
extern "C" {
#endif

HRESULT         GetTopURLForThread(DWORD tid, char * psz);
BOOL            JustFailed();
VOID            SaveDefaultDebugState(void);
BOOL            AreSymbolsEnabled();
void            MagicInit();
void            MagicDeinit();
int             GetStackBacktrace(int iStart, int cTotal, DWORD * pdwEip, INET_SYMBOL_INFO * psiSym);
void            GetStringFromSymbolInfo(DWORD dwAddr, INET_SYMBOL_INFO *pai, CHAR * pszString);
int             hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker);

#ifdef UNIX // UNIX needs to define the following in C type.
}
#endif

typedef HANDLE EVENT_HANDLE;
typedef HANDLE THREAD_HANDLE;
#define CloseEvent CloseHandle
#define CloseThread CloseHandle
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x

#define WIN16API
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debug\ws.cxx ===
//+------------------------------------------------------------------------
//  
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       Working set test infrastructure
//  
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PSAPI_H_
#define X_PSAPI_H_
#include "psapi.h"
#endif

#define MAX_PAGE_ENTRIES 256
#define MAXMODULES 64
#define MAX_WS_DELTA_PAGES 1024

struct WSPAGEINFO
{
   DWORD fAttr      :  8;
   DWORD fShared    :  1;
   DWORD filler     :  3;
   DWORD addrPage   : 20;
};

struct WSPAGEENTRY
{
    DWORD addrStart;
    DWORD addrEnd;
    TCHAR szModule[16];
    TCHAR szSection[8];
    DWORD dwSize;
};

static WSPAGEENTRY s_aPE[MAX_PAGE_ENTRIES];
static PSAPI_WS_WATCH_INFORMATION s_aWsChanges[MAX_WS_DELTA_PAGES];
static DWORD s_cPageEntries = 0;
static HINSTANCE s_hmod = NULL;
static BOOL s_bWsDeltaStarted = FALSE;

static BOOL (WINAPI *s_pfnGetProcessMemoryInfo)(HANDLE Process, PPROCESS_MEMORY_COUNTERS ppmemctrs, DWORD cb);
static BOOL (WINAPI *s_pfnEmptyWorkingSet)(HANDLE hProcess);
static BOOL (WINAPI *s_pfnQueryWorkingSet)(HANDLE hProcess, PVOID pv, DWORD cb);
static BOOL (WINAPI *s_pfnEnumProcessModules)(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded);
static DWORD (WINAPI *s_pfnGetModuleBaseName)(HANDLE hProcess, HMODULE hModule, LPTSTR lpBaseName, DWORD nSize);
static BOOL (WINAPI *s_pfnGetWsChanges)(HANDLE hProcess, PPSAPI_WS_WATCH_INFORMATION lpWatchInfo, DWORD cb);
static BOOL (WINAPI *s_pfnInitializeProcessForWsWatch)(HANDLE hProcess);

HRESULT LoadPSAPI()
{
    if (s_hmod)
	{
        return S_OK;
	}

    s_hmod = LoadLibrary(_T("PSAPI"));
    if (!s_hmod)
	{
        RRETURN(E_FAIL);
	}

    *(void **)&s_pfnGetProcessMemoryInfo = GetProcAddress(s_hmod, "GetProcessMemoryInfo");
    *(void **)&s_pfnQueryWorkingSet = GetProcAddress(s_hmod, "QueryWorkingSet");
    *(void **)&s_pfnEmptyWorkingSet = GetProcAddress(s_hmod, "EmptyWorkingSet");
    *(void **)&s_pfnEnumProcessModules = GetProcAddress(s_hmod, "EnumProcessModules");
    *(void **)&s_pfnGetModuleBaseName = GetProcAddress(s_hmod, "GetModuleBaseNameW");
    *(void **)&s_pfnGetWsChanges = GetProcAddress(s_hmod, "GetWsChanges");
    *(void **)&s_pfnInitializeProcessForWsWatch = GetProcAddress(s_hmod, "InitializeProcessForWsWatch");

    return S_OK;
}

HRESULT UnLoadPSAPI()
{
    if (!s_hmod)
	{
        return S_OK;
	}

    if (!FreeLibrary(s_hmod))
	{
		RRETURN(E_FAIL);
	}

    s_hmod = NULL;
	s_pfnGetProcessMemoryInfo = NULL;
    s_pfnQueryWorkingSet = NULL;
    s_pfnEmptyWorkingSet = NULL;
    s_pfnEnumProcessModules = NULL;
    s_pfnGetModuleBaseName = NULL;
    s_pfnGetWsChanges = NULL;
    s_pfnInitializeProcessForWsWatch = NULL;

    return S_OK;
}

HRESULT WINAPI
DbgExWsClear(HANDLE hProcess)
{
	HRESULT hr;

    hr = LoadPSAPI();
    if (S_OK != hr)
	{
		// No PSAPI for Win95, so return doing nothing if
		// LoadLibrary fails!
		hr = S_OK;
        goto Cleanup;
	}

    if (!(*s_pfnEmptyWorkingSet)(hProcess))
    {
		hr = E_FAIL;
        goto Cleanup;
    }

    s_cPageEntries = 0;

Cleanup:
	RRETURN(hr);
}

DWORD AddModuleSections(HANDLE hProcess, PVOID pBase, WSPAGEENTRY **ppPE)
{
    BYTE *pifh;
    PIMAGE_SECTION_HEADER pish;
    ULONG i;
    ULONG cSections = 0;

    pifh = (BYTE *)pBase + ((PIMAGE_DOS_HEADER)pBase)->e_lfanew + sizeof(DWORD);
    
    cSections = ((PIMAGE_FILE_HEADER)pifh)->NumberOfSections;
    if (cSections + s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        return cSections;
    }

    pish = (PIMAGE_SECTION_HEADER)(pifh + sizeof(IMAGE_FILE_HEADER) + ((PIMAGE_FILE_HEADER)pifh)->SizeOfOptionalHeader);

    for (i=0; i<cSections; i++, pish++, (*ppPE)++)
    {
        (*ppPE)->addrStart = (DWORD_PTR)pBase + pish->VirtualAddress;
        (*ppPE)->addrEnd = (DWORD_PTR)pBase + pish->VirtualAddress + pish->SizeOfRawData - 1;
        (*s_pfnGetModuleBaseName)(hProcess, (HMODULE)pBase, (*ppPE)->szModule, sizeof((*ppPE)->szModule));
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCSTR)pish->Name, -1,
                            (LPWSTR)(*ppPE)->szSection,
                            ARRAY_SIZE((*ppPE)->szSection));
        (*ppPE)->dwSize = 0;
    }

    return cSections;
}

HRESULT FillPETable(HANDLE hProcess)
{
	HRESULT hr = S_OK;
    HMODULE ahModule[MAXMODULES];
    ULONG i;
    WSPAGEENTRY *pPE;
    MEMORY_BASIC_INFORMATION mbi;
    DWORD cb;

    if (!(*s_pfnEnumProcessModules)(hProcess, ahModule, sizeof(ahModule), &cb))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    for (i = 0, pPE = s_aPE; i < cb / sizeof(HMODULE); i++)
    {
        s_cPageEntries += AddModuleSections(hProcess, (PVOID)ahModule[i], &pPE);

        if (s_cPageEntries > MAX_PAGE_ENTRIES)
        {
		    hr = E_OUTOFMEMORY;
			goto Cleanup;
        }
    }

    if (!VirtualQuery(GetProcessHeap(), &mbi, sizeof(mbi)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    pPE->addrStart = (DWORD_PTR)mbi.BaseAddress;
    pPE->addrEnd = (DWORD_PTR)mbi.BaseAddress + mbi.RegionSize;
    lstrcpy (pPE->szModule, _T("Process Heap"));
    pPE->szSection[0] = 0;
    pPE++->dwSize = 0;
    
    s_cPageEntries++;
    if (s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        hr = E_OUTOFMEMORY;
	    goto Cleanup;
    }

    if (!VirtualQuery(&cb, &mbi, sizeof(mbi)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    pPE->addrStart = (DWORD_PTR)mbi.BaseAddress;
    pPE->addrEnd = (DWORD_PTR)mbi.BaseAddress + mbi.RegionSize;
    lstrcpy (pPE->szModule, _T("Thread Stack"));
    pPE->szSection[0] = 0;
    pPE++->dwSize = 0;

    s_cPageEntries++;
    if (s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        hr = E_OUTOFMEMORY;
	    goto Cleanup;
    }

    pPE->addrStart = 0;
    pPE->addrEnd = 0xFFFFFFFF;
    lstrcpy (pPE->szModule, _T("(Unknown)"));
    pPE->szSection[0] = 0;
    pPE->dwSize = 0;

    s_cPageEntries++;
    if (s_cPageEntries > MAX_PAGE_ENTRIES)
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT WINAPI
DbgExWsTakeSnapshot(HANDLE hProcess)
{
	HRESULT hr = S_OK;
    DWORD i,j;
    WSPAGEINFO *pWSPages = NULL, *pBufHead = NULL;
    PROCESS_MEMORY_COUNTERS psvmctr;
    SYSTEM_INFO si;
    DWORD cPages = 0;

    memset(s_aPE, 0, sizeof(s_aPE));
    s_cPageEntries = 0;

    hr = LoadPSAPI();
    if (S_OK != hr)
	{
		// No PSAPI for Win95, so return doing nothing if
		// LoadLibrary fails!
		hr = S_OK;
        goto Cleanup;
	}

    if (!(*s_pfnGetProcessMemoryInfo)(hProcess, &psvmctr, sizeof(psvmctr)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    GetSystemInfo(&si);
    // Double the buffer size to make sure that QueryWorkingSet always succeeds!
    cPages = (psvmctr.WorkingSetSize / si.dwPageSize)*2 + 1;

    pWSPages = pBufHead = new WSPAGEINFO[cPages];
	if (!pWSPages)
    {
        hr = E_OUTOFMEMORY;
	    goto Cleanup;
    }

    if (!(*s_pfnQueryWorkingSet)(hProcess, pWSPages, cPages * sizeof(WSPAGEINFO)))
    {
	    hr = E_FAIL;
		goto Cleanup;
    }

    hr = FillPETable(hProcess);
	if (S_OK != hr)
    {
	    goto Cleanup;
    }
    
    cPages = *((DWORD *)pWSPages++);
    for (i=0; i<cPages; i++, pWSPages++)
    {
        for (j=0; j<s_cPageEntries; j++)
        {
            if ((*(DWORD *)pWSPages & 0xFFFFF000) >= s_aPE[j].addrStart && (*(DWORD*)pWSPages & 0xFFFFF000) <= s_aPE[j].addrEnd)
            {
                s_aPE[j].dwSize += si.dwPageSize;
                break;
            }
        }
    }

Cleanup:
    delete pBufHead;
    RRETURN(hr);
}

BSTR WINAPI
DbgExWsGetModule(long row)
{
    if (row >= 0 && (DWORD)row < s_cPageEntries)
        return (BSTR)s_aPE[row].szModule;
    else
        return NULL;
}

BSTR WINAPI
DbgExWsGetSection(long row)
{
    if (row >= 0 && (DWORD)row < s_cPageEntries)
        return (BSTR)s_aPE[row].szSection;
    else
        return NULL;
}

HRESULT WINAPI
DbgExWsStartDelta(HANDLE hProcess)
{
	HRESULT hr;

    hr = LoadPSAPI();
    if (S_OK != hr)
	{
		// No PSAPI for Win95, so return doing nothing if
		// LoadLibrary fails!
		hr = S_OK;
        goto Cleanup;
	}

    if (!(*s_pfnInitializeProcessForWsWatch)(hProcess))
    {
		hr = E_FAIL;
        goto Cleanup;
    }

    // clear all WS changes till before the call to DbgExWsStartDelta
    (*s_pfnGetWsChanges)(hProcess, s_aWsChanges, sizeof(s_aWsChanges));
    s_bWsDeltaStarted = TRUE;

Cleanup:
	RRETURN(hr);
}

long WINAPI
DbgExWsEndDelta(HANDLE hProcess)
{
    long nPageFaults = -1;
    PPSAPI_WS_WATCH_INFORMATION pWsChanges = s_aWsChanges;

    if (s_bWsDeltaStarted)
    {
        (*s_pfnGetWsChanges)(hProcess, s_aWsChanges, sizeof(s_aWsChanges));
        if (s_aWsChanges[MAX_WS_DELTA_PAGES-1].FaultingPc)
        {
            nPageFaults = MAX_WS_DELTA_PAGES;
        }
        else
        {
            while (pWsChanges->FaultingPc || pWsChanges->FaultingVa)
            {
                pWsChanges++;
            }
            
            nPageFaults = pWsChanges - s_aWsChanges;
        }

        s_bWsDeltaStarted = FALSE;
    }

    return nPageFaults;
}

long WINAPI
DbgExWsSize(long row)
{
    if (row >= 0 && (DWORD)row < s_cPageEntries)
        return (long)s_aPE[row].dwSize;
    else
        return 0;
}

long WINAPI
DbgExWsCount()
{
    return (long)s_cPageEntries;
}

long WINAPI
DbgExWsTotal()
{
    DWORD i;
    long total = 0;
    
    for (i=0; i<s_cPageEntries; i++)
    {
        total += (long)s_aPE[i].dwSize;
    }

    return total;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\debuglib\debuglib.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       debuglib.c
//
//  Contents:   Interface to debugging .dll (if available)
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <w4warn.h>
#include <limits.h>
#include <mshtmdbg.h>

#include "markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef __cplusplus
extern "C" {
#endif

struct TAGINFO
{
    CHAR *  pchOwner;
    CHAR *  pchDesc;
    BOOL    fEnabled;
};

TAGINFO g_rgtaginfo[] =
{
    { "Debug",      "General debug output",                     TRUE    },  //  0: tagDefault
    { "Trace",      "Errors",                                   TRUE    },  //  1: tagError
    { "Trace",      "Warnings",                                 FALSE   },  //  2: tagWarning
    { "Thread",     "Thread related tracing",                   FALSE   },  //  3: tagThread
    { "Assert",     "Exit on asserts",                          FALSE   },  //  4: tagAssertExit
    { "Assert",     "Stacktraces on asserts",                   TRUE    },  //  5: tagAssertStacks
    { "Memory",     "Use VMem for MemAlloc",                    FALSE   },  //  6: tagMemoryStrict
    { "Memory",     "Use VMem for CoTaskMemAlloc",              FALSE   },  //  7: tagCoMemoryStrict
    { "Memory",     "Use VMem strict at end (vs beginning)",    FALSE   },  //  8: tagMemoryStrictTail
    { "Memory",     "VMem pad to quadword at end",              FALSE   },  //  9: tagMemoryStrictAlign
    { "Trace",      "All calls to OCX interfaces",              FALSE   },  // 10: tagOLEWatch
    { "Perf",       "Perf and size killers",                    FALSE   },  // 11: tagPerf
    { "Peer",       "Provide test host behaviors",              FALSE   },  // 12: tagHostInfoBehaviors
    { "FALSE",      "FALSE",                                    FALSE   },  // 13: tagFALSE
};

#define TAG_NONAME              0x01
#define TAG_NONEWLINE           0x02
#define ARRAY_SIZE(x)           (sizeof(x) / sizeof(x[0]))

#define tagDefault              ((TRACETAG)0)
#define tagError                ((TRACETAG)1)
#define tagWarning              ((TRACETAG)2)
#define tagThread               ((TRACETAG)3)
#define tagAssertExit           ((TRACETAG)4)
#define tagAssertStacks         ((TRACETAG)5)
#define tagMemoryStrict         ((TRACETAG)6)
#define tagCoMemoryStrict       ((TRACETAG)7)
#define tagMemoryStrictTail     ((TRACETAG)8)
#define tagMemoryStrictAlign    ((TRACETAG)9)
#define tagOLEWatch             ((TRACETAG)10)
#define tagPerf                 ((TRACETAG)11)
#define tagHostInfoBehavior     ((TRACETAG)12)
#define tagFALSE                ((TRACETAG)13)

HINSTANCE g_hInstDbg = NULL;
HINSTANCE g_hInstLeak = NULL;

char * GetModuleName(HINSTANCE hInst)
{
    static char achMod[MAX_PATH];
    achMod[0] = 0;
    GetModuleFileNameA(hInst, achMod, sizeof(achMod));
    char * psz = &achMod[lstrlenA(achMod)];
    while (psz > achMod && *psz != '\\' && *psz != '//') --psz;
    if (*psz == '\\' || *psz == '//') ++psz;
    return(psz);
}

void LeakDumpAppend(char * pszMsg, void * pvArg = NULL)
{
    HANDLE hFile;
    char ach[1024];
    DWORD dw;

    lstrcpyA(ach, GetModuleName(g_hInstLeak));
    lstrcatA(ach, ": ");
    wsprintfA(&ach[lstrlenA(ach)], pszMsg, pvArg);

    hFile = CreateFileA("c:\\leakdump.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        WriteFile(hFile, ach, lstrlenA(ach), &dw, NULL);
        WriteFile(hFile, "\r\n", 2, &dw, NULL);
        CloseHandle(hFile);
    }
}

DWORD WINAPI _DbgExGetVersion()
{
    return(MSHTMDBG_API_VERSION);
}

BOOL WINAPI _DbgExIsFullDebug()
{
    return(FALSE);
}

void WINAPI _DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
}

void WINAPI _DbgExDoTracePointsDialog(BOOL fWait)
{
}

void WINAPI _DbgExRestoreDefaultDebugState()
{
}

BOOL WINAPI _DbgExEnableTag(TRACETAG tag, BOOL fEnable)
{
    BOOL fOld = FALSE;

    if (tag > 0 && tag < ARRAY_SIZE(g_rgtaginfo) - 1)
    {
        fOld = g_rgtaginfo[tag].fEnabled;
        g_rgtaginfo[tag].fEnabled = fEnable;
    }

    return(fOld);
}

BOOL WINAPI _DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk)
{
    return(FALSE);
}

BOOL WINAPI _DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak)
{
    return(FALSE);
}

BOOL WINAPI _DbgExIsTagEnabled(TRACETAG tag)
{
    return(tag >= 0 && tag < ARRAY_SIZE(g_rgtaginfo) && g_rgtaginfo[tag].fEnabled);
}

TRACETAG WINAPI _DbgExFindTag(char * szTagDesc)
{
    TAGINFO * pti = g_rgtaginfo;
    TRACETAG tag;

    for (tag = 0; tag < ARRAY_SIZE(g_rgtaginfo); ++tag, ++pti)
    {
        if (!lstrcmpiA(pti->pchDesc, szTagDesc))
        {
            return(tag);
        }
    }

    return(tagFALSE);
}

TRACETAG WINAPI _DbgExTagError()
{
    return(tagError);
}

TRACETAG WINAPI _DbgExTagWarning()
{
    return(tagWarning);
}

TRACETAG WINAPI _DbgExTagThread()
{
    return(tagThread);
}

TRACETAG WINAPI _DbgExTagAssertExit()
{
    return(tagAssertExit);
}

TRACETAG WINAPI _DbgExTagAssertStacks()
{
    return(tagAssertStacks);
}

TRACETAG WINAPI _DbgExTagMemoryStrict()
{
    return(tagMemoryStrict);
}

TRACETAG WINAPI _DbgExTagCoMemoryStrict()
{
    return(tagCoMemoryStrict);
}

TRACETAG WINAPI _DbgExTagMemoryStrictTail()
{
    return(tagMemoryStrictTail);
}

TRACETAG WINAPI _DbgExTagMemoryStrictAlign()
{
    return(tagMemoryStrictAlign);
}

TRACETAG WINAPI _DbgExTagOLEWatch()
{
    return(tagOLEWatch);
}

TRACETAG WINAPI _DbgExTagPerf()
{
    return(tagPerf);
}

TRACETAG WINAPI _DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled)
{
    TAGINFO * pti = g_rgtaginfo;
    TRACETAG tag;

    for (tag = 0; tag < ARRAY_SIZE(g_rgtaginfo) - 1; ++tag, ++pti)
    {
        if (!lstrcmpiA(pti->pchDesc, szDescrip) && !lstrcmpiA(pti->pchOwner, szOwner))
        {
            return(tag);
        }
    }

    return(tagFALSE);
}

TRACETAG WINAPI _DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled)
{
    TAGINFO * pti = g_rgtaginfo;
    TRACETAG tag;

    for (tag = 0; tag < ARRAY_SIZE(g_rgtaginfo) - 1; ++tag, ++pti)
    {
        if (!lstrcmpiA(pti->pchDesc, szDescrip) && !lstrcmpiA(pti->pchOwner, szOwner))
        {
            return(tag);
        }
    }

    return(tagFALSE);
}

BOOL WINAPI _DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker)
{
    if (DbgExIsTagEnabled(tag))
    {
        CHAR    achDup[512], *pch;
        CHAR    achBuf[1024];
        LONG    cch = 0;

        lstrcpynA(achDup, szFmt, ARRAY_SIZE(achDup));

        for (pch = achDup; *pch; ++pch)
        {
            if (*pch == '%')
            {
                if (pch[1] == '%')
                {
                    ++pch;
                    continue;
                }

                if (pch[1] == 'h' && pch[2] == 'r')
                {
                    pch[1] = 'l';
                    pch[2] = 'X';
                    continue;
                }
            }
        }

        if (!(usFlags & TAG_NONAME))
        {
            strcpy(achBuf, "MSHTML: ");
            cch += 8;
        }

        cch += wvsprintfA(&achBuf[cch], szFmt, valMarker);

        if (!(usFlags & TAG_NONEWLINE))
        {
            strcpy(&achBuf[cch], "\r\n");
        }

        OutputDebugStringA(achBuf);
    }

    return(FALSE);
}

void WINAPI _DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal)
{
}

BOOL WINAPI _DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage)
{
    CHAR szBuf[4096];
    wsprintfA(szBuf, "MSHTML: Assertion Failure in file %s, line %ld:\r\nMSHTML:   %s\r\n",
              szFile ? szFile : "unknown", iLine, szMessage);
    OutputDebugStringA(szBuf);
    return TRUE;
}

void WINAPI _DbgExAssertThreadDisable(BOOL fDisable)
{
}

HRESULT WINAPI _DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker)
{
    return(hr);
}

size_t WINAPI _DbgExPreAlloc(size_t cbRequest)
{
    return(cbRequest);
}

void * WINAPI _DbgExPostAlloc(void *pv)
{
    return(pv);
}

void * WINAPI _DbgExPreFree(void *pv)
{
    if (g_hInstDbg)
    {
        LeakDumpAppend("DbgExPreFree: freeing memory at %08lX", pv);
        pv = NULL;
    }

    return(pv);
}

void WINAPI _DbgExPostFree()
{
}

size_t WINAPI _DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv)
{
    *ppv = pvRequest;
    return(cbRequest);
}

void * WINAPI _DbgExPostRealloc(void *pv)
{
    return(pv);
}

void * WINAPI _DbgExPreGetSize(void *pvRequest)
{
    return(pvRequest);
}

size_t WINAPI _DbgExPostGetSize(size_t cb)
{
    return(cb);
}

void * WINAPI _DbgExPreDidAlloc(void *pvRequest)
{
    return(pvRequest);
}

BOOL WINAPI _DbgExPostDidAlloc(void *pvRequest, BOOL fActual)
{
    return(fActual);
}

void WINAPI _DbgExMemoryTrackDisable(BOOL fDisable)
{
}

void WINAPI _DbgExCoMemoryTrackDisable(BOOL fDisable)
{
}

void WINAPI _DbgExMemoryBlockTrackDisable(void * pv)
{
}

void WINAPI _DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt)
{
}

void * WINAPI _DbgExGetMallocSpy()
{
    return(NULL);
}

void WINAPI _DbgExTraceMemoryLeaks()
{
}

BOOL WINAPI _DbgExValidateInternalHeap()
{
    return(TRUE);
}

LONG_PTR WINAPI _DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return(errExpr);
}

LONG_PTR WINAPI _DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return(errExpr);
}

HRESULT WINAPI _DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return(hrTest);
}

HRESULT WINAPI _DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite)
{
    return(hrTest);
}

void WINAPI _DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

void WINAPI _DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line)
{
}

void WINAPI _DbgExSetSimFailCounts(int firstFailure, int cInterval)
{
}

void WINAPI _DbgExShowSimFailDlg()
{
}

BOOL WINAPI _DbgExFFail()
{
    return(FALSE);
}

int WINAPI _DbgExGetFailCount()
{
    return(INT_MIN);
}

void WINAPI _DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv)
{
}

void WINAPI _DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize)
{
}

void WINAPI _DbgExOpenMemoryMonitor()
{
}

void WINAPI _DbgExOpenLogFile(LPCSTR szFName)
{
}

void * WINAPI _DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker)
{
    return(pvRequest);
}

char * WINAPI _DbgExMemGetName(void *pvRequest)
{
    return("");
}

HRESULT WINAPI _DbgExWsClear(HANDLE hProcess)
{
    return(S_OK);
}

HRESULT WINAPI _DbgExWsTakeSnapshot(HANDLE hProcess)
{
    return(S_OK);
}

BSTR WINAPI _DbgExWsGetModule(long row)
{
    return(NULL);
}

BSTR WINAPI _DbgExWsGetSection(long row)
{
    return(NULL);
}

long WINAPI _DbgExWsSize(long row)
{
    return(0);
}

long WINAPI _DbgExWsCount()
{
    return(0);
}

long WINAPI _DbgExWsTotal()
{
    return(0);
}

HRESULT WINAPI _DbgExWsStartDelta(HANDLE hProcess)
{
    return(S_OK);
}

long WINAPI _DbgExWsEndDelta(HANDLE hProcess)
{
    return(-1);
}

void WINAPI _DbgExDumpProcessHeaps()
{
}

PERFTAG WINAPI _DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip)
{
    return(0);
}

void WINAPI _DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker)
{
}

void WINAPI _DbgExPerfDump()
{
}

void WINAPI _DbgExPerfClear()
{
}

void WINAPI _DbgExPerfTags()
{
}

void WINAPI _DbgExPerfEnable(BOOL fEnable)
{
}

char * WINAPI _DbgExDecodeMessage(UINT msg)
{
    return("");
}

PERFMETERTAG WINAPI _DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip)
{
    return(0);
}

void WINAPI _DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
}

void WINAPI _DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal)
{
}

char * WINAPI _DbgExMtGetName(PERFMETERTAG mt)
{
    return("");
}

char * WINAPI _DbgExMtGetDesc(PERFMETERTAG mt)
{
    return("");
}

BOOL WINAPI _DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue)
{
    return(0);
}

void WINAPI _DbgExMtOpenMonitor()
{
}

void WINAPI _DbgExMtLogDump(LPSTR pchFile)
{
}

PERFMETERTAG WINAPI _DbgExMtLookupMeter(char * szTag)
{
    return 0;
}

long WINAPI _DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive)
{
    return 0;
}

long WINAPI _DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive)
{
    return 0;
}


void WINAPI _DbgExSetTopUrl(LPWSTR pstrUrl)
{
}

void WINAPI _DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf)
{
    pszBuf[0] = 0;
}

BOOL WINAPI _DbgExGetChkStkFill(DWORD * pdwFill)
{
    *pdwFill = GetPrivateProfileIntA("chkstk", "fill", 0xCCCCCCCC, "mshtmdbg.ini");
    return(!GetPrivateProfileIntA("chkstk", "disable", FALSE, "mshtmdbg.ini"));
}

int WINAPI _DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol)
{
	return 0;
}

// cdecl function "wrappers" to their va_list equivalent ----------------------

BOOL __cdecl
DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...)
{
    va_list va;
    BOOL    f;

    va_start(va, szFmt);
    f = DbgExTaggedTraceListEx(tag, 0, szFmt, va);
    va_end(va);

    return f;
}

BOOL __cdecl
DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    va_list va;
    BOOL    f;

    va_start(va, szFmt);
    f = DbgExTaggedTraceListEx(tag, usFlags, szFmt, va);
    va_end(va);

    return f;
}

HRESULT __cdecl
DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...)
{
    va_list va;
    HRESULT hrResult;

    va_start(va, cHResult);
    hrResult = DbgExCheckAndReturnResultList(hr, fTrace, pstrFile, line, cHResult, va);
    va_end(va);

    return(hrResult);
}

void * __cdecl
DbgExMemSetName(void *pvRequest, char * szFmt, ...)
{
    va_list va;
    void * pv;

    va_start(va, szFmt);
    pv = DbgExMemSetNameList(pvRequest, szFmt, va);
    va_end(va);

    return(pv);
}

void __cdecl
DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...)
{
    va_list va;

    va_start(va, pchFmt);
    DbgExPerfLogFnList(tag, pvObj, pchFmt, va);
    va_end(va);
}

// InitDebugLib ---------------------------------------------------------------

#define DBGEXFUNCTIONS() \
    DBGEXWRAP (DWORD, DbgExGetVersion, (), ()) \
    DBGEXWRAP (BOOL, DbgExIsFullDebug, (), ()) \
    DBGEXWRAP_(void, DbgExSetDllMain, (HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID)), (hDllHandle, pfnDllMain)) \
    DBGEXWRAP_(void, DbgExDoTracePointsDialog, (BOOL fWait), (fWait)) \
    DBGEXWRAP_(void, DbgExRestoreDefaultDebugState, (), ()) \
    DBGEXWRAP (BOOL, DbgExEnableTag, (TRACETAG tag, BOOL fEnable), (tag, fEnable)) \
    DBGEXWRAP (BOOL, DbgExSetDiskFlag, (TRACETAG tag, BOOL fSendToDisk), (tag, fSendToDisk)) \
    DBGEXWRAP (BOOL, DbgExSetBreakFlag, (TRACETAG tag, BOOL fBreak), (tag, fBreak)) \
    DBGEXWRAP (BOOL, DbgExIsTagEnabled, (TRACETAG tag), (tag)) \
    DBGEXWRAP (TRACETAG, DbgExFindTag, (char * szTagDesc), (szTagDesc)) \
    DBGEXWRAP (TRACETAG, DbgExTagError, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagWarning, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagThread, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagAssertExit, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagAssertStacks, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagMemoryStrict, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagCoMemoryStrict, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagMemoryStrictTail, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagMemoryStrictAlign, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagOLEWatch, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagPerf, (), ()) \
    DBGEXWRAP (TRACETAG, DbgExTagRegisterTrace, (CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled), (szOwner, szDescrip, fEnabled)) \
    DBGEXWRAP (TRACETAG, DbgExTagRegisterOther, (CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled), (szOwner, szDescrip, fEnabled)) \
    DBGEXWRAP (BOOL, DbgExTaggedTraceListEx, (TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker), (tag, usFlags, szFmt, valMarker)) \
    DBGEXWRAP_(void, DbgExTaggedTraceCallers, (TRACETAG tag, int iStart, int cTotal), (tag, iStart, cTotal)) \
    DBGEXWRAP (BOOL, DbgExAssertImpl, (char const * szFile, int iLine, char const * szMessage), (szFile, iLine, szMessage)) \
    DBGEXWRAP_(void, DbgExAssertThreadDisable, (BOOL fDisable), (fDisable)) \
    DBGEXWRAP (HRESULT, DbgExCheckAndReturnResultList, (HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker), (hr, fTrace, pstrFile, line, cHResult, valMarker)) \
    DBGEXWRAP (size_t, DbgExPreAlloc, (size_t cbRequest), (cbRequest)) \
    DBGEXWRAP (void *, DbgExPostAlloc, (void *pv), (pv)) \
    DBGEXWRAP (void *, DbgExPreFree, (void *pv), (pv)) \
    DBGEXWRAP_(void, DbgExPostFree, (), ()) \
    DBGEXWRAP (size_t, DbgExPreRealloc, (void *pvRequest, size_t cbRequest, void **ppv), (pvRequest, cbRequest, ppv)) \
    DBGEXWRAP (void *, DbgExPostRealloc, (void *pv), (pv)) \
    DBGEXWRAP (void *, DbgExPreGetSize, (void *pvRequest), (pvRequest)) \
    DBGEXWRAP (size_t, DbgExPostGetSize, (size_t cb), (cb)) \
    DBGEXWRAP (void *, DbgExPreDidAlloc, (void *pvRequest), (pvRequest)) \
    DBGEXWRAP (BOOL, DbgExPostDidAlloc, (void *pvRequest, BOOL fActual), (pvRequest, fActual)) \
    DBGEXWRAP_(void, DbgExMemoryTrackDisable, (BOOL fDisable), (fDisable)) \
    DBGEXWRAP_(void, DbgExCoMemoryTrackDisable, (BOOL fDisable), (fDisable)) \
    DBGEXWRAP_(void, DbgExMemoryBlockTrackDisable, (void * pv), (pv)) \
    DBGEXWRAP_(void, DbgExMemSetHeader, (void * pvRequest, size_t cb, PERFMETERTAG mt), (pvRequest, cb, mt)) \
    DBGEXWRAP (void *, DbgExGetMallocSpy, (), ()) \
    DBGEXWRAP_(void, DbgExTraceMemoryLeaks, (), ()) \
    DBGEXWRAP (BOOL, DbgExValidateInternalHeap, (), ()) \
    DBGEXWRAP (LONG_PTR, DbgExTraceFailL, (LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line), (errExpr, errTest, fIgnore, pstrExpr, pstrFile, line)) \
    DBGEXWRAP (LONG_PTR, DbgExTraceWin32L, (LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line), (errExpr, errTest, fIgnore, pstrExpr, pstrFile, line)) \
    DBGEXWRAP (HRESULT, DbgExTraceHR, (HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line), (hrTest, fIgnore, pstrExpr, pstrFile, line)) \
    DBGEXWRAP (HRESULT, DbgExTraceOLE, (HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite), (hrTest, fIgnore, pstrExpr, pstrFile, line, lpsite)) \
    DBGEXWRAP_(void, DbgExTraceEnter, (LPSTR pstrExpr, LPSTR pstrFile, int line), (pstrExpr, pstrFile, line)) \
    DBGEXWRAP_(void, DbgExTraceExit, (LPSTR pstrExpr, LPSTR pstrFile, int line), (pstrExpr, pstrFile, line)) \
    DBGEXWRAP_(void, DbgExSetSimFailCounts, (int firstFailure, int cInterval), (firstFailure, cInterval)) \
    DBGEXWRAP_(void, DbgExShowSimFailDlg, (), ()) \
    DBGEXWRAP (BOOL, DbgExFFail, (), ()) \
    DBGEXWRAP (int, DbgExGetFailCount, (), ()) \
    DBGEXWRAP_(void, DbgExTrackItf, (REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv), (iid, pch, fTrackOnQI, ppv)) \
    DBGEXWRAP_(void, DbgExOpenViewObjectMonitor, (HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize), (hwndOwner, pUnk, fUseFrameSize)) \
    DBGEXWRAP_(void, DbgExOpenMemoryMonitor, (), ()) \
    DBGEXWRAP_(void, DbgExOpenLogFile, (LPCSTR szFName), (szFName)) \
    DBGEXWRAP (void *, DbgExMemSetNameList, (void * pvRequest, char * szFmt, va_list valMarker), (pvRequest, szFmt, valMarker)) \
    DBGEXWRAP (char *, DbgExMemGetName, (void *pvRequest), (pvRequest)) \
    DBGEXWRAP (HRESULT, DbgExWsClear, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP (HRESULT, DbgExWsTakeSnapshot, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP (BSTR, DbgExWsGetModule, (long row), (row)) \
    DBGEXWRAP (BSTR, DbgExWsGetSection, (long row), (row)) \
    DBGEXWRAP (long, DbgExWsSize, (long row), (row)) \
    DBGEXWRAP (long, DbgExWsCount, (), ()) \
    DBGEXWRAP (long, DbgExWsTotal, (), ()) \
    DBGEXWRAP (HRESULT, DbgExWsStartDelta, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP (long, DbgExWsEndDelta, (HANDLE hProcess), (hProcess)) \
    DBGEXWRAP_(void, DbgExDumpProcessHeaps, (), ()) \
    DBGEXWRAP (PERFTAG, DbgExPerfRegister, (char * szTag, char * szOwner, char * szDescrip), (szTag, szOwner, szDescrip)) \
    DBGEXWRAP_(void, DbgExPerfLogFnList, (PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker), (tag, pvObj, pchFmt, valMarker)) \
    DBGEXWRAP_(void, DbgExPerfDump, (), ()) \
    DBGEXWRAP_(void, DbgExPerfClear, (), ()) \
    DBGEXWRAP_(void, DbgExPerfTags, (), ()) \
    DBGEXWRAP_(void, DbgExPerfEnable, (BOOL fEnable), (fEnable)) \
    DBGEXWRAP (char *, DbgExDecodeMessage, (UINT msg), (msg)) \
    DBGEXWRAP(PERFMETERTAG, DbgExMtRegister, (char * szTag, char * szOwner, char * szDescrip), (szTag, szOwner, szDescrip)) \
    DBGEXWRAP_(void, DbgExMtAdd, (PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal), (mt, lCnt, lVal)) \
    DBGEXWRAP_(void, DbgExMtSet, (PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal), (mt, lCnt, lVal)) \
    DBGEXWRAP (char *, DbgExMtGetName, (PERFMETERTAG mt), (mt)) \
    DBGEXWRAP (char *, DbgExMtGetDesc, (PERFMETERTAG mt), (mt)) \
    DBGEXWRAP (BOOL, DbgExMtSimulateOutOfMemory, (PERFMETERTAG mt, LONG_PTR lNewValue), (mt, lNewValue)) \
    DBGEXWRAP_(void, DbgExMtOpenMonitor, (), ()) \
    DBGEXWRAP_(void, DbgExMtLogDump, (LPSTR pchFile), (pchFile)) \
    DBGEXWRAP (PERFMETERTAG, DbgExMtLookupMeter, (char * szTag), (szTag)) \
    DBGEXWRAP (long, DbgExMtGetMeterCnt, (PERFMETERTAG mt, BOOL fExclusive), (mt, fExclusive)) \
    DBGEXWRAP (long, DbgExMtGetMeterVal, (PERFMETERTAG mt, BOOL fExclusive), (mt, fExclusive)) \
    DBGEXWRAP_(void, DbgExSetTopUrl, (LPWSTR pstrUrl), (pstrUrl)) \
    DBGEXWRAP_(void, DbgExGetSymbolFromAddress, (void * pvAddr, char * pszBuf, DWORD cchBuf), (pvAddr, pszBuf, cchBuf)) \
    DBGEXWRAP (BOOL, DbgExGetChkStkFill, (DWORD * pdwFill), (pdwFill)) \
    DBGEXWRAP (int, DbgExGetStackTrace, (int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol), (iStart, cTotal, pbBuffer, cbBuffer, cchModule, cchSymbol)) \

#undef  DBGEXWRAP
#undef  DBGEXWRAP_
#define DBGEXWRAP(ret, fn, formals, params) ret (WINAPI * g_##fn) formals = NULL;
#define DBGEXWRAP_(ret, fn, formals, params) ret (WINAPI * g_##fn) formals = NULL;

DBGEXFUNCTIONS()

#undef  DBGEXWRAP
#undef  DBGEXWRAP_
#define DBGEXWRAP(ret, fn, formals, params) ret WINAPI fn formals { return(g_##fn params); }
#define DBGEXWRAP_(ret, fn, formals, params) ret WINAPI fn formals { g_##fn params; }

DBGEXFUNCTIONS()

BOOL InitDebugProcedure(void ** ppv, char * pchFn)
{
    *ppv = (void *)GetProcAddress(g_hInstDbg, pchFn);

    if (*ppv == NULL)
    {
        char ach[512];
        wsprintfA(ach, "InitDebugLib: Can't find mshtmdbg.dll entrypoint %s\r\n", pchFn);
        OutputDebugStringA(ach);
        return(FALSE);
    }

    return(TRUE);
}

void InitDebugStubs()
{
    #undef  DBGEXWRAP
    #undef  DBGEXWRAP_
    #define DBGEXWRAP(ret, fn, formals, params) g_##fn = _##fn;
    #define DBGEXWRAP_(ret, fn, formals, params) g_##fn = _##fn;

    DBGEXFUNCTIONS()
}

void InitDebugLib(HANDLE hDllHandle, BOOL (WINAPI * pfnDllMain)(HANDLE, DWORD, LPVOID))
{
    g_hInstDbg = LoadLibraryA("mshtmdbg.dll");

    if (g_hInstDbg == NULL)
    {
//        OutputDebugStringA("InitDebugLib: Can't find mshtmdbg.dll.  Only partial debug support available.\r\n");
        goto dostubs;
    }

    #undef  DBGEXWRAP
    #undef  DBGEXWRAP_
    #define DBGEXWRAP(ret, fn, formals, params) if (!InitDebugProcedure((void **)&g_##fn, #fn)) goto dostubs;
    #define DBGEXWRAP_(ret, fn, formals, params) if (!InitDebugProcedure((void **)&g_##fn, #fn)) goto dostubs;

    DBGEXFUNCTIONS()

    if (DbgExGetVersion() != MSHTMDBG_API_VERSION)
    {
        char ach[512];
        wsprintfA(ach, "InitDebugLib: Version mismatch for MSHTMDBG.DLL.  Expected %ld but found %ld.\r\n",
                  MSHTMDBG_API_VERSION, DbgExGetVersion());
        OutputDebugStringA(ach);
        FreeLibrary(g_hInstDbg);
        g_hInstDbg = NULL;
        goto dostubs;
    }
    else
    {
        DbgExSetDllMain(hDllHandle, pfnDllMain);
    }

    return;

dostubs:

    InitDebugStubs();
}

void TermDebugLib(HANDLE hDllHandle, BOOL fFinal)
{
    if (g_hInstDbg == NULL)
        return;

    if (fFinal)
    {
        FreeLibrary(g_hInstDbg);
        g_hInstDbg = NULL;
    }
    else
    {
        DbgExSetDllMain(hDllHandle, NULL);
    }
}

#ifdef __cplusplus
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\coredisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __COREDISP_H__
#define __COREDISP_H__
//;end_internal

//;begin_internal
//
// The following dispid must be the smallest possible dispid so that it
// always ends up first in our attr array.
// It does not need to be exposed to the outside world
#define DISPID_AAHEADER                 MINLONG             // DISPID is 0x80000000
#define DISPID_RECALC_INFO              MINLONG+1
//;end_internal


#define DISPID_XOBJ_MIN                 0x80010000
#define DISPID_XOBJ_MAX                 0x8001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN
#define DISPID_HTMLOBJECT               (DISPID_XOBJ_BASE   + 500)
#define DISPID_ELEMENT                  (DISPID_HTMLOBJECT  + 500)
#define DISPID_SITE                     (DISPID_ELEMENT     + 1000)
#define DISPID_OBJECT                   (DISPID_SITE        + 1000)
#define DISPID_STYLE                    (DISPID_OBJECT      + 1000)
#define DISPID_ATTRS                    (DISPID_STYLE       + 1000)
#define DISPID_EVENTS                   (DISPID_ATTRS       + 1000)
#define DISPID_XOBJ_EXPANDO             (DISPID_EVENTS      + 1000)
#define DISPID_XOBJ_ORDINAL             (DISPID_XOBJ_EXPANDO+ 1000)

//;begin_internal
// Expandos for ActiveX controls, note these are very limited compared to
// normal expandos on an element.

#define DISPID_ACTIVEX_EXPANDO_BASE      DISPID_XOBJ_EXPANDO
#define DISPID_ACTIVEX_EXPANDO_MAX       (DISPID_ACTIVEX_EXPANDO_BASE + 999)

#define DISPID_OBJECT_ORDINAL_BASE       DISPID_XOBJ_ORDINAL
#define DISPID_OBJECT_ORDINAL_MAX       (DISPID_OBJECT_ORDINAL_BASE + 999)

#define DISPID_COLLECTION_MIN           1000000
#define DISPID_COLLECTION_MAX           2999999

// Divide collection dispid space into "named member" half and "ordinal access" half
// for stylesheets collection.
#define DISPID_STYLESHEETSCOLLECTION_NAMED_BASE        (DISPID_COLLECTION_MIN)
#define DISPID_STYLESHEETSCOLLECTION_NAMED_MAX         (DISPID_COLLECTION_MIN+((DISPID_COLLECTION_MAX-DISPID_COLLECTION_MIN)/2))
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE      (DISPID_STYLESHEETSCOLLECTION_NAMED_MAX+1)
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX       (DISPID_COLLECTION_MAX)

// DISPID range for expandos not associated with an ActiveX control
#define DISPID_EXPANDO_BASE             3000000
#define DISPID_EXPANDO_MAX              3999999

#define IsStandardDispid(dispid)        (dispid <= 0)
#define IsExpandoDispid(dispid)         (DISPID_EXPANDO_BASE <= dispid && dispid <= DISPID_EXPANDO_MAX)

#define DISPID_EVENTHOOK_SENSITIVE_BASE   4000000
#define DISPID_EVENTHOOK_SENSITIVE_MAX    4499999
#define DISPID_EVENTHOOK_INSENSITIVE_BASE 4500000
#define DISPID_EVENTHOOK_INSENSITIVE_MAX  4999999

#define DISPID_PEER_HOLDER_BASE         5000000

#define IsPeerDispid(dispid)            (DISPID_PEER_HOLDER_BASE <= dispid)

//;end_internal

//;begin_internal
//
// IE 4 dispids that no longer exist
//
//;end_internal
#define DISPID_HTMLOPTIONBUTTONELEMENTEVENTS_ONCHANGE       DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONCHANGE

//;begin_internal
//
// Standard control properties
//
//;end_internal

//;begin_internal
//;QUESTION: rgardner - why do we use these names ???
//;end_internal
#define DISPID_CommonCtrl_FONTNAME        1
#define DISPID_CommonCtrl_FONTSIZE        2
#define DISPID_CommonCtrl_FONTBOLD        3
#define DISPID_CommonCtrl_FONTITAL        4
#define DISPID_CommonCtrl_FONTUNDER       5
#define DISPID_CommonCtrl_FONTSTRIKE      6
#define DISPID_CommonCtrl_FONTWEIGHT      7
#define DISPID_CommonCtrl_FONTCHARSET     8
#define DISPID_CommonCtrl_FONTSUPERSCRIPT 9
#define DISPID_CommonCtrl_FONTSUBSCRIPT   10

// Data Binding DISPID's
#define DISPID_MSDATASRCINTERFACE       (-3900)
#define DISPID_ADVISEDATASRCCHANGEEVENT (-3901)


//;begin_internal
// DISPID values for HTML Dialogs files per interface
//;end_internal

#define DISPID_HTMLDLG                          25000
#define DISPID_HTMLDLGMODEL                     26000

//;begin_internal
// DISPID values for HTML Popup files per interface
//;end_internal

#define DISPID_HTMLPOPUP                        27000

//;begin_internal
// DISPID values for HTML Application files per interface
//;end_internal

#define DISPID_HTMLAPP                          5000

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These values match those used by VB and are for the benefit of controls
//  with hard coded knowledge of VB.
//
//----------------------------------------------------------------------------
//;end_internal

#define STDPROPID_XOBJ_NAME                 (DISPID_XOBJ_BASE + 0x0)
#define STDPROPID_XOBJ_INDEX                (DISPID_XOBJ_BASE + 0x1)
//;begin_internal
// for IE3 compatibility

#define STDPROPID_IE3XOBJ_OBJECTALIGN     (DISPID_XOBJ_BASE + 0x1) 

// STDPROPID_XOBJ_BASEHREF is a constant used by IE3
//;end_internal
#define STDPROPID_XOBJ_BASEHREF             (DISPID_XOBJ_BASE + 0x2) 
#define STDPROPID_XOBJ_LEFT                 (DISPID_XOBJ_BASE + 0x3)
#define STDPROPID_XOBJ_TOP                  (DISPID_XOBJ_BASE + 0x4)
#define STDPROPID_XOBJ_WIDTH                (DISPID_XOBJ_BASE + 0x5)
#define STDPROPID_XOBJ_HEIGHT               (DISPID_XOBJ_BASE + 0x6)
#define STDPROPID_XOBJ_VISIBLE              (DISPID_XOBJ_BASE + 0x7)
#define STDPROPID_XOBJ_PARENT               (DISPID_XOBJ_BASE + 0x8)
#define STDPROPID_XOBJ_DRAGMODE             (DISPID_XOBJ_BASE + 0x9)
#define STDPROPID_XOBJ_DRAGICON             (DISPID_XOBJ_BASE + 0xA)
#define STDPROPID_XOBJ_TAG                  (DISPID_XOBJ_BASE + 0xB)
#define STDPROPID_XOBJ_TABSTOP              (DISPID_XOBJ_BASE + 0xE)
#define STDPROPID_XOBJ_TABINDEX             (DISPID_XOBJ_BASE + 0xF)
#define STDPROPID_XOBJ_HELPCONTEXTID        (DISPID_XOBJ_BASE + 0x32)
#define STDPROPID_XOBJ_DEFAULT              (DISPID_XOBJ_BASE + 0x37)
#define STDPROPID_XOBJ_CANCEL               (DISPID_XOBJ_BASE + 0x38)
#define STDPROPID_XOBJ_LEFTNORUN            (DISPID_XOBJ_BASE + 0x39)
#define STDPROPID_XOBJ_TOPNORUN             (DISPID_XOBJ_BASE + 0x3A)
#define STDPROPID_XOBJ_ALIGNPERSIST         (DISPID_XOBJ_BASE + 0x3C)
#define STDPROPID_XOBJ_LINKTIMEOUT          (DISPID_XOBJ_BASE + 0x3D)
#define STDPROPID_XOBJ_LINKTOPIC            (DISPID_XOBJ_BASE + 0x3E)
#define STDPROPID_XOBJ_LINKITEM             (DISPID_XOBJ_BASE + 0x3F)
#define STDPROPID_XOBJ_LINKMODE             (DISPID_XOBJ_BASE + 0x40)
#define STDPROPID_XOBJ_DATACHANGED          (DISPID_XOBJ_BASE + 0x41)
#define STDPROPID_XOBJ_DATAFIELD            (DISPID_XOBJ_BASE + 0x42)
#define STDPROPID_XOBJ_DATASOURCE           (DISPID_XOBJ_BASE + 0x43)
#define STDPROPID_XOBJ_WHATSTHISHELPID      (DISPID_XOBJ_BASE + 0x44)
#define STDPROPID_XOBJ_CONTROLTIPTEXT       (DISPID_XOBJ_BASE + 0x45)
#define STDPROPID_XOBJ_STATUSBARTEXT        (DISPID_XOBJ_BASE + 0x46)
#define STDPROPID_XOBJ_APPLICATION          (DISPID_XOBJ_BASE + 0x47)
#define STDPROPID_XOBJ_BLOCKALIGN           (DISPID_XOBJ_BASE + 0x48)
#define STDPROPID_XOBJ_CONTROLALIGN         (DISPID_XOBJ_BASE + 0x49)
#define STDPROPID_XOBJ_STYLE                (DISPID_XOBJ_BASE + 0x4A)
#define STDPROPID_XOBJ_COUNT                (DISPID_XOBJ_BASE + 0x4B)
#define STDPROPID_XOBJ_DISABLED             (DISPID_XOBJ_BASE + 0x4C)
#define STDPROPID_XOBJ_RIGHT                (DISPID_XOBJ_BASE + 0x4D)
#define STDPROPID_XOBJ_BOTTOM               (DISPID_XOBJ_BASE + 0x4E)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------
//;end_internal

#define STDDISPID_XOBJ_ONBLUR                           (DISPID_XOBJ_BASE)
#define STDDISPID_XOBJ_ONFOCUS                          (DISPID_XOBJ_BASE + 1)
#define STDDISPID_XOBJ_BEFOREUPDATE                     (DISPID_XOBJ_BASE + 4)
#define STDDISPID_XOBJ_AFTERUPDATE                      (DISPID_XOBJ_BASE + 5)
#define STDDISPID_XOBJ_ONROWEXIT                        (DISPID_XOBJ_BASE + 6)
#define STDDISPID_XOBJ_ONROWENTER                       (DISPID_XOBJ_BASE + 7)
#define STDDISPID_XOBJ_ONMOUSEOVER                      (DISPID_XOBJ_BASE + 8)
#define STDDISPID_XOBJ_ONMOUSEOUT                       (DISPID_XOBJ_BASE + 9)
#define STDDISPID_XOBJ_ONHELP                           (DISPID_XOBJ_BASE + 10)
#define STDDISPID_XOBJ_ONDRAGSTART                      (DISPID_XOBJ_BASE + 11)
#define STDDISPID_XOBJ_ONSELECTSTART                    (DISPID_XOBJ_BASE + 12)
#define STDDISPID_XOBJ_ERRORUPDATE                      (DISPID_XOBJ_BASE + 13)
#define STDDISPID_XOBJ_ONDATASETCHANGED                 (DISPID_XOBJ_BASE + 14)
#define STDDISPID_XOBJ_ONDATAAVAILABLE                  (DISPID_XOBJ_BASE + 15)
#define STDDISPID_XOBJ_ONDATASETCOMPLETE                (DISPID_XOBJ_BASE + 16)
#define STDDISPID_XOBJ_ONFILTER                         (DISPID_XOBJ_BASE + 17)
#define STDDISPID_XOBJ_ONLOSECAPTURE                    (DISPID_XOBJ_BASE + 18)
#define STDDISPID_XOBJ_ONPROPERTYCHANGE                 (DISPID_XOBJ_BASE + 19)
#define STDDISPID_XOBJ_ONDRAG                           (DISPID_XOBJ_BASE + 20)
#define STDDISPID_XOBJ_ONDRAGEND                        (DISPID_XOBJ_BASE + 21)
#define STDDISPID_XOBJ_ONDRAGENTER                      (DISPID_XOBJ_BASE + 22)
#define STDDISPID_XOBJ_ONDRAGOVER                       (DISPID_XOBJ_BASE + 23)
#define STDDISPID_XOBJ_ONDRAGLEAVE                      (DISPID_XOBJ_BASE + 24)
#define STDDISPID_XOBJ_ONDROP                           (DISPID_XOBJ_BASE + 25)
#define STDDISPID_XOBJ_ONCUT                            (DISPID_XOBJ_BASE + 26)
#define STDDISPID_XOBJ_ONCOPY                           (DISPID_XOBJ_BASE + 27)
#define STDDISPID_XOBJ_ONPASTE                          (DISPID_XOBJ_BASE + 28)
#define STDDISPID_XOBJ_ONBEFORECUT                      (DISPID_XOBJ_BASE + 29)
#define STDDISPID_XOBJ_ONBEFORECOPY                     (DISPID_XOBJ_BASE + 30)
#define STDDISPID_XOBJ_ONBEFOREPASTE                    (DISPID_XOBJ_BASE + 31)
#define STDDISPID_XOBJ_ONROWSDELETE                     (DISPID_XOBJ_BASE + 32)
#define STDDISPID_XOBJ_ONROWSINSERTED                   (DISPID_XOBJ_BASE + 33)
#define STDDISPID_XOBJ_ONCELLCHANGE                     (DISPID_XOBJ_BASE + 34)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Base DISPIDs for each class.
//
//  Object and its base classes must use ids in the reserved x-object range.
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_NORMAL_FIRST                     1000
#define DISPID_ANCHOR                           DISPID_NORMAL_FIRST
#define DISPID_BLOCK                            DISPID_NORMAL_FIRST
#define DISPID_BODY                             (DISPID_TEXTSITE + 1000)
#define DISPID_BR                               DISPID_NORMAL_FIRST
#define DISPID_BGSOUND                          DISPID_NORMAL_FIRST
#define DISPID_DD                               DISPID_NORMAL_FIRST
#define DISPID_DIR                              DISPID_NORMAL_FIRST
#define DISPID_DIV                              DISPID_NORMAL_FIRST
#define DISPID_DL                               DISPID_NORMAL_FIRST
#define DISPID_DT                               DISPID_NORMAL_FIRST
#define DISPID_EFONT                            DISPID_NORMAL_FIRST
#define DISPID_FORM                             DISPID_NORMAL_FIRST
#define DISPID_HEADER                           DISPID_NORMAL_FIRST
#define DISPID_HEDELEMS                         DISPID_NORMAL_FIRST
#define DISPID_HR                               DISPID_NORMAL_FIRST
#define DISPID_LABEL                            DISPID_NORMAL_FIRST
#define DISPID_LI                               DISPID_NORMAL_FIRST
#define DISPID_IMGBASE                          DISPID_NORMAL_FIRST
#define DISPID_IMG                              (DISPID_IMGBASE + 1000)
#define DISPID_INPUTIMAGE                       (DISPID_IMGBASE + 1000)
#define DISPID_INPUT                            (DISPID_TEXTSITE + 1000)
#define DISPID_INPUTTEXTBASE                    (DISPID_INPUT+1000)
#define DISPID_INPUTTEXT                        (DISPID_INPUTTEXTBASE+1000)
#define DISPID_MENU                             DISPID_NORMAL_FIRST
#define DISPID_OL                               DISPID_NORMAL_FIRST
#define DISPID_PARA                             DISPID_NORMAL_FIRST
#define DISPID_SELECT                           DISPID_NORMAL_FIRST
#define DISPID_SELECTOBJ                        DISPID_NORMAL_FIRST
#define DISPID_TABLE                            DISPID_NORMAL_FIRST
#define DISPID_TEXTSITE                         DISPID_NORMAL_FIRST
#define DISPID_TEXTAREA                         (DISPID_INPUTTEXT + 1000)
#define DISPID_MARQUEE                          (DISPID_TEXTAREA + 1000)
#define DISPID_RICHTEXT                         (DISPID_MARQUEE + 1000)
#define DISPID_BUTTON                           (DISPID_RICHTEXT + 1000)
#define DISPID_UL                               DISPID_NORMAL_FIRST
#define DISPID_PHRASE                           DISPID_NORMAL_FIRST
#define DISPID_UNKNOWNPDL                       DISPID_NORMAL_FIRST
#define DISPID_COMMENTPDL                       DISPID_NORMAL_FIRST
#define DISPID_TABLECELL                        (DISPID_TEXTSITE + 1000)
#define DISPID_RANGE                            DISPID_NORMAL_FIRST
#define DISPID_SELECTION                        DISPID_NORMAL_FIRST
#define DISPID_OPTION                           DISPID_NORMAL_FIRST
#define DISPID_1D                               (DISPID_TEXTSITE + 1000)
#define DISPID_MAP                              DISPID_NORMAL_FIRST
#define DISPID_AREA                             DISPID_NORMAL_FIRST
#define DISPID_PARAM                            DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_TABLEROW                         DISPID_NORMAL_FIRST
#define DISPID_TABLECOL                         DISPID_NORMAL_FIRST
#define DISPID_SCRIPT                           DISPID_NORMAL_FIRST
#define DISPID_STYLESHEET                       DISPID_NORMAL_FIRST
#define DISPID_STYLERULE                        DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGE                        DISPID_NORMAL_FIRST
#define DISPID_STYLESHEETS_COL                  DISPID_NORMAL_FIRST
#define DISPID_STYLERULES_COL                   DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGES_COL                   DISPID_NORMAL_FIRST
#define DISPID_MIMETYPES_COL                    DISPID_NORMAL_FIRST
#define DISPID_PLUGINS_COL                      DISPID_NORMAL_FIRST
#define DISPID_2D                               DISPID_NORMAL_FIRST
#define DISPID_OMWINDOW                         DISPID_NORMAL_FIRST
#define DISPID_EVENTOBJ                         DISPID_NORMAL_FIRST
#define DISPID_PERSISTDATA                      DISPID_NORMAL_FIRST
#define DISPID_OLESITE                          DISPID_NORMAL_FIRST
#define DISPID_FRAMESET                         DISPID_NORMAL_FIRST
#define DISPID_LINK                             DISPID_NORMAL_FIRST
#define DISPID_STYLEELEMENT                     DISPID_NORMAL_FIRST
#define DISPID_FILTERS                          DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_OMRECT                           DISPID_NORMAL_FIRST
#define DISPID_DOMATTRIBUTE                     DISPID_NORMAL_FIRST
#define DISPID_DOMTEXTNODE                      DISPID_NORMAL_FIRST
#define DISPID_GENERIC                          DISPID_NORMAL_FIRST
#define DISPID_URN_COLL                         DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE_COLLECTION             DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE                        DISPID_NORMAL_FIRST
#define DISPID_TAGNAMES_COLLECTION              DISPID_NORMAL_FIRST

#define DISPID_HTMLDOCUMENT                     DISPID_NORMAL_FIRST
#define DISPID_OMDOCUMENT                       DISPID_NORMAL_FIRST
#define DISPID_DATATRANSFER                     DISPID_NORMAL_FIRST
#define DISPID_XMLDECL                          DISPID_NORMAL_FIRST
#define DISPID_DOCFRAG                          DISPID_NORMAL_FIRST
#define DISPID_ILINEINFO                        DISPID_NORMAL_FIRST
#define DISPID_IHTMLCOMPUTEDSTYLE               DISPID_NORMAL_FIRST
//;begin_internal
    // Special case for compatability with IE4 -> therefore the 1:
//;end_internal
#define DISPID_WINDOW                           1
#define DISPID_SCREEN                           DISPID_NORMAL_FIRST
#define DISPID_FRAMESCOLLECTION                 DISPID_NORMAL_FIRST
#define DISPID_HISTORY                          1
#define DISPID_LOCATION                         1
#define DISPID_NAVIGATOR                        1
#define DISPID_COLLECTION                       (DISPID_NORMAL_FIRST+500)
#define DISPID_OPTIONS_COL                      (DISPID_NORMAL_FIRST+500)

#define DISPID_CHECKBOX                         DISPID_NORMAL_FIRST
#define DISPID_RADIO                            (DISPID_CHECKBOX + 1000)

#define DISPID_FRAMESITE                        (DISPID_SITE        + 1000)
#define DISPID_FRAME                            (DISPID_FRAMESITE   + 1000)
#define DISPID_IFRAME                           (DISPID_FRAMESITE   + 1000)

#define WEBOC_DISPIDBASE                        (DISPID_FRAMESITE   + 2000)
#define WEBOC_DISPIDMAX                         (WEBOC_DISPIDBASE   +  100)

#define DISPID_PROTECTEDELEMENT                 DISPID_NORMAL_FIRST
#define DISPID_DEFAULTS                         DISPID_NORMAL_FIRST
#define DISPID_MARKUP                           DISPID_NORMAL_FIRST
#define DISPID_DOMIMPLEMENTATION                DISPID_NORMAL_FIRST

//;begin_internal
//----------------------------------------------------------------------------
//
//  Reserved negative DISPIDs
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_WINDOWOBJECT                     (-5500)
#define DISPID_LOCATIONOBJECT                   (-5506)
#define DISPID_HISTORYOBJECT                    (-5507)
#define DISPID_NAVIGATOROBJECT                  (-5508)
#define DISPID_SECURITYCTX                      (-5511)
#define DISPID_AMBIENT_DLCONTROL                (-5512)
#define DISPID_AMBIENT_USERAGENT                (-5513)
#define DISPID_SECURITYDOMAIN                   (-5514)
//;begin_internal
#define DISPID_DEBUG_ISSECUREPROXY              (-5515)
#define DISPID_DEBUG_TRUSTEDPROXY               (-5516)
#define DISPID_DEBUG_INTERNALWINDOW             (-5517)
#define DISPID_DEBUG_ENABLESECUREPROXYASSERTS   (-5518)
//;end_internal
#define DLCTL_DLIMAGES                          0x00000010
#define DLCTL_VIDEOS                            0x00000020
#define DLCTL_BGSOUNDS                          0x00000040
#define DLCTL_NO_SCRIPTS                        0x00000080
#define DLCTL_NO_JAVA                           0x00000100
#define DLCTL_NO_RUNACTIVEXCTLS                 0x00000200
#define DLCTL_NO_DLACTIVEXCTLS                  0x00000400
#define DLCTL_DOWNLOADONLY                      0x00000800
#define DLCTL_NO_FRAMEDOWNLOAD                  0x00001000
#define DLCTL_RESYNCHRONIZE                     0x00002000
#define DLCTL_PRAGMA_NO_CACHE                   0x00004000
#define DLCTL_NO_BEHAVIORS                      0x00008000
#define DLCTL_NO_METACHARSET                    0x00010000
#define DLCTL_URL_ENCODING_DISABLE_UTF8         0x00020000
#define DLCTL_URL_ENCODING_ENABLE_UTF8          0x00040000
#define DLCTL_NOFRAMES                          0x00080000
#define DLCTL_FORCEOFFLINE                      0x10000000
#define DLCTL_NO_CLIENTPULL                     0x20000000
#define DLCTL_SILENT                            0x40000000
#define DLCTL_OFFLINEIFNOTCONNECTED             0x80000000
#define DLCTL_OFFLINE                           DLCTL_OFFLINEIFNOTCONNECTED

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each non xobject event
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_ONABORT                          (DISPID_NORMAL_FIRST)
#define DISPID_ONCHANGE                         (DISPID_NORMAL_FIRST + 1)
#define DISPID_ONERROR                          (DISPID_NORMAL_FIRST + 2)
#define DISPID_ONLOAD                           (DISPID_NORMAL_FIRST + 3)
#define DISPID_ONSELECT                         (DISPID_NORMAL_FIRST + 6)
#define DISPID_ONSUBMIT                         (DISPID_NORMAL_FIRST + 7)
#define DISPID_ONUNLOAD                         (DISPID_NORMAL_FIRST + 8)
#define DISPID_ONBOUNCE                         (DISPID_NORMAL_FIRST + 9)
#define DISPID_ONFINISH                         (DISPID_NORMAL_FIRST + 10)
#define DISPID_ONSTART                          (DISPID_NORMAL_FIRST + 11)
#define DISPID_ONLAYOUT                         (DISPID_NORMAL_FIRST + 13)
#define DISPID_ONSCROLL                         (DISPID_NORMAL_FIRST + 14)
#define DISPID_ONRESET                          (DISPID_NORMAL_FIRST + 15)
#define DISPID_ONRESIZE                         (DISPID_NORMAL_FIRST + 16)
#define DISPID_ONBEFOREUNLOAD                   (DISPID_NORMAL_FIRST + 17)
#define DISPID_ONCHANGEFOCUS                    (DISPID_NORMAL_FIRST + 18)
#define DISPID_ONCHANGEBLUR                     (DISPID_NORMAL_FIRST + 19)
#define DISPID_ONPERSIST                        (DISPID_NORMAL_FIRST + 20)
#define DISPID_ONPERSISTSAVE                    (DISPID_NORMAL_FIRST + 21)
#define DISPID_ONPERSISTLOAD                    (DISPID_NORMAL_FIRST + 22)
#define DISPID_ONCONTEXTMENU                    (DISPID_NORMAL_FIRST + 23)
#define DISPID_ONBEFOREPRINT                    (DISPID_NORMAL_FIRST + 24)
#define DISPID_ONAFTERPRINT                     (DISPID_NORMAL_FIRST + 25)
#define DISPID_ONSTOP                           (DISPID_NORMAL_FIRST + 26)
#define DISPID_ONBEFOREEDITFOCUS                (DISPID_NORMAL_FIRST + 27)
#define DISPID_ONMOUSEHOVER                     (DISPID_NORMAL_FIRST + 28)
#define DISPID_ONCONTENTREADY                   (DISPID_NORMAL_FIRST + 29)
#define DISPID_ONLAYOUTCOMPLETE                 (DISPID_NORMAL_FIRST + 30)
#define DISPID_ONPAGE                           (DISPID_NORMAL_FIRST + 31)
#define DISPID_ONLINKEDOVERFLOW                 (DISPID_NORMAL_FIRST + 32)
#define DISPID_ONMOUSEWHEEL                     (DISPID_NORMAL_FIRST + 33)
#define DISPID_ONBEFOREDEACTIVATE               (DISPID_NORMAL_FIRST + 34)
#define DISPID_ONMOVE                           (DISPID_NORMAL_FIRST + 35)
#define DISPID_ONCONTROLSELECT                  (DISPID_NORMAL_FIRST + 36)
#define DISPID_ONSELECTIONCHANGE                (DISPID_NORMAL_FIRST + 37)
#define DISPID_ONMOVESTART                      (DISPID_NORMAL_FIRST + 38)
#define DISPID_ONMOVEEND                        (DISPID_NORMAL_FIRST + 39)
#define DISPID_ONRESIZESTART                    (DISPID_NORMAL_FIRST + 40)
#define DISPID_ONRESIZEEND                      (DISPID_NORMAL_FIRST + 41)
#define DISPID_ONMOUSEENTER                     (DISPID_NORMAL_FIRST + 42)
#define DISPID_ONMOUSELEAVE                     (DISPID_NORMAL_FIRST + 43)
#define DISPID_ONACTIVATE                       (DISPID_NORMAL_FIRST + 44)
#define DISPID_ONDEACTIVATE                     (DISPID_NORMAL_FIRST + 45)
#define DISPID_ONMULTILAYOUTCLEANUP             (DISPID_NORMAL_FIRST + 46)
#define DISPID_ONBEFOREACTIVATE                 (DISPID_NORMAL_FIRST + 47)
#define DISPID_ONFOCUSIN                        (DISPID_NORMAL_FIRST + 48)
#define DISPID_ONFOCUSOUT                       (DISPID_NORMAL_FIRST + 49)

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each unique HtmlAttribute/CssAttribute
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_A_FIRST                          DISPID_ATTRS
#define DISPID_A_MIN                            DISPID_ATTRS
#define DISPID_A_MAX                            (DISPID_ATTRS+999)

#define DISPID_A_BACKGROUNDIMAGE                (DISPID_A_FIRST+1)
#define DISPID_A_COLOR                          (DISPID_A_FIRST+2)
#define DISPID_A_TEXTTRANSFORM                  (DISPID_A_FIRST+4)
#define DISPID_A_NOWRAP                         (DISPID_A_FIRST+5)
#define DISPID_A_LINEHEIGHT                     (DISPID_A_FIRST+6)
#define DISPID_A_TEXTINDENT                     (DISPID_A_FIRST+7)
#define DISPID_A_LETTERSPACING                  (DISPID_A_FIRST+8)
#define DISPID_A_LANG                           (DISPID_A_FIRST+9)
#define DISPID_A_OVERFLOW                       (DISPID_A_FIRST+10)

#define DISPID_A_PADDING                        (DISPID_A_FIRST+11)
#define DISPID_A_PADDINGTOP                     (DISPID_A_FIRST+12)
#define DISPID_A_PADDINGRIGHT                   (DISPID_A_FIRST+13)
#define DISPID_A_PADDINGBOTTOM                  (DISPID_A_FIRST+14)
#define DISPID_A_PADDINGLEFT                    (DISPID_A_FIRST+15)

#define DISPID_A_CLEAR                          (DISPID_A_FIRST+16)
#define DISPID_A_LISTTYPE                       (DISPID_A_FIRST+17)
#define DISPID_A_FONTFACE                       (DISPID_A_FIRST+18)
#define DISPID_A_FONTSIZE                       (DISPID_A_FIRST+19)

#define DISPID_A_TEXTDECORATIONLINETHROUGH      (DISPID_A_FIRST+20)
#define DISPID_A_TEXTDECORATIONUNDERLINE        (DISPID_A_FIRST+21)
#define DISPID_A_TEXTDECORATIONBLINK            (DISPID_A_FIRST+22)
#define DISPID_A_TEXTDECORATIONNONE             (DISPID_A_FIRST+23)


#define DISPID_A_FONTSTYLE                      (DISPID_A_FIRST+24)
#define DISPID_A_FONTVARIANT                    (DISPID_A_FIRST+25)
#define DISPID_A_BASEFONT                       (DISPID_A_FIRST+26)
#define DISPID_A_FONTWEIGHT                     (DISPID_A_FIRST+27)

#define DISPID_A_TABLEBORDERCOLOR               (DISPID_A_FIRST+28)
#define DISPID_A_TABLEBORDERCOLORLIGHT          (DISPID_A_FIRST+29)
#define DISPID_A_TABLEBORDERCOLORDARK           (DISPID_A_FIRST+30)
#define DISPID_A_TABLEVALIGN                    (DISPID_A_FIRST+31)

#define DISPID_A_BACKGROUND                     (DISPID_A_FIRST+32)
#define DISPID_A_BACKGROUNDPOSX                 (DISPID_A_FIRST+33)
#define DISPID_A_BACKGROUNDPOSY                 (DISPID_A_FIRST+34)

#define DISPID_A_TEXTDECORATION                 (DISPID_A_FIRST+35)

#define DISPID_A_MARGIN                         (DISPID_A_FIRST+36)
#define DISPID_A_MARGINTOP                      (DISPID_A_FIRST+37)
#define DISPID_A_MARGINRIGHT                    (DISPID_A_FIRST+38)
#define DISPID_A_MARGINBOTTOM                   (DISPID_A_FIRST+39)
#define DISPID_A_MARGINLEFT                     (DISPID_A_FIRST+40)

#define DISPID_A_FONT                           (DISPID_A_FIRST+41)
#define DISPID_A_FONTSIZEKEYWORD                (DISPID_A_FIRST+42)
#define DISPID_A_FONTSIZECOMBINE                (DISPID_A_FIRST+43)

#define DISPID_A_BACKGROUNDREPEAT               (DISPID_A_FIRST+44)
#define DISPID_A_BACKGROUNDATTACHMENT           (DISPID_A_FIRST+45)
#define DISPID_A_BACKGROUNDPOSITION             (DISPID_A_FIRST+46)
#define DISPID_A_WORDSPACING                    (DISPID_A_FIRST+47)
#define DISPID_A_VERTICALALIGN                  (DISPID_A_FIRST+48)
#define DISPID_A_BORDER                         (DISPID_A_FIRST+49)
#define DISPID_A_BORDERTOP                      (DISPID_A_FIRST+50)
#define DISPID_A_BORDERRIGHT                    (DISPID_A_FIRST+51)
#define DISPID_A_BORDERBOTTOM                   (DISPID_A_FIRST+52)
#define DISPID_A_BORDERLEFT                     (DISPID_A_FIRST+53)
#define DISPID_A_BORDERCOLOR                    (DISPID_A_FIRST+54)
#define DISPID_A_BORDERTOPCOLOR                 (DISPID_A_FIRST+55)
#define DISPID_A_BORDERRIGHTCOLOR               (DISPID_A_FIRST+56)
#define DISPID_A_BORDERBOTTOMCOLOR              (DISPID_A_FIRST+57)
#define DISPID_A_BORDERLEFTCOLOR                (DISPID_A_FIRST+58)
#define DISPID_A_BORDERWIDTH                    (DISPID_A_FIRST+59)
#define DISPID_A_BORDERTOPWIDTH                 (DISPID_A_FIRST+60)
#define DISPID_A_BORDERRIGHTWIDTH               (DISPID_A_FIRST+61)
#define DISPID_A_BORDERBOTTOMWIDTH              (DISPID_A_FIRST+62)
#define DISPID_A_BORDERLEFTWIDTH                (DISPID_A_FIRST+63)
#define DISPID_A_BORDERSTYLE                    (DISPID_A_FIRST+64)
#define DISPID_A_BORDERTOPSTYLE                 (DISPID_A_FIRST+65)
#define DISPID_A_BORDERRIGHTSTYLE               (DISPID_A_FIRST+66)
#define DISPID_A_BORDERBOTTOMSTYLE              (DISPID_A_FIRST+67)
#define DISPID_A_BORDERLEFTSTYLE                (DISPID_A_FIRST+68)
#define DISPID_A_TEXTDECORATIONOVERLINE         (DISPID_A_FIRST+69)
#define DISPID_A_FLOAT                          (DISPID_A_FIRST+70)
#define DISPID_A_DISPLAY                        (DISPID_A_FIRST+71)
#define DISPID_A_LISTSTYLETYPE                  (DISPID_A_FIRST+72)
#define DISPID_A_LISTSTYLEPOSITION              (DISPID_A_FIRST+73)
#define DISPID_A_LISTSTYLEIMAGE                 (DISPID_A_FIRST+74)
#define DISPID_A_LISTSTYLE                      (DISPID_A_FIRST+75)
#define DISPID_A_WHITESPACE                     (DISPID_A_FIRST+76)
#define DISPID_A_PAGEBREAKBEFORE                (DISPID_A_FIRST+77)
#define DISPID_A_PAGEBREAKAFTER                 (DISPID_A_FIRST+78)
#define DISPID_A_SCROLL                         (DISPID_A_FIRST+79)
#define DISPID_A_VISIBILITY                     (DISPID_A_FIRST+80)
//;begin_internal
// This dispid is available
#define DISPID_A_HIDDEN                         (DISPID_A_FIRST+81)
//;end_internal
#define DISPID_A_FILTER                         (DISPID_A_FIRST+82)

#define DISPID_DEFAULTVALUE                     (DISPID_A_FIRST+83)

#define DISPID_A_BORDERCOLLAPSE                 (DISPID_A_FIRST+84)

#define DISPID_A_POSITION                       (DISPID_A_FIRST+90)
#define DISPID_A_ZINDEX                         (DISPID_A_FIRST+91)
#define DISPID_A_CLIP                           (DISPID_A_FIRST+92)
#define DISPID_A_CLIPRECTTOP                    (DISPID_A_FIRST+93)
#define DISPID_A_CLIPRECTRIGHT                  (DISPID_A_FIRST+94)
#define DISPID_A_CLIPRECTBOTTOM                 (DISPID_A_FIRST+95)
#define DISPID_A_CLIPRECTLEFT                   (DISPID_A_FIRST+96)

#define DISPID_A_FONTFACESRC                    (DISPID_A_FIRST+97)
#define DISPID_A_TABLELAYOUT                    (DISPID_A_FIRST+98)

//;begin_internal
// The style as a text string
//;end_internal
#define DISPID_A_STYLETEXT                      (DISPID_A_FIRST+99)

//;begin_internal
// Known attributes that have special meaning
//;end_internal
#define DISPID_A_LANGUAGE                       (DISPID_A_FIRST+100)

#define DISPID_A_VALUE                          (DISPID_A_FIRST+101)
#define DISPID_A_CURSOR                         (DISPID_A_FIRST+102)


//;begin_internal
//+-----------------------------------------------------------------------
//  A couple of dispids that are used internally for firing
//  events and prop notifies.
// Keep all the internal dispid's together, otherwise we'll trip up 

#define DISPID_A_EVENTSINK                      (DISPID_A_FIRST+103)
#define DISPID_A_PROPNOTIFYSINK                 (DISPID_A_FIRST+104)
#define DISPID_A_ROWSETNOTIFYSINK               (DISPID_A_FIRST+105)
#define DISPID_INTERNAL_INLINESTYLEAA           (DISPID_A_FIRST+106) // In line style Attr Array
#define DISPID_INTERNAL_CSTYLEPTRCACHE          (DISPID_A_FIRST+107) // Cached CStyle Ptr
#define DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE   (DISPID_A_FIRST+108) // runtime style ptr obj
#define DISPID_INTERNAL_INVOKECONTEXT           (DISPID_A_FIRST+109) // Cached Invoke context

#define DISPID_A_BGURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+110)
#define DISPID_A_LIURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+111)
#define DISPID_A_ROWSETASYNCHNOTIFYSINK         (DISPID_A_FIRST+112)
#define DISPID_INTERNAL_FILTERPTRCACHE          (DISPID_A_FIRST+113) // FilterCollection in AttrArray
#define DISPID_A_ROWPOSITIONCHANGESINK          (DISPID_A_FIRST+114)
//;end_internal

#define DISPID_A_BEHAVIOR                       (DISPID_A_FIRST+115) // xtags
#define DISPID_A_READYSTATE                     (DISPID_A_FIRST+116) // ready state

#define DISPID_A_DIR                            (DISPID_A_FIRST+117) // Complex Text support for bidi
#define DISPID_A_UNICODEBIDI                    (DISPID_A_FIRST+118) // Complex Text support for CSS2 unicode-bidi
#define DISPID_A_DIRECTION                      (DISPID_A_FIRST+119) // Complex Text support for CSS2 direction

#define DISPID_A_IMEMODE                        (DISPID_A_FIRST+120) 

#define DISPID_A_RUBYALIGN                      (DISPID_A_FIRST+121)
#define DISPID_A_RUBYPOSITION                   (DISPID_A_FIRST+122)
#define DISPID_A_RUBYOVERHANG                   (DISPID_A_FIRST+123)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY  (DISPID_A_FIRST+124)
#define DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY (DISPID_A_FIRST+125)
#define DISPID_INTERNAL_CDOMCHILDRENPTRCACHE     (DISPID_A_FIRST+126)
//;end_internal

#define DISPID_A_LAYOUTGRIDCHAR                 (DISPID_A_FIRST+127)
#define DISPID_A_LAYOUTGRIDLINE                 (DISPID_A_FIRST+128)
#define DISPID_A_LAYOUTGRIDMODE                 (DISPID_A_FIRST+129)
#define DISPID_A_LAYOUTGRIDTYPE                 (DISPID_A_FIRST+130)
#define DISPID_A_LAYOUTGRID                     (DISPID_A_FIRST+131)

#define DISPID_A_TEXTAUTOSPACE                  (DISPID_A_FIRST+132)

#define DISPID_A_LINEBREAK                      (DISPID_A_FIRST+133)
#define DISPID_A_WORDBREAK                      (DISPID_A_FIRST+134)

#define DISPID_A_TEXTJUSTIFY                    (DISPID_A_FIRST+135)
#define DISPID_A_TEXTJUSTIFYTRIM                (DISPID_A_FIRST+136)
#define DISPID_A_TEXTKASHIDA                    (DISPID_A_FIRST+137)

#define DISPID_A_OVERFLOWX                      (DISPID_A_FIRST+139)
#define DISPID_A_OVERFLOWY                      (DISPID_A_FIRST+140)

#define DISPID_A_HTCDISPATCHITEM_VALUE          (DISPID_A_FIRST+141)
#define DISPID_A_DOCFRAGMENT                    (DISPID_A_FIRST+142)

#define DISPID_A_HTCDD_ELEMENT                  (DISPID_A_FIRST+143)
#define DISPID_A_HTCDD_CREATEEVENTOBJECT        (DISPID_A_FIRST+144)

#define DISPID_A_URNATOM                        (DISPID_A_FIRST+145)
#define DISPID_A_UNIQUEPEERNUMBER               (DISPID_A_FIRST+146)

#define DISPID_A_ACCELERATOR                    (DISPID_A_FIRST+147)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE       (DISPID_A_FIRST+148)
#define DISPID_INTERNAL_RUNTIMESTYLEAA              (DISPID_A_FIRST+149)
#define DISPID_A_HTCDISPATCHITEM_VALUE_SCRIPTSONLY  (DISPID_A_FIRST+150)
//;end_internal

#define DISPID_A_EXTENDEDTAGDESC                (DISPID_A_FIRST+151)

#define DISPID_A_ROTATE                         (DISPID_A_FIRST+152)
#define DISPID_A_ZOOM                           (DISPID_A_FIRST+153)

#define DISPID_A_HTCDD_PROTECTEDELEMENT         (DISPID_A_FIRST+154)
#define DISPID_A_LAYOUTFLOW                     (DISPID_A_FIRST+155)
// DISPID_A_FIRST+156 unused -- removing 'rectangular'
// #define DISPID_A_RECTANGULAR                    (DISPID_A_FIRST+156)

#define DISPID_A_HTCDD_ISMARKUPSHARED           (DISPID_A_FIRST+157)
#define DISPID_A_WORDWRAP                       (DISPID_A_FIRST+158)
#define DISPID_A_TEXTUNDERLINEPOSITION          (DISPID_A_FIRST+159)
#define DISPID_A_HASLAYOUT                      (DISPID_A_FIRST+160)
#define DISPID_A_MEDIA                          (DISPID_A_FIRST+161)
#define DISPID_A_EDITABLE                       (DISPID_A_FIRST+162)
#define DISPID_A_HIDEFOCUS                      (DISPID_A_FIRST+163)

//;begin_internal
#define DISPID_INTERNAL_LAYOUTRECTREGISTRYPTRCACHE  (DISPID_A_FIRST+164)
//;end_internal

#define DISPID_A_HTCDD_DEFAULTS                 (DISPID_A_FIRST+165)

#define DISPID_A_TEXTLINETHROUGHSTYLE           (DISPID_A_FIRST+166)
#define DISPID_A_TEXTUNDERLINESTYLE             (DISPID_A_FIRST+167)
#define DISPID_A_TEXTEFFECT                     (DISPID_A_FIRST+168)
#define DISPID_A_TEXTBACKGROUNDCOLOR            (DISPID_A_FIRST+169)
#define DISPID_A_RENDERINGPRIORITY              (DISPID_A_FIRST+170)

//;begin_internal
#define DISPID_INTERNAL_DWNPOSTPTRCACHE             (DISPID_A_FIRST+171)
#define DISPID_INTERNAL_CODEPAGESETTINGSPTRCACHE    (DISPID_A_FIRST+172)
#define DISPID_INTERNAL_DWNDOCPTRCACHE              (DISPID_A_FIRST+173)
#define DISPID_INTERNAL_DATABINDTASKPTRCACHE        (DISPID_A_FIRST+174)
#define DISPID_INTERNAL_URLLOCATIONCACHE            (DISPID_A_FIRST+175)
#define DISPID_INTERNAL_ARYELEMENTRELEASENOTIFYPTRCACHE (DISPID_A_FIRST+176)
#define DISPID_INTERNAL_PEERFACTORYURLMAPPTRCACHE   (DISPID_A_FIRST+177)
#define DISPID_INTERNAL_STMDIRTYPTRCACHE            (DISPID_A_FIRST+178)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_COMPUTEFORMATSTATECACHE     (DISPID_A_FIRST+179)
//;end_internal

//
#define DISPID_A_SCROLLBARBASECOLOR             (DISPID_A_FIRST+180)
#define DISPID_A_SCROLLBARFACECOLOR             (DISPID_A_FIRST+181)
#define DISPID_A_SCROLLBAR3DLIGHTCOLOR          (DISPID_A_FIRST+182)
#define DISPID_A_SCROLLBARSHADOWCOLOR           (DISPID_A_FIRST+183)
#define DISPID_A_SCROLLBARHIGHLIGHTCOLOR        (DISPID_A_FIRST+184)
#define DISPID_A_SCROLLBARDARKSHADOWCOLOR       (DISPID_A_FIRST+185)
#define DISPID_A_SCROLLBARARROWCOLOR            (DISPID_A_FIRST+186)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE  (DISPID_A_FIRST+187)
//;end_internal

#define DISPID_A_DEFAULTTEXTSELECTION           (DISPID_A_FIRST+188)
#define DISPID_A_TEXTDECORATIONCOLOR            (DISPID_A_FIRST+189)
#define DISPID_A_TEXTCOLOR                      (DISPID_A_FIRST+190)
#define DISPID_A_STYLETEXTDECORATION            (DISPID_A_FIRST+191)

#define DISPID_A_WRITINGMODE                    (DISPID_A_FIRST+192)

//;begin_internal
#define DISPID_INTERNAL_MEDIA_REFERENCE         (DISPID_A_FIRST+193)
#define DISPID_INTERNAL_GENERICCOMPLUSREF       (DISPID_A_FIRST+194)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_FOCUSITEMS              (DISPID_A_FIRST+195)
//;end_internal

#define DISPID_A_SCROLLBARTRACKCOLOR            (DISPID_A_FIRST+196)

//;begin_internal
#define DISPID_INTERNAL_DWNHEADERCACHE          (DISPID_A_FIRST+197)
//;end_internal

#define DISPID_A_FROZEN                         (DISPID_A_FIRST+198)
#define DISPID_A_VIEWINHERITSTYLE               (DISPID_A_FIRST+199)

//;begin_internal
#define DISPID_INTERNAL_FRAMESCOLLECTION        (DISPID_A_FIRST+200)
//;end_internal

//;begin_internal
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE    (DISPID_A_FIRST+201)
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER  (DISPID_A_FIRST+202)
//;end_internal

#define DISPID_A_TEXTALIGNLAST                  (DISPID_A_FIRST+203)
#define DISPID_A_TEXTKASHIDASPACE               (DISPID_A_FIRST+204)

//;begin_internal
#define DISPID_INTERNAL_FONTHISTORYINDEX        (DISPID_A_FIRST+205)
//;end_internal

#define DISPID_A_ALLOWTRANSPARENCY              (DISPID_A_FIRST+206)

#define DISPID_INTERNAL_URLSEARCHCACHE          (DISPID_A_FIRST+207)

#define DISPID_A_ISBLOCK                        (DISPID_A_FIRST+208)

#define DISPID_A_TEXTOVERFLOW                   (DISPID_A_FIRST+209)

//;begin_internal
#define DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE  (DISPID_A_FIRST+210)
//;end_internal

#define DISPID_A_MINHEIGHT                      (DISPID_A_FIRST+211)

//;begin_internal
//------------------------------------------------------------------------
//
//  Event property and method dispids
//
//------------------------------------------------------------------------
//;end_internal

#define DISPID_EVPROP_ONMOUSEOVER           (DISPID_EVENTS +  0)
#define DISPID_EVMETH_ONMOUSEOVER            STDDISPID_XOBJ_ONMOUSEOVER
#define DISPID_EVPROP_ONMOUSEOUT            (DISPID_EVENTS +  1)
#define DISPID_EVMETH_ONMOUSEOUT             STDDISPID_XOBJ_ONMOUSEOUT
#define DISPID_EVPROP_ONMOUSEDOWN           (DISPID_EVENTS +  2)
#define DISPID_EVMETH_ONMOUSEDOWN            DISPID_MOUSEDOWN
#define DISPID_EVPROP_ONMOUSEUP             (DISPID_EVENTS +  3)
#define DISPID_EVMETH_ONMOUSEUP              DISPID_MOUSEUP
#define DISPID_EVPROP_ONMOUSEMOVE           (DISPID_EVENTS +  4)
#define DISPID_EVMETH_ONMOUSEMOVE            DISPID_MOUSEMOVE
#define DISPID_EVPROP_ONKEYDOWN             (DISPID_EVENTS +  5)
#define DISPID_EVMETH_ONKEYDOWN              DISPID_KEYDOWN
#define DISPID_EVPROP_ONKEYUP               (DISPID_EVENTS +  6)
#define DISPID_EVMETH_ONKEYUP                DISPID_KEYUP
#define DISPID_EVPROP_ONKEYPRESS            (DISPID_EVENTS +  7)
#define DISPID_EVMETH_ONKEYPRESS             DISPID_KEYPRESS
#define DISPID_EVPROP_ONCLICK               (DISPID_EVENTS +  8)
#define DISPID_EVMETH_ONCLICK                DISPID_CLICK
#define DISPID_EVPROP_ONDBLCLICK            (DISPID_EVENTS +  9)
#define DISPID_EVMETH_ONDBLCLICK             DISPID_DBLCLICK
#define DISPID_EVPROP_ONSELECT              (DISPID_EVENTS + 10)
#define DISPID_EVMETH_ONSELECT               DISPID_ONSELECT
#define DISPID_EVPROP_ONSUBMIT              (DISPID_EVENTS + 11)
#define DISPID_EVMETH_ONSUBMIT               DISPID_ONSUBMIT
#define DISPID_EVPROP_ONRESET               (DISPID_EVENTS + 12)
#define DISPID_EVMETH_ONRESET                DISPID_ONRESET
#define DISPID_EVPROP_ONHELP                (DISPID_EVENTS + 13)
#define DISPID_EVMETH_ONHELP                 STDDISPID_XOBJ_ONHELP
#define DISPID_EVPROP_ONFOCUS               (DISPID_EVENTS + 14)
#define DISPID_EVMETH_ONFOCUS                STDDISPID_XOBJ_ONFOCUS
#define DISPID_EVPROP_ONBLUR                (DISPID_EVENTS + 15)
#define DISPID_EVMETH_ONBLUR                 STDDISPID_XOBJ_ONBLUR
#define DISPID_EVPROP_ONROWEXIT             (DISPID_EVENTS + 18)
#define DISPID_EVMETH_ONROWEXIT              STDDISPID_XOBJ_ONROWEXIT
#define DISPID_EVPROP_ONROWENTER            (DISPID_EVENTS + 19)
#define DISPID_EVMETH_ONROWENTER             STDDISPID_XOBJ_ONROWENTER
#define DISPID_EVPROP_ONBOUNCE              (DISPID_EVENTS + 20)
#define DISPID_EVMETH_ONBOUNCE               DISPID_ONBOUNCE
#define DISPID_EVPROP_ONBEFOREUPDATE        (DISPID_EVENTS + 21)
#define DISPID_EVMETH_ONBEFOREUPDATE         STDDISPID_XOBJ_BEFOREUPDATE
#define DISPID_EVPROP_ONAFTERUPDATE         (DISPID_EVENTS + 22)
#define DISPID_EVMETH_ONAFTERUPDATE          STDDISPID_XOBJ_AFTERUPDATE
#define DISPID_EVPROP_ONBEFOREDRAGOVER      (DISPID_EVENTS + 23)
#define DISPID_EVMETH_ONBEFOREDRAGOVER       EVENTID_CommonCtrlEvent_BeforeDragOver
#define DISPID_EVPROP_ONBEFOREDROPORPASTE   (DISPID_EVENTS + 24)
#define DISPID_EVMETH_ONBEFOREDROPORPASTE    EVENTID_CommonCtrlEvent_BeforeDropOrPaste
#define DISPID_EVPROP_ONREADYSTATECHANGE    (DISPID_EVENTS + 25)
#define DISPID_EVMETH_ONREADYSTATECHANGE     DISPID_READYSTATECHANGE
#define DISPID_EVPROP_ONFINISH              (DISPID_EVENTS + 26)
#define DISPID_EVMETH_ONFINISH               DISPID_ONFINISH
#define DISPID_EVPROP_ONSTART               (DISPID_EVENTS + 27)
#define DISPID_EVMETH_ONSTART                DISPID_ONSTART
#define DISPID_EVPROP_ONABORT               (DISPID_EVENTS + 28)
#define DISPID_EVMETH_ONABORT                DISPID_ONABORT
#define DISPID_EVPROP_ONERROR               (DISPID_EVENTS + 29)
#define DISPID_EVMETH_ONERROR                DISPID_ONERROR
#define DISPID_EVPROP_ONCHANGE              (DISPID_EVENTS + 30)
#define DISPID_EVMETH_ONCHANGE               DISPID_ONCHANGE
#define DISPID_EVPROP_ONSCROLL              (DISPID_EVENTS + 31)
#define DISPID_EVMETH_ONSCROLL               DISPID_ONSCROLL
#define DISPID_EVPROP_ONLOAD                (DISPID_EVENTS + 32)
#define DISPID_EVMETH_ONLOAD                 DISPID_ONLOAD
#define DISPID_EVPROP_ONUNLOAD              (DISPID_EVENTS + 33)
#define DISPID_EVMETH_ONUNLOAD               DISPID_ONUNLOAD
#define DISPID_EVPROP_ONLAYOUT              (DISPID_EVENTS + 34)
#define DISPID_EVMETH_ONLAYOUT               DISPID_ONLAYOUT
#define DISPID_EVPROP_ONDRAGSTART           (DISPID_EVENTS + 35)
#define DISPID_EVMETH_ONDRAGSTART            STDDISPID_XOBJ_ONDRAGSTART
#define DISPID_EVPROP_ONRESIZE              (DISPID_EVENTS + 36)
#define DISPID_EVMETH_ONRESIZE               DISPID_ONRESIZE
#define DISPID_EVPROP_ONSELECTSTART         (DISPID_EVENTS + 37)
#define DISPID_EVMETH_ONSELECTSTART          STDDISPID_XOBJ_ONSELECTSTART
#define DISPID_EVPROP_ONERRORUPDATE         (DISPID_EVENTS + 38)
#define DISPID_EVMETH_ONERRORUPDATE          STDDISPID_XOBJ_ERRORUPDATE
#define DISPID_EVPROP_ONBEFOREUNLOAD        (DISPID_EVENTS + 39)
#define DISPID_EVMETH_ONBEFOREUNLOAD         DISPID_ONBEFOREUNLOAD
#define DISPID_EVPROP_ONDATASETCHANGED      (DISPID_EVENTS + 40)
#define DISPID_EVMETH_ONDATASETCHANGED       STDDISPID_XOBJ_ONDATASETCHANGED
#define DISPID_EVPROP_ONDATAAVAILABLE       (DISPID_EVENTS + 41)
#define DISPID_EVMETH_ONDATAAVAILABLE        STDDISPID_XOBJ_ONDATAAVAILABLE
#define DISPID_EVPROP_ONDATASETCOMPLETE     (DISPID_EVENTS + 42)
#define DISPID_EVMETH_ONDATASETCOMPLETE      STDDISPID_XOBJ_ONDATASETCOMPLETE
#define DISPID_EVPROP_ONFILTER              (DISPID_EVENTS + 43)
#define DISPID_EVMETH_ONFILTER               STDDISPID_XOBJ_ONFILTER
#define DISPID_EVPROP_ONCHANGEFOCUS         (DISPID_EVENTS + 44)
#define DISPID_EVMETH_ONCHANGEFOCUS          DISPID_ONCHANGEFOCUS
#define DISPID_EVPROP_ONCHANGEBLUR          (DISPID_EVENTS + 45)
#define DISPID_EVMETH_ONCHANGEBLUR           DISPID_ONCHANGEBLUR
#define DISPID_EVPROP_ONLOSECAPTURE         (DISPID_EVENTS + 46)
#define DISPID_EVMETH_ONLOSECAPTURE          STDDISPID_XOBJ_ONLOSECAPTURE
#define DISPID_EVPROP_ONPROPERTYCHANGE      (DISPID_EVENTS + 47)
#define DISPID_EVMETH_ONPROPERTYCHANGE       STDDISPID_XOBJ_ONPROPERTYCHANGE
#define DISPID_EVPROP_ONPERSISTSAVE         (DISPID_EVENTS + 48)
#define DISPID_EVMETH_ONPERSISTSAVE          DISPID_ONPERSISTSAVE
#define DISPID_EVPROP_ONDRAG                (DISPID_EVENTS + 49)
#define DISPID_EVMETH_ONDRAG                 STDDISPID_XOBJ_ONDRAG
#define DISPID_EVPROP_ONDRAGEND             (DISPID_EVENTS + 50)
#define DISPID_EVMETH_ONDRAGEND              STDDISPID_XOBJ_ONDRAGEND
#define DISPID_EVPROP_ONDRAGENTER           (DISPID_EVENTS + 51)
#define DISPID_EVMETH_ONDRAGENTER            STDDISPID_XOBJ_ONDRAGENTER
#define DISPID_EVPROP_ONDRAGOVER            (DISPID_EVENTS + 52)
#define DISPID_EVMETH_ONDRAGOVER             STDDISPID_XOBJ_ONDRAGOVER
#define DISPID_EVPROP_ONDRAGLEAVE           (DISPID_EVENTS + 53)
#define DISPID_EVMETH_ONDRAGLEAVE            STDDISPID_XOBJ_ONDRAGLEAVE
#define DISPID_EVPROP_ONDROP                (DISPID_EVENTS + 54)
#define DISPID_EVMETH_ONDROP                 STDDISPID_XOBJ_ONDROP
#define DISPID_EVPROP_ONCUT                 (DISPID_EVENTS + 55)
#define DISPID_EVMETH_ONCUT                  STDDISPID_XOBJ_ONCUT
#define DISPID_EVPROP_ONCOPY                (DISPID_EVENTS + 56)
#define DISPID_EVMETH_ONCOPY                 STDDISPID_XOBJ_ONCOPY
#define DISPID_EVPROP_ONPASTE               (DISPID_EVENTS + 57)
#define DISPID_EVMETH_ONPASTE                STDDISPID_XOBJ_ONPASTE
#define DISPID_EVPROP_ONBEFORECUT           (DISPID_EVENTS + 58)
#define DISPID_EVMETH_ONBEFORECUT            STDDISPID_XOBJ_ONBEFORECUT
#define DISPID_EVPROP_ONBEFORECOPY          (DISPID_EVENTS + 59)
#define DISPID_EVMETH_ONBEFORECOPY           STDDISPID_XOBJ_ONBEFORECOPY
#define DISPID_EVPROP_ONBEFOREPASTE         (DISPID_EVENTS + 60)
#define DISPID_EVMETH_ONBEFOREPASTE          STDDISPID_XOBJ_ONBEFOREPASTE
#define DISPID_EVPROP_ONPERSISTLOAD         (DISPID_EVENTS + 61)
#define DISPID_EVMETH_ONPERSISTLOAD          DISPID_ONPERSISTLOAD
#define DISPID_EVPROP_ONROWSDELETE          (DISPID_EVENTS + 62)
#define DISPID_EVMETH_ONROWSDELETE           STDDISPID_XOBJ_ONROWSDELETE
#define DISPID_EVPROP_ONROWSINSERTED        (DISPID_EVENTS + 63)
#define DISPID_EVMETH_ONROWSINSERTED         STDDISPID_XOBJ_ONROWSINSERTED
#define DISPID_EVPROP_ONCELLCHANGE          (DISPID_EVENTS + 64)
#define DISPID_EVMETH_ONCELLCHANGE           STDDISPID_XOBJ_ONCELLCHANGE
#define DISPID_EVPROP_ONCONTEXTMENU         (DISPID_EVENTS + 65)
#define DISPID_EVMETH_ONCONTEXTMENU          DISPID_ONCONTEXTMENU
#define DISPID_EVPROP_ONBEFOREPRINT         (DISPID_EVENTS + 66)
#define DISPID_EVMETH_ONBEFOREPRINT          DISPID_ONBEFOREPRINT
#define DISPID_EVPROP_ONAFTERPRINT          (DISPID_EVENTS + 67)
#define DISPID_EVMETH_ONAFTERPRINT           DISPID_ONAFTERPRINT
#define DISPID_EVPROP_ONSTOP                (DISPID_EVENTS + 68)
#define DISPID_EVMETH_ONSTOP                DISPID_ONSTOP
#define DISPID_EVPROP_ONBEFOREEDITFOCUS     (DISPID_EVENTS + 69)
#define DISPID_EVMETH_ONBEFOREEDITFOCUS      DISPID_ONBEFOREEDITFOCUS
#define DISPID_EVPROP_ONATTACHEVENT         (DISPID_EVENTS + 70)
#define DISPID_EVPROP_ONMOUSEHOVER          (DISPID_EVENTS + 71)
#define DISPID_EVMETH_ONMOUSEHOVER           DISPID_ONMOUSEHOVER
#define DISPID_EVPROP_ONCONTENTREADY        (DISPID_EVENTS + 72)
#define DISPID_EVMETH_ONCONTENTREADY         DISPID_ONCONTENTREADY
#define DISPID_EVPROP_ONLAYOUTCOMPLETE      (DISPID_EVENTS + 73)
#define DISPID_EVMETH_ONLAYOUTCOMPLETE       DISPID_ONLAYOUTCOMPLETE
#define DISPID_EVPROP_ONPAGE                (DISPID_EVENTS + 74)
#define DISPID_EVMETH_ONPAGE                 DISPID_ONPAGE
#define DISPID_EVPROP_ONLINKEDOVERFLOW      (DISPID_EVENTS + 75)
#define DISPID_EVMETH_ONLINKEDOVERFLOW       DISPID_ONLINKEDOVERFLOW
#define DISPID_EVPROP_ONMOUSEWHEEL          (DISPID_EVENTS + 76)
#define DISPID_EVMETH_ONMOUSEWHEEL           DISPID_ONMOUSEWHEEL
#define DISPID_EVPROP_ONBEFOREDEACTIVATE    (DISPID_EVENTS + 77)
#define DISPID_EVMETH_ONBEFOREDEACTIVATE     DISPID_ONBEFOREDEACTIVATE
#define DISPID_EVPROP_ONMOVE                (DISPID_EVENTS + 78)
#define DISPID_EVMETH_ONMOVE                 DISPID_ONMOVE
#define DISPID_EVPROP_ONCONTROLSELECT       (DISPID_EVENTS + 79)
#define DISPID_EVMETH_ONCONTROLSELECT        DISPID_ONCONTROLSELECT
#define DISPID_EVPROP_ONSELECTIONCHANGE     (DISPID_EVENTS + 80)
#define DISPID_EVMETH_ONSELECTIONCHANGE      DISPID_ONSELECTIONCHANGE
#define DISPID_EVPROP_ONMOVESTART           (DISPID_EVENTS + 81)
#define DISPID_EVMETH_ONMOVESTART            DISPID_ONMOVESTART
#define DISPID_EVPROP_ONMOVEEND             (DISPID_EVENTS + 82)
#define DISPID_EVMETH_ONMOVEEND              DISPID_ONMOVEEND
#define DISPID_EVPROP_ONRESIZESTART         (DISPID_EVENTS + 83)
#define DISPID_EVMETH_ONRESIZESTART          DISPID_ONRESIZESTART
#define DISPID_EVPROP_ONRESIZEEND           (DISPID_EVENTS + 84)
#define DISPID_EVMETH_ONRESIZEEND            DISPID_ONRESIZEEND
#define DISPID_EVPROP_ONMOUSEENTER          (DISPID_EVENTS + 85)
#define DISPID_EVMETH_ONMOUSEENTER           DISPID_ONMOUSEENTER
#define DISPID_EVPROP_ONMOUSELEAVE          (DISPID_EVENTS + 86)
#define DISPID_EVMETH_ONMOUSELEAVE           DISPID_ONMOUSELEAVE
#define DISPID_EVPROP_ONACTIVATE            (DISPID_EVENTS + 87)
#define DISPID_EVMETH_ONACTIVATE             DISPID_ONACTIVATE
#define DISPID_EVPROP_ONDEACTIVATE          (DISPID_EVENTS + 88)
#define DISPID_EVMETH_ONDEACTIVATE           DISPID_ONDEACTIVATE
#define DISPID_EVPROP_ONMULTILAYOUTCLEANUP  (DISPID_EVENTS + 89)
#define DISPID_EVMETH_ONMULTILAYOUTCLEANUP   DISPID_ONMULTILAYOUTCLEANUP
#define DISPID_EVPROP_ONBEFOREACTIVATE      (DISPID_EVENTS + 90)
#define DISPID_EVMETH_ONBEFOREACTIVATE       DISPID_ONBEFOREACTIVATE
#define DISPID_EVPROP_ONFOCUSIN             (DISPID_EVENTS + 91)
#define DISPID_EVMETH_ONFOCUSIN              DISPID_ONFOCUSIN
#define DISPID_EVPROP_ONFOCUSOUT            (DISPID_EVENTS + 92)
#define DISPID_EVMETH_ONFOCUSOUT             DISPID_ONFOCUSOUT
#define DISPID_EVPROPS_COUNT                (                93)


//;begin_internal
#endif // __COREDISP_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\always.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       Common header file for the Trident project.
//
//  Note:       This file is very order-dependent.  Don't switch files around
//              just for the heck of it!
//
//----------------------------------------------------------------------------

#ifndef I_ALWAYS_H_
#define I_ALWAYS_H_

// COM+ shim.  Uncomment below line to build the COM+ shim.
//#define COMPLUS_SHIM

#ifndef INCMSG
#define INCMSG(x)
//#define INCMSG(x) message(x)
#endif

#pragma INCMSG("--- Beg 'always.h'")

#define _OLEAUT32_
#define INC_OLE2
#define WIN32_LEAN_AND_MEAN
#define OEMRESOURCE
#define _COMDLG32_

#ifndef X_TRIRT_H_
#define X_TRIRT_H_
#pragma INCMSG("--- Beg 'trirt.h'")
#include <trirt.h>
#pragma INCMSG("--- End 'trirt.h'")
#endif

// Windows includes

#ifndef X_COMMDLG_H_
#define X_COMMDLG_H_
#pragma INCMSG("--- Beg <commdlg.h>")
#include <commdlg.h>
#pragma INCMSG("--- End <commdlg.h>")
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#pragma INCMSG("--- Beg <platform.h>")
#include <platform.h>
#pragma INCMSG("--- End <platform.h>")
#endif

#ifndef X_DOCOBJ_H_
#define X_DOCOBJ_H_
#pragma INCMSG("--- Beg <docobj.h>")
#include <docobj.h>
#pragma INCMSG("--- End <docobj.h>")
#endif


// Core includes

#include <w4warn.h>

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_WRAPDEFS_H_
#define X_WRAPDEFS_H_
#include "wrapdefs.h"
#endif

#ifndef X_F3UTIL_HXX_
#define X_F3UTIL_HXX_
#include "f3util.hxx"
#endif

#ifndef X_TRANSFORM_HXX_
#define X_TRANSFORM_HXX_
#include "transform.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_CSTR_HXX_
#define X_CSTR_HXX_
#include "cstr.hxx"
#endif

#ifndef X_FORMSARY_HXX_
#define X_FORMSARY_HXX_
#include "formsary.hxx"
#endif

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include <assoc.hxx>
#endif

#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

#ifndef X_DLL_HXX_
#define X_DLL_HXX_
#include "dll.hxx"
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#pragma INCMSG("--- Beg 'types.h'")
#include "types.h"
#pragma INCMSG("--- End 'types.h'")
#endif


// This prevents you from having to include codepage.h if all you want is
// the typedef for CODEPAGE.

typedef UINT CODEPAGE;

#ifndef X_SHLWAPI_H_
#define X_SHLWAPI_H_
#pragma INCMSG("--- Beg <shlwapi.h>")
#include <shlwapi.h>
#pragma INCMSG("--- End <shlwapi.h>")
#endif

#ifndef X_SHLWAPIP_H_
#define X_SHLWAPIP_H_
#pragma INCMSG("--- Beg <shlwapip.h>")
#include <shlwapip.h>
#pragma INCMSG("--- End <shlwapip.h>")
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

// Allow old-style string functions until they're all gone

#define STRSAFE_NO_DEPRECATE

// Right now including strsafe at this point causes a 
// warning that it is using a deprecated function. Until
// we find the cause of this warning, we should ignore it.
// (This warning would only appear if you remove the above
// #define.)

#pragma warning ( disable : 4995 )

#ifndef X_STRSAFE_H_
#define X_STRSAFE_H_
#pragma INCMSG("--- Beg 'strsafe.h'")
#include "strsafe.h"
#pragma INCMSG("--- End 'strsafe.h'")
#endif

#pragma warning ( default : 4995 )


#pragma INCMSG("--- End 'always.h'")
#else
#pragma INCMSG("*** Dup 'always.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\corerc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       corerc.h
//
//  Contents:   Resource identifiers for Core project.
//
//----------------------------------------------------------------------------
//
//  Resource identifier ranges.
//
//  Low resource identifiers are reserved for servers listed in the registry.
//  We need to do this because the ExtractIcon API uses the index of the icon,
//  not the resource identifier of icon.  By reserving this range for registered
//  servers, we can insure that the registered icon indices are correct.
//
//  00000 - 00019    Core registered servers
//  00020 - 00159    Ctrl '96 registered servers
//  00160 - 00199    Form registered servers
//  00200 - 00899    Ctrl '97 registered servers
//  00900 - 00999    Site registered servers (overlaps with ddoc)
//
//  02000 - 03999    Core miscellaneous
//  04000 - 05999    Ctrl miscellaneous
//  06000 - 07999    Form miscellaneous
//  08000 - 09999    Site miscellaneous (overlaps with ddoc)
//
//  10000 - 19999    Menu help string = IDS_MENUHELP(idm)
//  20000 - 29999    Tooltip text = IDS_TOOLTIP(idm)
//
//----------------------------------------------------------------------------
//
//  Naming convention
//
//  IDR_     Resource. Id must be unique per resource type, prefer
//           unique across resource types.
//  IDM_     Menu item, unique across product.
//  IDI_     Dialog item. Must be unique in dialog.
//  IDS_     String table element.
//  IDS_EA_  Action part of error message.
//  IDS_EE_  Error part of of error message.
//  IDS_ES_  Solution part of error message.
//  IDS_MSG_ Informational message.
//  IDS_E_   HRESULT to text mapping.
//
//----------------------------------------------------------------------------

#ifndef I_CORERC_H_
#define I_CORERC_H_
#pragma INCMSG("--- Beg 'corerc.h'")

#define IDS_MENUHELP(idm) (10000 + (idm))
#define IDS_TOOLTIP(idm)  (20000 + (idm))

//  resource ID offsets for class descriptor information
#define IDOFF_TOOLBOXBITMAP   5
#define IDOFF_ACCELS          6
#define IDOFF_MENU            7
#define IDOFF_MGW             8

// unfortunately, these macros can't be used in defining
//  the symbols below: the resource compiler doesn't like them.
#define IDS_USERTYPEFULL(base)  ((base)/5)
#define IDS_USERTYPESHORT(base) ((base)/5 + 1)
#define IDR_MENU(base)          ((base) + IDOFF_MENU)
#define IDR_TOOLBOXBITMAP(base) ((base) + IDOFF_TOOLBOXBITMAP)
#define IDR_ACCELS(base)        ((base) + IDOFF_ACCELS)

//----------------------------------------------------------------------------
//
// Registered servers (00xx)
//
//----------------------------------------------------------------------------

// Form

#define IDR_FORM_ICON             5

#define IDR_ACCELS_SITE_RUN             40
#define IDR_ACCELS_SITE_DESIGN          41
#define IDR_ACCELS_INPUTTXT_RUN         42
#define IDR_ACCELS_INPUTTXT_DESIGN      43
#define IDR_ACCELS_TCELL_RUN            44
#define IDR_ACCELS_TCELL_DESIGN         45
#define IDR_ACCELS_FRAMESET_RUN         46
#define IDR_ACCELS_FRAMESET_DESIGN      47
#define IDR_ACCELS_BODY_RUN             48
#define IDR_ACCELS_BODY_DESIGN          49
#define IDR_ACCELS_TXTSITE_RUN          50
#define IDR_ACCELS_TXTSITE_DESIGN       51


//+-------------------------------------------------------------------------
//
//  Cursors (20xx)
//
//--------------------------------------------------------------------------

#define IDC_SELBAR                      2008    // Text select cursor for text site

#define IDC_RESIZEROW2				    9804 
#define IDC_RESIZECOL2				    9805 


#define IDC_NOSCROLLVH                  2025
#define IDB_NOTLOADED                   2030
#define IDB_MISSING                     2031

//----------------------------------------------------------------------------
//
// Squeeze files (21xx)
//
//----------------------------------------------------------------------------

#define RT_DOCFILE                      256
#define RT_FILE                         2110

//+------------------------------------------------------------------------
//
//  Strings -- packed for size reason; start at multiple of 16.
    //      No existing ID can be changed once localization occurs
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Error strings
//
//-------------------------------------------------------------------------

#define IDS_E_CMDNOTSUPPORTED           2206
#define IDS_ERR_OD_E_OUTOFMEMORY        2207

//+------------------------------------------------------------------------
//
//  cdbase strings
//
//-------------------------------------------------------------------------

// 2210 starts string table chunk
#define IDS_USERTYPEAPP                 2212    // Microsoft Forms 2.0
#define IDS_MESSAGE_BOX_TITLE           2213    // Microsoft Forms
#define IDS_ERROR_SOLUTION              2214    // Solution:\n<0s>
#define IDS_UNKNOWN_ERROR               2215    // Unknown error <0x>
#define IDS_EA_SETTING_PROPERTY         2216    // Could not set property ...
#define IDS_EA_GETTING_PROPERTY         2217    // Could not get property ...
#define IDS_EE_INVALID_PROPERTY_VALUE   2218    // The value entered is not valid ..
#define IDS_ES_ENTER_VALUE_IN_RANGE     2220    // Enter a value between..
#define IDS_ES_ENTER_VALUE_GT_ZERO      2221    // Enter a value greater than
#define IDS_ES_ENTER_VALUE_GE_ZERO      2222    // Enter a value greater than
#define IDS_MSG_SAVE_MODIFIED_OBJECT    2223    // Save modified object?
#define IDS_EE_INVALIDPICTURETYPE       2227    // CTL_E_INVALIDPICTURETYPE mouse icon must be a mouse icon
#define IDS_EE_SETNOTSUPPORTEDATRUNTIME 2321    // Set property is not support at runtime.
#define IDS_EE_CANTMOVEFOCUSTOCTRL      2322    // can't move focus to control because...
#define IDS_EE_METHODNOTAPPLICABLE      2324
#define IDS_ES_ENTER_PROPER_VALUE       2325    // Enter a proper value
#define IDS_EA_CALLING_METHOD           2326    // Could not call method ...
#define IDS_EE_CONTROLNEEDSFOCUS        2327    // The control needs to have the focus
#define IDS_ES_CONTROLNEEDSFOCUS        2328    // Try setting the focus to the control using the SetFocus method
#define IDS_EE_UNEXPECTED               2329    // E_UNEXPECTED
#define IDS_EE_FAIL                     2330    // E_FAIL
#define IDS_EE_INVALIDPICTURE           2331    // CTL_E_INVALIDPICTURE
#define IDS_EE_INVALIDPROPERTYARRAYINDEX 2332   // CTL_E_INVALIDPROPERTYARRAYINDEX
#define IDS_EE_INVALIDPROPERTYVALUE     2333    // CTL_E_INVALIDPROPERTYVALUE
#define IDS_EE_OVERFLOW                 2334    // CTL_E_OVERFLOW
#define IDS_EE_PERMISSIONDENIED         2335    // CTL_E_PERMISSIONDENIED
#define IDS_EE_INVALIDARG               2336    // E_INVALIDARG
#define IDS_EE_NOTLICENSED              2337    // CLASS_E_NOTLICENSED
#define IDS_EE_INVALIDPASTETARGET       2338    // CTL_E_INVALIDPASTETARGET
#define IDS_EE_INVALIDPASTESOURCE       2339    // CTL_E_INVALIDPASTESOURCE

#define IDS_UNKNOWN                     2340

#define IDS_EE_INTERNET_INVALID_URL         2341
#define IDS_EE_INTERNET_NAME_NOT_RESOLVED   2342
#define IDS_EE_INET_E_UNKNOWN_PROTOCOL      2343
#define IDS_EE_INET_E_REDIRECT_FAILED       2344
#define IDS_EE_MISMATCHEDTAG                2345    // CTL_E_MISMATCHEDTAG
#define IDS_EE_INCOMPATIBLEPOINTERS         2346    // CTL_E_INCOMPATIBLEPOINTERS
#define IDS_EE_UNPOSITIONEDPOINTER          2347    // CTL_E_UNPOSITIONEDPOINTER
#define IDS_EE_UNPOSITIONEDELEMENT          2348    // CTL_E_UNPOSITIONEDELEMENT
#define IDS_EE_INVALIDLINE                  2349    // CTL_E_INVALIDLINE

//+------------------------------------------------------------------------
//
//  formkrnl strings
//
//-------------------------------------------------------------------------

#define IDS_CTRLPROPERTIES              2229
#define IDS_NAMEDCTRLPROPERTIES         2230
#define IDS_EA_PASTE_CONTROL            2235
#define IDS_EA_INSERT_CONTROL           2236
#define IDS_MSG_FIND_DIALOG_HACK        2237

//----------------------------------------------------------------------------
//
// Misc strings
//
//----------------------------------------------------------------------------

//  The following IDS's must be kept in order, such that the
//    string for a given unit has the id IDS_UNITS_BASE + units
//    Otherwise, the StringToHimetric and HimetricToString functions
//    in himetric.cxx will break.  (chrisz)

#define IDS_UNITS_BASE                  2240
#define IDS_UNITS_INCH                  (IDS_UNITS_BASE+0)
#define IDS_UNITS_CM                    (IDS_UNITS_BASE+1)
#define IDS_UNITS_POINT                 (IDS_UNITS_BASE+2)


//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_UNDO                        (IDS_UNITS_POINT + 1)
#define IDS_REDO                        (IDS_UNDO + 1)
#define IDS_CANTUNDO                    (IDS_UNDO + 2)
#define IDS_CANTREDO                    (IDS_UNDO + 3)
#define IDS_UNDONEWCTRL                 (IDS_UNDO + 4)
#define IDS_UNDODELETE                  (IDS_UNDO + 5)
#define IDS_UNDOPROPCHANGE              (IDS_UNDO + 6)
#define IDS_UNDOMOVE                    (IDS_UNDO + 7)
#define IDS_UNDODRAGDROP                (IDS_UNDO + 9)
#define IDS_UNDOPASTE                   (IDS_UNDO + 15)
#define IDS_UNDOTYPING                  (IDS_UNDO + 16)
#define IDS_UNDOGENERICTEXT             (IDS_UNDO + 19)
#define IDS_UNDOCHANGEVALUE             (IDS_UNDO + 20)
#define IDS_UNDOBACKSPACE               (IDS_UNDO + 21)

//----------------------------------------------------------------------------
//
// Misc (25xx)
//
//----------------------------------------------------------------------------

#define IDR_SELTOOLBMP                  2500    // Iconbar selection tool.
#define IDB_DITHER                      2502
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching

#define IDS_DRAGMOVEHERE                2508
#define IDS_DRAGCOPYHERE                2509
#define IDR_THKHATCHBMP                 2510    // Bitmap for thick border hatching
#define IDS_UNKNOWNPROTOCOL             2511    
#define IDS_SECURECONNECTIONINFO        2512
#define IDS_SECURE_LOW                  2513
#define IDS_SECURE_MEDIUM               2514
#define IDS_SECURE_HIGH                 2515
#define IDS_SECURESOURCE                2516

//----------------------------------------------------------------------------
//
// Icons
//
//----------------------------------------------------------------------------

#define RES_ICO_HTML                    2661

//----------------------------------------------------------------------------
//
// Misc resources
//
//----------------------------------------------------------------------------

#define IDR_CLICKSOUND              800
#define IDR_SITECONTEXT             24624  //0x6030  // bad id - not in core range

// dependencies - shdocvw\resource.h
#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range
#define IDR_BROWSE_CONTEXT_MENU     24641  //0x6041  // bad id - not in core range

#define IDR_DRAG_CONTEXT_MENU       24645  //0x6045  // bad id - not in core range

#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2




//
//  Form dialogs
//

//----------------------------------------------------------------------------
//
// Tab order dialog (3250 - 3260)
//
//----------------------------------------------------------------------------
#define IDR_TABORDERLBL             3250
#define IDR_TABORDERLSTBOX          3251
#define IDR_BTNMOVEUP               3252
#define IDR_BTNMOVEDOWN             3253
//#define IDR_BTNAUTOORDER            3254
#define IDR_TABORDERDLG             3255
#define IDR_TABORDERMOVELBL         3256

//+----------------------------------------------------------------------------
//
// HTML Block Format String
//
//-----------------------------------------------------------------------------

#define IDS_BLOCKFMT_NORMAL    1000
#define IDS_BLOCKFMT_PRE       1001
#define IDS_BLOCKFMT_ADDRESS   1002
#define IDS_BLOCKFMT_H1        1003
#define IDS_BLOCKFMT_H2        1004
#define IDS_BLOCKFMT_H3        1005
#define IDS_BLOCKFMT_H4        1006
#define IDS_BLOCKFMT_H5        1007
#define IDS_BLOCKFMT_H6        1008
#define IDS_BLOCKFMT_OL        1009
#define IDS_BLOCKFMT_UL        1010
#define IDS_BLOCKFMT_DIR       1011
#define IDS_BLOCKFMT_MENU      1012
#define IDS_BLOCKFMT_DT        1013
#define IDS_BLOCKFMT_DD        1014
#define IDS_BLOCKFMT_P         1016

#define IDS_HELPABOUT_STRING   1017
#define IDS_URLAUTODETECTOR_QUOTE_MSG 1018

#define IDS_BEGIN_DELIMITER                     1033
#define IDS_END_DELIMITER                       1034
#define IDS_END_LINE_DELIMITER                  1035

//+----------------------------------------------------------------------------
//
// default title caption for untitled HTML documents
//
//-----------------------------------------------------------------------------

#define IDS_NULL_TITLE         1020

#pragma INCMSG("--- End 'corerc.h'")
#else
#pragma INCMSG("*** Dup 'corerc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\coreguid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       coreguid.h
//
//  Contents:   extern references for forms guids
//
//----------------------------------------------------------------------------

// Please check \forms3\src\site\include\siteguid.h for information about GUID

#ifndef I_COREGUID_H_
#define I_COREGUID_H_
#pragma INCMSG("--- Beg 'coreguid.h'")

// TODO delete these. should be getting from public headers.
EXTERN_C const GUID CGID_ShellDocView;
EXTERN_C const GUID IID_IBrowseControl;
EXTERN_C const GUID IID_ITargetFrame2;
EXTERN_C const GUID CGID_MSHTML;

// Use PUBLIC_GUID for GUIDs used outside FORMS3.DLL.
// Use PRIVATE_GUID for all other GUIDS.

#ifndef PUBLIC_GUID
#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

#ifndef PRIVATE_GUID
#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// GUID from classic MSHTML
PRIVATE_GUID(CGID_IWebBrowserPriv, 0xED016940L,0xBD5B,0x11cf, 0xBA,0x4E,0x00,0xC0,0x4F,0xD7,0x08,0x16)

// private GUID used by IOleCommandTarget support in CBaseBag
//
PRIVATE_GUID(CGID_DATAOBJECTEXEC, 0x3050f3e4L,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b)

// GUID for private command group in CElement::Exec
PRIVATE_GUID(CGID_ProtectedElementPrivate, 0x3050f6dd, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// VARIANT conversion interface exposed by script engines (VBScript/JScript).
PUBLIC_GUID(SID_VariantConversion,  0x1f101481, 0xbccd, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9)

// Service GUID to return a pointer to the scoped obect, used in IObjectIdentity impls
PUBLIC_GUID(SID_ELEMENT_SCOPE_OBJECT, 0x3050f408,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b)

// CLSID to create the default recalc engine
PUBLIC_GUID(CLSID_CRecalcEngine, 0x3050f499, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// CLSID for CBase (needed to allow the document to go from a IUnknown to a CBase
PUBLIC_GUID(CLSID_CBase, 0x3050f49a, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b)

// ********************** DO NOT REMOVE the below GUID. **********************
//
// IE4 shipped the interface IHTMLControlElementEvents with the same GUID as IControlEvents
// from forms^3 this is of course bad.  To resolve this problem Trident's
// GUID for IHTMLControlElementEvents has changed however, the old GUID remembered in
// the FindConnectionPt.  The only side affect is that using the old GUID will not marshall
// the interface correctly only the new GUID has the correct marshalling code.

// {9A4BBF53-4E46-101B-8BBD-00AA003E3B29}
PRIVATE_GUID(IID_IControlEvents, 0x9A4BBF53, 0x4E46, 0x101B, 0x8B, 0xBD, 0x00, 0xAA, 0x00, 0x3E, 0x3B, 0x29)

#pragma INCMSG("--- End 'coreguid.h'")
#else
#pragma INCMSG("*** Dup 'coreguid.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\ctrldisp.h ===
/**************************************************************************************


  (rgardner) This file is obsolete - please put all changes in COREDISP.H
  It will be delfile'd shortly in a cleanup pass
                                                

 **************************************************************************************/

#pragma error("Don't include this file")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\dlc\typenav.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:       typenav.cxx
//
//  Contents:   Navigates an IDispatch's ITypeInfo.
//
//  Classes:    Priv
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include "typenav.hxx"
#endif

DeclareTag(tagCTypeInfoNav, "CTypeInfoNav", "CTypeInfoNav methods");


CTypeInfoNav::CTypeInfoNav () :
      _pTI(0),
      _wVarCount(0),
      _wFuncCount(0),
      _uIndex(~0U),                      // Signal to Next() need to preload 1
      _wVarFlagsFilter(0),
      _fFuncDesc(FALSE),
      _pVD(0),
      _dispid(DISPID_UNKNOWN)
{
    TraceTag((tagCTypeInfoNav, "CTypeInfoNav::CTypeInfoNav() -> %p", this));
}


CTypeInfoNav::~CTypeInfoNav ()
{
    TraceTag((tagCTypeInfoNav, "CTypeInfoNav::~CTypeInfoNav() -> %p", this));

    //
    // Release the ITypeInfo and VARDESC or FUNCDESC pointers.
    //
    if (_pVD)
    {
        Assert(_pTI);
        if (_fFuncDesc)
            _pTI->ReleaseFuncDesc(_pFD);
        else
            _pTI->ReleaseVarDesc(_pVD);
    }

    ReleaseInterface(_pTI);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitIDispatch
//
//  Synopsis:   Queries for an IDispatch to digout the ITypeInfo interface
//              and remember the actual number of entries in ITypeInfo for
//              iterating later.
//
//  Arguments:  [pUnk]      -- The interface which supports IDispatch.
//              [pITypeInfo]-- Returns an AddRef'd ITypeInfo if the pointer
//                             is not 0.
//              [wVFFilter] -- Variable or function filter to match (if zero
//                             then all properties are used).
//              [dispid]    -- dispid to match (if DISPID_UNKNOWN then look at
//                             each entry).
//
//  Returns:    HRESULT
//                  E_NOINTERFACE   - if pUnk doesn't support IID_Dispatch and
//                                    ITypeInfo.
//                  E_nnnn          - any HRESULT from:
//                                          QueryInterface,
//                                          IDispatch::GetTypeInfo
//                                          ITypeInfo::GetTypeAttr
//                  S_OK            - success.
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::InitIDispatch (IUnknown * pUnk,
                             ITypeInfo ** pITypeInfo,
                             WORD wVFFilter,
                             DISPID dispid)
{
    TraceTag((tagCTypeInfoNav,
              "CTypeInfoNav::InitIDispatch(%p, %p, %l, %l) -> %p",
              pUnk, pITypeInfo, wVFFilter, dispid, this));

    HRESULT     hr;
    IDispatch * pDisp = 0;

    Assert(pUnk);

    // Get typeinfo of control.
    hr = pUnk->QueryInterface(IID_IDispatch, (void **)&pDisp);
    if (hr)
        goto Cleanup;

    hr = InitIDispatch(pDisp, pITypeInfo, wVFFilter, dispid);

Cleanup:
    ReleaseInterface(pDisp);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitIDispatch
//
//  Synopsis:   Queries for an IDispatch to digout the ITypeInfo interface
//              and remember the actual number of entries in ITypeInfo for
//              iterating later.
//
//  Arguments:  [pDispatch] -- The IDispatch interface typeinfo to traverse.
//              [pITypeInfo]-- Returns an AddRef'd ITypeInfo if the pointer
//                             is not 0.
//              [wVFFilter] -- Variable or function filter to match (if zero
//                             then all properties are used).
//              [dispid]    -- dispid to match (if DISPID_UNKNOWN then look at
//                             each entry).
//
//  Returns:    HRESULT
//                  E_NOINTERFACE   - if pUnk doesn't support IID_Dispatch and
//                                    ITypeInfo.
//                  E_nnnn          - any HRESULT from:
//                                          QueryInterface,
//                                          IDispatch::GetTypeInfo
//                                          ITypeInfo::GetTypeAttr
//                  S_OK            - success.
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::InitIDispatch (IDispatch * pDisp,
                             ITypeInfo ** ppTypeInfo,
                             WORD wVFFilter,
                             DISPID dispid)
{
    TraceTag((tagCTypeInfoNav,
              "CTypeInfoNav::InitIDispatch(%p, %p, %l, %l) -> %p",
              pDisp, ppTypeInfo, wVFFilter, dispid, this));

    HRESULT     hr;

    Assert(pDisp);

    // Get typeinfo of control.
    hr = pDisp->GetTypeInfo(0, g_lcidUserDefault, &_pTI);
    if (hr)
        goto Cleanup;

    hr = InitITypeInfo(ppTypeInfo ? _pTI : 0, wVFFilter, dispid);

Cleanup:
    // We need to addref the ITypeInfo we're returning, InitITypeInfo
    // will do the addref for the copy we're returning.  GetTypeInfo
    // did the addref for the _pTI we're holding on to.
    if (ppTypeInfo)
    {
        *ppTypeInfo = hr ? NULL : _pTI;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   InitITypeInfo
//
//  Synopsis:   Given an ITypeInfo interface remember this ITypeInfo interface
//              and the actual number of entries in ITypeInfo for iteration.
//
//  Arguments:  [pTypeInfo] -- ITypeInfo.
//              [wVFFilter] -- Variable or function filter to match (if zero
//                             then all properties are used).
//              [dispid]    -- dispid to match (if DISPID_UNKNOWN then look at
//                             each entry).
//
//  Returns:    HRESULT
//                  E_POINTER   - if pTypeInfo is 0.
//                  E_nnnn      - any HRESULT from ITypeInfo::GetTypeAttr
//                  S_OK        - success.
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::InitITypeInfo (ITypeInfo * pTypeInfo,
                             WORD wVFFilter,
                             DISPID dispid)
{
    TraceTag((tagCTypeInfoNav,
              "CTypeInfoNav::InitITypeInfo(%p, %l, %l) -> %p",
              pTypeInfo, wVFFilter, dispid, this));

    HRESULT     hr;
    TYPEATTR *  pTA;

    Assert((pTypeInfo == 0 && _pTI) || pTypeInfo);

    _dispid = dispid;

    if (pTypeInfo)
    {
        _pTI = pTypeInfo;
        _pTI->AddRef();
    }

    hr = _pTI->GetTypeAttr(&pTA);
    Assert(!hr);
    if (!hr)
    {
        _wVarCount = pTA->cVars;
        _wFuncCount = pTA->cFuncs;
        
        _fIsDual = ((pTA->wTypeFlags & TYPEFLAG_FDUAL) != 0);

        _pTI->ReleaseTypeAttr(pTA);

        _wVarFlagsFilter = wVFFilter;
    }

    RRETURN(hr);
}



#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   DbgUserDefined
//
//  Synopsis:   Internal debugging code, for a property in the typelib traverse
//              the property type looking for a user defined type.
//
//  Arguments:  None
//
//  Returns:    None
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
void
CTypeInfoNav::DbgUserDefined ()
{
    HRESULT hr;

    // If the tag is on then output additional information.
    if (IsTagEnabled(tagCTypeInfoNav))
    {
        OutputDebugString(_T("Property Name = "));

        BSTR bstr = NULL;
        UINT cNames;
        _pTI->GetNames(_fFuncDesc ? _pFD->memid : _pVD->memid,
                       &bstr, 1, &cNames);
#ifndef _MACUNICODE
        OutputDebugString(bstr);
#else
        {
            CStr str;
            str.Set(bstr);
            OutputDebugString(str);
        }
#endif
        OutputDebugString(_T("\r\n"));

        FormsFreeString(bstr);

        if (_fFuncDesc)
        {
            if (_pFD->lprgelemdescParam)
            {
                if (_pFD->lprgelemdescParam->tdesc.vt == VT_USERDEFINED)
                {
                    HREFTYPE hreftype = 
                               _pFD->lprgelemdescParam->tdesc.hreftype;

                    ITypeInfo * pUserTI;
                    hr = _pTI->GetRefTypeInfo(hreftype, &pUserTI);
                    if (!hr)
                    {
                        TYPEATTR *pTypeAttr;
                        hr = pUserTI->GetTypeAttr(&pTypeAttr);
                        if (!hr)
                        {
                            OutputDebugString(
                                           _T("User define type\r\n") );
                            pUserTI->ReleaseTypeAttr(pTypeAttr);
                        }
                        ReleaseInterface(pUserTI);
                    }
                }
            }
        }
    }
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   Next
//
//  Synopsis:   Iterates through an ITypeInfo libraries looking only at
//              VAR_DISPATCH entries which match the _wVarFlagsFilter.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//                  E_POINTER           - if _pTINav or pTI are undefined (NULL)
//                  E_nnnn              - any HRESULT from ITypeInfo::GetVarDesc
//                  S_OK                - success
//                  S_FALSE             - No more items to iterate over
//
//  Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT
CTypeInfoNav::Next ()
{
    TraceTag((tagCTypeInfoNav, "CTypeInfoNav::Next() -> %p", this));

    HRESULT     hr = S_OK;
    WORD        wCount = _fIsDual ? _wFuncCount : _wFuncCount + _wVarCount;

    Assert(_pTI);

    while (++_uIndex < wCount)
    {
        // No, get the next one.

        UINT uIndex;        // index within current type (funcs or vars)

        // release the previous result
        if (_pVD)
        {
            if (_fFuncDesc)
                _pTI->ReleaseFuncDesc(_pFD);
            else
                _pTI->ReleaseVarDesc(_pVD);
            _pVD = 0;
        }

        // Get the description of the IDispatched variable.
        _fFuncDesc = (_uIndex < _wFuncCount);
        uIndex = _fFuncDesc ? _uIndex : (_uIndex - _wFuncCount);

        hr = _fFuncDesc ? _pTI->GetFuncDesc(uIndex, &_pFD) :
                          _pTI->GetVarDesc(uIndex, &_pVD);
        if (!hr)
        {
            TraceTag((tagCTypeInfoNav,
                     "  Next: dispid = %p; wVarFlags = %p -> %p",
                     _fFuncDesc ? _pFD->memid : _pVD->memid,
                     _fFuncDesc ? _pFD->wFuncFlags : _pVD->wVarFlags,
                     this));

#if DBG == 1
            DbgUserDefined();
#endif

            //
            // Can this variable only be accessed via IDispatch::Invoke?
            //
            if (_fFuncDesc ?
                ((_pFD->funckind == FUNC_DISPATCH) || (_pFD->funckind == FUNC_PUREVIRTUAL)) :
                (_pVD->varkind == VAR_DISPATCH))
            {
                DISPID dispid = _fFuncDesc ? _pFD->memid : _pVD->memid;

                // Are we trying to match to a particular dispid or if we found
                // the particular dispid then look at the filter.
                if ((_dispid == DISPID_UNKNOWN) || (_dispid == dispid))
                {
                    //
                    // If we have filters to check, then make sure the
                    // currentwVarFlags matches the filter before we say
                    // it's a match.
                    //
                    WORD wFlags = _fFuncDesc ? _pFD->wFuncFlags :
                                               _pVD->wVarFlags;
                    if (!_wVarFlagsFilter ||
                        (_wVarFlagsFilter & wFlags) == _wVarFlagsFilter)
                        break;
                }
            }            
        } else
            break;
    }      // end while loop

    //
    // If the internal index is larger than Count() then return
    // S_FALSE to signal there are no more entries to iterate over
    // or if we had an error then just the current error value in hr otherwise
    // we succeeded so return S_OK.
    //
    if (!hr)
        hr = (_uIndex >= wCount) ? S_FALSE : S_OK;

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\empty.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\dithers.h ===
#ifndef I_DITHERS_H_
#define I_DITHERS_H_
#pragma INCMSG("--- Beg 'dithers.h'")

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    int r, g, b;

} ERRBUF;

__inline size_t ErrbufBytes(size_t pels)
{
    return (pels + 2) * sizeof(ERRBUF);
}

///////////////////////////////////////////////////////////////////////////////

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight );

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap,
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, 
   int cy );

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void DithGray8to1( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, 
   UINT x, UINT cx, UINT y, int cy );

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN);

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy);

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN);

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Dith24rto8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Dith24rto1(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, 
    UINT x, UINT cx, UINT y, int cy);

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

void Dith24rto15(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

void Dith24rto16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

void Convert24rto15(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, UINT x, UINT cx, UINT y, int cy);

void Convert24rto16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, UINT x, UINT cx, UINT y, int cy);

void DithGray8to15( WORD* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, 
   UINT cx, UINT y, int cy );

void DithGray8to16( WORD* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, 
   UINT cx, UINT y, int cy );

HRESULT DitherTo8(  BYTE * pDestBits, LONG nDestPitch, 
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans);

HRESULT AllocDitherBuffers(LONG cx, ERRBUF **ppBuf1, ERRBUF **ppBuf2);

void FreeDitherBuffers(ERRBUF *pBuf1, ERRBUF *pBuf2);

///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#pragma INCMSG("--- End 'dithers.h'")
#else
#pragma INCMSG("*** Dup 'dithers.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\mstdwrap.h ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         MStdWrap.h
//
// Contents     Class definition for Mac Unicode-friendly Standard Wrapper 
//              Interfaces
//
//              
//
// Note:        These subclass definitions are required to convert internal
//              UNICODE strings to ANSI strings before passing them on to
//              the appropriate Mac Forms superclass method. By defining
//              the interface name as our subclass wrapper, the main body of
//              code does not need to concern itself with UNICODE vs ANSI -
//              the code will call the correct method.
//
//	History:	02/07/96    Created by kfl / black diamond.
//
//-----------------------------------------------------------------------------

#ifndef I_MSTDWRAP_HXX_
#define I_MSTDWRAP_HXX_
#pragma INCMSG("--- Beg 'mstdwrap.h'")

#if defined(_MACUNICODE) && !defined(_MAC)

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
interface IForms96BinderDispenserMac : public IForms96BinderDispenser
{
public:
    operator IForms96BinderDispenser* () { return this; }


        virtual HRESULT __stdcall ParseName( 
            /* [in] */ OLECHAR *pszName,
            /* [out] */ IForms96Binder **ppBinder);

        virtual HRESULT __stdcall ParseName( 
            /* [in] */ WCHAR *pszName,
            /* [out] */ IForms96Binder **ppBinder) = 0;


};
#define IForms96BinderDispenser                    IForms96BinderDispenserMac

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
interface ISimpleTabularDataMac : public ISimpleTabularData
{
public:
    operator ISimpleTabularData* () { return this; }

    virtual HRESULT __stdcall GetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [out] */ OLECHAR *pchBuf,
            /* [out] */ ULONG *pcchActual);
        virtual HRESULT __stdcall GetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [out] */ WCHAR *pchBuf,
            /* [out] */ ULONG *pcchActual) = 0;
        
        virtual HRESULT __stdcall SetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ OLECHAR *pchBuf);
        virtual HRESULT __stdcall SetString( 
            /* [in] */ ULONG iRow,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ WCHAR *pchBuf) = 0;

        virtual HRESULT __stdcall FindPrefixString( 
            /* [in] */ ULONG iRowStart,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ OLECHAR *pchBuf,
            /* [in] */ DWORD findFlags,
            /* [out] */ STDFIND *foundFlag,
            /* [out] */ ULONG *piRowFound);
        virtual HRESULT __stdcall FindPrefixString( 
            /* [in] */ ULONG iRowStart,
            /* [in] */ ULONG iColumn,
            /* [in] */ ULONG cchBuf,
            /* [in] */ WCHAR *pchBuf,
            /* [in] */ DWORD findFlags,
            /* [out] */ STDFIND *foundFlag,
            /* [out] */ ULONG *piRowFound) = 0;
};
#define ISimpleTabularData                    ISimpleTabularDataMac



#endif // _MACUNICODE

#pragma INCMSG("--- End 'mstdwrap.h'")
#else
#pragma INCMSG("*** Dup 'mstdwrap.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\mfmwrap.h ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         MFmWrap.h
//
// Contents     Interface definition for Mac Unicode-friendly Forms Wrapper 
//              Interfaces
//
// Interfaces   CControlMac
//              
//
// Note:        These class definitions are required to convert internal
//              UNICODE strings to ANSI strings before passing them on to
//              the appropriate Mac Forms superclass method. By defining
//              the interface name as our subclass wrapper, the main body of
//              code does not need to concern itself with UNICODE vs ANSI -
//              the code will call the correct method.
//
//	History:	02/07/96    Created by kfl / black diamond.
//
//-----------------------------------------------------------------------------

#ifndef I_MFMWRAP_HXX_
#define I_MFMWRAP_HXX_
#pragma INCMSG("--- Beg 'mfmwrap.hxx'")

// Note:        The following typedefs are required by the Mac 
//              Unicode wrapper classes.  MFmWrap #defines
//              some of the forms interfaces so that the main body 
//              of code will use the wrapper classes instead of the
//              original forms interface.  However, in order to not 
//              have to wrap any method that refers to a pointer
//              to the wrapped interface, we need a way to reference
//              the original interface - thus the need for the pointer
//              typedef.
//

interface IControls;
typedef IControls *             LPCONTROLS;

#  if defined(_MACUNICODE) && !defined(_MAC)
// the rest of the code will only be used for Mac UNICODE  implementations
STDAPI FormsCreatePropertyFrameW(
            HWND        hwndOwner,
            UINT        x,
            UINT        y,
      const LPWSTR      lpszCaption,
            ULONG       cObjects,
            IUnknown**  ppunk,
            ULONG       cPages,
      const CLSID *     pPageClsID,
            LCID        lcid);
#define   FormsCreatePropertyFrame   FormsCreatePropertyFrameW

/*
STDAPI FormsOpenReadOnlyStorageOnResourceW(
    HINSTANCE hInst, LPCWSTR lpstrID, LPSTORAGE * ppStg);
#define   FormsOpenReadOnlyStorageOnResource   FormsOpenReadOnlyStorageOnResourceW
*/
#ifdef PRODUCT_97
//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
interface ITextBox95Mac : public ITextBox95
{
public:
    operator ITextBox95* () { return this; }

    virtual HRESULT __stdcall SetPasswordChar( 
        /* [in] */ OLECHAR wchar);
    virtual HRESULT __stdcall SetPasswordChar( 
        /* [in] */ WCHAR wchar) = 0;
    
    
    virtual HRESULT __stdcall GetPasswordChar( 
        /* [out] */ OLECHAR *wchar);
    virtual HRESULT __stdcall GetPasswordChar( 
        /* [out] */ WCHAR *wchar) = 0;
};
#define ITextBox95                    ITextBox95Mac
#endif  // PRODUCT_97

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlSelectorEventsMac : public IControlSelectorEvents
{
public:
    operator IControlSelectorEvents* () { return this; }

    virtual HRESULT __stdcall SelectionChange( 
        /* [in] */ REFCLSID clsid,
        /* [in] */ OLECHAR *szTooltip);
    
    virtual HRESULT __stdcall SelectionChange( 
        /* [in] */ REFCLSID clsid,
        /* [in] */ WCHAR *szTooltip) = 0;
};
#define IControlSelectorEvents                    IControlSelectorEventsMac


//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlsMac : public IControls
{
public:
    operator IControls* () { return this; }

        virtual HRESULT __stdcall GetItemByName( 
            /* [in] */ LPCOLESTR pstr,
            /* [out] */ IControl **Control);
        
        virtual HRESULT __stdcall GetItemByName( 
            /* [in] */ LPCWSTR pstr,
            /* [out] */ IControl **Control) = 0;
        
};
#define IControls                    IControlsMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlPaletteEventsMac : public IControlPaletteEvents
{
public:
    operator IControlPaletteEvents* () { return this; }

        virtual HRESULT __stdcall SelectionChange( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ LPOLESTR szTooltip);
        virtual HRESULT __stdcall SelectionChange( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ LPWSTR szTooltip) = 0;
};
#define IControlPaletteEvents        IControlPaletteEventsMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IControlPaletteMac : public IControlPalette
{
public:
    operator IControlPalette* () { return this; }

        virtual HRESULT __stdcall AddPage( 
            /* [in] */ IStorage *pStg,
            /* [in] */ LPOLESTR szName,
            /* [out] */ long *plIndex);
        virtual HRESULT __stdcall AddPage( 
            /* [in] */ IStorage * pStg,
            /* [in] */ LPWSTR szName,
            /* [out] */ long *plIndex) = 0;
        
        
        virtual HRESULT __stdcall InsertPage( 
            /* [in] */ IStorage *pStg,
            /* [in] */ LPOLESTR szName,
            /* [in] */ long lIndex);
        
        virtual HRESULT __stdcall InsertPage( 
            /* [in] */ IStorage * pStg,
            /* [in] */ LPWSTR szName,
            /* [in] */ long lIndex) = 0;
        
};
#define IControlPalette        IControlPaletteMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface IGetUniqueIDMac : public IGetUniqueID
{
public:
    operator IGetUniqueID* () { return this; }

        virtual HRESULT __stdcall GetUniqueName( 
            /* [in] */ LPWSTR pstrPrefix,
            /* [in] */ LPWSTR pstrSuggestedName,
            /* [out][in] */ ULONG *pulSuffix,
            /* [in] */ BOOL fAllowDupeCheck) = 0;
        virtual HRESULT __stdcall GetUniqueName( 
            /* [in] */ LPOLESTR pstrPrefix,
            /* [in] */ LPOLESTR pstrSuggestedName,
            /* [out][in] */ ULONG *pulSuffix,
            /* [in] */ BOOL fAllowDupeCheck);
};
#define IGetUniqueID                IGetUniqueIDMac

//------------------------------------------------------------------------------ 
//
//------------------------------------------------------------------------------
interface ITabStripExpertEventsMac : public ITabStripExpertEvents
{
public:
    operator ITabStripExpertEvents* () { return this; }

        virtual HRESULT __stdcall DoRenameItem( 
            /* [in] */ long lIndex,
            /* [in] */ LPOLESTR bstr,
            /* [in] */ LPOLESTR bstrTip,
            /* [in] */ LPOLESTR bstrAccel,
            /* [out][in] */ VARIANT_BOOL *EnableDefault);
        virtual HRESULT __stdcall DoRenameItem( 
            /* [in] */ long lIndex,
            /* [in] */ LPWSTR bstr,
            /* [in] */ LPWSTR bstrTip,
            /* [in] */ LPWSTR bstrAccel,
            /* [out][in] */ VARIANT_BOOL *EnableDefault) = 0;
};

interface ITabStripExpertMac : public ITabStripExpert
{
public:
    operator ITabStripExpert* () { return this; }

        virtual HRESULT __stdcall SetTabStripExpertEvents( 
            ITabStripExpertEventsMac *pTabStripExpertEvents)  = 0;
        virtual HRESULT __stdcall SetTabStripExpertEvents( 
            ITabStripExpertEvents *pTabStripExpertEvents) 
        { return  SetTabStripExpertEvents ((ITabStripExpertEventsMac*)pTabStripExpertEvents);  }
};
#define ITabStripExpert                ITabStripExpertMac
#define ITabStripExpertEvents          ITabStripExpertEventsMac

#endif // _MACUNICODE

#pragma INCMSG("--- End 'mfmwrap.hxx'")
#else
#pragma INCMSG("*** Dup 'mfmwrap.hxx'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\platrisc.h ===
//+---------------------------------------------------------------------------
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       src\core\include\platrisc.h
//
//  Contents:   header file containing inline declarations for all Win95
//              functions used in Forms^3.  For RISC platforms ONLY.
//
//  History:    02-Nov-94   SumitC      Created
//
//----------------------------------------------------------------------------

#ifndef I_PLATRISC_H_
#define I_PLATRISC_H_
#pragma INCMSG("--- Beg 'platrisc.h'")

//
//  Definitions for the init and uninit functions.  These are to be called
//  as the first thing during DLL attach and the last thing during DLL detach,
//  respectively.
//
void InitWrappers();
void DeinitWrappers();


// definitions for all non-Intel platforms, i.e. MIPS, Alpha, PowerPC etc.

extern DWORD g_dwPlatformVersion;   // (dwMajorVersion << 16) + (dwMinorVersion)
extern DWORD g_dwPlatformID;        // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
extern BOOL g_fUnicodePlatform;

// All such platforms are Unicode-only, so there is no need for the Unicode
// wrapper functions.


#pragma INCMSG("--- End 'platrisc.h'")
#else
#pragma INCMSG("*** Dup 'platrisc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\shell.h ===
#ifndef I_SHELL_H_
#define I_SHELL_H_
#pragma INCMSG("--- Beg 'shell.h'")

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include <shlobj.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#pragma INCMSG("--- End 'shell.h'")
#else
#pragma INCMSG("*** Dup 'shell.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\qi_impl.h ===
#ifndef I_QI_IMPL_H_
#define I_QI_IMPL_H_
#pragma INCMSG("--- Beg 'qi_impl.h'")

#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_IBindHost                    0xfc4801a1
#define Data1_IBrowserService              0x02ba3b52
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataObject                  0x0000010e
#define Data1_DataSource                   0x7c0ffab3
#define Data1_DataSourceListener           0x7c0ffab2
#define Data1_IDATASRCListener             0x3050f380
#define Data1_IDispatch                    0x00020400
#define Data1_IDispObserver                0x3050f442
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoUnits            0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IForm                        0x04598fc8
#define Data1_IFormExpert                  0x04598fc5
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IHlinkTarget                 0x79eac9c4
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMonikerProp                 0xa5ca5f7f
#define Data1_IOleCommandTarget            0xb722bccb
#define Data1_IOleDocument                 0xb722bcc5
#define Data1_IOleDocumentView             0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleParentUndoUnit           0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoUnit                 0x894ad3b0
#define Data1_IOleUndoManager              0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistHistory              0x91A565C1
#define Data1_IPersistMoniker              0x79eac9c9
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistHTML                 0x049948d1
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideClassInfo2           0xa6bc3ac0
#define Data1_IProvideDynamicClassInfo     0x6d5140d1
#define Data1_IProvideMultipleClassInfo    0xa7aba9c1
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITargetContainer             0x7847EC01
#define Data1_ITargetEmbedding             0x548793c0
#define Data1_ITargetFrame                 0xd5f78c80
#define Data1_ITargetFrame2                0x3abac181
#define Data1_ITargetNotify                0x863a99a0
#define Data1_ITargetNotify2               0x3050f6b1
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10
#define Data1_IAccessible                  0x618736e0
#define Data1_IHTMLFrameBase               0x3050f311
#define Data1_IHTMLTextSite                0x1ff6aa71
#define Data1_IHTMLImageSite               0x49A4B4C0
#define Data1_IHTMLBodyElement             0x3050f1d8
#define Data1_IHTMLFontElement             0x3050f1d9
#define Data1_IHTMLAnchorElement           0x3050f1da
#define Data1_IHTMLAnchorElement2          0x3050f825
#define Data1_IHTMLUListElement            0x3050f1dd
#define Data1_IHTMLOListElement            0x3050f1de
#define Data1_IHTMLLIElement               0x3050f1e0
#define Data1_IHTMLBRElement               0x3050f1f0
#define Data1_IHTMLDListElement            0x3050f1f1
#define Data1_IHTMLDDElement               0x3050f1f2
#define Data1_IHTMLDTElement               0x3050f1f3
#define Data1_IHTMLHRElement               0x3050f1f4
#define Data1_IHTMLParaElement             0x3050f1f5
#define Data1_IHTMLHeaderElement           0x3050f1f6
#define Data1_IHTMLDivElement              0x3050f200
#define Data1_IHTMLBaseFontElement         0x3050f202
#define Data1_IGetUniqueID                 0xaf8665b0
#define Data1_CSubForm                     0x3050f1c7
#define Data1_IBoundObjectSite             0x9BFBBC01
#define Data1_IBitmapSurface               0x3050f2ef 
#define Data1_IGdiSurface                  0x3050f2f0 
#define Data1_IDDSurface                   0x3050f2f1 
#define Data1_IBitmapSurfaceFactory        0x3050f2f2 
#define Data1_IGdiSurfaceFactory           0x3050f2f3 
#define Data1_IDDSurfaceFactory            0x3050f2f4 
#define Data1_IRGBColorTable               0x3050f2f5 
#define Data1_IDispatchEx                  0xa6ef9860
#define Data1_IHTMLEventObj                0x3050f32d
#define Data1_IHTMLWindow2                 0x332c4427
#define Data1_IHTMLWindow3                 0x3050f4ae
#define Data1_IHTMLWindow4                 0x3050f6cf
#define Data1_IHTMLFramesCollection2       0x332c4426
#define Data1_IHTMLDocument                0x626FC520
#define Data1_IHTMLDocument2               0x332c4425
#define Data1_IHTMLDocument3               0x3050f485
#define Data1_IHTMLDocument4               0x3050f69a
#define Data1_IHTMLDocument5               0x3050f80c
#define Data1_IHTMLDataTransfer            0x3050f4b3
#define Data1_IMarqueeInfo                 0x0bdc6ae0
#define Data1_IObjectSafety                0xcb5bdc81
#define Data1_IShellPropSheetExt           0x000214E9
#define Data1_IHTMLScreen                  0x3050f35c
#define Data1_IHTMLScreen2                 0x3050f84a
#define Data1_IHTMLViewFilter              0x3050f2f1
#define Data1_IHTMLViewFilterSite          0x3050f2f4
#define Data1_ITimerService                0x3050f35f
#define Data1_ITimer                       0x3050f360
#define Data1_ITimerSink                   0x3050f361
#define Data1_IHTMLLocation                0x163BB1E0
#define Data1_IHTMLElement                 0x3050f1ff
#define Data1_IHTMLElement2                0x3050f434
#define Data1_IHTMLElement3                0x3050f673
#define Data1_IHTMLElement4                0x3050f80f
#define Data1_IInternetHostSecurityManager 0x3af280b6
#define Data1_IHTMLTxtRange                0x3050F220
#define Data1_IHTMLTxtRangeCollection      0x3050f7ed
#define Data1_IHTMLTextRangeMetrics        0x3050F40B
#define Data1_IHTMLTextRangeMetrics2       0x3050f4a6
#define Data1_ICustomDoc                   0x3050f3f0
#define Data1_ICSSFilterSite               0x3050f3ed
#define Data1_IHTMLDatabinding             0x3050f3f2
#define Data1_IObjectIdentity              0xCA04B7E6
#define Data1_IHTMLTableRow                0x3050f23c
#define Data1_IHTMLTableRowMetrics         0x3050f413
#define Data1_IBindStatusCallback          0x79eac9c1
#define Data1_IWindowForBindingUI          0x79EAC9D5
#define Data1_IDebugDocumentHost           0x51973C27
#define Data1_IHTMLEventObj2               0x3050f48B
#define Data1_IWebBridge                   0xAE24FDAD
#define Data1_IElementBehavior             0x3050f425
#define Data1_IElementBehaviorUI           0x3050f4bf
#define Data1_IElementBehaviorSite         0x3050f427
#define Data1_IElementBehaviorSiteOM       0x3050f489
#define Data1_IElementBehaviorSiteOM2      0x3050f659
#define Data1_IElementBehaviorSiteRender   0x3050f4a7
#define Data1_IElementBehaviorSiteCategory 0x3050f4ee
#define Data1_IElementBehaviorSiteLayout   0x3050f6b7
#define Data1_IElementBehaviorSiteLayout2  0x3050f847
#define Data1_IElementBehaviorFactory      0x3050f429
#define Data1_IElementNamespaceTable       0x3050f670
#define Data1_IElementNamespace            0x3050f671
#define Data1_IElementNamespaceFactory     0x3050f672
#define Data1_IHTCDefaultDispatch          0x3050f4fd
#define Data1_IHTCPropertyBehavior         0x3050f5df
#define Data1_IHTCEventBehavior            0x3050f4ff
#define Data1_IHTCAttachBehavior           0x3050f5f4
#define Data1_IProfferService              0xcb728b20
#define Data1_IPersistPropertyBag2         0x22F55881
#ifdef VSTUDIO7
#define Data1_IIdentityBehavior            0x3050f60c
#define Data1_IIdentityBehaviorFactory     0x3050f60d
#endif //VSTUDIO7
#define Data1_ICSSFilter                   0x3050f3ec
#define Data1_IHTMLRect                    0x3050f4a3
#define Data1_IHTMLRectCollection          0x3050f4a4
#define Data1_IHTMLTableRow2               0x3050f4a1
#define Data1_IHTMLTableRow3               0x3050f82c
#define Data1_IRecalcEngine                0x3050f496
#define Data1_IRecalcHost                  0x3050f497
#define Data1_IObjectWithSite              0xFC4801A3
#define Data1_IMarkupPointer               0x3050f49f
#define Data1_IMarkupPointer2              0x3050f675
#define Data1_IMarkupServices              0x3050f4a0
#define Data1_IMarkupServices2             0x3050f682
#define Data1_IMarkupContainer             0x3050f5f9
#define Data1_IMarkupContainer2            0x3050f648
#define Data1_IHTMLChangeLog               0x3050f649
#define Data1_IHTMLChangePlayback          0x3050f6e0
#define Data1_IHTMLViewServices            0x3050f603
#define Data1_IHTMLPopup                   0x3050f666
#if DBG==1
#define Data1_IHTMLChangeSink              0x3050f64a
#endif // DBG==1
#define Data1_IHTMLEventObj2               0x3050f48B
#define Data1_IHTMLPersistDataOLD          0x3050f48e
#define Data1_IHTMLPersistDataOM           0x3050f4c0
#define Data1_IHTMLPersistData             0x3050f4c5
#define Data1_IActiveScriptSite            0xdb01a1e3
#define Data1_IScriptletHandler            0xa001a870
#define Data1_IScriptletHandlerConstructor 0xa3d52a50
#define Data1_IClassFactoryEx              0x342d1ea0
#define Data1_IHTMLDOMNode                 0x3050f5da
#define Data1_IHTMLDOMNode2                0x3050f80b
#define Data1_IHTMLDOMTextNode             0x3050f4b1
#define Data1_IHTMLDOMTextNode2            0x3050f809
#define Data1_IHTMLDOMAttribute            0x3050f4b0
#define Data1_IHTMLDOMAttribute2           0x3050f810
#define Data1_IHTMLDOMCollectionator       0x3050f4af
#define Data1_IHTMLAttributeCollection     0x3050f4c3
#define Data1_IHTMLAttributeCollection2    0x3050f80a
#define Data1_IHTMLUniqueName              0x3050f4d0
#define Data1_IHTMLObjectElement           0x3050f24f
#define Data1_IHTMLObjectElement2          0x3050f4cd
#define Data1_IHTMLObjectElement3          0x3050f827
#define Data1_IHTMLTable                   0x3050f21e
#define Data1_IHTMLTable2                  0x3050f4ad
#define Data1_IHTMLTable3                  0x3050f829
#define Data1_IScriptletSite               0xc5f21c30
#define Data1_IHTMLIFrameElement2          0x3050f4e6
#define Data1_IHTMLLinkElement2            0x3050f4e5
#define Data1_IHTMLLinkElement3            0x3050f81e
#define Data1_IHTMLIFrameElement           0x3050f315
#define Data1_IHTMLLinkElement             0x3050f205
#define Data1_ISegmentList                 0x3050f605
#define Data1_ISegment                     0x3050f683
#define Data1_IHighlightRenderingServices  0x3050f606
#define Data1_IHTMLFormElement2            0x3050f4f6
#define Data1_IHTMLFormElement3            0x3050f836
#define Data1_IHTMLCaret                   0x3050f604
#define Data1_IDispClient                  0x3050f437
#define Data1_IElementAdorner              0x3050f607
#define Data1_IHTMLAppBehavior             0x3050f5ca
#define Data1_IHTMLAppBehavior2            0x3050f5c9
#define Data1_IHTMLAppBehavior3            0x3050f5cd
#define Data1_IHTMLInputElement            0x3050f5d2
#define Data1_IHTMLInputElement2           0x3050f821
#define Data1_IHTMLInputTextElement        0x3050f2a6
#define Data1_IHTMLInputHiddenElement      0x3050f2a4
#define Data1_IHTMLInputImage              0x3050f2c2
#define Data1_IHTMLInputButtonElement      0x3050f2b2
#define Data1_IHTMLDialog2                 0x3050f5e0
#define Data1_IHTMLInputFileElement        0x3050f2ad
#define Data1_IHTMLOptionButtonElement     0x3050f2bc
#define Data1_IRecalcProperty              0x3050f5d6
#define Data1_IHTMLDocumentFragment        0x3050f5e5
#define Data1_IHTMLElementCollection2      0x3050f5ee
#define Data1_IHTMLElementCollection3      0x3050f835
#define Data1_IHTMLAreasCollection2        0x3050f5ec
#define Data1_IHTMLAreasCollection3        0x3050f837
#define Data1_IHTMLSelectElement2          0x3050f5ed
#define Data1_IHTMLSelectElement4          0x3050f838
#define Data1_IHTMLControlRange            0x3050f29c
#define Data1_IHTMLControlRange2           0x3050f65e
#define Data1_IEditDebugServices           0x3050f60b
#define Data1_IRecalcHostDebug             0x3050f5f7
#define Data1_IMarkupTextFrags             0x3050f5fa
#define Data1_ISecureUrlHost               0xc81984c4
#define Data1_IHTMLElementLayout           0x3050f637
#define Data1_IHTMLLayoutFactory           0x3050f638
#define Data1_IHTMLLayout                  0x3050f639
#define Data1_IHTMLLayoutContext           0x3050f63a
#define Data1_IHTMLBreakTable              0x3050f63b
#define Data1_IXMLGenericParse             0xe4e23071
#define Data1_IHTMLStyle                   0x3050f25e
#define Data1_IHTMLStyle2                  0x3050f4a2
#define Data1_IHTMLStyle3                  0x3050f656
#define Data1_IHTMLStyle4                  0x3050f816
#define Data1_IHTMLRuleStyle               0x3050f3cf
#define Data1_IHTMLRuleStyle2              0x3050f4ac
#define Data1_IHTMLRuleStyle3              0x3050f657
#define Data1_IHTMLRuleStyle4              0x3050f817
#define Data1_IHTMLCurrentStyle            0x3050f3db
#define Data1_IHTMLCurrentStyle2           0x3050f658
#define Data1_IHTMLCurrentStyle3           0x3050f818
#define Data1_IHTMLRenderStyle             0x3050f6ae
#define Data1_IHTMLSubmitData              0x3050f645
#define Data1_IElementBehaviorSubmit       0x3050f646
#define Data1_IHTMLProtectedElement        0x3050f65a
#define Data1_IHTMLElementDefaults         0x3050f6c9
#define Data1_IHTMLElementRender           0x3050f669
#define Data1_ITravelLogClient             0x3050f67a
#define Data1_IWebBrowser                  0xeab22ac1
#define Data1_IWebBrowserApp               0x0002df05
#define Data1_IWebBrowser2                 0xd30c1661
#define Data1_IHTMLPrivateWindow           0x3050f6dc
#define Data1_IHTMLPrivateWindow2          0x3050f7e5
#define Data1_IHTMLPrivateWindow3          0x3050f840
#define Data1_IHTMLEventObj3               0x3050f680
#define Data1_IHTMLEventObj4               0x3050f814
#define Data1_IHTMLPaintSite               0x3050f6a7
#define Data1_IHTMLFilterPaintSite         0x3050f6d3
#define Data1_IHlinkFrame                  0x79eac9c5 
#define Data1_IHTMLPainter                 0x3050f6a6
#define Data1_IHTMLPainterEventInfo        0x3050f6df
#define Data1_IDisplayServices             0x3050f69d
#define Data1_IIMEServices                 0x3050f6ca
#define Data1_IPrivacyServices             0x3050f84b
#define Data1_IHTCAttachBehavior2          0x3050f7eb
#define Data1_IHTMLStyleSheet              0x3050f2e3
#define Data1_IHTMLStyleSheet2             0x3050f3d1
#define Data1_IHTMLFrameElement            0x3050f313
#define Data1_IHTMLFrameElement2           0x3050f7f5
#define Data1_IElementNamespacePrivate     0x3050f7ff
#define Data1_IInternetSecurityMgrSite     0x79eac9ed
#define Data1_IInternetSecurityManager     0x79eac9ee
#define Data1_ITargetFramePriv             0x9216E421
#define Data1_IUrlHistoryNotify            0xbc40bec1 
#define Data1_IElementNamespaceFactory2    0x3050f805
#define Data1_IHTMLCommentElement          0x3050f20c
#define Data1_IHTMLCommentElement2         0x3050f813
#define Data1_IHTMLDOMImplementation       0x3050f80d
#define Data1_IHTMLHtmlElement             0x3050f81c
#define Data1_IHTMLHeadElement             0x3050f81d
#define Data1_IHTMLMetaElement             0x3050f203
#define Data1_IHTMLMetaElement2            0x3050f81f
#define Data1_IHTMLTableSection            0x3050f23b
#define Data1_IHTMLTableSection2           0x3050f5c7
#define Data1_IHTMLTableSection3           0x3050f82b
#define Data1_IHTMLOptionElement           0x3050f211
#define Data1_IHTMLOptionElement3          0x3050f820
#define Data1_IHTMLTableCell               0x3050f23d
#define Data1_IHTMLTableCell2              0x3050f82d
#define Data1_IHTMLListElement             0x3050f20e
#define Data1_IHTMLListElement2            0x3050f822
#define Data1_IHTMLBlockElement            0x3050f208
#define Data1_IHTMLBlockElement2           0x3050f823
#define Data1_IHTMLPhraseElement           0x3050f20a
#define Data1_IHTMLPhraseElement2          0x3050f824
#define Data1_IHTMLImgElement2             0x3050f826
#define Data1_IHTMLScriptElement2          0x3050f828
#define Data1_IHTMLTableCol                0x3050f23a
#define Data1_IHTMLTableCol2               0x3050f82a
#define Data1_IHTMLIsIndexElement          0x3050f206
#define Data1_IHTMLIsIndexElement2         0x3050f82f
#define Data1_IHTMLLabelElement            0x3050f32a
#define Data1_IHTMLLabelElement2           0x3050f832
#define Data1_IHTMLLegendElement           0x3050f3ea
#define Data1_IHTMLLegendElement2          0x3050f834
#define Data1_IHTMLFieldSetElement         0x3050f3e7
#define Data1_IHTMLFieldSetElement2        0x3050f833
#define Data1_IHTMLTextContainer           0x3050f230
#define Data1_IEnumPrivacyRecords          0x3050f844

#if DBG==1
#define Data1_IDebugWindowProxy            0x3050f592
#define Data1_IDebugWindow                 0x3050f593
#endif


#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        *ppv = (itf *)pObj;                 \
        }                                   \
        break;                              \

#define QI_INHERITS2(pObj, itf, itfDerived) \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        *ppv = (itfDerived *)pObj;          \
        }                                   \
        break;                              \

#define QI_TEAROFF(pObj, itf, pUnkOuter)    \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        HRESULT hr = CreateTearOffThunk(    \
            pObj,                           \
            (void *)pObj->s_apfn##itf,      \
            pUnkOuter,                      \
            ppv);                           \
        if (hr)                             \
            RRETURN(hr);                    \
        }                                   \
        break;                              \

#define QI_TEAROFF2(pObj, itf, itfDerived, pUnkOuter) \
    case Data1_##itf:                                 \
        if (iid == IID_##itf)                         \
        {                                             \
        HRESULT hr = CreateTearOffThunk(              \
            pObj,                                     \
            (void *)pObj->s_apfn##itfDerived,         \
            pUnkOuter,                                \
            ppv);                                     \
        if (hr)                                       \
            RRETURN(hr);                              \
        }                                             \
        break;                                        \

#define QI_HTML_TEAROFF(pObj, itf, pUnkOuter)    \
    case Data1_##itf:                       \
        if (iid == IID_##itf)               \
        {                                   \
        HRESULT hr = CreateTearOffThunk(    \
            pObj,                           \
            (void *)pObj->s_apfnpd##itf,    \
            pUnkOuter,                      \
            ppv,                            \
            (void *)s_ppropdescsInVtblOrder##itf);                 \
        if (hr)                             \
            RRETURN(hr);                    \
        }                                   \
        break;                              \


extern const IID * const g_apIID_IDispatchEx[];

#define QI_TEAROFF_DISPEX(pObj, pUnkOuter) \
    case Data1_IDispatch:                             \
    case Data1_IDispatchEx:                           \
        if (iid == IID_IDispatch || iid == IID_IDispatchEx)\
        {                                             \
        HRESULT hr = CreateTearOffThunk(              \
            pObj,                                     \
            pObj->s_apfnIDispatchEx,                 \
            pUnkOuter,                                \
            ppv,                                      \
            NULL,                                     \
            NULL,                                     \
            0,                                        \
            g_apIID_IDispatchEx);                     \
        if (hr)                                       \
            RRETURN(hr);                              \
        }                                             \
        break;                                        \

#define QI_FALLTHRU(itfName1__, itfName2__) case Data1_##itfName1__: if (iid == IID_##itfName1__) goto handle_##itfName2__; else break; 
#define QI_CASE(itfName__) case Data1_##itfName__: if (iid == IID_##itfName__) goto handle_##itfName__; else break; handle_##itfName__: ;

#pragma INCMSG("--- End 'qi_impl.h'")
#else
#pragma INCMSG("*** Dup 'qi_impl.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\privcid.h ===
#ifndef I_PRIVCID_H_
#define I_PRIVCID_H_
#ifndef RC_INVOKED
#pragma INCMSG("--- Beg 'privcid.h'")
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include "mshtmcid.h"
#endif

//----------------------------------------------------------------------------
//
// Private Command IDs.
//
//----------------------------------------------------------------------------

#define IDM_TABKEY                  6000
#define IDM_SHTABKEY                6001
#define IDM_RETURNKEY               6002
#define IDM_ESCKEY                  6003

#if DBG == 1
// dependencies - shdocvw\resource.h
#define IDM_DEBUG_TRACETAGS         6004
#define IDM_DEBUG_RESFAIL           6005
#define IDM_DEBUG_DUMPOTRACK        6006
#define IDM_DEBUG_BREAK             6007
#define IDM_DEBUG_VIEW              6008
#define IDM_DEBUG_DUMPTREE          6009
#define IDM_DEBUG_DUMPLINES         6010
#define IDM_DEBUG_LOADHTML          6011
#define IDM_DEBUG_SAVEHTML          6012
#define IDM_DEBUG_MEMMON            6013
#define IDM_DEBUG_METERS            6014
#define IDM_DEBUG_DUMPDISPLAYTREE   6015
#define IDM_DEBUG_DUMPFORMATCACHES  6016
#define IDM_DEBUG_DUMPLAYOUTRECTS   6017
#define IDM_DEBUG_DUMPRECALC        6018
#endif

// IE4 Shdocvw Messages

#define IDM_SHDV_FINALTITLEAVAIL         6020
#define IDM_SHDV_MIMECSETMENUOPEN        6021
#define IDM_SHDV_PRINTFRAME              6022
#define IDM_SHDV_PUTOFFLINE              6022
#define IDM_SHDV_GOBACK                  6024   // different from IDM_GOBACK
#define IDM_SHDV_GOFORWARD               6025   // different from ISM_GOFORWARD
#define IDM_SHDV_CANGOBACK               6026
#define IDM_SHDV_CANGOFORWARD            6027
#define IDM_SHDV_CANSUPPORTPICS          6028
#define IDM_SHDV_CANDEACTIVATENOW        6029
#define IDM_SHDV_DEACTIVATEMENOW         6030
#define IDM_SHDV_NODEACTIVATENOW         6031
#define IDM_SHDV_SETPENDINGURL           6032
#define IDM_SHDV_ISDRAGSOURCE            6033
#define IDM_SHDV_DOCFAMILYCHARSET        6034
#define IDM_SHDV_DOCCHARSET              6035
#define IDM_SHDV_GETMIMECSETMENU         6036
#define IDM_SHDV_CANDOCOLORSCHANGE       6038
#define IDM_SHDV_ONCOLORSCHANGE                  6039

// Flavors of refresh

#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc

// placeholder for context menu extensions
#define IDM_MENUEXT_PLACEHOLDER          6047

// IE5 Webcheck messages
#define IDM_DWNH_SETDOWNLOAD             6048

// IE5 Shdocvw messages
#define IDM_ONPERSISTSHORTCUT            6050
#define IDM_SHDV_GETFONTMENU             6051
#define IDM_SHDV_FONTMENUOPEN            6052
#define IDM_SAVEASTHICKET                6053
#define IDM_SHDV_GETDOCDIRMENU           6054
#define IDM_SHDV_ADDMENUEXTENSIONS       6055
#define IDM_SHDV_PAGEFROMPOSTDATA        6056
#define IDM_SHDV_WINDOWOPEN              6057

#define IDM_GETSWITCHTIMERS              6998   // Used by MSHTMPAD for perf timings
#define IDM_WAITFORRECALC                6999   // Used by MSHTMPAD for perf timings

// JuliaC -- This is hack for InfoViewer's "Font Size" toolbar button
// For details, please see bug 45627
#define IDM_INFOVIEW_ZOOM                7000
#define IDM_INFOVIEW_GETZOOMRANGE        7001

#define IDM_ELEMENTP_SETREFERENCEMEDIA   7002   // set media on element

// IOleCommandTarget IDs
#define IDM_GETPUNKCONTROL               6048

// Reserve this range for Shdocvw's usage of CGID_DocHostCommandHandler
#define IDM_SHDOCVWDHCOMMAND_START       7050
#define IDM_SHDOCVWDHCOMMAND_END         7099

// Debug-only command for saving a document out to a stream
#if DBG==1
#define IDM_DEBUG_GETTREETEXT            7102
#endif

#ifndef RC_INVOKED
#pragma INCMSG("--- End 'privcid.h'")
#endif
#else
#ifndef RC_INVOKED
#pragma INCMSG("*** Dup 'privcid.h'")
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\f3debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
// File:      F3DEBUG.H
//
// Contains:  Debugging stuff for use in Forms^3
//            See CORE\DEBUG\F3DEBUG.TXT for more information.
//
//--------------------------------------------------------------------------

#ifndef I_F3DEBUG_H_
#define I_F3DEBUG_H_
#pragma INCMSG("--- Beg 'f3debug.h'")

#ifndef X_MSHTMDBG_H_
#define X_MSHTMDBG_H_
#pragma INCMSG("--- Beg <mshtmdbg.h>")
#include <mshtmdbg.h>
#pragma INCMSG("--- End <mshtmdbg.h>")
#endif

#ifndef X_MARKCODE_HXX_
#define X_MARKCODE_HXX_
#pragma INCMSG("--- Beg 'markcode.hxx'")
#include "markcode.hxx"
#pragma INCMSG("--- End 'markcode.hxx'")
#endif

//--------------------------------------------------------------------------
// Assert, Verify && WHEN_DBG
//--------------------------------------------------------------------------

#if defined(_M_IX86)
    #define F3DebugBreak() _asm { int 3 }
#else
    #define F3DebugBreak() DebugBreak()
#endif

#if DBG != 1 && HTMLPAD != 1

#define Verify(x)   x
#ifdef _PREFIX_
#define Assert(x) { if ( !(x) ) exit(1); }
#else
#define Assert(x)
#endif
#ifdef _PREFIX_
#define AssertSz(x, sz) { if ( !(x) ) exit(1); }
#else
#define AssertSz(x, sz)
#endif
#define Check(x)
#define CheckSz(x, sz)
#define IF_DBG(x)
#define WHEN_DBG(x)
#define IF_NOT_DBG(x) x
#define WHEN_NOT_DBG(x) x
#define StartupAssert(x)
#define AssertThreadDisable(fb)
#define DBG_COMMA


#else // #if DBG != 1

struct THREADSTATE;

#define AssertThreadDisable(fDisable)   DbgExAssertThreadDisable(fDisable)

extern DWORD g_dwFALSE;

#define Verify(x)       Assert(x)

// Note: For PREFIX runs, we need to make the compiler believe that we're going to exit upon a false Assert.
//       To do this, we redefine the Assert() and AssertSz() macros when _PREFIX_ is defined.
//

#ifdef _PREFIX_
#define Assert(x) { if ( !(x) ) exit(1); }
#else
#define Assert(x)       do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, #x)) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#ifdef _PREFIX_
#define AssertSz(x, sz) { if ( !(x) ) exit(1); }
#else
#define AssertSz(x, sz) do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, sz)) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#ifdef _PREFIX_
#define Check(x) 
#else
#define Check(x)       do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, #x) && DbgExIsFullDebug()) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#ifdef _PREFIX_
#define CheckSz(x, sz) 
#else
#define CheckSz(x, sz) do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, sz) && DbgExIsFullDebug()) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#endif

#define AssertLocSz(x, File, Line, sz)   do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(File, Line, sz)) {\
                               F3DebugBreak(); }} while (g_dwFALSE)
#define IF_DBG(x) x
#define WHEN_DBG(x) x
#define IF_NOT_DBG(x)
#define WHEN_NOT_DBG(x)
#define DBG_COMMA ,

//
// Startup assertion:
// The assertion is called by initializing a global variable with
// a function that performs the assertion and returns 1. The name
// of the global variable and function name are suffixed with the
// line number to make them unique. Unfortunatly, one cannot just
// write StartupAssert_##__LINE__, because __LINE__ is not an
// argument to the macro and so the expansion is, e.g. StartupAssert__##53.
// So we indirect through another macro which concatenates its
// two arguments.
//

#define concat_name(x, y) x##y
#define concat_line_impl(x, y) concat_name(x, y)
#define concat_LINE(x) concat_line_impl(x, __LINE__)

#define StartupAssert(x)                                                    \
static int                                                                  \
concat_LINE(StartupAssert_) ()                                              \
{                                                                           \
    Assert(x);                                                              \
    return 1;                                                               \
}                                                                           \
                                                                            \
static int concat_LINE(g_StartupAssert_) = concat_LINE(StartupAssert_)()    \

#endif // #if DBG != 1

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

#if DBG != 1 && HTMLPAD != 1
    #define TraceTag(x)
    #define TraceTagEx(x)
    #define TaggedTraceListEx(tag, usFlags, szFmt, valMarker)
    #define TraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescription)
    #define DeclareTagEx(tag, szOwner, szDescription, fEnabled)
    #define DeclareTagOther(tag, szOwner, szDescription)
    #define ExternTag(tag)
    #define IsTagEnabled(tag) FALSE
    #define EnableTag(tag, fEnable)
    #define SetDiskFlag(tag, fSendToDisk)
    #define SetBreakFlag(tag, fBreak)
    #define FindTag(szTagDesc) NULL
    #define PerfDbgTag(tag, szOwner, szDescrip) \
            PerfTag(tag, szOwner, szDescrip)
    #define PerfDbgTagOther(tag, szOwner, szDescrip) \
            PerfTag(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) \
            PerfExtern(tag)
    #define PerfDbgLog(tag,pv,f) PerfLog(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfLog1(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfLog2(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfLog3(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfLog4(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfLogFn x
    #define IsPerfDbgEnabled(tag) IsPerfEnabled(tag)

#else
    #define TraceTag(x)                         \
        do                                      \
        {                                       \
            if (TaggedTrace x) {                \
                F3DebugBreak();                 \
            }                                   \
        } while  (g_dwFALSE)

    #define TraceTagEx(x)                       \
        do                                      \
        {                                       \
            if (TaggedTraceEx x) {              \
                F3DebugBreak();                 \
            }                                   \
        } while  (g_dwFALSE)

    #define TraceCallers(tag, iStart, cTotal)   \
        TaggedTraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterTrace(szOwner, szDescrip, FALSE));
    #define DeclareTagEx(tag, szOwner, szDescrip, fEnabled) \
        TRACETAG tag(DbgExTagRegisterTrace(szOwner, szDescrip, fEnabled));
    #define DeclareTagOther(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterOther(szOwner, szDescrip, FALSE));
    #define ExternTag(tag) extern TRACETAG tag;
    #define PerfDbgTag(tag, szOwner, szDescrip) DeclareTag(tag, szOwner, szDescrip)
    #define PerfDbgTagOther(tag, szOwner, szDescrip) DeclareTagOther(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) ExternTag(tag)
    #define PerfDbgLog(tag,pv,f) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfDbgLogFn x
    #define IsPerfDbgEnabled(tag) IsTagEnabled(tag)

    int __cdecl PerfDbgLogFn(int tag, void * pvObj, char * pchFmt, ...);

    // Tag trace functions

    #define TaggedTrace         DbgExTaggedTrace
    #define TaggedTraceEx       DbgExTaggedTraceEx
    #define TaggedTraceListEx   DbgExTaggedTraceListEx
    #define TaggedTraceCallers  DbgExTaggedTraceCallers

    // TaggedTraceEx usFlags parameter defines

    #define TAG_NONAME      0x01
    #define TAG_NONEWLINE   0x02
    #define TAG_USECONSOLE  0x04
    #define TAG_INDENT      0x08
    #define TAG_OUTDENT     0x10

    // Register a new tag.

    // Standard tags
    #define tagError                DbgExTagError()
    #define tagWarning              DbgExTagWarning()
    #define tagThread               DbgExTagThread()
    #define tagAssertExit           DbgExTagAssertExit()
    #define tagAssertStacks         DbgExTagAssertStacks()
    #define tagMemoryStrict         DbgExTagMemoryStrict()
    #define tagCoMemoryStrict       DbgExTagCoMemoryStrict()
    #define tagMemoryStrictTail     DbgExTagMemoryStrictTail()
    #define tagMemoryStrictAlign    DbgExTagMemoryStrictAlign()
    #define tagOLEWatch             DbgExTagOLEWatch()
    #define tagPerf                 DbgExTagPerf()

    // Get/Set tag enabled status.

    #define IsTagEnabled            DbgExIsTagEnabled
    #define EnableTag               DbgExEnableTag
    #define SetDiskFlag             DbgExSetDiskFlag
    #define SetBreakFlag            DbgExSetBreakFlag
    #define FindTag                 DbgExFindTag

#endif

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#if DBG != 1 && HTMLPAD != 1

    #define DbgPreAlloc(cb)             cb
    #define DbgPostAlloc(pv)            pv
    #define DbgPreFree(pv)              pv
    #define DbgPostFree()
    #define DbgPreRealloc(pv, cb, ppv)  cb
    #define DbgPostRealloc(pv)          pv
    #define DbgPreGetSize(pv)           pv
    #define DbgPostGetSize(cb)          cb
    #define DbgPreDidAlloc(pv)          pv
    #define DbgPostDidAlloc(pv, fAct)   fAct

    #define DbgMemoryTrackDisable(fb)
    #define DbgCoMemoryTrackDisable(fb)
    #define DbgMemoryBlockTrackDisable(pv)

    #define CHECK_HEAP()

#else

    #define DbgPreAlloc                 DbgExPreAlloc
    #define DbgPostAlloc                DbgExPostAlloc
    #define DbgPreFree                  DbgExPreFree
    #define DbgPostFree                 DbgExPostFree
    #define DbgPreRealloc               DbgExPreRealloc
    #define DbgPostRealloc              DbgExPostRealloc
    #define DbgPreGetSize               DbgExPreGetSize
    #define DbgPostGetSize              DbgExPostGetSize
    #define DbgPreDidAlloc              DbgExPreDidAlloc
    #define DbgPostDidAlloc             DbgExPostDidAlloc

    #define DbgMemoryTrackDisable       DbgExMemoryTrackDisable
    #define DbgCoMemoryTrackDisable     DbgExCoMemoryTrackDisable
    #define DbgMemoryBlockTrackDisable  DbgExMemoryBlockTrackDisable

    //
    // Use the CHECK_HEAP macro to do thorough heap validation.
    //
    BOOL CheckSmallBlockHeap();
    void WINAPI DbgExCheckHeap();
    #define CHECK_HEAP()                DbgExCheckHeap();

#endif


//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#if DBG == 1 || HTMLPAD == 1
    #define DbgTrackItf     DbgExTrackItf
#else
    #define DbgTrackItf(iid, pch, fTrackOnQi, ppv)
#endif

//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#if (DBG == 1 || HTMLPAD == 1) && defined(__cplusplus)

#define SetSimFailCounts    DbgExSetSimFailCounts
#define GetFailCount        DbgExGetFailCount
#define TraceFailL          DbgExTraceFailL
#define TraceWin32L         DbgExTraceWin32L
#define TraceHR             DbgExTraceHR
#define TraceOLE            DbgExTraceOLE
#define TraceEnter          DbgExTraceEnter
#define TraceExit           DbgExTraceExit

template <class t> inline t
TraceFail(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceFailL((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

template <class t> inline t
TraceWin32(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceWin32L((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

// disabled TraceEnter, we don't need it at this time
#undef TraceEnter
#define TraceEnter(x, y, z) NULL

#define TFAIL(e, x)             (TraceEnter(#x, __FILE__, __LINE__), TraceFail( (x), (e), FALSE, #x, __FILE__, __LINE__))
#define TW32(e, x)              (TraceEnter(#x, __FILE__, __LINE__), TraceWin32((x), (e), FALSE, #x, __FILE__, __LINE__))
#define THR(x)                  (TraceEnter(#x, __FILE__, __LINE__), TraceHR((x), FALSE, #x, __FILE__, __LINE__))

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (TraceEnter(#x, __FILE__, __LINE__), (void) TraceFail((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_W32(e,x)         (TraceEnter(#x, __FILE__, __LINE__), (void) TraceWin32((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_HR(x)            (TraceEnter(#x, __FILE__, __LINE__), (void) TraceHR((x), TRUE, #x, __FILE__, __LINE__))

#else // #if DBG == 1

#define SetSimFailCounts(firstFailure, cInterval)

#define TFAIL(e, x)             (x)
#define TW32(e, x)              (x)
#define THR(x)                  (x)

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (x)
#define IGNORE_W32(e,x)         (x)
#define IGNORE_HR(x)            (x)

#endif // #if DBG == 1

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#if DBG == 1 || HTMLPAD == 1

    #define SRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, -1)
    #define RRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 0)
    #define RRETURN1(hr, s1) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

    #define SRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, -1)
    #define RRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 0)
    #define RRETURN1_NOTRACE(hr, s1) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2_NOTRACE(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3_NOTRACE(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

#else   // DBG == 0

    #define SRETURN(hr)                 return (hr)
    #define RRETURN(hr)                 return (hr)
    #define RRETURN1(hr, s1)            return (hr)
    #define RRETURN2(hr, s1, s2)        return (hr)
    #define RRETURN3(hr, s1, s2, s3)    return (hr)
    #define RRETURN4(hr, s1, s2, s3, s4)return (hr)

    #define SRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN1_NOTRACE(hr, s1)            return (hr)
    #define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
    #define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4)return (hr)

#endif  // DBG

//+-------------------------------------------------------------------------
//  Stack Spew
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

#pragma INCMSG("--- End 'f3debug.h'")
#else
#pragma INCMSG("*** Dup 'f3debug.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\uwininet.h ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       uwininet.h
//
//  Contents:   Redefinitions of unicode versions of some Wininet APIs
//              which are declared incorrectly in wininet.h and unimplemented
//              in wininet.dll.
//
//              Note that this workaround doesn't solve the whole problem
//              since INTERNET_CACHE_ENTRY_INFO contains a non-unicode
//              lpszSourceUrlName which too much trouble to convert in our
//              wrapper (at any rate, we don't use it).
//
//----------------------------------------------------------------------------

#ifndef I_UWININET_H_
#define I_UWININET_H_
#pragma INCMSG("--- Beg 'uwininet.h'")

#ifndef X_WININET_H_
#define X_WININET_H_
#pragma INCMSG("--- Beg <wininet.h>")
#define _WINX32_
#include <wininet.h>
#pragma INCMSG("--- End <wininet.h>")
#endif

// to get all the defs, winineti.h requires wincrypt.h be included before it!
#ifndef X_WINCRYPT_H
#define X_WINCRYPT_H
#pragma INCMSG("--- Beg <wincrypt.h>")
#include "wincrypt.h"
#pragma INCMSG("--- End <wincrypt.h>")
#endif

#ifndef X_WININETI_H_
#define X_WININETI_H_
#pragma INCMSG("--- Beg <winineti.h>")
#define _WINX32_
#include <winineti.h>
#pragma INCMSG("--- End <winineti.h>")
#endif

#define DATE_STR_LENGTH 30

#define LPCBYTE         const BYTE *


// urlmon unicode wrapper for ansi api
STDAPI ObtainUserAgentStringW(DWORD dwOption, LPWSTR lpszUAOut, DWORD* cbSize);

//
//  Wrap CreateUrlCacheEntry
//--------------------------------------------------
URLCACHEAPI_(BOOL) CreateUrlCacheEntryBugW ( IN LPCWSTR lpszUrlName, 
                       IN DWORD dwFileSize, 
                       IN LPCWSTR lpszExtension, 
                       OUT LPWSTR lpszFileName, 
                       IN DWORD dwRes);

#undef CreateUrlCacheEntry  
#ifdef UNICODE
#define CreateUrlCacheEntry CreateUrlCacheEntryBugW
#else
#define CreateUrlCacheEntry CreateUrlCacheEntryA
#endif

//
// Wrap CommitUrlCachEntry
//--------------------------------------------------

URLCACHEAPI_(BOOL) CommitUrlCacheEntryBugW ( 
                       IN LPCWSTR  lpszUrlName,
                       IN LPCWSTR  lpszLocalFileName,
                       IN FILETIME ExpireTime,
                       IN FILETIME LastModifiedTime,
                       IN DWORD    dwCachEntryType,
                       IN LPCBYTE  lpHeaderInfo,
                       IN DWORD    dwHeaderSize,
                       IN LPCWSTR  lpszFileExtension,
                       IN DWORD    dwReserved);

#undef CommitUrlCacheEntry
#ifdef UNICODE  
#define CommitUrlCacheEntry CommitUrlCacheEntryBugW
#else
#define CommitUrlCacheEntry CommitUrlCacheEntryA
#endif




URLCACHEAPI_(BOOL) GetUrlCacheEntryInfoBugW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );

#undef GetUrlCacheEntryInfo // remove the buggy version

#ifdef UNICODE
#define GetUrlCacheEntryInfo GetUrlCacheEntryInfoBugW
#else
#define GetUrlCacheEntryInfo GetUrlCacheEntryInfoA
#endif // !UNICODE


// Same Problem here

BOOLAPI GetUrlCacheEntryInfoExBugW(
	IN LPCWSTR lpszUrl,
	OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
	IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
	OUT LPSTR lpszRedirectUrl,
	IN OUT LPDWORD lpdwRedirectUrlBufSize,
	LPVOID lpReserved,
	DWORD dwReserved
);

#undef GetUrlCacheEntryInfoEx // remove the buggy version

#ifdef UNICODE
#define GetUrlCacheEntryInfoEx GetUrlCacheEntryInfoExBugW
#else
#define GetUrlCacheEntryInfoEx GetUrlCacheEntryInfoExA
#endif // !UNICODE

// Same problem here
URLCACHEAPI_(BOOL) SetUrlCacheEntryInfoBugW(
    IN LPCWSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );

#undef SetUrlCacheEntryInfo 

#ifdef UNICODE
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoBugW
#else
#define SetUrlCacheEntryInfo  SetUrlCacheEntryInfoA
#endif // !UNICODE

// again, but worse...
BOOL
WINAPI
DeleteUrlCacheEntryBugW(LPCWSTR lpszUrlName);

BOOL
WINAPI
DeleteUrlCacheEntryA(LPCSTR lpszUrlName);

#undef DeleteUrlCacheEntry

#ifdef UNICODE
#define DeleteUrlCacheEntry  DeleteUrlCacheEntryBugW
#else
#define DeleteUrlCacheEntry  DeleteUrlCacheEntryA
#endif // !UNICODE


// Get/Set helpers for URL components.
enum URLCOMP_ID
{
    URLCOMP_HOST,
    URLCOMP_HOSTNAME,
    URLCOMP_PATHNAME,
    URLCOMP_PORT,
    URLCOMP_PROTOCOL,
    URLCOMP_SEARCH,
    URLCOMP_HASH,
    URLCOMP_WHOLE
};

UINT GetUrlScheme(const TCHAR * pchUrlIn);

BOOL IsURLSchemeCacheable(UINT uScheme);

BOOL IsUrlSecure(const TCHAR * pchUrl);

HRESULT GetUrlComponentHelper(const TCHAR * pchUrlIn,
                      CStr *        pstrComp,
                      DWORD         dwFlags,
                      URLCOMP_ID    ucid,
                      BOOL          fUseOmLocationFormat = FALSE);
HRESULT SetUrlComponentHelper(const TCHAR * pchUrlIn,
                      TCHAR *       pchUrlOut,
                      DWORD         dwBufLen,
                      const BSTR *  pstrComp,
                      URLCOMP_ID    ucid);
HRESULT ComposeUrl(SHURL_COMPONENTS * puc,
                   DWORD              dwFlags,
                   TCHAR            * pchUrlOut,
                   DWORD            * pdwSize);

//Other helper routines and wininetapi wrappers
HRESULT ConvertDateTimeToString(FILETIME Time, 
                               BSTR * pchDateStr, 
                               BOOL   fReturnTime);


//GetDateFormat is UNICODE on NT ONLY
int 
WINAPI
GetDateFormat_BugW(LCID Locale, 
              DWORD dwFlags, 
              CONST SYSTEMTIME * lpDate, 
              LPCTSTR lpFormat,
              LPTSTR lpDateStr, 
              int cchDate);
#undef GetDateFormat
#ifdef UNICODE
#define GetDateFormat GetDateFormat_BugW
#else
#define GetDateFormat GetDateFormatA
#endif // !UNICODE


//GetTimeFormat is UNICODE on NT ONLY
int 
WINAPI
GetTimeFormat_BugW(LCID Locale, 
              DWORD dwFlags, 
              CONST SYSTEMTIME * lpTime, 
              LPCTSTR lpFormat,
              LPTSTR lpTimeStr, 
              int cchDate);
#undef GetTimeFormat
#ifdef UNICODE
#define GetTimeFormat GetTimeFormat_BugW
#else
#define GetTimeFormat GetTimeFormatA
#endif // !UNICODE

URLCACHEAPI_(BOOL) RetrieveUrlCacheEntryFileBugW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    );

#undef RetrieveUrlCacheEntryFile // remove the buggy version

#ifdef UNICODE
#define RetrieveUrlCacheEntryFile RetrieveUrlCacheEntryFileBugW
#else
#define RetrieveUrlCacheEntryFile RetrieveUrlCacheEntryFileA
#endif // !UNICODE

#ifdef DLOAD1
#define UWININET_EXTERN_C extern "C"
#else
#define UWININET_EXTERN_C
#endif

// These are exported but not defined in any header file. (cthrash)
#ifdef UNICODE
#ifdef DLOAD1

// NOTE: Unicode version doesn't exist in WININET.DLL
//       The function definition does not correspond to the export.
//       If it actually works, it is a miracle.
UWININET_EXTERN_C
INTERNETAPI_(BOOL) InternetGetCertByURL(LPCWSTR lpszURL,
                     LPWSTR lpszCertText,
                     DWORD dwcbCertText);

#else

UWININET_EXTERN_C
BOOLAPI InternetGetCertByURLW(LPCWSTR lpszURL,
                      LPWSTR lpszCertText,
                      DWORD dwcbCertText);

#define InternetGetCertByURL InternetGetCertByURLW

#endif // DLOAD1
#else

UWININET_EXTERN_C
BOOLAPI InternetGetCertByURLA(LPCSTR lpszURL,
                      LPSTR lpszCertText,
                      DWORD dwcbCertText);

#define InternetGetCertByURL InternetGetCertByURLA

#endif //UNICODE

URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFileBugW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwReserved
    );

#undef UnlockUrlCacheEntryFile // remove the buggy version

#ifdef UNICODE
#define DoUnlockUrlCacheEntryFile UnlockUrlCacheEntryFileBugW
#else
#define DoUnlockUrlCacheEntryFile UnlockUrlCacheEntryFileA
#endif

HRESULT ShortCutSetUrlHelper(const TCHAR * pchUrlIn,
                             TCHAR       * pchUrlOut,
                             DWORD         dwBufLen,
                             const BSTR  * pstrComp,
                             URLCOMP_ID    ucid,
                             BOOL          fUseOmLocationFormat = FALSE);

#pragma INCMSG("--- End 'uwininet.h'")
#else
#pragma INCMSG("*** Dup 'uwininet.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\coreid.c ===
/*
   coreid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#define INCMSG(x)

#include <coreguid.h>
// NOTE: oleacc.h contains a whole bunch of guids which all are 
// being loaded.  
// CONSIDER: Copying out only guids that we need and put in here.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\dbuuid.c ===
/*
   dbuuid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// I copied the following lines from <oledb.h> to get the definition
// of LPOLESTR.  Surely we don't need all of them.
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

//+----------------------------------------------------------------------------
//
//  File:       dbuuid.c
//
//  Synopsis:   IIDs gleaned from the OLE-DB libs. We need to have it
//              in source form for Lego and the Mac folks.  We also pull out
//              of oledb.h only those special GUIDS which we need.
//
//  Comment:    This is from dbuuid.lib
//
//-----------------------------------------------------------------------------

DEFINE_GUID(IID_IRowsetAsynch,                         0x0c733a0f, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowsetNewRowAfter,                    0x0c733a71, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);

DEFINE_GUID(DBCOL_SPECIALCOL,                          0xc8b52232, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
DEFINE_GUID(DBPROPSET_ROWSET,                          0xc8b522be, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);

// IID used by ICursor-consuming controls
DEFINE_GUID(IID_IRowCursor,                            0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x00, 0xaa, 0x00, 0x3c, 0x9c, 0xb6);

DEFINE_GUID(IID_IVBDSC,                                0x1ab42240, 0x8c70, 0x11ce, 0x94, 0x21, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// GUIDs for IRowPosition family
DEFINE_GUID(CLSID_CRowPosition,                        0x2048eee6,0x7fa2,0x11d0,0x9e,0x6a,0x00,0xa0,0xc9,0x13,0x8c,0x29);

// GUIDS for ADO
#define DEFINE_DAOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)
DEFINE_DAOGUID(IID_IADORecordsetConstruction,     0x00000283);
DEFINE_DAOGUID(CLSID_CADORecordset,      0x00000535);
DEFINE_DAOGUID(IID_IADORecordset15,		 0x0000050E);

// GUIDS for CurrentRecord
DEFINE_GUID(IID_ICurrentRecordInstance,                0x3050f328,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);

// GUIDS for data source interfaces
DEFINE_GUID(IID_IDATASRCListener,                      0x3050f380,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(IID_DataSourceListener,                    0x7c0ffab2,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);
DEFINE_GUID(IID_DataSource,                            0x7c0ffab3,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\coreidpr.c ===
/*
   coreidpr.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
#define INCMSG(x)
#include <coreguid.h>

DEFINE_GUID(IID_IProvideMultipleClassInfo,
    0xA7ABA9C1,0x8983,0x11CF,0x8F,0x20,0x00,0x80,0x5F,0x2C,0xD0,0x64);
DEFINE_GUID(IID_IPersistPropertyBag2,
    0x22F55881,0x280B,0x11d0,0xA8,0xA9,0x00,0xA0,0xC9,0x0C,0x20,0x04);
DEFINE_GUID(IID_IPropertyBag2,
    0x22F55882,0x280B,0x11d0,0xA8,0xA9,0x00,0xA0,0xC9,0x0C,0x20,0x04);
DEFINE_GUID(IID_IActiveDesigner,
    0x51AAE3E0,0x7486,0x11CF,0xA0,0xC2,0x00,0xAA,0x00,0x62,0xBE,0x57);

DEFINE_GUID(CLSID_Mshtmled,
    0x3050f494,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(IID_IScriptletConstructor, 
	0xc265fb00,0x9fa4,0x11d1,0x89,0xb6,0x00,0x60,0x08,0xc3,0xfb,0xfc);
DEFINE_GUID(CLSID_ScriptletConstructor,
    0x21617250,0xa071,0x11d1,0x89,0xb6,0x00,0x60,0x08,0xc3,0xfb,0xfc);
DEFINE_GUID(IScriptletHandlerConstructor,
    0xa3d52a50,0xb7ff,0x11d1,0xa3,0x5a,0x00,0x60,0x08,0xc3,0xfb,0xfc);
DEFINE_GUID(SID_SEditCommandTarget,
    0x3050f4b5,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(CGID_EditStateCommands,
    0x3050f4b6,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(IID_IThumbnailView,
    0x7bb0b520,0xb1a7,0x11d2,0xbb,0x23,0x0,0xc0,0x4f,0x79,0xab,0xcd);
DEFINE_GUID(IID_IRenMailEditor,
    0x000670ba,0x0000,0x0000,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46);
DEFINE_GUID(CLSID_HTMLServerDoc,
    0x3050f4e7,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(SID_SHTMLEditServices,
    0x3050f7f9,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);
DEFINE_GUID(CLSID_HTMLEditor,
    0x3050f4f5,0x98b5,0x11cf,0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b);    
DEFINE_GUID(IID_IHTMLEditorViewManager,
    0x53A2D5B0,0xD2FC,0x11D0,0x84,0xE0,0x00,0x60,0x97,0xC9,0x98,0x7D);
DEFINE_GUID(SID_SHTMLEditorViewManager,
    0x53A2D5B1,0xD2FC,0x11D0,0x84,0xE0,0x00,0x60,0x97,0xC9,0x98,0x7D);
DEFINE_GUID(IID_IRenVersionCheck, 
    0X3F9DF312,0X78EE,0X11D2,0X83,0XB9,0X0,0X60,0XB0,0XEC,0XD,0XFF);
DEFINE_GUID(IID_IXMLViewerIdentity, 
    0xcc0baf51,0x3321,0x11d2,0xae,0x28,0x00,0x80,0xc7,0x33,0x7e,0xa1);
DEFINE_GUID(SID_DefView,
    0x6D12FE80,0x7911,0x11CF,0x95,0x34,0x00,0x00,0xC0,0x5B,0xAE,0x0B);
DEFINE_GUID(SID_SHTMEDDesignerHost,
    0xAD7F6C62,0xF6BD,0x11d2,0x95,0x9b,0x00,0x60,0x97,0xc5,0x53,0xc8);
DEFINE_GUID(SID_SMenuBandHandler,           
    0xd14e31c, 0xd8c0, 0x11d0, 0x98,0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
DEFINE_GUID(SID_SMarsPanel,
    0x24ec0ae8,0x734e,0x4c18,0xb1,0x91,0x6d,0x3b,0xf1,0xd9,0x41,0x3b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\docobj.c ===
/*
   docobj.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#include <windef.h>
#include <basetyps.h>
#include "urlhist.h"   

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//+----------------------------------------------------------------------------
//
//  File:       docobj.c
//
//  Synopsis:   IIDs gleaned from the Sterling libs. We need to have it
//              in source form for Lego and the Mac folks.
//
//  Comment:    This is from docobj.lib
//
//-----------------------------------------------------------------------------

DEFINE_GUID(IID_IMsoMailEditor,            0xb722bcce, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IMsoMailSite,              0xb722bccd, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);

DEFINE_GUID(IID_IMsoFormSite,              0xb722bccc, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleCommandTarget,         0xb722bccb, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IPrint,                    0xb722bcc9, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IContinueCallback,         0xb722bcca, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IEnumOleDocumentViews,     0xb722bcc8, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleDocumentView,          0xb722bcc6, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleDocumentSite,          0xb722bcc7, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
DEFINE_GUID(IID_IOleDocument,              0xb722bcc5, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
//TODO -- Nuke when the build is switched to the NT build -- BharatS
DEFINE_GUID(SID_STopLevelBrowser,         0x4C96BE40L, 0x915C, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);


DEFINE_GUID(IID_IDummy,                    0xb722bcc4, 0x4e68, 0x101b, 0xA2, 0xBC, 0x00, 0xAA, 0x00, 0x40, 0x47, 0x70);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\multimon.c ===
#include <windows.h>

#include "markcode.hxx"
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//=============================================================================
//
// This file defines the MULTIMON stub module that fakes multiple monitor 
// apis on pre Memphis Win32 OSes
// this is the only file that defines COMPILE_MULTIMON_STUBS 
//=============================================================================

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\wrapfns.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapfns.h
//
//  Contents:   The list of Unicode functions wrapped for Win95.  Each
//              wrapped function should listed in alphabetical order with
//              the following format:
//
//      STRUCT_ENTRY(FunctionName, ReturnType, (Param list with args), (Argument list))
//
//              For example:
//
//      STRUCT_ENTRY(RegisterClass, ATOM, (CONST WNDCLASSW * pwc), (pwc))
//
//      For functions which return void, use the following:
//
//      STRUCT_ENTRY_VOID(FunctionName, (Param list with args), (Argument list))
//
//      For functions which do no conversions, use STRUCT_ENTRY_NOCONVERT
//      and STRUCT_ENTRY_VOID_NOCONVERT
//
//----------------------------------------------------------------------------


#ifndef NOOVERRIDE
#undef ChooseColor
#define ChooseColor __ChooseColor
STRUCT_ENTRY_NOCONVERT2(ChooseColor, BOOL, (LPCHOOSECOLORW lpcc), (lpcc))
#else
STRUCT_ENTRY_NOCONVERT(ChooseColor, BOOL, (LPCHOOSECOLORW lpcc), (lpcc))
#endif

#ifndef NOOVERRIDE
#undef ChooseFont
#define ChooseFont __ChooseFont
STRUCT_ENTRY2(ChooseFont, BOOL, (LPCHOOSEFONTW lpcf), (lpcf))
#else
STRUCT_ENTRY(ChooseFont, BOOL, (LPCHOOSEFONTW lpcf), (lpcf))
#endif

#if DBG==1
STRUCT_ENTRY_NOCONVERT(LoadLibrary, HINSTANCE, (LPCWSTR lpsz), (lpsz))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\wrapdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapdefs.h
//
//  Contents:   Definitions of variables and functions required for wrapping
//              functions where there are differences between Windows95 and
//              Windows NT.
//
//              If you want to add your own wrapped function, see the
//              directions in wrapfns.h.
//----------------------------------------------------------------------------

#ifndef I_WRAPDEFS_HXX_
#define I_WRAPDEFS_HXX_
#pragma INCMSG("--- Beg 'wrapdefs.h'")

// define some other languages until ntdefs.h catches up
#ifndef LANG_YIDDISH
#define LANG_YIDDISH      0x3d       
#endif
#ifndef LANG_MONGOLIAN
#define LANG_MONGOLIAN    0x50       // Mongolia
#endif
#ifndef LANG_TIBETAN
#define LANG_TIBETAN      0x51       // Tibet
#endif
#ifndef LANG_KHMER
#define LANG_KHMER        0x53       // Cambodia
#endif
#ifndef LANG_LAO
#define LANG_LAO          0x54       // Laos
#endif
#ifndef LANG_BURMESE
#define LANG_BURMESE      0x55       // Burma/Myanmar
#endif
#ifndef LANG_MANIPURI
#define LANG_MANIPURI     0x58       
#endif
#ifndef LANG_SINDHI
#define LANG_SINDHI       0x59
#endif
#ifndef LANG_SYRIAC
#define LANG_SYRIAC       0x5a
#endif
#ifndef LANG_SINHALESE
#define LANG_SINHALESE    0x5b      // Sinhalese - Sri Lanca
#endif
#ifndef LANG_KASHMIRI
#define LANG_KASHMIRI     0x60       
#endif
#ifndef LANG_NAPALI
#define LANG_NAPALI       0x61       
#endif
#ifndef LANG_PASHTO
#define LANG_PASHTO       0x63       
#endif


extern DWORD g_dwPlatformID;        // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
extern DWORD g_dwPlatformVersion;   // (dwMajorVersion << 16) + (dwMinorVersion)
extern BOOL  g_fUnicodePlatform;
extern BOOL  g_fTerminalServer;     // TRUE if running under NT Terminal Server, FALSE otherwise
extern BOOL  g_fTermSrvClientSideBitmaps; // TRUE if TS supports client-side bitmaps
extern BOOL  g_fNLS95Support;
extern BOOL  g_fFarEastWin9X;
extern BOOL  g_fFarEastWinNT;
extern BOOL  g_fExtTextOutWBuggy;
extern BOOL  g_fExtTextOutGlyphCrash;
extern BOOL  g_fBidiSupport;        // COMPLEXSCRIPT
extern BOOL  g_fComplexScriptInput;
extern BOOL  g_fMirroredBidiLayout;

void InitUnicodeWrappers();
UINT GetLatinCodepage();            // Most likely 1252
HRESULT DoFileDownLoad(const TCHAR * pchHref);

#if defined(_M_IX86) && !defined(WINCE)
    #define USE_UNICODE_WRAPPERS 1
#else
    #define USE_UNICODE_WRAPPERS 0
#endif

BOOL IsTerminalServer();


//+------------------------------------------------------------------------
//
// Returns the global function pointer for a unicode function.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1
    #define UNICODE_FN(fn)  g_pufn##fn
#else
    #define UNICODE_FN(fn)  fn
#endif

//+------------------------------------------------------------------------
//
// Turn off warnings from dllimport.
//
//-------------------------------------------------------------------------
BOOL IsFarEastLCID( LCID lcid );
BOOL IsBidiLCID( LCID lcid ); // COMPLEXSCRIPT
BOOL IsComplexLCID( LCID lcid );

#ifndef BYPASS_UNICODE_WRAPPERS

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#define _SHELL32_
#define _SHDOCVW_
#pragma INCMSG("--- Beg <shellapi.h>")
#include <shellapi.h>
#pragma INCMSG("--- End <shellapi.h>")
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#pragma INCMSG("--- Beg <commctrl.h>")
#include <commctrl.h>
#pragma INCMSG("--- End <commctrl.h>")
#endif

#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#pragma INCMSG("--- Beg <comctrlp.h>")
#include <comctrlp.h>
#pragma INCMSG("--- End <comctrlp.h>")
#endif

#ifndef X_INTSHCUT_H_
#define X_INTSHCUT_H_
#define _INTSHCUT_
#pragma INCMSG("--- Beg <intshcut.h>")
#include <intshcut.h>
#pragma INCMSG("--- End <intshcut.h>")
#endif

#endif

//+------------------------------------------------------------------------
//
//  Declaration of global function pointers to unicode or wrapped functions.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY2(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;
        
#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs) \
        extern void (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_NOCONVERT2(FnName, FnType, FnParamList, FnArgs) \
        extern FnType (__stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs) \
        extern void (__stdcall *g_pufn##FnName) FnParamList;

#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY2
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_NOCONVERT2
#undef STRUCT_ENTRY_VOID_NOCONVERT

#endif


//+------------------------------------------------------------------------
//
//  Define inline functions which call functions in the table. The
//  functions are defined from entries in wrapfns.h.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1 && !defined(BYPASS_UNICODE_WRAPPERS)

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall FnName FnParamList {return (*g_pufn##FnName) FnArgs;}
#define STRUCT_ENTRY2(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall __##FnName FnParamList {return (*g_pufn##FnName) FnArgs;}

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs) \
        inline void __stdcall FnName FnParamList {(*g_pufn##FnName) FnArgs;}

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall FnName FnParamList {return (*g_pufn##FnName) FnArgs;}
#define STRUCT_ENTRY_NOCONVERT2(FnName, FnType, FnParamList, FnArgs) \
        inline FnType __stdcall __##FnName FnParamList {return (*g_pufn##FnName) FnArgs;}

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs) \
        inline void __stdcall FnName FnParamList {(*g_pufn##FnName) FnArgs;}


#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_VOID_NOCONVERT

//-------------------------------------------------------------------------
//
// Handle wsprintf specially, as it has a variable length argument list.
//
//-------------------------------------------------------------------------

#undef wsprintf

inline int
__cdecl wsprintf(LPTSTR pwszOut, LPCTSTR pwszFormat, ...)
{
    int i;
    va_list arglist;

    va_start(arglist, pwszFormat);
    i = wvsprintf(pwszOut, pwszFormat, arglist);
    va_end(arglist);

    return i;
}

#endif

#pragma INCMSG("--- End 'wrapdefs.h'")
#else
#pragma INCMSG("*** Dup 'wrapdefs.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\include\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4552) /* operator has no effect; expected operator with side-effect            */
#pragma warning(disable:4553) /* operator has no effect; did you intend '='?                           */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4711) /* function 'function' selected for inline expansion                     */
#pragma warning(disable:4068) /* unknown pragma */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */


/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */
#pragma warning(error:4259) /* pure virtual function not defined                                       */

#pragma warning(error:4102) /* 'label' : unreferenced label                                            */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

#pragma warning(3:4127) /* conditional expression is constant                                          */
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#pragma warning(disable:4798) /* pcode: constructors and destructors have native code generated        */
#endif

#ifdef _M_IA64
#pragma warning(disable:4268) /* 'variable' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros */
#endif

/*
 * VC6.0 temporary hack
 */

/*
#pragma warning(disable:4189) // local variable initialized but not used 
#pragma warning(disable:4701) // local variable used and may not have been initialized
#pragma warning(disable:4096) // __cdecl must be used with ...
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\uuid16.c ===
#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define INITGUID
#include <w4warn.h>
#include <windows.h>
#include <basetyps.h>
#include <olectl.h>

DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
DEFINE_GUID(IID_IActiveScriptSiteInterruptPoll, 0x539698a0, 0xcdca, 0x11cf, 0xa5, 0xeb, 0x00, 0xaa, 0x00, 0x47, 0xa0, 0x63);

// These are bogus IIDs.  We still need to sync up with the standard ID values
DEFINE_OLEGUID(IID_IAdviseSinkEx, 0x00000419, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSiteWindowless, 0x00000408, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSiteEx, 0x00000417, 0, 0);
DEFINE_OLEGUID(IID_IProvideClassInfo2, 0x00000410, 0, 0);
DEFINE_OLEGUID(IID_IOleParentUndoUnit, 0x00000422, 0, 0);
DEFINE_OLEGUID(IID_IOleUndoManager, 0x0000040c, 0, 0);
DEFINE_OLEGUID(IID_IEnumOleUndoUnits, 0x00000423, 0, 0);
DEFINE_OLEGUID(IID_IOleUndoUnit, 0x00000424, 0, 0);
DEFINE_OLEGUID(IID_IViewObjectEx, 0x0000041d, 0, 0);
DEFINE_OLEGUID(IID_IQuickActivate, 0x0000040b, 0, 0);
DEFINE_OLEGUID(IID_ICategorizeProperties, 0x0000042a, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObjectWindowless, 0x00000416, 0, 0);
DEFINE_OLEGUID(IID_ILocalRegistry, 0x0000041e, 0, 0);
DEFINE_OLEGUID(IID_ISelectionContainer, 0x00000428, 0, 0);
DEFINE_OLEGUID(IID_ICodeNavigate, 0x00000429, 0, 0);
DEFINE_OLEGUID(IID_IObjectWithSite, 0x0000042c, 0, 0);
DEFINE_OLEGUID(IID_IPointerInactive, 0x0000042d, 0, 0);
DEFINE_OLEGUID(IID_ILicensedClassManager, 0x00000412, 0, 0);
DEFINE_OLEGUID(IID_IVideoWindow, 0x00000430, 0, 0);
DEFINE_OLEGUID(CLSID_FilterGraph, 0x00000431, 0, 0);
DEFINE_OLEGUID(IID_IGraphBuilder, 0x00000432, 0, 0);
DEFINE_OLEGUID(IID_IBasicAudio, 0x00000433, 0, 0);
DEFINE_OLEGUID(IID_IBasicVideo, 0x00000434, 0, 0);
DEFINE_OLEGUID(IID_IMediaControl, 0x00000436, 0, 0);
DEFINE_OLEGUID(IID_IMediaPosition, 0x00000437, 0, 0);
DEFINE_OLEGUID(IID_IMediaEventEx, 0x00000435, 0, 0);
DEFINE_OLEGUID(IID_IMediaEvent, 0x00000438, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo2,      0x00020412L, 0, 0);


DEFINE_OLEGUID(IID_IBoundObject,      0x00000439L, 0, 0);
DEFINE_OLEGUID(IID_IBoundObjectSite,      0x00000440L, 0, 0);
DEFINE_OLEGUID(IID_ICursor,      0x00000441L, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\comdlg32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       comdlg32.cxx
//
//  Contents:   Dynamic wrappers for common dialog procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

DYNLIB g_dynlibCOMDLG32 = { NULL, NULL, "COMDLG32.dll" };

BOOL APIENTRY
ChooseColorW(LPCHOOSECOLORW lpcc)
{
    static DYNPROC s_dynprocChooseColorW =
            { NULL, &g_dynlibCOMDLG32, "ChooseColorW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseColorW);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSECOLORW))s_dynprocChooseColorW.pfn)
            (lpcc);
}

BOOL APIENTRY
ChooseColorA(LPCHOOSECOLORA lpcc)
{
    static DYNPROC s_dynprocChooseColorA =
            { NULL, &g_dynlibCOMDLG32, "ChooseColorA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseColorA);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSECOLORA))s_dynprocChooseColorA.pfn)
            (lpcc);
}


BOOL APIENTRY
ChooseFontW(LPCHOOSEFONTW lpcf)
{
    static DYNPROC s_dynprocChooseFontW =
            { NULL, &g_dynlibCOMDLG32, "ChooseFontW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseFontW);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSEFONTW))s_dynprocChooseFontW.pfn)
            (lpcf);
}

BOOL APIENTRY
ChooseFontA(LPCHOOSEFONTA lpcf)
{
    static DYNPROC s_dynprocChooseFontA =
            { NULL, &g_dynlibCOMDLG32, "ChooseFontA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocChooseFontA);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCHOOSEFONTA))s_dynprocChooseFontA.pfn)
            (lpcf);
}

DWORD APIENTRY
CommDlgExtendedError()
{
    static DYNPROC s_dynprocCommDlgExtendedError =
            { NULL, &g_dynlibCOMDLG32, "CommDlgExtendedError" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCommDlgExtendedError);
    if (hr)
        return CDERR_INITIALIZATION;

    return ((DWORD (APIENTRY *)())s_dynprocCommDlgExtendedError.pfn)
            ();
}

BOOL APIENTRY
PrintDlgA(PRINTDLGA* pprintdlg)
{
    static DYNPROC s_dynprocPrintDlgA =
            { NULL, &g_dynlibCOMDLG32, "PrintDlgA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocPrintDlgA);
    if (hr)
        return NULL;

    return ((BOOL (APIENTRY *)(PRINTDLGA*))s_dynprocPrintDlgA.pfn)
            (pprintdlg);
}

BOOL APIENTRY
PrintDlgW(PRINTDLGW* pprintdlg)
{
    static DYNPROC s_dynprocPrintDlgW =
            { NULL, &g_dynlibCOMDLG32, "PrintDlgW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocPrintDlgW);
    if (hr)
        return NULL;

    return ((BOOL (APIENTRY *)(PRINTDLGW*))s_dynprocPrintDlgW.pfn)
            (pprintdlg);
}

#ifdef UNIX
extern "C" char *APIENTRY
MwFilterType(char *filter, BOOL b)
{
    static DYNPROC s_dynprocMwFilterType =
            { NULL, &g_dynlibCOMDLG32, "MwFilterType" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocMwFilterType);
    if (hr)
        return NULL;

    return ((char *(APIENTRY *)(char *, BOOL))s_dynprocMwFilterType.pfn)
            (filter, b);
}
#endif // UNIX


#if !defined(_M_IX86_)

BOOL APIENTRY
GetOpenFileNameW(LPOPENFILENAMEW pofnw)
{
    static DYNPROC s_dynprocGetOpenFileNameW =
            { NULL, &g_dynlibCOMDLG32, "GetOpenFileNameW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetOpenFileNameW);
    if (hr)
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPOPENFILENAMEW))s_dynprocGetOpenFileNameW.pfn)
            (pofnw);
}

BOOL APIENTRY
GetSaveFileNameW(LPOPENFILENAMEW pofnw)
{
    static DYNPROC s_dynprocGetSaveFileNameW =
            { NULL, &g_dynlibCOMDLG32, "GetSaveFileNameW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetSaveFileNameW);
    if (hr)
        return FALSE;

    return ((BOOL (APIENTRY *)(LPOPENFILENAMEW))s_dynprocGetSaveFileNameW.pfn)
            (pofnw);
}



#endif

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\misc\objextid.c ===
/*
   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifndef _MAC
#include <windef.h>
#include <basetyps.h>
#endif

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// Include the object extensions GUID's
//
// These weird stuff with windows.h is necessary because it reenables warning
// 4001 and generally causes havoc at warning level 4.
//
#pragma warning(disable:4115) // named type in parenthses

#include <windows.h>
#include <w4warn.h>
#include <servprov.h>
#include <ole2.h>
#include <objext.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\comctl32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       comctl32.cxx
//
//  Contents:   Dynamic wrappers for common control procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#undef WINCOMMCTRLAPI
#define WINCOMMCTRLAPI
#include <commctrl.h>

#ifndef X_COMCTRLP_H_
#define X_COMCTRLP_H_
#include "comctrlp.h"
#endif

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

DYNLIB g_dynlibCOMCTL32 = { NULL, NULL, "comctl32.dll" };

void APIENTRY
InitCommonControls(void)
{
    static DYNPROC s_dynprocInitCommonControls =
            { NULL, &g_dynlibCOMCTL32, "InitCommonControls" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocInitCommonControls);
    if (hr)
        return ;

    (*(void (APIENTRY *)(void))s_dynprocInitCommonControls.pfn)
            ();
}


BOOL APIENTRY
InitCommonControlsEx(LPINITCOMMONCONTROLSEX lpICC)
{
    static DYNPROC s_dynprocInitCommonControlsEx =
            { NULL, &g_dynlibCOMCTL32, "InitCommonControlsEx" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocInitCommonControlsEx);
    if (hr)
        return FALSE;

    return(*(BOOL (APIENTRY *)(LPINITCOMMONCONTROLSEX))s_dynprocInitCommonControlsEx.pfn)
            (lpICC);
}


HIMAGELIST APIENTRY
WINAPI ImageList_Create(int cx,int cy,UINT flags,int cInitial,int cGrow)
{
    static DYNPROC s_dynprocImageList_Create =
            { NULL, &g_dynlibCOMCTL32, "ImageList_Create" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_Create);
    if (hr)
        return NULL;

    return(*(HIMAGELIST (APIENTRY *)(int ,int ,UINT ,int ,int ))s_dynprocImageList_Create.pfn)
            (cx,cy,flags,cInitial, cGrow);
}


int APIENTRY
WINAPI ImageList_AddMasked( HIMAGELIST  himl,   // handle to the image list
                            HBITMAP  hbmImage,  // handle to the bitmap
                            COLORREF  crMask    // color used to generate mask
                            )
{
    static DYNPROC s_dynprocImageList_AddMasked =
            { NULL, &g_dynlibCOMCTL32, "ImageList_AddMasked" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_AddMasked);
    if (hr)
        return -1;

    return(*(int (APIENTRY *)(HIMAGELIST ,HBITMAP , COLORREF ))s_dynprocImageList_AddMasked.pfn)
            (himl,hbmImage,crMask);
}


HIMAGELIST APIENTRY
WINAPI ImageList_Merge(HIMAGELIST  himl1,
                       int  i1,
                       HIMAGELIST  himl2,
                       int  i2,
                       int  dx,
                       int  dy
                       )
{
    static DYNPROC s_dynprocImageList_Merge =
            { NULL, &g_dynlibCOMCTL32, "ImageList_Merge" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_Merge);
    if (hr)
        return NULL;

    return(*(HIMAGELIST (APIENTRY *)(HIMAGELIST,int, HIMAGELIST,int,int,int))s_dynprocImageList_Merge.pfn)
            (himl1, i1,himl2, i2, dx, dy);
}


HICON APIENTRY
WINAPI ImageList_GetIcon( HIMAGELIST himl, int  i, UINT  flags )
{
    static DYNPROC s_dynprocImageList_GetIcon =
            { NULL, &g_dynlibCOMCTL32, "ImageList_GetIcon" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_GetIcon);
    if (hr)
        return NULL;

    return(*(HICON (APIENTRY *)(HIMAGELIST , int, UINT  ))s_dynprocImageList_GetIcon.pfn)
            (himl,  i, flags );
}



BOOL APIENTRY
WINAPI ImageList_Destroy( HIMAGELIST  himl)
{
    static DYNPROC s_dynprocImageList_Destroy =
            { NULL, &g_dynlibCOMCTL32, "ImageList_Destroy" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocImageList_Destroy);
    if (hr)
        return FALSE;

    return(*(BOOL (APIENTRY *)(HIMAGELIST ))s_dynprocImageList_Destroy.pfn)
            (himl);

}

WINCOMMCTRLAPI void APIENTRY
WINAPI DoReaderMode(PREADERMODEINFO prmi)
{
    // use ordinal instead of function name
    //
    static DYNPROC s_dynprocDoReaderMode =
#ifdef UNIX
            { NULL, &g_dynlibCOMCTL32, "DoReaderMode"};
#else
            { NULL, &g_dynlibCOMCTL32, (LPSTR) 383 };
#endif

    HRESULT hr;
    hr = LoadProcedure(&s_dynprocDoReaderMode);
    if (hr)
        return;

    (*(void (APIENTRY *) (PREADERMODEINFO )) s_dynprocDoReaderMode.pfn) (prmi);
}

#ifndef PRODUCT_96

HWND APIENTRY
WINAPI CreateToolbarEx(HWND        hwnd,
                       DWORD       ws,
                       UINT        wID,
                       int         nBitmaps,
                       HINSTANCE   hBMInst,
                       UINT        wBMID,
                       LPCTBBUTTON lpButton,
                       int         iNumButtons,
                       int         dxButton,
                       int         dyButton,
                       int         dxBitmap,
                       int         dyBitmap,
                       UINT        uStructSize)
{
    static DYNPROC s_dynprocCreateToolbarEx =
            { NULL, &g_dynlibCOMCTL32, "CreateToolbarEx" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCreateToolbarEx);
    if (hr)
        return FALSE;

    return(*(HWND (APIENTRY *)(HWND,DWORD,UINT,int,HINSTANCE,UINT,LPCTBBUTTON,int,int,int,int,int,UINT ))s_dynprocCreateToolbarEx.pfn)
            (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButton,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize);

}

#endif


#ifdef VSTUDIO7


WINCOMMCTRLAPI
BOOL
WINAPI _TrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    static DYNPROC s_dynprocTrackMouseEvent =
            { NULL, &g_dynlibCOMCTL32, "_TrackMouseEvent" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocTrackMouseEvent);
    if (hr)
        return FALSE;

    return(*(BOOL (APIENTRY *)(LPTRACKMOUSEEVENT))s_dynprocTrackMouseEvent.pfn)
            (lpTME);
}

#endif

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\dynwrap.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       dynwrap.cxx
//
//  Contents:   Utility for dynamically loaded procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

extern void MLangUnload();
extern BOOL IsMLangLoaded();

// List of loaded libraries.

DeclareTag(tagLoadDll, "!Perf", "Trace callers on DLL loads");

static DYNLIB * s_pdynlibHead;

#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   DeinitDynamicLibrary
//
//  Synopsis:   Unloads library
//
//----------------------------------------------------------------------------
void
DeinitDynamicLibrary(LPCTSTR pchLib)
{
    DYNLIB * pdynlib, ** ppdynlibPrev;
    char buf[200];
    int l;

    l = WideCharToMultiByte(CP_ACP, 0, pchLib, _tcslen(pchLib), buf, ARRAY_SIZE(buf), NULL, NULL);

    if (!StrCmpNICA(buf, "mlang.dll", l))
    {
        MLangUnload();
    }
    else
    {
        ppdynlibPrev = &s_pdynlibHead;
        for (pdynlib = s_pdynlibHead; pdynlib; )
        {
            if (!StrCmpNICA(buf, pdynlib->achName, l))
            {
                if (pdynlib->hinst)
                {
                    FreeLibrary(pdynlib->hinst);
                    pdynlib->hinst = NULL;
                    *ppdynlibPrev = pdynlib = pdynlib->pdynlibNext;
                }
            }
            else
            {
                ppdynlibPrev = &pdynlib->pdynlibNext;
                pdynlib = pdynlib->pdynlibNext;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsDynamicLibraryLoaded
//
//  Synopsis:   Check if library loaded
//
//----------------------------------------------------------------------------
BOOL
IsDynamicLibraryLoaded(LPCTSTR pchLib)
{
    DYNLIB * pdynlib;
    char buf[200];
    int l;

    l = WideCharToMultiByte(CP_ACP, 0, pchLib, _tcslen(pchLib), buf, ARRAY_SIZE(buf), NULL, NULL);

    if (!StrCmpNICA(buf, "mlang.dll", l))
    {
        return IsMLangLoaded();
    }
    else
    {
        for (pdynlib = s_pdynlibHead; pdynlib; pdynlib = pdynlib->pdynlibNext)
        {
            if (!StrCmpNICA(buf, pdynlib->achName, l))
            {
                if (pdynlib->hinst)
                {
                    return TRUE;
                }
                break;
            }
        }
    }

    return FALSE;
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   DeinitDynamicLibraries
//
//  Synopsis:   Undoes the work of LoadProcedure.
//
//----------------------------------------------------------------------------
void
DeinitDynamicLibraries()
{
    DYNLIB * pdynlib;

    for (pdynlib = s_pdynlibHead; pdynlib; pdynlib = pdynlib->pdynlibNext)
    {
        if (pdynlib->hinst)
        {
            FreeLibrary(pdynlib->hinst);
            pdynlib->hinst = NULL;
        }
    }
    s_pdynlibHead = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadProcedure
//
//  Synopsis:   Load library and get address of procedure.
//
//              Declare DYNLIB and DYNPROC globals describing the procedure.
//              Note that several DYNPROC structures can point to a single
//              DYNLIB structure.
//
//                  DYNLIB g_dynlibOLEDLG = { NULL, "OLEDLG.DLL" };
//                  DYNPROC g_dynprocOleUIInsertObjectA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };
//                  DYNPROC g_dynprocOleUIPasteSpecialA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIPasteSpecialA" };
//
//              Call LoadProcedure to load the library and get the procedure
//              address.  LoadProcedure returns immediatly if the procedure
//              has already been loaded.
//
//                  hr = LoadProcedure(&g_dynprocOLEUIInsertObjectA);
//                  if (hr)
//                      goto Error;
//
//                  uiResult = (*(UINT (__stdcall *)(LPOLEUIINSERTOBJECTA))
//                      g_dynprocOLEUIInsertObjectA.pfn)(&ouiio);
//
//              Release the library at shutdown.
//
//                  void DllProcessDetach()
//                  {
//                      DeinitDynamicLibraries();
//                  }
//
//  Arguments:  pdynproc  Descrition of library and procedure to load.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
LoadProcedure(DYNPROC *pdynproc)
{
    HINSTANCE   hinst;
    DYNLIB *    pdynlib = pdynproc->pdynlib;
    DWORD       dwError;

    if (pdynproc->pfn && pdynlib->hinst)
        return S_OK;

    if (!pdynlib->hinst)
    {
        TraceTag((tagPerf, "Loading library %s", pdynlib->achName));
        TraceTag((tagLoadDll, "%s initially loaded by:", pdynlib->achName));
        TraceCallers(tagLoadDll, 0, 10);
        
        // Try to load the library using the normal mechanism.

        hinst = LoadLibraryA(pdynlib->achName);

#ifdef WINCE
        if (!hinst)
        {
            goto Error;
        }
#endif // WINCE

#if !defined(WINCE)
        // If that failed because the module was not be found,
        // then try to find the module in the directory we were
        // loaded from.

        if (!hinst)
        {
            dwError = GetLastError();

            if (   dwError == ERROR_MOD_NOT_FOUND
                || dwError == ERROR_DLL_NOT_FOUND)
            {
                char achBuf1[MAX_PATH];
                char achBuf2[MAX_PATH];
                char *pch;

                // Get path name of this module.
                if (GetModuleFileNameA(g_hInstCore, achBuf1, ARRAY_SIZE(achBuf1)) == 0)
                    goto Error;

                // Find where the file name starts in the module path.
                if (GetFullPathNameA(achBuf1, ARRAY_SIZE(achBuf2), achBuf2, &pch) == 0)
                    goto Error;

                // Chop off the file name to get a directory name.
                *pch = 0;

                // See if there's a dll with the given name in the directory.
                if (SearchPathA(
                        achBuf2,
                        pdynlib->achName,
                        NULL,
                        ARRAY_SIZE(achBuf1),
                        achBuf1,
                        NULL) != 0)
                {
                    // Yes, there's a dll. Load it.
                    hinst = LoadLibraryExA(
                                achBuf1,
                                NULL,
                                LOAD_WITH_ALTERED_SEARCH_PATH);
                }
            }
        }
        if (!hinst)
        {
            goto Error;
        }
#endif // !defined(WINCE)

        // Link into list for DeinitDynamicLibraries

        {
            LOCK_GLOBALS;

            if (pdynlib->hinst)
                FreeLibrary(hinst);
            else
            {
                pdynlib->hinst = hinst;
                pdynlib->pdynlibNext = s_pdynlibHead;
                s_pdynlibHead = pdynlib;
            }
        }
    }

    pdynproc->pfn = GetProcAddress(pdynlib->hinst, pdynproc->achName);
    if (!pdynproc->pfn)
    {
        goto Error;
    }

    return S_OK;

Error:
    RRETURN(GetLastWin32Error());
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeDynlib
//
//  Synopsis:   Free a solitary dynlib entry from the link list of dynlibs
//
//  Arguments:  Pointer to DYNLIB to be freed
//
//  Returns:    S_OK
//
//----------------------------------------------------------------------------

HRESULT
FreeDynlib(DYNLIB *pdynlib)
{
    DYNLIB ** ppdynlibPrev;

    LOCK_GLOBALS;

    if (pdynlib == s_pdynlibHead)
    {
        ppdynlibPrev = &s_pdynlibHead;
    }
    else
    {
        DYNLIB * pdynlibPrev;

        for (pdynlibPrev = s_pdynlibHead;
             pdynlibPrev && pdynlibPrev->pdynlibNext != pdynlib;
             pdynlibPrev = pdynlibPrev->pdynlibNext);

        ppdynlibPrev = pdynlibPrev ? &pdynlibPrev->pdynlibNext : NULL;
    }

    if (ppdynlibPrev)
    {
        if (pdynlib->hinst)
        {
            FreeLibrary(pdynlib->hinst);
            pdynlib->hinst = NULL;
        }
        
        *ppdynlibPrev = pdynlib->pdynlibNext;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\imgutil.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       imgutil.cxx
//
//  Contents:   Dynamic wrappers for plugin image decoder support DLL.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

#ifdef UNIX
#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include <ddraw.h>
#endif
#endif

DYNLIB g_dynlibIMGUTIL = { NULL, NULL, "imgutil.dll" };

void APIENTRY
InitImgUtil(void)
{
    static DYNPROC s_dynprocInitImgUtil =
            { NULL, &g_dynlibIMGUTIL, "InitImgUtil" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocInitImgUtil);
    if (hr)
        return ;

    (*(void (APIENTRY *)(void))s_dynprocInitImgUtil.pfn)
            ();
}

STDAPI DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, 
   IUnknown* pEventSink )
{
    static DYNPROC s_dynprocDecodeImage =
            { NULL, &g_dynlibIMGUTIL, "DecodeImage" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDecodeImage);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(IStream*, IMapMIMEToCLSID*, IUnknown*))s_dynprocDecodeImage.pfn)
            (pStream, pMap, pEventSink);
}

STDAPI CreateMIMEMap( IMapMIMEToCLSID** ppMap )
{
    static DYNPROC s_dynprocCreateMIMEMap =
            { NULL, &g_dynlibIMGUTIL, "CreateMIMEMap" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCreateMIMEMap);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(IMapMIMEToCLSID**))s_dynprocCreateMIMEMap.pfn)
            (ppMap);
}

STDAPI GetMaxMIMEIDBytes( ULONG* pnMaxBytes )
{
    static DYNPROC s_dynprocGetMaxMIMEIDBytes =
            { NULL, &g_dynlibIMGUTIL, "GetMaxMIMEIDBytes" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetMaxMIMEIDBytes);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(ULONG*))s_dynprocGetMaxMIMEIDBytes.pfn)
            (pnMaxBytes);
}

STDAPI IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, 
   UINT* pnFormat )
{
    static DYNPROC s_dynprocIdentifyMIMEType =
            { NULL, &g_dynlibIMGUTIL, "IdentifyMIMEType" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocIdentifyMIMEType);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(const BYTE*, ULONG, UINT*))s_dynprocIdentifyMIMEType.pfn)
            (pbBytes, nBytes, pnFormat);
}

STDAPI SniffStream( IStream* pInStream, UINT* pnFormat, 
   IStream** ppOutStream )
{
    static DYNPROC s_dynprocSniffStream =
            { NULL, &g_dynlibIMGUTIL, "SniffStream" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocSniffStream);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(IStream*, UINT*, IStream**))s_dynprocSniffStream.pfn)
            (pInStream, pnFormat, ppOutStream);
}

STDAPI ComputeInvCMAP(const RGBQUAD *pRGBColors, ULONG nColors, BYTE *pInvTable, ULONG cbTable)
{
    static DYNPROC s_dynprocComputeInvCMAP =
            { NULL, &g_dynlibIMGUTIL, "ComputeInvCMAP" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocComputeInvCMAP);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(const RGBQUAD *, ULONG, BYTE *, ULONG))s_dynprocComputeInvCMAP.pfn)
            (pRGBColors, nColors, pInvTable, cbTable);
}

STDAPI CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
    static DYNPROC s_dynprocCreateDDrawSurfaceOnDIB =
            { NULL, &g_dynlibIMGUTIL, "CreateDDrawSurfaceOnDIB" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCreateDDrawSurfaceOnDIB);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(HBITMAP, IDirectDrawSurface **))s_dynprocCreateDDrawSurfaceOnDIB.pfn)
            (hbmDib, ppSurface);
}

#if 0

// KENSY: This functionality is folded into MSHTML so that IMGUTIL doesn't
//        have to be loaded

STDAPI DitherTo8( BYTE * pDestBits, LONG nDestPitch, 
                   BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                   RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                   BYTE * pbDestInvMap,
                   LONG x, LONG y, LONG cx, LONG cy,
                   LONG lDestTrans, LONG lSrcTrans)
{
    static DYNPROC s_dynprocDitherTo8 =
            { NULL, &g_dynlibIMGUTIL, "DitherTo8" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDitherTo8);
    if (hr)
        return NULL;

    return(*(HRESULT (APIENTRY *)(BYTE *, LONG, BYTE *, LONG, REFGUID, RGBQUAD *, RGBQUAD *, BYTE *, LONG, LONG, LONG, LONG, LONG, LONG))s_dynprocDitherTo8.pfn)
        (pDestBits, nDestPitch, pSrcBits, nSrcPitch, bfidSrc, prgbDestColors, prgbSrcColors, pbDestInvMap, x, y, cx, cy, lDestTrans, lSrcTrans);
}

#endif

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\hlink.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       hlink.cxx
//
//  Contents:   Dynamic wrappers for Hlink.dll functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

DYNLIB g_dynlibHLINK = { NULL, NULL, "HLINK.DLL" };

#define WRAPIT(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibHLINK, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}


WRAPIT(HlinkCreateFromMoniker,
    (IMoniker * pimkTrgt, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, IHlinkSite * pihlsite,
     DWORD dwSiteData, IUnknown * piunkOuter, REFIID riid, void ** ppvObj),
    (pimkTrgt, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj))

WRAPIT(HlinkCreateFromString,
    (LPCWSTR pwzTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, IHlinkSite * pihlsite,
     DWORD dwSiteData, IUnknown * piunkOuter, REFIID riid, void ** ppvObj),
    (pwzTarget, pwzLocation, pwzFriendlyName, pihlsite, dwSiteData, piunkOuter, riid, ppvObj))


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\imm32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       imm32.cxx
//
//  Contents:   Dynamic wrappers for imm32.dll functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IMM_H_
#define X_IMM_H_
#include "imm.h"
#endif

#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif

#ifndef NO_IME

DYNLIB g_dynlibIMM32 = { NULL, NULL, "IMM32.DLL" };

extern BOOL HasActiveIMM();
extern IActiveIMMApp * GetActiveIMM();

//----------------------------------------------------------------------------
// ActiveIMM wrappers
//----------------------------------------------------------------------------

HIMC ImmAssociateContextDIMM(HWND hWnd, HIMC hIMC)
{
    Assert(HasActiveIMM());

    HIMC hPrev;

    GetActiveIMM()->AssociateContext(hWnd, hIMC, &hPrev);

    return hPrev;
}

LRESULT ImmEscapeADIMM(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData)
{
    Assert(HasActiveIMM());

    LRESULT lResult;

    GetActiveIMM()->EscapeA(hKL, hIMC, uEscape, lpData, &lResult);

    return lResult;
}

LRESULT ImmEscapeWDIMM(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData)
{
    Assert(HasActiveIMM());

    LRESULT lResult;

    GetActiveIMM()->EscapeW(hKL, hIMC, uEscape, lpData, &lResult);

    return lResult;
}

BOOL ImmGetCandidateWindowDIMM(HIMC hIMC, DWORD dwBufLen, LPCANDIDATEFORM lpCandidate)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->GetCandidateWindow(hIMC, dwBufLen, lpCandidate));
}

LONG ImmGetCompositionStringADIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen)
{
    Assert(HasActiveIMM());
    
    LONG lCopied;

    GetActiveIMM()->GetCompositionStringA(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);

    return lCopied;
}

LONG ImmGetCompositionStringWDIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen)
{
    Assert(HasActiveIMM());
    
    LONG lCopied;

    GetActiveIMM()->GetCompositionStringW(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);

    return lCopied;
}

BOOL ImmSetCompositionStringADIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCompositionStringA(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead));
}

BOOL ImmSetCompositionStringWDIMM(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead)
{
    Assert(HasActiveIMM());
    
    return SUCCEEDED(GetActiveIMM()->SetCompositionStringW(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead));
}

HIMC ImmGetContextDIMM(HWND hWnd)
{
    Assert(HasActiveIMM());

    HIMC hIMC;

    GetActiveIMM()->GetContext(hWnd, &hIMC);

    return hIMC;
}

BOOL ImmGetConversionStatusDIMM(HIMC hIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence));
}

BOOL ImmSetConversionStatusDIMM(HIMC hIMC, DWORD dwConversion, DWORD dwSentence)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetConversionStatus(hIMC, dwConversion, dwSentence));
}

BOOL ImmGetOpenStatusDIMM(HIMC hIMC)
{
    Assert(HasActiveIMM());

    return (GetActiveIMM()->GetOpenStatus(hIMC) == S_OK);
}

BOOL ImmSetOpenStatusDIMM(HIMC hIMC, BOOL fOpen)
{
    Assert(HasActiveIMM());

    return (GetActiveIMM()->SetOpenStatus(hIMC, fOpen) == S_OK);
}

DWORD ImmGetPropertyDIMM(HKL hKL, DWORD dwFlags)
{
    Assert(HasActiveIMM());

    DWORD dwProperty;

    GetActiveIMM()->GetProperty(hKL, dwFlags, &dwProperty);

    return dwProperty;
}

UINT ImmGetVirtualKeyDIMM(HWND hWnd)
{
    Assert(HasActiveIMM());

    UINT uVirtualKey;

    GetActiveIMM()->GetVirtualKey(hWnd, &uVirtualKey);

    return uVirtualKey;
}

BOOL ImmNotifyIMEDIMM(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->NotifyIME(hIMC, dwAction, dwIndex, dwValue));
}

BOOL ImmReleaseContextDIMM(HWND hWnd, HIMC hIMC)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->ReleaseContext(hWnd, hIMC));
}

BOOL ImmSetCandidateWindowDIMM(HIMC hIMC, LPCANDIDATEFORM lpCandidate)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCandidateWindow(hIMC, lpCandidate));
}

BOOL ImmSetCompositionFontADIMM(HIMC hIMC, LPLOGFONTA lplf)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCompositionFontA(hIMC, lplf));
}

BOOL ImmSetCompositionWindowDIMM(HIMC hIMC, LPCOMPOSITIONFORM lpcf)
{
    Assert(HasActiveIMM());

    return SUCCEEDED(GetActiveIMM()->SetCompositionWindow(hIMC, lpcf));
}

BOOL ImmIsIMEDIMM(HKL hklCurrent)
{
    if(HasActiveIMM())
    {
        return GetActiveIMM()->IsIME(hklCurrent);
    }
    return FALSE;
}

#ifndef DLOAD1
//----------------------------------------------------------------------------
// Active wrapper functions
//----------------------------------------------------------------------------

#define WRAPIT(fn, rettype, errret, a1, a2)\
rettype WINAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibIMM32, #fn };\
    \
    if (HasActiveIMM()) \
        return fn##DIMM a2; \
    \
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return errret;\
    return (*(rettype (WINAPI *) a1)s_dynproc##fn.pfn) a2;\
}

WRAPIT(ImmAssociateContext,
       HIMC,
       NULL,
       (HWND hwnd, HIMC himc),
       (hwnd, himc))

WRAPIT(ImmEscapeA,
       LRESULT,
       0,
       (HKL hkl, HIMC himc, UINT uEscape, LPVOID lpData),
       (hkl, himc, uEscape, lpData))

WRAPIT(ImmEscapeW,
       LRESULT,
       0,
       (HKL hkl, HIMC himc, UINT uEscape, LPVOID lpData),
       (hkl, himc, uEscape, lpData))

WRAPIT(ImmGetCandidateWindow,
       BOOL,
       0,
       (HIMC himc, DWORD dwBufLen, LPCANDIDATEFORM lpCandidate),
       (himc, dwBufLen, lpCandidate))

WRAPIT(ImmGetCompositionStringA,
       LONG,
       IMM_ERROR_GENERAL,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
       (hIMC, dwIndex, lpBuf, dwBufLen))

WRAPIT(ImmGetCompositionStringW,
       LONG,
       IMM_ERROR_GENERAL,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
       (hIMC, dwIndex, lpBuf, dwBufLen))

WRAPIT(ImmSetCompositionStringA,
       BOOL,
       0,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead),
       (hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead))

WRAPIT(ImmSetCompositionStringW,
       BOOL,
       0,
       (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen, LPVOID lpRead, DWORD dwBufRead),
       (hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwBufRead))

WRAPIT(ImmGetContext,
       HIMC,
       NULL,
       (HWND hwnd),
       (hwnd))

WRAPIT(ImmGetConversionStatus,
       BOOL,
       0,
       (HIMC himc, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence),
       (himc, lpfdwConversion, lpfdwSentence))

WRAPIT(ImmSetConversionStatus,
       BOOL,
       0,
       (HIMC himc, DWORD dwConversion, DWORD dwSentence),
       (himc, dwConversion, dwSentence))

WRAPIT(ImmGetOpenStatus,
       BOOL,
       FALSE,
       (HIMC himc),
       (himc))

WRAPIT(ImmSetOpenStatus,
       BOOL,
       FALSE,
       (HIMC himc, BOOL fOpen),
       (himc, fOpen))

WRAPIT(ImmGetProperty,
       DWORD,
       0,
       (HKL hkl, DWORD dwFlags),
       (hkl, dwFlags))

WRAPIT(ImmGetVirtualKey,
       UINT,
       0,
       (HWND hwnd),
       (hwnd))

WRAPIT(ImmNotifyIME,
       BOOL,
       0,
       (HIMC himc, DWORD dwAction, DWORD dwIndex, DWORD dwValue),
       (himc, dwAction, dwIndex, dwValue))

WRAPIT(ImmReleaseContext,
       BOOL,
       0,
       (HWND hwnd, HIMC himc),
       (hwnd, himc))

WRAPIT(ImmSetCandidateWindow,
       BOOL,
       0,
       (HIMC himc, LPCANDIDATEFORM lpCandidate),
       (himc, lpCandidate))

WRAPIT(ImmSetCompositionFontA,
       BOOL,
       0,
       (HIMC himc, LPLOGFONTA lplf),
       (himc, lplf))

WRAPIT(ImmSetCompositionWindow,
       BOOL,
       0,
       (HIMC himc, LPCOMPOSITIONFORM lpcf),
       (himc, lpcf))

WRAPIT(ImmIsIME,
       BOOL,
       FALSE,
       (HKL hklCurrent),
       (hklCurrent))
#endif // DLOAD1

//----------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------

HRESULT GetKeyboardCodePageDIMM(UINT *puCodePage)
{
    HRESULT hr;

    if (!HasActiveIMM())
    {
        UINT ConvertLanguageIDtoCodePage(WORD langid);

        *puCodePage = ConvertLanguageIDtoCodePage((WORD)(DWORD_PTR)GetKeyboardLayout(0 /*idThread*/));
        hr = S_FALSE;
    }
    else
    {
        hr = THR( GetActiveIMM()->GetCodePageA(GetKeyboardLayout(0), puCodePage) );
    }

    RRETURN1(hr,S_FALSE);
}

//
// Actually returns an LCID with SortID == 0, matching the behavior
// of GetKeyboardLCID.
//

HRESULT GetKeyboardLCIDDIMM(LCID *plid)
{
    HKL hKL = GetKeyboardLayout(0 /*idThread*/);

    if (HasActiveIMM())
    {
        HRESULT hr;
        LANGID langid;

        hr = THR( GetActiveIMM()->GetLangId(hKL, &langid) );
        if (OK(hr))
        {
            *plid = LCID(langid);
            return S_OK;
        }
    }

    *plid = (WORD)(DWORD_PTR)hKL;

    return S_FALSE;
}

#endif // ndef NO_IME

static const WORD s_CodePageTable[] =
{
// CodePage       PLID  primary language
// -------------------------------------
       0,       // 00 - undefined
    1256,       // 01 - Arabic
    1251,       // 02 - Bulgarian
    1252,       // 03 - Catalan
     950,       // 04 - Taiwan, Hong Kong (PRC and Singapore are 936)
    1250,       // 05 - Czech
    1252,       // 06 - Danish
    1252,       // 07 - German
    1253,       // 08 - Greek
    1252,       // 09 - English
    1252,       // 0a - Spanish
    1252,       // 0b - Finnish
    1252,       // 0c - French
    1255,       // 0d - Hebrew
    1250,       // 0e - Hungarian
    1252,       // 0f - Icelandic
    1252,       // 10 - Italian
     932,       // 11 - Japan
     949,       // 12 - Korea
    1252,       // 13 - Dutch
    1252,       // 14 - Norwegian
    1250,       // 15 - Polish
    1252,       // 16 - Portuguese
       0,       // 17 - Rhaeto-Romanic
    1250,       // 18 - Romanian
    1251,       // 19 - Russian
    1250,       // 1a - Croatian
    1250,       // 1b - Slovak
    1250,       // 1c - Albanian
    1252,       // 1d - Swedish
     874,       // 1e - Thai
    1254,       // 1f - Turkish
       0,       // 20 - Urdu
    1252,       // 21 - Indonesian
    1251,       // 22 - Ukranian
    1251,       // 23 - Byelorussian
    1250,       // 24 - Slovenian
    1257,       // 25 - Estonia
    1257,       // 26 - Latvian
    1257,       // 27 - Lithuanian
       0,       // 28 - undefined
    1256,       // 29 - Farsi
    1258,       // 2a - Vietnanese
       0,       // 2b - undefined
       0,       // 2c - undefined
    1252,       // 2d - Basque
       0,       // 2e - Sorbian
    1251,       // 2f - FYRO Macedonian
    1252,       // 30 - Sutu        *** use 1252 for the following ***
    1252,       // 31 - Tsonga
    1252,       // 32 - Tswana
    1252,       // 33 - Venda
    1252,       // 34 - Xhosa
    1252,       // 35 - Zulu
    1252,       // 36 - Africaans (uses 1252)
    1252,       // 38 - Faerose
    1252,       // 39 - Hindi
    1252,       // 3a - Maltese
    1252,       // 3b - Sami
    1252,       // 3c - Gaelic
    1252,       // 3e - Malaysian
       0,       // 3f -
       0,       // 40 -
    1252,       // 41 - Swahili
       0,       // 42 - 
       0,       // 43 - 
       0,       // 44 - 
    1252,       // 45 - Bengali *** The following languages use 1252, but
    1252,       // 46 - Gurmuki     actually have only Unicode characters ***
    1252,       // 47 - Gujarait
    1252,       // 48 - Oriya
    1252,       // 49 - Tamil
    1252,       // 4a - Telugu
    1252,       // 4b - Kannada
    1252,       // 4c - Malayalam
       0,       // 4d - 
       0,       // 4e - 
       0,       // 4f - 
    1252,       // 50 - Mongolian
    1252,       // 51 - Tibetan
       0,       // 52 - 
    1252,       // 53 - Khmer
    1252,       // 54 - Lao
    1252,       // 55 - Burmese
       0,       // 56 - LANG_MAX
};

#define ns_CodePageTable  (sizeof(s_CodePageTable)/sizeof(s_CodePageTable[0]))

#if !defined(lidSerbianCyrillic)
  #define lidSerbianCyrillic 0xc1a
#else
  #if lidSerbianCyrillic != 0xc1a
    #error "lidSerbianCyrillic macro value has changed"
  #endif // lidSerbianCyrillic
#endif

/*
 *  ConvertLanguageIDtoCodePage (lid)
 *
 *  @mfunc      Maps a language ID to a Code Page
 *
 *  @rdesc      returns Code Page
 *
 *  @devnote:
 *      This routine takes advantage of the fact that except for Chinese,
 *      the code page is determined uniquely by the primary language ID,
 *      which is given by the low-order 10 bits of the lcid.
 *
 *      The WORD s_CodePageTable could be replaced by a BYTE with the addition
 *      of a couple of if's and the BYTE table replaced by a nibble table
 *      with the addition of a shift and a mask.  Since the table is only
 *      92 bytes long, it seems that the simplicity of using actual code page
 *      values is worth the extra bytes.
 */

UINT
ConvertLanguageIDtoCodePage(WORD langid)
{
    WORD langidT = PRIMARYLANGID(langid);       // langidT = primary language (Plangid)
    CODEPAGE cp;

#if !defined(UNIX)
    if(langidT >= LANG_CROATIAN)                // Plangid = 0x1a
    {
        if(langid == lidSerbianCyrillic)        // Special case for langid = 0xc1a
            return 1251;                        // Use Cyrillic code page

        if(langidT >= ns_CodePageTable)         // Africans Plangid = 0x36, which
            return CP_ACP;                      //  is outside table
    }
#endif // !UNIX

    cp = s_CodePageTable[langidT];              // Translate Plangid to code page

    if(cp != 950 || (langid & 0x400))           // All but Singapore, PRC, and Serbian
        return cp != 0 ? cp : CP_ACP;           // Remember there are holes in the array
                                                // that may not always be there.

    return 936;                                 // Singapore and PRC
}

/*
 *  GetKeyboardCodePage ()
 *
 *  @mfunc      Gets Code Page for keyboard active on current thread
 *
 *  @rdesc      returns Code Page
 */

UINT GetKeyboardCodePage()
{
#if !defined(MACPORT) && !defined(WINCE)
  #ifndef NO_IME
    UINT uCodePage;
    return SUCCEEDED(GetKeyboardCodePageDIMM(&uCodePage)) ? uCodePage : GetACP();
  #else
    return ConvertLanguageIDtoCodePage((WORD)(DWORD)GetKeyboardLayout(0 /*idThread*/));
  #endif  
#else
    return ConvertLanguageIDtoCodePage(GetUserDefaultLCID());
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\msls.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       msls.cxx
//
//  Contents:   Dynamic wrappers for Line Services procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LSDEFS_H_
#define X_LSDEFS_H_
#include "lsdefs.h"
#endif

#ifndef X_LSFRUN_H_
#define X_LSFRUN_H_
#include "lsfrun.h"
#endif

#ifndef X_FMTRES_H_
#define X_FMTRES_H_
#include "fmtres.h"
#endif

#ifndef X_PLSDNODE_H_
#define X_PLSDNODE_H_
#include "plsdnode.h"
#endif

#ifndef X_PLSSUBL_H_
#define X_PLSSUBL_H_
#include "plssubl.h"
#endif

#ifndef X_LSKJUST_H_
#define X_LSKJUST_H_
#include "lskjust.h"
#endif

#ifndef X_LSCONTXT_H_
#define X_LSCONTXT_H_
#include "lscontxt.h"
#endif

#ifndef X_LSLINFO_H_
#define X_LSLINFO_H_
#include "lslinfo.h"
#endif

#ifndef X_PLSLINE_H_
#define X_PLSLINE_H_
#include "plsline.h"
#endif

#ifndef X_PLSSUBL_H_
#define X_PLSSUBL_H_
#include "plssubl.h"
#endif

#ifndef X_PDOBJ_H_
#define X_PDOBJ_H_
#include "pdobj.h"
#endif

#ifndef X_PHEIGHTS_H_
#define X_PHEIGHTS_H_
#include "pheights.h"
#endif

#ifndef X_PLSRUN_H_
#define X_PLSRUN_H_
#include "plsrun.h"
#endif

#ifndef X_LSESC_H_
#define X_LSESC_H_
#include "lsesc.h"
#endif

#ifndef X_POBJDIM_H_
#define X_POBJDIM_H_
#include "pobjdim.h"
#endif

#ifndef X_LSPRACT_H_
#define X_LSPRACT_H_
#include "lspract.h"
#endif

#ifndef X_LSBRK_H_
#define X_LSBRK_H_
#include "lsbrk.h"
#endif

#ifndef X_LSDEVRES_H_
#define X_LSDEVRES_H_
#include "lsdevres.h"
#endif

#ifndef X_LSEXPAN_H_
#define X_LSEXPAN_H_
#include "lsexpan.h"
#endif

#ifndef X_LSPAIRAC_H_
#define X_LSPAIRAC_H_
#include "lspairac.h"
#endif

#ifndef X_LSKTAB_H_
#define X_LSKTAB_H_
#include "lsktab.h"
#endif

#ifndef X_LSKEOP_H_
#define X_LSKEOP_H_
#include "lskeop.h"
#endif

#ifndef X_PLSQSINF_H_
#define X_PLSQSINF_H_
#include "plsqsinf.h"
#endif

#ifndef X_PCELLDET_H_
#define X_PCELLDET_H_
#include "pcelldet.h"
#endif

#ifndef X_PLSCELL_H_
#define X_PLSCELL_H_
#include "plscell.h"
#endif

#ifndef X_BRKPOS_H_
#define X_BRKPOS_H_
#include "brkpos.h"
#endif

#ifndef X_LSFUNCWRAP_HXX_
#define X_LSFUNCWRAP_HXX_
#include "lsfuncwrap.hxx"
#endif

// Define the DYNLIB for MSLS
DYNLIB g_dynlibMSLS = { NULL, NULL, "MSLS31.DLL" };

// Define the DYNPROC for all MSLS functions
#define LSWRAP(fn,a1,a2) DYNPROC g_dynproc##fn = { NULL, &g_dynlibMSLS, #fn };
LSFUNCS()
#undef LSWRAP

HRESULT 
InitializeLSDynProcs()
{
    HRESULT hr;

    // It is okay to call LoadProcedure multiple times and on different threads -- we just do this for perf.
    static  BOOL fDLLInited = FALSE;

    if (fDLLInited)
        return S_OK;

#define LSWRAP(fn,a1,a2) \
    hr = THR(LoadProcedure(&g_dynproc##fn));\
    if (hr)\
        goto Cleanup;

    LSFUNCS();
#undef LSWRAP

Cleanup:
    if (!hr)
        fDLLInited = TRUE;

    RRETURN (hr);
}


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\msjava.cxx ===
#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define JAVAVMAPI                  // avoid dll linkage errors

#ifndef X_NATIVE_H_
#define X_NATIVE_H_
#include "native.h"
#endif

#ifndef X_NATIVCOM_H_
#define X_NATIVCOM_H_
#include "nativcom.h"
#endif



DYNLIB g_dynlibMSJAVA = { NULL, NULL, "MSJAVA.DLL" };
extern DYNLIB g_dynlibSHDOCVW;

#define EXTERNC extern "C"

EXTERNC long __cdecl execute_java_dynamic_method(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...)
{
    va_list arg;
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "execute_java_dynamic_methodV" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    va_start(arg, signature);

    int64_t retVal = (*(int64_t (__cdecl *)(ExecEnv*, HObject*, const char *,
        const char*, va_list))s_dynproc.pfn)
            ( ee, obj, method_name, signature, arg);
    va_end(arg);
    return (long)retVal;
}

EXTERNC int64_t __cdecl execute_java_dynamic_method64(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...)
{
    va_list arg;
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "execute_java_dynamic_methodV" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    va_start(arg, signature);

    int64_t retVal = (*(int64_t (__cdecl *)(ExecEnv*, HObject*, const char *,
        const char*, va_list))s_dynproc.pfn)
            ( ee, obj, method_name, signature, arg);
    va_end(arg);
    return retVal;
}

EXTERNC HObject* __cdecl execute_java_constructor(ExecEnv *ee, const char *classname,       \
        ClassClass *cb, const char *signature, ...)
{
    va_list arg;
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "execute_java_constructorV" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    va_start(arg, signature);

    HObject* retVal = (*(HObject* (__cdecl *)(ExecEnv*, const char *,
        ClassClass*, const char*, va_list))s_dynproc.pfn)
            ( ee, classname, cb, signature, arg );
    va_end(arg);
    return retVal;
}

EXTERNC BOOL __cdecl is_instance_of(JHandle *phobj,ClassClass *dcb,ExecEnv *ee)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "is_instance_of" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return FALSE;

    return (*(BOOL (__cdecl *)(JHandle*,ClassClass*,ExecEnv*))s_dynproc.pfn)
            ( phobj, dcb, ee );
}

EXTERNC Hjava_lang_String* __cdecl makeJavaStringW(const unicode *pszwSrc, int cch)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "makeJavaStringW" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(Hjava_lang_String* (__cdecl *)(const unicode*,int))s_dynproc.pfn)
            ( pszwSrc, cch );
}

EXTERNC ClassClass* __cdecl FindClass(ExecEnv *ee, PCUTF8 classname, bool_t resolve)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "FindClass" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(ClassClass* (__cdecl *)(ExecEnv*, PCUTF8, bool_t))s_dynproc.pfn)
            ( ee, classname, resolve );
}

EXTERNC unicode * __cdecl javaStringStart (HString *string)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "javaStringStart" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(unicode* (__cdecl *)(HString*))s_dynproc.pfn)
            ( string );
}

EXTERNC int __cdecl javaStringLength(Hjava_lang_String *string)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "javaStringLength" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return 0;

    return (*(int (__cdecl *)(HString*))s_dynproc.pfn)
            ( string );
}

Hjava_lang_Object * __cdecl convert_IUnknown_to_Java_Object(IUnknown *punk,
                                                            Hjava_lang_Object *phJavaClass,
                                                            int       fAssumeThreadSafe)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "convert_IUnknown_to_Java_Object" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    return (*(Hjava_lang_Object* (__cdecl *)(IUnknown*,
                                              Hjava_lang_Object*,
                                              int))s_dynproc.pfn)
            ( punk, phJavaClass, fAssumeThreadSafe );
}

IUnknown * __cdecl convert_Java_Object_to_IUnknown(Hjava_lang_Object *phJavaObject, const IID *pIID)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "convert_Java_Object_to_IUnknown" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    return (*(IUnknown* (__cdecl *)(Hjava_lang_Object*,
                                     const IID*))s_dynproc.pfn)
            ( phJavaObject, pIID );
}

void __cdecl GCFramePush(PVOID pGCFrame, PVOID pObjects, DWORD cbObjectStructSize)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "GCFramePush" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return;

    (*(void (__cdecl *)(PVOID, PVOID, DWORD))s_dynproc.pfn)
            ( pGCFrame, pObjects, cbObjectStructSize );
}

void __cdecl GCFramePop(PVOID pGCFrame)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "GCFramePop" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return;

    (*(void (__cdecl *)(PVOID))s_dynproc.pfn) ( pGCFrame );
}

void* __cdecl jcdwGetData(Hjava_lang_Object * phJCDW)
{
    static DYNPROC s_dynproc = { NULL, &g_dynlibMSJAVA, "jcdwGetData" };
    HRESULT hr = LoadProcedure(&s_dynproc);
    if (hr)
        return NULL;

    return (*(void* (__cdecl *)(Hjava_lang_Object*))s_dynproc.pfn)
            ( phJCDW );
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\oleaut32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       oleaut32.cxx
//
//  Contents:   Dynamic wrappers for OLE Automation monikers.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

DYNLIB g_dynlibOLEAUT32 = { NULL, NULL, "oleaut32.dll" };

#define WRAP_HR(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAP_HR_NOTHR(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = (*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAP(t, fn, a1, a2)\
STDAPI_(t) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return 0;\
    return (*(t (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAP_VOID(fn, a1, a2)\
STDAPI_(void) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEAUT32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return;\
    (*(void (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}

WINOLEAUTAPI_(void )
VariantInit(VARIANTARG *pvarg)
{
	pvarg->vt = VT_EMPTY;
}

WINOLEAUTAPI
VariantClear(VARIANTARG *pvarg)
{
    HRESULT hr;
    static DYNPROC s_dynprocVariantClear = { NULL, &g_dynlibOLEAUT32, "VariantClear" };

	switch (pvarg->vt)
	{
	case VT_I1:
	case VT_I2:
	case VT_I4:
	case VT_R4:
	case VT_R8:
	case VT_CY:
	case VT_NULL:
	case VT_EMPTY:
	case VT_BOOL:
		break;
		
	case VT_DISPATCH:
	case VT_UNKNOWN:
		ReleaseInterface(V_UNKNOWN(pvarg));
		break;

    case VT_SAFEARRAY:
        THR(SafeArrayDestroy(V_ARRAY(pvarg)));
        break;
		
	default:
		hr = THR(LoadProcedure(&s_dynprocVariantClear));
		if (hr)
			RRETURN(hr);
		hr = THR((*(HRESULT (STDAPICALLTYPE *) (VARIANTARG *))s_dynprocVariantClear.pfn)(pvarg));
		RRETURN(hr);
	}

	V_VT(pvarg) = VT_EMPTY;
	RRETURN(S_OK);
}

WRAP_HR(RegisterTypeLib,
    (ITypeLib *ptlib, OLECHAR *szFullPath, OLECHAR *szHelpDir),
    (ptlib, szFullPath, szHelpDir))

WRAP_HR(LoadTypeLib,
    (const OLECHAR *szFile, ITypeLib **pptlib), 
    (szFile, pptlib))

WRAP_HR(SetErrorInfo,
   (unsigned long dwReserved, IErrorInfo*perrinfo), 
   (dwReserved, perrinfo))

WRAP_HR(GetErrorInfo, 
    (ULONG dwReserved, IErrorInfo ** pperrinfo), 
    (dwReserved, pperrinfo))

WRAP_HR(LoadRegTypeLib,
    (REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib **pptlib),
    (rguid, wVerMajor, wVerMinor, lcid, pptlib))

WINOLEAUTAPI
VariantCopy(VARIANTARG *pvargDest, VARIANTARG *pvargSrc)
{
    HRESULT hr;
    static DYNPROC s_dynprocVariantCopy = { NULL, &g_dynlibOLEAUT32, "VariantCopy" };

	switch (pvargSrc->vt)
	{
	case VT_I1:
	case VT_I2:
	case VT_I4:
	case VT_R4:
	case VT_R8:
	case VT_CY:
	case VT_NULL:
	case VT_EMPTY:
	case VT_BOOL:
        hr = S_OK;
		break;
		
	case VT_DISPATCH:
	case VT_UNKNOWN:
        hr = S_OK;
		if ( V_UNKNOWN(pvargSrc) )
			V_UNKNOWN(pvargSrc)->AddRef();
		break;

    case VT_SAFEARRAY:
        hr = S_OK;
        pvargDest->vt = VT_SAFEARRAY;
        if (V_ARRAY(pvargSrc))
            hr = THR(SafeArrayCopy(V_ARRAY(pvargSrc), &V_ARRAY(pvargDest)));
        else
            V_ARRAY(pvargDest) = NULL;
        RRETURN(hr);
        break;

	default:
		hr = THR(LoadProcedure(&s_dynprocVariantCopy));
		if (hr)
			RRETURN(hr);
		hr = THR((*(HRESULT (STDAPICALLTYPE *) (VARIANTARG *, VARIANTARG *))s_dynprocVariantCopy.pfn)(pvargDest, pvargSrc));
		RRETURN(hr);
	}

    VariantClear(pvargDest);
    *pvargDest = *pvargSrc;
	RRETURN(hr);
}

WRAP_HR(VariantChangeType,
    (VARIANTARG *pvargDest, VARIANTARG *pvarSrc, unsigned short wFlags, VARTYPE vt),
    (pvargDest, pvarSrc, wFlags, vt))

WRAP(BSTR, SysAllocStringLen,
    (const OLECHAR*pch, unsigned int i), (pch, i))

WRAP(BSTR, SysAllocString,
    (const OLECHAR*pch), (pch))

WRAP(BSTR, SysAllocStringByteLen, (LPCSTR psz, UINT len), (psz, len))

STDAPI_(void) SysFreeString(BSTR bs)
{
    if (bs)
    {
        HRESULT hr;
        static DYNPROC s_dynprocSysFreeString = { NULL, &g_dynlibOLEAUT32, "SysFreeString" };
        hr = THR(LoadProcedure(&s_dynprocSysFreeString));
        if (hr)
            return;
        (*(void (STDAPICALLTYPE *) (BSTR bs))s_dynprocSysFreeString.pfn)(bs);
    }
}

WRAP_HR(DispGetIDsOfNames,
    (ITypeInfo*ptinfo, OLECHAR **rgszNames, UINT cNames, DISPID*rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid))

WRAP_HR(DispInvoke, 
        (void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags, 
         DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr),
        ( _this, ptinfo, dispidMember, wFlags, pparams, pvarResult, pexcepinfo, puArgErr))

WRAP_HR(CreateErrorInfo,
    (ICreateErrorInfo **pperrinfo), (pperrinfo))

WRAP(SAFEARRAY *, SafeArrayCreateVector,
    (VARTYPE vt, long iBound, ULONG cElements), (vt, iBound, cElements) );

WRAP_HR(SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData), (psa, ppvData))

WRAP_HR(SafeArrayUnaccessData,
    (SAFEARRAY * psa), (psa) );

WRAP(UINT, SafeArrayGetElemsize,
    (SAFEARRAY * psa), (psa) );

WRAP_HR(SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUBound),
    (psa,nDim,plUBound))

WRAP_HR(SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv), (psa, rgIndices, pv))

WRAP(UINT, SafeArrayGetDim,
    (SAFEARRAY * psa), (psa))

WRAP(UINT, SysStringLen,
    (BSTR bstr), (bstr))

WRAP_HR(SafeArrayDestroy,
    (SAFEARRAY * psa), (psa))

WRAP(INT, DosDateTimeToVariantTime,
    (USHORT wDosDate, USHORT wDosTime, DOUBLE * pvtime), (wDosDate, wDosTime, pvtime))

WRAP(UINT, SysStringByteLen, (BSTR bstr), (bstr))

WRAP_HR_NOTHR(VariantChangeTypeEx, 
    (VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt),
    (pvargDest, pvarSrc, lcid, wFlags, vt))

WRAP_HR(CreateTypeLib2,
    (SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib2 **ppctlib),
    (syskind, szFile, ppctlib))

WRAP(SAFEARRAY *, SafeArrayCreate,
        (VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound),
        (vt, cDims, rgsabound))

WRAP_HR(SafeArrayPutElement,
        (SAFEARRAY * psa, LONG * rgIndices, void * pv),
        (psa, rgIndices, pv))

WRAP_HR(UnRegisterTypeLib,
    (REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind),
    (libID, wVerMajor, wVerMinor, lcid, syskind))

WRAP_HR(SafeArrayDestroyData,
    (SAFEARRAY * psa),
    (psa))

WRAP_HR(SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLbound),
    (psa, nDim, plLbound))

WRAP_HR(SafeArrayCopy,
    (SAFEARRAY * psa, SAFEARRAY ** ppsaOut),
    (psa, ppsaOut))

WRAP(INT, SysReAllocString, (BSTR *a, const OLECHAR *b), (a, b))
WRAP(INT, SysReAllocStringLen, (BSTR *a, const OLECHAR *b, UINT c), (a, b, c))

WRAP_HR(VarUI1FromI2, (SHORT sIn, BYTE * pbOut), (sIn, pbOut))
WRAP_HR(VarUI1FromI4, (LONG lIn, BYTE * pbOut), (lIn, pbOut))
WRAP_HR(VarUI1FromR4, (FLOAT fltIn, BYTE * pbOut), (fltIn, pbOut))
WRAP_HR(VarUI1FromR8, (DOUBLE dblIn, BYTE * pbOut), (dblIn, pbOut))
WRAP_HR(VarUI1FromCy, (CY cyIn, BYTE * pbOut), (cyIn, pbOut))
WRAP_HR(VarUI1FromDate, (DATE dateIn, BYTE * pbOut), (dateIn, pbOut))
WRAP_HR(VarUI1FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, BYTE * pbOut), (strIn, lcid, dwFlags, pbOut))
WRAP_HR(VarUI1FromDisp, (IDispatch * pdispIn, LCID lcid, BYTE * pbOut), (pdispIn, lcid, pbOut))
WRAP_HR(VarUI1FromBool, (VARIANT_BOOL boolIn, BYTE * pbOut), (boolIn, pbOut))
WRAP_HR(VarUI1FromI1, (CHAR cIn, BYTE *pbOut), (cIn, pbOut))
WRAP_HR(VarUI1FromUI2, (USHORT uiIn, BYTE *pbOut), (uiIn, pbOut))
WRAP_HR(VarUI1FromUI4, (ULONG ulIn, BYTE *pbOut), (ulIn, pbOut))
WRAP_HR(VarUI1FromDec, (DECIMAL *pdecIn, BYTE *pbOut), (pdecIn, pbOut))
WRAP_HR(VarI2FromUI1, (BYTE bIn, SHORT * psOut), (bIn, psOut))
WRAP_HR(VarI2FromI4, (LONG lIn, SHORT * psOut), (lIn, psOut))
WRAP_HR(VarI2FromR4, (FLOAT fltIn, SHORT * psOut), (fltIn, psOut))
WRAP_HR(VarI2FromR8, (DOUBLE dblIn, SHORT * psOut), (dblIn, psOut))
WRAP_HR(VarI2FromCy, (CY cyIn, SHORT * psOut), (cyIn, psOut))
WRAP_HR(VarI2FromDate, (DATE dateIn, SHORT * psOut), (dateIn, psOut))
WRAP_HR(VarI2FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, SHORT * psOut), (strIn, lcid, dwFlags, psOut))
WRAP_HR(VarI2FromDisp, (IDispatch * pdispIn, LCID lcid, SHORT * psOut), (pdispIn, lcid, psOut))
WRAP_HR(VarI2FromBool, (VARIANT_BOOL boolIn, SHORT * psOut), (boolIn, psOut))
WRAP_HR(VarI2FromI1, (CHAR cIn, SHORT *psOut), (cIn, psOut))
WRAP_HR(VarI2FromUI2, (USHORT uiIn, SHORT *psOut), (uiIn, psOut))
WRAP_HR(VarI2FromUI4, (ULONG ulIn, SHORT *psOut), (ulIn, psOut))
WRAP_HR(VarI2FromDec, (DECIMAL *pdecIn, SHORT *psOut), (pdecIn, psOut))
WRAP_HR(VarI4FromUI1, (BYTE bIn, LONG * plOut), (bIn, plOut))
WRAP_HR(VarI4FromI2, (SHORT sIn, LONG * plOut), (sIn, plOut))
WRAP_HR(VarI4FromR4, (FLOAT fltIn, LONG * plOut), (fltIn, plOut))
WRAP_HR(VarI4FromR8, (DOUBLE dblIn, LONG * plOut), (dblIn, plOut))
WRAP_HR(VarI4FromCy, (CY cyIn, LONG * plOut), (cyIn, plOut))
WRAP_HR(VarI4FromDate, (DATE dateIn, LONG * plOut), (dateIn, plOut))
WRAP_HR(VarI4FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, LONG * plOut), (strIn, lcid, dwFlags, plOut))
WRAP_HR(VarI4FromDisp, (IDispatch * pdispIn, LCID lcid, LONG * plOut), (pdispIn, lcid, plOut))
WRAP_HR(VarI4FromBool, (VARIANT_BOOL boolIn, LONG * plOut), (boolIn, plOut))
WRAP_HR(VarI4FromI1, (CHAR cIn, LONG *plOut), (cIn, plOut))
WRAP_HR(VarI4FromUI2, (USHORT uiIn, LONG *plOut), (uiIn, plOut))
WRAP_HR(VarI4FromUI4, (ULONG ulIn, LONG *plOut), (ulIn, plOut))
WRAP_HR(VarI4FromDec, (DECIMAL *pdecIn, LONG *plOut), (pdecIn, plOut))
//WRAP_HR(VarI4FromInt, (INT intIn, LONG *plOut), (intIn, plOut))
WRAP_HR(VarR4FromUI1, (BYTE bIn, FLOAT * pfltOut), (bIn, pfltOut))
WRAP_HR(VarR4FromI2, (SHORT sIn, FLOAT * pfltOut), (sIn, pfltOut))
WRAP_HR(VarR4FromI4, (LONG lIn, FLOAT * pfltOut), (lIn, pfltOut))
WRAP_HR(VarR4FromR8, (DOUBLE dblIn, FLOAT * pfltOut), (dblIn, pfltOut))
WRAP_HR(VarR4FromCy, (CY cyIn, FLOAT * pfltOut), (cyIn, pfltOut))
WRAP_HR(VarR4FromDate, (DATE dateIn, FLOAT * pfltOut), (dateIn, pfltOut))
WRAP_HR(VarR4FromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, FLOAT *pfltOut), (strIn, lcid, dwFlags, pfltOut))
WRAP_HR(VarR4FromDisp, (IDispatch * pdispIn, LCID lcid, FLOAT * pfltOut), (pdispIn, lcid, pfltOut))
WRAP_HR(VarR4FromBool, (VARIANT_BOOL boolIn, FLOAT * pfltOut), (boolIn, pfltOut))
WRAP_HR(VarR4FromI1, (CHAR cIn, FLOAT *pfltOut), (cIn, pfltOut))
WRAP_HR(VarR4FromUI2, (USHORT uiIn, FLOAT *pfltOut), (uiIn, pfltOut))
WRAP_HR(VarR4FromUI4, (ULONG ulIn, FLOAT *pfltOut), (ulIn, pfltOut))
WRAP_HR(VarR4FromDec, (DECIMAL *pdecIn, FLOAT *pfltOut), (pdecIn, pfltOut))
WRAP_HR(VarR8FromUI1, (BYTE bIn, DOUBLE * pdblOut), (bIn, pdblOut))
WRAP_HR(VarR8FromI2, (SHORT sIn, DOUBLE * pdblOut), (sIn, pdblOut))
WRAP_HR(VarR8FromI4, (LONG lIn, DOUBLE * pdblOut), (lIn, pdblOut))
WRAP_HR(VarR8FromR4, (FLOAT fltIn, DOUBLE * pdblOut), (fltIn, pdblOut))
WRAP_HR(VarR8FromCy, (CY cyIn, DOUBLE * pdblOut), (cyIn, pdblOut))
WRAP_HR(VarR8FromDate, (DATE dateIn, DOUBLE * pdblOut), (dateIn, pdblOut))
WRAP_HR(VarR8FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, DOUBLE *pdblOut), (strIn, lcid, dwFlags, pdblOut))
WRAP_HR(VarR8FromDisp, (IDispatch * pdispIn, LCID lcid, DOUBLE * pdblOut), (pdispIn, lcid, pdblOut))
WRAP_HR(VarR8FromBool, (VARIANT_BOOL boolIn, DOUBLE * pdblOut), (boolIn, pdblOut))
WRAP_HR(VarR8FromI1, (CHAR cIn, DOUBLE *pdblOut), (cIn, pdblOut))
WRAP_HR(VarR8FromUI2, (USHORT uiIn, DOUBLE *pdblOut), (uiIn, pdblOut))
WRAP_HR(VarR8FromUI4, (ULONG ulIn, DOUBLE *pdblOut), (ulIn, pdblOut))
WRAP_HR(VarR8FromDec, (DECIMAL *pdecIn, DOUBLE *pdblOut), (pdecIn, pdblOut))
WRAP_HR(VarDateFromUI1, (BYTE bIn, DATE * pdateOut), (bIn, pdateOut))
WRAP_HR(VarDateFromI2, (SHORT sIn, DATE * pdateOut), (sIn, pdateOut))
WRAP_HR(VarDateFromI4, (LONG lIn, DATE * pdateOut), (lIn, pdateOut))
WRAP_HR(VarDateFromR4, (FLOAT fltIn, DATE * pdateOut), (fltIn, pdateOut))
WRAP_HR(VarDateFromR8, (DOUBLE dblIn, DATE * pdateOut), (dblIn, pdateOut))
WRAP_HR(VarDateFromCy, (CY cyIn, DATE * pdateOut), (cyIn, pdateOut))
WRAP_HR(VarDateFromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, DATE *pdateOut), (strIn, lcid, dwFlags, pdateOut))
WRAP_HR(VarDateFromDisp, (IDispatch * pdispIn, LCID lcid, DATE * pdateOut), (pdispIn, lcid, pdateOut))
WRAP_HR(VarDateFromBool, (VARIANT_BOOL boolIn, DATE * pdateOut), (boolIn, pdateOut))
WRAP_HR(VarDateFromI1, (CHAR cIn, DATE *pdateOut), (cIn, pdateOut))
WRAP_HR(VarDateFromUI2, (USHORT uiIn, DATE *pdateOut), (uiIn, pdateOut))
WRAP_HR(VarDateFromUI4, (ULONG ulIn, DATE *pdateOut), (ulIn, pdateOut))
WRAP_HR(VarDateFromDec, (DECIMAL *pdecIn, DATE *pdateOut), (pdecIn, pdateOut))
WRAP_HR(VarCyFromUI1, (BYTE bIn, CY * pcyOut), (bIn, pcyOut))
WRAP_HR(VarCyFromI2, (SHORT sIn, CY * pcyOut), (sIn, pcyOut))
WRAP_HR(VarCyFromI4, (LONG lIn, CY * pcyOut), (lIn, pcyOut))
WRAP_HR(VarCyFromR4, (FLOAT fltIn, CY * pcyOut), (fltIn, pcyOut))
WRAP_HR(VarCyFromR8, (DOUBLE dblIn, CY * pcyOut), (dblIn, pcyOut))
WRAP_HR(VarCyFromDate, (DATE dateIn, CY * pcyOut), (dateIn, pcyOut))
WRAP_HR(VarCyFromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, CY * pcyOut), (strIn, lcid, dwFlags, pcyOut))
WRAP_HR(VarCyFromDisp, (IDispatch * pdispIn, LCID lcid, CY * pcyOut), (pdispIn, lcid, pcyOut))
WRAP_HR(VarCyFromBool, (VARIANT_BOOL boolIn, CY * pcyOut), (boolIn, pcyOut))
WRAP_HR(VarCyFromI1, (CHAR cIn, CY *pcyOut), (cIn, pcyOut))
WRAP_HR(VarCyFromUI2, (USHORT uiIn, CY *pcyOut), (uiIn, pcyOut))
WRAP_HR(VarCyFromUI4, (ULONG ulIn, CY *pcyOut), (ulIn, pcyOut))
WRAP_HR(VarCyFromDec, (DECIMAL *pdecIn, CY *pcyOut), (pdecIn, pcyOut))
WRAP_HR(VarBstrFromUI1, (BYTE bVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (bVal, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromI2, (SHORT iVal, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (iVal, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromI4, (LONG lIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (lIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromR4, (FLOAT fltIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (fltIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromR8, (DOUBLE dblIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (dblIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromCy, (CY cyIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (cyIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromDate, (DATE dateIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (dateIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromDisp, (IDispatch * pdispIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (pdispIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromBool, (VARIANT_BOOL boolIn, LCID lcid, ULONG dwFlags, BSTR * pbstrOut), (boolIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromI1, (CHAR cIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (cIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromUI2, (USHORT uiIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (uiIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromUI4, (ULONG ulIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (ulIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBstrFromDec, (DECIMAL *pdecIn, LCID lcid, ULONG dwFlags, BSTR *pbstrOut), (pdecIn, lcid, dwFlags, pbstrOut))
WRAP_HR(VarBoolFromUI1, (BYTE bIn, VARIANT_BOOL * pboolOut), (bIn, pboolOut))
WRAP_HR(VarBoolFromI2, (SHORT sIn, VARIANT_BOOL * pboolOut), (sIn, pboolOut))
WRAP_HR(VarBoolFromI4, (LONG lIn, VARIANT_BOOL * pboolOut), (lIn, pboolOut))
WRAP_HR(VarBoolFromR4, (FLOAT fltIn, VARIANT_BOOL * pboolOut), (fltIn, pboolOut))
WRAP_HR(VarBoolFromR8, (DOUBLE dblIn, VARIANT_BOOL * pboolOut), (dblIn, pboolOut))
WRAP_HR(VarBoolFromDate, (DATE dateIn, VARIANT_BOOL * pboolOut), (dateIn, pboolOut))
WRAP_HR(VarBoolFromCy, (CY cyIn, VARIANT_BOOL * pboolOut), (cyIn, pboolOut))
WRAP_HR(VarBoolFromStr, (OLECHAR * strIn, LCID lcid, ULONG dwFlags, VARIANT_BOOL * pboolOut), (strIn, lcid, dwFlags, pboolOut))
WRAP_HR(VarBoolFromDisp, (IDispatch * pdispIn, LCID lcid, VARIANT_BOOL * pboolOut), (pdispIn, lcid, pboolOut))
WRAP_HR(VarBoolFromI1, (CHAR cIn, VARIANT_BOOL *pboolOut), (cIn, pboolOut))
WRAP_HR(VarBoolFromUI2, (USHORT uiIn, VARIANT_BOOL *pboolOut), (uiIn, pboolOut))
WRAP_HR(VarBoolFromUI4, (ULONG ulIn, VARIANT_BOOL *pboolOut), (ulIn, pboolOut))
WRAP_HR(VarBoolFromDec, (DECIMAL *pdecIn, VARIANT_BOOL *pboolOut), (pdecIn, pboolOut))
WRAP_HR(VarI1FromUI1, (BYTE bIn, CHAR *pcOut), (bIn, pcOut))
WRAP_HR(VarI1FromI2, (SHORT uiIn, CHAR *pcOut), (uiIn, pcOut))
WRAP_HR(VarI1FromI4, (LONG lIn, CHAR *pcOut), (lIn, pcOut))
WRAP_HR(VarI1FromR4, (FLOAT fltIn, CHAR *pcOut), (fltIn, pcOut))
WRAP_HR(VarI1FromR8, (DOUBLE dblIn, CHAR *pcOut), (dblIn, pcOut))
WRAP_HR(VarI1FromDate, (DATE dateIn, CHAR *pcOut), (dateIn, pcOut))
WRAP_HR(VarI1FromCy, (CY cyIn, CHAR *pcOut), (cyIn, pcOut))
WRAP_HR(VarI1FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, CHAR *pcOut), (strIn, lcid, dwFlags, pcOut))
WRAP_HR(VarI1FromDisp, (IDispatch *pdispIn, LCID lcid, CHAR *pcOut), (pdispIn, lcid, pcOut))
WRAP_HR(VarI1FromBool, (VARIANT_BOOL boolIn, CHAR *pcOut), (boolIn, pcOut))
WRAP_HR(VarI1FromUI2, (USHORT uiIn, CHAR *pcOut), (uiIn, pcOut))
WRAP_HR(VarI1FromUI4, (ULONG ulIn, CHAR *pcOut), (ulIn, pcOut))
WRAP_HR(VarI1FromDec, (DECIMAL *pdecIn, CHAR *pcOut), (pdecIn, pcOut))
WRAP_HR(VarUI2FromUI1, (BYTE bIn, USHORT *puiOut), (bIn, puiOut))
WRAP_HR(VarUI2FromI2, (SHORT uiIn, USHORT *puiOut), (uiIn, puiOut))
WRAP_HR(VarUI2FromI4, (LONG lIn, USHORT *puiOut), (lIn, puiOut))
WRAP_HR(VarUI2FromR4, (FLOAT fltIn, USHORT *puiOut), (fltIn, puiOut))
WRAP_HR(VarUI2FromR8, (DOUBLE dblIn, USHORT *puiOut), (dblIn, puiOut))
WRAP_HR(VarUI2FromDate, (DATE dateIn, USHORT *puiOut), (dateIn, puiOut))
WRAP_HR(VarUI2FromCy, (CY cyIn, USHORT *puiOut), (cyIn, puiOut))
WRAP_HR(VarUI2FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, USHORT *puiOut), (strIn, lcid, dwFlags, puiOut))
WRAP_HR(VarUI2FromDisp, (IDispatch *pdispIn, LCID lcid, USHORT *puiOut), (pdispIn, lcid, puiOut))
WRAP_HR(VarUI2FromBool, (VARIANT_BOOL boolIn, USHORT *puiOut), (boolIn, puiOut))
WRAP_HR(VarUI2FromI1, (CHAR cIn, USHORT *puiOut), (cIn, puiOut))
WRAP_HR(VarUI2FromUI4, (ULONG ulIn, USHORT *puiOut), (ulIn, puiOut))
WRAP_HR(VarUI2FromDec, (DECIMAL *pdecIn, USHORT *puiOut), (pdecIn, puiOut))
WRAP_HR(VarUI4FromUI1, (BYTE bIn, ULONG *pulOut), (bIn, pulOut))
WRAP_HR(VarUI4FromI2, (SHORT uiIn, ULONG *pulOut), (uiIn, pulOut))
WRAP_HR(VarUI4FromI4, (LONG lIn, ULONG *pulOut), (lIn, pulOut))
WRAP_HR(VarUI4FromR4, (FLOAT fltIn, ULONG *pulOut), (fltIn, pulOut))
WRAP_HR(VarUI4FromR8, (DOUBLE dblIn, ULONG *pulOut), (dblIn, pulOut))
WRAP_HR(VarUI4FromDate, (DATE dateIn, ULONG *pulOut), (dateIn, pulOut))
WRAP_HR(VarUI4FromCy, (CY cyIn, ULONG *pulOut), (cyIn, pulOut))
WRAP_HR(VarUI4FromStr, (OLECHAR *strIn, LCID lcid, ULONG dwFlags, ULONG *pulOut), (strIn, lcid, dwFlags, pulOut))
WRAP_HR(VarUI4FromDisp, (IDispatch *pdispIn, LCID lcid, ULONG *pulOut), (pdispIn, lcid, pulOut))
WRAP_HR(VarUI4FromBool, (VARIANT_BOOL boolIn, ULONG *pulOut), (boolIn, pulOut))
WRAP_HR(VarUI4FromI1, (CHAR cIn, ULONG *pulOut), (cIn, pulOut))
WRAP_HR(VarUI4FromUI2, (USHORT uiIn, ULONG *pulOut), (uiIn, pulOut))
WRAP_HR(VarUI4FromDec, (DECIMAL *pdecIn, ULONG *pulOut), (pdecIn, pulOut))
WRAP_HR(VarFormatCurrency, 
    (LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR *pbstrOut),
    (pvarIn, iNumDig, iIncLead, iUseParens, iGroup, dwFlags, pbstrOut))

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\msrating.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       msrating.cxx
//
//  Contents:   Dynamic wrappers for msrating functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef UNIX // UNIX doesn't use this file

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx"
#endif

DYNLIB g_dynlibMSRATING = { NULL, NULL, "MSRATING.DLL" };

#define WRAPIT(wrapper, fn, a1, a2)\
STDAPI wrapper a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMSRATING, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

WRAPIT(AreRatingsEnabled, RatingEnabledQuery, (), ());

#endif // UNIX doesn't use this file.

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\inetcomm.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       inetcomm.cxx
//
//  Contents:   Dynamic wrappers for INETCOMM.DLL.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_WINCRYPT_H_
#define X_WINCRYPT_H_
#include "wincrypt.h"
#endif

// #define _WIN32_OE  0x0500 // TODO: until this is globally visible - and only if your want MHTML
#ifndef X_MIMEOLE_H_
#define X_MIMEOLE_H_
#define _MIMEOLE_   // To avoid having DECLSPEC_IMPORT
#include "mimeole.h"
#endif

// Turn on DEFINE_GUID
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
  
// {35461E30-C488-11d1-960E-00C04FBD7C09}
DEFINE_GUID(CLSID_IMimeObjResolver, 0x35461e30, 0xc488, 0x11d1, 0x96, 0xe, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

// {FECEAFFD-C441-11d1-960E-00C04FBD7C09}
DEFINE_GUID(IID_IMimeObjResolver, 0xfeceaffd, 0xc441, 0x11d1, 0x96, 0xe, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

DYNLIB g_dynlibINETCOMM = { NULL, NULL, "INETCOMM.DLL" };        

//+---------------------------------------------------------------------------
//
//  Function:   MimeOleObjectFromMoniker
//
//  Synopsis:   Wraps either IMimeObjResolver.MimeOleObjectFromMoniker or 
//              imported function MimeOleObjectFromMoniker from INETCOMM.DLL
//              First, we attempt to cocreate an IMimeObjResolver. If this
//              fails, we try to call the INETCOMM.DLL directly. If this
//              fails, many bad things will happen.
//
//----------------------------------------------------------------------------

HRESULT WINAPI  MimeOleObjectFromMoniker(
            /* in */        BINDF               bindf,
            /* in */        IMoniker            *pmkOriginal,
            /* in */        IBindCtx            *pBindCtx,
            /* in */        REFIID              riid, 
            /* out */       LPVOID              *ppvObject,
            /* out */       IMoniker            **ppmkNew )
{
    HRESULT hr = E_FAIL;

    // Load IMimeObjResolver from CoCreateInstance
    IMimeObjResolver * pObjResolver = NULL;

    hr = THR( CoCreateInstance( CLSID_IMimeObjResolver, 
                                NULL, 
                                CLSCTX_INPROC_SERVER,
                                IID_IMimeObjResolver,
                                (void **) &pObjResolver ));

    if(! FAILED( hr ))
    {
        // If we sucessfully cocreated the object, dispatch to it
        hr = pObjResolver->MimeOleObjectFromMoniker( bindf, pmkOriginal, pBindCtx, riid, ppvObject, ppmkNew );
        pObjResolver->Release();
        pObjResolver = NULL;
    }
    else
    {
        // LoadLibrary and call the exported function directly
        static DYNPROC s_dynprocMOOFM = { NULL, &g_dynlibINETCOMM, "MimeOleObjectFromMoniker" };
        hr = THR( LoadProcedure( &s_dynprocMOOFM ));
        
        if (hr)
            goto Cleanup;
            
        // The following mess is defining, derefing, and calling a function pointer pfn                                    
        hr = THR((* ( HRESULT (WINAPI *) (  BINDF bindf, 
                                            IMoniker *pmkOriginal, 
                                            IBindCtx *pBindCtx, 
                                            REFIID riid, 
                                            LPVOID *ppvObject, 
                                            IMoniker **ppmkNew )        // api of fn ptr
                    ) s_dynprocMOOFM.pfn )( bindf,                      // call to fn ptr
                                            pmkOriginal, 
                                            pBindCtx, 
                                            riid, 
                                            ppvObject, 
                                            ppmkNew )  );
    }

Cleanup:
    RRETURN2( hr, S_FALSE, MK_S_ASYNCHRONOUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\shell32.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       Shell32.cxx
//
//  Contents:   Dynamic wrappers for shell procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#define _SHELL32_
#define _SHDOCVW_
#include <shellapi.h>
#endif

#ifndef X_SHFOLDER_HXX_
#define X_SHFOLDER_HXX_
#define _SHFOLDER_
#include "shfolder.h"
#endif

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

#ifndef DLOAD1
int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1);

DYNLIB g_dynlibSHELL32 = { NULL, NULL, "SHELL32.DLL" };
DYNLIB g_dynlibSHFOLDER = { NULL, NULL, "SHFOLDER.DLL" };
#endif // DLOAD1

extern DYNLIB g_dynlibSHDOCVW;

#ifndef DLOAD1
HINSTANCE APIENTRY
ShellExecuteA(HWND hwnd,	LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameter, LPCSTR lpDirectory, INT nShowCmd)
{
    static DYNPROC s_dynprocShellExecuteA =
            { NULL, &g_dynlibSHELL32, "ShellExecuteA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocShellExecuteA);
    if (hr) 
        return (HINSTANCE)NULL;

    return (*(HINSTANCE (APIENTRY *)(HWND, LPCSTR, LPCSTR, LPCSTR, LPCSTR, INT))s_dynprocShellExecuteA.pfn)
            (hwnd, lpOperation, lpFile, lpParameter, lpDirectory, nShowCmd);
}

HINSTANCE APIENTRY
ShellExecuteW(HWND hwnd,	LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameter, LPCWSTR lpDirectory, INT nShowCmd)
{
    CStrIn strInOperation(lpOperation);
    CStrIn strInFile(lpFile);
    CStrIn strInParameter(lpParameter);
    CStrIn strInDirectory(lpDirectory);

    return ShellExecuteA(hwnd, strInOperation, strInFile, strInParameter, strInDirectory, nShowCmd);
}


DWORD_PTR WINAPI 
SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
    static DYNPROC s_dynprocSHGetFileInfoA =
            { NULL, &g_dynlibSHELL32, "SHGetFileInfoA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocSHGetFileInfoA);
    if (hr) 
        return 0;

    return (*(DWORD_PTR (APIENTRY *)(LPCSTR, DWORD, SHFILEINFOA *, UINT, UINT))s_dynprocSHGetFileInfoA.pfn)
            (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
}

DWORD_PTR WINAPI 
SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
    Assert(cbFileInfo == sizeof(SHFILEINFOW));
    Assert(psfi);

    if (!g_fUnicodePlatform)
    {
        CStrIn      strPath(pszPath);
        SHFILEINFOA sfi;
        DWORD_PTR   dw;

        memset(&sfi, 0, sizeof(sfi));
        dw = SHGetFileInfoA(strPath, dwFileAttributes, &sfi, sizeof(sfi), uFlags);

        psfi->hIcon = sfi.hIcon;
        psfi->iIcon = sfi.iIcon;
        psfi->dwAttributes = sfi.dwAttributes;
        UnicodeFromMbcs(psfi->szDisplayName, ARRAY_SIZE(psfi->szDisplayName), sfi.szDisplayName);
        UnicodeFromMbcs(psfi->szTypeName, ARRAY_SIZE(psfi->szTypeName), sfi.szTypeName);

        return dw;
    }
    else
    {
        static DYNPROC s_dynprocSHGetFileInfoW =
                { NULL, &g_dynlibSHELL32, "SHGetFileInfoW" };

        HRESULT hr;

        hr = LoadProcedure(&s_dynprocSHGetFileInfoW);
        if (hr) 
            return 0;

        return (*(DWORD_PTR (APIENTRY *)(LPCWSTR, DWORD, SHFILEINFOW *, UINT, UINT))s_dynprocSHGetFileInfoW.pfn)
                (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
    }
}

#if !defined(_M_IX86) || defined(WINCE)

UINT WINAPI ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, 
	HICON FAR *phiconSmall, UINT nIcons)
{
    static DYNPROC s_dynprocExtractIconExW =
            { NULL, &g_dynlibSHELL32, "ExtractIconExW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocExtractIconExW);
    if (hr) 
        return 0;

    return (*(UINT (APIENTRY *)(LPCWSTR, int, HICON FAR *, HICON FAR *, UINT))s_dynprocExtractIconExW.pfn)
            (lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
}

HICON WINAPI ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
    static DYNPROC s_dynprocExtractIconW =
            { NULL, &g_dynlibSHELL32, "ExtractIconW" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocExtractIconW);
    if (hr) 
        return 0;

    return (*(HICON (APIENTRY *)(HINSTANCE, LPCWSTR, UINT))s_dynprocExtractIconW.pfn)
            (hInst, lpszExeFileName, nIconIndex);  
}

#endif

#endif // DLOAD1

//+---------------------------------------------------------------------------
//
//  Function:   DoFileDownLoad
//
//  Synopsis:   calls the DoFileDownload proc in SHDOCVW.DLL
//
//  Arguments:  [pchHref]   ref to file to download
//
//
//----------------------------------------------------------------------------
HRESULT
DoFileDownLoad(const TCHAR * pchHref)
{
    static DYNPROC s_dynprocFileDownload =
            { NULL, &g_dynlibSHDOCVW, "DoFileDownload" };
    HRESULT hr = LoadProcedure(&s_dynprocFileDownload);

    Assert(pchHref);

    if (!hr)
    {
        hr = (*(HRESULT (APIENTRY*)(LPCWSTR))s_dynprocFileDownload.pfn)(pchHref); 
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

#ifdef NO_MARSHALLING

SHDOCAPI APIENTRY CoCreateInternetExplorer( REFIID iid, DWORD dwClsContext, void **ppvunk );

HRESULT APIENTRY
CoCreateInternetExplorer( REFIID iid, DWORD dwClsContext, void **ppvunk )
{
    static DYNPROC s_dynprocCoCreateInternetExplorer =
            { NULL, &g_dynlibSHDOCVW, "CoCreateInternetExplorer" };
    HRESULT hr = LoadProcedure(&s_dynprocCoCreateInternetExplorer);

    if (!hr)
    {
            hr = (*(HRESULT (APIENTRY*)(REFIID, DWORD, void**))s_dynprocCoCreateInternetExplorer.pfn)(iid, dwClsContext, ppvunk); 
    }
    else
    {
            hr = E_FAIL;
    }

    return hr;
}

#endif

#ifndef DLOAD1

HICON APIENTRY
ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon)
{
    static DYNPROC s_dynprocExtractAssociatedIconA =
            { NULL, &g_dynlibSHELL32, "ExtractAssociatedIconA" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocExtractAssociatedIconA);
    if (hr) 
        return (HICON) NULL;

    return (*(HICON (APIENTRY *)(HINSTANCE, LPSTR, LPWORD))s_dynprocExtractAssociatedIconA.pfn)
            (hInst, lpIconPath, lpiIcon);
}

HICON APIENTRY
ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
    CStrIn strIconPath(lpIconPath);

    return ExtractAssociatedIconA(hInst, strIconPath, lpiIcon);
}

extern BOOL g_fUseShell32InsteadOfSHFolder;

STDAPI
SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, TCHAR * pchPath)
{
    static DYNPROC s_dynprocSHFOLDERSHGetFolderPath =
            { NULL, &g_dynlibSHFOLDER, "SHGetFolderPathW" };
    static DYNPROC s_dynprocSHELL32SHGetFolderPath =
            { NULL, &g_dynlibSHELL32, "SHGetFolderPathW" };
    void *pfnSHGetFolderPath = NULL;

    HRESULT hr = E_FAIL;

    if (g_fUseShell32InsteadOfSHFolder)
    {
        hr = LoadProcedure(&s_dynprocSHELL32SHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHELL32SHGetFolderPath.pfn;

        AssertSz(SUCCEEDED(hr), "Coudn't find ShGetFolderPathW in SHELL32.DLL");
    }
    
    // If we aren't on NT5+ or WinME+ then try shfolder32
    if (hr)
    {
        hr = LoadProcedure(&s_dynprocSHFOLDERSHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHFOLDERSHGetFolderPath.pfn;

        if (hr) 
            return hr;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HWND, int, HANDLE, DWORD, LPWSTR))pfnSHGetFolderPath)
            (hwnd, csidl, hToken, dwFlags, pchPath);
}

STDAPI
SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pchPath)
{
    static DYNPROC s_dynprocSHFOLDERSHGetFolderPath =
            { NULL, &g_dynlibSHFOLDER, "SHGetFolderPathA" };
    static DYNPROC s_dynprocSHELL32SHGetFolderPath =
            { NULL, &g_dynlibSHELL32, "SHGetFolderPathA" };
    void *pfnSHGetFolderPath = NULL;

    HRESULT hr = E_FAIL;

    if (g_fUseShell32InsteadOfSHFolder)
    {
        hr = LoadProcedure(&s_dynprocSHELL32SHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHELL32SHGetFolderPath.pfn;

        AssertSz(SUCCEEDED(hr), "Coudn't find ShGetFolderPathA in SHELL32.DLL");
    }

    if (hr)
    {
        hr = LoadProcedure(&s_dynprocSHFOLDERSHGetFolderPath);
        pfnSHGetFolderPath = s_dynprocSHFOLDERSHGetFolderPath.pfn;

        if (hr) 
            return hr;
    }


    return (*(HRESULT (STDAPICALLTYPE *)(HWND, int, HANDLE, DWORD, LPSTR))pfnSHGetFolderPath)
            (hwnd, csidl, hToken, dwFlags, pchPath);
}

#endif // DLOAD1

HRESULT
IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut)
{
    static DYNPROC s_dynprocIEParseDisplayNameWithBCW =
            { NULL, &g_dynlibSHDOCVW, (LPSTR) 218 };

    HRESULT hr = LoadProcedure(&s_dynprocIEParseDisplayNameWithBCW);

    if (S_OK == hr)
    {
        hr = (*(HRESULT (APIENTRY*)(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut))
                s_dynprocIEParseDisplayNameWithBCW.pfn)(uiCP, pwszPath, pbc, ppidlOut);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

#ifndef DLOAD1

BOOL
IsIEDefaultBrowser()
{
    BOOL bResult;

    static DYNPROC s_dynprocIsIEDefaultBrowser =
            { NULL, &g_dynlibSHDOCVW, (LPSTR) 167 };

    HRESULT hr = LoadProcedure(&s_dynprocIsIEDefaultBrowser);

    if (S_OK == hr)
    {
        bResult = (*(BOOL (APIENTRY*)())
                s_dynprocIsIEDefaultBrowser.pfn)();
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

// Note: the shell32 function is actually called SHSimpleIDListFromPath.
// I had to rename it due to a naming conflict. (scotrobe 01/24/2000)
//
LPITEMIDLIST
SHSimpleIDListFromPathPriv(LPCTSTR pszPath)
{
    static DYNPROC s_dynprocSHSimpleIDListFromPathPriv =
            { NULL, &g_dynlibSHELL32, (LPSTR) 162 };

    if (S_OK == LoadProcedure(&s_dynprocSHSimpleIDListFromPathPriv))
    {
        return (*(LPITEMIDLIST (APIENTRY*)(LPCTSTR pszPath))s_dynprocSHSimpleIDListFromPathPriv.pfn)(pszPath);
    }

    return NULL;
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\olepro32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       olepro32.cxx
//
//  Contents:   Dynamic wrappers for OLE Automation monikers.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef UNIX
DYNLIB g_dynlibOLEPRO32 = { NULL, NULL, "olepro32.dll" };
#else
DYNLIB g_dynlibOLEPRO32 = { NULL, NULL, "oleaut32.dll" };
#endif

#define WRAP_HR(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEPRO32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

#define WRAP(t, fn, a1, a2)\
STDAPI_(t) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEPRO32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return 0;\
    return (*(t (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAP_VOID(fn, a1, a2)\
STDAPI_(void) fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibOLEPRO32, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        return;\
    (*(void (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2;\
}



WRAP_HR(OleLoadPicture, 
    (LPSTREAM lpstream, LONG lSize, BOOL fRunmode, REFIID riid, LPVOID FAR* lplpvObj),
    (lpstream, lSize, fRunmode, riid, lplpvObj))

WRAP_HR(OleLoadPicturePath, 
    (LPOLESTR  szURLorPath, LPUNKNOWN punkCaller, DWORD dwReserved, OLE_COLOR clrReserved, REFIID riid, LPVOID *  ppvRet),
    (szURLorPath, punkCaller, dwReserved, clrReserved, riid, ppvRet))

WRAP_HR(OleCreateFontIndirect,
    (LPFONTDESC lpFontDesc, REFIID riid, LPVOID FAR* lplpvObj),
    (lpFontDesc, riid, lplpvObj))

WRAP_HR(OleCreatePropertyFrame,
    (HWND hwndOwner, UINT x, UINT y, LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages, LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved),
    (hwndOwner, x, y, lpszCaption, cObjects, ppUnk, cPages, pPageClsID, lcid, dwReserved, pvReserved))

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\urlmon.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       urlmon.cxx
//
//  Contents:   Dynamic wrappers for URL monikers.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef DLOAD1

DYNLIB g_dynlibURLMON = { NULL, NULL, "URLMON.DLL" };
DYNLIB g_dynlibMPR = { NULL, NULL, "MPR.DLL" };


#define WRAPIT(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibURLMON, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR_NOTRACE((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN2(hr, S_FALSE, MK_S_ASYNCHRONOUS);\
}

WRAPIT(CreateURLMoniker,
    (IMoniker * pMkCtx, LPCWSTR szURL, IMoniker **ppmk),
    (pMkCtx, szURL, ppmk))

WRAPIT(CreateURLMonikerEx,
    (IMoniker * pMkCtx, LPCWSTR szURL, IMoniker **ppmk, DWORD dwFlags),
    (pMkCtx, szURL, ppmk, dwFlags))

WRAPIT(CreateAsyncBindCtx,
    (DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC),
    (reserved, pBSCb, pEFetc, ppBC))

WRAPIT(CreateAsyncBindCtxEx,
    (IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb,
        IEnumFORMATETC *pEnum, IBindCtx **ppBC, DWORD reserved),
    (pbc, dwOptions, pBSCb, pEnum, ppBC, reserved));

WRAPIT(MkParseDisplayNameEx,
    (IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk),
    (pbc, szDisplayName, pchEaten, ppmk))

WRAPIT(RegisterBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback ** ppBSCBPrev, DWORD dwReserved),
    (pBC, pBSCb, ppBSCBPrev, dwReserved))

WRAPIT(RevokeBindStatusCallback,
        (LPBC pBC, IBindStatusCallback *pBSCb),
        (pBC, pBSCb))

WRAPIT(RegisterAsyncBindCtx,
    (LPBC pBC, IBindStatusCallback *pBSCb, DWORD reserved),
    (pBC, pBSCb, reserved))

WRAPIT(HlinkSimpleNavigateToMoniker,
    (IMoniker *pmkTarget, LPCWSTR szLocation, LPCWSTR szAddParams, IUnknown *pUnk, IBindCtx *pbc, IBindStatusCallback *pbsc, DWORD grfHLNF, DWORD dwReserved),
    (pmkTarget, szLocation, szAddParams, pUnk, pbc, pbsc, grfHLNF, dwReserved))

WRAPIT(CoGetClassObjectFromURL,
    (REFCLSID rclsid, LPCWSTR szCode, DWORD dwFileVersionMS, DWORD dwFileVersionLS, LPCWSTR szTYPE, IBindCtx *pBindCtx, DWORD dwClsContext, void *pvReserved, REFIID riid, LPVOID * ppv),
    (rclsid, szCode, dwFileVersionMS, dwFileVersionLS, szTYPE, pBindCtx, dwClsContext, pvReserved, riid, ppv))

WRAPIT(GetClassFileOrMime,
    (LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid),
    (pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, dwReserved, pclsid))

WRAPIT(RegisterMediaTypes,
    (UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes),
    (ctypes, rgszTypes, rgcfTypes));

WRAPIT(IsAsyncMoniker,
    (IMoniker * pmk),
    (pmk));

WRAPIT(FindMimeFromData,
    (LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR *ppwzMimeOut, DWORD dwReserved),
    (pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved));

WRAPIT(CoInternetParseUrl,
    (LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzUrl, ParseAction, dwFlags, pszResult, cchResult, pcchResult, dwReserved));

WRAPIT(CoInternetCombineUrl,
    (LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzBaseUrl, pwzRelativeUrl, dwFlags, pszResult, cchResult, pcchResult, dwReserved));

WRAPIT(CoInternetCreateSecurityManager,
    (IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved),
    (pSP, ppSM, dwReserved));

WRAPIT(CoInternetGetSession,
    (DWORD dwMode, IInternetSession **ppInternetSession, DWORD dwReserved),
    (dwMode, ppInternetSession, dwReserved));

WRAPIT(CoInternetCompareUrl,
    (LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwFlags),
    (pwzUrl1, pwzUrl2, dwFlags));

WRAPIT(CoInternetQueryInfo,
    (LPCWSTR pwzUrl, QUERYOPTION QueryOption, DWORD dwQueryFlags, LPVOID pvBuffer, DWORD cbBuffer, DWORD *pcbBuffer, DWORD dwReserved),
    (pwzUrl, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved));

WRAPIT(CoInternetCreateZoneManager,
    (IServiceProvider *pSP, IInternetZoneManager **ppUZM, DWORD dwReserved),
    (pSP, ppUZM, dwReserved));

WRAPIT(FaultInIEFeature,
    (HWND hWnd, uCLSSPEC *pClassSpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
    (hWnd, pClassSpec, pQuery, dwFlags));

WRAPIT(CompareSecurityIds,
    (BYTE * pbSecurityId1, DWORD dwLen1, BYTE * pbSecurityId2, DWORD dwLen2, DWORD dwReserved),
    (pbSecurityId1, dwLen1, pbSecurityId2, dwLen2, dwReserved));

WRAPIT(ObtainUserAgentString,
    (DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize),
    (dwOption, pszUAOut, cbSize));

WRAPIT(URLOpenBlockingStreamW,
    (LPUNKNOWN pCaller, LPCWSTR szUrl, LPSTREAM *ppStream, DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB),
    (pCaller, szUrl, ppStream, dwReserved, lpfnCB));

#endif // DLOAD1

STDAPI ObtainUserAgentStringW(DWORD dwOption, LPWSTR lpszUAOut, DWORD* cbSize)
{
    CStrOut strUAOut(lpszUAOut, MAX_PATH);

    return ObtainUserAgentString(dwOption, strUAOut, cbSize);
}

#ifndef DLOAD1

#define WRAPIT_VOID(fn, a1, a2)\
STDAPI_(void) fn a1\
{\
    HRESULT hr; \
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibURLMON, #fn }; \
    hr = THR(LoadProcedure(&s_dynproc##fn)); \
    if (!hr) \
    { \
        ((*(void (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2); \
    } \
}

WRAPIT_VOID(ReleaseBindInfo,
    (BINDINFO * pbindinfo),
    (pbindinfo));

#endif // DLOAD1

HRESULT FaultInIEFeatureHelper(HWND hWnd,
            uCLSSPEC *pClassSpec,
            QUERYCONTEXT *pQuery, DWORD dwFlags)
{
    HRESULT hr = FaultInIEFeature(hWnd, pClassSpec, pQuery, dwFlags);

    RRETURN1((hr == E_ACCESSDENIED) ? S_OK : hr, S_FALSE);
}

#ifndef DLOAD1

#define MPR_WRAPIT(fn, a1, a2)\
STDAPI_(DWORD) fn a1\
{\
    DWORD dw = ERROR_INVALID_PARAMETER; \
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibMPR, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    dw = ((*(DWORD (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    return dw; \
}

MPR_WRAPIT(WNetOpenEnumA,
    (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum),
    (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

MPR_WRAPIT(WNetOpenEnumW,
    (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum),
    (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

MPR_WRAPIT(WNetCloseEnum,
    (HANDLE dwEnum),
    (dwEnum));

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\unicwrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       unicwrap.cxx
//
//  Contents:   Wrappers for all Unicode functions used in the Forms^3 project.
//              Any Unicode parameters/structure fields/buffers are converted
//              to ANSI, and then the corresponding ANSI version of the function
//              is called.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#define _SHELL32_
#define _SHDOCVW_
#include <shellapi.h>
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include <commctrl.h>       // for treeview
#endif

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_ICADD_H_
#define X_ICADD_H_
typedef LONG NTSTATUS;      // from <ntdef.h> - needed by winsta.h
#include <winsta.h>
#include <icadd.h>
#endif

DeclareTag(tagUniWrap, "UniWrap", "Unicode wrappers information");
DeclareTag(tagTerminalServer, "Doc", "Use Terminal Server mode");

MtDefine(CStrInW_pwstr, Utilities, "CStrInW::_pwstr")
MtDefine(CStrIn_pstr,   Utilities, "CStrIn::_pstr")
MtDefine(CStrOut_pstr,  Utilities, "CStrOut::_pstr")
MtDefine(IsTerminalServer_szProductSuite, Utilities, "IsTerminalServer_szProductSuite");

DWORD   g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
DWORD   g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
DWORD   g_dwPlatformBuild;              // Build number
DWORD   g_dwPlatformServicePack;        // Service Pack
UINT    g_uLatinCodepage;
BOOL    g_fUnicodePlatform;
BOOL    g_fTerminalServer;              // TRUE if running under NT Terminal Server, FALSE otherwise
BOOL    g_fTermSrvClientSideBitmaps;    // TRUE if TS supports client-side bitmaps
BOOL    g_fNLS95Support;
BOOL    g_fGotLatinCodepage = FALSE;
BOOL    g_fFarEastWin9X;
BOOL    g_fFarEastWinNT;
BOOL    g_fExtTextOutWBuggy;
BOOL    g_fExtTextOutGlyphCrash;
BOOL    g_fBidiSupport; // COMPLEXSCRIPT
BOOL    g_fComplexScriptInput;
BOOL    g_fMirroredBidiLayout;
BOOL    g_fThemedPlatform;
BOOL    g_fWhistlerOS;
BOOL    g_fUseShell32InsteadOfSHFolder;

DeclareTagOther(tagHackGDICoords,"DocHackGDICoords","simulate Win95 GDI coordinate limitation")
DeclareTag(tagCheck16bitLimitations, "Display", "Assert if GDI coordinates are out of 16-bit space");


//+------------------------------------------------------------------------
//
//  Define prototypes of wrapped functions.
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1 /* { */

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType _stdcall FnName##Wrap FnParamList ;

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)      \
        void _stdcall FnName##Wrap FnParamList ;

#if DBG==1 /* { */

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        FnType _stdcall FnName##Wrap FnParamList ;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs) \
        void _stdcall FnName##Wrap FnParamList ;

#else

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs)
#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)

#endif /* } */

#define NOOVERRIDE
        
#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_VOID_NOCONVERT


//+------------------------------------------------------------------------
//
//  Unicode function globals initialized to point to wrapped functions.
//
//-------------------------------------------------------------------------

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)      \
        void   (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#if DBG==1 /* { */

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        FnType (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
        void   (_stdcall *g_pufn##FnName) FnParamList = &FnName##Wrap;

#else

#define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
        FnType (_stdcall *g_pufn##FnName) FnParamList;

#define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
        void   (_stdcall *g_pufn##FnName) FnParamList;

#endif /* } */

#include "wrapfns.h"

#undef STRUCT_ENTRY
#undef STRUCT_ENTRY_VOID
#undef STRUCT_ENTRY_NOCONVERT
#undef STRUCT_ENTRY_VOID_NOCONVERT

#endif /* } */

//+---------------------------------------------------------------------------
//
//  Function:       IsFarEastLCID(lcid)
//
//  Returns:        True iff lcid is a East Asia locale.
//
//----------------------------------------------------------------------------

BOOL
IsFarEastLCID(LCID lcid)
{
    switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
        case LANG_CHINESE:
        case LANG_JAPANESE:
        case LANG_KOREAN:
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//  COMPLEXSCRIPT
//  Function:       IsBidiLCID(lcid)
//
//  Returns:        True iff lcid is a right to left locale.
//
//----------------------------------------------------------------------------
#define lcidKashmiri 0x0860
#define lcidUrduIndia     0x0820

BOOL 
IsBidiLCID(LCID lcid)
{
    switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
        case LANG_ARABIC:
        case LANG_FARSI:
        case LANG_HEBREW:
        case LANG_KASHMIRI:
            if (lcid == lcidKashmiri)
                return FALSE;
        case LANG_PASHTO:
        case LANG_SINDHI:
        case LANG_SYRIAC:
        case LANG_URDU:
            if (lcid == lcidUrduIndia)
                return FALSE;
        case LANG_YIDDISH:
            return TRUE;
            break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//  COMPLEXSCRIPT
//  Function:       IsComplexLCID(lcid)
//
//  Returns:        True iff lcid is a complex script locale.
//
//----------------------------------------------------------------------------

BOOL 
IsComplexLCID(LCID lcid)
{
    switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
    {
        case LANG_ARABIC:
        case LANG_ASSAMESE:
        case LANG_BENGALI:
        case LANG_BURMESE:
        case LANG_FARSI:
        case LANG_GUJARATI:
        case LANG_HEBREW:
        case LANG_HINDI:
        case LANG_KANNADA:
        case LANG_KASHMIRI:
        case LANG_KHMER:
        case LANG_KONKANI:
        case LANG_LAO:
        case LANG_MALAYALAM:
        case LANG_MANIPURI:
        case LANG_MARATHI:
        case LANG_MONGOLIAN:
        case LANG_NAPALI:
        case LANG_ORIYA:
        case LANG_PASHTO:
        case LANG_PUNJABI:
        case LANG_SANSKRIT:
        case LANG_SINDHI:
        case LANG_SINHALESE:
        case LANG_SYRIAC:
        case LANG_TAMIL:
        case LANG_TELUGU:
        case LANG_THAI:
        case LANG_TIBETAN:
        case LANG_URDU:
        case LANG_VIETNAMESE:
        case LANG_YIDDISH:
           return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DebugSetTerminalServer
//
//  Synopsis:   Sets terminal server mode
//
//----------------------------------------------------------------------------

#if DBG==1
void
DebugSetTerminalServer()
{
    static int s_Real_fTerminalServer = -2;

    if (s_Real_fTerminalServer == -2)
    {
        s_Real_fTerminalServer = IsTerminalServer();
    }

    g_fTerminalServer = IsTagEnabled(tagTerminalServer) ? TRUE
                                                        : s_Real_fTerminalServer;
}
#endif

/************************************ B E G I N   O F   S H E L L   C O D E
* (dmitryt)
* This code is borrowed from shell (file shell\lib\stockthk\rtlmir.cpp)
* to employ the same functionality in deciding whether we should apply WS_EX_LAYOUTRTL
* bit or not. This logic is used in 2 places - when we create HTA window and when we 
* create a HTML dialog.
* We use this code to set a single flag, g_fMirroredBidiLayout.
* 
***************************************************************************/

typedef LANGID (WINAPI *PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage
typedef BOOL (WINAPI *PFNENUMUILANGUAGES)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR); // kernel32!EnumUILanguages

typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

#ifdef UNICODE
#define ConvertHexStringToInt ConvertHexStringToIntW
#else
#define ConvertHexStringToInt ConvertHexStringToIntA
#endif

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
BOOL IEisOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOEXA s_osvi = {0};
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;
        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if (!GetVersionExA((OSVERSIONINFOA*)&s_osvi))
        {
            // If it failed, it must be a down level platform
            s_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA((OSVERSIONINFOA*)&s_osvi);
        }
    }

    switch (dwOS)
    {
/*
    case OS_TERMINALCLIENT:
        // WARNING: this will only return TRUE for REMOTE TS sessions (eg you are comming in via tsclient).
        // If you want to see if TS is enabled or if the user is on the TS console, the use one of the other flags.
        bRet = GetSystemMetrics(SM_REMOTESESSION);
        break;

    case OS_WIN2000TERMINAL:
        // WARNING: this flag is VERY ambiguous... you probably want to use one of 
        // OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or  OS_PERSONALTERMINALSERVER instead.
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use one of OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER instead !");
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                s_osvi.dwMajorVersion >= 5);
        break;

    case OS_TERMINALSERVER:
        // NOTE: be careful about using OS_TERMINALSERVER. It will only return true for nt server boxes
        // configured in what used to be called "Applications Server" mode in the win2k days. It is now simply called
        // "Terminal Server" (hence the name of this flag).
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
#ifdef DEBUG
        if (bRet)
        {
            // all "Terminal Server" machines have to be server (cannot be per/pro)
            ASSERT(VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType);
        }
#endif
        break;

    case OS_TERMINALREMOTEADMIN:
        // this checks to see if TS has been installed in the "Remote Administration" mode. This is
        // the default for server installs on win2k and whistler
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                (VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
        break;

    case OS_PERSONALTERMINALSERVER:
        bRet = ((VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask) &&
                !(VER_SUITE_TERMINAL & s_osvi.wSuiteMask));
        break;

    case OS_FASTUSERSWITCHING:
        bRet = (((VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS) & s_osvi.wSuiteMask) &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "AllowMultipleTSSessions"));
        break;

    case OS_FRIENDLYLOGONUI:
        bRet = (!IsMachineDomainMember() &&
                !IsWinlogonRegValuePresent(HKEY_LOCAL_MACHINE,
                                           "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                           "GinaDLL") &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "LogonType"));
        break;

    case OS_DOMAINMEMBER:
        bRet = IsMachineDomainMember();
        ASSERT(VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId); // has to be a NT machine to be on a domain!
        break;

    case 4: // used to be OS_NT5, is the same as OS_WIN2000ORGREATER so use that instead
*/
    case OS_WIN2000ORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;
/*
    // NOTE: The flags in this section are bogus and SHOULD NOT BE USED 
    //       (but the ie4 shell32 uses them, so don't RIP on downlevel platforms)
    case OS_WIN2000PRO:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_PROFESSIONAL instead of OS_WIN2000PRO !");
        bRet = (VER_NT_WORKSTATION == s_osvi.wProductType &&
                s_osvi.dwMajorVersion == 5);
        break;
    case OS_WIN2000ADVSERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_ADVSERVER instead of OS_WIN2000ADVSERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000DATACENTER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_DATACENTER instead of OS_WIN2000DATACENTER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000SERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_SERVER instead of OS_WIN2000SERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask)  && 
                s_osvi.dwMajorVersion == 5);
        break;
    // END bogus Flags

    case OS_EMBEDDED:
        bRet = (VER_SUITE_EMBEDDEDNT & s_osvi.wSuiteMask);
        break;

    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WIN95GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 0 &&
                LOWORD(s_osvi.dwBuildNumber) == 950);
        break;
*/
    case OS_WIN98ORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;
/*
    case OS_WIN98_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;

    case OS_MILLENNIUMORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 90) ||
                s_osvi.dwMajorVersion > 4));
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WHISTLERORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion > 5) ||
                (s_osvi.dwMajorVersion == 5 && (s_osvi.dwMinorVersion > 0 ||
                (s_osvi.dwMinorVersion == 0 && LOWORD(s_osvi.dwBuildNumber) > 2195)))));
        break;

    case OS_PERSONAL:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (VER_SUITE_PERSONAL & s_osvi.wSuiteMask));
        break;

    case OS_PROFESSIONAL:
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) && 
                (VER_NT_WORKSTATION == s_osvi.wProductType));
        break;

    case OS_DATACENTER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_ADVSERVER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_SERVER:
        // NOTE: be careful! this specifically means Server -- will return false for Avanced Server and Datacenter machines
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask));
        break;

    case OS_ANYSERVER:
        // this is for people who want to know if this is ANY type of NT server machine (eg dtc, ads, or srv)
        bRet = ((VER_NT_SERVER == s_osvi.wProductType) || (VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType));
        break;
*/
    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}   


/***************************************************************************\
* ConvertHexStringToIntA
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToIntA( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}



/***************************************************************************\
* Mirror_GetUserDefaultUILanguage
*
* Reads the User UI language on NT5
*
* History:
* 22-June-1998 samera    Created
\***************************************************************************/
LANGID Mirror_GetUserDefaultUILanguage( void )
{
    LANGID langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnGetUserDefaultUILanguage = (PFNGETUSERDEFAULTUILANGUAGE)
                                          GetProcAddress(hmod, "GetUserDefaultUILanguage");
    }

    if( pfnGetUserDefaultUILanguage )
        langId = pfnGetUserDefaultUILanguage();

    return langId;
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR 
lParam)
{
    int langID = 0;

    ConvertHexStringToInt(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{

    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    static PFNENUMUILANGUAGES pfnEnumUILanguages=NULL;

    if( NULL == pfnEnumUILanguages )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnEnumUILanguages = (PFNENUMUILANGUAGES)
                                          GetProcAddress(hmod, "EnumUILanguagesW");
    }

    if( pfnEnumUILanguages )
        pfnEnumUILanguages(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}


/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    HKEY          hKey;
    DWORD         dwType;
    CHAR          szResourceLocale[12];
    DWORD         dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    if(IEisOS(OS_WIN2000ORGREATER))
    {
        /*
         * Need to use NT5 detection method (Multiligual UI ID)
         */
        langID = Mirror_GetUserDefaultUILanguage();

        if( langID )
        {
            WCHAR wchLCIDFontSignature[16];
            iLCID = MAKELCID( langID , SORT_DEFAULT );

            /*
             * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
             * convert to decimal value and call GetLocaleInfo afterwards.
             * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
             */

            if( GetLocaleInfoW( iLCID , 
                                LOCALE_FONTSIGNATURE , 
                                (WCHAR *) &wchLCIDFontSignature[0] ,
                                (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
            {
      
                /* Let's verify the bits we have a BiDi UI locale */
                if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
                {
                    bRet = TRUE;
                }
            }
        }
    } else {

        /*
         * Check if BiDi-Memphis is running with Lozalized Resources (
         * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
         */
        if(IEisOS(OS_WIN98ORGREATER) && GetSystemMetrics(SM_MIDEASTENABLED))
        {

            if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                               "Control Panel\\Desktop\\ResourceLocale" , 
                               0, 
                               KEY_READ, &hKey) == ERROR_SUCCESS) 
            {
                RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
                szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                RegCloseKey(hKey);

                if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                {
                    iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                    if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                    {
                        bRet = TRUE;
                        langID = LANGIDFROMLCID(iLCID);
                    }
                }
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}

//************************************ E N D   O F   S H E L L   C O D E


//+---------------------------------------------------------------------------
//
//  Function:   InitUnicodeWrappers
//
//  Synopsis:   Determines the platform we are running on and
//              initializes pointers to unicode functions.
//
//----------------------------------------------------------------------------

void
InitUnicodeWrappers()
{
#ifndef WINCE
    OSVERSIONINFOA ovi;
#else //WINCE
    OSVERSIONINFO ovi;
#endif //WINCE
    const UINT acp = GetACP();
#ifndef UNIX
    const BOOL fFarEastLCID = IsFarEastLCID(GetSystemDefaultLCID());
#else
    const BOOL fFarEastLCID = FALSE;  // UNIXTODO
#endif

#ifndef WINCE
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    Verify(GetVersionExA(&ovi));
#else //WINCE
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    Verify(GetVersionEx(&ovi));
#endif //WINCE

    g_dwPlatformVersion     = (ovi.dwMajorVersion << 16) + ovi.dwMinorVersion;
    g_dwPlatformID          = ovi.dwPlatformId;
    g_dwPlatformBuild       = ovi.dwBuildNumber;
    g_fThemedPlatform       = (g_dwPlatformID  == VER_PLATFORM_WIN32_NT &&  g_dwPlatformVersion > 0x00050000) ? 
                              TRUE :
                              FALSE;

    // We realize that this is the same code with the line above, 
    // just worried that theming becomes available for downlevel OS'. 
    g_fWhistlerOS           = (g_dwPlatformID  == VER_PLATFORM_WIN32_NT &&  g_dwPlatformVersion > 0x00050000) ? 
                              TRUE :
                              FALSE;

    // NOTE:    On Millennium or W2k we should use Shell32 for SHGetFolderPath
    //          instead of SHFolder.
    g_fUseShell32InsteadOfSHFolder = (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID 
                                        && (g_dwPlatformVersion >= 0x0004005a))
                                     || (VER_PLATFORM_WIN32_NT == g_dwPlatformID 
                                        && g_dwPlatformVersion >= 0x00050000);

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        char * pszBeg = ovi.szCSDVersion;

        if (*pszBeg)
        {
            char * pszEnd = pszBeg + lstrlenA(pszBeg);
            
            while (pszEnd > pszBeg)
            {
                char c = pszEnd[-1];

                if (c < '0' || c > '9')
                    break;

                pszEnd -= 1;
            }

            while (*pszEnd)
            {
                g_dwPlatformServicePack *= 10;
                g_dwPlatformServicePack += *pszEnd - '0';
                pszEnd += 1;
            }
        }
    }

#ifndef WINCE
    g_fUnicodePlatform      = (g_dwPlatformID == VER_PLATFORM_WIN32_NT ||
                               g_dwPlatformID == VER_PLATFORM_WIN32_UNIX);

    g_fNLS95Support         = (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS ||
                              (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
                                 ovi.dwMajorVersion >= 3)) ? TRUE : FALSE;

    g_fFarEastWin9X         = fFarEastLCID &&
                              g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS;

    g_fFarEastWinNT         = fFarEastLCID &&
                              g_dwPlatformID == VER_PLATFORM_WIN32_NT;

    // NB (cthrash) ExtTextOutW and related functions are buggy under the
    // following OSes: Win95 PRC All, Win95 TC Golden
    
    g_fExtTextOutWBuggy     = g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS &&
                              ((   acp == 950 // CP_TWN
                                && g_dwPlatformVersion == 0x00040000) ||
                               (   acp == 936 // CP_CHN_GB
                                && g_dwPlatformVersion < 0x0004000a ));

    // NB (mikejoch) ExtTextOut(... , ETO_GLYPH_INDEX, ...) crashes under all
    // FE Win95 OSes -- JPN, KOR, CHT, & CHS. Fixed for Win98.
    g_fExtTextOutGlyphCrash = fFarEastLCID &&
                              g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS &&
                              g_dwPlatformVersion < 0x0004000a;
/*
    g_fMirroredBidiLayout  = ((g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS &&
                                g_dwPlatformVersion >= 0x0004000a) ||
                               (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
                                g_dwPlatformVersion >= 0x00050000));
*/

    g_fMirroredBidiLayout  = IsBiDiLocalizedSystem();


#ifndef UNIX
    HKL aHKL[32];
    UINT uKeyboards = GetKeyboardLayoutList(32, aHKL);
    // check all keyboard layouts for existance of a RTL language.
    // bounce out when the first one is encountered.
    for(UINT i = 0; i < uKeyboards; i++)
    {
        if(IsBidiLCID(LOWORD(aHKL[i])))
        {
            g_fBidiSupport = TRUE;
            g_fComplexScriptInput = TRUE;
            break;
        }

        if(IsComplexLCID(LOWORD(aHKL[i])))
        {
            g_fComplexScriptInput = TRUE;
        }
        
    }
#else //UNIX
    g_fBidiSupport = FALSE;
    g_fComplexScriptInput = FALSE;
#endif
#else //WINCE
    g_fUnicodePlatform      = TRUE;

    g_fNLS95Support         = TRUE;

    g_fFarEastWin9X         = FALSE;

    g_fFarEastWinNT         = fFarEastLCID;

    g_fExtTextOutWBuggy     = FALSE;

    g_fExtTextOutGlyphCrash = FALSE;

    g_fBidiSupport          = FALSE;

    g_fComplexScriptInput   = FALSE;

    g_fMirroredBidiLayout = FALSE;

#endif //WINCE



#if USE_UNICODE_WRAPPERS==1     /* { */

    //
    // If the platform is unicode, then overwrite function table to point
    // to the unicode functions.
    //

    if (g_fUnicodePlatform)
    {
        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
                g_pufn##FnName = &FnName##W;

        #define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)      \
                g_pufn##FnName = &FnName##W;

        #define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
                g_pufn##FnName = &FnName##W;

        #define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
                g_pufn##FnName = &FnName##W;

        #include "wrapfns.h"

        #undef STRUCT_ENTRY
        #undef STRUCT_ENTRY_VOID
        #undef STRUCT_ENTRY_NOCONVERT
        #undef STRUCT_ENTRY_VOID_NOCONVERT
    }
    else
    {
        //
        // If we are not doing conversions of trivial wrapper functions, initialize pointers
        // to point to operating system functions.
        //

        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)
        #define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs) \
                g_pufn##FnName = (FnType (_stdcall *)FnParamList) &FnName##A;

        #define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)    \
                g_pufn##FnName = (void (_stdcall *)FnParamList) &FnName##A;

        #include "wrapfns.h"

        #undef STRUCT_ENTRY
        #undef STRUCT_ENTRY_VOID
        #undef STRUCT_ENTRY_NOCONVERT
        #undef STRUCT_ENTRY_VOID_NOCONVERT

    }
#else
    {
        // RISC workaround for CP wrappers.

        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY2(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs)
        #define STRUCT_ENTRY_NOCONVERT(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_NOCONVERT2(FnName, FnType, FnParamList, FnArgs)
        #define STRUCT_ENTRY_VOID_NOCONVERT(FnName, FnParamList, FnArgs)

        #include "wrapfns.h"

        #undef STRUCT_ENTRY
        #undef STRUCT_ENTRY_VOID
        #undef STRUCT_ENTRY_NOCONVERT
        #undef STRUCT_ENTRY_VOID_NOCONVERT
    }    
#endif /* } */

    g_fTerminalServer = IsTerminalServer();

    if (g_fTerminalServer)
    {
        // see whether TS supports client-side bitmaps, by asking about a 1x1
        // bitmap.  If that doesn't work, we won't bother trying anything
        // larger.
        ICA_DEVICE_BITMAP_INFO info;
        HDC hdc = ::GetDC(NULL);
        INT rc, bSucc;

        info.cx = info.cy = 1;

        bSucc = ExtEscape(
                    hdc,
                    ESC_GET_DEVICEBITMAP_SUPPORT,
                    sizeof(info),
                    (LPSTR)&info,
                    sizeof(rc),
                    (LPSTR)&rc
                    );

        g_fTermSrvClientSideBitmaps = !!bSucc;
    }

#if DBG == 1
    DebugSetTerminalServer();
#endif
}

//+------------------------------------------------------------------------
//
//  Wrapper function utilities.
//  NOTE: normally these would also be surrounded by an #ifndef NO_UNICODE_WRAPPERS
//        but the string conversion functions are needed for dealing with
//        wininet.
//
//-------------------------------------------------------------------------

int MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch = -1);
int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1);


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0)
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   ConvertibleCodePage, static
//
//  Synopsis:   Returns a codepage appropriate for WideCharToMultiByte.
//
//  Comment:    WideCharToMultiByte obviously cannot convert cp1200 (Unicode)
//              to multibyte.  Hence we bail out and use CP_ACP.
//
//              cp50000 is x-user-defined.  This by definition is to use
//              CP_ACP.
//
//----------------------------------------------------------------------------

UINT
ConvertibleCodePage(UINT uCP)
{
    return (uCP == 1200 || uCP == 50000) ? CP_ACP : uCP;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    Assert(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //
    // Since the passed in buffer may not be null terminated, we have
    // a problem if cch==ARRAYSIZE(_awch), because MultiByteToWideChar
    // will succeed, and we won't be able to null terminate the string!
    // Decrease our buffer by one for this case.
    //
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAY_SIZE(_awch)-1);

    if (_cwchLen > 0)
    {
        // Some callers don't NULL terminate.
        //
        // We could check "if (-1 != cch)" before doing this,
        // but always doing the null is less code.
        //
        _awch[_cwchLen] = 0;

        if(_awch[_cwchLen-1] == 0)
            _cwchLen--;                // account for terminator

        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    // Again, leave room for null termination
    cchBufReq++;

    Assert(cchBufReq > 0);
    _pwstr = new(Mt(CStrInW_pwstr)) WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD64(_pwstr));
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );

    // Again, make sure we're always null terminated
    Assert(_cwchLen < cchBufReq);
    _pwstr[_cwchLen] = 0;

    if (0 == _pwstr[_cwchLen-1]) // account for terminator
        _cwchLen--;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}


CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(ConvertibleCodePage(uCP))
{
    Init(pwstr, -1);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0)
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    Assert(cwch == -1 || cwch > 0);
    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAY_SIZE(_ach)-1, NULL, NULL);

    if (_cchLen > 0)
    {
        // This is DBCS safe since byte before _cchLen is last character
        _ach[_cchLen] = 0;
        // TODO DBCS REVIEW: this may not be safe if the last character
        // was a multibyte character...
        if (_ach[_cchLen-1]==0)
            _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //
    cchBufReq = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    Assert(cchBufReq > 0);

    cchBufReq++; // may need to append NUL

    TraceTag((tagUniWrap, "CStrIn: Allocating buffer for argument (_uCP=%ld,cwch=%ld,pwstr=%lX,cchBufReq=%ld)",
             _uCP, cwch, pwstr, cchBufReq));

    _pstr = new(Mt(CStrIn_pstr)) char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        TraceTag((tagUniWrap, "CStrIn: No heap space for wrapped function argument."));
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD64(_pstr));
    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);

#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        TraceTag((tagError, "WideCharToMultiByte failed with errcode %ld", errcode));
        Assert(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

        // Again, make sure we're always null terminated
    Assert(_cchLen < cchBufReq);
    _pstr[_cchLen] = 0;
    if (0 == _pstr[_cchLen-1]) // account for terminator
        _cchLen--;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    Assert(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, pwstrT - pwstr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    Assert(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        _cwchBuf = 0;
        _pstr = NULL;
        return;
    }

    Assert(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAY_SIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    TraceTag((tagUniWrap, "CStrOut: Allocating buffer for wrapped function argument."));
    _pstr = new(Mt(CStrOut_pstr)) char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TraceTag((tagUniWrap, "CStrOut: No heap space for wrapped function argument."));
        Assert(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertIncludingNul()
{
    int cch;

    if (!_pstr)
        return 0;

    cch = MultiByteToWideChar(_uCP, 0, _pstr, -1, _pwstr, _cwchBuf);

#if DBG == 1 /* { */
    if (cch <= 0 && _cwchBuf > 0)
    {
        int errcode = GetLastError();
        AssertSz(errcode != S_OK, "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Function:   MbcsFromUnicode
//
//  Synopsis:   Converts a string to MBCS from Unicode.
//
//  Arguments:  [pstr]  -- The buffer for the MBCS string.
//              [cch]   -- The size of the MBCS buffer, including space for
//                              NULL terminator.
//
//              [pwstr] -- The Unicode string to convert.
//              [cwch]  -- The number of characters in the Unicode string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pstr].
//
//----------------------------------------------------------------------------

int
MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    Assert(cch >= 0);
    if (!pstr || cch == 0)
        return 0;

    Assert(pwstr);
    Assert(cwch == -1 || cwch > 0);

    ret = WideCharToMultiByte(CP_ACP, 0, pwstr, cwch, pstr, cch, NULL, NULL);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
        Assert(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnicodeFromMbcs
//
//  Synopsis:   Converts a string to Unicode from MBCS.
//
//  Arguments:  [pwstr] -- The buffer for the Unicode string.
//              [cwch]  -- The size of the Unicode buffer, including space for
//                              NULL terminator.
//
//              [pstr]  -- The MBCS string to convert.
//              [cch]  -- The number of characters in the MBCS string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pwstr].
//
//----------------------------------------------------------------------------

int
UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    Assert(cwch >= 0);

    if (!pwstr || cwch == 0)
        return 0;

    Assert(pstr);
    Assert(cch == -1 || cch > 0);

    ret = MultiByteToWideChar(CP_ACP, 0, pstr, cch, pwstr, cwch);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
        Assert(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    return ret;
}



//+------------------------------------------------------------------------
//
//  Implementation of the wrapped functions
//
//-------------------------------------------------------------------------

#if USE_UNICODE_WRAPPERS==1 /* { */

#if DBG==1 /* { */
BOOL WINAPI
ChooseColorWrap(LPCHOOSECOLORW lpcc)
{
    Assert(!lpcc->lpTemplateName);
    return ChooseColorA((LPCHOOSECOLORA) lpcc);
}
#endif /* } */


BOOL WINAPI
ChooseFontWrap(LPCHOOSEFONTW lpcfw)
{
    BOOL            ret;
    CHOOSEFONTA     cfa;
    LOGFONTA        lfa;
    LPLOGFONTW      lplfw;

    Assert(!lpcfw->lpTemplateName);
    Assert(!lpcfw->lpszStyle);

    Assert(sizeof(CHOOSEFONTA) == sizeof(CHOOSEFONTW));
    memcpy(&cfa, lpcfw, sizeof(CHOOSEFONTA));

    memcpy(&lfa, lpcfw->lpLogFont, offsetof(LOGFONTA, lfFaceName));
    MbcsFromUnicode(lfa.lfFaceName, ARRAY_SIZE(lfa.lfFaceName), lpcfw->lpLogFont->lfFaceName);

    cfa.lpLogFont = &lfa;

    ret = ChooseFontA(&cfa);

    if (ret)
    {
        lplfw = lpcfw->lpLogFont;
        memcpy(lpcfw, &cfa, sizeof(CHOOSEFONTW));
        lpcfw->lpLogFont = lplfw;

        memcpy(lpcfw->lpLogFont, &lfa, offsetof(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(lpcfw->lpLogFont->lfFaceName, ARRAY_SIZE(lpcfw->lpLogFont->lfFaceName), (LPCSTR)(lfa.lfFaceName));
    }
    return ret;
}

#if DBG == 1 /* { */
HINSTANCE WINAPI
LoadLibraryWrap(LPCWSTR lpLibFileName)
{
    Assert(0 && "LoadLibrary called - use LoadLibraryEx instead");
    return 0;
}
#endif /* } */
#endif /* } */

// Everything after this is present on all platforms (Unicode or not)

//+---------------------------------------------------------------------------
//      GetLatinCodepage
//----------------------------------------------------------------------------

UINT
GetLatinCodepage()
{
    if (!g_fGotLatinCodepage)
    {
        // When converting Latin-1 characters, we will use g_uLatinCodepage.
        // The first choice is to use Windows-1252 (Windows Latin-1).  That
        // should be present in all systems, unless deliberately removed.  If
        // that fails, we go for our second choice, which is MS-DOS Latin-1.
        // If that fails, we'll just go with CP_ACP. (cthrash)

        if ( !IsValidCodePage( g_uLatinCodepage = 1252 ) &&
             !IsValidCodePage( g_uLatinCodepage = 850 ) )
        {
                g_uLatinCodepage = CP_ACP;
        }

        g_fGotLatinCodepage = TRUE;
    }

    return(g_uLatinCodepage);
}


// NOTE: these definitions come from shlwapip.h.  The right way to use them
// is to #include <shlwapi.h> with _WIN32_IE set to 0x501 or better, which
// is done by changing WIN32_IE_VERSION in common.inc.  However, doing this
// causes conflicts between shlwapip.h and shellapi.h.  So until the shell
// folks get their story straight, I'm just reproducing the definitions I
// need here. (SamBent)

#if !defined(GMI_TSCLIENT)
//
//  GMI_TSCLIENT tells you whether you are running as a Terminal Server
//  client and should disable your animations.
//
#define GMI_TSCLIENT            0x0003  // Returns nonzero if TS client

STDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi);

#endif // !defined(GMI_TSCLIENT)


BOOL IsTerminalServer()
{
    return !!SHGetMachineInfo(GMI_TSCLIENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\winmm.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       winmm.cxx
//
//  Contents:   Dynamic wrappers for multi media
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MMSYSTEM_H_
#define X_MMSYSTEM_H_
#define _WINMM_
#include <mmsystem.h>
#endif

DYNLIB g_dynlibWINMM = { NULL, NULL, "WINMM.DLL" };

BOOL WINAPI
PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
{
    static DYNPROC s_dynprocPlaySoundA =
            { NULL, &g_dynlibWINMM, "PlaySoundA" };

    if (THR(LoadProcedure(&s_dynprocPlaySoundA)))
        return FALSE;

    return (*(BOOL (APIENTRY *)(LPCSTR, HMODULE, DWORD))s_dynprocPlaySoundA.pfn)
            (pszSound, hmod, fdwSound);

}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\theme.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995-2000
//
//  File:       theme.cxx
//
//  Contents:   Dynamic wrappers for Theme procedures.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#ifndef X_CDERR_H_
#define X_CDERR_H_
#include <cderr.h>
#endif

#ifndef X_UXTHEME_H_
#define X_UXTHEME_H_
#undef  _UXTHEME_
#define _UXTHEME_
#include "uxtheme.h"
#endif

#ifndef X_WINUSER32_H_
#define X_WINUSER32_H_
#undef  _WINUSER32_
#define _WINUSER32_
#include "winuser.h"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

DYNLIB g_dynlibTheme    = { NULL, NULL, "UXTHEME.dll" };
DYNLIB g_dynlibKERNEL32 = { NULL, NULL, "KERNEL32.dll" };

extern DYNLIB g_dynlibUSER32;
extern BOOL   g_fThemedPlatform;
extern DWORD  g_dwPlatformBuild;

THEMEAPI_(HTHEME)
OpenThemeData(HWND hwnd, LPCWSTR pstrClassList)
{
    static DYNPROC s_dynprocOpenThemeData =
            { NULL, &g_dynlibTheme, "OpenThemeData" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocOpenThemeData);
    
    if (hr)
    {
        return NULL;
    }

    return (*(HTHEME (STDAPICALLTYPE *)(HWND, LPCWSTR))
            s_dynprocOpenThemeData.pfn)
            (hwnd, pstrClassList);
}

THEMEAPI_(HTHEME)
OpenThemeDataEx(HWND hwnd, LPCWSTR pstrClassList, DWORD dwFlags)
{
    static DYNPROC s_dynprocOpenThemeDataEx =
            { NULL, &g_dynlibTheme, (LPSTR) 61 };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocOpenThemeDataEx);
    
    if (hr)
    {
        // FOR IE INSTALLED ON DOWNLEVEL WHISTLER
        // OpenThemeDataEx will not be available
        // so we can default to OpenThemeData
        // This can be changed to return NULL
        // before we ship.
        return OpenThemeData(hwnd, pstrClassList);
    }

    return (*(HTHEME (STDAPICALLTYPE *)(HWND, LPCWSTR, DWORD))
            s_dynprocOpenThemeDataEx.pfn)
            (hwnd, pstrClassList, dwFlags);
}

THEMEAPI
SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, LPCWSTR pszSubIdList)
{
    static DYNPROC s_dynprocSetWindowTheme =
            { NULL, &g_dynlibTheme, "SetWindowTheme" };
    
    HRESULT hr;

    hr = LoadProcedure(&s_dynprocSetWindowTheme);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HWND, LPCWSTR, LPCWSTR))
            s_dynprocSetWindowTheme.pfn)
            (hwnd, pszSubAppName, pszSubIdList);
}

THEMEAPI
DrawThemeBorder(
    HTHEME hTheme, 
    HDC hdc, 
    int iStateId, 
    const RECT *pRect
)
{
    static DYNPROC s_dynprocDrawThemeBorder =
            { NULL, &g_dynlibTheme, "DrawThemeBorder" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDrawThemeBorder);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, const RECT *))
            s_dynprocDrawThemeBorder.pfn)
            (hTheme, hdc, iStateId, pRect);
}

THEMEAPI
DrawThemeBackground(   HTHEME hTheme,
                       HDC hdc,
                       int iPartId,
                       int iStateId,
                       const RECT *pRect,
                       const RECT *pClipRect)
{
    static DYNPROC s_dynprocDrawThemeBackground =
            { NULL, &g_dynlibTheme, "DrawThemeBackground" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocDrawThemeBackground);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, const RECT *, const RECT *))
            s_dynprocDrawThemeBackground.pfn)
            (hTheme, hdc, iPartId, iStateId, pRect, pClipRect);
}

THEMEAPI
GetThemeTextMetrics(   HTHEME hTheme,
                       HDC hdc,
                       int iPartId,
                       int iStateId,
                       TEXTMETRIC *ptm)
{
    static DYNPROC s_dynprocGetThemeTextMetrics =
            { NULL, &g_dynlibTheme, "GetThemeTextMetrics" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeTextMetrics);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, TEXTMETRIC *))
            s_dynprocGetThemeTextMetrics.pfn)
            (hTheme, hdc, iPartId, iStateId, ptm);
}

THEMEAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme, 
    HDC    hdc /*optional*/,
    int iPartId, 
    int iStateId, 
    const RECT *pBoundingRect /*optional*/, 
    RECT *pContentRect
)
{
    static DYNPROC s_dynprocGetThemeBackgroundContentRect =
            { NULL, &g_dynlibTheme, "GetThemeBackgroundContentRect" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeBackgroundContentRect);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int,  const RECT*, RECT *))
            s_dynprocGetThemeBackgroundContentRect.pfn)
            (hTheme, hdc, iPartId, iStateId, pBoundingRect, pContentRect);
}

THEMEAPI
GetThemeBackgroundExtent(
    HTHEME hTheme, 
    HDC    hdc /*optional*/,
    int iPartId, 
    int iStateId, 
    const RECT *pContentRect, 
    RECT *pExtentRect
)
{
    static DYNPROC s_dynprocGetThemeBackgroundExtent =
            { NULL, &g_dynlibTheme, "GetThemeBackgroundExtent" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeBackgroundExtent);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int,  const RECT*, RECT *))
            s_dynprocGetThemeBackgroundExtent.pfn)
            (hTheme, hdc, iPartId, iStateId, pContentRect, pExtentRect);
}

THEMEAPI 
GetThemeColor(
    HTHEME hTheme, 
    int iPartId, 
    int iStateId, 
    int iPropId, 
    COLORREF *pColor
)
{
    static DYNPROC s_dynprocGetThemeColor =
            { NULL, &g_dynlibTheme, "GetThemeColor" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeColor);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, int, int,  int, COLORREF *))
            s_dynprocGetThemeColor.pfn)
            (hTheme, iPartId, iStateId, iPropId, pColor);
}

THEMEAPI
GetThemeFont(   HTHEME hTheme,
                       HDC hdc,
                       int iPartId,
                       int iStateId,
                       int iPropId,
                       LOGFONT *pFont)
{
    static DYNPROC s_dynprocGetThemeFont =
            { NULL, &g_dynlibTheme, "GetThemeFont" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeFont);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int,  int, LOGFONT *))
            s_dynprocGetThemeFont.pfn)
            (hTheme, hdc, iPartId, iStateId, iPropId, pFont);
}


THEMEAPI
GetThemeTextExtent(
    HTHEME hTheme, 
    HDC hdc, 
    int iPartId, 
    int iStateId, 
    LPCWSTR pstrText, 
    int iCharCount,
    DWORD dwTextFlags, 
    const RECT *pBoundingRect, 
    RECT *pExtentRect
)
{
    static DYNPROC s_dynprocGetThemeTextExtent =
            { NULL, &g_dynlibTheme, "GetThemeTextExtent" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetThemeTextExtent);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, LPCWSTR, int, DWORD, const RECT*, RECT *))
            s_dynprocGetThemeTextExtent.pfn)
            (hTheme, hdc, iPartId, iStateId, pstrText, iCharCount, dwTextFlags, pBoundingRect, pExtentRect);
}

THEMEAPI_(BOOL) IsThemePartDefined(
    HTHEME hTheme, 
    int iPartId, 
    int iStateId
    )
{
    static DYNPROC s_dynprocIsThemePartDefined =
            { NULL, &g_dynlibTheme, "IsThemePartDefined" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocIsThemePartDefined);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)(HTHEME, int, int))
            s_dynprocIsThemePartDefined.pfn)
            (hTheme, iPartId, iStateId);
}

THEMEAPI
CloseThemeData(HTHEME hTheme)
{
    static DYNPROC s_dynprocCloseThemeData =
            { NULL, &g_dynlibTheme, "CloseThemeData" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocCloseThemeData);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME))
            s_dynprocCloseThemeData.pfn)
            (hTheme);
}

THEMEAPI_(BOOL)
IsAppThemed()
{
    static DYNPROC s_dynprocIsAppThemed =
            { NULL, &g_dynlibTheme, "IsAppThemed" };

    HRESULT hr;

    if (!g_fThemedPlatform)
        return FALSE;
    
    hr = LoadProcedure(&s_dynprocIsAppThemed);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)())
            s_dynprocIsAppThemed.pfn)
            ();
}

THEMEAPI_(DWORD)
GetThemeAppProperties()
{
    static DYNPROC s_dynprocGetThemeAppProperties =
            { NULL, &g_dynlibTheme, "GetThemeAppProperties" };

    HRESULT hr;

    if (!g_fThemedPlatform)
        return 0;

    hr = LoadProcedure(&s_dynprocGetThemeAppProperties);
    
    if (hr)
    {
        return 0;
    }

    return (*(DWORD (STDAPICALLTYPE *)())
            s_dynprocGetThemeAppProperties.pfn)
            ();
}

THEMEAPI_(VOID)
SetThemeAppProperties(DWORD dwFlags)
{
    static DYNPROC s_dynprocSetThemeAppProperties =
            { NULL, &g_dynlibTheme, "SetThemeAppProperties" };

    HRESULT hr;

    if (!g_fThemedPlatform)
        return;

    hr = LoadProcedure(&s_dynprocSetThemeAppProperties);
    
    if (hr)
    {
        return;
    }

    return (*(VOID (STDAPICALLTYPE *)(DWORD))
            s_dynprocSetThemeAppProperties.pfn)
            (dwFlags);
}
THEMEAPI_(BOOL)
IsThemeActive()
{
    static DYNPROC s_dynprocIsThemeActive =
            { NULL, &g_dynlibTheme, "IsThemeActive" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return FALSE;

    hr = LoadProcedure(&s_dynprocIsThemeActive);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)())
            s_dynprocIsThemeActive.pfn)
            ();
}

THEMEAPI HitTestThemeBackground(
    HTHEME hTheme,
    OPTIONAL HDC hdc,
    int iPartId,
    int iStateId,
    DWORD dwOptions,
    const RECT *pRect,
    OPTIONAL HRGN hrgn,
    POINT ptTest,
    OUT WORD *pwHitTestCode)
{
    static DYNPROC s_dynprocHitTestThemeBackground =
            { NULL, &g_dynlibTheme, "HitTestThemeBackground" };

    HRESULT hr;

    hr = LoadProcedure(&s_dynprocHitTestThemeBackground);
    
    if (hr)
    {
        return E_FAIL;
    }

    return (*(HRESULT (STDAPICALLTYPE *)(HTHEME, HDC, int, int, DWORD, const RECT *, HRGN, POINT, OUT WORD *))
            s_dynprocHitTestThemeBackground.pfn)
            (hTheme, hdc, iPartId, iStateId, dwOptions, pRect, hrgn, ptTest, pwHitTestCode);
}

VOID
WINAPI
ReleaseActCtx(HANDLE hActCtx)
{
    static DYNPROC s_dynprocReleaseActCtx =
            { NULL, &g_dynlibKERNEL32, "ReleaseActCtx" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return;

    hr = LoadProcedure(&s_dynprocReleaseActCtx);
    
    if (hr)
    {
        return;
    }

    return (*(VOID (STDAPICALLTYPE *)(HANDLE))
            s_dynprocReleaseActCtx.pfn)
            (hActCtx);

/*

    VOID (WINAPI *pfn)(HANDLE);
 
    if (!g_fThemedPlatform)
    {
        return;
    }
    
    pfn = (VOID (WINAPI *)(HANDLE))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "ReleaseActCtx");

    if (pfn)
    {
        pfn(hActCtx);
    }

    return;
*/    
}

HANDLE
WINAPI
CreateActCtxW(PCACTCTXW pActCtx)
{
    static DYNPROC s_dynprocCreateActCtxW =
            { NULL, &g_dynlibKERNEL32, "CreateActCtxW" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return NULL;

    hr = LoadProcedure(&s_dynprocCreateActCtxW);
    
    if (hr)
    {
        return NULL;
    }

    return (*(HANDLE (STDAPICALLTYPE *)(PCACTCTXW))
            s_dynprocCreateActCtxW.pfn)
            (pActCtx);

/*
    HANDLE (WINAPI *pfn)(PCACTCTXW);

    if (!g_fThemedPlatform)
    {
        return NULL;
    }
    
    pfn = (HANDLE (WINAPI *)(PCACTCTXW))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "CreateActCtxW");

    if (pfn)
    {
        return pfn(pActCtx);
    }

    return NULL;
*/
}

HANDLE
WINAPI
CreateActCtxA(PCACTCTXA pActCtx)
{
    static DYNPROC s_dynprocCreateActCtxA =
            { NULL, &g_dynlibKERNEL32, "CreateActCtxA" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return NULL;

    hr = LoadProcedure(&s_dynprocCreateActCtxA);
    
    if (hr)
    {
        return NULL;
    }

    return (*(HANDLE (STDAPICALLTYPE *)(PCACTCTXA))
            s_dynprocCreateActCtxA.pfn)
            (pActCtx);
}

BOOL
WINAPI
ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
{        
    static DYNPROC s_dynprocActivateActCtx =
            { NULL, &g_dynlibKERNEL32, "ActivateActCtx" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return FALSE;

    hr = LoadProcedure(&s_dynprocActivateActCtx);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)(HANDLE, ULONG_PTR *))
            s_dynprocActivateActCtx.pfn)
            (hActCtx, lpCookie);

/*
    BOOL (WINAPI *pfn)(HANDLE, ULONG*);

    if (!g_fThemedPlatform)
    {
        return NULL;
    }
    
    pfn = (BOOL (WINAPI *)(HANDLE, ULONG*))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "ActivateActCtx");

    if (pfn)
    {
        return pfn(hActCtx, lpCookie);
    }

    return FALSE;
*/
}

BOOL
WINAPI
DeactivateActCtx(ULONG dwFlags, ULONG_PTR lpCookie)
{
    static DYNPROC s_dynprocDeactivateActCtx =
            { NULL, &g_dynlibKERNEL32, "DeactivateActCtx" };

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return FALSE;

    hr = LoadProcedure(&s_dynprocDeactivateActCtx);
    
    if (hr)
    {
        return FALSE;
    }

    return (*(BOOL (STDAPICALLTYPE *)(ULONG, ULONG_PTR))
            s_dynprocDeactivateActCtx.pfn)
            (dwFlags, lpCookie);

/*
    BOOL (WINAPI *pfn)(ULONG);

    if (!g_fThemedPlatform)
    {
        return NULL;
    }
    
    pfn = (BOOL (WINAPI *)(ULONG))GetProcAddress(GetModuleHandleA("KERNEL32.DLL"), "DeactivateActCtxW");

    if (pfn)
    {
        return pfn(lpCookie);
    }

    return FALSE;
*/
}

UINT 
Wrap_GetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize)
{
#ifdef UNICODE
    static DYNPROC s_dynprocGetSystemWindowsDirectory =
            { NULL, &g_dynlibKERNEL32, "GetSystemWindowsDirectoryW" };
#else
    static DYNPROC s_dynprocGetSystemWindowsDirectory =
            { NULL, &g_dynlibKERNEL32, "GetSystemWindowsDirectoryA" };
#endif // !UNICODE

    HRESULT hr;
    
    if (!g_fThemedPlatform)
        return 0;

    hr = LoadProcedure(&s_dynprocGetSystemWindowsDirectory);
    
    if (hr)
    {
        return 0;
    }

    return (*(UINT (STDAPICALLTYPE *)(LPTSTR, UINT))
            s_dynprocGetSystemWindowsDirectory.pfn)
            (lpBuffer, uSize);
}

//
// we need this thing to compile
// this is defined in winuser.h
//

/*
 * Combobox information
 */
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT  rcItem;
    RECT  rcButton;
    DWORD stateButton;
    HWND  hwndCombo;
    HWND  hwndItem;
    HWND  hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;
//
// end of winuser story
//

BOOL
WINAPI
GetComboBoxInfo(
    HWND hwndCombo,
    PCOMBOBOXINFO pcbi
)
{
    static DYNPROC s_dynprocGetComboBoxInfo =
            { NULL, &g_dynlibUSER32, "GetComboBoxInfo" };
    
    HRESULT hr;

    hr = LoadProcedure(&s_dynprocGetComboBoxInfo);

    if (hr)
    {
        return NULL;
    }

    return (*(BOOL (STDAPICALLTYPE *)(HWND, PCOMBOBOXINFO))
            s_dynprocGetComboBoxInfo.pfn)
            (hwndCombo, pcbi);
}

#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\ctrl\project.inc ===
# project.inc - project specific settings

CTRL_INC_DIRS=$(SRCROOT)\ctrl\base $(SRCROOT)\ctrl\include $(SRCROOT)\core\include
CTRL_INC_DIRS=$(CTRL_INC_DIRS) $(SRCROOT)\site\include $(SRCROOT)\f3\include $(SDKDIR)
CTRL_INC_DIRS=$(CTRL_INC_DIRS) $(TOOLSINCLUDE) $(TOOLSMISCINCLUDE) $(BLDROOT)\types
CTRL_INC_DIRS=$(CTRL_INC_DIRS) $(SRCROOT)\..\tools\riched\inc $(ROOT)\help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\usp.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       usp.cxx
//
//  Contents:   Dynamic wrappers for USP.dll (UniScribe) functions.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_USP_HXX_
#define X_USP_HXX_
#include "usp.hxx"
#endif

DYNLIB g_dynlibUSP = { NULL, NULL, "USP10.DLL" };

#define WRAPIT(fn, a1, a2)\
HRESULT WINAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibUSP, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (*) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN(hr);\
}

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibUSP, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return NULL;\
    return (*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2;\
}

#define WRAPIT_ERR1(fn, a1, a2, e1)\
HRESULT WINAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibUSP, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (*) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, e1);\
}


WRAPIT(ScriptFreeCache,
    (SCRIPT_CACHE *psc),
    (psc))

WRAPIT_ERR1(ScriptItemize,
    (PCWSTR pwcInChars, int cInChars, int cMaxItems, const SCRIPT_CONTROL *psControl,
     const SCRIPT_STATE *psState, SCRIPT_ITEM *pItems, PINT pcItems),
    (pwcInChars, cInChars, cMaxItems, psControl, psState, pItems, pcItems),
    E_OUTOFMEMORY)

WRAPIT_ERR1(ScriptShape,
    (HDC hdc, SCRIPT_CACHE *psc, const WCHAR *pwcChars, int cChars, int cMaxGlyphs,
     SCRIPT_ANALYSIS *psa, WORD *pwOutGlyphs, WORD *pwLogClust, SCRIPT_VISATTR *psva, int *pcGlyphs),
    (hdc, psc, pwcChars, cChars, cMaxGlyphs, psa, pwOutGlyphs, pwLogClust, psva, pcGlyphs),
    E_OUTOFMEMORY)

WRAPIT(ScriptPlace,
    (HDC hdc, SCRIPT_CACHE *psc, const WORD *pwGlyphs, int cGlyphs, const SCRIPT_VISATTR *psva,
     SCRIPT_ANALYSIS *psa, int *piAdvance, GOFFSET *pGoffset, ABC *pABC),
    (hdc, psc, pwGlyphs, cGlyphs, psva, psa, piAdvance, pGoffset, pABC))

WRAPIT(ScriptTextOut,
    (const HDC hdc, SCRIPT_CACHE *psc, int x, int y, UINT fuOptions, const RECT  *lprc, 
     const SCRIPT_ANALYSIS *psa, const WCHAR *pwcInChars, int cChars, const WORD *pwGlyphs, 
     int cGlyphs, const int *piAdvance, const int *piJustify, const GOFFSET *pGoffset),
    (hdc, psc, x, y, fuOptions, lprc, 
     psa, pwcInChars, cChars, pwGlyphs, 
     cGlyphs, piAdvance, piJustify, pGoffset))

WRAPIT(ScriptBreak,
    (PCWSTR pwcChars, int cChars,const SCRIPT_ANALYSIS *psa, SCRIPT_LOGATTR *psla),
    (pwcChars, cChars, psa, psla))

WRAPIT(ScriptGetCMap,
    (HDC hdc, SCRIPT_CACHE * psc, PCWSTR pwcInChars, int cChars, DWORD dwFlags, PWORD pwOutGlyphs),
    (hdc, psc, pwcInChars, cChars, dwFlags, pwOutGlyphs))

WRAPIT(ScriptGetProperties,
    (const SCRIPT_PROPERTIES ***ppSp, int *piNumScripts),
    (ppSp, piNumScripts))

WRAPIT(ScriptGetFontProperties,
    (HDC hdc, SCRIPT_CACHE *psc, SCRIPT_FONTPROPERTIES  *sfp),
    (hdc, psc, sfp))

WRAPIT(ScriptStringAnalyse,
    (HDC hdc, const void *pString, int cString, int cGlyphs, int iCharset, DWORD dwFlags,
     int iReqWidth, SCRIPT_CONTROL *psControl, SCRIPT_STATE *psState, const int *piDx, 
     SCRIPT_TABDEF *pTabdef, const BYTE *pbInClass, SCRIPT_STRING_ANALYSIS *pssa),
    (hdc, pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl, psState,
     piDx, pTabdef, pbInClass, pssa))

WRAPIT(ScriptStringGetLogicalWidths,
    (SCRIPT_STRING_ANALYSIS ssa, int *piDx),
    (ssa, piDx))

WRAPIT(ScriptStringOut,
    (SCRIPT_STRING_ANALYSIS ssa, int iX, int iY, UINT uOptions, const RECT *prc,
     int iMinSel, int iMaxSel, BOOL fDisabled),
    (ssa, iX, iY, uOptions, prc, iMinSel, iMaxSel, fDisabled))

WRAPIT(ScriptStringFree,
    (SCRIPT_STRING_ANALYSIS *pssa),
    (pssa))

WRAPIT_(const SIZE*,
        ScriptString_pSize,
        (SCRIPT_STRING_ANALYSIS ssa),
        (ssa))

WRAPIT_(const int*,
        ScriptString_pcOutChars,
        (SCRIPT_STRING_ANALYSIS ssa),
        (ssa))


WRAPIT_(const SCRIPT_LOGATTR*,
        ScriptString_pLogAttr,
        (SCRIPT_STRING_ANALYSIS ssa),
        (ssa))


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\wininet.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       wininet.cxx
//
//  Contents:   Dynamic wrappers for InternetCombineUrl
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef DLOAD1

DYNLIB g_dynlibWININET = { NULL, NULL, "WININET.DLL" };

#ifdef _MAC // temporarily redefine macros to warn about missing code.

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    DEBUGSTR("\pWinInet Missing Implementation");\
    return (type) 0;\
}
#define WRAPIT(fn, a1, a2) WRAPIT_(BOOL, fn, a1, a2)

#define WRAPIT2_(type, fn, fn2, a1, a2)\
type WINAPI fn a1\
{\
    DEBUGSTR("\pWinInet Missing Implementation");\
    return (type) 0;\
}
#define WRAPIT2(fn, fn2, a1, a2) WRAPIT2_(BOOL, fn, fn2, a1, a2)

#else

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibWININET, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return FALSE;\
    return ((*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2);\
}
#define WRAPIT(fn, a1, a2) WRAPIT_(BOOL, fn, a1, a2)

#define WRAPIT2_(type, fn, fn2, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibWININET, fn2 };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return FALSE;\
    return ((*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2);\
}
#define WRAPIT2(fn, fn2, a1, a2) WRAPIT2_(BOOL, fn, fn2, a1, a2)

#endif // _MAC

WRAPIT(InternetCanonicalizeUrlA,
    (LPCSTR lpszUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
    (lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags));

WRAPIT(InternetCanonicalizeUrlW,
    (LPCWSTR lpszUrl, LPWSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
    (lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags));

WRAPIT_( DWORD, InternetConfirmZoneCrossingA,
    (HWND hWnd, LPSTR szUrlPrev, LPSTR szUrlNew,BOOL bPost),
    (hWnd, szUrlPrev, szUrlNew, bPost) );

INTERNETAPI_(DWORD)
InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    IN BOOL bPost
    )
{
    CStrIn cstrUrlPrev( szUrlPrev );
    CStrIn cstrUrlNew( szUrlNew );

    return( InternetConfirmZoneCrossingA(hWnd,cstrUrlPrev,cstrUrlNew,bPost) );
}



//
// Wrapper for CreateUrlCacheEntry
//-----------------------------------------------------------------------
WRAPIT(CreateUrlCacheEntryA,
       (LPCSTR lpszUrlName, DWORD dwFileSize, LPCSTR lpszExt, LPSTR lpszFileName, DWORD dwRes),
       (lpszUrlName, dwFileSize, lpszExt, lpszFileName, dwRes));
#endif // DLOAD1

BOOL WINAPI CreateUrlCacheEntryBugW( IN  LPCWSTR lpszUrlName,
                                  IN  DWORD dwFileSize,
                                  IN  LPCWSTR lpszExtension,
                                  OUT LPWSTR lpszFileName,
                                  IN  DWORD dwRes)
{
    CStrIn strInUrl(lpszUrlName);
    CStrIn strInExt(lpszExtension);
    CStrOut strOutName(lpszFileName, MAX_PATH);

    return CreateUrlCacheEntryA(strInUrl, dwFileSize, strInExt, strOutName, dwRes);
}


#ifndef DLOAD1
//
//  Wrapper for CommitUrlCacheEntry
//----------------------------------------------------------------------------
WRAPIT(CommitUrlCacheEntryA,
       (LPCSTR lpszUrl, LPCSTR lpszLocalName, FILETIME Expires, FILETIME lastMod,
            DWORD dwType, LPBYTE lpHeaderInfo, DWORD dwHeaderSize, LPCSTR lpszFileExtension, LPCSTR dwRes),
       (lpszUrl, lpszLocalName, Expires, lastMod, dwType, lpHeaderInfo, dwHeaderSize, lpszFileExtension, dwRes));

#endif // DLOAD1

BOOL WINAPI CommitUrlCacheEntryBugW (
                                   IN LPCWSTR   lpszUrlName,
                                   IN LPCWSTR   lpszLocalFileName,
                                   IN FILETIME  ExpireTime,
                                   IN FILETIME  LastModifiedTime,
                                   IN DWORD     dwCachEntryType,
                                   IN LPCBYTE   lpHeaderInfo,
                                   IN DWORD     dwHeaderSize,
                                   IN LPCWSTR   lpszFileExtension,
                                   IN DWORD     dwReserved)
{
    CStrIn strInUrl(lpszUrlName);
    CStrIn strInFile(lpszLocalFileName);
    CStrIn strInExt(lpszFileExtension);

    return CommitUrlCacheEntryA(strInUrl,
                                strInFile,
                                ExpireTime,
                                LastModifiedTime,
                                dwCachEntryType,
                                (LPBYTE) lpHeaderInfo,
                                dwHeaderSize,
                                strInExt,
                                (LPCSTR)(ULongToPtr(dwReserved)));
}

#ifndef DLOAD1

//
// Wrapper for GetUrlCacheEntryInfo
//--------------------------------------------------------------------------
WRAPIT(GetUrlCacheEntryInfoA,
    (LPCSTR lpszUrl, LPINTERNET_CACHE_ENTRY_INFO pcai, LPDWORD pcb),
    (lpszUrl, pcai, pcb));

BOOL WINAPI GetUrlCacheEntryInfoBugW(
    LPCWSTR lpszUrl,
    LPINTERNET_CACHE_ENTRY_INFO pcai,
    LPDWORD pcb)
{
    CStrIn strInUrl(lpszUrl);

    return GetUrlCacheEntryInfoA(strInUrl, pcai, pcb);
}


WRAPIT(GetUrlCacheEntryInfoExA,
    (IN LPCSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR lpszRedirectUrl,
    IN OUT LPDWORD lpdwRedirectUrlBufSize,
    LPVOID lpReserved,
    DWORD dwReserved),
    (lpszUrl, lpCacheEntryInfo,lpdwCacheEntryInfoBufSize,lpszRedirectUrl,lpdwRedirectUrlBufSize,lpReserved,dwReserved));



BOOL WINAPI
GetUrlCacheEntryInfoExBugW(
    IN LPCWSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR lpszRedirectUrl,
    IN OUT LPDWORD lpdwRedirectUrlBufSize,
    LPVOID lpReserved,
    DWORD dwReserved)
{
    CStrIn strInUrl(lpszUrl);

    return GetUrlCacheEntryInfoExA(strInUrl, lpCacheEntryInfo,
                                    lpdwCacheEntryInfoBufSize, lpszRedirectUrl,
                                    lpdwRedirectUrlBufSize, lpReserved,
                                    dwReserved);
}

WRAPIT2(DeleteUrlCacheEntryA, "DeleteUrlCacheEntry",
       (LPCSTR lpszUrlName),
       (lpszUrlName));

#endif // DLOAD1

BOOL WINAPI
DeleteUrlCacheEntryBugW(LPCWSTR lpszUrlName)
{
    CStrIn strInUrl(lpszUrlName);

    return DeleteUrlCacheEntryA(strInUrl);
}


#ifndef DLOAD1

WRAPIT(SetUrlCacheEntryInfoA,
       (LPCSTR lpszUrlName, LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
        DWORD dwFieldControl),
       (lpszUrlName, lpCacheEntryInfo, dwFieldControl));
#endif // DLOAD1

BOOL WINAPI SetUrlCacheEntryInfoBugW(
    LPCWSTR lpszUrlName,
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
    DWORD dwFieldControl)
{
    CStrIn strInUrl(lpszUrlName);

    // NOTE: does this work? Casting LPINTERNET_CACHE_ENTRY_INFO to LPINTERNET_CACHE_ENTRY_INFOA w/o Unicode conversion
    return SetUrlCacheEntryInfoA(strInUrl, (LPINTERNET_CACHE_ENTRY_INFOA) lpCacheEntryInfo, dwFieldControl);
}

#ifndef DLOAD1

WRAPIT(InternetQueryOptionA,
    (IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength),
    (hInternet, dwOption, lpBuffer, lpdwBufferLength));


WRAPIT(RetrieveUrlCacheEntryFileA,
    (LPCSTR lpszUrl, LPINTERNET_CACHE_ENTRY_INFOA pcai, LPDWORD pcb, DWORD res),
    (lpszUrl, pcai, pcb, res));

#endif // DLOAD1

BOOL WINAPI RetrieveUrlCacheEntryFileBugW(
    LPCWSTR lpszUrl,
    LPINTERNET_CACHE_ENTRY_INFO pcai,
    LPDWORD pcb,
    DWORD res)
{
#ifndef UNIX
    BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
#else
    union
    {
        double alignOn8ByteBoundary;
        BYTE   alignedBuf[MAX_CACHE_ENTRY_INFO_SIZE];
    } buf;
    INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *)&buf;
#endif // UNIX

    DWORD                       cInfo = sizeof(buf);
    CStrIn                      strInUrl(lpszUrl);

    // NOTE: does this work? Casting LPINTERNET_CACHE_ENTRY_INFO to LPINTERNET_CACHE_ENTRY_INFOA w/o Unicode conversion
    if (!RetrieveUrlCacheEntryFileA(strInUrl, (LPINTERNET_CACHE_ENTRY_INFOA) pInfo, &cInfo, res))
    {
        // NOTE: (rodc) This test is here because sometimes an error is
        // reported even if the local file can be returned. In this case
        // ERROR_INVALID_DATA is the last error. Since all we want is the
        // file name pretend all is well.
        if (GetLastError() != ERROR_INVALID_DATA)
            return FALSE;
    }

    cInfo = (*pcb - sizeof(INTERNET_CACHE_ENTRY_INFO))/sizeof(WCHAR);
    pcai->lpszLocalFileName = (TCHAR *) (((BYTE *) pcai) + sizeof(INTERNET_CACHE_ENTRY_INFO));
    MultiByteToWideChar(
            CP_ACP,
            0,
            (char *) pInfo->lpszLocalFileName,
            -1,
            pcai->lpszLocalFileName,
            cInfo);
    pcai->LastModifiedTime.dwHighDateTime = pInfo->LastModifiedTime.dwHighDateTime;
    pcai->LastModifiedTime.dwLowDateTime = pInfo->LastModifiedTime.dwLowDateTime;
    pcai->ExpireTime.dwHighDateTime = pInfo->LastModifiedTime.dwHighDateTime;
    pcai->ExpireTime.dwLowDateTime = pInfo->LastModifiedTime.dwLowDateTime;

    return TRUE;
}

#ifndef DLOAD1

WRAPIT(InternetCrackUrlA,
    (LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
    (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents));

#ifndef WINCE
BOOL WINAPI InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS puc
    )
{
    CStrIn  strInUrl(lpszUrl);
    CStrOut strOutScheme    (puc->lpszScheme,   puc->dwSchemeLength);
    CStrOut strOutHostName  (puc->lpszHostName, puc->dwHostNameLength);
    CStrOut strOutUserName  (puc->lpszUserName, puc->dwUserNameLength);
    CStrOut strOutPassword  (puc->lpszPassword, puc->dwPasswordLength);
    CStrOut strOutUrlPath   (puc->lpszUrlPath,  puc->dwUrlPathLength);
    CStrOut strOutExtraInfo (puc->lpszExtraInfo,puc->dwExtraInfoLength);
    BOOL    fRet;

 #ifdef _MAC
    URL_COMPONENTSA ucA;

    Assert(puc->dwStructSize==sizeof(URL_COMPONENTS));

    memmove(&ucA, puc, sizeof(ucA));

    ucA.lpszScheme       = ((LPSTR)strOutScheme);
    ucA.lpszHostName     = ((LPSTR)strOutHostName);
    ucA.lpszUserName     = ((LPSTR)strOutUserName);
    ucA.lpszPassword     = ((LPSTR)strOutPassword);
    ucA.lpszUrlPath      = ((LPSTR)strOutUrlPath);
    ucA.lpszExtraInfo    = ((LPSTR)strOutExtraInfo);

    fRet = InternetCrackUrlA((char*)strInUrl, dwUrlLength, dwFlags, &ucA);

#else

   URL_COMPONENTS ucA;

    Assert(puc->dwStructSize==sizeof(URL_COMPONENTS));

    memmove(&ucA, puc, sizeof(ucA));

    ucA.lpszScheme       = (LPTSTR)((LPSTR)strOutScheme);
    ucA.lpszHostName     = (LPTSTR)((LPSTR)strOutHostName);
    ucA.lpszUserName     = (LPTSTR)((LPSTR)strOutUserName);
    ucA.lpszPassword     = (LPTSTR)((LPSTR)strOutPassword);
    ucA.lpszUrlPath      = (LPTSTR)((LPSTR)strOutUrlPath);
    ucA.lpszExtraInfo    = (LPTSTR)((LPSTR)strOutExtraInfo);

    fRet = InternetCrackUrlA(strInUrl, dwUrlLength, dwFlags, &ucA);

#endif // _MAC

    if (fRet)
    {
        puc->dwStructSize       = ucA.dwStructSize;
        puc->dwSchemeLength     = strOutScheme.ConvertExcludingNul();
        puc->nScheme            = ucA.nScheme;
        puc->dwHostNameLength   = strOutHostName.ConvertExcludingNul();
        puc->nPort              = ucA.nPort;
        puc->dwUserNameLength   = strOutUserName.ConvertExcludingNul();
        puc->dwPasswordLength   = strOutPassword.ConvertExcludingNul();
        puc->dwUrlPathLength    = strOutUrlPath.ConvertExcludingNul();
        puc->dwExtraInfoLength  = strOutExtraInfo.ConvertExcludingNul();
    }
    else
    {
        puc->dwStructSize       = ucA.dwStructSize;
        puc->dwSchemeLength     = ucA.dwSchemeLength;
        puc->nScheme            = ucA.nScheme;
        puc->dwHostNameLength   = ucA.dwHostNameLength;
        puc->nPort              = ucA.nPort;
        puc->dwUserNameLength   = ucA.dwUserNameLength;
        puc->dwPasswordLength   = ucA.dwPasswordLength;
        puc->dwUrlPathLength    = ucA.dwUrlPathLength;
        puc->dwExtraInfoLength  = ucA.dwExtraInfoLength;
    }

    return fRet;
}
#else //WINCE
WRAPIT(InternetCrackUrlW,
    (LPCWSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
    (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents));
#endif //WINCE

WRAPIT(InternetCreateUrlA,
    (LPURL_COMPONENTS lpUrlComponents, DWORD dwFlags, LPSTR lpszUrl, LPDWORD lpdwUrlLength),
    (lpUrlComponents, dwFlags, lpszUrl, lpdwUrlLength));

BOOL WINAPI InternetCreateUrlW(
    IN LPURL_COMPONENTS puc,
    IN DWORD dwFlags,
    OUT LPWSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    )
{
    CStrOut  strOutUrl(lpszUrl, *lpdwUrlLength);

    CStrIn strInScheme    (puc->lpszScheme,   puc->dwSchemeLength);
    CStrIn strInHostName  (puc->lpszHostName, puc->dwHostNameLength);
    CStrIn strInUserName  (puc->lpszUserName, puc->dwUserNameLength);
    CStrIn strInPassword  (puc->lpszPassword, puc->dwPasswordLength);
    CStrIn strInUrlPath   (puc->lpszUrlPath,  puc->dwUrlPathLength);
    CStrIn strInExtraInfo (puc->lpszExtraInfo,puc->dwExtraInfoLength);
    BOOL    fRet;

    URL_COMPONENTS ucA;

    Assert(puc->dwStructSize==sizeof(URL_COMPONENTS));

    // Only the pointer members need to be changed, so copy all the
    // data and then set the pointer members to their correct values.
    memmove(&ucA, puc, sizeof(ucA));

    ucA.lpszScheme       = (LPTSTR)((LPSTR)strInScheme);
    ucA.lpszHostName     = (LPTSTR)((LPSTR)strInHostName);
    ucA.lpszUserName     = (LPTSTR)((LPSTR)strInUserName);
    ucA.lpszPassword     = (LPTSTR)((LPSTR)strInPassword);
    ucA.lpszUrlPath      = (LPTSTR)((LPSTR)strInUrlPath);
    ucA.lpszExtraInfo    = (LPTSTR)((LPSTR)strInExtraInfo);

    fRet = InternetCreateUrlA(&ucA, dwFlags, strOutUrl, lpdwUrlLength);

    if (fRet)
    {
        *lpdwUrlLength = strOutUrl.ConvertExcludingNul();
    }
    return fRet;
}

WRAPIT(InternetGetCertByURL,
        (LPCTSTR lpszURL, LPTSTR lpszCertText, DWORD dwcbCertText),
        (lpszURL, lpszCertText, dwcbCertText));

WRAPIT(InternetShowSecurityInfoByURL,
       (LPTSTR lpszURL, HWND hwndParent),
       (lpszURL, hwndParent));

WRAPIT(InternetAlgIdToStringA,
        (ALG_ID algID, LPSTR lpsz, LPDWORD lpdw, DWORD dwReserved),
        (algID, lpsz, lpdw, dwReserved));

WRAPIT(InternetAlgIdToStringW,
        (ALG_ID algID, LPWSTR lpwz, LPDWORD lpdw, DWORD dwReserved),
        (algID, lpwz, lpdw, dwReserved));

WRAPIT(InternetSecurityProtocolToStringA,
        (DWORD dwProtocol, LPSTR lpsz, LPDWORD lpdw, DWORD dwReserved),
        (dwProtocol, lpsz, lpdw, dwReserved));

WRAPIT(InternetSecurityProtocolToStringW,
        (DWORD dwProtocol, LPWSTR lpwz, LPDWORD lpdw, DWORD dwReserved),
        (dwProtocol, lpwz, lpdw, dwReserved));

WRAPIT_(HANDLE, FindFirstUrlCacheEntryA,
    (LPCSTR lpszUrlSearchPattern, LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo, LPDWORD lpdwFirstCacheEntryInfoBufferSize),
    (lpszUrlSearchPattern, lpFirstCacheEntryInfo, lpdwFirstCacheEntryInfoBufferSize));
WRAPIT(FindNextUrlCacheEntryA,
    (HANDLE hEnumHandle, LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo, LPDWORD lpdwNextCacheEntryInfoBufferSize),
    (hEnumHandle, lpNextCacheEntryInfo, lpdwNextCacheEntryInfoBufferSize));
WRAPIT(DeleteUrlCacheEntry,
    (LPCSTR lpszUrlName),
    (lpszUrlName));
WRAPIT(FindCloseUrlCache,
    (HANDLE hEnumHandle),
    (hEnumHandle));

WRAPIT_(DWORD, InternetErrorDlg,
     (HWND hWnd, HINTERNET hRequest, DWORD dwError, DWORD dwFlags, LPVOID * lppvData),
     (hWnd, hRequest, dwError, dwFlags, lppvData));

#endif // DLOAD1

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Misc
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
IsURLSchemeCacheable(UINT uScheme)
{
    switch(uScheme)
    {
    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
    case URL_SCHEME_GOPHER:
    case URL_SCHEME_FTP:
        return TRUE;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSecureUrl
//
//  Synopsis:   Returns TRUE for https, FALSE for anything else
//
//              Starting with an IE 4.01 QFE in 1/98, IsUrlSecure returns TRUE
//              for javascript:, vbscript:, and about: if the source
//              document in the wrapped URL is secure.
//
//----------------------------------------------------------------------------
BOOL
IsUrlSecure(const TCHAR *pchUrl)
{
    BOOL fSecure;
    ULONG cb;

    if (!pchUrl)
        return FALSE;

    switch(GetUrlScheme(pchUrl))
    {
    case URL_SCHEME_HTTPS:
        return TRUE;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_FILE:
    case URL_SCHEME_RES:
    case URL_SCHEME_FTP:
        return FALSE;

    default:
        if (!CoInternetQueryInfo(pchUrl, QUERY_IS_SECURE, 0, &fSecure, sizeof(fSecure), &cb, 0) && cb == sizeof(fSecure))
            return fSecure;
        return FALSE;
    }
}

UINT
GetUrlScheme(const TCHAR * pchUrlIn)
{
    PARSEDURL      puw = {0};

    if (!pchUrlIn)
        return (UINT)URL_SCHEME_INVALID;

    puw.cbSize = sizeof(PARSEDURL);

    return (SUCCEEDED(ParseURL(pchUrlIn, &puw))) ?
                puw.nScheme : URL_SCHEME_INVALID;
}


INTERNET_PORT
GetDefaultPort(SHINTERNET_SCHEME nScheme)
{
    switch (nScheme)
    {
    case SHINTERNET_SCHEME_FTP:
        return INTERNET_DEFAULT_FTP_PORT;
    case SHINTERNET_SCHEME_GOPHER:
        return INTERNET_DEFAULT_GOPHER_PORT;
    case SHINTERNET_SCHEME_HTTP:
        return INTERNET_DEFAULT_HTTP_PORT;
    case SHINTERNET_SCHEME_HTTPS:
        return INTERNET_DEFAULT_HTTPS_PORT;
    case SHINTERNET_SCHEME_SOCKS:
        return INTERNET_DEFAULT_SOCKS_PORT;
    default:
        return INTERNET_INVALID_PORT_NUMBER;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlComponentHelper
//
//  Synopsis:   Cracks the Url and returns the specified component.
//
//              The parameter fUseOmLocationFormat is used to decide whether
//              to preserve Nav/IE5 compat in returning a component of
//              window.location. This parameter is not set when returning
//              a component of the href of an A or an AREA.
//
//              Setting fUseOmLocationFormat has the following effect:
//              1. The leading '\' is preserved in the 'pathname'.
//              2. The default port is suppressed in 'host' and 'port'.
//
//----------------------------------------------------------------------------
HRESULT
GetUrlComponentHelper(const TCHAR * pchUrlIn,
                      CStr *        pstrComp,
                      DWORD         dwFlags,
                      URLCOMP_ID    ucid,
                      BOOL          fUseOmLocationFormat)
{
    HRESULT          hr = E_INVALIDARG;
    SHURL_COMPONENTS uc;
    TCHAR            achUrl[pdlUrlLen];
    TCHAR            achComp[pdlUrlLen];
    DWORD            dw, dwLength = ARRAY_SIZE(achUrl);
    TCHAR            chTarget, chDelimit;

    if (!pstrComp || !pchUrlIn)
        goto Cleanup;

    if (!InternetCanonicalizeUrl(pchUrlIn, achUrl, &dwLength, dwFlags))
        goto Cleanup;

    hr = S_OK;

    // Clear everything and set only those fields that we are interested in
    memset(&uc, 0, sizeof(uc));
    uc.dwStructSize = sizeof(SHURL_COMPONENTS);
    switch(ucid)
    {
    case URLCOMP_HOST:
    case URLCOMP_HOSTNAME:
    case URLCOMP_PORT:
        uc.lpszHostName = achComp;
        uc.dwHostNameLength = ARRAY_SIZE(achComp);
        break;
    case URLCOMP_PATHNAME:
        uc.lpszUrlPath = achComp;
        uc.dwUrlPathLength = ARRAY_SIZE(achComp);
        break;
    case URLCOMP_PROTOCOL:
        uc.lpszScheme = achComp;
        uc.dwSchemeLength = ARRAY_SIZE(achComp);
        break;
    case URLCOMP_HASH:
    case URLCOMP_SEARCH:
        uc.lpszExtraInfo = achComp;
        uc.dwExtraInfoLength = ARRAY_SIZE(achComp);
        break;
    }

    if (!UrlCrackW(achUrl, 0, 0, &uc))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    switch(ucid)
    {
    case URLCOMP_HOST:
        hr = THR(pstrComp->Set(uc.lpszHostName));
        if (hr)
            goto Cleanup;

		// Add the port number if there is a "host" (e.g. there is no host for "file:\\server\share")
		// and - for OM Location compatibility reasons - it is NOT the default port
        if (uc.dwHostNameLength && !(fUseOmLocationFormat && uc.nPort == GetDefaultPort(uc.nScheme)))
        {
            hr = THR(pstrComp->Append(_T(":")));
            if (hr)
                goto Cleanup;
            _itot(uc.nPort, achComp, 10);
            hr = THR(pstrComp->Append(achComp));
        }
        break;
    case URLCOMP_HOSTNAME:
        hr = THR(pstrComp->Set(uc.lpszHostName));
        break;
    case URLCOMP_PATHNAME:
        // get rid of the leading '/' if any
        if (!fUseOmLocationFormat && _T('/') == uc.lpszUrlPath[0])
        {
            uc.lpszUrlPath++;
            uc.dwUrlPathLength--;
        }

        // Hack for  for "file://" location -- prepend a '/' (#100998)
        else if (       fUseOmLocationFormat
                 &&     INTERNET_SCHEME_FILE == uc.nScheme
                 &&     _T('/') != uc.lpszUrlPath[0]
                )
        {
            for (dw = uc.dwUrlPathLength+1; dw > 0; dw--)
            {
                uc.lpszUrlPath[dw] = uc.lpszUrlPath[dw-1];
            }
            uc.lpszUrlPath[0] = _T('/');
            uc.dwUrlPathLength++;
        }
        else if ( fUseOmLocationFormat
                  && SHINTERNET_SCHEME_UNKNOWN == uc.nScheme )
        {
            //
            // Bug # 15575. Match shdocvw 5.01 behavior.
            // Calling pathname on about:blank - returned /blank
            //
            UINT ulScheme = GetUrlScheme(pchUrlIn);

            //
            // 5.01 always added a / for about: protocol
            //
            // there are other differences as well
            // ( we're throwing extra escape characters
            // for example about:<body>foo</body> in 5.5
            // is %3Cbody%3E etc. (endcoded)
            // in 5.01 is <body>
            //
            // however - only think about:blank is interesting.
            //
            if ( ulScheme == URL_SCHEME_ABOUT)
            {
                for (dw = uc.dwUrlPathLength+1; dw > 0; dw--)
                {
                    uc.lpszUrlPath[dw] = uc.lpszUrlPath[dw-1];
                }
                uc.lpszUrlPath[0] = _T('/');
                uc.dwUrlPathLength++;
            }
        }
        // ignore the 'search' portion starting from the first
        // '?' or '#'
        for (dw = 0; dw < uc.dwUrlPathLength; dw++)
        {
            if (_T('?') == uc.lpszUrlPath[dw] ||
                _T('#') == uc.lpszUrlPath[dw])
            {
                uc.dwUrlPathLength = dw;
                break;
            }
        }
        hr = THR(pstrComp->Set(uc.lpszUrlPath, uc.dwUrlPathLength));
        break;
    case URLCOMP_PORT:
		// Add the port number if there is a "host" (e.g. there is no host for "file:\\server\share")
		// and - for OM Location compatibility reasons - it is NOT the default port
        if (uc.dwHostNameLength && !(fUseOmLocationFormat && uc.nPort == GetDefaultPort(uc.nScheme)))
        {
            _itot(uc.nPort, achComp, 10);
            hr = THR(pstrComp->Set(achComp));
        }
        else
        {
            hr = THR(pstrComp->Set(g_Zero.ach));
        }
        break;
    case URLCOMP_PROTOCOL:
        hr = THR(pstrComp->Set(uc.lpszScheme));
        if (hr)
            goto Cleanup;
        hr = THR(pstrComp->Append(_T(":")));
        break;

    case URLCOMP_HASH:
        chTarget = _T('#');
        chDelimit = _T('?');
        goto ExtractExtraInfo;
        break;

    case URLCOMP_SEARCH:
        chTarget = _T('?');
        chDelimit = _T('#');
ExtractExtraInfo:
        // extra info returns both hash/search in the same slot. Find the part
        // that has ?abc
        {
            TCHAR * pchSearch = _tcschr(uc.lpszExtraInfo, chTarget);
            if (pchSearch)
            {
                TCHAR * pchHashPart = NULL;
                DWORD   cch = uc.dwExtraInfoLength;

                // for the location object oriented calls, we mimic the shdocvw behavior in
                // 5.01 and return the '?' character even if it is not followed by a search string
                if (cch==1 && !fUseOmLocationFormat)
                {
                    cch--;
                    pchSearch++;
                }

                pchHashPart = _tcschr(pchSearch, chDelimit);

                cch = (pchHashPart) ? pchHashPart - pchSearch : _tcslen(pchSearch);

                hr = THR(pstrComp->Set(pchSearch, cch));
            }
        }
        break;

    }

Cleanup:
    RRETURN(hr);
}


HRESULT
SetUrlComponentHelper(const TCHAR * pchUrlIn,
                      TCHAR       * pchUrlOut,
                      DWORD         dwBufLen,
                      const BSTR  * pstrOriginal,
                      URLCOMP_ID    ucid)
{
    HRESULT          hr = E_INVALIDARG;
    SHURL_COMPONENTS uc;
    TCHAR            achHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR            achScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR            achUrlPath[INTERNET_MAX_PATH_LENGTH];
    TCHAR            achExtraInfo[INTERNET_MAX_PATH_LENGTH];
    TCHAR            achUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR            achPassword[INTERNET_MAX_PASSWORD_LENGTH];
    DWORD            dwLength = dwBufLen;
    TCHAR *          pchPort = NULL;
    BOOL             fPrefixExists;
    TCHAR *          pstrComp = NULL;
    int              iCompLen;


    if (!pstrOriginal || dwLength < pdlUrlLen)
        goto Cleanup;
    if (!pchUrlIn || _tcslen(pchUrlIn) >= dwLength)
        goto Cleanup;
    if (!InternetCanonicalizeUrl(pchUrlIn, pchUrlOut, &dwLength, 0))
        goto Cleanup;

    hr = S_OK;

    uc.dwStructSize = sizeof(SHURL_COMPONENTS);
    uc.lpszScheme = achScheme;
    uc.dwSchemeLength = ARRAY_SIZE(achScheme);
    uc.lpszHostName = achHostName;
    uc.dwHostNameLength = ARRAY_SIZE(achHostName);
    uc.lpszUserName = achUserName;
    uc.dwUserNameLength = ARRAY_SIZE(achUserName);
    uc.lpszPassword = achPassword;
    uc.dwPasswordLength = ARRAY_SIZE(achPassword);
    uc.lpszUrlPath = achUrlPath;
    uc.dwUrlPathLength = ARRAY_SIZE(achUrlPath);
    uc.lpszExtraInfo = achExtraInfo;
    uc.dwExtraInfoLength = ARRAY_SIZE(achExtraInfo);
    uc.nPort = 0;

    if (!_tcslen(pchUrlOut))
    {
        // there is no current url, so set all fields to 0, we will
        // only set the one ...
        uc.dwSchemeLength = 0;
        uc.dwHostNameLength = 0;
        uc.dwUserNameLength = 0;
        uc.dwPasswordLength = 0;
        uc.dwUrlPathLength = 0;
        uc.dwExtraInfoLength = 0;
    }
    else if (!UrlCrackW(pchUrlOut, 0, 0, &uc))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    iCompLen = SysStringLen(*pstrOriginal);
    pstrComp = *pstrOriginal;

    // pull off leading and trailing /'s for NS compatibility
    while (iCompLen && (*pstrComp == _T('/') || *pstrComp == _T('\\')))
    {
        pstrComp++;
        iCompLen--;
    }

    while (iCompLen && (*(pstrComp+iCompLen-1) == _T('/') ||
                        *(pstrComp+iCompLen-1) ==_T('\\')))
    {
        iCompLen--;
    }

    switch(ucid)
    {
    case URLCOMP_HOST:
        // set port first
        pchPort = _tcsrchr(pstrComp, _T(':'));
        if (pchPort)
            uc.nPort = (USHORT)StrToInt(pchPort+1);
        // fall through
    case URLCOMP_HOSTNAME:
        uc.dwHostNameLength = min( (LONG)((pchPort) ? pchPort - pstrComp : (UINT)iCompLen),
                                   (LONG)(ARRAY_SIZE(achHostName) -1));
        _tcsncpy(uc.lpszHostName, pstrComp, uc.dwHostNameLength);
        break;

    case URLCOMP_PATHNAME:
        uc.dwUrlPathLength = min( (UINT)iCompLen,
                                  (UINT) ARRAY_SIZE(achUrlPath)-1 );
        _tcsncpy(uc.lpszUrlPath, pstrComp, uc.dwUrlPathLength);
        break;
    case URLCOMP_PORT:
        uc.nPort = (USHORT)StrToInt(pstrComp);
        break;
    case URLCOMP_PROTOCOL:
        uc.dwSchemeLength = min( (UINT)iCompLen,
                                 (UINT) ARRAY_SIZE(achScheme));
        _tcsncpy(uc.lpszScheme, pstrComp, uc.dwSchemeLength);

        // Remove trailing ':' if any.
        if (uc.dwSchemeLength > 0 &&
            _T(':') == uc.lpszScheme[uc.dwSchemeLength - 1])
        {
             uc.lpszScheme[--uc.dwSchemeLength] = 0;
        }
        break;
    case URLCOMP_SEARCH:
        // Must prefix this with '?'
        fPrefixExists = (uc.dwExtraInfoLength > 0);
        uc.dwExtraInfoLength = iCompLen + 1;
        if (uc.dwExtraInfoLength >= ARRAY_SIZE(achExtraInfo))
            goto Cleanup;
        uc.lpszExtraInfo[0] = _T('?');
         _tcsncpy(uc.lpszExtraInfo + 1, pstrComp, iCompLen);
        break;
    case URLCOMP_HASH:
        // Must prefix this with '#'
        fPrefixExists = (uc.dwExtraInfoLength > 0);
        uc.dwExtraInfoLength = iCompLen + 1;
        if (uc.dwExtraInfoLength >= ARRAY_SIZE(achExtraInfo))
            goto Cleanup;
        uc.lpszExtraInfo[0] = _T('#');
         _tcsncpy(uc.lpszExtraInfo + 1, pstrComp, iCompLen);
        break;
    }

    dwLength = dwBufLen;
    hr = THR(ComposeUrl(&uc, 0, pchUrlOut, & dwLength));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------
//
//  method  :   ComposeUrl()
//
//  Synopsis : The core of this was stolen from ie, and modified to be
//      more general and robust.  it creates a single url string from
//      the componenet pieces.
//
//----------------------------------------------------------------

HRESULT
ComposeUrl(SHURL_COMPONENTS * puc,
           DWORD              dwFlags,
           TCHAR            * pchUrlOut,
           DWORD            * pdwSize)
{
	HRESULT   hr = S_OK;
    ULONG     lRequiredSize;
    TCHAR     achSchemeSep[]  = _T("://");
    TCHAR     achPort[18];
    TCHAR   * pchCopyHere = NULL;
    const int iSchemeSepLen = _tcslen(achSchemeSep);
    int       nPortLength;
    int       iTch =  sizeof(TCHAR);

    // set up for the port component
    _itot(puc->nPort, achPort, 10);
    nPortLength = _tcslen(achPort);

    // is there enough space in the buffer?
    lRequiredSize = puc->dwSchemeLength    +     // http
                   iSchemeSepLen          +     // ://
                   puc->dwHostNameLength  +     // www.myserver.org
                   nPortLength  + 1       +     // :##
                   puc->dwUserNameLength  +
                   ((puc->dwUserNameLength != 0) ? 1 : 0) +  // +1 for '@'
                   puc->dwPasswordLength  +
                   ((puc->dwPasswordLength != 0) ? 1 : 0) +  // +1 for ':'
                   1                      +     // /
                   puc->dwUrlPathLength   +     // the rest
                   1                      +     // '#' or '?'
                   puc->dwExtraInfoLength +     // search string, hash-name
                   1;                           // +1 for '\0'

    if (lRequiredSize > *pdwSize)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
        goto Cleanup;
    }

    // start building the string...
    pchCopyHere = pchUrlOut;

    if (puc->dwSchemeLength)
    {
	    _tcsncpy(pchCopyHere, puc->lpszScheme, puc->dwSchemeLength);
        pchCopyHere += puc->dwSchemeLength;

        _tcsncpy(pchCopyHere, achSchemeSep, iSchemeSepLen);
        pchCopyHere += iSchemeSepLen;
    }

    if (puc->dwUserNameLength)
    {
        _tcsncpy(pchCopyHere, puc->lpszUserName, puc->dwUserNameLength);
        pchCopyHere += puc->dwUserNameLength;

        if (puc->dwPasswordLength)
        {
            _tcsncpy(pchCopyHere, _T(":"), iTch);
            pchCopyHere ++;

            _tcsncpy(pchCopyHere, puc->lpszPassword, puc->dwPasswordLength);
            pchCopyHere += puc->dwPasswordLength;
        }
        _tcsncpy(pchCopyHere, _T("@"), iTch);
        pchCopyHere ++;
    }

	if (puc->dwHostNameLength)
	{
		_tcsncpy(pchCopyHere, puc->lpszHostName, puc->dwHostNameLength);
		pchCopyHere += puc->dwHostNameLength;

		if (nPortLength)
		{
			_tcsncpy(pchCopyHere, _T(":"), iTch);
			pchCopyHere ++;

			_tcsncpy(pchCopyHere, achPort, nPortLength);
			pchCopyHere += nPortLength;
		}
	}

    if (puc->dwUrlPathLength)
    {
        if (puc->dwHostNameLength && *puc->lpszUrlPath != _T('/'))
        {
            _tcsncpy(pchCopyHere, _T("/"), iTch);
            pchCopyHere ++;
        }

        _tcsncpy(pchCopyHere, puc->lpszUrlPath, puc->dwUrlPathLength);
        pchCopyHere += puc->dwUrlPathLength;
    }

    if (puc->dwExtraInfoLength)
    {
        _tcsncpy(pchCopyHere, puc->lpszExtraInfo, puc->dwExtraInfoLength);
        pchCopyHere += puc->dwExtraInfoLength;
    }

    *pchCopyHere= _T('\0');

Cleanup:
    RRETURN(hr);
}

#ifndef DLOAD1


WRAPIT(InternetGetCookie,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPTSTR lpCookieData, LPDWORD lpdwSize),
       (lpszUrl, lpszCookieName, lpCookieData, lpdwSize));

WRAPIT(InternetGetCookieEx,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPTSTR lpszCookieData, LPDWORD lpdwSize, DWORD dwFlags, LPVOID dwReserved),
       (lpszUrl, lpszCookieName, lpszCookieData, lpdwSize, dwFlags, dwReserved));

WRAPIT(InternetSetCookie,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPCTSTR lpszCookieData),
       (lpszUrl, lpszCookieName, lpszCookieData));

WRAPIT_(DWORD,InternetSetCookieExW,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPCTSTR lpszCookieData, DWORD dwFlags, DWORD_PTR dwReserved),
       (lpszUrl, lpszCookieName, lpszCookieData, dwFlags, dwReserved));

WRAPIT_(DWORD,InternetSetCookieExA,
       (LPCTSTR lpszUrl, LPCTSTR lpszCookieName, LPCTSTR lpszCookieData, DWORD dwFlags, DWORD_PTR dwReserved),
       (lpszUrl, lpszCookieName, lpszCookieData, dwFlags, dwReserved));

//+-----------------------------------------------------------------------
//
// GetDateFormat() and GetTimeFormat() only have unicode version on NT
//
//-----------------------------------------------------------------------

WRAPIT(GetDateFormatA,
       (LCID locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, LPCTSTR lpFormat,
            LPTSTR lpDateStr, int cchDate),
       (locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate));

int WINAPI GetDateFormat_BugW( IN LCID Locale,
                               IN DWORD dwFlags,
                               IN CONST SYSTEMTIME * lpDate,
                               IN LPCTSTR lpFormat,
                               OUT LPTSTR lpDateStr,
                               IN int cchDate)
{
#ifndef WINCE
    int    iValue;
    CStrIn strInFormat(lpFormat);
    CStrOut strOutDateStr(lpDateStr, cchDate);

    iValue = GetDateFormatA(Locale, dwFlags, lpDate, strInFormat, strOutDateStr, cchDate);

    if (iValue)
    {
        iValue = strOutDateStr.ConvertIncludingNul();
    }

    return iValue;
#else //WINCE
	return GetDateFormat(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
#endif //WINCE
}

WRAPIT(GetTimeFormatA,
       (LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, LPCTSTR lpFormat,
            LPTSTR lpTimeStr, int cchTime),
       (Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime));

int WINAPI GetTimeFormat_BugW( IN LCID Locale,
                               IN DWORD dwFlags,
                               IN CONST SYSTEMTIME * lpTime,
                               IN LPCTSTR lpFormat,
                               OUT LPTSTR lpTimeStr,
                               IN int cchTime)
{
#ifndef WINCE
    int   iValue;
    CStrIn strInFormat(lpFormat);
    CStrOut strOutTimeStr(lpTimeStr, cchTime);

    iValue = GetTimeFormatA(Locale, dwFlags, lpTime, strInFormat, strOutTimeStr, cchTime);

    if (iValue)
    {
        iValue = strOutTimeStr.ConvertIncludingNul();
    }
    return iValue;
#else //WINCE
    return GetTimeFormat(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
#endif //WINCE
}

#endif // DLOAD1

//+---------------------------------------------------------------------------
//
//  method : ConvertDateTimeToString
//
//  Synopsis:
//          Converts given date and time if requested to string using the local time
//          in a fixed format mm/dd/yyyy or mm/dd/yyy hh:mm:ss
//
//----------------------------------------------------------------------------

// NB (cthrash) This function produces a standard(?) format date, of the form
// MM/DD/YY HH:MM:SS (in military time.) The date format *will not* be tailored
// for the locale.  This is for Netscape compatibility, and is a departure from
// how IE3 worked.  If you want the date in the format of the document's locale,
// you should use the Java Date object.

HRESULT
ConvertDateTimeToString(FILETIME Time, BSTR * pBstr, BOOL fReturnTime)
{
    HRESULT    hr;
    SYSTEMTIME SystemTime;
    TCHAR pchDateStr[DATE_STR_LENGTH];
    FILETIME     ft;

    Assert(pBstr);

    // We want to return local time as Nav not GMT
    if (!FileTimeToLocalFileTime(&Time, &ft))
    {
        hr  = GetLastWin32Error();
        goto Cleanup;
    }

    if (!FileTimeToSystemTime( &ft, &SystemTime ))
    {
        hr  = GetLastWin32Error();
        goto Cleanup;
    }

    // We want Gregorian dates and 24-hour time.
    if(fReturnTime)
    {
        hr = THR(Format( 0, pchDateStr, ARRAY_SIZE(pchDateStr),
                     _T("<0d2>/<1d2>/<2d4> <3d2>:<4d2>:<5d2>"),
                     SystemTime.wMonth,
                     SystemTime.wDay,
                     SystemTime.wYear,
                     SystemTime.wHour,
                     SystemTime.wMinute,
                     SystemTime.wSecond ));
    }
    else
    {
        hr = THR(Format( 0, pchDateStr, ARRAY_SIZE(pchDateStr),
                     _T("<0d2>/<1d2>/<2d4>"),
                     SystemTime.wMonth,
                     SystemTime.wDay,
                     SystemTime.wYear));
    }

    if (hr)
        goto Cleanup;

    hr = THR(FormsAllocString(pchDateStr, pBstr));

Cleanup:
    RRETURN(hr);
}

#ifndef DLOAD1

WRAPIT(InternetTimeToSystemTime,
       (LPCTSTR lpszTime, SYSTEMTIME *pst, DWORD dwReserved),
       (lpszTime, pst, dwReserved));

WRAPIT(UnlockUrlCacheEntryFileA,
    (LPCSTR lpszUrl, DWORD dwReserved),
    (lpszUrl, dwReserved));

#endif // DLOAD1

BOOL WINAPI UnlockUrlCacheEntryFileBugW(
    LPCWSTR lpszUrl,
    DWORD dwReserved)
{
    CStrIn strInUrl(lpszUrl);

    return UnlockUrlCacheEntryFileA(strInUrl, dwReserved);
}

#ifndef DLOAD1

// These calls are used by pluginst.cxx to track down the mime
// type.  These are all specifically ANSI calls because wonderful
// wininet.dll does not support the wide-char versions, even though
// it happily exports them.

WRAPIT_( HINTERNET, InternetOpenA,
    (LPCSTR lpszAgent,DWORD dwAccessType,LPCSTR lpszProxy,LPCSTR lpszProxyBypass,DWORD dwFlags),
    (lpszAgent,dwAccessType,lpszProxy,lpszProxyBypass,dwFlags));

INTERNETAPI_(HINTERNET)
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    CStrIn szAgent( lpszAgent );
    CStrIn szProxy( lpszProxy );
    CStrIn szProxyBypass( lpszProxyBypass );

    return( InternetOpenA( szAgent, dwAccessType, szProxy, szProxyBypass, dwFlags ) );
}


WRAPIT_( HINTERNET, InternetOpenUrlA,
    (HINTERNET hInternet,LPCSTR lpszUrl,LPCSTR lpszHeaders,DWORD dwHeadersLength,DWORD dwFlags,DWORD_PTR dwContext),
    (hInternet,lpszUrl,lpszHeaders,dwHeadersLength,dwFlags,dwContext));

INTERNETAPI_(HINTERNET)
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    CStrIn szUrl( lpszUrl );
    CStrIn szHeaders( lpszHeaders );

    return( InternetOpenUrlA(hInternet,szUrl,szHeaders,dwHeadersLength,dwFlags,dwContext) );
}

WRAPIT_( BOOL, InternetSetOptionA,
    (HINTERNET hInternet,DWORD dwOption,LPVOID lpBuffer,DWORD dwBufferLength),
    (hInternet,dwOption,lpBuffer,dwBufferLength)
);

//
// W A R N I N G:
//
//   This wrapper does not handle all types of calls to this
//   routine.  It does no Wide-char to ascii conversion, and
//   so only handles the calls such as INTERNET_SET_CONNECT_TIMETOUT
//   which do NOT take strings in the lpBuffer parameter.
//
// W A R N I N G
//

BOOLAPI InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    return( InternetSetOptionA( hInternet, dwOption, lpBuffer, dwBufferLength ) );
}

WRAPIT_( BOOL, HttpQueryInfoA,
    (HINTERNET hRequest,DWORD dwInfoLevel,LPVOID lpBuffer,LPDWORD lpdwBufferLength,LPDWORD lpdwIndex),
    (hRequest,dwInfoLevel,lpBuffer,lpdwBufferLength,lpdwIndex)
);


BOOLAPI HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    CStrOut     strOutMime((WCHAR*)lpBuffer, MAX_PATH);
    BOOL        fRet;

    fRet = HttpQueryInfoA(hRequest,dwInfoLevel,strOutMime,lpdwBufferLength,lpdwIndex);

    strOutMime.ConvertIncludingNul();

    return( fRet );
}

WRAPIT( InternetCloseHandle,
    (HINTERNET hInternet),
    (hInternet));

WRAPIT(InternetUnlockRequestFile,
    (HANDLE hLock),
    (hLock));

WRAPIT(InternetGetConnectedState,
    (LPDWORD lpdwFlags, DWORD dwReserved),
    (lpdwFlags, dwReserved));

WRAPIT(IsUrlCacheEntryExpiredW,
    (LPCWSTR lpszUrlName, DWORD dwFlags, FILETIME * pftLastModifiedTime),
    (lpszUrlName, dwFlags, pftLastModifiedTime));

#endif // DLOAD1

//+--------------------------------------------------------------------------
//
//  Function : ShortCutUrlHelper
//
//  Synopsis : the helper's helper. in this cas (HASH and SEARCH setting we
//          do not need the over head of the full SetUrlCode. i.e. we are
//          either appending or replacing existing parts
//
//---------------------------------------------------------------------------

HRESULT
ShortCutSetUrlHelper(const TCHAR * pchUrlIn,
                     TCHAR       * pchUrlOut,
                     DWORD         dwBufLen,
                     const BSTR  * pstrComp,
                     URLCOMP_ID    ucid,
                     BOOL          fUseOmLocationFormat)
{
    HRESULT        hr = S_OK;
    DWORD          cch = 0;
    const TCHAR    chTarget = (ucid==URLCOMP_HASH) ? _T('#') : _T('?');
    const TCHAR  * pchComp = (*pstrComp) ? *pstrComp : _T("");
    long           lLength = SysStringLen(*pstrComp)+1;  // +1 for \0

    Assert((ucid==URLCOMP_HASH) || (ucid==URLCOMP_SEARCH));

    // copy over the base url
    if (pchUrlIn)
    {
        while (*pchUrlIn && (*pchUrlIn != chTarget) && (cch++ < (dwBufLen-1)))
        {
            *pchUrlOut++ = * pchUrlIn++;
        }
    }

    // deal with the hash/search character
    // NS always appends a '#' but never a '?'
    // Only add the '#' if the pstrComp does not start with '#' in location case.

    // SHDOCVW implementation always added the '?' to the beginning of the
    // URL in case it was not there.

    if ((ucid==URLCOMP_HASH && (!fUseOmLocationFormat || (*pchComp != chTarget))) ||
        (ucid==URLCOMP_SEARCH && fUseOmLocationFormat && (*pchComp != chTarget)))
    {
        (*pchUrlOut++) = chTarget;
        cch++;
    }

    // add the search/hash property. Truncate if too long
    if (cch+lLength > dwBufLen)
        lLength = dwBufLen - cch;

    _tcsncpy(pchUrlOut, pchComp, lLength);
    *(pchUrlOut+lLength-1) = _T('\0');
    hr = S_OK;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\dl\bookmark.cxx ===
//+---------------------------------------------------------------------------
//
//  Maintained by: Jerry, Terry and Ted
//
//  Microsoft DataDocs
//  Copyright (C) Microsoft Corporation, 1994-1995
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  File:       ddoc\dl\bookmark.cxx
//
//  Contents:   Data Layer Bookmark/Chapter helper object
//
//  Classes:    CDataLayerBookmarkHelper
//
//  Functions:  None.
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DLCURSOR_HXX_
#define X_DLCURSOR_HXX_
#include "dlcursor.hxx"
#endif

DeclareTag(tagDataLayerBookmarkHelper, "DataLayerBookmark's",
           "Nile (OLE DB) bookmarks/chapters" );

MtDefine(CDataLayerBookmarkHelperRep, DataBind, "CDataLayerBookmarkHelperRep")

//+---------------------------------------------------------------------------
//
//  CDataLayerBookmarkHelperRep is the refcounted object which holds the real
//  bookmark.  Note:  This is not a OLE refcount!  Iff the Bookmark/Chapter
//  is null the pointer to this rep (_pRep) is null.  Iff the Bookmark/Chapter
//  is a predefined DBBMK_* iSize is eSimple and _dbbmk holds that byte (use
//  IsSimple() to check for this.)  Iff iSize is eFabricated then this bookmark
//  is a fabricated bookmark for use by an DataLayerCursor (use IsFabricated().)
//  _pDataLayerCursor is only used for Nile bookmarks (i.e. IsVarying, IsULONG
//  and IsHROW.)  Be sure to look at IsValidObjects routines at the bottom of
//  this file for this and other representation invariants.
//

class CDataLayerBookmarkHelperRep
{
public:
    unsigned long           _uRefCount;
    CDataLayerCursor *const _pDataLayerCursor;
    const size_t            _iSize;
    enum
        {
        eSimple = -1,
        eULONG = -2
        };
    BOOL IsSimple()      const { return _iSize == eSimple; }


    BOOL IsULONG()       const { return _iSize == eULONG; }
    BOOL IsVarying()     const { return int(_iSize) >= 0; }
    BOOL IsHCHAPTER()    const { return FALSE; }
    BOOL IsFabricated()  const { return FALSE; }
    union // NOTE:  This must be the last field in this structure! (see new).
    {
        BYTE                      _abData[1];
        ULONG                     _uData;
        HROW                      _hRow;
    };
    CDataLayerBookmarkHelperRep(CDataLayerCursor *const, const size_t iSize,
        const void *pvData );
    CDataLayerBookmarkHelperRep(CDataLayerCursor *const, const ULONG &);
    // overload new && delete to enable caching of 
    // bookmark creation (frankman 1/23/96)
    void *operator new (size_t uCompilerSize, size_t uDataSize);
    void *operator new (size_t);
    void operator delete( void* p );

    // two fixed bookmarks
    static CDataLayerBookmarkHelperRep TheFirst;
    static CDataLayerBookmarkHelperRep TheLast;

private:
//    NO_COPY(CDataLayerBookmarkHelperRep);
    CDataLayerBookmarkHelperRep(const BYTE &dbbmk ) :
        _uRefCount(1), _pDataLayerCursor(NULL), _iSize((const size_t)eSimple)
    {
        _abData[0] = dbbmk;
    }

public:
};

typedef CDataLayerBookmarkHelperRep CRep;

//+---------------------------------------------------------------------------
//
//  Member:     Constructor - Create a simple, "predefined" bookmark
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(const BYTE &dbbmk)
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::constructor(%p{%u})", this, dbbmk ));

    if (dbbmk == DBBMK_FIRST)
    {
        _pRep = &CDataLayerBookmarkHelperRep::TheFirst;
    }
    else
    {
        Assert(dbbmk == DBBMK_LAST);
        _pRep = &CDataLayerBookmarkHelperRep::TheLast;
    }
    IS_VALID(this);
}

// Initialize statics

// as good a place as any to define these
extern const BYTE g_bBmkLast = DBBMK_LAST;

#ifdef _MAC
CRep CRep::TheFirst((BYTE) DBBMK_FIRST);
CRep CRep::TheLast((BYTE) DBBMK_LAST);
#else
CRep CRep::TheFirst = CRep((BYTE) DBBMK_FIRST);
CRep CRep::TheLast = CRep((BYTE) DBBMK_LAST);
#endif
const CDataLayerBookmark CDataLayerBookmark::TheNull = CDataLayerBookmark();
const CDataLayerBookmark CDataLayerBookmark::TheFirst = CDataLayerBookmark((BYTE) DBBMK_FIRST);
const CDataLayerBookmark CDataLayerBookmark::TheLast = CDataLayerBookmark((BYTE) DBBMK_LAST);


CDataLayerBookmarkHelperRep::CDataLayerBookmarkHelperRep(
    CDataLayerCursor *const pDataLayerCursor,
    const size_t iSize, const void *pvData ) :
    _uRefCount(1), _pDataLayerCursor(pDataLayerCursor), _iSize(iSize)
{
    memcpy(_abData, pvData, iSize);
}
CDataLayerBookmarkHelperRep::CDataLayerBookmarkHelperRep(
    CDataLayerCursor *const pDataLayerCursor, const ULONG &rul ) :
    _uRefCount(1), _pDataLayerCursor(pDataLayerCursor), _iSize((const size_t)eULONG)
{
    _uData = rul;
}


inline void *
CDataLayerBookmarkHelperRep::operator new(size_t uCompilerSize,
                                          size_t uDataSize)
                                          
{
    return ::new(Mt(CDataLayerBookmarkHelperRep)) BYTE[uCompilerSize + uDataSize - sizeof(void*)];
}

inline void *
CDataLayerBookmarkHelperRep::operator new(size_t uCompilerSize)
                                          
{
    return ::new(Mt(CDataLayerBookmarkHelperRep)) BYTE[uCompilerSize];
}


inline void 
CDataLayerBookmarkHelperRep::operator delete (void *p)
{
    ::delete p;
}

//+---------------------------------------------------------------------------
//
//  getDataPointer and getDataSize are used when using a bookmark/chapter with
//  Nile.  They decode the internal rep and return appropriate info.
//

const BYTE *
CDataLayerBookmarkHelper::getDataPointer() const
{
    const BYTE *ret = IsNull() ? NULL
                               : _pRep->_abData;
    return ret;
}


size_t
CDataLayerBookmarkHelper::getDataSize() const
{
    size_t ret = IsNull() ? 0 :
                 _pRep->IsSimple() ? 1 :
                 _pRep->IsVarying() ? _pRep->_iSize :
                sizeof(ULONG);
    return ret;
}

// TODO: should be in-line now, but outside world doesn't know about CRep
BOOL
CDataLayerBookmarkHelper::IsDBBMK_FIRST() const
{
    // we only allow the world to have one Rep for the for DBBMK_FIRST
    Assert((_pRep == &CRep::TheFirst)
        == (_pRep && _pRep->IsSimple() && _pRep->_abData[0] == DBBMK_FIRST) );
    return _pRep == &CRep::TheFirst;
}


// TODO: should be in-line now, but outside world doesn't know about CRep
BOOL
CDataLayerBookmarkHelper::IsDBBMK_LAST() const
{
    // we only allow the world to have one Rep for the for DBBMK_LAST
    Assert((_pRep == &CRep::TheLast)
        == (_pRep && _pRep->IsSimple() && _pRep->_abData[0] == DBBMK_LAST) );
    return _pRep == &CRep::TheLast;
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Trace is used for TraceTag because decoding the rep on the fly is not easy.
//

void
CDataLayerBookmarkHelper::Trace(LPSTR pstr)
{
    if (IsNull())
    {
        TraceTag((tagDataLayerBookmarkHelper,
                  "CDataLayerBookmarkHelper::%s(%p{0})", pstr, this ));
    }
    else
    {
        TraceTag((tagDataLayerBookmarkHelper,
                  "CDataLayerBookmarkHelper::%s(%p{%p, %u, %u, %p})",
                  pstr, this, _pRep, _pRep->_uRefCount, _pRep->_iSize,
                  _pRep->_pDataLayerCursor ));
    }
}
#define TRACE(x) Trace(x)
#else
#define TRACE(x) 0
#endif



//+---------------------------------------------------------------------------
//
//  Member:     Copy Constructor
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(
    const CDataLayerBookmarkHelper &rdlb ) : _pRep(rdlb._pRep)
{
    TRACE("constructor");

    IS_VALID(this);

    if (!IsNull())
    {
        _pRep->_uRefCount += 1;
    }
}




//+---------------------------------------------------------------------------
//
//  Member:     Constructor - construct from a DBVECTOR
//
//  Iff we run out of memory the resultant Bookmark/Chapter is null (use IsNull)
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(
    CDataLayerCursor &rDataLayerCursor, const DBVECTOR &rdbv )
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::constructor(%p{%p, %u})",
              this, &rDataLayerCursor, rdbv.size ));

    _pRep = new (rdbv.size) CRep(&rDataLayerCursor, rdbv.size, rdbv.ptr);
    CoTaskMemFree(rdbv.ptr);
    IS_VALID(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     Constructor - construct from a ULONG
//
//  Iff we run out of memory the resultant Bookmark/Chapter is null (use IsNull)
//

CDataLayerBookmarkHelper::CDataLayerBookmarkHelper(
    CDataLayerCursor &rDataLayerCursor, const ULONG &rul )
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::constructor(%p{%p, %u})",
              this, &rDataLayerCursor, rul ));

    _pRep = new CRep(&rDataLayerCursor, rul);
    IS_VALID(this);
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     Destructor
//

CDataLayerBookmarkHelper::~CDataLayerBookmarkHelper()
{
    TRACE("destructor");

    IS_VALID(this);

    Assert("Passivate wasn't called before destructor" &&
           (IsNull()) );
}
#endif



//+---------------------------------------------------------------------------
//
//  Member:     Unlink
//
//  Decrement ref count and release if gone.
//

void
CDataLayerBookmarkHelper::Unlink()
{
    TRACE("Unlink");

    IS_VALID(this);

    if (!IsNull())
    {
        _pRep->_uRefCount -= 1;
        if (!_pRep->_uRefCount)
        {
            if (!_pRep->IsSimple())
            {
                delete _pRep;
                _pRep = 0;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Assignment operator
//

CDataLayerBookmarkHelper &
CDataLayerBookmarkHelper::operator=(const CDataLayerBookmarkHelper &rdlb)
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmarkHelper::%p = %p", this, &rdlb ));

    IS_VALID(this);
    if (_pRep != rdlb._pRep)
    {
        Unlink();
        _pRep = rdlb._pRep;
        if (!IsNull())
        {
            _pRep->_uRefCount += 1;
        }
    }
    return *this;
}


//+---------------------------------------------------------------------------
//
//  Member:     operator==
//
//  Synopsis:   Compare two bookmarks
//

BOOL
CDataLayerBookmark::operator==(const CDataLayerBookmark &rdlb) const
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmark::%p == %p", this, &rdlb ));

    IS_VALID((CDataLayerBookmark*)this);
    IS_VALID((CDataLayerBookmark*)&rdlb);

    if (_pRep == rdlb._pRep)
    {
        return TRUE;
    }
    if (IsNull() || rdlb.IsNull())
    {
        return FALSE;
    }

    if (_pRep->IsVarying() != rdlb._pRep->IsVarying())
    {
        return (FALSE);
    }
    if (!_pRep->IsVarying())
    {
        if (_pRep->_iSize != rdlb._pRep->_iSize)
        {
            return FALSE;
        }
        if (_pRep->IsULONG())
        {
            goto RowsetCompare;
        }

        Assert(_pRep->IsSimple());      // last case must be simple..
        // we only have two static bookmarks, and we already checked if
        //  the two _pReps matched!
        Assert(_pRep->_abData[0] != rdlb._pRep->_abData[0]);
        return FALSE;
    }
    else
    {
RowsetCompare:
        Assert(_pRep->_pDataLayerCursor == rdlb._pRep->_pDataLayerCursor);
        DBCOMPARE dbc;
        return !_pRep->_pDataLayerCursor->_pRowsetLocate->Compare(
                   _pRep->_pDataLayerCursor->_hChapter,
                   getDataSize(), getDataPointer(),
                   rdlb.getDataSize(), rdlb.getDataPointer(), &dbc ) &&
               dbc == DBCOMPARE_EQ;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     operator<
//
//  Synopsis:   Compare two bookmarks
//

BOOL
CDataLayerBookmark::operator<(const CDataLayerBookmark &rdlb) const
{
    TraceTag((tagDataLayerBookmarkHelper,
              "CDataLayerBookmark::%p < %p", this, &rdlb ));

    IS_VALID((CDataLayerBookmark*)this);
    IS_VALID((CDataLayerBookmark*)&rdlb);

    if (_pRep == rdlb._pRep || rdlb.IsNull())
    {
        return FALSE;
    }
    if (IsNull())
    {
        return TRUE;
    }
    if (_pRep->IsSimple() || rdlb._pRep->IsSimple())
    {
        return !rdlb._pRep->IsSimple() ||
               _pRep->_abData[0] < rdlb._pRep->_abData[0];
    }

    Assert((_pRep->IsVarying() || _pRep->IsULONG()) &&
           (rdlb._pRep->IsVarying() || rdlb._pRep->IsULONG()) );

    Assert(_pRep->_pDataLayerCursor == rdlb._pRep->_pDataLayerCursor);

    const BYTE *pbBookmarkData1 = getDataPointer();
    size_t      cbBookmarkSize1 = getDataSize();
    const BYTE *pbBookmarkData2 = rdlb.getDataPointer();
    size_t      cbBookmarkSize2 = rdlb.getDataSize();
    DBCOMPARE   dbc;

    if (_pRep->_pDataLayerCursor->_pRowsetLocate->Compare(
            _pRep->_pDataLayerCursor->_hChapter,
            cbBookmarkSize1, pbBookmarkData1,
            cbBookmarkSize2, pbBookmarkData2, &dbc ) ||
        dbc == DBCOMPARE_NE || dbc == DBCOMPARE_NOTCOMPARABLE )
    {
        int cmp = memcmp(pbBookmarkData1, pbBookmarkData2,
                         min(cbBookmarkSize1, cbBookmarkSize2) );
        return cmp < 0 || (cmp == 0 && cbBookmarkSize1 < cbBookmarkSize2);
    }
    else
    {
        Assert(dbc == DBCOMPARE_EQ || dbc == DBCOMPARE_LT ||
               dbc == DBCOMPARE_GT );
        return (dbc == DBCOMPARE_LT);
    }
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method, called by macro IS_VALID(p)
//

BOOL
CDataLayerBookmarkHelper::IsValidObject()
{
    if (!IsNull())
    {
        Assert("_pRep must be exactly one type" &&
               (_pRep->IsSimple()  + _pRep->IsFabricated() +
                _pRep->IsVarying() + _pRep->IsULONG() == 1 ) );
        Assert("Nile and HROW Bookmarks (only) should have cursors" &&
               ((_pRep->IsVarying() || _pRep->IsULONG()) ==
                !!_pRep->_pDataLayerCursor ) );
        Assert("Only two fixed Reps for Simple bookmarks" &&
                (_pRep == &CRep::TheFirst || _pRep == &CRep::TheLast)
                    == _pRep->IsSimple() );
        Assert("Cursors must be active" &&
               (!_pRep->_pDataLayerCursor ||
                _pRep->_pDataLayerCursor->IsActive() ) );
        Assert("Refcounts must not underflow" &&
               (_pRep->_uRefCount != (unsigned long)-1l) );
    }
    return TRUE;
}


BOOL
CDataLayerBookmark::IsValidObject()
{
    super::IsValidObject();
    return TRUE;
}


char s_achCDataLayerBookmarkHelper[] = "CDataLayerBookmarkHelper";
char s_achCDataLayerBookmark[]       = "CDataLayerBookmark";

//+---------------------------------------------------------------------------
//
//  Member:     Dump
//
//  Synopsis:   Dump function, called by macro DUMP(p,dc)
//

void
CDataLayerBookmarkHelper::Dump(CDumpContext&)
{
    TraceTag((tagDataLayerBookmarkHelper, "CDataLayerBookmarkHelper::Dump(%p)",
              this ));

    IS_VALID(this);
}


void
CDataLayerBookmark::Dump(CDumpContext& dc)
{
    TraceTag((tagDataLayerBookmarkHelper, "CDataLayerBookmark::Dump(%p)",
              this ));

    super::Dump(dc);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
//  Synopsis:   GetClassName function. (virtual)
//

char *
CDataLayerBookmarkHelper::GetClassName()
{
    return s_achCDataLayerBookmarkHelper;
}


char *
CDataLayerBookmark::GetClassName()
{
    return s_achCDataLayerBookmark;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\wrappers\winspool.cxx ===
------DEADDEADDEAD------

This file is being removed, it should not be compiled. 
The class involved is no longer referenced.

------DEADDEADDEAD------

//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       winspool.cxx
//
//  Contents:   Wrappers for non-unicode winspool functions
//
//----------------------------------------------------------------------------

#include "precomp.hxx"

#ifndef DLOAD1

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WINSPOOL_H_
#define X_WINSPOOL_H_
#include "winspool.h"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifdef UNIX
DYNLIB g_dynlibWINSPOOL = { NULL, NULL, "MW32.DLL" };
#else
DYNLIB g_dynlibWINSPOOL = { NULL, NULL, "WINSPOOL.DRV" };
#endif 

#define WRAPIT_(type, fn, a1, a2)\
type WINAPI fn a1\
{\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibWINSPOOL, #fn };\
    if(THR(LoadProcedure(&s_dynproc##fn)))\
        return FALSE;\
    return ((*(type (APIENTRY *) a1)s_dynproc##fn.pfn) a2);\
}
#define WRAPIT(fn, a1, a2) WRAPIT_(BOOL, fn, a1, a2)

#define DOCINFO(x) (Level==1)?((DOC_INFO_1W *)pDocInfo)->x:((DOC_INFO_2W *)pDocInfo)->x
#define DOCINFO2(x) (Level==1)?0:((DOC_INFO_2W *)pDocInfo)->x
#define JOBINFO1W(x) ((JOB_INFO_1W *)pJob)->x
#define JOBINFO1A(x) ((JOB_INFO_1A *)pJobA)->x
#define COPY_JOBINFO1A_MEMBER(x)\
    if (JOBINFO1A(x))\
    {\
        strcpy((LPSTR) strOutString, JOBINFO1A(x));\
        JOBINFO1W(x) = pNextString;\
    }\
    else\
    {\
        JOBINFO1W(x) = NULL;\
    }
#define COPY_JOBINFO1W_MEMBER(x)\
    memcpy(((LPBYTE)pJobA)+cbTaken, x##A, x##A.strlen()+1);\
    JOBINFO1A(x) = ((LPBYTE)pJobA)+cbTaken;\
    cbTaken += x##A.strlen()+1;



WRAPIT(OpenPrinterA,
    (LPSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSA pDefault),
    (pPrinterName, phPrinter, pDefault));

BOOL WINAPI OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
)
{
    Assert(!pDefault && "Default parameter not supported in OpenPrinter wrapper.  See src\\core\\wrappers\\winspool.cxx");
    CStrIn strInPrinterName(pPrinterName);

    return OpenPrinterA(strInPrinterName, phPrinter, NULL);
}

WRAPIT(ClosePrinter, (HANDLE hPrinter), (hPrinter));

/* if we ever need a wrapper for SetPrinter (Level 0), uncomment this
WRAPIT(SetPrinterA,
    (HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command),
    (hPrinter, Level, pPrinter, Command));

BOOL WINAPI SetPrinterW(
   HANDLE hPrinter,
   DWORD Level,
   LPBYTE pPrinter,
   DWORD Command
)
{
    Assert(!Level && !pPrinter && "Only level 0 supported in SetPrinter wrapper.  See src\\core\\wrappers\\winspool.cxx");

    return SetPrinterA(hPrinter, 0, NULL, Command);
}
*/

WRAPIT_(DWORD, StartDocPrinterA,
    (HANDLE hPrinter, DWORD Level, LPBYTE pDocInfo),
    (hPrinter, Level, pDocInfo));

DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    if (!pDocInfo || Level < 1 || Level > 2)
    {
        return 0;
    }

    // Need to convert pDocInfo strings
    CStrIn strInDocName( DOCINFO(pDocName) );
    CStrIn strInOutputFile( DOCINFO(pOutputFile) );
    CStrIn strInDatatype( DOCINFO(pDatatype) );
    DOC_INFO_1A DocInfo1A = { strInDocName, strInOutputFile, strInDatatype };
    DOC_INFO_2A DocInfo2A = { strInDocName, strInOutputFile, strInDatatype, DOCINFO2(dwMode), DOCINFO2(JobId) };

    return StartDocPrinterA(hPrinter, Level, (Level==1) ? (LPBYTE)&DocInfo1A : (LPBYTE)&DocInfo2A );
}

WRAPIT(EndDocPrinter, (HANDLE hPrinter), (hPrinter));

WRAPIT(GetJobA,
    (HANDLE hPrinter, DWORD JobId, DWORD Level, LPBYTE pJob, DWORD cbBuf, LPDWORD pcbNeeded),
    (hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded));

BOOL
WINAPI
GetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
    // Allocate another buffer whose length matches the buffer passed in in non-unicode (byte) units.
    // That way we hope to simply propagate any buffer size errors in and out.
    DWORD cbBufA = cbBuf/sizeof(TCHAR) - sizeof(JOB_INFO_1W)/sizeof(TCHAR) + sizeof(JOB_INFO_1A);
    LPBYTE pJobA = (BYTE *)MemAlloc(Mt(Mem), cbBufA);
    DWORD cbNeededA;
    BOOL fResult = FALSE;

    Assert(Level == 1 && "GetJob wrapper only supports Level 1 in wrapper.  See src\\core\\wrappers\\winspool.cxx");
    Assert(pJob && pcbNeeded);

    if (!pJobA)
    {
        goto Cleanup;
    }

    fResult = GetJobA(hPrinter, JobId, Level, pJobA, cbBufA, &cbNeededA);

    if (!fResult)
    {
        goto Cleanup;
    }
    else
    {
        DWORD cbTaken = sizeof(JOB_INFO_1W);
        LONG index;

        // Copy the JOBINFO structure.
        memcpy(pJob, pJobA, sizeof(JOB_INFO_1W));

        // Copy and convert all output strings.
        for ( index = 1 ; index <= 6 ; index++ )
        {
            LPWSTR pNextString = (LPWSTR)pJob + cbTaken;
            {
                CStrOut strOutString(pNextString, cbBuf - cbTaken);

                switch (index)
                {
                case 1:
                    COPY_JOBINFO1A_MEMBER(pPrinterName)
                    break;
                case 2:
                    COPY_JOBINFO1A_MEMBER(pMachineName)
                    break;
                case 3:
                    COPY_JOBINFO1A_MEMBER(pUserName)
                    break;
                case 4:
                    COPY_JOBINFO1A_MEMBER(pDocument)
                    break;
                case 5:
                    COPY_JOBINFO1A_MEMBER(pDatatype)
                    break;
                case 6:
                    COPY_JOBINFO1A_MEMBER(pStatus)
                    break;
                }

                cbTaken += strOutString.ConvertIncludingNul();
            }
        }
    }

    // Convert pcbNeeded back to unicode units.
    *pcbNeeded = cbNeededA*sizeof(TCHAR) - sizeof(JOB_INFO_1A)*sizeof(TCHAR) + sizeof(JOB_INFO_1W);

Cleanup:

    if (pJobA)
    {
        MemFree(pJobA);
    }

    return fResult;
}


WRAPIT(SetJobA, (HANDLE hPrinter, DWORD JobId, DWORD Level, LPBYTE Job, DWORD Command), (hPrinter, JobId, Level, Job, Command));

BOOL
WINAPI
SetJobW(
    HANDLE hPrinter,
    DWORD JobId,
    DWORD Level,
    LPBYTE Job,
    DWORD Command)
{
    Assert(Level == 0 && Job == NULL && "SetJob wrapper only supports Level 0 in wrapper.  See src\\core\\wrappers\\winspool.cxx");

    return SetJobA(hPrinter, JobId, 0, NULL, Command);

/* If we ever need SetJob at level 1, we can use this code:
    else if (Level == 1)
    {
        LPBYTE pJob = Job;
        CStrIn pPrinterNameA(JOBINFO1W(pPrinterName));
        CStrIn pMachineNameA(JOBINFO1W(pMachineName));
        CStrIn pUserNameA(JOBINFO1W(pUserName));
        CStrIn pDocumentA(JOBINFO1W(pDocument));
        CStrIn pDatatypeA(JOBINFO1W(pDatatype));
        CStrIn pStatusA(JOBINFO1W(pStatus));
        BYTE   pJobA[sizeof(JOB_INFO_1A) + 6*MAX_PATH];
        DWORD  cbTaken = sizeof(JOB_INFO_1A);
        LONG   index;

        Assert(Job);

        memcpy(pJobA, pJob, sizeof(JOB_INFO_1A));

        // Copy and convert all output strings.
        for ( index = 1 ; index <= 6 ; index++ )
        {
            switch (index)
            {
            case 1:
                COPY_JOBINFO1W_MEMBER(pPrinterName)
                break;
            case 2:
                COPY_JOBINFO1W_MEMBER(pMachineName)
                break;
            case 3:
                COPY_JOBINFO1W_MEMBER(pUserName)
                break;
            case 4:
                COPY_JOBINFO1W_MEMBER(pDocument)
                break;
            case 5:
                COPY_JOBINFO1W_MEMBER(pDatatype)
                break;
            case 6:
                COPY_JOBINFO1W_MEMBER(pStatus)
                break;
            }
        }

        return SetJobA(hPrinter, JobId, 1, pJobA, Command);
    }
    */
}


WRAPIT_(LONG, DocumentPropertiesA,
    (HWND hWnd, HANDLE hPrinter, LPSTR pDeviceName, PDEVMODEA pDevModeOutput, PDEVMODEA pDevModeInput, DWORD fMode),
    (hWnd, hPrinter, pDeviceName, pDevModeOutput, pDevModeInput, fMode));

LONG
WINAPI
DocumentPropertiesW(
    HWND hWnd,
    HANDLE hPrinter,
    LPWSTR pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput,
    DWORD fMode)
{
    CStrIn strInDeviceName(pDeviceName);

    // IMPORTANT: We are not converting the DEVMODE structure back and forth
    // from ASCII to Unicode on Win95 anymore because we are not touching the
    // two strings or any other member.  Converting the DEVMODE structure can
    // be tricky because of potential and common discrepancies between the
    // value of the dmSize member and sizeof(DEVMODE).  (25155)

    // Since we are not converting the DEVMODE structure back and forth, we can
    // simply forward the call to DocumentPropertiesA.  Note that both pDevModeOutput
    // and pDevModeInput (if not NULL) have to point to DEVMODEA buffers.

    return DocumentPropertiesA(hWnd, hPrinter, strInDeviceName, (PDEVMODEA) pDevModeOutput, (PDEVMODEA) pDevModeInput, fMode);

    // We do this instead of converting as follows (left here in case we ever have to go back):
    /*
    LONG lReturn;

    // Different semantics depending on value of fMode.
    switch (fMode)
    {
    case DM_OUT_BUFFER:
    {
        CStrOut strOutDeviceName(&(pDevModeOutput->dmDeviceName[0]), CCHDEVICENAME);
        CStrOut strOutFormName(&(pDevModeOutput->dmFormName[0]), CCHFORMNAME);
        LONG lSize = DocumentPropertiesA(0, hPrinter, strInDeviceName, NULL, NULL, 0);
        HGLOBAL hDevModeAOutput = (lSize>0)?GlobalAlloc(GHND, lSize):0;
        DEVMODEA *pDevModeAOutput;

        Assert(!pDevModeInput && "pDevModeInput parameter not supported in DocumentProperties wrapper.  See src\\core\\wrappers\\winspool.cxx.");

        if (hDevModeAOutput)
        {
            pDevModeAOutput = (LPDEVMODEA) GlobalLock(hDevModeAOutput);

            if (pDevModeAOutput)
            {
                lReturn = DocumentPropertiesA(hWnd, hPrinter, strInDeviceName, pDevModeAOutput, NULL, fMode);

                // Copy portion between the two strings.
                memcpy(&(pDevModeOutput->dmSpecVersion), &(pDevModeAOutput->dmSpecVersion), ((BYTE *)&(pDevModeAOutput->dmFormName)) - ((BYTE *)&(pDevModeAOutput->dmSpecVersion)));

                // Adjust dmSize member for wide-character strings.
                pDevModeOutput->dmSize = pDevModeAOutput->dmSize + CCHDEVICENAME + CCHFORMNAME;

                // Copy portion following the second string, including the driver specific stuff following the
                // allocation of the DEVMODEA structure.
                memcpy(&(pDevModeOutput->dmLogPixels), &(pDevModeAOutput->dmLogPixels), ((BYTE *)pDevModeAOutput) + sizeof(DEVMODEA) - ((BYTE *)&(pDevModeAOutput->dmLogPixels)) + pDevModeAOutput->dmDriverExtra);

                // Copy the two strings (the cause of this headache).

                strcpy((LPSTR) strOutDeviceName, (const char *) &(pDevModeAOutput->dmDeviceName[0]));
                strOutDeviceName.ConvertIncludingNul();

                strcpy((LPSTR) strOutFormName, (const char *) &(pDevModeAOutput->dmFormName[0]));
                strOutFormName.ConvertIncludingNul();

                GlobalUnlock(hDevModeAOutput);
            }

            GlobalFree(hDevModeAOutput);
        }
    }
        break;

    case 0:
    {
        // Obtain size of DEVMODE structure.
        lReturn = DocumentPropertiesA(hWnd, hPrinter, strInDeviceName, NULL, NULL, 0);

        // Since we don't convert the DEVMODE structure back and forth (see IMPORTANT statement
        // above), the size of the structure doesn't increase, and we don't have to
        // add additional space needed by DEVMODEW:
        // lReturn += (lReturn>0)?(CCHDEVICENAME + CCHFORMNAME):0;
    }
        break;

    default:

        lReturn = -1;

        Assert(!"Given fMode not supported in DocumentProperties wrapper.  See src\\core\\wrappers\\winspool.cxx.");
    }

    return lReturn;
    */
}

WRAPIT(GetPrinterDriverA,
    (HANDLE hPrinter, LPSTR pEnvironment, DWORD Level, LPBYTE pDriverInfo, DWORD cbBuf, LPDWORD pcbNeeded),
    (hPrinter, pEnvironment, Level, pDriverInfo, cbBuf, pcbNeeded));


#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\dl\dbllink.cxx ===
//-----------------------------------------------------------------------------
//
// Handy-Dandy doubly linked list package.
//
// Created by tedsmith
//
// See comments in dbllink.hxx  (this stuff is boring anyway)

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DBLLINK_HXX_
#define X_DBLLINK_HXX_
#include "dbllink.hxx"
#endif

void
CDblLinkedListBase::Remove(Node *pNode)
{
    Assert("Node must exist in Linked list" &&
           (pNode && !IsAnchor(pNode) && Contains(pNode)) );

    pNode->_pNext->_pPrev = pNode->_pPrev;
    pNode->_pPrev->_pNext = pNode->_pNext;
#if DBG == 1
    pNode->_pPrev = pNode->_pNext = NULL;
#endif
}


void
CDblLinkedListBase::InsertAfter(Node *pPosition, Node *pNewNode)
{
    Assert("A node can only be in one TIntrusive... at a time" &&
           (!pNewNode->_pPrev && !pNewNode->_pNext) );
    Assert("Node must exist in Linked list" &&
           (pPosition && Contains(pPosition)) );

    pNewNode->_pNext = pPosition->_pNext;
    pNewNode->_pPrev = pPosition;
    pPosition->_pNext->_pPrev = pNewNode;
    pPosition->_pNext = pNewNode;
}


void
CDblLinkedListBase::InsertBefore(Node *pPosition, Node *pNewNode)
{
    Assert("A node can only be in one TIntrusive... at a time" &&
           (!pNewNode->_pPrev && !pNewNode->_pNext) );
    Assert("Node must exist in Linked list" &&
           (pPosition && Contains(pPosition)) );

    pNewNode->_pNext = pPosition;
    pNewNode->_pPrev = pPosition->_pPrev;
    pPosition->_pPrev->_pNext = pNewNode;
    pPosition->_pPrev = pNewNode;
}


#if DBG == 1
BOOL
CDblLinkedListBase::Contains(const Node *pNode) const
{
    CALL_ISVALIDOBJECT(this);

    // We must implement this routine without using our abstract access
    //   routines since it is used to validate the arguments of those routines.
    const Node *pCur;
    for (pCur = &_Anchor; pCur != pNode; pCur = pCur->_pNext)
    {
        if (pCur == _Anchor._pPrev)
        {
            pCur = NULL;
            break;
        }
    }
    return !!pCur;
}


void
CDblLinkedListBase::IsValidObject() const
{
    const Node *pCur = &_Anchor;
    do
    {
        Assert(pCur->_pPrev);
        Assert(pCur->_pNext);
        Assert(pCur->_pPrev->_pNext == pCur);
        Assert(pCur->_pNext->_pPrev == pCur);
        pCur = pCur->_pNext;
    }
    while (!IsAnchor(pCur));
}


void
CDblLinkedListBaseIterator::IsValidObject() const
{
    Assert("A list must be associated with this Iterator" &&
           (_pList) );
    _pList->IsValidObject();
    Assert("Node must exist in Linked list" &&
           (!_pNode || _pList->Contains(_pNode)) );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\async.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stdevent.cxx
//  Author:     Charles Frankston (cfranks)
//
//  Contents:   IRowsetAsynch methods
//

//
//
#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

//+-----------------------------------------------------------------------
//
//  Member:    GetStatus (IDBAsynchStatus public member)
//
//  Synopsis:  Returns the fraction of an async rowset currently populated.
//             Since we don't know what portion of an async rowset remains
//             to be populated, we use a gross approximation:
//                - if the rowset is still being populated, return 1/2
//                - if the rowset is done, return count/count, or 1
//
//  Returns:   S_OK             all OK.
//

STDMETHODIMP
CImpIRowset::GetStatus(HCHAPTER hChapter, DBASYNCHOP ulOperation,
                       DBCOUNTITEM *pulProgress, DBCOUNTITEM *pulProgressMax,
                       DBASYNCHPHASE *pulStatusCode, LPOLESTR *ppwszStatusText)
{
    HRESULT hr = S_OK;
    DBCOUNTITEM lProgressDummy, lProgressMaxDummy;
    DBASYNCHPHASE lStatusCodeDummy;
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if (ppwszStatusText)
        *ppwszStatusText = NULL;            // We don't support status text

    if (!pulProgress) pulProgress = &lProgressDummy;
    if (!pulProgressMax) pulProgressMax = &lProgressMaxDummy;
    if (!pulStatusCode) pulStatusCode = &lStatusCodeDummy;

    if (!pOSPData->_fPopulationComplete)
    {
        *pulStatusCode = DBASYNCHPHASE_POPULATION;
        *pulProgress = pOSPData->_cSTDRows;
        hr = GetpOSP(hChapter)->getEstimatedRows((DBROWCOUNT *)pulProgressMax);
        if (FAILED(hr) || *pulProgressMax==0)
            *pulProgressMax = 2 * pOSPData->_cSTDRows;    // Arbitrary
    }
    else
    {
        *pulProgress = pOSPData->_cSTDRows;
        // pulProgressMax might be used as the denominator of a ratio.
        // Best it never be zero..
        *pulProgressMax = *pulProgress ? *pulProgress : 1;
        *pulStatusCode = DBASYNCHPHASE_COMPLETE;
    }

Cleanup:
    return hr;
}
        
//+-----------------------------------------------------------------------
//
//  Member:    Abort (IDBAsynchStatus public member)
//
//  Synopsis:  Stops any asynch data transfer that may be in progress
//
//  Returns:   S_OK if the STD returned success
//             E_FAIL if not.
//
STDMETHODIMP
CImpIRowset::Abort(HCHAPTER	hChapter,
                   ULONG     ulOperation)
{
    HRESULT hr;

    if (GetpOSPData(hChapter) == NULL)
        hr = DB_E_BADCHAPTER;
    else if (SUCCEEDED(GetpOSP(hChapter)->stopTransfer()))
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\dl\dlcursor.cxx ===
//+-----------------------------------------------------------------------------
//
//  Maintained by: Jerry, Terry and Ted
//
//  Microsoft DataDocs
//  Copyright (C) Microsoft Corporation, 1994-1995
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  File:       ddoc\dl\dlcursor.cxx
//
//  Contents:   Data Layer cursor object
//
//  Classes:    CDataLayerCursor
//
//  Functions:  None.
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DLCURSOR_HXX_
#define X_DLCURSOR_HXX_
#include "dlcursor.hxx"
#endif

DeclareTag(tagDataLayerCursor, "DataLayerCursor",
           "Nile (OLE DB) cursor helper class" );

MtDefine(CDataLayerBookmark, DataBind, "CDataLayerBookmark")
MtDefine(CDataLayerCursor, DataBind, "CDataLayerCursor")
MtDefine(CDataLayerCursor_adlColInfo, CDataLayerCursor, "CDataLayerCursor::_adlColInfo")
MtDefine(CDataLayerCursorDeleteRows_aRowStatus, DataBind, "CDataLayerCursor::DeleteRows aRowStatus")

//+-----------------------------------------------------------------------------
//
//  Default Constructor
//
CDataLayerCursor::CDataLayerCursor(CDataLayerCursorEvents *pDLCEvents) :
    _DLNotify(pDLCEvents, GetCurrentThreadId()),
    _ulRefs(1),
    _ulAllRefs(1),
    _pAccessor(NULL),
    _pColumnsInfo(NULL),
    _pRowsetChange(NULL),
    _pRowsetExactScroll(NULL),
    _pRowsetLocate(NULL),
    _pRowsetNewRowAfter(NULL),
    _pRowsetFind(NULL),
    _pRowsetIdentity(NULL),
    _pChapteredRowset(NULL),
    _pRowsetChapterMember(NULL),
    _pcpRowsetNotify(NULL),
    _pcpDBAsynchNotify(NULL),
    _wAdviseCookieRowsetNotify(0),
    _wAdviseCookieDBAsynchNotify(0),
    _cColumns(0),
    _adlColInfo(NULL),
    _cStrBlk(NULL),
    _hBookmarkAccessor(NULL),
    _pRowsetUpdate(NULL),
    _pRowsetScroll(NULL),
    _pSupportErrorInfo(NULL),
    _hNullAccessor(NULL),
    _rcCapabilities(0),
    _uChapterSize(~0ul),
    _fNewRowsSinceLastAsynchRatioFinishedCall(FALSE),
    _fFixedSizedBookmark(FALSE),
    _fDeleteAllInProgress(FALSE)
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::constructor() -> %p", this ));
}




#if DBG == 1
//+-----------------------------------------------------------------------------
//
//  Destructor
//
CDataLayerCursor::~CDataLayerCursor()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::destructor(%p)", this));

    Assert("Passivate wasn't called before destructor" &&
           (!_pColumnsInfo      && !_pRowsetChange      &&
            !_pRowsetExactScroll &&
            !_pRowsetLocate     && !_pRowsetNewRowAfter &&
            !_pRowsetFind       && !_pRowsetIdentity    &&
            !_pcpRowsetNotify               &&  !_pcpDBAsynchNotify        && 
            !_wAdviseCookieRowsetNotify    && !_wAdviseCookieDBAsynchNotify &&
            !_rcCapabilities     && !_pAccessor ) );
}
#endif



//+-------------------------------------------------------------------------
// Member:      AddRef (public, IUnknown)
//
// Synopsis:    increase refcount
//
// Returns:     new refcount

ULONG
CDataLayerCursor::AddRef()
{
    ULONG ulRefs = ++_ulRefs;
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, passivate if 0
//
// Returns:     new refcount

ULONG
CDataLayerCursor::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        Passivate();
        SubRelease();
    }
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      SubAddRef
//
// Synopsis:    increase sub-refcount
//
// Returns:     new sub-refcount

ULONG
CDataLayerCursor::SubAddRef()
{
    ULONG ulAllRefs = ++_ulAllRefs;
    return ulAllRefs;
}


//+-------------------------------------------------------------------------
// Member:      SubRelease
//
// Synopsis:    decrease sub-refcount, die if 0
//
// Returns:     new refcount

ULONG
CDataLayerCursor::SubRelease()
{
    ULONG ulAllRefs = --_ulAllRefs;
    if (ulAllRefs == 0)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }
    return ulAllRefs;
}



//+-----------------------------------------------------------------------------
//
//  Passivate - Cleanup and go back to the pre-Init state
//
void
CDataLayerCursor::Passivate()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Passivate(%p)", this));

    if (_pRowsetLocate)
    {
        IS_VALID(this);


        // Stop getting notifications:
        if (_wAdviseCookieRowsetNotify)
        {
            _pcpRowsetNotify->Unadvise(_wAdviseCookieRowsetNotify);
            _wAdviseCookieRowsetNotify = 0;
        }

        // Stop getting notifications:
        if (_wAdviseCookieDBAsynchNotify)
        {
            _pcpDBAsynchNotify->Unadvise(_wAdviseCookieDBAsynchNotify);
            _wAdviseCookieDBAsynchNotify = 0;
        }

        if (_hChapter && _pChapteredRowset)
        {
            DL_THR(ChapteredRowset, ReleaseChapter(_hChapter, NULL) );
        }

        ReleaseAccessor(_hNullAccessor);
        ReleaseAccessor(_hBookmarkAccessor);
        if (_adlColInfo)
        {
            delete [] _adlColInfo;
            _adlColInfo = NULL;
        }
        if (_cStrBlk)
        {
            CoTaskMemFree(_cStrBlk);
            _cStrBlk = NULL;
        }
        _cColumns = 0;
        ClearInterface(&_pRowsetChapterMember);
        ClearInterface(&_pChapteredRowset);
        ClearInterface(&_pRowsetIdentity);
        ClearInterface(&_pRowsetFind);
        ClearInterface(&_pRowsetNewRowAfter);
        ClearInterface(&_pRowsetExactScroll);
        ClearInterface(&_pRowsetChange);
        ClearInterface(&_pAccessor);
        ClearInterface(&_pColumnsInfo);
        ClearInterface(&_pRowsetUpdate);
        ClearInterface(&_pRowsetScroll);
        ClearInterface(&_pAsynchStatus);
        ClearInterface(&_pSupportErrorInfo);
        ClearInterface(&_pcpRowsetNotify);
        ClearInterface(&_pcpDBAsynchNotify);
        _rcCapabilities = 0;
        _fNewRowsSinceLastAsynchRatioFinishedCall = FALSE;
        _fFixedSizedBookmark = FALSE;
        _fDeleteAllInProgress = FALSE;
        ClearInterface(&_pRowsetLocate);
    }
}


//+-----------------------------------------------------------------------------
//
//  CDataLayerCursor Init method
//
HRESULT
CDataLayerCursor::Init(IUnknown *pUnkRowset, HCHAPTER hChapter, DWORD dwFlags)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Init(%p, %p)",
              this, pUnkRowset ));

    HRESULT hr;

    Assert("Passivate wasn't called before Init" &&
           (!_pRowsetChange      &&
            !_pRowsetExactScroll &&
            !_pRowsetLocate     && !_pRowsetNewRowAfter &&
            !_pRowsetFind       && !_pRowsetIdentity    &&
            !_pcpRowsetNotify               && !_wAdviseCookieRowsetNotify  &&
            !_rcCapabilities    && !_pAccessor &&
            !_pcpDBAsynchNotify           && !_wAdviseCookieDBAsynchNotify) );

    Assert("We must be passed a valid pUnkRowset" && pUnkRowset);

    _hChapter = hChapter;
    
    // we just gotta have an IRowsetLocate to get started
    hr = pUnkRowset->QueryInterface(IID_IRowsetLocate,
                                              (void **)&_pRowsetLocate);
    if (hr)
        goto Error;
    
    // look for pSupportErrorIno before anything else, so that all
    // other start up processing can feedback rich errors, if supported
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_ISupportErrorInfo,
                                              (void **)&_pSupportErrorInfo));

    if (dwFlags & DLC_SinkNotifications)
    {
        IConnectionPointContainer *pCPC = NULL;
        
        THR_NOTRACE(pUnkRowset->QueryInterface(IID_IConnectionPointContainer,
                                                  (void **)&pCPC));
        if (pCPC)
        {
            THR_NOTRACE(pCPC->FindConnectionPoint(IID_IRowsetNotify, &_pcpRowsetNotify));
            if (_pcpRowsetNotify)
            {
                THR_NOTRACE(_pcpRowsetNotify->Advise((IRowsetNotify *)&_DLNotify, &_wAdviseCookieRowsetNotify));
            }

            THR_NOTRACE(pCPC->FindConnectionPoint(IID_IDBAsynchNotify, &_pcpDBAsynchNotify));
            if (_pcpDBAsynchNotify)
            {
                THR_NOTRACE(_pcpDBAsynchNotify->Advise((IDBAsynchNotify *)&_DLNotify, &_wAdviseCookieDBAsynchNotify));
            }

            ClearInterface(&pCPC);
        }
    }

    _fFilterNotificationsToChapter = !!(dwFlags & DLC_FilterNotificationsToChapter);

    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetChange,
                                              (void **)&_pRowsetChange));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetExactScroll,
                                              (void **)&_pRowsetExactScroll));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetNewRowAfter,
                                              (void **)&_pRowsetNewRowAfter));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetFind,
                                              (void **)&_pRowsetFind));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetUpdate,
                                              (void **)&_pRowsetUpdate));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetScroll,
                                              (void **)&_pRowsetScroll));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IDBAsynchStatus,
                                              (void **)&_pAsynchStatus));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IChapteredRowset,
                                              (void **)&_pChapteredRowset));
    THR_NOTRACE(pUnkRowset->QueryInterface(IID_IRowsetChapterMember,
                                              (void **)&_pRowsetChapterMember));

    if (_hChapter && _pChapteredRowset)
    {
        DL_THR(ChapteredRowset, AddRefChapter(_hChapter, NULL) );
    }

    if (_pRowsetExactScroll)
    {
        _rcCapabilities |= RCOrdinalIndex;
    }
    if (_pRowsetScroll)
    {
        _rcCapabilities |= RCScrollable;
    }
    
    if (_pAsynchStatus)
    {
        DBCOUNTITEM ulProgress, ulProgressMax;
        DBASYNCHPHASE ulStatusCode;
        
        _rcCapabilities |= RCAsynchronous;
        _pAsynchStatus->GetStatus(_hChapter, DBASYNCHOP_OPEN,
                                 &ulProgress, &ulProgressMax,
                                 &ulStatusCode, NULL);
        _fComplete = (ulStatusCode == DBASYNCHPHASE_COMPLETE);
    }
    else
    {
        _fComplete = TRUE;
    }

    hr = FetchRowsetIdentity();
    if (hr)
        goto Error;

    hr = DL_THR(RowsetLocate, QueryInterface(IID_IAccessor,
                                       (void **)&_pAccessor ) );
    if (hr)
    {
        goto Error;
    }

    CacheColumnInfo(_pRowsetLocate);

    
Cleanup:
    RRETURN(hr);

Error:
    Assert(hr);
    Passivate();
    goto Cleanup;
}

HRESULT
CDataLayerCursor::CacheColumnInfo(IUnknown *RowsetLocate)
{
    HRESULT hr;
    DBCOLUMNINFO *aColInfoTemp = NULL;

    if (!_pColumnsInfo)
    {
        hr = DL_THR(RowsetLocate, QueryInterface(IID_IColumnsInfo,
                                               (void **)&_pColumnsInfo ) );
        if (hr)
        {
            goto Cleanup;
        }
    }

    // CacheColumnInfo should only be called once per rowset.
    Assert(!_cStrBlk && !_adlColInfo);

    hr = DL_THR(ColumnsInfo, GetColumnInfo(&_cColumns, &aColInfoTemp, &_cStrBlk));
    if (hr)
    {
        goto Cleanup;
    }

    // Allocate cache:
    _adlColInfo = new(Mt(CDataLayerCursor_adlColInfo)) ColumnInfo[_cColumns];
    if (!_adlColInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        DBCOLUMNINFO *pInfoTempIndex;
        ColumnInfo *pInfoIndex;
        ULONG i;

        for (i = 0, pInfoTempIndex = aColInfoTemp, pInfoIndex = _adlColInfo;
             i < _cColumns;
             i++, pInfoTempIndex++, pInfoIndex++ )
        {
            pInfoIndex->pwszName    = pInfoTempIndex->pwszName;
            pInfoIndex->iNumber     = pInfoTempIndex->iOrdinal;
            pInfoIndex->dwFlags     = pInfoTempIndex->dwFlags;
            pInfoIndex->dwType      = pInfoTempIndex->wType;
            pInfoIndex->cbMaxLength = pInfoTempIndex->ulColumnSize;
        }
    }

    _uChapterSize = ~0ul; // We don't know anything about the size.

    Assert(hr == S_OK);

Cleanup:
    // Deallocate temp column info and string buffer:
    if (aColInfoTemp) CoTaskMemFree(aColInfoTemp);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  FetchRowsetIdentity (private method, called by Init())
//      See whether the provider allows bitwise comparison of HROWs.
//      If not, fetch _pRowsetIdentity interface pointer.
//
//  Params:  none
//
//  Returns: S_OK if everything was fine

HRESULT
CDataLayerCursor::FetchRowsetIdentity()
//  Only fetch _pRowsetIdentity if required by provider.
{
    Assert(_pRowsetLocate && "must have valid IRowsetLocate");

    HRESULT hr = S_OK;
    IRowsetInfo *pRowsetInfo;
    const int kRowset=0;            // index into aPropIDSets
    DBPROPIDSET aPropIDSets[kRowset + 1];
    const int kLiteralIdentity=0;   // indexes into aPropertyIDs
    const int kStrongIdentity=1;
    DBPROPID aPropertyIDs[kStrongIdentity + 1];
    ULONG cPropSets=0;
    DBPROPSET *aPropSets = NULL;
    DBPROP *pLiteralIdentity, *pStrongIdentity;
    BOOL bBitCompareOK = TRUE;  // does provider approve comparing HROWs bitwise?
    // NOTE defaulting to TRUE even if properties are unsupported?
    
    if (THR(_pRowsetLocate->QueryInterface(IID_IRowsetInfo,
                                        (void **)&pRowsetInfo)))
    {
        // Assume true identity
        goto Cleanup;
    }

    // prepare query to IRowsetInfo::GetProperties
    aPropIDSets[kRowset].rgPropertyIDs = aPropertyIDs;
    aPropIDSets[kRowset].cPropertyIDs = ARRAY_SIZE(aPropertyIDs);
    aPropIDSets[kRowset].guidPropertySet = DBPROPSET_ROWSET;
    aPropertyIDs[kLiteralIdentity] = DBPROP_LITERALIDENTITY;
    aPropertyIDs[kStrongIdentity] = DBPROP_STRONGIDENTITY;

    hr = THR(HandleError(IID_IRowsetInfo, pRowsetInfo->GetProperties(
                                        ARRAY_SIZE(aPropIDSets), aPropIDSets,
                                        &cPropSets, &aPropSets ) ) );
    ClearInterface(&pRowsetInfo);
    if (hr)
    {
        goto Cleanup;
    }

    // see if rowset lets us compare HROWS bitwise
    pLiteralIdentity = & aPropSets[kRowset].rgProperties[kLiteralIdentity];
    pStrongIdentity = & aPropSets[kRowset].rgProperties[kStrongIdentity];

    if (pLiteralIdentity->dwStatus == DBPROPSTATUS_OK &&
        V_BOOL(&pLiteralIdentity->vValue) == VARIANT_FALSE)
    {
        bBitCompareOK = FALSE;
    }

    if (! bBitCompareOK)
    {
        hr = DL_THR(RowsetLocate, QueryInterface(IID_IRowsetIdentity,
                                        (void **) &_pRowsetIdentity ) );
        if (hr == E_NOINTERFACE)
            hr = S_OK;          // degrade to comparing HROWs directly
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // release memory returned by query
    if (cPropSets > 0)
    {
        ULONG iPropSet;
        for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
            CoTaskMemFree(aPropSets[iPropSet].rgProperties);
        CoTaskMemFree(aPropSets);
    }

    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  NewRowAfter - Inserts a new HROW in a given Chapter at position just after
//                Bookmark, the row will have no data in it and must be filled
//                in before Update is called
//
//  Params:  rdlb  Reference to Bookmark to add row just after
//           pHRow Pointer to HROW to receive new (ref-counted) row or
//                 NULL iff no record is needed just now of that row.
//
//  Returns: S_OK if everything was fine
//           E_...  error in standard OLE range on actual error
//           if no records could be returned, then *pHRow filled in with NULL
//
HRESULT
CDataLayerCursor::NewRowAfter(const CDataLayerBookmark &rdlb, HROW *pHRow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::NewRowAfter(%p, %p)",
              this, &rdlb ));

    IS_VALID(this);

    HROW hRow = NULL;
    HRESULT hr = S_OK;

    if (!_hNullAccessor)
    {
        hr = THR(CreateAccessor(_hNullAccessor,
                                DBACCESSOR_ROWDATA,
                                NULL, 0 ));
        if (hr)
        {
            goto Cleanup;
        }
    }

    Assert(_hNullAccessor);

    if (_pRowsetNewRowAfter)
    {
        ULONG cbBookmark = 0; 
        const BYTE* pBookmark = NULL;   // to keep compiler happy

        // caller sends us DBBMK_FIRST to insert a new "first" row.
        // In this case, we give IRowsetNewRowAfter::SetNewDataAfter
        // what it wants for this situation, namely a bookmark of length 0
        if (!rdlb.IsDBBMK_FIRST())
        {
            cbBookmark = rdlb.getDataSize();
            pBookmark = rdlb.getDataPointer();
        }

        hr = DL_THR(RowsetNewRowAfter, SetNewDataAfter(
            _hChapter,
            cbBookmark, pBookmark,
            _hNullAccessor, NULL, &hRow ));
        hr = ClampITFResult(hr);
    }
    else
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        IGNORE_HR(_DLNotify.OnRowChange(_pRowsetLocate, 1, &hRow,
                                DBREASON_ROW_INSERT, DBEVENTPHASE_DIDEVENT,
                                TRUE));
    }

Cleanup:
    if (pHRow)
    {
        *pHRow = hr ? NULL : hRow;
    }
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  GetRowAt - Retrieves the specified HROW in a given Chapter
//
//  Params:  rdlb  Reference to Bookmark to start fetching at
//
//  Returns: S_OK if everything was fine
//           S_FALSE if no record could be returned for "normal" reasons
//           E_...  error in standard OLE range on actual error
//           if no records could be returned, then *pHRow filled in with NULL
//
HRESULT
CDataLayerCursor::GetRowAt(const CDataLayerBookmark &rdlb, HROW *pHRow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetRowAt(%p, %p)",
              this, &rdlb ));

    IS_VALID(this);
    HRESULT hr;
    DBCOUNTITEM cRows;

    hr = GetRowsAt(rdlb, 0, 1, &cRows, pHRow);
    if (!cRows)
    {
        *pHRow = NULL;
    }

    RRETURN2(hr, S_FALSE, DB_S_BOOKMARKSKIPPED);
}


//+-----------------------------------------------------------------------------
//
//  GetRowsAt - Retrieves the next set of HROW's in a given Chapter.
//
//  Params:  rdlb           Reference to Bookmark to start fetching at
//           iOffset        Offset from rdlb to the first row to fetch
//           iRows          number of rows to fetch, signed, < 0 to go backwards
//           puFetchedRows  pointer to return the number of rows fetched
//           pHRows         caller allocated array of HROW's for result
//
//  Returns: S_OK -- everything OK
//           S_FALSE -- not all records retrieved (possibly 0), but no error
//           DB_S_BOOKMARKSKIPPED iff rdlb refers to a deleted hrow
//           DB_S_ENDOFROWSET if our fetch went past end of rowset
//           E_...  "standard" error code (no other OLE DB errors propagated)
//
//  Comments: We have to be carefull to return the new rows which have been
//            added to the cursor but not commited, iff this cursor doesn't do
//            this for us.
//
HRESULT
CDataLayerCursor::GetRowsAt(const  CDataLayerBookmark &rdlb,
                            DBROWOFFSET iOffset,
                            DBROWCOUNT  iRows,
                            DBCOUNTITEM *puFetchedRows,
                            HROW  *pHRows )
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetRowsAt(%p, %p, %i, %u)",
              this, &rdlb, iOffset, iRows ));

    IS_VALID(this);
    Assert(!rdlb.IsNull());
    Assert(puFetchedRows);
    Assert(pHRows);

    *puFetchedRows = 0;

    HRESULT     hr              = S_OK;
    const BYTE *pbBookmarkData  = rdlb.getDataPointer();
    size_t      uBookmarkSize   = rdlb.getDataSize();
    
    hr = DL_THR(RowsetLocate, GetRowsAt(DBWATCHREGION_NULL,
            _hChapter, uBookmarkSize, pbBookmarkData,
            iOffset, iRows, puFetchedRows, &pHRows ));

    RRETURN2(hr, DB_S_ENDOFROWSET, DB_S_BOOKMARKSKIPPED);
}


//+-----------------------------------------------------------------------------
//
//  DeleteRows - Deletes the given hRows
//
//  Params:  uRows   of rows to delete
//           pHRows  array of hRows to delete
//
HRESULT
CDataLayerCursor::DeleteRows(size_t uRows, HROW *pHRows)
{
    HRESULT hr;
    HCHAPTER hcDummy = 0;       // reserved arg for DeleteRows
    DBROWSTATUS *aRowStatus = new(Mt(CDataLayerCursorDeleteRows_aRowStatus)) DBROWSTATUS[uRows];

    if (aRowStatus == 0) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        hr = THR(_DLNotify.OnRowChange(_pRowsetLocate, uRows, pHRows,
                             DBREASON_ROW_DELETE, DBEVENTPHASE_ABOUTTODO,
                             FALSE ));
        if (FAILED(hr) || hr == S_FALSE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        Assert(!hr);    // AndrewL 5/96 Why do we allow success codes other than S_FALSE?
    }


    hr = DL_THR(RowsetChange, DeleteRows(hcDummy, uRows, pHRows, aRowStatus));

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        // TODO: Handle partial success correctly
        Assert(hr != DB_S_ERRORSOCCURRED);
        IGNORE_HR(_DLNotify.OnRowChange(_pRowsetLocate, uRows, pHRows,
                              DBREASON_ROW_DELETE,
                              (hr == S_OK ? DBEVENTPHASE_FAILEDTODO
                                                : DBEVENTPHASE_DIDEVENT ),
                              TRUE ));
    }


Cleanup:
    delete [] aRowStatus;
    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  GetData - reads data from an HROW using the specifed accessor
//
//  Params:  hRow       the row to read from
//           hAccessor  the accessor handle to use
//           pData      caller allocated databuffer (buffer MUST be big enough)
//           fOriginal  callers wants unmodified data
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::GetData(HROW hRow, HACCESSOR hAccessor, void *pData,
                          BOOL fOriginal)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetData(%p)", this));

    IS_VALID(this);

    if (fOriginal && _pRowsetUpdate)
    {
        return DL_THR(RowsetUpdate, GetOriginalData(hRow, hAccessor,
                                                    (BYTE *)pData ) ); 
    }
    else
    {
        return DL_THR(RowsetLocate, GetData(hRow, hAccessor,
                                            (BYTE *)pData ) );
    }
}




//+-----------------------------------------------------------------------------
//
//  SetData - set data from an HROW using the specifed accessor
//
//  Params:  hRow      the row to set
//           hAccessor the accessor handle to use
//           pData     caller allocated databuffer (buffer MUST be big enough)
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::SetData(HROW hRow, HACCESSOR hAccessor, void *pData)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::SetData(%p)", this));

    IS_VALID(this);

    HRESULT hr = E_ACCESSDENIED;

    if (_pRowsetChange)
    {
        hr = DL_THR(RowsetChange, SetData(hRow, hAccessor, (BYTE *)pData));
    }

    if (hr)
    {
        goto Cleanup;
    }

    // If we are not receiving notifications from below, we should fire
    //   events ourselves.
    if (!_wAdviseCookieRowsetNotify)
    {
        // TODO: this should be a FieldChange, not a RowChange
        IGNORE_HR(_DLNotify.OnRowChange(_pRowsetLocate, 1, &hRow,
                                DBREASON_COLUMN_SET, DBEVENTPHASE_DIDEVENT,
                                TRUE));
    }

Cleanup:
    return hr;
}




//+-----------------------------------------------------------------------------
//
//  Update - flush data to the database
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Update()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Update(%p)", this));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Update(NULL, 0, NULL, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Update - flush one record's data to the database
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Update(HROW hrow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Update(%p %p)", this, hrow));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Update(NULL, 1, &hrow, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Undo - discard all pending changes
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Undo()
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Undo(%p)", this));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Undo(NULL, 0, NULL, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Undo - discard pending changes to one row
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::Undo(HROW hrow)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Undo(%p, %p)", this, hrow));

    IS_VALID(this);

    HRESULT hr = S_OK;

    if (_pRowsetUpdate)
    {
        hr = DL_THR(RowsetUpdate, Undo(NULL, 1, &hrow, NULL, NULL, NULL));
        hr = ClampITFResult(hr);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  GetRowStatus - return pending row status for given row, using the OLE DB M9
//                  definitions.
//
//  Returns: S_OK if everything is cool
//
HRESULT
CDataLayerCursor::GetRowStatus(HROW hrow, LONG *pstatus)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Undo(%p, %p)", this, hrow));

    IS_VALID(this);

    // assume success, data not changed
    HRESULT hr = S_OK;
    *pstatus = DBPENDINGSTATUS_UNCHANGED;

    if (_pRowsetUpdate)
    {
        DBCOUNTITEM cRows;
        HROW *aRows;
        DBROWSTATUS *aStatus;
        DBPENDINGSTATUS dwRowStatus = DBPENDINGSTATUS_NEW |
                                DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED;
        
        hr = DL_THR(RowsetUpdate, GetPendingRows(NULL, dwRowStatus,
                                                 &cRows, &aRows, &aStatus));
        if (hr)
        {
            if (hr == S_FALSE)
            {
                Assert(cRows == 0);
                Assert(aRows == NULL);
                Assert(aStatus == NULL);
                hr = S_OK;
            }
            goto Cleanup;
        }

        Assert(cRows != 0);
        Assert(aRows != NULL);
        Assert(aStatus != NULL);

        HROW *pRowLoop;
        ULONG cRowLoop;
        
        for (pRowLoop = aRows, cRowLoop = cRows;
             cRowLoop;
             --cRowLoop, pRowLoop++ )
        {
            if (IsSameRow(*pRowLoop, hrow))
            {
                switch(aStatus[cRows - cRowLoop])
                {
                case DBPENDINGSTATUS_NEW:
                case DBPENDINGSTATUS_CHANGED:
                case DBPENDINGSTATUS_DELETED:
                    *pstatus = aStatus[cRows - cRowLoop];
                    break;
                default:
                    Assert(!"Unknown Row Status");
                    break;
                }
                break;
            }
        }

        ReleaseRows(cRows, aRows);
        CoTaskMemFree(aRows);
        CoTaskMemFree(aStatus);
    }

Cleanup:
    hr = ClampITFResult(hr);
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  GetPositionAndSize - Return the ordinal position within a given Chapter.
//
//  Params:  rdlb           Reference to Bookmark whose position is desired
//           puFetchedRows  pointer to ULONG to return the position in
//           puChapterSize  pointer to ULONG to return the size in
//
//  Comments:
//          NULL's are accepted and may be more efficient
//
//  Returns: S_OK -- everything OK
//           E_...  "standard" error code (no OLE DB errors propagated)
//
HRESULT
CDataLayerCursor::GetPositionAndSize(const CDataLayerBookmark &rdlb,
                                     DBCOUNTITEM *puPosition, DBCOUNTITEM *puChapterSize )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetPositionAndSize(%p)", this ));

    IS_VALID(this);

    HRESULT hr = E_FAIL;
    DBCOUNTITEM   uPosition    = 0;
    DBCOUNTITEM   uChapterSize = _uChapterSize;

    if (_pRowsetExactScroll)
    {
        hr = DL_THR(RowsetExactScroll, GetExactPosition(
            _hChapter,
            rdlb.getDataSize(), rdlb.getDataPointer(),
            &uPosition, &uChapterSize ));
        hr = ClampITFResult(hr);
    }
    if (hr && _pRowsetScroll)
    {
        hr = DL_THR(RowsetScroll, GetApproximatePosition(
            _hChapter,
            rdlb.getDataSize(), rdlb.getDataPointer(),
            &uPosition, &uChapterSize ));
        hr = ClampITFResult(hr);
    }

    if (!hr)
    {
        if (puPosition)
        {
            *puPosition = uPosition;
        }
        if (puChapterSize)
        {
            _uChapterSize = uChapterSize;
            *puChapterSize = uChapterSize;
        }
    }
    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  GetPositionAndSize - Return the ordinal position within a given Chapter.
//
//  Params:  rdlch          Reference to Chapter which contains...
//           hRow           hRow whose position is desired
//           puFetchedRows  pointer to ULONG to return the position in
//           puChapterSize  pointer to ULONG to return the size in
//
//  Comments:
//          NULL's are accepted and may be more efficient
//
//  Returns: S_OK -- everything OK
//           E_...  "standard" error code (no OLE DB errors propagated)
//
HRESULT
CDataLayerCursor::GetPositionAndSize(HROW hRow,
                                     DBCOUNTITEM *puPosition, DBCOUNTITEM *puChapterSize )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetPositionAndSize(%p)", this ));

    IS_VALID(this);

    CDataLayerBookmark dlb;
    HRESULT hr = THR(CreateBookmark(hRow, &dlb));
    if (!hr)
    {
        hr = GetPositionAndSize(dlb, puPosition, puChapterSize);
    }
    RRETURN(hr);
}



//+-----------------------------------------------------------------------------
//
//  GetSize - Return the number of rows within a given Chapter.
//
//  Params:  rdlch          Reference to Chapter which contains...
//           puChapterSize  pointer to ULONG to return the size in
//
//  Returns: S_OK -- everything OK
//           E_...  "standard" error code (no OLE DB errors propagated)
//

HRESULT
CDataLayerCursor::GetSize(DBCOUNTITEM *puChapterSize)
{
    Assert(puChapterSize);

    return GetPositionAndSize(CDataLayerBookmark::TheFirst,
                              NULL, puChapterSize );
}



//+-----------------------------------------------------------------------------
//
//
//    AddRefRows
//
//    Params:   pHRows  caller allocated array of HROWS to AddRef
//              ulcb    number of elements in the array
//
//    Comments: NULL hRows are acceptable and will be ignored
//
void
CDataLayerCursor::AddRefRows(int ulcb, HROW *pHRows)
{
    for (; ulcb--; pHRows += 1)
    {
        if (*pHRows)
        {
            {
                DL_VERIFY_OK(RowsetLocate, AddRefRows(1, pHRows, NULL, NULL));
            }
        }
    }
}



//+-----------------------------------------------------------------------------
//
//
//    ReleaseRows
//
//    Params:   pHRows  caller allocated array of HROWS to release
//              ulcb    number of elements in the array
//
//    Comments: NULL hRows are acceptable and will be ignored
//
void
CDataLayerCursor::ReleaseRows(int ulcb, HROW *pHRows)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::ReleaseRows(%p)", this));

    IS_VALID(this);
    

    for (; ulcb--; pHRows += 1)
    {
        if (*pHRows)
        {
            {
                DL_VERIFY_OK(RowsetLocate, ReleaseRows(1, pHRows, NULL, NULL, NULL));
            }
        }
    }
}



//+-----------------------------------------------------------------------------
//
//  GetColumnNumberFromName : Gives back the number of a column given its name
//
//  Params:  pstrName     Pointer to the name of the column
//           ulColumnNum  The place to put the column index of the cursor
//                          (smallest index = 1, greatest index = NrOfColumns)
//
//  Returns: E_FAIL if the column name is invalid,
//           S_OK   if valid
//
HRESULT
CDataLayerCursor::GetColumnNumberFromName(LPCTSTR pstrName, DBORDINAL &ulColumnNum)
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetColumnNumberFromName(%p)", this ));

    IS_VALID(this);

    Assert("Non-null Name pointer required" && pstrName);

    HRESULT hr = S_OK;
    DBID colid = {{0}, DBKIND_NAME, {const_cast<LPTSTR>(pstrName)}};

    ulColumnNum = DB_INVALIDCOLUMN;

    Assert(_pColumnsInfo);

    hr = DL_THR(ColumnsInfo, MapColumnIDs(1, &colid, &ulColumnNum));
    if (hr)
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  GetColumnNameFromNumber : Gives back the name of a column given its number
//
//  Params:  ulColumnNum  The column index
//           ppstrName    Pointer to the name of the column
//
//  Returns: E_FAIL if the column number is invalid,
//           S_OK   if valid
//

HRESULT 
CDataLayerCursor::GetColumnNameFromNumber(DBORDINAL ulColumnNum, LPCTSTR *ppstrName)
{
    HRESULT hr;

    if (0<ulColumnNum && ulColumnNum<=_cColumns)
    {
        *ppstrName = _adlColInfo[ulColumnNum].pwszName;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  CreateBookmark
//
//  Creates and returns a bookmark coresponding to the given row
//
//  Returns:
//      S_OK iff bookmark is returned
//
HRESULT
CDataLayerCursor::CreateBookmark(HROW hRow,
                                 CDataLayerBookmark *pdlb )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::CreateBookmark(%p, %p, %p)",
              this, hRow, pdlb ));

    IS_VALID(this);
    IS_VALID(pdlb);

    Assert(hRow);

    HRESULT hr;

    if (!_hBookmarkAccessor)
    {
        hr = InitBookmarkAccessor();
        if (hr)
        {
            goto Cleanup;
        }
    }
    if (_fFixedSizedBookmark)
    {
        ULONG uBookmark;
        hr = THR(GetData(hRow, _hBookmarkAccessor, &uBookmark));
        if (!hr)
        {
            *pdlb = CDataLayerBookmark(*this, uBookmark);
        }
    }
    else
    {
        DBVECTOR dbv;
        hr = THR(GetData(hRow, _hBookmarkAccessor, &dbv));
        if (!hr)
        {
            *pdlb = CDataLayerBookmark(*this, dbv);
        }
    }

Cleanup:
    return hr; // RRETURN(hr); TODO: until we figure out better clamping (ICS)
}


//+-----------------------------------------------------------------------------
//
//  InitBookmarkAccessor
//
//  Creates an accessor handle for only 1 column : the bookmark
//
//  Returns:
//      S_OK if everything is cool
//      E_FAIL sets _hBookmarkAccessor handle to 0
//
HRESULT
CDataLayerCursor::InitBookmarkAccessor()
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::InitBookmarkAccessor(%p)", this ));

    IS_VALID(this);

    HRESULT hr = E_FAIL;

    Assert(!_hBookmarkAccessor);

    ULONG         cColumns    = _cColumns;
    ColumnInfo *pdlColumnInfo = _adlColInfo;

    for (; cColumns--; pdlColumnInfo++)
    {
        if (pdlColumnInfo->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK)
        {
            DBBINDING binding;
            _fFixedSizedBookmark = (pdlColumnInfo->dwFlags &
                                    DBCOLUMNFLAGS_ISFIXEDLENGTH ) &&
                                    pdlColumnInfo->cbMaxLength == sizeof(ULONG);
            binding.eParamIO = DBPARAMIO_NOTPARAM;
            binding.iOrdinal = pdlColumnInfo->iNumber;
            binding.dwPart    = DBPART_VALUE;
            binding.bPrecision = 0;
            binding.bScale   = 0;
            binding.obValue  = 0;
            binding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
            binding.pBindExt = 0;
            binding.dwFlags  = 0;
            if (_fFixedSizedBookmark)
            {
                binding.cbMaxLen = sizeof(ULONG);
                binding.wType = DBTYPE_UI4;
            }
            else
            {
                binding.cbMaxLen = sizeof(DBVECTOR);
                binding.wType = DBTYPE_UI1 | DBTYPE_VECTOR;
            }
                                                     
            hr = THR(CreateAccessor(_hBookmarkAccessor,
                                    DBACCESSOR_ROWDATA,
                                    &binding, 1 ));
            break;
        }
    }

    RRETURN(hr);
}




//+-----------------------------------------------------------------------------
//
//  CreateAccessor - Creates an accessor handle, default is complete row by ref
//
//  Params:   rhAccessor  reference to an accessor handle
//            dwAccFlags  specifies the accessor type, default is read
//            rgBindings  caller allocated array of binding information
//            ulcb        number of elements in the array
//
//  Returns:  S_OK if everything is cool, E_FAIL sets the accessor handle to 0
//
HRESULT
CDataLayerCursor::CreateAccessor(HACCESSOR      &rhAccessor,
                                 DBACCESSORFLAGS dwAccFlags,
                                 const DBBINDING rgBindings[],
                                 int             ulcb )
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::CreateAccessor(%p)", this ));

    IS_VALID(this);

    Assert(_pRowsetLocate);

    rhAccessor = NULL;

    RRETURN1(DL_THR(Accessor, CreateAccessor(dwAccFlags,
                                             (ULONG)ulcb,
                                             rgBindings,
                                             0,
                                             &rhAccessor,
                                             NULL )),
              DB_E_BYREFACCESSORNOTSUPPORTED );
}




//+-----------------------------------------------------------------------------
//
//  ReleaseAccessor - releases an accessor created with CreateAccessor
//
//  Params:   rhAccessor  reference to an accessor handle (which may be NULL)
//
//  Comments: rhAccessor will always be set to NULL
//
void
CDataLayerCursor::ReleaseAccessor(HACCESSOR &rhAccessor)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::ReleaseAccessor(%p, %p)",
             this, rhAccessor ));

    IS_VALID(this);

    if (rhAccessor)
    {
        DL_VERIFY_OK(Accessor, ReleaseAccessor(rhAccessor, NULL));
        rhAccessor = NULL;
    }
}




//+-----------------------------------------------------------------------------
//
//  GetColumnCount : Gives back the number of columns in the cursor
//
//  Params:  cWidth   Place to put the number of columns.
//
//  Returns: S_OK
//
HRESULT
CDataLayerCursor::GetColumnCount(DBORDINAL &cColumns)
{
    TraceTag((tagDataLayerCursor,
              "CDataLayerCursor::GetColumnCount(%p)", this ));

    IS_VALID(this);

    DBORDINAL cCnt = _cColumns;
    ColumnInfo *pdlColumnInfo = _adlColInfo;

    cColumns = 0;
    for ( ; cCnt-- ; pdlColumnInfo++)
    {
        cColumns += !(pdlColumnInfo->dwFlags & (DBCOLUMNFLAGS_ISBOOKMARK ));
    }

    RRETURN(THR(S_OK));
}




//+-----------------------------------------------------------------------------
//
//  GetPColumnInfo : helper function to get a pointer to our internal
//                   ColumnInfo structure for a given column number,
//                   including error checking to make sure that this
//                   is an ordinary (non-bookmark, etc.) column
//
//  Params:   ulColumnNum  Column index into the cursor
//            ppColumnInfo  Receiver of pointer
//
//  Returns:  S_OK          everything is fine
//            E_INVALIDARG  column out of range, or not a regular column
//
HRESULT
CDataLayerCursor::GetPColumnInfo(DBORDINAL ulColumnNum,
                                 const ColumnInfo **ppColumnInfo)
{
    HRESULT hr = E_INVALIDARG;

    TraceTag((tagDataLayerCursor, "CDataLayerCursor::GetPColumnInfo(%p)", this));

    IS_VALID(this);

    if (ulColumnNum < _cColumns)
    {
        *ppColumnInfo = &_adlColInfo[ulColumnNum];

        if (((*ppColumnInfo)->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0)
        {
            hr = S_OK;
        }
    }

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  FilterRowsToChapter : helper function to comb through a list of HROWs
//                  keeping only the ones belonging to my chapter.  This
//                  is useful for IRowsetNotify methods.  A chaptered
//                  rowset will notify about all HROWs, but we should only
//                  react to the HROWs from my chapter.
//
//  Params:   cRows     number of HROWs in the list
//            rghRows   list of HROWs
//            pcRows    pointer to number of good HROWs (returned)
//            prghRows  pointer to list of good HROWs (returned)
//
//  Note:   The caller should compare the pointer returned through prghRows
//          with the pointer passed in as rghRows.  If they differ, the caller
//          should free the memory allocated for the returned list by executing
//          "delete *prghRows".  However, this routine will use the original
//          list whenever possible, avoiding unneeded memory allocations.
//
//  Returns:  S_OK          everything is fine
//            E_INVALIDARG  pcRows or prghRows not valid
//
HRESULT
CDataLayerCursor::FilterRowsToChapter(
        DBROWCOUNT cRows,
        const HROW rghRows[  ],
        DBROWCOUNT *pcRows,
        const HROW **prghRows
        )
{
    HRESULT hr = S_OK;
    DBROWCOUNT cRowsGood = 0;
    BOOL fNeedAllocation = FALSE;
    DBROWCOUNT i;
    const HROW *pHrow;

    if (pcRows == NULL  ||  prghRows == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // assume most common case - reuse the input array in the output
    *prghRows = rghRows;

    // special case - chapter 0 means all rows are OK
    if (_hChapter == DB_NULL_HCHAPTER)
    {
        *pcRows = cRows;
        goto Cleanup;
    }

    // bad case - no IRowsetChapterMember means we can't even tell which
    // rows belong.  Be paranoid and say none of them.
    if (_pRowsetChapterMember == NULL)
    {
        *pcRows = 0;
        goto Cleanup;
    }

    // walk through the input array and see which HROWs belong to my chapter
    for (i=0, pHrow=rghRows;  i<cRows;  ++i, ++pHrow)
    {
        hr = DL_THR(RowsetChapterMember, IsRowInChapter(_hChapter, *pHrow));
        if (hr == S_OK)
        {
            if (cRowsGood < i)
                fNeedAllocation = TRUE;
            ++ cRowsGood;
        }
    }

    // if we need to allocate an array to return to the caller, do so now
    // and fill it in.
    if (fNeedAllocation)
    {
        HROW *pHrowReturn = new HROW[cRowsGood];

        *prghRows = pHrowReturn;

        for (i=0, pHrow=rghRows;  i<cRows;  ++i, ++pHrow)
        {
            hr = DL_THR(RowsetChapterMember, IsRowInChapter(_hChapter, *pHrow));
            if (hr == S_OK)
            {
                *pHrowReturn = *pHrow;
                ++ pHrowReturn;
            }
        }
    }

    // tell caller how many rows were good
    *pcRows = cRowsGood;
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


#if DBG == 1
//+-----------------------------------------------------------------------------
//
//  Validation method, called by macro IS_VALID(p)
//
BOOL
CDataLayerCursor::IsValidObject()
{
    ULONG i;

    Assert(this);
    Assert("We must have an IRowsetLocate" &&
           (_pRowsetLocate) );

    // _adlColInfo may not be set yet, if Init() fails for some reason
    if (_adlColInfo)
    {
        for (i = 0; i < _cColumns; i++)
        {
            Assert(_adlColInfo[i].iNumber == i);
        }
    }
    
    return TRUE;
}



char s_achCDataLayerCursor[] = "CDataLayerCursor";


//+-----------------------------------------------------------------------------
//
//  Dump function, called by macro DUMP(p,dc)
//
void
CDataLayerCursor::Dump(CDumpContext &dc)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::Dump(%p)", this));

    IS_VALID(this);
}



//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
char *
CDataLayerCursor::GetClassName()
{
    return s_achCDataLayerCursor;
}
#endif


///////////////////////////////////////////////////////////////////////
//
//      CDataLayerNotify subobject

HRESULT
CDataLayerNotify::CheckCallbackThread()
{
    HRESULT hr = S_OK;

    if (_dwTID != GetCurrentThreadId())
    {
        Assert(!"OLEDB callback on wrong thread");
        hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     QueryInterface
//
//  Synopsis:   Normal IUnknown QI
//
//  Arguments:  riid            IID of requested interface
//              ppv             Interface object to return
//
//  Returns:    S_OK            Interface supported
//              E_NOINTERFACE   Interface not supported.
//

STDMETHODIMP
CDataLayerNotify::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IRowsetNotify *)this;
    }
    else if (IsEqualIID(riid, IID_IRowsetNotify))
    {
        *ppv = (IRowsetNotify *)this;        
    }
    else if (IsEqualIID(riid, IID_IDBAsynchNotify))
    {
        *ppv = (IDBAsynchNotify *)this;
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+-------------------------------------------------------------------------
// Member:      AddRef (public, IUnknown)
//
// Synopsis:    increase refcount
//
// Returns:     new refcount

ULONG
CDataLayerNotify::AddRef()
{
    return MyDLC()->SubAddRef();
}


//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, die if 0
//
// Returns:     new refcount

ULONG
CDataLayerNotify::Release()
{
    return MyDLC()->SubRelease();
}


//+---------------------------------------------------------------------------
//  Member:     OnFieldChange
//
//  Synopsis:   Called by Nile when a field changes
//              Note that the notification we receive map perfectly to the
//              events we fire.
//

STDMETHODIMP
CDataLayerNotify::OnFieldChange (IRowset *pRowset, HROW hRow,
                                 DBORDINAL cColumns, DBORDINAL aColumns[],
                                 DBREASON eReason, DBEVENTPHASE ePhase,
                                 BOOL /* fCantDeny */)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::OnFieldChange(%p, %p)",
             this, pRowset ));

    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    Assert(pRowset);
    if (_pDLCEvents && (ePhase == DBEVENTPHASE_DIDEVENT))  // only fire once
    {
        DBROWCOUNT cRowsGood;
        const HROW *pHrow;

        // check that hRow belongs to my chapter
        if (MyDLC()->_fFilterNotificationsToChapter)
        {
            hr = MyDLC()->FilterRowsToChapter(1, &hRow, &cRowsGood, &pHrow);
            if (hr || cRowsGood==0)
                goto Cleanup;
            Assert(pHrow == &hRow);     // Filter should never allocate an array for only one row
        }
        
        IGNORE_HR(_pDLCEvents->FieldsChanged(hRow, cColumns, aColumns));
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     OnRowChange
//
//  Synopsis:   Called by Nile when a HROW changes
//

STDMETHODIMP
CDataLayerNotify::OnRowChange (IRowset *pRowset, DBCOUNTITEM cRows,
                               const HROW ahRows[],
                               DBREASON eReason, DBEVENTPHASE ePhase,
                               BOOL /* fCantDeny */)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::OnRowChange(%p, %p)",
             this, pRowset ));

    DBROWCOUNT cRowsGood = cRows;
    const HROW *pHrowsGood = ahRows;
    
    CDataLayerCursor *pDLC = MyDLC();
    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    Assert(pRowset);

    // ignore rows that don't belong to my chapter
    if (MyDLC()->_fFilterNotificationsToChapter)
    {
        hr = pDLC->FilterRowsToChapter(cRows, ahRows, &cRowsGood, &pHrowsGood);
        if (hr || cRowsGood == 0)
            goto Cleanup;
    }

    // Note that we want to update _uChapterSize even if nobody is listening.
    switch (ePhase)      // fire any given notification exactly once
    {
    case DBEVENTPHASE_OKTODO:
        if (eReason == DBREASON_ROW_DELETE || eReason == DBREASON_ROW_UNDOINSERT)
        {
            if (_pDLCEvents && !pDLC->_fDeleteAllInProgress)
            {
                hr = THR(_pDLCEvents->DeletingRows(cRowsGood, pHrowsGood));
            }
        }
        break;

    case DBEVENTPHASE_FAILEDTODO:
        if (eReason == DBREASON_ROW_DELETE || eReason == DBREASON_ROW_UNDOINSERT)
        {
            if (_pDLCEvents && !pDLC->_fDeleteAllInProgress)
            {
                IGNORE_HR(_pDLCEvents->DeleteCancelled(cRowsGood, pHrowsGood));
            }
        }
        break;

    case DBEVENTPHASE_DIDEVENT:
        switch (eReason)
        {
        case DBREASON_ROW_DELETE:
        case DBREASON_ROW_UNDOINSERT:
            if (pDLC->_uChapterSize != ~0ul)
            {
                pDLC->_uChapterSize -= cRowsGood;
            }
            if (_pDLCEvents && !pDLC->_fDeleteAllInProgress)
            {
                IGNORE_HR(_pDLCEvents->RowsDeleted(cRowsGood, pHrowsGood));
            }
            break;

        case DBREASON_ROW_INSERT:
        case DBREASON_ROW_ASYNCHINSERT:
        case DBREASON_ROW_UNDODELETE:
            if (pDLC->_uChapterSize != ~0ul)
            {
                pDLC->_uChapterSize += cRowsGood;
            }
            if (_pDLCEvents)
            {
                IGNORE_HR(_pDLCEvents->RowsInserted(cRowsGood, pHrowsGood));
            }
            break;

        case DBREASON_COLUMN_RECALCULATED:
        case DBREASON_COLUMN_SET:
        case DBREASON_ROW_RESYNCH:
        case DBREASON_ROW_UNDOCHANGE:
            if (_pDLCEvents)
            {
                IGNORE_HR(_pDLCEvents->RowsChanged(cRowsGood, pHrowsGood));
            }
            break;
        }
    }

Cleanup:
    if (pHrowsGood != ahRows)
        delete const_cast<HROW *>(pHrowsGood);
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     OnRowsetChange
//
//  Synopsis:   Called by Nile when the rowset has changed
//

STDMETHODIMP
CDataLayerNotify::OnRowsetChange (IRowset *pRowset, DBREASON eReason,
                                    DBEVENTPHASE ePhase, BOOL)
{
    TraceTag((tagDataLayerCursor, "CDataLayerCursor::OnRowsetChange(%p, %p)",
             this, pRowset ));

    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

//$ ISSUE: (dinartem) Trident now calls ExecStop at the beginning of
//$         UnloadContents which causes OnRowsetChange to be called with a
//$         pRowset of NULL.
//$    Assert(pRowset);

    switch (eReason)
    {
    case DBREASON_ROWSET_CHANGED:
        if (ePhase == DBEVENTPHASE_DIDEVENT)        // only fire once
        {
            if (_pDLCEvents)
            {
                IGNORE_HR(_pDLCEvents->AllChanged());
            }
        }
        break;

    default:
        hr = DB_S_UNWANTEDREASON;
        break;
    }

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CDataLayerNotify::OnLowResource(DB_DWRESERVE dwReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDataLayerNotify::OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE ulStatusCode,
            /* [in] */ LPOLESTR pwszStatusText)
{
    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    if (_pDLCEvents && ulStatusCode==DBASYNCHPHASE_POPULATION)
    {
        IGNORE_HR(_pDLCEvents->RowsAdded());
        // Fire PopulationComplete in the OnStop event..
    }

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CDataLayerNotify::OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ ULONG ulOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText)
{
    HRESULT hr = CheckCallbackThread();
    if (hr)
        goto Cleanup;

    MyDLC()->_fComplete = TRUE;

    if (_pDLCEvents)
    {
        // Add reason arguments soon..
        IGNORE_HR(_pDLCEvents->PopulationComplete());
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//  Member:     HandleError
//
//  Synopsis:   Error notification wrapper for Nile function calls,
//              notifies DL client of errors.
//
//  Arguments:  riid            IID of interface which was called
//              hr              HRESULT returned (may be success)
//
//  Returns:    HRESULT         hresult passed in
//

HRESULT
CDataLayerCursor::HandleError(REFIID riid, HRESULT hr)
{
    BOOL fSupportsErrorInfo = TRUE;
    
    if (SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    if (!_pSupportErrorInfo
            || _pSupportErrorInfo->InterfaceSupportsErrorInfo(riid))
    {
        // to avoid any confusion, make sure we don't have ErrorInfo lying
        //  around for some other failuer.
        ::SetErrorInfo(0, NULL);
        fSupportsErrorInfo = FALSE;
    }
    
    if (_DLNotify._pDLCEvents)
    {
        IGNORE_HR(_DLNotify._pDLCEvents->OnNileError(hr, fSupportsErrorInfo));
    }

Cleanup:
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     CDataLayerCursorEvents::OnNileError
//
//  Synopsis:   Default implementation of OnError event sink.
//
//  Arguments:  HRESULT         hresult of error (must be failure code)
//              BOOL            indicates if ErrorInfo corresponds to error
//
//  Returns:    S_OK            error message/notification handled
//              S_FALSE         error message/notification not handled
//              E_*             unexpected error blocking message/notification
//

HRESULT
CDataLayerCursorEvents::OnNileError(HRESULT, BOOL)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\include\empty.cxx ===
#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\change.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  Author:     Terry L. Lucas (TerryLu)
//
//  Contents:   CImpIRowsetChange object implementation
//


#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetChange specific interfaces
//
////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------
//
//  Member:    DeleteRows (public member)
//
//  Synopsis:  Given an array of of HROWs, this will remove the rows from
//             the table.  Note that the rows, in the case of the STD, are
//             immediately removed.  If there are any errors, error
//             information will be returned to the user, provided the user
//              has allocated an array for the information.
//
//  Arguments: hReserved        future use.  Ignored
//             cRows            number of rows to delete
//             ahRows           an array of HROWs to remove
//              aRowStatus      array for errors, one per HROW (or NULL)
//
//  Returns:   Success           if inputs are valid.
//             E_INVALIDARG      if cRows>0 but ahRows is NULL
//             E_FAIL            if STD reports an error
//             DB_E_NOTREENTRANT illegal reentrancy
//             DB_S_ERRORSOCCURRED  something failed, but at least one row
//                                  was deleted
//

STDMETHODIMP
CImpIRowset::DeleteRows (HCHAPTER hChapter, DBCOUNTITEM cRows, const HROW ahRows[],
                         DBROWSTATUS aRowStatus[])
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::DeleteRows(%p {%p, %u, %p, %p})",
              this, hChapter, cRows, ahRows, aRowStatus));

    HRESULT hr = S_OK;
    BOOL    fRowsDeleted = FALSE;           // were rows actually deleted
    BOOL    fRowsNotDeleted = FALSE;        // did any rows fail to delete
    const HROW *phRow = ahRows;                 // index for stepping HROWs

    if (cRows && !ahRows)                   // no input array
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (FAnyPhaseInProgress(DBREASON_ROW_DELETE)
            || FAnyPhaseInProgress(DBREASON_ROW_INSERT))
    {
        hr = DB_E_NOTREENTRANT;
        goto Cleanup;
    }

    if (GetpOSPData(hChapter) == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    // mark all the rows OK.  later events may change this
    LogErrors(aRowStatus, 0, cRows, DBROWSTATUS_S_OK);

    // we attempt to coalesce runs of consecutive ascending or descending rows,
    //  because our overhead in handling notifications will be much more
    //  manageable.
    while(cRows)
    {
        const HROW *phRowStartRun = phRow;
        DBCOUNTITEM ulRow;
        HRESULT hrT;
        HCHAPTER hChapter;              // chapter for this hRow

        hr = HROW2Index(*phRow, ulRow);
        if (hr)
        {
            // Advance loop variable, and log one error
            DBROWSTATUS dbs = hr==DB_E_DELETEDROW   ? DBROWSTATUS_E_DELETED
                                                    : DBROWSTATUS_E_INVALID;
            (++phRow, --cRows);

            LogErrors(aRowStatus, phRowStartRun-ahRows, 1, dbs);
            fRowsNotDeleted = TRUE;
            hr = S_OK;
        }
        else
        {
            DBCOUNTITEM ulRow2;
            DBCOUNTITEM cRowsRun;
            INT iDirection = 1; // algorithm works even if uninitialized, but
                                //  this keeps the compiler happy/
            DBROWCOUNT cRowsDeleted;

            hChapter = ChapterFromHRow((ChRow) *phRow);

            // Advance loop variables, continue advance if run length > 1
            phRow++;
            --cRows;
            if (cRows && !HROW2Index(*phRow, ulRow2))
            {
                iDirection = ulRow2 - ulRow;

                if (iDirection == 1 || iDirection == -1)
                {
                    // we've got a run!  Advance loop variables to past end.
                    for (;;)
                    {
                        DBCOUNTITEM ulRowTemp;

                        ulRow2 += iDirection;
                        if ((phRow++, --cRows) == 0)
                            break;
                        // Break this run if we ran off the end, changed chapter
                        // (not technically legal), or are simply not contiguous.
                        if (HROW2Index(*phRow, ulRowTemp) ||
                            ChapterFromHRow((ChRow) *phRow) != hChapter ||
                            ulRowTemp != ulRow2)
                        {
                            break;
                        }
                    }
                }
            }

            cRowsRun = (phRow - phRowStartRun);

            // Note that if cRowsRun == 1, then any value of iDirection
            //  produces identical results.  So it's OK that we may hit here
            //  with a garbage iDirection in certain circumstances.

            Assert(iDirection == -1 || iDirection == 1 || cRowsRun == 1);
            if (iDirection < 0)
                ulRow -= cRowsRun - 1;

            hrT = GetpOSP(hChapter)->deleteRows((LONG)ulRow, (LONG)cRowsRun, &cRowsDeleted);
            if (cRowsDeleted > 0)
                fRowsDeleted = TRUE;

            // Note that Indexes insides HROWs (CImpRows) should just
            //  have been fixed up!

            if (hrT)
            {
                fRowsNotDeleted = TRUE;
                Assert((DBROWCOUNT)cRowsDeleted != (DBROWCOUNT)cRowsRun);
                if (iDirection > 0)
                {
                    phRowStartRun += cRowsDeleted;
                }
                LogErrors(aRowStatus, phRowStartRun - ahRows,
                                cRowsRun - cRowsDeleted, DBROWSTATUS_E_CANCELED);
            }
            else
            {
                Assert((DBROWCOUNT)cRowsDeleted == (DBROWCOUNT)cRowsRun);
            }
        }
    }
Cleanup:
    if (hr == S_OK)     // no global errors - see whether row deletions worked
        hr = fRowsNotDeleted    ? fRowsDeleted  ? DB_S_ERRORSOCCURRED
                                                : DB_E_ERRORSOCCURRED
                                : S_OK;
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    InsertRow (public member)
//
//  Synopsis:  Create and initialize a new row in the STD.
//
//  Arguments: hChapter    chapter handle [IN]
//             hAccessor   Accessor to use [IN]
//             pData       Pointer to buffer of data to set [IN]
//             phRow       Row Handle [OUT]
//
//  Returns:   S_OK                    if data changed successfully
//             E_FAIL                  if Catch all (NULL pData, etc.)
//             E_INVALIDARG            if pcErrors!=NULL and paErrors==NULL
//             E_OUTOFMEMORY           if output error array couldn't be allocated
//             DB_E_BADACCESSORHANDLE  if invalid accessor
//             DB_E_BADCHAPTER         if chapter passed in
//

STDMETHODIMP
CImpIRowset::InsertRow(HCHAPTER   hChapter,
                        HACCESSOR  hAccessor, void *pData,
                        HROW      *phRow )
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::InsertRow(%p {%p %p})",
              this, hAccessor, pData ));
    return SetNewDataAfter(hChapter, 1, &g_bBmkLast,
                           hAccessor, (BYTE*)pData, phRow );
}


//+-----------------------------------------------------------------------
//
//  Member:     SetData (public member)
//
//  Synopsis:   Sets new data values into fields of a row.
//
//  Arguments:  hRow        Row Handle [IN]
//              hAccessor   Accessor to use [IN]
//              pData       Pointer to buffer of data to set [IN/OUT]
//
//  Returns:    S_OK                    Data changed successfully
//              DB_S_ERRORSOCCURRED     Parital success
//              DB_E_ERRORSOCCURRED     All columns failed
//              DB_E_BADACCESSORHANDLE  Invalid accessor
//              DB_E_BADROWHANDLE       Bad HROW (0)
//              E_FAIL                  Catch all (including out-of-mem)
//              DB_E_NOTREENTRANT       Illegal reentrancy
//
//  Sets status field (in *pData) for each column that has one

STDMETHODIMP
CImpIRowset::SetData (HROW hRow, HACCESSOR hAccessor, void* pData)
{
    TraceTag((tagNileRowsetProvider,
             "IRowsetChange::SetData(%p {%p, %p, %p})",
             this, hRow, hAccessor, pData ));

    HRESULT         hr;
    HRESULT         hrLastFailure;
    AccessorFormat  *pAccessor;
    ULONG           cBindings;
    DBBINDING       *pBinding;
    ULONG           ibind;
    ULONG           ulErrorCount = 0;
    DBCOUNTITEM     uStdRow;
    HCHAPTER        hChapter;

    // check that accessor is valid
    pAccessor = (AccessorFormat *)hAccessor;
    if (pAccessor == NULL)
    {
        hr = DB_E_BADACCESSORHANDLE;
        goto Cleanup;
    }
    if (!(pAccessor->dwAccFlags & DBACCESSOR_ROWDATA))
    {
        hr = DB_E_BADACCESSORTYPE;
        goto Cleanup;
    }

    cBindings = pAccessor->cBindings;
    pBinding  = pAccessor->aBindings;

    // check that hrow is valid
    hr = HROW2Index(hRow, uStdRow);
    if (hr)
    {
        goto Cleanup;
    }

    hChapter = ChapterFromHRow((ChRow) hRow);

    // Ensure a place to put data, unless the accessor is the null accessor then
    // a NULL pData is okay.
    if (pData == NULL && cBindings > 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Apply accessor to data.
    for (ibind = 0; ibind < cBindings; ++ibind)
    {
        XferInfo        xInfo;
        DBBINDING &     currBinding = pBinding[ibind];
        DBPART          dwPart = currBinding.dwPart;
        ULONG           iord = currBinding.iOrdinal;
        CSTDColumnInfo &stdColInfo = _astdcolinfo[ColToDBColIndex(iord)];
        DBLENGTH        dblenDummyLength;
        DBSTATUS        dbDummyStatus;

        xInfo.dwDBType = stdColInfo.dwType;
        xInfo.dwAccType = currBinding.wType;

        xInfo.pData = dwPart & DBPART_VALUE ?
            ((BYTE *)pData + currBinding.obValue) : NULL;
        xInfo.pdblenXferLength = dwPart & DBPART_LENGTH ?
            (DBLENGTH *)((BYTE *)pData + currBinding.obLength) : &dblenDummyLength;
        xInfo.pdbStatus = dwPart & DBPART_STATUS ?
            (DBSTATUS *)((BYTE *)pData + currBinding.obStatus) : &dbDummyStatus;
        xInfo.dblenDataMaxLength = stdColInfo.cbMaxLength;

        // check that the accessor is allowed to write to this column
        if (!(stdColInfo.dwFlags & DBCOLUMNFLAGS_WRITE) )
        {
            *xInfo.pdbStatus = DBROWSTATUS_E_PERMISSIONDENIED;
            ++ ulErrorCount;
            continue;
        }

        hr = DataCoerce(DataToProvider, hChapter, uStdRow, iord, xInfo);

        if (hr)
        {
            Assert(FAILED(hr));
            hrLastFailure = hr;
            ++ ulErrorCount;
        }
    }

    hr = ulErrorCount == 0 ?            S_OK :
         ulErrorCount == cBindings ?    DB_E_ERRORSOCCURRED :
                                        DB_S_ERRORSOCCURRED;

Cleanup:
    Assert(hr != E_OUTOFMEMORY);    // would conflict with Nile spec
    return hr;
}



//+-----------------------------------------------------------------------
//
//  Member:    LogErrors (private member)
//
//  Synopsis:  Helper function to fill in an array of DBROWSTATUS objects
//
//  Arguments: aRowStatus       array of DBROWSTATUSs, one per HROW.  If this
//                              is 0, this routine does nothing.
//             iFirstRow        index of first row to log error
//             cErrorRows       number of rows to log errors for
//             dbrsStatus       What status code to return for each HROW
//
//  Returns:   nothing
//

void
CImpIRowset::LogErrors(DBROWSTATUS aRowStatus[], DBCOUNTITEM iFirstRow, DBCOUNTITEM cErrorRows,
                       DBROWSTATUS dbrs)
{
    if (aRowStatus) {
        for ( ; cErrorRows>0; --cErrorRows, ++iFirstRow)
        {
            aRowStatus[iFirstRow] = dbrs;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\include\dlayrc.h ===
To be removed

//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       dlayrc.h
//
//  Contents:   Resource identifiers for Dlay project.
//
//----------------------------------------------------------------------------
//
//  Resource identifier ranges.
//  See corerc.h for a complete listing of ranges used in Forms3.
//
//  09000 - 09999    dlay miscellaneous
//
//----------------------------------------------------------------------------

#ifndef __DLAYRC_H__
#define __DLAYRC_H__

#define IDS_DLAY_ERROR_BASE      8999

#define IDS_MSG_DB_CANTSAVE         (IDS_DLAY_ERROR_BASE + 1)

#define IDS_EE_DB_COERCE            (IDS_DLAY_ERROR_BASE + 2)
#define IDS_EE_DB_DELROW            (IDS_DLAY_ERROR_BASE + 3)
#define IDS_EE_DB_READ              (IDS_DLAY_ERROR_BASE + 4)
#define IDS_EE_DB_SCHEMA            (IDS_DLAY_ERROR_BASE + 5)
#define IDS_EE_DB_CANCELED          (IDS_DLAY_ERROR_BASE + 6)
#define IDS_EE_DB_OTHER_STATUS      (IDS_DLAY_ERROR_BASE + 7)

#endif // __DLAYRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\colinfo.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      colinfo.cxx
//  Author:    Ido Ben-Shachar (t-idoben@microsoft.com)
//
//  Contents:  Implementation of GetColumnInfo
//
//  History:
//  08/02/95   Ido       GetColumnInfo returns appropriate flags.
//


#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

#define HIER_PREFIX     _T("^")
#define HIER_PREFIX_LEN (1)
#define HIER_SUFFIX     _T("^")
#define HIER_SUFFIX_LEN (1)

MtDefine(CImpIRowset_astdcolinfo, CImpIRowset, "CImpIRowset::_astdcolinfo");

//+---------------------------------------------------------------------------
//
//  Member:     CacheMetaData (public member)
//
//  Synopsis:   read meta data from OSP into a cache
//
//  Returns:    S_OK                if everything is fine
//              E_FAIL              initialization failed
//
HRESULT
CImpIRowset::CacheMetaData()
{
    HRESULT hr = S_OK;
    DBROWCOUNT cColsTemp;
    CSTDColumnInfo *pInfoIndex;
    ULONG i;
    OLEDBSimpleProvider *pOSP = GetpMetaOSP();

    Assert(!_astdcolinfo);
    // Go ahead and replace any previous cache, but this shouldn't happen
    delete [] _astdcolinfo;

    hr = pOSP->getColumnCount(&cColsTemp);
    _cCols = (ULONG)cColsTemp;

    if (hr || _cCols == 0)          // We can't make a valid 0 column rowset
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    cColsTemp = 1 + _cCols;         // bookmark column + OSP columns

    // Allocate cache:
    _astdcolinfo = new(Mt(CImpIRowset_astdcolinfo)) CSTDColumnInfo[cColsTemp];
    if (!_astdcolinfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // fill in cache for bookmark column
    pInfoIndex = _astdcolinfo;
    pInfoIndex->dwFlags = DBCOLUMNFLAGS_ISBOOKMARK |
                         DBCOLUMNFLAGS_ISFIXEDLENGTH;
    pInfoIndex->dwType = DBTYPE_I4;                     // bookmark is an integer
    pInfoIndex->cbMaxLength = sizeof(ULONG);            // bookmark is 4 bytes
    pInfoIndex->bstrName = NULL;                        // no name
    pInfoIndex->pChapRowset = NULL;                     // no referenced rowset

    // fill in cache for OSP columns
    for (i = 1, ++pInfoIndex;  i < (ULONG)cColsTemp;  ++i, ++pInfoIndex )
    {
        OSPRW  wRW;
        VARIANT tempVar;

        pInfoIndex->dwFlags = DBCOLUMNFLAGS_ISFIXEDLENGTH;
        hr = pOSP->getRWStatus(OSP_IndexAll, i, &wRW);
        if (!hr && wRW != OSPRW_READONLY)
        {
            pInfoIndex->dwFlags |= DBCOLUMNFLAGS_WRITE;
        }
        
        pInfoIndex->dwType = DBTYPE_VARIANT;            // columns hold variants
        pInfoIndex->cbMaxLength = sizeof(VARIANT);
        pInfoIndex->pChapRowset = NULL;
        pInfoIndex->bstrName = NULL;
        
        FastVariantInit(&tempVar);
        hr = pOSP->getVariant(0, i, OSPFORMAT_FORMATTED, &tempVar);
        if (!hr && tempVar.vt == VT_BSTR)
        {
            ULONG cColNameLen = SysStringLen(tempVar.bstrVal);

            // Detect hierarchy columns.
            if (FormsStringNCmp(HIER_PREFIX, HIER_PREFIX_LEN,
                                tempVar.bstrVal, HIER_PREFIX_LEN) == 0 &&
                FormsStringNCmp(HIER_SUFFIX, HIER_SUFFIX_LEN,
                                tempVar.bstrVal + cColNameLen - HIER_SUFFIX_LEN,
                                HIER_SUFFIX_LEN) == 0)
            {
                pInfoIndex->dwFlags |= DBCOLUMNFLAGS_ISCHAPTER;
                pInfoIndex->dwType = DBTYPE_HCHAPTER;
                pInfoIndex->cbMaxLength = sizeof(IUnknown *);
                // We won't save the prefix
                FormsAllocStringLen(tempVar.bstrVal + HIER_PREFIX_LEN,
                        cColNameLen - (HIER_PREFIX_LEN+HIER_SUFFIX_LEN),
                        &pInfoIndex->bstrName);
            }
            else
            {
                pInfoIndex->bstrName = tempVar.bstrVal;
                tempVar.bstrVal = NULL;     // BSTR now owned by pInfoIndex
            }

            VariantClear(&tempVar);
        }
    }

    // initialize my properties
    // TODO this should be table-driven
    {
        DBPROP prop;

        // we don't wast static data with a copy of DB_NULLID
        // prop.colid = DB_NULLID;
        memset(&prop.colid, 0, sizeof(prop.colid));

        prop.dwOptions = DBPROPOPTIONS_REQUIRED;
        prop.dwStatus  = DBPROPSTATUS_OK;

        // LITERALIDENTITY = False
        prop.dwPropertyID = DBPROP_LITERALIDENTITY;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

        // STRONGIDENTITY = False
        prop.dwPropertyID = DBPROP_STRONGIDENTITY;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

        //
        // the next 11 properties are the ones ADO queries (msador15 v1929)
        
        // OTHERUPDATEDELETE = True
        prop.dwPropertyID = DBPROP_OTHERUPDATEDELETE;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // OTHERINSERT = True
        prop.dwPropertyID = DBPROP_OTHERINSERT;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // CANHOLDROWS = True
        prop.dwPropertyID = DBPROP_CANHOLDROWS;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // CANSCROLLBACKWARDS = True
        prop.dwPropertyID = DBPROP_CANSCROLLBACKWARDS;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // UPDATABILITY = change | delete | insert
        prop.dwPropertyID = DBPROP_UPDATABILITY;
        V_VT(&prop.vValue) = VT_I4;
        V_I4(&prop.vValue) = DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_DELETE |
                                DBPROPVAL_UP_INSERT;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetLocate = True
        prop.dwPropertyID = DBPROP_IRowsetLocate;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetScroll = True
        prop.dwPropertyID = DBPROP_IRowsetScroll;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetUpdate = False
        prop.dwPropertyID = DBPROP_IRowsetUpdate;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IRowsetResynch = False
        prop.dwPropertyID = DBPROP_IRowsetResynch;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_FALSE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // IConnectionPointContainer = True
        prop.dwPropertyID = DBPROP_IConnectionPointContainer;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        
        // BOOKMARKSKIPPED = True
        prop.dwPropertyID = DBPROP_BOOKMARKSKIPPED;
        V_VT(&prop.vValue) = VT_BOOL;
        V_BOOL(&prop.vValue) = VARIANT_TRUE;
        IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

        // IRowsetAsynch = ASK THE OSP PROVIDER!
        // Note: we assume OSP providers can actually answer the question this early.
        {
            BOOL fAsync = FALSE;
            prop.dwPropertyID = DBPROP_IDBAsynchStatus;
            V_VT(&prop.vValue) = VT_BOOL;
            V_BOOL(&prop.vValue) = (VARIANT_BOOL)TRUE; // we do support this interface
            IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));

            IGNORE_HR(GetpMetaOSP()->isAsync(&fAsync));
            prop.dwPropertyID = DBPROP_ROWSET_ASYNCH;
            V_VT(&prop.vValue) = VT_I4;
            V_I4(&prop.vValue) = fAsync ? (DBPROPVAL_ASYNCH_INITIALIZE |
                                           DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION |
                                           DBPROPVAL_ASYNCH_RANDOMPOPULATION)
                                        : 0 ;
            IGNORE_HR(_dbpProperties.SetProperty(DBPROPSET_ROWSET, prop));
        }
    }

Cleanup:
    if (hr && hr != E_OUTOFMEMORY)
    {
        hr = E_FAIL;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IColumnsInfo specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    GetColumnInfo (public member)
//
//  Synopsis:  Returns information on the rows in a table.  This can be
//             used to discover the number of columns in a table, the
//             types of information stored in each column, and the name/label
//             of each column.  In the case of the STD, columns will only
//             be holding variants, and the names of the columns are stored
//             in row #0 (used for labels).
//             The column information is returned in an array of structures,
//             each corresponding to a column in the table.
//             Note that the memory allocated for paInfo and ppStringsBuffer
//             must be deallocated by the caller of this function.
//             Column 0 does not return information about itself since it
//             is just a holder for labels.  However, element 0
//             of paInfo stores information about the "bookmark column."
//             This column does not actually exist in the rowset, but is
//             used so that accessors to bookmarks can be created.
//
//  Arguments: pcColumns        number of columns in table       (OUT)
//             paInfo           array of column-info structures  (OUT)
//             ppStringsBuffer  storage for strings              (OUT)
//
//  Returns:   Success if column-info can be constructed and returned.
//             Returns E_INVALIDARG if argument pointers are null.
//             Returns E_OUTOFMEMORY if can't allocate memory for structures.
//

STDMETHODIMP
CImpIRowset::GetColumnInfo(DBORDINAL *pcColumns,
                           DBCOLUMNINFO **paInfo,
                           OLECHAR **ppStringsBuffer )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetColumnInfo(%p {%p, %p, %p})",
             this, pcColumns, paInfo, ppStringsBuffer) );

    HRESULT hr = S_OK;
    ULONG cTempInfo;                      // num of cols in STD+1 (for bookmark)
    DBCOLUMNINFO *aTempInfo;              // temp data block for output
    OLECHAR *pTempStringsBuffer;          // temp string-buffer block for output
    ULONG cStringBufferRemaining = 0;     // chars in string-buffer block
    DBCOLUMNINFO *pTempColumn;            // used to index data in for-loop
    ULONG i;
    CSTDColumnInfo *pColInfo;
    OLECHAR *pstrTemp;                  // used to step through str buffer

    // Check that output variables aren't null:
    if (!pcColumns || !paInfo || !ppStringsBuffer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    cTempInfo = _cCols + 1;

    // In case of error, null outputs:
    *pcColumns = 0;
    *paInfo = NULL;
    *ppStringsBuffer = NULL;

    // we must have valid meta data from the OSP
    if (!_astdcolinfo)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Allocate memory for structures holding column information:
    aTempInfo =
        (DBCOLUMNINFO *)CoTaskMemAlloc(sizeof(DBCOLUMNINFO) * cTempInfo);
    if (!aTempInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Zero structure:
    memset(aTempInfo, '\0', sizeof(DBCOLUMNINFO) * cTempInfo);

// Now we will fill in the structures with actual column information.
// Since the strings in the table are supposed to be stored in one big
//   block, this pass through the structures will not yet allocate that block,
//   but instead calculate its size.  We will need to do a second pass on the
//   columns to actually copy the strings into the buffer.

    // We need to store information about the bookmarks column:
    pColInfo = _astdcolinfo;
    aTempInfo->columnid.eKind = DBKIND_GUID_PROPID;
    aTempInfo->columnid.uGuid.guid = DBCOL_SPECIALCOL;
    aTempInfo->columnid.uName.ulPropid = DBPROPVAL_BMK_KEY; // "self" bookmark
    Assert(!aTempInfo->pwszName);                       // no name
    Assert(!aTempInfo->iOrdinal);                       // column number 0 in mapper
    aTempInfo->wType = pColInfo->dwType;                // bookmark is 4 bytes
    Assert(!aTempInfo->pTypeInfo);
    aTempInfo->ulColumnSize = pColInfo->cbMaxLength;    // bookmark is 4 bytes
    aTempInfo->bPrecision = (BYTE)~0;                   // no precision
    aTempInfo->bScale = (BYTE)~0;                       // no scale
    aTempInfo->dwFlags = pColInfo->dwFlags;

    // construct the information about the OSP columns
    for (i = 1, pTempColumn = aTempInfo + 1, ++pColInfo;
         i < cTempInfo;
         ++i, ++pTempColumn, ++pColInfo )
    {
        pTempColumn->columnid.eKind = DBKIND_NAME;      // id is col name
        Assert(!pTempColumn->columnid.uName.pwszName);  // fill this in later
        Assert(!pTempColumn->pwszName);                 // fill this in later
        pTempColumn->iOrdinal = i;
        pTempColumn->wType = pColInfo->dwType;          // columns hold variants
        Assert(!pTempColumn->pTypeInfo);
        pTempColumn->ulColumnSize = pColInfo->cbMaxLength;
        pTempColumn->bPrecision = (BYTE)~0;         // no precision
        pTempColumn->bScale = (BYTE)~0;             // no scale
        pTempColumn->dwFlags = pColInfo->dwFlags;

        // Calculate length of string buffer..
        cStringBufferRemaining += FormsStringLen(pColInfo->bstrName) + 1;
    }

    // Allocate the string buffer:
    pTempStringsBuffer =
                (OLECHAR *)CoTaskMemAlloc(sizeof(OLECHAR) * cStringBufferRemaining);
    if (!pTempStringsBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto Error1;
    }

    // Fill the string buffer:
    pstrTemp = pTempStringsBuffer;
    
    for (i = 1, pTempColumn = aTempInfo + 1, pColInfo = _astdcolinfo + 1;
         i < cTempInfo;
         ++i, ++pTempColumn, ++pColInfo )
    {
        ULONG cTempLengthCopied = FormsStringLen(pColInfo->bstrName);
        
        // Set a pointer to this string:
        pTempColumn->pwszName = pstrTemp;
        // Also set id of column to this string:
        pTempColumn->columnid.uName.pwszName = pstrTemp;

        if (cTempLengthCopied > 0)
        {
            _tcsncpy(pstrTemp, pColInfo->bstrName, cTempLengthCopied);
            pstrTemp += cTempLengthCopied;
        }
        pstrTemp[0] = '\0';
        ++ pstrTemp;
        
        cStringBufferRemaining -= cTempLengthCopied + 1;
    }

    Assert("Buffer should be fully used" &&
        (cStringBufferRemaining == 0) );

    // Set output variables:
    *pcColumns = cTempInfo;
    *paInfo = aTempInfo;
    *ppStringsBuffer = pTempStringsBuffer;

Cleanup:
    return hr;

Error1:
    // NOTE: delete pTempStringsBuffer here if this is called after it exists
    // deallocate array of structures:
    CoTaskMemFree(aTempInfo);
    goto Cleanup;
}


//+-----------------------------------------------------------------------
//
//  Member:    MapColumnIDs
//
//  Synopsis:  Given an array of column IDs, returns an array of column
//             ordinals.  Note that the output array of column ordinals
//             is allocated by the caller, and only filled in by this
//             function.  Given the column ID of the bookmark column,
//             column ordinal 0 is returned.  The value DB_INVALIDCOLUMN
//             is returned as an index if the column ID was invalid.
//
//  Arguments: cColumnIDs       number of IDs in array
//             aColumnIDs       array of column IDs
//             aColumns         array of column ordinals         (OUT)
//
//  Returns:   Success if output array can be filled.
//             E_INVALIDARG if cColumnIDs>0 and no input or output array.
//             DB_S_ERRORSOCCURRED if some but not all column IDs were invalid
//             DB_E_ERRORSOCCURRED if all column IDs were invalid
//

STDMETHODIMP
CImpIRowset::MapColumnIDs(DBORDINAL cColumnIDs,
                          const DBID aColumnIDs [],
                          DBORDINAL aColumns [] )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::MapColumnIDs(%p {%u, %p, %p})",
             this, cColumnIDs, aColumnIDs, aColumns) );

    HRESULT hr = S_OK;
    DBORDINAL cErrors = 0;             // number of invalid column IDs
    DBORDINAL i;
    const DBID *pTempColID;        // used to index source col ids
    DBORDINAL *pTempColOrd;            // used to index dest col ordinals

    // Check arguments:
    if ((cColumnIDs && !aColumnIDs) ||
        !aColumns)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // must have valid metadata from OSP
    if (!_astdcolinfo)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Now translate column IDs:
    for (i = 0, pTempColID = aColumnIDs, pTempColOrd = aColumns;
         i < cColumnIDs;
         i++, pTempColID++, pTempColOrd++ )
    {
        const GUID *pguid = &pTempColID->uGuid.guid;// useful for bookmark check

        *pTempColOrd = DB_INVALIDCOLUMN;    // assume failure
        
        switch(pTempColID->eKind)
        {
        case DBKIND_PGUID_PROPID:
            pguid = pTempColID->uGuid.pguid;
            // FALL THRU
        case DBKIND_GUID_PROPID:
            if (IsEqualGUID(*pguid, DBCOL_SPECIALCOL)
                    && pTempColID->uName.ulPropid == DBPROPVAL_BMK_KEY)
            {
                *pTempColOrd = 0;         // bookmark column is 0;
            }
            break;
        case DBKIND_NAME:
            if (pTempColID->uName.pwszName != NULL)
            {
                ULONG uIndex;                      // index into column labels
                ULONG cNameLength = _tcslen(pTempColID->uName.pwszName);

                // Check columns to see if they match string:
                for (uIndex = 1; uIndex <= _cCols; uIndex++)
                {
                    BSTR bstrName = _astdcolinfo[uIndex].bstrName;
                    ULONG cColumnNameLen = FormsStringLen(bstrName);
                    
                    if (FormsIsEmptyString(bstrName))
                    {
                        continue;           // this column does not have a name
                    }
                    
                    // Compare strings:
                    // make sure they're the same lengths for match
                    if ((cNameLength == cColumnNameLen) &&
                        (!_tcsnicmp(pTempColID->uName.pwszName,
                                    cNameLength,
                                    bstrName,
                                    cNameLength )))
                    {
                        *pTempColOrd = uIndex; // found it
                        break;
                    }
                }
            }
            break;
        }

        // See if we didn't find a string match:
        if (*pTempColOrd == DB_INVALIDCOLUMN)
        {
            ++ cErrors;
        }
    }

    hr =    cErrors == 0 ?          S_OK :
            cErrors < cColumnIDs ?  DB_S_ERRORSOCCURRED :
                                    DB_E_ERRORSOCCURRED;

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\newrow.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      newrow.cxx
//  Author:    Ted Smith
//
//  Contents:  Implementation of RowsetNewRowAfter
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetNewRowAfter specific interface
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    SetNewDataAfter (public member)
//
//  Synopsis:  Create and initialize a new row in the STD.
//
//  Arguments: hChapter            chapter handle [IN]
//             cbBookmarkPrevious  number of bytes in the bookmark [IN]
//             pBookmarkPrevious   pointer to bookmark [IN]
//             hAccessor           Accessor to use [IN]
//             pData               Pointer to buffer of data to set [IN]
//             phRow               Row Handle [OUT]
//
//  Returns:   S_OK                    if data changed successfully
//             E_FAIL                  if Catch all (NULL pData, etc.)
//             E_OUTOFMEMORY           if output error array couldn't be allocated
//             DB_E_BADACCESSORHANDLE  if invalid accessor
//             DB_E_BADCHAPTER         if chapter passed in
//             DB_E_BADBOOKMARK        if bookmark was invalid.
//             DB_E_NOTREENTRANT       if illegal reentrancy
//

STDMETHODIMP
CImpIRowset::SetNewDataAfter(HCHAPTER    hChapter,
                             DBBKMARK    cbBookmarkPrevious,
                             const BYTE *pBookmarkPrevious,
                             HACCESSOR   hAccessor,
                             BYTE       *pData,
                             HROW       *phRow )
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::SetNewDataAfter(%p {%u %p %p %p})",
              this, cbBookmarkPrevious, pBookmarkPrevious, hAccessor, pData ));

    HRESULT hr;
    HRESULT hrBookmarkSkipped = S_OK;
    DBCOUNTITEM   ulIndex;
    DBROWCOUNT    cRowsInserted;
    HROW    hRow = NULL;
    HROW    *phRowSafe = (phRow ? phRow : &hRow);
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (FAnyPhaseInProgress(DBREASON_ROW_DELETE)
            || FAnyPhaseInProgress(DBREASON_ROW_INSERT))
    {
        hr = DB_E_NOTREENTRANT;
        goto Cleanup;
    }

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if (cbBookmarkPrevious == 0)
    {
        ulIndex = 1;
    }
    else if (pOSPData->_cSTDRows==0 && cbBookmarkPrevious==1 &&
             (*pBookmarkPrevious==DBBMK_FIRST || *pBookmarkPrevious==DBBMK_LAST))
    {
        ulIndex = 1;
    }
    else
    {
        hr = THR(Bookmark2HRowNumber(hChapter, cbBookmarkPrevious, pBookmarkPrevious,
                                     ulIndex));
        if (hr)
        {
            if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
            hrBookmarkSkipped = hr;
        }

        if (ulIndex > pOSPData->_cSTDRows)
        {
            hr = DB_S_BOOKMARKSKIPPED;
            ulIndex = pOSPData->_cSTDRows;
        }
        ulIndex += 1;                   // +1 to insert AFTER current row
    }
    Assert(ulIndex > 0 && ulIndex <= pOSPData->_cSTDRows + 1);

    hr = THR(GetpOSP(hChapter)->insertRows((LONG)ulIndex, 1, &cRowsInserted));
    if (hr)
    {
        if (hr != E_OUTOFMEMORY)
        {
            hr = E_FAIL;
        }
        goto Cleanup;
    }

    hr = THR(Index2HROW(hChapter, ulIndex, hRow));
    if (hr)
    {
        goto Error;
    }

    // TODO: set default values into the columns of the new row (by writing
    // no code, we're accepting whatever the STD happens to leave in memory
    // when it allocates the new row)

    // TODO: generate a notification that a new row is being added

    Assert(hRow != NULL);        
    // TODO ole-db will presumably change pData from (const BYTE*) to (void*)
    // someday, and this cast can go away
    hr = THR(SetData(hRow, hAccessor, (void*)pData));
    if (FAILED(hr))
    {
        goto Error;
    }
        
Cleanup:
    if ((phRow == NULL || hr) && hRow != NULL)
    {
        ReleaseRows(1, &hRow, NULL, NULL, NULL);
        hRow = NULL;
    }
    *phRowSafe = hRow;

    if (hr == S_OK)
        hr = hrBookmarkSkipped;
    return hr;
    
Error:
    GetpOSP(hChapter)->deleteRows((LONG) ulIndex, 1, &cRowsInserted);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\locate.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      locate.cxx
//  Author:    Ted Smith
//
//  Contents:  Implementation of RowsetLocate
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetLocate specific interfaces
//
////////////////////////////////////////////////////////////////////////////////

//+-----------------------------------------------------------------------
//
//  Member:    Bookmark2HRowNumber (private member)
//
//  Synopsis:  Figure out what a row number from a bookmark, given
//             arguments passed to various Nile methods.
//
//  Arguments: cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             rulRow           where to return row number
//
//  Returns:   S_OK             all OK.
//             DB_S_BOOKMARKSKIPPED if initial bookmark referred to
//                              to a deleted row
//             DB_E_BADBOOKMARK bad bookmark: malformed, row 0,
//                              or row > 0x7fffffff
//

HRESULT
CImpIRowset::Bookmark2HRowNumber(HCHAPTER hChapter, DBBKMARK cbBookmark,
                                 const BYTE *pBookmark, DBCOUNTITEM &rulRow)
{
    HRESULT hr = S_OK;
    DBCOUNTITEM ulRow;
    
    if (!pBookmark)
    {
        goto BadBookmark;
    }

    if (cbBookmark == 1)
    {
        if (*pBookmark == DBBMK_FIRST)
        {
            ulRow = 1;
        }
        else if (*pBookmark == DBBMK_LAST)
        {
            COSPData *pOSPData = GetpOSPData(hChapter);
            if (pOSPData)
            {
                ulRow = pOSPData->_cSTDRows;
            }
            else
            {
                hr = DB_E_BADCHAPTER;
                goto Cleanup;
            }
        }
        else
        {
            goto BadBookmark;
        }
    }
    else if (cbBookmark == sizeof(ULONG))
    {
        ulRow = IndexFromHRow((ChRow)(HROW)(* (ULONG *) pBookmark));
        if (FhRowDeleted((ChRow)(HROW)(* (ULONG *) pBookmark)))
        {
            hr = DB_S_BOOKMARKSKIPPED;  // Note this is not a fatal error!
        }
        if ((LONG) ulRow < 1)
        {
            goto BadBookmark;
        }
    }
    else
    {
        goto BadBookmark;
    }

    rulRow = ulRow;
    
Cleanup:
    return hr;

BadBookmark:
    hr = DB_E_BADBOOKMARK;
    goto Cleanup;
}


//+-----------------------------------------------------------------------
//
//  Member:    GenerateHRowsFromHRowNumber (private member)
//
//  Synopsis:  Returns a set of contiguous rows within the rowset, starting
//             at the specified HRow number (which may not correspond to
//             index if a deletion is in progress).  The user can allocate
//             memory for the returned row handles by setting pahRows
//             to a block of memory.  If it is NULL, this function will
//             allocate that memory using CoTaskMemAlloc.
//
//  Arguments: ulFirstRow       the row number of the first HROW to return
//             lRowsOffset      number of rows to skip over
//             cRows            rows to fetch and direction to fetch in
//             pcRowsObtained   rows obtained
//             pahRows          handles of rows obtained
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_S_BOOKMARKSKIPPED if initial HRowNumber referred to
//                              to a deleted row
//             DB_S_ENDOFROWSET if we straddled the end of the rowset,
//                              but didn't set DB_S_BOOKMARKSKIPPED
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADBOOKMARK if bookmark was invalid.
//             DB_E_NOTREENTRANT on re-entrancy problem
//             
//

HRESULT
CImpIRowset::GenerateHRowsFromHRowNumber(HCHAPTER hChapter, DBCOUNTITEM ulFirstRow,
                                         DBROWOFFSET lRowsOffset, DBROWCOUNT cRows, 
                                         DBCOUNTITEM *pcRowsObtained, HROW **pahRows )
{

    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::GenerateHRowsFromHRowNumber(%p {%u %d %d %p %p})",
              this, ulFirstRow, lRowsOffset, cRows, pcRowsObtained, pahRows ));

    const ULONG ucRows     = (cRows < 0 ? -cRows : cRows); // true count
    const int   sIncrement = (cRows < 0 ? -1     : 1);     // increment
    HRESULT     hr = S_OK;
    ULONG       cGetRows;               // number of rows to fetch
    BOOL        fEndOfRowset = FALSE;   // did we hit end of rowset?
    BOOL        fRowsAllocated = FALSE; // did we allocate space for the HROWs
    COSPData    *pOSPData = GetpOSPData(hChapter);

    Assert(pcRowsObtained);
    Assert(pahRows);

    // In case of errors:
    *pcRowsObtained = 0;

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if ((LONG) ulFirstRow < 0)
    {
        hr = DB_E_BADBOOKMARK;
        goto Cleanup;
    }
    

    ulFirstRow += lRowsOffset;

    // We know that index was non-negative before the above operation.
    // So we can only overflow with large positive index, lRowsOffset...
    // Check for numeric overflow, arrange for appropriate error below
    if ((LONG) ulFirstRow < 0 && lRowsOffset > 0)
    {
        ulFirstRow = pOSPData->_cSTDRows + 1;
    }

    // Now we need to figure out how many rows to fetch, so that we can
    //   allocate a memory block big enough to hold the handles.
    //   Calculate max number of rows which can be fetched in direction first.
    
    // If index is out of bounds, then we have either hit
    //  end of Rowset, or else we consider ourselves to have a bad bookmark.
    // TODO: once Nile spec details are finalized, we can do better than
    //  bad bookmark in some cases.
    {
        BOOL fTooSmall = (LONG) ulFirstRow < 1;

        if (fTooSmall || (ulFirstRow > pOSPData->_cSTDRows))
        {
            if ((cRows < 0) !=  fTooSmall)
            {
                hr = DB_E_BADSTARTPOSITION;
                goto Cleanup;
            }
            else
            {
                // DB_S_ENDOFROWSET will be set below
                ulFirstRow = cRows < 0 ? 0 : pOSPData->_cSTDRows + 1;
            }
        }
    }

    // compute maximum available rows
    Assert(sIncrement < 0 || ulFirstRow > 0);
    cGetRows = (sIncrement < 0 ? ulFirstRow : pOSPData->_cSTDRows - ulFirstRow + 1);
    if ((LONG) cGetRows < 0)
    {
        cGetRows = 0;
    }
    
    if (ucRows <= cGetRows)
    {
        cGetRows = ucRows;
    }
    else
    {
        fEndOfRowset = TRUE;     // passed end of rowset.  not a failure.
    }

    // Allocate memory block if we need to:
    if (!*pahRows)
    {
        *pahRows = (HROW *)CoTaskMemAlloc(sizeof(HROW) * cGetRows);
        if (!*pahRows)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        fRowsAllocated = TRUE;
    }

    // Setup returned HROWs:
    {
        HROW *phRows;
        ULONG i;

        for (i = cGetRows, phRows = *pahRows;
             i;
             i--, ulFirstRow += sIncrement )
        {
            hr = THR(HRowNumber2HROWQuiet(hChapter, ulFirstRow, *phRows++));
            if (hr)
            {
                ReleaseRowsQuiet(cGetRows - i, *pahRows);
                if (fRowsAllocated)
                {
                    CoTaskMemFree(*pahRows);
                    *pahRows = NULL;
                }
                goto Cleanup;
            }
        }
    }

    *pcRowsObtained = cGetRows;
    if (fEndOfRowset)
    {
            hr = DB_S_ENDOFROWSET;
    }
           
Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Index2HROWQuiet (private member)
//
//  Synopsis:  Wrapper to convert an index to a HROW, without generating
//             notification of row activation.  (Up to caller).
//
//  Arguments: ulIndex      row index to convert to HROW
//             rhrow        reference to fill in with HROW
//
//  Returns:   hr           S_OK or E_OUTOFMEMORY or DB_E_NOTREENTRANT
//

HRESULT
CImpIRowset::Index2HROW(HCHAPTER hChapter, DBCOUNTITEM ulIndex, HROW &rhrow)
{
    RRETURN2(HRowNumber2HROWQuiet(hChapter, ulIndex, rhrow),
             DB_E_NOTREENTRANT, E_OUTOFMEMORY);
}

//+-----------------------------------------------------------------------
//
//  Member:    HRowNumber2HROWQuiet (private member)
//
//  Synopsis:  Wrapper to convert a HRow number to a HROW, without generating
//             notification of row activation.  (Up to caller).
//
//  Arguments: ulHRowNumber HRow number to convert to HROW
//             rhrow        reference to fill in with HROW
//
//  Returns:   hr           S_OK or E_OUTOFMEMORY or DB_E_NOTREENTRANT
//

HRESULT
CImpIRowset::HRowNumber2HROWQuiet(HCHAPTER hChapter, DBCOUNTITEM ulHRowNumber, HROW &rhrow)
{

    HRESULT hr = S_OK;
    ChRow href;

    href = HRowFromIndex(hChapter, ulHRowNumber);
    if (href.FHrefValid())
    {
        rhrow = href.ToNileHRow();
    }
    else
    {
        // We have an implicit assumption that the ONLY reason
        // an rhrow could not be created was out of memory.
        hr = E_OUTOFMEMORY;
        rhrow = 0;
    }

    RRETURN2(hr, DB_E_NOTREENTRANT, E_OUTOFMEMORY);
}


//+-----------------------------------------------------------------------
//
//  Member:    HROW2Index (private member)
//
//  Synopsis:  Given a HROW return the index
//
//  Arguments: hRow         HROW to convert
//             rulIndex     reference to fill in row number
//
//  Returns:   S_OK, DB_E_BADROWHANDLE, DB_E_DELETEDROW
//

HRESULT
CImpIRowset::HROW2Index(HROW hRow, DBCOUNTITEM &rulIndex)
{
    HRESULT hr = S_OK;
    rulIndex = IndexFromHRow((ChRow) hRow);

    if (FhRowDeleted((ChRow) hRow))
    {
        hr = DB_E_DELETEDROW;
    }

    if (rulIndex == 0)
    {
        hr = DB_E_BADROWHANDLE;
    }

    RRETURN2(hr, DB_E_BADROWHANDLE, DB_E_DELETEDROW);
}

//+-----------------------------------------------------------------------
//
//  Member:    GetRowsAt (public member)
//
//  Synopsis:  Given a bookmark and offset, returns the cRows HROWs found there.
//
//  Arguments: hChapter         chapter handle
//             cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             lRowsOffset      offset from bookmark to first desired row
//             cRows            maximum number of HROWs to return
//             pcRowsObtained   number of HROWs actually returned  (OUT)
//             paRows           array of HROWs returned            (OUT)
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_S_ENDOFROWSET if we straddled the end of the rowset
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//             DB_E_BADSTARTPOSITION if the offset goes off the end
//                              or beginning of the rowset
//             DB_S_BOOKMARKSKIPPED if initial bookmark referred to
//                              to a deleted row


STDMETHODIMP
CImpIRowset::GetRowsAt(HWATCHREGION, HCHAPTER hChapter,
                       DBBKMARK cbBookmark,  const BYTE *pBookmark,
                       DBROWOFFSET  lRowsOffset,     DBROWCOUNT  cRows,
                       DBCOUNTITEM *pcRowsObtained, HROW **pahRows )
{
    HRESULT thr = S_OK;                 // "temporary" hr

    HRESULT hr;
    DBCOUNTITEM ulRow;

    hr = Bookmark2HRowNumber(hChapter, cbBookmark, pBookmark, ulRow);

    // Note under the old scheme DB_S_BOOKMARKSKIPPED was returned from
    // GenerateHRowsFromRowNumber.  That scheme was fake.  We must detect
    // deleted rows now while we still have a bookmark, because once we're
    // working in terms of row numbers deleted rows are invisible.
    if (hr)
    {
        if (FAILED(hr))
            goto Cleanup;
        thr = hr;
    }

    // adjust the offset to take the skipped bookmark into account
    if (hr==DB_S_BOOKMARKSKIPPED)
    {
        if (lRowsOffset > 0)
        {
            -- lRowsOffset;
        }
        else if (lRowsOffset < 0)
        {
            ++ lRowsOffset;
            -- ulRow;
        }
    }

    hr = THR(GenerateHRowsFromHRowNumber(hChapter, ulRow, lRowsOffset, cRows,
                                         pcRowsObtained, pahRows ));

    // If we already have DB_S_BOOKMARKSKIPPED, then it takes precedence
    // over any S_ code that GenerateHRowsFromHRowNumber may return.
    if (thr && SUCCEEDED(hr))
    {
        Assert(thr == DB_S_BOOKMARKSKIPPED);
        hr = thr;
    }

Cleanup:
    return hr;
}



//+-----------------------------------------------------------------------
//
//  Member:    Compare (public member)
//
//  Synopsis:  Compare two bookmarks
//
//  Arguments: hChapter         chapter handle
//             cbBookmark1      number of bytes in the first bookmark
//             pBookmark1       pointer to first bookmark
//             cbBookmark2      number of bytes in the second bookmark
//             pBookmark2       pointer to second bookmark
//             pComparison      pointer to answer                  (OUT)
//
//  Returns:   S_OK             if we could do the comparison
//             E_INVALIDARG     if output pointer is null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//

STDMETHODIMP
CImpIRowset::Compare(HCHAPTER hChapter,
                     DBBKMARK cbBookmark1, const BYTE *pBookmark1,
                     DBBKMARK cbBookmark2, const BYTE *pBookmark2,
                     DBCOMPARE *pComparison )
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::Compare(%p {%u %p %u %p})",
              this, cbBookmark1, pBookmark1, cbBookmark2, pBookmark2 ));

    HRESULT hr = S_OK;

    if (!pComparison || !pBookmark1 || !pBookmark2 ||
    	cbBookmark1==0 || cbBookmark2==0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pComparison = DBCOMPARE_NOTCOMPARABLE; // In case something goes wrong

    DBCOUNTITEM ulRow1, ulRow2;

    // special case: one of the bookmarks is "first" or "last"
    if (cbBookmark1 == 1 && (*pBookmark1==DBBMK_FIRST || *pBookmark1==DBBMK_LAST))
    {
        if (cbBookmark2 == 1 && *pBookmark1 == *pBookmark2)
            *pComparison = DBCOMPARE_EQ;
        else
            *pComparison = DBCOMPARE_NE;
        goto Cleanup;
    }
    else if (cbBookmark2 == 1 && (*pBookmark2==DBBMK_FIRST || *pBookmark2==DBBMK_LAST))
    {
        if (cbBookmark1 == 1 && *pBookmark1 == *pBookmark2)
            *pComparison = DBCOMPARE_EQ;
        else
            *pComparison = DBCOMPARE_NE;
        goto Cleanup;
    }

    // normal case: first check that the bookmarks have the right shape
    if (cbBookmark1 != sizeof(ULONG) || cbBookmark2 != sizeof(ULONG) )
    {
        hr = DB_E_BADBOOKMARK;
        goto Cleanup;
    }

    // We use Bookmark2HRowNumber because it does First & Last bookmark special
    // cases for us, as well as DeleteInProgress handling (which might be
    // relevant? -cfranks), as well as all the bad bookmark tests.
    hr = Bookmark2HRowNumber(hChapter, cbBookmark1, pBookmark1, ulRow1);
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }

    hr = Bookmark2HRowNumber(hChapter, cbBookmark2, pBookmark2, ulRow2);
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }

    *pComparison = ulRow1 <  ulRow2 ? DBCOMPARE_LT :
                     ulRow1 == ulRow2 ? DBCOMPARE_EQ :
                     DBCOMPARE_GT;

Cleanup:
    return hr;
}



//+-----------------------------------------------------------------------

STDMETHODIMP
CImpIRowset::GetRowsByBookmark(HCHAPTER    hChapter,
                               DBCOUNTITEM cRows,
                               const DBBKMARK acbBookmarks[],
                               const BYTE *apBookmarks[],
                               HROW        ahRows[],
                               DBROWSTATUS aRowStatus[] )
{
#if 0                                   // started, but incomplete -cfranks
    HRESULT thr = S_OK;                 // "temporary" hr
    ULONG i, j;
    ULONG ulRow;

    HRESULT hr;
    ULONG   ulRow;
    ULONG	cErrors = 0;		// number of rows with bad status

    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetRowsAt(%p {%u %p %i %i})",
          this, cbBookmark, pBookmark, lRowsOffset, cRows) );

    j = 0;                              // j is output index (pahRows)
    for(i=0; i<cRows; i++)              // i is input index (acbBookmarks)
    {

        hr = Bookmark2HRowNumber(hChapter, acbBookmark[i], apBookmark[i], ulRow);

        // Note under the old scheme DB_S_BOOKMARKSKIPPED was returned from
        // GenerateHRowsFromRowNumber.  That scheme was fake.  We must detect
        // deleted rows now while we still have a bookmark, because once we're
        // working in terms of row numbers deleted rows are invisible.
        if (hr)
        {
            // S_BOOKMARKSKIPPED is not allowed in this call, so we
            // turn the skipped flag into a E_DELETEDROW
            if (hr==DB_S_BOOKMARKSKIPPED)
                hr = DB_E_DELETEDROW;
        }
        else
        {
            hr = THR(GenerateHRowsFromHRowNumber(hChapter, ulRow, 0, 1,
                                                 pcRowsObtained, pahRows[j]));
        }

        // record the status of current requested row
        // TODO: redo GenHRows to provide better status
        DBROWSTATUS drsStatus = hr ? DBROWSTATUS_E_INVALID : DBROWSTATUS_S_OK;
        if (aRowStatus)
        {
            aRowStatus[i] = drsStatus;
        }

        // Unless there was a more serious error, we want to be careful
        // to return DB_S_BOOKMARKSKIPPED, if we had one.
        if (!hr) hr = thr;
    } // for (i=0; i!=cRows; i++)

Cleanup:
    return hr;
#else

//    FireRowEvent(*pcRowsObtained, *pahRows,
//                 DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT);

    return E_NOTIMPL; // TODO: Do this
#endif
}

//+-----------------------------------------------------------------------

STDMETHODIMP
CImpIRowset::Hash(HCHAPTER    hChapter,
                  DBBKMARK    cBookmarks, const DBBKMARK acbBookmarks[],
                  const BYTE *apBookmarks[],
                  DBHASHVALUE aHashedValues[],
                  DBROWSTATUS aBookmarkStatus[] )
{
    return E_NOTIMPL; // TODO: This routine changes drastically in June spec...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\coerce.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       coerce.cxx
//  Author:     Terry L. Lucas (TerryLu)
//
//  Contents:   Implemenation of data coercion for CImpIRowset object.
//


#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

MtDefine(CImpIRowsetDataCoerce_pData, DataBind, "CImpIRowset::DataCoerce pData")

////////////////////////////////////////////////////////////////////////////////
//
//  Internal support routines:
//
////////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//  Member:     CanConvert (public member)
//
//  Synopsis:   Inform our client about the type conversions we support
//
//  Arguments:  dwSrcType               Source data type
//              dwDstType               Destination data type
//              dwConvertFlags          0x0 for Rowset conversion
//                                      0x1 for Command conversion (irrevelant)
//
//  Returns:    S_OK                    Can convert
//              S_FALSE                   Unable to convert
//
STDMETHODIMP
CImpIRowset::CanConvert(DBTYPE wFromType,
                        DBTYPE wToType,
                        DBCONVERTFLAGS dwConvertFlags)
{
    HRESULT hr;

    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::CanConvert(%p {%p, %l, %l, %l})",
              this, wFromType, wToType, dwConvertFlags));

    if (dwConvertFlags != DBCONVERTFLAGS_COLUMN)
    {
        hr = DB_E_BADCONVERTFLAG;
        goto Cleanup;
    }
    
    // We can intraconvert any of these.
    hr = ((wFromType == DBTYPE_VARIANT    ||
           wFromType == DBTYPE_STR     ||
           wFromType == DBTYPE_BSTR    ||
           wFromType == DBTYPE_WSTR )  && (wToType == DBTYPE_VARIANT ||
                                           wToType == DBTYPE_STR     ||
                                           wToType == DBTYPE_BSTR    ||
                                           wToType == DBTYPE_WSTR ))
         ? S_OK : S_FALSE;

Cleanup:
    return hr;
}

#ifdef NEVER
//+---------------------------------------------------------------------------
//  Member:     DataCoerce_STR (private member)
//
//  Synopsis:   Convert source data type to a string buffer in pSrc.
//
//  Arguments:  uRow                    Current row
//              uCol                    Current column
//              fBSTR                   Keep the BSTR allocated in fact pDst
//                                      wants the BSTR address.
//              xferData                Information necessary to get/set data
//
//  Returns:    None
//

void
CImpIRowset::DataCoerce_STR (HCHAPTER hChapter, ULONG uRow, ULONG uCol,
                             BOOL fBSTR, XferInfo & xferData )
{
    HRESULT     hr;
    DBLENGTH    dblenBuffMaxCharLen;
    VARIANTARG  vari;
    VARIANTARG  variChange;
    VARIANTARG  *pVar = &variChange;

    *xferData.pdblenXferLength = 0;

    FastVariantInit(&vari);
    FastVariantInit(&variChange);

    // Get the string value of the cell..
    hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_FORMATTED, &vari);
    if (hr)
    {
        *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
        goto Cleanup;
    }

    // Compute the max # of characters capable of being in pData.
    dblenBuffMaxCharLen = xferData.dblenDataMaxLength / sizeof(TCHAR);

    Assert(dblenBuffMaxCharLen);                    // Can't be zero.

    switch (vari.vt)
    {
    case VT_EMPTY:
        // Former code.  See bug 7640.  (AndrewL)
        // Assert(!"Uninitialized rowset element (VT_EMPTY).");
        //*xferData.pwStatus = DBSTATUS_CANTCONVERTVALUE;
        //goto Cleanup;
        //
        // Fall through. This says that an uninitialized array of any size
        // is treated as though it were prefilled with nulls, which is 
        // pretty close to typical database behavior. 

    case VT_NULL:
        hr = S_FALSE;                           // Signal NULL data.
        break;

    case VT_BSTR:
    {
        if (!fBSTR)
        {
            pVar = &vari;
        }
        else
        {
            // Return the BSTR.
            *(BSTR *)xferData.pData = vari.bstrVal;
        }
        hr = S_OK;
        break;
    }

    default:
        Assert(!"getVariant didn't return BSTR!");        
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        goto Cleanup;
    }

    if (!hr)
    {
        // BSTR to free?
        if (fBSTR)
        {
            // No, we're keeping the BSTR therefore, the size is BSTR
            *xferData.pdbStatus = DBSTATUS_S_OK;
            *xferData.pdblenXferLength = sizeof(BSTR *);
        }
        else if (pVar->vt == VT_BSTR)
        {
            // Yes, don't return the BSTR copy it to the buffer passed.
            DBLENGTH cDataSz = SysStringLen(pVar->bstrVal);
            DBLENGTH dblenActual = (cDataSz < dblenBuffMaxCharLen) ? cDataSz :
                                                            dblenBuffMaxCharLen - 1;

            _tcsncpy((TCHAR *)xferData.pData, (TCHAR *)(pVar->bstrVal), dblenActual);
            ((TCHAR *)xferData.pData)[dblenActual] = _T('\0');

            SysFreeString(pVar->bstrVal);           // Release the BSTR.

            if (dblenBuffMaxCharLen > cDataSz)
            {
                *xferData.pdbStatus = DBSTATUS_S_OK;

                // Number of bytes.
                *xferData.pdblenXferLength = cDataSz * sizeof(TCHAR);
            }
            else
            {
                *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;

                // Number of bytes.
                *xferData.pdblenXferLength = xferData.dblenDataMaxLength;
            }
        }
        else
        {
            Assert(!"Should never get here, if so bigger problem above.");
            *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        }
    }
    else if (hr == S_FALSE)
    {
        // NULL value.
        *((TCHAR *)xferData.pData) = _T('\0');

        *xferData.pdbStatus = DBSTATUS_S_ISNULL;
    }
    else
    {
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
    }

Cleanup:
    ;
}
#endif


//+---------------------------------------------------------------------------
//  Member:     DataToWSTR (private member)
//
//  Synopsis:   Helper function to fetch or set WSTR data.  This is needed 3
//              times in DataCoerce, so we moved the common code out to this
//              routine.
//
//  Arguments:  dDirection              Get/Set the data to/from provider
//              hChapter                Chapter handle
//              uRow                    Row number
//              uCol                    Column number
//              xferData                Information used to get/set data
//
//  Returns:    Values based on Nile spec for GetData and SetData:
//              S_OK                    if everything is fine (or NULL)
//              DB_E_UNSUPPORTEDCONVERSION Could not coerce a column value
//              E_OUTOFMEMORY           Out of Memory (GetData only)
//              E_FAIL                  Serious conversion problems
//

HRESULT
CImpIRowset::DataToWSTR (DATA_DIRECTION dDirection, HCHAPTER hChapter,
                         ULONG uRow, ULONG uCol, XferInfo & xferData)
{
    HRESULT hr=S_OK;
    VARIANT tempVar;
    DBLENGTH dblenDataMaxChar;
    DBLENGTH dblenXferSize;

    *xferData.pdbStatus = DBSTATUS_S_OK;

    // Do we have data to set/get?
    if (xferData.pData != NULL)
    {
        if (dDirection == DataFromProvider)
        {
            dblenDataMaxChar = xferData.dblenDataMaxLength / sizeof(OLECHAR);
            
            FastVariantInit(&tempVar);
            hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_FORMATTED, &tempVar);

            if (hr == S_OK && tempVar.vt==VT_BSTR)
            {
                *xferData.pdblenXferLength = SysStringLen(tempVar.bstrVal);
                dblenXferSize = min(*xferData.pdblenXferLength,
                                dblenDataMaxChar ? dblenDataMaxChar-1 : 0);
                _tcsncpy((TCHAR *)xferData.pData, tempVar.bstrVal, dblenXferSize);

                // NULL terminate the string.
                if (dblenDataMaxChar)
                {
                    ((OLECHAR *)xferData.pData)[dblenXferSize] = _T('\0');
                }
                
                // Let our consumer know if we had more data than we could
                // transfer.
                if (*xferData.pdblenXferLength > dblenXferSize)
                    *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;
            }
            else
            {
                *((OLECHAR *)xferData.pData) = _T('\0');        // NULL value.
                if (hr==S_FALSE || (hr==S_OK && tempVar.vt!=VT_BSTR))
                {
                    *xferData.pdbStatus = DBSTATUS_S_ISNULL;
                    *xferData.pdblenXferLength = 0;
                    if (hr==S_OK)
                        VariantClear(&tempVar);
                    hr = S_OK;              // This is not an error to our caller.
                }
                else                                                    // failure
                {
                    // getVariant failed.  Assume it was unable
                    // to perform the conversion.
                    *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
                }
            }
        }
        else
        {
            FastVariantInit(&tempVar);
            // We now also deal with the case of SETTING a DBSTATUS_ISNULL..
            if (*xferData.pdbStatus!=DBSTATUS_S_ISNULL)
            {
                tempVar.vt = VT_BSTR;
                tempVar.bstrVal = SysAllocString((OLECHAR *)xferData.pData);
                if (tempVar.bstrVal == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_FORMATTED,
                                       tempVar);
                *xferData.pdblenXferLength = SysStringLen(tempVar.bstrVal);
                VariantClear(&tempVar);
            }
            else
            {
                tempVar.vt = VT_NULL;
                hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_RAW, tempVar);
            }

        }

        if (hr)
            *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
    }

    // The buffer length is always byte count not character count.
    // NOTE: The OLE-DB spec says DON'T COUNT THE NULL!!
    *xferData.pdblenXferLength = (*xferData.pdblenXferLength) * sizeof(OLECHAR);

Cleanup:
    return hr;
}
    

//+---------------------------------------------------------------------------
//  Member:     DataCoerce (private member)
//
//  Synopsis:   Convert the source data to the destination's format.  The
//              xferData describes the data to get/set, max length of the data,
//              and the status and length of data set/get.
//
//              Because STD mapper deals with only strings and variants, only
//              possible values for *xferData.pwStatus are DBSTATUS_OK,
//              DBSTATUS_ISNULL, DBSTATUS_CANTCONVERTVALUE,
//              and DBSTATUS_CANTCREATE.
//
//
//  Arguments:  dDirection              Get/Set the data to/from provider
//              hChapter                Chapter handle
//              uRow                    Row number
//              uCol                    Column number
//              xferData                Information used to get/set data
//
//  Returns:    Values based on Nile spec for GetData and SetData:
//              S_OK                    if everything is fine (or NULL)
//              DB_E_UNSUPPORTEDCONVERSION Could not coerce a column value
//              E_OUTOFMEMORY           Out of Memory (GetData only)
//              E_FAIL                  Serious conversion problems
//

HRESULT
CImpIRowset::DataCoerce (DATA_DIRECTION dDirection, HCHAPTER hChapter,
                         ULONG uRow, ULONG uCol, XferInfo & xferData)
{
    HRESULT hr = S_OK;
    WCHAR wchBuf[128];      // intermediate buffer to recieve WSTR.
    DBLENGTH dblenXferLength;   // length of intermediate WSTR received.
    XferInfo xferBuf;       // intermediate (WSTR) xfer info.

    xferBuf.pData = wchBuf;     // first xfer will be to intermediate

    // Do not allow the destination length and status to be aliased.
    Assert((void*)xferData.pdblenXferLength != (void*)xferData.pdbStatus);

    // We don't use arrays or byref of things. 
    if ( (xferData.dwAccType & DBTYPE_ARRAY) ||
         (xferData.dwAccType & DBTYPE_BYREF) ||
         (xferData.dwDBType  & DBTYPE_ARRAY) ||
         (xferData.dwDBType  & DBTYPE_BYREF) )
    {
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        goto Cleanup;
    }


    *xferData.pdbStatus = DBSTATUS_S_OK;

    switch (xferData.dwAccType)
    {

    case DBTYPE_VARIANT:
    {
        VARIANTARG *pVar = (VARIANTARG *)xferData.pData;

        if (xferData.pData != NULL)
        {
            if (dDirection == DataFromProvider)
            {
                FastVariantInit(pVar);      // for bad VB providers
                hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_RAW, pVar);
            }
            else
            {
                hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_RAW, *pVar);
            }

            *xferData.pdbStatus = hr ? DBSTATUS_E_CANTCREATE :
                                       DBSTATUS_S_OK;
        }
        
        // Just get the size of the string.
        *xferData.pdblenXferLength = sizeof(VARIANT);
        break;
    }

    case DBTYPE_BSTR:
        // Do we have data to set/get?
        if (xferData.pData == NULL)
            break;

        if (dDirection == DataFromProvider)
        {
            VARIANT tempVar;
            FastVariantInit(&tempVar);      // for bad VB providers
            hr = GetpOSP(hChapter)->getVariant(uRow, uCol, OSPFORMAT_FORMATTED, &tempVar);

            if (hr == S_OK && tempVar.vt == VT_BSTR)    // we got what we asked for
            {
                *(BSTR *)xferData.pData = tempVar.bstrVal;  // copy the BSTR ptr
            }
            else
            {
                *(BSTR *)xferData.pData = NULL;     // for people who ignore status
                // TODO The MFC-based TDC control returns DISP_E_TYPEMISMATCH when
                // asked for values from missing columns.  Treat as null for now.
                if (hr==DISP_E_TYPEMISMATCH ||
                    hr==S_FALSE || (hr==S_OK && tempVar.vt!=VT_BSTR))   // NULL
                {
                    *xferData.pdbStatus = DBSTATUS_S_ISNULL;
                    if (hr == S_OK)
                        VariantClear(&tempVar);
                }
                else                                                    // failure
                {
                    // getVariant failed.  Assume it was unable
                    // to perform the conversion.
                    *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
                }
            }
            *xferData.pdblenXferLength = sizeof(BSTR);
        }
        else
        {
            // else dDirection==DataToProvider ..
            VARIANT tempVar;
            tempVar.vt = VT_BSTR;
            tempVar.bstrVal = *(BSTR *)xferData.pData;
            hr = GetpOSP(hChapter)->setVariant(uRow, uCol, OSPFORMAT_FORMATTED, tempVar);
            if (FAILED(hr))
            {
                *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
            }
        }

        break;

    case DBTYPE_WSTR:
        // The whole DBTYPE_WSTR case contained a lot of code needed in
        // common with DBTYPE_STR, so its a subroutine here..
        hr = DataToWSTR (dDirection, hChapter, uRow, uCol, xferData);
        break;

    case DBTYPE_STR:
        xferBuf.pdblenXferLength = &dblenXferLength;
        xferBuf.dblenDataMaxLength = sizeof(wchBuf);
        xferBuf.pdbStatus = xferData.pdbStatus; // borrow client's status word

        // If we're setting data into the STD, then that data must be WSTR
        if (dDirection == DataToProvider)
        {
            // Get length of incoming char string in narrow chars (incl nul).
            dblenXferLength = strlen((char *) xferData.pData) + 1;

            // If there's any Chance the narrow char version won't fit in
            // wchBuf (worst case -- all single byte chars).
            if (dblenXferLength*sizeof(WCHAR) > sizeof(wchBuf))
            {
                xferBuf.dblenDataMaxLength = dblenXferLength;
                // then allocate a buffer instead
                xferBuf.pData = new(Mt(CImpIRowsetDataCoerce_pData)) WCHAR[dblenXferLength];
                if (!xferBuf.pData) // if alloc failed, quit, partial
                {                   // transfers are not desirable.
                    *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;
                    goto Cleanup;
                }
            }
                
            // Do the conversion to wide char into our buffer.
            // Note after this piont ulXferLength becomes a WCHAR count!
            dblenXferLength =
                 MultiByteToWideChar(CP_ACP, 0,              // CP & flags
                                     (char *)xferData.pData, // STR
                                     dblenXferLength,        // STR len
                                     (WCHAR *)xferBuf.pData, // WSTR
                                     (xferBuf.dblenDataMaxLength/
                                      sizeof(WCHAR))); // WSTR buf size

            
            // MultiByteToWideChar has a peculiar way of indicating errors
            if (xferBuf.dblenDataMaxLength!=0 && dblenXferLength==0)
            {
                if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
                {
                    *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;
                }
                goto Cleanup;
            }

            // *xferData.pulXferLength is a byte count, make sure to *2..
            *xferData.pdblenXferLength = dblenXferLength*sizeof(WCHAR);
            break;
        }

        // NOTE! This DataToWSTR call is shared by the To & From cases!
        hr = DataToWSTR (dDirection, hChapter, uRow, uCol, xferBuf);

        if (dDirection == DataFromProvider)
        {
            if (FAILED(hr))     // Note truncation is not considered failure!
            {
                // If our intermediate xfer failed, return error codes            
                // xferData.pdbStatus already set.
                *xferData.pdblenXferLength = dblenXferLength;
                break;
            }

            // If our internal buffer wasn't big enough we need to allocate
            // Note that ulXferLength here is in Bytes (set by DataToWSTR above)
            if (dblenXferLength > sizeof(wchBuf))
            {
                xferBuf.pData = new(Mt(CImpIRowsetDataCoerce_pData)) WCHAR[dblenXferLength/sizeof(WCHAR)];
                if (!xferBuf.pData)
                {
                    *xferData.pdbStatus = DBSTATUS_E_CANTCREATE;                    
                    goto Cleanup;
                }
                hr = DataToWSTR (dDirection, hChapter, uRow, uCol, xferBuf);
                if (FAILED(hr))
                    goto Cleanup;
            }

            *xferData.pdblenXferLength =
                 WideCharToMultiByte(CP_ACP, 0,                 // CP & flags
                                     (WCHAR *)xferBuf.pData,    // WSTR
                                     -1,                // WSTR len (null-terminated)
                                     (char *)xferData.pData,    // STR
                                     xferData.dblenDataMaxLength,  // STR buf size
                                     NULL, NULL);        // Default char & flag

            // WideCharToMultiByte has a peculiar way of indicating errors
            if (xferData.dblenDataMaxLength!=0 && *xferData.pdblenXferLength==0)
            {
                if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
                {
                    *xferData.pdbStatus = DBSTATUS_S_TRUNCATED;
                    // An even more peculiar way of getting the actual length req'd.
                    *xferData.pdblenXferLength =
                         WideCharToMultiByte(CP_ACP, 0,       // CP & flags
                                             (WCHAR *)xferBuf.pData, // WSTR
                                             dblenXferLength, // WSTR len
                                             NULL,            // STR (not used)
                                             0,               // STR len
                                             NULL, NULL);   // Default char & flag
                }
            }
            else
            {   // WideCharToMultiByte counts the terminating null character, but
                // OLE-DB doesn't
                -- *xferData.pdblenXferLength;
            }
        }
        break;

    default:
        //Assert(! "Unknown destination data type in DataCoerce.");
        *xferData.pdbStatus = DBSTATUS_E_CANTCONVERTVALUE;
        break;
    }

Cleanup:
    if (xferBuf.pData!=wchBuf)
    {
        delete xferBuf.pData;
    }

    switch (*xferData.pdbStatus)
    {
    case DBSTATUS_S_OK:
    case DBSTATUS_S_ISNULL:
        hr = S_OK;
        break;
    case DBSTATUS_E_CANTCREATE:
        hr = (dDirection == DataFromProvider) ? E_OUTOFMEMORY : E_FAIL;
        break;
    case DBSTATUS_S_TRUNCATED:
        hr = S_OK;
        break;
    default:
        hr = DB_E_UNSUPPORTEDCONVERSION;
        break;
    }

    RRETURN1(hr, DB_E_UNSUPPORTEDCONVERSION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\delete.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      delete.cxx
//  Authors:   Jerry Dunietz (jerryd@microsoft.com)
//             Ido Ben-Shachar (t-idoben@microsoft.com)
//
//  Contents:  Implementation of RowsetDelete
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetDelete specific interface
//
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\property.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Author:     Sam Bent (sambent)
//
//  Contents:   CDBProperties object implementation
//
//  History:
//  07/31/96    SamBent     Creation

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

DeclareTag(tagDBProperties, "CDBProperties", "OLE_DB provider properties");

MtDefine(CDBProperties, DataBind, "CDBProperties")
MtDefine(CDBProperties_aPropSets, CDBProperties, "CDBProperties::_aPropSets")
MtDefine(CDBProperties_rgProperties, CDBProperties, "CDBProperties::_aPropSets::_rgProperties")

////////////////////////////////////////////////////////////////////////////////
//
//  CDBProperties specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//  Member:     constructor (public member)
//
//  Synopsis:   instantiate a CDBProperties
//
//  Arguments:  none

CDBProperties::CDBProperties():
	_cPropSets(0),
	_aPropSets(0)
{
    TraceTag((tagDBProperties,
             "CDBProperties::constructor -> %p", this ));
}


//+---------------------------------------------------------------------------
//  Member:     destructor (public member)
//
//  Synopsis:   release storage used by CDBProperties

CDBProperties::~CDBProperties()
{
    TraceTag((tagDBProperties,
             "CDBProperties::destructor -> %p", this ));

	ULONG iPropSet;
	for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
	{
		delete [] _aPropSets[iPropSet].rgProperties;
	}
	delete [] _aPropSets;
}


//+---------------------------------------------------------------------------
//  Member:     GetPropertySet (public member)
//
//  Synopsis:   look up a property set by its GUID
//
//  Arguments:  guid            GUID of desired property set
//
//  Returns:    pointer to desired property set, or 0 if not found

DBPROPSET*
CDBProperties::GetPropertySet(const GUID& guid) const
{
    TraceTag((tagDBProperties,
             "CDBProperties::GetPropertySet({%p} %p)", this, guid ));

	DBPROPSET* pPropSet = 0;		// the answer, assume not found
	
	// linear search
	ULONG iPropSet;
	for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
	{
		if (IsEqualGUID(guid, _aPropSets[iPropSet].guidPropertySet))
		{
			pPropSet = &_aPropSets[iPropSet];
			break;
		}
	}

	return pPropSet;
}


//+---------------------------------------------------------------------------
//  Member:     CopyPropertySet (public member)
//
//  Synopsis:   make a copy of a property set, given its GUID
//
//  Arguments:  guid            GUID of desired property set
//              pPropSetDst     ptr to DBPROPSET where copy should go
//
//  Returns:    S_OK            it worked
//              E_OUTOFMEMORY   no bytes
//              E_FAIL          no property set for given GUID

HRESULT
CDBProperties::CopyPropertySet(const GUID& guid, DBPROPSET* pPropSetDst) const
{
    TraceTag((tagDBProperties,
             "CDBProperties::CopyPropertySet({%p} %p, %p)", this, guid, pPropSetDst ));
    Assert(pPropSetDst && "must supply a PropSet pointer");

    HRESULT hr = S_OK;
	const DBPROPSET* pPropSetSrc = GetPropertySet(guid);
	ULONG iProp;

    if (pPropSetSrc == 0)       // not found
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // start with shallow copy
    *pPropSetDst = *pPropSetSrc;
    
    // allocate property array
    pPropSetDst->rgProperties = (DBPROP*)
                    CoTaskMemAlloc(pPropSetSrc->cProperties * sizeof(DBPROP));
    if (pPropSetDst->rgProperties == 0)
    {
        pPropSetDst->cProperties = 0;       // defensive
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // copy the property array
    for (iProp=0; iProp<pPropSetSrc->cProperties; ++iProp)
    {
        pPropSetDst->rgProperties[iProp] = pPropSetSrc->rgProperties[iProp];
    }
    
Cleanup:
	return hr;
}


//+---------------------------------------------------------------------------
//  Member:     GetProperty (public member)
//
//  Synopsis:   look up a property by its property set GUID and ID.
//
//  Arguments:  guid            guid of desired property
//              dwId            id of desired property
//
//  Returns:    pointer to DBPROP for the property, or 0 if not found

const DBPROP*
CDBProperties::GetProperty(const GUID& guid, DBPROPID dwId) const
{
    TraceTag((tagDBProperties,
             "CDBProperties::GetProperty({%p} %p, %lu)", this, guid, dwId ));

	ULONG iProp;
	const DBPROPSET* pPropSet = GetPropertySet(guid);
	const DBPROP*	pProp = 0;		// the answer, assume not found

	if (pPropSet == 0)			// no properties for desired property set
		goto Cleanup;
	
	// look up the desired property in the property set
	for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
	{
		if (dwId == pPropSet->rgProperties[iProp].dwPropertyID)
		{
			pProp = & pPropSet->rgProperties[iProp];
			break;
		}
	}

Cleanup:
	return pProp;
}


//+---------------------------------------------------------------------------
//  Member:     SetProperty (public member)
//
//  Synopsis:   add a new property, or reset an existing one
//
//  Arguments:  guid			property set GUID of desired property
//								prop.dwPropertyID contains its ID.
//				prop			(reference to) DBPROP describing new property.
//
//  Returns:    S_OK            property added/reset
//              E_OUTOFMEMORY   no memory for new property set or new property

HRESULT
CDBProperties::SetProperty(const GUID& guid, const DBPROP& prop)
{
    TraceTag((tagDBProperties,
             "CDBProperties::SetProperty({%p}, %p, %p)", this, guid, prop ));

	HRESULT hr;
	DBPROP *pProp;			// pointer to array entry for new property
	ULONG iProp;
	DBPROPSET* pPropSet = GetPropertySet(guid);

	if (pPropSet == 0)				// no properties yet in desired property set
	{
		ULONG iPropSet;
		
		// get a new property set array
		DBPROPSET * aNewPropSets = new(Mt(CDBProperties_aPropSets)) DBPROPSET[_cPropSets + 1];
		if (aNewPropSets == 0)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}

		// copy the old array into the new
		for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
		{
			aNewPropSets[iPropSet] = _aPropSets[iPropSet];
		}

		// add the new property set
		pPropSet = & aNewPropSets[_cPropSets];
		pPropSet->guidPropertySet = guid;
		pPropSet->cProperties = 0;
		pPropSet->rgProperties = 0;

		// release the old array, install the new one
		delete [] _aPropSets;
		_aPropSets = aNewPropSets;
		++ _cPropSets;
	}

	// look for the desired property.
	pProp = 0;
	for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
	{
		if (pPropSet->rgProperties[iProp].dwPropertyID == prop.dwPropertyID)
		{
			pProp = &pPropSet->rgProperties[iProp];
			break;
		}
	}

	// if it's a new property, add it.  OLE-DB doesn't provide for any "unused"
	// portion in the array of DBPROPS, so we must reallocate the array every
	// time we add a property.  
	if (pProp == 0)
	{
		// allocate new property array
		DBPROP* aNewProperties = new(Mt(CDBProperties_rgProperties)) DBPROP[pPropSet->cProperties + 1];
		if (aNewProperties == 0)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}

		// copy old array into new
		for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
		{
			aNewProperties[iProp] = pPropSet->rgProperties[iProp];
		}

		// prepare to use new property entry
		pProp = & aNewProperties[pPropSet->cProperties];

		// release old array, install new
		delete [] pPropSet->rgProperties;
		pPropSet->rgProperties = aNewProperties;
		++ pPropSet->cProperties;
	}

	// copy the property into my array
	*pProp = prop;

	hr = S_OK;

Cleanup:
	RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\rowset.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       rowset.cxx
//  Author:     Terry L. Lucas (TerryLu)
//
//  Contents:   CImpIRowset object implementation
//
//  History:
//  07/18/95    TerryLu     Creation of Nile provider implementation.
//  07/28/95    TerryLu     Removed aggregation possiblity for now (no pUnk...).
//  08/02/95    Ido         GetRowsetInfo returns appropriate flags.
//  08/07/95    TerryLu     Added IConnectionPointContainer & IConnectionPoint.
//  08/14/95    TerryLu     Removed IConnectionPointContainer and used CBase.
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include <connect.hxx>
#endif

#ifndef X_COREDISP_H_
#define X_COREDISP_H_
#include "coredisp.h"
#endif

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

DeclareTag(tagNileRowsetProvider, "CImpIRowset", "STD Nile provider");
MtDefine(CImpIRowset, DataBind, "CImpIRowset")
MtDefine(CTopRowset, DataBind, "CTopRowset")
MtDefine(CChapRowset, DataBind, "CChapRowset")
MtDefine(COSPData, DataBind, "COSPData")

const CONNECTION_POINT_INFO CImpIRowset::s_acpi[] =
{
    CPI_ENTRY(IID_IRowsetNotify, DISPID_A_ROWSETNOTIFYSINK)
    CPI_ENTRY(IID_IDBAsynchNotify, DISPID_A_ROWSETASYNCHNOTIFYSINK)
    CPI_ENTRY_NULL
};


const CImpIRowset::CLASSDESC CImpIRowset::s_classdesc =
{
        NULL,                               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
};



//+---------------------------------------------------------------------------
//  Member:     Constructor (public member)
//
//  Synopsis:   Instanciate an IRowset
//
//  Arguments:  None
//
//  Returns:    None

CImpIRowset::CImpIRowset ()
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::constructor -> %p", this ));

#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
#endif

    CBase::Init();

    _NextH2R = 1;                       // for rowmap (vestigial)
    _pUnkOuter = getpIUnknown();
}



//+---------------------------------------------------------------------------
//  Member:     Destructor (public member)
//
//  Synopsis:   Cleanup the IRowset
//
//  Arguments:  None
//
//  Returns:    None

CImpIRowset::~CImpIRowset ()
{
    TraceTag((tagNileRowsetProvider, "CImpIRowset::destructor() -> %p", this));
}



////////////////////////////////////////////////////////////////////////////////
//
//  CBase specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//  Member:     PrivateQueryInterface (public member)
//
//  Synopsis:   Private QI come to here for CBase derived objects.
//
//  Arguments:  riid            IID of requested interface
//              ppv             Interface object to return
//
//  Returns:    S_OK            Interface supported
//              E_NOINTERFACE   Interface not supported.
//

STDMETHODIMP
CImpIRowset::PrivateQueryInterface (REFIID riid, LPVOID * ppv)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::QueryInterface(%p {%p, %p})", this, riid, ppv ));

    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = getpIUnknown();
    }
#define TEST(IFace) else if (IsEqualIID(riid, IID_##IFace)) *ppv = (IFace *)this

    TEST(IRowset);
    TEST(IAccessor);
    TEST(IColumnsInfo);
    TEST(IRowsetLocate);
    TEST(IChapteredRowset);
    TEST(IRowsetChange);
    TEST(IRowsetScroll);
    TEST(IRowsetExactScroll);
    TEST(IRowsetNewRowAfter);
    TEST(IRowsetIdentity);
    TEST(IRowsetChapterMember);
    TEST(IRowsetFind);
    TEST(IRowsetInfo);
    TEST(IConvertType);
    TEST(IDBAsynchStatus);
    TEST(IRowsetFind);
    
#undef TEST

    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
    {
        *((IConnectionPointContainer **)ppv) =
                                            new CConnectionPointContainer(this, NULL);
        if (!*ppv)
        {
            RRETURN(E_OUTOFMEMORY);
        }
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//  Member:     Passivate (public member)
//
//  Synopsis:   Called when main CImpIRowset reference count (_ulRefs) drops
//              to zero. Do not call this method directly.  Use Release instead.
//
//  Arguments:  None
//
//  Returns:    Nothing
//

void
CImpIRowset::Passivate ()
{
    FireRowsetEvent(DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT);

    if (_astdcolinfo)
    {
        // If there are subsidary chapters rowsets, clear them.
        // (Column 0, the bookmark column can never have one).
        for (ULONG uCol = 1; uCol <= _cCols; uCol++)
        {
            if (_astdcolinfo[uCol].pChapRowset)
                _astdcolinfo[uCol].pChapRowset->Release();

            FormsFreeString(_astdcolinfo[uCol].bstrName);
        }

        delete [] _astdcolinfo;
    }

    // release all live accessors
    while (!_dblAccessors.IsEmpty())
    {
        ULONG ulRefcount;
        HACCESSOR hAccessor = (HACCESSOR) _dblAccessors.First();
        ReleaseAccessor(hAccessor, &ulRefcount);
    }
    
    CBase::Passivate();
}

void
CTopRowset::Passivate()
{
    ClearInterface(&_pOSPData);

    super::Passivate();
}

CTopRowset::~CTopRowset()
{
    Assert(!_pOSPData && "Rowset released before Passivate!");
}


//+---------------------------------------------------------------------------
//  Member:     GetClassDesc (public member)
//
//  Synopsis:   Return the class descriptor, we only use the descriptor to
//              describe the number of connection points our container can
//              handle and the connection points.
//
//  Arguments:  None
//
//  Returns:    CLASSDESC
//

const CBase::CLASSDESC *
CImpIRowset::GetClassDesc () const
{
    return &s_classdesc;
}


////////////////////////////////////////////////////////////////////////////////
//
//  IRowset specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


#if DBG == 1

ULONG
MaxLengthOfBinding(const DBBINDING &currBinding)
{
    ULONG ulReturn;
    
    switch (currBinding.wType)
    {
        // these are the variable-length types listed in OLE-DB manual Appendix A.
    case DBTYPE_STR:
    case DBTYPE_BYTES:
    case DBTYPE_WSTR:
    case DBTYPE_VARNUMERIC:
        ulReturn = currBinding.cbMaxLen;
        break;

        // and these are the fixed-length types
    case DBTYPE_I2:             ulReturn = sizeof(SHORT);           break;
    case DBTYPE_I4:             ulReturn = sizeof(LONG);            break;
    case DBTYPE_R4:             ulReturn = sizeof(float);           break;
    case DBTYPE_R8:             ulReturn = sizeof(double);          break;
    case DBTYPE_CY:             ulReturn = sizeof(LARGE_INTEGER);   break;
    case DBTYPE_DATE:           ulReturn = sizeof(DATE);            break;
    case DBTYPE_BSTR:           ulReturn = sizeof(BSTR);            break;
    case DBTYPE_IDISPATCH:      ulReturn = sizeof(IDispatch*);      break;
    case DBTYPE_ERROR:          ulReturn = sizeof(SCODE);           break;
    case DBTYPE_BOOL:           ulReturn = sizeof(VARIANT_BOOL);    break;
    case DBTYPE_VARIANT:        ulReturn = sizeof(VARIANT);         break;
    case DBTYPE_IUNKNOWN:       ulReturn = sizeof(IUnknown*);       break;
    case DBTYPE_DECIMAL:        ulReturn = sizeof(DECIMAL);         break;
    case DBTYPE_UI1:            ulReturn = sizeof(BYTE);            break;
    case DBTYPE_I1:             ulReturn = sizeof(BYTE);            break;
    case DBTYPE_UI2:            ulReturn = sizeof(USHORT);          break;
    case DBTYPE_UI4:            ulReturn = sizeof(ULONG);           break;
    case DBTYPE_I8:             ulReturn = sizeof(LARGE_INTEGER);   break;
    case DBTYPE_UI8:            ulReturn = sizeof(ULARGE_INTEGER);  break;
    case DBTYPE_GUID:           ulReturn = sizeof(GUID);            break;
    case DBTYPE_VECTOR:         ulReturn = sizeof(DBVECTOR);        break;
    case DBTYPE_NUMERIC:        ulReturn = sizeof(DB_NUMERIC);      break;
    case DBTYPE_DBDATE:         ulReturn = sizeof(DBDATE);          break;
    case DBTYPE_DBTIME:         ulReturn = sizeof(DBTIME);          break;
    case DBTYPE_DBTIMESTAMP:    ulReturn = sizeof(DBTIMESTAMP);     break;
    case DBTYPE_HCHAPTER:       ulReturn = sizeof(HCHAPTER);        break;
    case DBTYPE_FILETIME:       ulReturn = sizeof(FILETIME);        break;
    case DBTYPE_PROPVARIANT:    ulReturn = sizeof(PROPVARIANT);     break;

        // finally, in case we missed something...
    default:
        AssertSz(0, "Unexpected type");
        ulReturn = currBinding.cbMaxLen;
        break;
    }

    return ulReturn;
}


//+---------------------------------------------------------------------------
//  Member:     DbgCheckOverlap (private member only in debug build)
//
//  Synopsis:   Verifies that a DBBINDING does not have any value, length or
//              status data overlap. Overlap problem will assert.
//
//  Arguments:  currBinding     Binding to validate
//
//  Returns:    None
//

void
CImpIRowset::DbgCheckOverlap (const DBBINDING &currBinding)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::DbgCheckOverlap({%p})", &currBinding ));

    DBPART    currPart = currBinding.dwPart;
    short     sCount = 0;
    ULONG     left[3], right[3];

    if (currPart & DBPART_VALUE)
    {
        left[sCount] = currBinding.obValue;
        right[sCount] = left[sCount] + MaxLengthOfBinding(currBinding) - 1;
        sCount++;
    }

    if (currPart & DBPART_LENGTH)
    {
        left[sCount] = currBinding.obLength;
        right[sCount] = left[sCount] + sizeof(ULONG) - 1;
        sCount++;
    }

    if (currPart & DBPART_STATUS)
    {
        left[sCount] = currBinding.obStatus;
        right[sCount] = left[sCount] + sizeof(ULONG) - 1;
        sCount++;
    }

    // More than one comming in, check overlapping.
    if (((sCount > 1) &&
         ((left[0] <= right[1]) && (right[0] >= left[1])) ) || /*0 & 1 intersect*/
        ((sCount > 2)                                     &&
         (((left[1] <= right[2]) && (right[1] >= left[2]))  || /*1 & 2 intersect*/
          ((left[0] <= right[2]) && (right[0] >= left[2])) ))) /*0 & 2 intersect*/
    {
        Assert(!"Accessor values overlap");
    }
}
#endif  // DBG == 1



//+---------------------------------------------------------------------------
//  Member:     CreateAccessor (public member)
//
//  Synopsis:   Creates a set of bindings that can be used to send data
//              to or retrieve data from the data cache.
//
//  Arguments:  eAccFlags           How bindings are used
//              cBindings           Number of Bindings
//              aBindings           Array of DBBINDINGS
//              cbRowSize           ignored -- only used for IReadData
//              phAccessor          Accessor Handle
//              aStatus             Array of status words, one per binding
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_OUTOFMEMORY           Couldn't allocate memory
//              E_INVALIDARG            Invalid arg
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORFLAGS   Bad eAccFlags
//              DB_E_BYREFACCESSORNOTSUPPORTED  Can't support PASSBYREF
//              DB_E_ERRORSOCCURRED     One or more bindings failed, see aStatus
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//              DB_E_NULLACCESSORNOTSUPPORTED   No bindings.
//

STDMETHODIMP
CImpIRowset::CreateAccessor (DBACCESSORFLAGS eAccFlags,
                             DBCOUNTITEM cBindings,
                             const DBBINDING aBindings[],
                             DBLENGTH /* cbRowSize */,
                             HACCESSOR * phAccessor,
                             DBBINDSTATUS aStatus[])
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::CreateAccessor(%p {%p, %u, %p, %p, %p})",
             this,
             eAccFlags, cBindings, aBindings, phAccessor, aStatus ));

    HRESULT             hr = S_OK;
    AccessorFormat      *pAccessor;
    ULONG               ibind;
    ULONG               icol;
    ULONG               cValidBindings = 0;  // number of validated bindings

    // Check Parameters
    if (phAccessor == NULL || (cBindings>0 && aBindings==NULL))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *phAccessor = NULL;

    // Do a quick check to make sure we recognize the binding type.
    // TODO: should we silently ignore DBACCESSOR_OPTIMIZE?
    if (eAccFlags != DBACCESSOR_ROWDATA)
    {
            hr = DB_E_BADBINDINFO;
            goto Cleanup;
    }

    // Sanity check on the bindings the user gave us.
    // Specifically hunt down some common client coding bugs.
    for (ibind = 0; ibind < cBindings; ibind++)
    {
        const DBBINDING &   currBinding = aBindings[ibind];
        DBPART              currPart = currBinding.dwPart;
        DBBINDSTATUS        dbsStatus = DBBINDSTATUS_OK;

        icol = currBinding.iOrdinal;
        if (icol > (_cCols + 1))        // +1 for bookmark info
        {
            Assert(!"Bad column number");
            dbsStatus = DBBINDSTATUS_BADORDINAL;
        }

        // At least one of these valid parts has to be set. In SetData I assume it is.
        if (!(currPart & (DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS)))
        {
            Assert(!"dwPart missing VALUE, LENGTH or STATUS being specified");
            dbsStatus = DBBINDSTATUS_BADBINDINFO;
        }

        // other binding problems forbidden by OLE-DB
        const DBTYPE currType = currBinding.wType;
        const DBTYPE currTypePtr = currType &(DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR);
        const DBTYPE currTypeBase = currType & 0xffff;
        if (
            // part other than value, length, or status
            (currPart & ~(DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS)) ||
            // type is empty or null
            (currType==DBTYPE_EMPTY || currType==DBTYPE_NULL) ||
            // byref or'd with empty, null, or reserved
            (currType&DBTYPE_BYREF && (currTypeBase==DBTYPE_EMPTY ||
                                       currTypeBase==DBTYPE_NULL || currType&DBTYPE_RESERVED)) ||
            // more than one of byref, array, and vector
            (!(currTypePtr==0 || currTypePtr==DBTYPE_BYREF ||
               currTypePtr==DBTYPE_ARRAY || currTypePtr==DBTYPE_VECTOR)) ||
            // provider owned memory for non-pointer type
            (!currTypePtr && currBinding.dwMemOwner==DBMEMOWNER_PROVIDEROWNED)
           )
        {
            dbsStatus = DBBINDSTATUS_BADBINDINFO;
        }

        // we only support client owned memory
        if (currBinding.dwMemOwner != DBMEMOWNER_CLIENTOWNED)
            dbsStatus = DBBINDSTATUS_BADBINDINFO;
        
        CSTDColumnInfo &  stdColInfo = _astdcolinfo[ColToDBColIndex(icol)];

        // Check for legal type conversion
        if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK)
        {
            // For bookmarks, we support an explicit list of target types.
            if ((currBinding.wType != (DBTYPE_UI1 | DBTYPE_VECTOR)) &&
                (currBinding.wType != DBTYPE_BYTES) &&
                (currBinding.wType != DBTYPE_I4) &&
                (currBinding.wType != DBTYPE_UI4)) // sign confusion in DLcursor
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
            // furthermore, consumer must give us enough room for the bookmark
            if (currBinding.wType == DBTYPE_BYTES &&
                currBinding.cbMaxLen < sizeof(HROW))
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
        }
        else if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER)
        {
            if (currBinding.wType != DBTYPE_HCHAPTER)
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
        }
        else
        {   // for non-bookmarks, use my IConvertType::CanConvert
            if (CanConvert(stdColInfo.dwType, currBinding.wType,
                           DBCONVERTFLAGS_COLUMN) != S_OK)
            {
                dbsStatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
            }
        }

        // Check for correct sizing of types.
        // Sometimes macros are used which do sizeof(), but specify wrong type.
        // (i.e. bind a char[20] as a DWORD.)

// TODO: Need to implement NOW ***TLL***
//        if (FAILED(CheckSizeofDBType(aBindings[ibind].dwType,
//                                     aBindings[ibind].cbMaxLen )))
//        {
//            hr = E_FAIL;
//            goto Cleanup;
//        }

        if (aStatus)
            aStatus[ibind] = dbsStatus;
        if (dbsStatus == DBBINDSTATUS_OK)
        {
            ++ cValidBindings;
        }

#if DBG == 1
        DbgCheckOverlap(currBinding);
#endif  // DBG == 1
    }

    if (cValidBindings < cBindings)
    {
        goto Cleanup;
    }
    
    // Make a copy of the client's binding array, and the type of binding.
    // We could potentially give out direct ptrs to the structure.
    // Note: Accessors with no bindings (cBindings = 0) are legal, that is the
    //       AccessorFormat for a null accessor has just the dwAccFlags and
    //       cBindings fields the aBindings[] is not allocated.

    pAccessor = new(cBindings) AccessorFormat(1, eAccFlags, cBindings, aBindings);
    if (pAccessor == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // add the accessor to the active list
    _dblAccessors.Append(pAccessor);
    
    *phAccessor = (HACCESSOR)pAccessor;

    hr = S_OK;

Cleanup:
    if (hr == S_OK)     // no global errors, check whether bindings worked
        hr = cValidBindings<cBindings   ? DB_E_ERRORSOCCURRED
                                        : S_OK;
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     GetBindings (public member)
//
//  Synopsis:   Returns the bindings in an accessor
//
//  Arguments:  hAccessor       Accessor Handle
//              peAccFlags      Accessor Type flag
//              pcBindings      Number of Bindings returned
//              paBindings      Bindings
//
//  Returns:    S_OK                    if everything is fine,
//              E_INVALIDARG            peAccFlags/pcBinding/paBinding was NULL
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::GetBindings (HACCESSOR hAccessor,
                          DBACCESSORFLAGS * peAccFlags,
                          DBCOUNTITEM * pcBindings,
                          DBBINDING ** paBindings )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetBindings(%p {%p, %p, %p, %p})",
             this, hAccessor, peAccFlags, pcBindings, paBindings ));

    HRESULT     hr = S_OK;
    ULONG       cBindingSize;

    Assert(hAccessor);

    // Retrieve our accessor structure from the client's hAccessor,
    // make a copy of the bindings for the user, then done.
    AccessorFormat    *pAccessor = (AccessorFormat *)hAccessor;

    // Check Other Parameters
    if (!(peAccFlags && pcBindings && paBindings))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Set values that should be returned if an error occurrs
    *peAccFlags = DBACCESSOR_INVALID;
    *pcBindings = 0;
    *paBindings = NULL;

    // Allocate and return Array of bindings
    cBindingSize = pAccessor->cBindings * sizeof(DBBINDING);
    *paBindings = (DBBINDING *)CoTaskMemAlloc(cBindingSize);
    if (*paBindings)
    {
        *peAccFlags  = pAccessor->dwAccFlags;
        *pcBindings = pAccessor->cBindings;
        memcpy(*paBindings, pAccessor->aBindings, cBindingSize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


HRESULT
CImpIRowset::EnsureReferencedRowset(HCHAPTER hChapter, ULONG uStdRow, ULONG icol,
                                    OLEDBSimpleProvider **ppOSP)
{
    HRESULT hr = S_OK;
    VARIANT varOSP;             // Variant to hold returned OSP
    OLEDBSimpleProvider *pOSP = NULL;
    OLEDBSimpleProvider *pOSPparent;
    CSTDColumnInfo& stdColInfo = _astdcolinfo[ColToDBColIndex(icol)];
    VariantInit(&varOSP);

    // if the call was made only to create the child rowset, and it already
    // exists, there's nothing to do.
    if (stdColInfo.pChapRowset != NULL && ppOSP == NULL)
        goto Cleanup;

    if (stdColInfo.dwType != DBTYPE_HCHAPTER)
    {
        hr = DB_E_NOTAREFERENCECOLUMN;
        goto Cleanup;
    }

    // get the OSP and (row,col) from which to fetch a child OSP.
    if (uStdRow > 0)
    {
        // if we have an OSP and (row,col) already, just use them.
        // This is the normal case, when GetData is trying to retrieve
        // a chapter handle from a field.
        pOSPparent = GetpOSP(hChapter);
    }
    else
    {
        // if we don't have an OSP and row, arbitrarily use the first row
        // of the metaOSP.  This is the case when a client calls
        // GetReferencedRowset on a column before actually fetching any
        // values from that column.  This strategy will fail if the metaOSP
        // doesn't have any rows, but that seems pretty unlikely.
        uStdRow = 1;
        pOSPparent = GetpMetaOSP();
    }

    // fetch the child OSP, on which we'll create the child rowset
    hr = pOSPparent->getVariant(uStdRow, icol, OSPFORMAT_RAW, &varOSP);

    if (hr || varOSP.vt != VT_UNKNOWN)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure it's an OSP
    hr = varOSP.punkVal->QueryInterface(IID_OLEDBSimpleProvider, (void **)&pOSP);
    if (hr)
        goto Cleanup;

    // return the OSP, if desired
    if (ppOSP)
    {
        pOSP->AddRef();
        *ppOSP = pOSP;
    }

    // make a child rowset, if needed
    if (stdColInfo.pChapRowset == NULL)
    {
        hr = CChapRowset::CreateRowset(pOSP,
                                       (IUnknown **)&stdColInfo.pChapRowset);
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    ClearInterface(&pOSP);
    VariantClear(&varOSP);
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     GetChapterData
//
//  Synopsis:   The Chapter returning part of GetData, pulled out for readability
//
//  Arguments:  see below
//
//  Returns:    S_OK                    if everything is fine,
//              DB_S_ERRORSOCCURRED     for compound accessor, partial success
//              DB_E_ERRORSOCCURRED     for compound accessor, all columns failed
//              E_FAIL                  Catch all (pData is NULL)
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//

HRESULT
CImpIRowset::GetChapterData(XferInfo &xfrData, CSTDColumnInfo &stdColInfo,
                            DBBINDING &currBinding, HCHAPTER hChapter,
                            HROW hrow, ULONG uStdRow, ULONG icol)
{
    HRESULT hr;
    OLEDBSimpleProvider *pOSP = NULL;
    HCHAPTER hChildChapter = NULL;

    *xfrData.pdbStatus = DBSTATUS_E_CANTCREATE; // assume failure
    Assert(currBinding.wType == DBTYPE_HCHAPTER);

    hr = EnsureReferencedRowset(hChapter, uStdRow, icol, &pOSP);
    if (hr)
        goto Cleanup;

    Assert(stdColInfo.pChapRowset);
    hr = stdColInfo.pChapRowset->EnsureHChapter(hrow, pOSP, &hChildChapter);
    if (hr)
        goto Cleanup;

    *(HCHAPTER *)xfrData.pData = hChildChapter;
    *xfrData.pdbStatus = DBSTATUS_S_OK;

Cleanup:

    ClearInterface(&pOSP);

    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     GetData (public member)
//
//  Synopsis:   Retrieves data from the rowset's cache
//
//  Arguments:  hRow        Row Handle
//              hAccessor   Accessor to use
//              pData       Pointer to buffer where data should go.
//
//  Returns:    S_OK                    if everything is fine,
//              DB_S_ERRORSOCCURRED     for compound accessor, partial success
//              DB_E_ERRORSOCCURRED     for compound accessor, all columns failed
//              E_FAIL                  Catch all (pData is NULL)
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//

STDMETHODIMP
CImpIRowset::GetData (HROW hRow, HACCESSOR hAccessor, void *pData)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetData(%p {%p, %p, %p})",
             this, hRow, hAccessor, pData ));

    HRESULT         hr = S_OK;
    HRESULT         hrIndex;
    HRESULT         hrLastFailure = S_OK;
    AccessorFormat  *pAccessor;
    DBBINDING       *pBinding;
    ULONG           cBindings;
    ULONG           ibind;
    ULONG           ulErrorCount;
    HCHAPTER        hChapter;
    DBCOUNTITEM     uStdRow;

    Assert(hAccessor);
    pAccessor = (AccessorFormat *)hAccessor;

    cBindings = pAccessor->cBindings;
    pBinding  = pAccessor->aBindings;

    // Ensure a place to put data, unless the accessor is the null accessor then
    // a NULL pData is okay.
    if (pData == NULL && cBindings != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hrIndex = HROW2Index(hRow, uStdRow);
    if (hrIndex)
    {
        // Most errors mean immediate failure.
        // If row has been deleted, or is being deleted, only allow
        //  bookmark fetches.
        // Check in advance rather than in loop below, so that we don't
        //  have a problem on what success/error code to return after
        //  a DBVECTOR may have been allocated.  Avoid leaks!
        
        if (hrIndex != DB_E_DELETEDROW && hrIndex != DB_E_NOTREENTRANT)
        {
            hr = hrIndex;
            goto Cleanup;
        }
        for (ibind = 0; ibind < cBindings; ibind++)
        {
            if (pBinding[ibind].iOrdinal != 0)   // not BOOKMARK column
            {
                hr = DB_E_DELETEDROW;
                goto Cleanup;
            }
        }
    }

    hChapter = ChapterFromHRow((ChRow) hRow);

    // These restrictions should have been tested by CreateAccessor
    Assert(pAccessor->dwAccFlags == DBACCESSOR_ROWDATA);

    ulErrorCount = 0;
    for (ibind = 0; ibind < cBindings; ibind++)
    {
        XferInfo        xfrData;
        DBBINDING &     currBinding = pBinding[ibind];
        DBPART          dwPart = currBinding.dwPart;
        ULONG           icol = currBinding.iOrdinal;
        CSTDColumnInfo &stdColInfo = _astdcolinfo[ColToDBColIndex(icol)];
        DBLENGTH        dblenDummyLength;
        DBSTATUS        dbDummyStatus;

        xfrData.dwDBType = stdColInfo.dwType;
        xfrData.dblenDataMaxLength = currBinding.cbMaxLen;
        xfrData.dwAccType = currBinding.wType;
        xfrData.pData = dwPart & DBPART_VALUE
                        ? ((BYTE *) pData + currBinding.obValue)
                        : NULL;
        xfrData.pdblenXferLength = dwPart & DBPART_LENGTH
                        ? (DBLENGTH *)((BYTE *) pData + currBinding.obLength)
                        : &dblenDummyLength;
        xfrData.pdbStatus = dwPart & DBPART_STATUS
                        ? (DBSTATUS *)((BYTE *) pData + currBinding.obStatus)
                        : &dbDummyStatus;

        // What are we retrieving a bookmark or regular column data?
        if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK)
        {
            // dlcursor seems confused about UI4 vs. I4 -cfranks 11Jun96
            if (currBinding.wType == DBTYPE_I4 ||
                currBinding.wType == DBTYPE_UI4 ||
                currBinding.wType == DBTYPE_BYTES)
            {
                Assert(currBinding.wType != DBTYPE_BYTES ||
                    currBinding.cbMaxLen >= sizeof(ULONG));
                *xfrData.pdblenXferLength = sizeof(ULONG);
                if (xfrData.pData)
                {
                    *(ULONG *)(xfrData.pData) = (ULONG)hRow;
                }
            }
            else
            {
                Assert(currBinding.wType == (DBTYPE_VECTOR|DBTYPE_UI1));
                *xfrData.pdblenXferLength = sizeof(DBVECTOR);
                if (xfrData.pData)
                {
                    // Get the bookmark.
                    ((DBVECTOR *)(xfrData.pData))->size = sizeof(HROW);
                    HROW *pu = (HROW *)CoTaskMemAlloc(sizeof(HROW));
                    if (!pu)
                    {
                        *xfrData.pdbStatus = DBSTATUS_E_CANTCREATE;
                        hr = E_OUTOFMEMORY;
                        goto LoopCleanup;
                    }

                    *pu = hRow;
                    ((DBVECTOR *)(xfrData.pData))->ptr = pu;
                }
            }

            *xfrData.pdbStatus = DBSTATUS_S_OK;

            hr = S_OK;
        }
        else if (stdColInfo.dwFlags & DBCOLUMNFLAGS_ISCHAPTER)
        {
            hr = GetChapterData(xfrData, stdColInfo, currBinding, hChapter,
                           hRow, uStdRow, icol);
        }
        else
        {
            // handles this case above
            Assert(!hrIndex);
            hr = DataCoerce(DataFromProvider, hChapter, uStdRow, icol, xfrData);
        }

LoopCleanup:
        if (hr)
        {
            hrLastFailure = hr;
            ulErrorCount++;
        }
    }

    // We report any lossy conversions with a special status.
    if (ulErrorCount)
    {
        Assert(hrLastFailure != S_OK);
        hr = (ulErrorCount == cBindings) ? DB_E_ERRORSOCCURRED
                                         : DB_S_ERRORSOCCURRED;
    }
    else
    {
        Assert(hr == S_OK);
    }
Cleanup:



    RRETURN4(hr, DB_E_ERRORSOCCURRED, DB_S_ERRORSOCCURRED,
                DB_E_UNSUPPORTEDCONVERSION, DB_E_BADACCESSORHANDLE);
}

//+---------------------------------------------------------------------------
//  Member:     GetNextRows (public member)
//
//  Synopsis:   Fetches rows squentially, remembering the previous position
//
//  Arguments:  hChapter            Chapter handle
//              lRowsOffset         Rows to skip before reading
//              cRows               Number of rows to fetch
//              pcRowsObtained      Number of rows obtained
//              pahRows             Array of Hrows obtained
//
//  Returns:    S_OK                    if everything is fine,
//              E_INVALIDARG            invalid argument
//              E_OUTOFMEMORY           Out of Memory
//              E_UNEXPECTED            Zombie State
//              DB_E_BADACCESSORHANDLE  Invalid Accessor given
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::GetNextRows (HCHAPTER hChapter,
                          DBROWOFFSET lRowsOffset,
                          DBROWCOUNT cRows,
                          DBCOUNTITEM * pcRowsObtained,
                          HROW ** pahRows)
{
    HRESULT hr;
    DBCOUNTITEM ulRow;
    BOOL fRowsAllocated = FALSE;
    COSPData * pOSPData = GetpOSPData(hChapter);

    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetNextRows(%p {%l, %l, %p, %p})",
             this, lRowsOffset, cRows, pcRowsObtained, pahRows ));

    *pcRowsObtained = 0;                // in case of error

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Error;
    }
    
    // Allocate memory block if we need to:
    // TODO:: We're not freeing this on failure right now!!!
    if (!*pahRows)
    {
        *pahRows = (HROW *)CoTaskMemAlloc(sizeof(HROW) * cRows);
        if (!*pahRows)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        fRowsAllocated = TRUE;
    }

    // First time?
    if (DBBMK_INITIAL==pOSPData->_iGetNextCursor)
    {
        if (cRows > 0)
        {
            pOSPData->_iGetNextCursor =
                (ULONG) (HRowFromIndex(hChapter, 1)).ToNileHRow();
        }
        else
        {
            // Negative cRow means start at end and go backwards
            pOSPData->_iGetNextCursor =
                (ULONG) (HRowFromIndex(hChapter, pOSPData->_cSTDRows)).ToNileHRow();
        }
    }

    hr = Bookmark2HRowNumber(hChapter, sizeof(pOSPData->_iGetNextCursor),
                             (BYTE *)&pOSPData->_iGetNextCursor, ulRow);
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Error;
        // Surprsingly, this call is not supposed to return DB_S_BOOKMARKSKIPPED
        hr = S_OK;
    }

    // GenerateHRowsFromHRowNumber also takes care of firing events
    hr = THR(GenerateHRowsFromHRowNumber(hChapter, ulRow, lRowsOffset, cRows,
                                         pcRowsObtained, pahRows));

    // Advance cursor
    if (!hr)                            // Don't advance on error?
    {
        ulRow += lRowsOffset +
                 (cRows > 0 ? *pcRowsObtained : -(LONG)*pcRowsObtained);
        pOSPData->_iGetNextCursor = (ULONG) (HRowFromIndex(hChapter, ulRow)).ToNileHRow();
    }

Error:
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     RestartPosition (public member)
//
//  Synopsis:   Repositions the "next fetch position" to the start of the
//              rowset/chapter.
//
//  Arguments:  hChapter            Chapter handle
//
//  Returns:    S_OK                    if everything is fine,
//              DB_S_COLUMNSCHANGED     see OLE DB docs
//              E_FAIL                  provider-specific error
//              E_UNEXPECTED            Zombie State
//              DB_E_BADCHAPTER         invalid chapter
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//              DB_E_ROWSNOTRELEASED    provider insists all HROWS released
//

STDMETHODIMP
CImpIRowset::RestartPosition (HCHAPTER hChapter)
{
    HRESULT hr = S_OK;
    COSPData *pOSPData = GetpOSPData(hChapter);

    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::RestartPosition(%p {%p})",
             this, hChapter ));

    if (pOSPData)
    {
        pOSPData->_iGetNextCursor = DBBMK_INITIAL;    // reset cursor
    }
    else
    {
        hr = DB_E_BADCHAPTER;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     GetReferencedRowset (public member)
//
//  Synopsis:   Returns an interface pointer to the rowset to which the bookmark
//              applies.
//
//  Arguments:  iOrdinal            Bookmark or Chapter Column
//              riid                ID of desired interface
//              ppReferencedRowset  where to put interface pointer 
//
//  Returns:    S_OK                        if everything is fine,
//              E_FAIL                      Provider specific Error
//              E_INVALIDARG                Invalid parameters were specified
//              E_UNEXPECTED                Zombie State
//              DB_E_NOTAREFERENCECOLUMN    iColumn contains no Bookmarks or
//                                          Chapters
//              DB_E_NOTREENTRANT           Can not enter function at this time
//

STDMETHODIMP
CImpIRowset::GetReferencedRowset (DBORDINAL iOrdinal, REFIID riid, IUnknown **ppReferencedRowset)
{
    HRESULT hr;
    CImpIRowset *pRowset;

    *ppReferencedRowset = NULL;

    hr = EnsureReferencedRowset(DB_NULL_HCHAPTER, 0, iOrdinal, NULL);
    if (hr)
        goto Cleanup;
    
    pRowset = _astdcolinfo[iOrdinal].pChapRowset;
    Assert(pRowset);
    if (pRowset)
        hr = pRowset->QueryInterface(riid, (void **)ppReferencedRowset);

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     GetProperties (public member)
//
//  Synopsis:   Returns current settings of properites supported by
//              the rowset.
//
//  NOTE:       this is a temporary minimum implementation, which only handles
//              the properties that DLCURSOR cares about.
//
//  Arguments:  cPropIDSets          number of explicitly requested propID
//                                   sets; 0 means all supported by callee.
//              aPropIDSets          if cPropIDSets != 0 array of propID sets for
//                                   which properties are being requested
//              pcPropSets           where to return # of DBPROPSETs
//              paPropSets           where to return ptr to DBPROPSETs
//              
//
//  Returns:    S_OK                 The method succeeded
//              E_FAIL               Provider-specific error
//              E_INVALIDARG         Bad arguments (several possibilities)
//              E_OUTOFMEMORY        Provider can't allocate sufficient memory
//              E_UNEXPECTED         Zombie state
//              DB_S_ERRORSOCCURRED  Some but not all properties failed
//              DB_E_ERRORSOCCURRED  All properties failed
//

STDMETHODIMP
CImpIRowset::GetProperties (const ULONG cPropIDSets, const DBPROPIDSET aPropIDSets[],
                            ULONG *pcPropSets, DBPROPSET **paPropSets)
{
    TraceTag((tagNileRowsetProvider,
              "CImpIRowset::GetProperties(%p {%u, %p, %p, %p})", this,
              cPropIDSets, aPropIDSets, pcPropSets, paPropSets ));

    HRESULT hr;
    ULONG cPropSets = cPropIDSets;
    ULONG iPropSet;
    DBPROPSET* aPropSets = 0;
    BOOL bFailures=FALSE, bSuccesses=FALSE; // did none, some or all properties succeed

    if (cPropIDSets == 0)       // means "return all properties"
    {
        cPropSets = _dbpProperties.GetNPropSets();
    }
    
    // check for bad arguments
    if (pcPropSets==0 || paPropSets==0 || (cPropIDSets>0 && aPropIDSets==0))
    {
        hr = E_INVALIDARG; 
        goto Cleanup;
    }

    for (iPropSet=0; iPropSet<cPropIDSets; ++iPropSet)
    {
        if (aPropIDSets[iPropSet].cPropertyIDs > 0  &&
            aPropIDSets[iPropSet].rgPropertyIDs == 0)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // get memory for results
    aPropSets = (DBPROPSET *)
                        CoTaskMemAlloc(sizeof(DBPROPSET) * cPropSets);
    if (aPropSets == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
    {
        aPropSets[iPropSet].rgProperties = 0;   // makes error cleanup simpler
    }
    
    // fill in each property set
    for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
    {
        DBPROPSET* pPropSet = & aPropSets[iPropSet];

        if (cPropIDSets == 0)               // copying all properties
        {
            hr = _dbpProperties.CopyPropertySet(iPropSet, pPropSet);
            if (hr)
                goto Error;
            bSuccesses = TRUE;
        }
        else if (aPropIDSets[iPropSet].cPropertyIDs == 0)   // all props for this GUID
        {
            hr = _dbpProperties.CopyPropertySet(aPropIDSets[iPropSet].guidPropertySet,
                                                pPropSet);
            if (hr == E_FAIL)           // no properties for this GUID
            {
                pPropSet->cProperties = 0;
                pPropSet->rgProperties = 0;
                pPropSet->guidPropertySet = aPropIDSets[iPropSet].guidPropertySet;
                hr = S_OK;
                bFailures = TRUE;
            }
            else if (hr)
                goto Error;
            bSuccesses = TRUE;
        }
        else                                // explicit list of properties
        {
            const DBPROPIDSET* pPropIDSet = & aPropIDSets[iPropSet];
            ULONG iProp;
            
            pPropSet->cProperties = pPropIDSet->cPropertyIDs;
            pPropSet->guidPropertySet = pPropIDSet->guidPropertySet;
            
            // get memory for property array
            pPropSet->rgProperties = (DBPROP *)
                            CoTaskMemAlloc(sizeof(DBPROP) * pPropIDSet->cPropertyIDs);
            if (pPropSet->rgProperties == 0)
            {
                hr = E_OUTOFMEMORY;
                pPropSet->cProperties = 0;
                goto Error;
            }

            // fill in property array
            for (iProp=0; iProp<pPropIDSet->cPropertyIDs; ++iProp)
            {
                const DBPROP* pProp = _dbpProperties.GetProperty(pPropIDSet->guidPropertySet,
                                                pPropIDSet->rgPropertyIDs[iProp]);
                if (pProp)
                {
                    pPropSet->rgProperties[iProp] = *pProp;
                    bSuccesses = TRUE;
                } else
                {
                    pPropSet->rgProperties[iProp].dwPropertyID = pPropIDSet->rgPropertyIDs[iProp];
                    pPropSet->rgProperties[iProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                    bFailures = TRUE;
                }
            }
        }
    }

    *pcPropSets = cPropSets;
    *paPropSets = aPropSets;
    hr = bFailures  ? bSuccesses    ? DB_S_ERRORSOCCURRED
                                    : DB_E_ERRORSOCCURRED
                    : S_OK;

Cleanup:
    RRETURN2 (hr, DB_S_ERRORSOCCURRED, DB_E_ERRORSOCCURRED);

Error:
    // release memory
    if (aPropSets)
    {
        for (iPropSet=0; iPropSet<cPropSets; ++iPropSet)
        {
            CoTaskMemFree(aPropSets[iPropSet].rgProperties);
        }
    }
    CoTaskMemFree(aPropSets);

    // tell caller we didn't allocate memory
    *pcPropSets = 0;
    *paPropSets = 0;
    
    goto Cleanup;
}    


//+---------------------------------------------------------------------------
//  Member:     GetSpecification (public member)
//
//  Synopsis:   Returns the interface pointer of object that created the rowset
//
//  Arguments:  riid                IID of the interface being queried for
//              ppSpecification     Interface that instantiated this object
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_INVALIDARG            Invalid parameters were specified
//              E_NOINTERFACE           The provider did not support the riid
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time
//

STDMETHODIMP
CImpIRowset::GetSpecification (REFIID riid, IUnknown **ppSpecification)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetSpecification(%p {%p, %p})",
             this, riid, ppSpecification ));

    HRESULT hr = E_NOINTERFACE;

    if (ppSpecification == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppSpecification = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     AddRefAccessor (public member)
//
//  Synopsis:   AddRefs an Accessor
//
//  Arguments:  hAccessor   Accessor to addref
//              pcRefCount  pointer to where to return new refcount
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::AddRefAccessor (HACCESSOR hAccessor, ULONG *pcRefCount)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::AddRefAccessor(%p {%p %p})", this, hAccessor, pcRefCount ));

    Assert(hAccessor);

    AccessorFormat *pAccessor = (AccessorFormat*) hAccessor;

    ++ pAccessor->cRefCount;
    if (pcRefCount)
        *pcRefCount = pAccessor->cRefCount;
        
    return S_OK;
}



//+---------------------------------------------------------------------------
//  Member:     ReleaseAccessor (public member)
//
//  Synopsis:   Releases an Accessor
//
//  Arguments:  hAccessor   Accessor to release
//              pcRefCount  pointer to where to return new refcount
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time.
//

STDMETHODIMP
CImpIRowset::ReleaseAccessor (HACCESSOR hAccessor, ULONG *pcRefCount)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::ReleaseAccessor(%p {%p %p})", this, hAccessor, pcRefCount ));

    Assert(hAccessor);

    AccessorFormat *pAccessor = (AccessorFormat*) hAccessor;
    Assert(pAccessor->cRefCount > 0);

    -- pAccessor->cRefCount;
    if (pcRefCount)
        *pcRefCount = pAccessor->cRefCount;
        
    if (pAccessor->cRefCount == 0)
    {
        // remove the accessor from the active list
        _dblAccessors.Remove(pAccessor);
        
        // Free the actual structure.
        delete pAccessor;
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//  Member:     AddRefRows (public member)
//
//  Synopsis:   Bump ref counts on rows.
//
//  Arguments:  cRow            Number of rows to AddRef
//              ahRow           Array of handles of rows to be released
//              pcRowCounted    Count of rows actually AddRefed, may be NULL
//              aRefCount       Array of refcnts for the rows
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_INVALIDARG            Invalid parameters were specified
//              DB_S_ERRORSOCCURRED     Some but not all rows were invalid
//              DB_E_ERRORSOCCURRED     All rows were invalid
//

STDMETHODIMP
CImpIRowset::AddRefRows (DBCOUNTITEM cRows,
                         const HROW ahRow[],
                         DBREFCOUNT aRefCount[],
                         DBROWSTATUS aRowStatus[])
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::AddRefRows(%p {%u %p %p %p})",
             this, cRows, ahRow, aRefCount, aRowStatus ));
             
    HRESULT hr = S_OK;
    ULONG cErrors = 0;          // number of rows that failed
    ULONG iRow;

    if (ahRow == NULL && cRows != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (iRow=0; iRow < cRows; ++iRow)
    {
        LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_S_OK);
        
        if (ahRow[iRow] == NULL)
        {
            Assert(!"Null HROW to CImpIRowset::AddRefRows.");
            LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_E_INVALID);
            ++ cErrors;
        }
        else
        {
            if (aRefCount)
            {
                // Since we don't actually refcount our hRow objects, we return
                // a fake refcount here.
                aRefCount[iRow] = 1;
            }
        }
    }

    hr =    cErrors == 0 ?      S_OK :
            cErrors < cRows ?   DB_S_ERRORSOCCURRED :
                                DB_E_ERRORSOCCURRED;

Cleanup:
    RRETURN2(hr, DB_S_ERRORSOCCURRED, DB_E_ERRORSOCCURRED);
}

//+---------------------------------------------------------------------------
//  Member:     ReleaseRows (public member)
//
//  Synopsis:   Releases row handles, generating appropriate notifications.
//
//  Arguments:  cRow            Number of rows to release
//              ahRow           Array of handles of rows to be released
//              aRefCount       Array of refcnts for the rows
//              aRowStatus      Array of status codes
//
//  Returns:    S_OK                    if everything is fine,
//              E_FAIL                  Provider specific Error
//              E_INVALIDARG            Invalid parameters were specified
//              E_UNEXPECTED            Zombie State
//              DB_E_NOTREENTRANT       Can not enter function at this time
//

STDMETHODIMP
CImpIRowset::ReleaseRows (DBCOUNTITEM cRows,
                          const HROW ahRow[],
                          DBROWOPTIONS aRowOptions[],
                          DBREFCOUNT aRefCount[],
                          DBROWSTATUS aRowStatus[])
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::ReleaseRows(%p {%u %p %p %p %p})",
             this, cRows, ahRow, aRowOptions, aRefCount, aRowStatus ));

    HRESULT hr = S_OK;

    if (cRows == 0)
    {
        goto Cleanup;
    }

    // in some sense, all rows are alive, even if their ref-counts
    //  have hit 0.....
    hr = ReleaseRowsQuiet(cRows, ahRow, aRefCount, aRowStatus);


Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//  Member:     ReleaseRowsQuiet (private member)
//
//  Synopsis:   Releases row handles, without generating any notifications.
//
//  Arguments:  cRow            Number of rows to release
//              ahRow           Array of handles of rows to be released
//              aRefCounts      Where to return ref-count of each succesfully
//                              released row.  May be NULL.
//              aRowStatus      Status of each row.  May be NULL.
//
//  Returns:    S_OK                everything worked
//              DB_S_ERRORSOCCURRED some but not all rows failed
//              DB_E_ERRORSOCCURRED all rows failed
//

HRESULT
CImpIRowset::ReleaseRowsQuiet(DBCOUNTITEM cRows, const HROW ahRow[],
                                DBREFCOUNT aRefCounts[], DBROWSTATUS aRowStatus[])
{
    ULONG iRow;
    ULONG cErrors = 0;      // number of rows that caused problems
    HRESULT hr;

    // In the new world, handles don't need to be released.
    // We run this loop only to decrement the refcounts so our
    // caller believes the handles were released.   -cfranks
    for (iRow = 0; iRow<cRows; ++iRow)
    {
        LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_S_OK);
        if (!ahRow[iRow])
        {
            ++ cErrors;
            LogErrors(aRowStatus, iRow, 1, DBROWSTATUS_E_INVALID);
            continue;            
        }

        if (aRefCounts)
        {
            aRefCounts[iRow] = 1;          // Fake refcount
        }
    }

    hr =    cErrors==0 ?    S_OK :
            cErrors<cRows ? DB_S_ERRORSOCCURRED :
                            DB_E_ERRORSOCCURRED;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     IsSameRow (public member)
//
//  Synopsis:   compares two HROWs to see if they are logicaly the same row
//
//  Arguments:  hThisRow        First HROW to compare
//              hThatRow        Second HROW to compare
//
//  Returns:    S_OK                    HROWs are the same
//              S_FALSE                 HROWs are for different rows
//

STDMETHODIMP
CImpIRowset::IsSameRow(HROW hThisRow, HROW hThatRow)
{
    HRESULT hr = S_OK;
    if (!hThisRow || !hThatRow)
    {
        hr = DB_E_BADROWHANDLE;
        goto Cleanup;
    }
    
    if ( FhRowDeleted((ChRow)hThisRow) || FhRowDeleted((ChRow)hThatRow) )
    {
        hr = DB_E_DELETEDROW;
        goto Cleanup;
    }


    if ((IndexFromHRow((ChRow) hThisRow) != IndexFromHRow((ChRow) hThatRow)) ||
        (ChapterFromHRow((ChRow) hThisRow) != ChapterFromHRow((ChRow) hThatRow)))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//  Member:     FireFieldEvent (public member)
//
//  Synopsis:   Fires the IRowsetNotify::OnFieldChange event on change to the
//              value of a field.
//
//  Arguments:  hRow                    row of field that changed
//              iColumn                 column in the row that changed
//              eReason                 action that caused change event to fire
//              ePhase                  phase of this notification
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDPHASE         not interested in this event phase
//              S_FALSE                 event/phase is vetoed
//

HRESULT
CImpIRowset::FireFieldEvent(HROW hRow, DBORDINAL cColumns, DBORDINAL aColumns[],
                            DBREASON eReason, DBEVENTPHASE ePhase)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IRowsetNotify * pRSN = NULL;
    NOTIFY_STATE    ns;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireFieldEvent(%p {%l, %l, %p, %l, %l})",
             this, hRow, cColumns, aColumns, eReason, ePhase ));

    aaidx = AA_IDX_UNKNOWN;
    
    ns = EnterNotify(eReason, ePhase);

    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pRSN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRSN)))
        {
            hr = THR(pRSN->OnFieldChange(
                    (IRowset *) this, 
                    hRow, 
                    cColumns, 
                    aColumns,
                    eReason, 
                    ePhase, 
                    TRUE));
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDREASON))
            {
                hr = S_OK;
            }
        }
    }

    LeaveNotify(eReason, ePhase, ns);

    ReleaseInterface(pRSN);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//  Member:     FireRowEvent (public member)
//
//  Synopsis:   Fires the IRowsetNotify::OnRowChange event on first change to
//              a row or any whole-row change.
//
//  Arguments:  cRows                   count of HROWs in rghRows
//              rghRows                 array of HROWs which are changing
//              eReason                 action that caused change event to fire
//              ePhase                  phase of this notification
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDPHASE         not interested in this event phase
//              S_FALSE                 event/phase is vetoed
//

HRESULT
CImpIRowset::FireRowEvent(DBCOUNTITEM cRows, const HROW rghRows[],
                          DBREASON eReason, DBEVENTPHASE ePhase)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IRowsetNotify * pRSN = NULL;
    NOTIFY_STATE    ns;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireRowEvent(%p {%l, %p, %l, %l})",
             this, cRows, rghRows, eReason, ePhase ));

    aaidx = AA_IDX_UNKNOWN;
    
    ns = EnterNotify(eReason, ePhase);

    for(;;)
    {
        aaidx = FindNextAAIndex(DISPID_A_ROWSETNOTIFYSINK,
                                CAttrValue::AA_Internal, aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pRSN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRSN)))
        {
            hr = THR(pRSN->OnRowChange(
                    (IRowset *) this, 
                    cRows, 
                    rghRows,
                    eReason, 
                    ePhase, 
                    FALSE));
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDREASON))
            {
                hr = S_OK;
            }
        }
    }

    LeaveNotify(eReason, ePhase, ns);
    ReleaseInterface(pRSN);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//  Member:     FireRowsetEvent (public member)
//
//  Synopsis:   Fires the IRowsetNotify::OnRowsetChange event on any change to
//              a rowset.
//
//  Arguments:  eReason                 action that caused change event to fire
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//

HRESULT
CImpIRowset::FireRowsetEvent(DBREASON eReason, DBEVENTPHASE ePhase)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IRowsetNotify * pRSN = NULL;
    NOTIFY_STATE    ns;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireRowEvent(%p {%l, %l})",
             this, eReason, ePhase));

    aaidx = AA_IDX_UNKNOWN;
    
    ns = EnterNotify(eReason, DBEVENTPHASE_DIDEVENT);
    
    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pRSN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRSN)))
        {
            hr = THR(pRSN->OnRowsetChange(
                    (IRowset *) this, 
                    eReason, 
                    ePhase, 
                    FALSE));
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDREASON))
            {
                hr = S_OK;
            }
        }
    }

    LeaveNotify(eReason, DBEVENTPHASE_DIDEVENT, ns);

    ReleaseInterface(pRSN);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     FireAsynchOnProgress
//
//  Synopsis:   Fires the IDBAsynchNotify::OnPgoress event 
//
//  Arguments:  ulProgress              the current row count
//              ulProgressMax           the estimated final row count
//              ulStatusCode            DBASYNCHPHASE_POPULATION, or
//                                      DBASYNCHPHASE_COMPLETE
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDOPERATION
//

HRESULT
CImpIRowset::FireAsynchOnProgress(DBCOUNTITEM ulProgress, DBCOUNTITEM ulProgressMax,
                                  DBASYNCHPHASE ulStatusCode)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IDBAsynchNotify * pDBAN = NULL;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireAsynchOnProgress(%p {%l, %l, %l})",
              this, ulProgress, ulProgressMax, ulStatusCode));

    aaidx = AA_IDX_UNKNOWN;

    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETASYNCHNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pDBAN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pDBAN)))
        {
            hr = THR(pDBAN->OnProgress(
                    NULL,               // chapter
                    DBASYNCHOP_OPEN,
                    ulProgress,                 
                    ulProgressMax,
                    ulStatusCode,
                    NULL));             // status text
        }
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDOPERATION))
            {
                hr = S_OK;
            }
    }

    ReleaseInterface(pDBAN);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     FireAsynchOnStop
//
//  Synopsis:   Fires the IDBAsynchNotify::OnStop event 
//
//  Arguments:  hrStatus                one of:
//                                       S_OK, DB_E_CANCELED (sp?),
//                                       E_OUTOFMEMORY, E_FAIL
//
//  Returns:    S_OK                    if everything is fine
//              S_UNWANTEDEVENT         not interested in event anymore
//              S_UNWANTEDOPERATION
//

HRESULT
CImpIRowset::FireAsynchOnStop(HRESULT hrStatus)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    IDBAsynchNotify * pDBAN = NULL;
    
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::FireAsynchOnStop(%p {%l})",
             this, hrStatus));

    aaidx = AA_IDX_UNKNOWN;

    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_ROWSETASYNCHNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        ClearInterface(&pDBAN);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pDBAN)))
        {
            hr = THR(pDBAN->OnStop(
                    NULL,               // chapter
                    DBASYNCHOP_OPEN,
                    hrStatus,
                    NULL));             // status text
            if (hr && (hr==DB_S_UNWANTEDPHASE || hr==DB_S_UNWANTEDOPERATION))
            {
                hr = S_OK;
            }
        }
    }

    ReleaseInterface(pDBAN);
    RRETURN(hr);
}

HRESULT
CImpIRowset::Init(OLEDBSimpleProvider *pSTD)
{
    return CacheMetaData();
}

//+---------------------------------------------------------------------------
//
//  Member:     Init (public member)
//
//  Synopsis:   Initializes IRowset with an ISTD
//
//  Arguments:  pSTD                Data provider
//
//  Returns:    S_OK                if everything is fine
//              E_FAIL              initialization failed
//

HRESULT
CTopRowset::Init (OLEDBSimpleProvider *pSTD)
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::Init(%p {%p})",
             this, pSTD ));

    HRESULT         hr = S_OK;

    Assert("Must have an OLEDBSimpleProvider" && pSTD);

    _pOSPData = new COSPData;
    if (!_pOSPData)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    hr = _pOSPData->Init(pSTD, this);
    if (hr)
        goto Error;

    // Init our idea of the # of rows from our only OSP member
    _cRows = _pOSPData->_cSTDRows;
    TraceTag((tagOSPRowDelta, "Init. Rowset %p has %ld rows, chapter %p has %ld rows",
                this, _cRows, _pOSPData, _pOSPData->_cSTDRows));

    hr = super::Init(pSTD);

Error:
    // Any errors here fail creation of the rowset.
    // Since we may already have hooked up event sinks to our COSPData,
    // we can't just delete it here.  Even releasing it is nasty, since
    // that will happen again in Rowset Passivate.  Let Passivate clean us up.
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CreateRowset (static)
//
//  Synopsis:   Creates creates an IRowset from an OLEDBSimpleProvider returning
//              as IUnknown
//
//  Arguments:  pRowset         - empty rowset object, new'd by one of our descendent
//                                clases, but not even checked for success.
//              pSTD            - OLEDBSimpleProvider provider wrapped by Nile
//              ppUnk           - IUnknown of Nile provider (IRowset, ...) this
//                                *ppUnk is AddRef on return.
//
//  Returns:    S_OK            - Wrapping succeeded.
//
//  Mac note:   When _MACUNICODE is defined,
//              OLEDBSimpleProvider* == OLEDBSimpleProviderMac* != LPSIMPLETABULARDATA

HRESULT
CImpIRowset::CreateRowset (CImpIRowset *pRowset, LPOLEDBSimpleProvider pSTD, IUnknown **ppUnk)
{
    HRESULT             hr;

    Assert(ppUnk);
    Assert(pSTD);

    *ppUnk = NULL;

    if (!pRowset)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pRowset->Init(pSTD);
    if (!hr)
    {
        *ppUnk = pRowset->getpIUnknown();
    }
    else
    {
        pRowset->Release();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CTopRowset::CreateRowset(LPOLEDBSimpleProvider pSTD, IUnknown **ppUnk)
{
    CTopRowset      *pRowset;

    pRowset = new CTopRowset;
    return super::CreateRowset((CImpIRowset *)pRowset, pSTD, ppUnk);
}

HRESULT
CChapRowset::CreateRowset(LPOLEDBSimpleProvider pSTD, IUnknown **ppUnk)
{
    HRESULT hr;
    CChapRowset      *pRowset = NULL;

    pRowset = new CChapRowset;

    if (pRowset)
    {
        pSTD->AddRef();
        pRowset->_pMetaOSP = pSTD;

        hr = super::CreateRowset((CImpIRowset *)pRowset, pSTD, ppUnk);
        
        if (hr)
        {
            ClearInterface(&pRowset->_pMetaOSP);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
// Add an entry to _aryOSPData.
//
HRESULT
CChapRowset::EnsureHChapter(HROW hRow,
                            OLEDBSimpleProvider *pOSP, HCHAPTER *phChildChapter)
{
    COSPData *pOSPData;
    HRESULT hr;
    DBROWCOUNT cRows;
    ULONG uRow = ChRow(hRow).DeRef();

    hr = _aryOSPData.EnsureSize(uRow+1);    // we don't use index 0
    if (hr)
        goto Error;

    // Do we already have OSP Data for this OSP?
    if (!(COSPData*)_aryOSPData[uRow])   // No.
    {
        pOSPData = new COSPData;
        if (!pOSPData)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        // Initialize the OSP data.
        // TODO:: Should we do anything here to check this OSP's conformity
        // to the metaOSP's meta data?
        hr = pOSPData->Init(pOSP, this);
        if (hr)
        {
            delete pOSPData;
            goto Error;
        }

        _aryOSPData[uRow] = (PCOSPData)pOSPData;
        IGNORE_HR(pOSP->getRowCount(&cRows));
        _cRows += (ULONG)cRows;
        TraceTag((tagOSPRowDelta, "Added chapter %p with %ld rows.  Rowset %p has %ld rows",
                    pOSPData, cRows, this, _cRows));
    }

    // In case we're returning an existing OSPData, we want to double-check
    // that it's the same OSP (in debug at least).

    Assert(_aryOSPData[uRow]->_pSTD == pOSP);

    *phChildChapter = _aryOSPData[uRow];
    
    
Error:
    return hr;
}

STDMETHODIMP
CImpIRowset::AddRefChapter(HCHAPTER hChapter,
              ULONG *pcRefCount)
{
    ULONG ulRefs;

#ifdef REALLY_REFCOUNT_CHAPTERS
    if (hChapter)
    {
        // TODO there's no way to verify hChapter belongs to this rowset
        COSPData *pOSPData = GetpOSPData(hChapter);
        ulRefs = pOSPData->AddRef();
    }
    else
#endif
    {
        ulRefs = 1;
    }
    
    if (pcRefCount)
        *pcRefCount = ulRefs;
    
    return S_OK;
}

STDMETHODIMP
CImpIRowset::ReleaseChapter(HCHAPTER hChapter,
              ULONG *pcRefCount)
{
    ULONG ulRefs;
    
#ifdef REALLY_REFCOUNT_CHAPTERS
    if (hChapter)
    {
        // TODO there's no way to verify hChapter belongs to this rowset
        COSPData *pOSPData = GetpOSPData(hChapter);
        ulRefs = pOSPData->Release();
    }
    else
#endif
    {
        ulRefs = 1;
    }
    
    if (pcRefCount)
        *pcRefCount = ulRefs;
    
    return S_OK;
}


STDMETHODIMP
CImpIRowset::IsRowInChapter(HCHAPTER hChapter, HROW hrow)
{
    HRESULT hr;

    hr = (hChapter == ChapterFromHRow((ChRow) hrow)) ? S_OK : S_FALSE;

    return hr;
}


void
CChapRowset::Passivate()
{
    // Recursively kill any child OSPDatas we may have.
    // (This will also release the child OSPs).
    for (ULONG uRow=1; uRow < (ULONG)_aryOSPData.Count(); uRow++)
    {
        if (_aryOSPData[uRow]._pCOSPData)
        {
            _aryOSPData[uRow]->Release();
            _aryOSPData[uRow] = NULL; // off chance we're passivate twice
        }
    }
        
    ClearInterface(&_pMetaOSP);

    super::Passivate();
}

HRESULT
COSPData::Init(OLEDBSimpleProvider *pSTD, CImpIRowset * pRowset)
{
    HRESULT hr;
    int isAsync = 0;
    DBROWCOUNT cRowsTemp;
    
    Assert(pRowset && pSTD);

    _pRowset = pRowset;                 // We don't refcount our rowset.

    _pSTD = pSTD;                       // We DO refcount our OSP.
    _pSTD->AddRef();

    // Initialize rowset cache:

    hr = _pSTD->getRowCount(&cRowsTemp);
    _cSTDRows = (LONG)cRowsTemp;
    if (hr)
    {
        goto Error;
    }
    TraceTag((tagOSPRowDelta, "Init.  Chapter %p has %ld rows",
                this, _cSTDRows));

    hr = _pSTD->getColumnCount(&cRowsTemp);
    _cSTDCols = (LONG)cRowsTemp;
    if (hr)
    {
        goto Error;
    }

    // Set the PopulationComplete bit.  It's always true for synchronous OSPs.
    // For async OSPs, we may be too late for the transferComplete notification,
    // so we check if the estimated count agrees with the row count.  Some OSPs
    // will fire transferComplete when we hook up the listener, if they're already
    // complete;  this is fine.  Finally, if getEstimatedRows fails, we assume
    // the OSP is complete;  this makes things no worse than they already are.
    _fPopulationComplete = TRUE;
    IGNORE_HR(_pSTD->isAsync(&isAsync));
    if (isAsync)
    {
        DBROWCOUNT lEstimatedRows;
        if (S_OK == _pSTD->getEstimatedRows(&lEstimatedRows))
        {
            // if the OSPs estimate agrees with its row count, we're too late
            // for the transferComplete notification
            _fPopulationComplete = (_cSTDRows == (ULONG)lEstimatedRows);
        }
    }

    // Set std events:
    // NOTE: Do this before calling GetColumnInfo, since it relies on the std
    //   events to be called.
    hr = _pSTD->addOLEDBSimpleProviderListener((OLEDBSimpleProviderListener *)&_STDEvents);
    if (hr)
    {
        _pSTD->Release();
        goto Error;
    }

    _iGetNextCursor = DBBMK_INITIAL;    // special value
    _iFindRowsCursor = DBBMK_INITIAL;
Error:
    return hr;
}

STDMETHODIMP_(ULONG)
COSPData::Release()
{
    ULONG ulRefs;
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        _ulRefs = 0;
    }
    ulRefs = _ulRefs;
    SubRelease();
    return ulRefs;
}

//
// Pure IUnknown
//

STDMETHODIMP
COSPData::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\rowhndl.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      rowhndl.cxx
//  Author:    Charles Frankston
//
//  Contents:  Implementation of new scheme to manage row handles & bookmarks
//  Date:      started May 28, 1996
////
//------------------------------------------------------------------------

// keep our code to 80 columns:
//       1         2         3         4         5         6         7         
// 4567890123456789012345678901234567890123456789012345678901234567890123456789

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

MtDefine(CRowArray, DataBind, "CRowArray")

//+------------------------------------------------------------------------
//
//  Class:      CRowMap
//
//  Purpose:    Class used to track translations from hRows to STD row
//              indexes, and visa versa.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member: CRowMap::HandleFromRow
//
//  Synopsis:   Returns the handle corresponding to a row.  These handles
//              are meant to be used at hRows or Bookmarks.  Handles persist
//              for the life of the CRowMap class they came from.  They
//              always continue to point to the same row (even in the face
//              of row inserts and deletes) unless that row is deleted, in
//              which case they will point to the first non-deleted row
//              following the original row.
//
//  Arguments:  row   row # to get a handle to.
//
//-------------------------------------------------------------------------
ChRow
CImpIRowset::HRowFromIndex(HCHAPTER hChapter, DBCOUNTITEM row)
{
    ChRow href;                 // Handle reference
    CRowArray<ChRow> *pMapIndex2hRow = &GetpOSPData(hChapter)->_mapIndex2hRow;

   // Get the hRow for this row if there already is one.
    href = pMapIndex2hRow->GetElem ((int) row);

    if (!href.FHrefValid())                    // Didn't already have one.
    {
        // Get the next free handle, set it to point to this row.
        if (S_OK != _maphRow2Index.SetElem(_NextH2R,
                                           CIndex((int)row, (COSPData *)(LONG_PTR)hChapter)))
        {
            // Must have been a mem alloc failure.  Don't assign to href.
            goto Error;
        }
        // Record the hRow we just claimed,
        href = href.SetRef(_NextH2R++);;

        // and set the entry for this row to point back to href entry
        pMapIndex2hRow->SetElem((int) row, href);
    }

Error:
    return (href);
}
    
//+------------------------------------------------------------------------
//
//  Member: CRowMap::RowFromHRow
//
//  Synopsis:   Returns the Row # that a particular handle addresses.
//              If the row has been deleted, the handle will still be valid
//              but would now point to the first non-deleted row following.
//
//  Arguments:  handle
//
//-------------------------------------------------------------------------
/* Inline'd in .hxx file! */

//+------------------------------------------------------------------------
//
//  Member: CRowMap::FhRowDeleted
//
//  Synopsis:   Returns TRUE if the row referred to by handle has been deleted.
//
//  Arguments:  handle
//
//-------------------------------------------------------------------------
/* Inline'd in .hxx file! */

// For iterating through ChRow's.
ChRow
CImpIRowset::FirsthRef(HCHAPTER hChapter)
{
    ChRow hRef;                         // contructed at 0

    return NexthRef(hChapter, hRef);
}

ChRow
CImpIRowset::NexthRef(HCHAPTER hChapter, ChRow hRef)
{
    // Advance to the next CIndex that matches the chapter
    // we're working on.
    for (hRef=hRef.NextHRef();  ValidhRef(hRef);  hRef=hRef.NextHRef())
    {
        if (_maphRow2Index.GetElem(hRef.DeRef()).GetpChap() ==
           (COSPData *)(LONG_PTR)hChapter)
       {
           break;
       }
    }
    return hRef;
}

BOOL
CImpIRowset::ValidhRef(ChRow hRef)
{
    return ((LONG)hRef.DeRef() < _NextH2R);
}

//+------------------------------------------------------------------------
//
//  Member: CRowMap::InsertRows
//
//  Synopsis:   Inserts new rows.  The row table (mpIndex2hRow) is shifted
//              up to make room, and all the handles in the handle table
//              (_maphRow2Index) are adjusted to account for the shift.
//
//  Arguments:  row     index of row to start insertion at (i.e. 0 would
//                      insert before the first element).
//              c       count of # of rows to insert
//              pChap   Pointer to chapter that we're dealing with now
//              mpIndex2hRow The handle table for this chapter
//
//-------------------------------------------------------------------------
HRESULT
CImpIRowset::InsertRows(ULONG row, int c, COSPData *pOSPData)
{
    HRESULT hr;
    ChRow hRef;                         // Constructor will create a 0 hRef
    CIndex v;
    HCHAPTER hChapter = HChapterFromOSPData(pOSPData);
    
    Assert(c >= 0);

    // Create space for new rows in Row2hRow table.
    // New entries are initialized to invalid hRef, showing that there
    // aren't handles checked out yet for the new rows.
    hr = pOSPData->_mapIndex2hRow.InsertMultiple(row, c, hRef);
    if (hr)
        goto Error;         // out of mem for insert
    
    // March through hRow array fixing up values
    for (hRef = FirsthRef(hChapter); ValidhRef(hRef);
         hRef = NexthRef(hChapter, hRef))
    {
        v = _maphRow2Index.GetElemNoCheck(hRef.DeRef());

        if (v.Row() >= (int)row)
        {
            _maphRow2Index.SetElemNoCheck(hRef.DeRef(),
                                         v.SetRow(v.Row()+c, v.FDeleted()));
        }
    }
    
Error:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member: CRowMap::DeleteRows
//
//  Synopsis:   Deletes rows.  The row table (mpIndex2hRow) is shifted
//              down, and all the handles in the handle table
//              (_mapIndex2hRow) are adjusted to account for the shift.
//
//  Arguments:  row     index of row to start deletion at (i.e. 0 would
//                      start deletion at the first element).
//              c       count of # of rows to delete
//              pChap   Pointer to chapter that we're dealing with now
//              mpIndex2hRow The handle table for this chapter
//
//-------------------------------------------------------------------------
void
CImpIRowset::DeleteRows(ULONG row, int c, COSPData *pOSPData)
{
    ChRow hRef;
    CIndex v;
    HCHAPTER hChapter = HChapterFromOSPData(pOSPData);

    Assert( c >= 0);
    // adjust Row2hRow mapping table
    pOSPData->_mapIndex2hRow.DeleteMultiple(row, c);

    // March through hRow array fixing up values
    for (hRef = FirsthRef(hChapter); ValidhRef(hRef);
         hRef = NexthRef(hChapter, hRef))
    {
        v = _maphRow2Index.GetElemNoCheck(hRef.DeRef());
        if (v.Row() >= (int)row)        // In the range affected by deletion?
        {
            if (v.Row() < (int)(row+c))  // In the range of now deleted rows?
            {
                // If this row has been deleted, set it to point to
                // first undeleted element, & mark it negative to show
                // that its been deleted.
                _maphRow2Index.SetElemNoCheck(hRef.DeRef(), v.SetRowDel(row));
            }
            else
            {
                // Adjust all values after deleted range.  Be sure to retain
                // any existing deleted flag.
                _maphRow2Index.SetElemNoCheck(hRef.DeRef(),
                                             v.SetRow(v.Row()-c, v.FDeleted()));
            }
        }

    }
}

#ifdef NEVER
//+------------------------------------------------------------------------
//
//  Member: CRowMap::InvalidateMap
//
//  Synopsis:   Invalidates the entire HRow to CRow mapping table.  Used
//              when the rowset has disappeared (or been sorted) out from
//              under us.  This will ensure that any and all outstanding
//              hRows, Bookmarks, etc. are invalid, can't be stored through
//              can't be used to fetch new data, etc.
//
//-------------------------------------------------------------------------
void
CImpIRowset::InvalidateMap()
{
    ChRow hRef;
    CIndex v;

    // March through hRow array deleting all values.
    // March through hRow array fixing up values
    for (hRef = FirsthRef(hChapter); ValidhRef(hRef);
         hRef = NexthRef(hRef, hChapter))
    {
        v = _maphRow2Index.GetElemNoCheck(hRef.DeRef());
        _maphRow2Index.SetElemNoCheck(hRef.DeRef(), v.SetRowDel(1));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\stdevent.cxx ===
//--------------------------------------------------------------------
// Microsoft Nile to STD Mapping Layer
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stdevent.cxx
//  Author:     Ido Ben-Shachar (t-idoben)
//
//  Contents:   Event handlers for STD
//

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

MtDefine(COSPDataCSTDEventsCellChangedHelper_rgColumns, DataBind, "COSPData::CSTDEvents::CellChangesHelper rgColumns")
MtDefine(COSPDataCSTDEventsDeleteRowsHelper_aDeletedHROWs, DataBind, "COSPData::CSTDEvents::DeleteRowsHelper aDeleteHROWs")
MtDefine(COSPDataCSTDEventsInsertRowsHelper_aInsertedHROWs, DataBind, "COSPData::CSTDEvents::InsertRowsHelper aInsertedHROWs")

DeclareTag(tagOSPRowDelta, "Databinding", "trace changes to OSP row count");
DeclareTag(tagOSPEvents, "Databinding", "trace OSP notifications");

////////////////////////////////////////////////////////////////////////////////
//
// ISimpleTabularDataEvents specific interfaces
//
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
COSPData::CSTDEvents::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_OLEDBSimpleProviderListener))
    {
        *ppv = (OLEDBSimpleProviderListener *) this;
    }
    else
    {
        *ppv = NULL;
    }
    
    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}



//+---------------------------------------------------------------------------
//  Member:     aboutToChangeCell
//
//  Synopsis:   for AboutTo phase of cellChanged
//
//  Arguments:  iRow                    row of changed cell
//              iColumn                 column of changed cell
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::aboutToChangeCell(DBROWCOUNT iRow, DB_LORDINAL iColumn)
{
    TraceTag((tagOSPEvents, "OSP %x aboutToChangeCell(%ld,%ld)", MyOSP(), iRow, iColumn));
    return CellChangedHelper(iRow, iColumn, TRUE);
}

//+---------------------------------------------------------------------------
//  Member:     CellChanged
//
//  Synopsis:   A cell somewhere in the rowset has been altered.  Therefore,
//              this function cleans up the rowset to reflect this change.
//              Notifications are also fired.  If multiple rows have changed
//              (iRow == -1) then FireRowsetEvent is called.  If multiple
//              columns have changed (iColumn == -1) then FireRowEvent is
//              called.  Otherwise, only one field has changed, and
//              FireFieldEvent is called.
//
//  Arguments:  iRow                    row of changed cell
//              iColumn                 column of changed cell
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::cellChanged(DBROWCOUNT iRow, DB_LORDINAL iColumn)
{
    TraceTag((tagOSPEvents, "OSP %x cellChanged(%ld,%ld)", MyOSP(), iRow, iColumn));
    return CellChangedHelper(iRow, iColumn, FALSE);
}

//+---------------------------------------------------------------------------
//  Member:     CellChangedHelper
//
//  Synopsis:   Does the actual work for CellChanged. fBefore tells us which
//              notification phase we're in.
//
//  Arguments:  iRow                    row of changed cell
//              iColumn                 column of changed cell
//              fBefore                 which phase are we in
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::CellChangedHelper(DBROWCOUNT iRow, DB_LORDINAL iColumn, BOOL fBefore)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::CellChanged(%p {%u %u})",
          this, iRow, iColumn) );
    HRESULT hr = S_OK;

    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;
    DBORDINAL cColCount, iSingleCol;
    DBORDINAL *rgColumns = NULL;
    HROW hrowTemp = NULL;

    if (!pRowset)                       // just in case
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);

    // -1,-1 is a special notification meaning the STD was scrambled out
    // from under us.  Everything we know is invalid.  This should probably
    // be handled better, but for now..
    
    if (iRow == -1) // multiple rows changed
    {
        // ISSUE: Is this a valid and appropriate reason for OnRowEvent?
        // also, we fire on two phases instead of 4..
        HRESULT hr1;
        hr1 = pRowset->FireRowEvent(0, &hrowTemp,
                               DBREASON_COLUMN_SET, 
                               fBefore ? DBEVENTPHASE_ABOUTTODO :
                               DBEVENTPHASE_DIDEVENT);
        if (fBefore && hr1)
        {
            pRowset->FireRowEvent(0, &hrowTemp,
                               DBREASON_COLUMN_SET, 
                               DBEVENTPHASE_FAILEDTODO);
            hr = hr1;
        }
    }
    else        // only one Row changed, but maybe multiple columns
    {

        hr = THR(pRowset->Index2HROW(hChapter, iRow, hrowTemp));
        if (hr)
        {
            goto Cleanup;
        }

        if (0<iColumn && iColumn<=(LONG)pOSPData->_cSTDCols)
        {
            // a single column is changing
            cColCount = 1;
            iSingleCol = iColumn;
            rgColumns = &iSingleCol;
        }
        
        else if (iColumn == -1)
        {
            // all columns in this row changed
            cColCount = pOSPData->_cSTDCols;
            
            rgColumns = new(Mt(COSPDataCSTDEventsCellChangedHelper_rgColumns)) DBORDINAL[cColCount];
            if (rgColumns == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            
            for (ULONG i=0; i<cColCount; ++i)
            {
                rgColumns[i] = i+1;
            }
        }

        else
        {
            // OSP gave us a bad column number
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //   Currently, we force all 4 event phases to occur, even if the
        //   receiver of the notifications fails on one of the phases.  This is
        //   related to the problem of the changes to the field being visible
        //   before any of the phases actually occur.
        //   There is no notion of the "first time" that a field changed,
        //   thus DBREASON_ROW_FIRSTCHANGE can't be fired.
        if (fBefore)
        {
            hr = pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_OKTODO);
            if (!hr)
                hr = pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_ABOUTTODO);
            if (hr)
                pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO);
        }
        else
        {
            pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_SYNCHAFTER);
            pRowset->FireFieldEvent(hrowTemp, cColCount, rgColumns,
                                       DBREASON_COLUMN_SET, DBEVENTPHASE_DIDEVENT);
        }
    }

Cleanup:
    if (iColumn == -1)
    {
        delete [] rgColumns;
    }
    return hr;
}



//+---------------------------------------------------------------------------
//  Member:     aboutToDeleteRows
//
//  Synopsis:   About To phase of DeletedRows notification
//              
//  Arguments:  iRow                    first row deleted
//              cRows                   number of rows deleted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::aboutToDeleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagOSPEvents, "OSP %x aboutToDeleteRows(%ld,%ld)", MyOSP(), iRow, cRows));
    return DeleteRowsHelper(iRow, cRows, TRUE);
}

//+---------------------------------------------------------------------------
//  Member:     DeletedRows
//
//  Synopsis:   Rows in the STD have been deleted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row deleted
//              cRows                   number of rows deleted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::deletedRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagOSPEvents, "OSP %x deletedRows(%ld,%ld)", MyOSP(), iRow, cRows));
    return DeleteRowsHelper(iRow, cRows, FALSE);
}

//+---------------------------------------------------------------------------
//  Member:     DeletedRowsHelper
//
//  Synopsis:   Rows in the STD have been deleted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row deleted
//              cRows                   number of rows deleted
//              fBefore                 which phase we're in
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::DeleteRowsHelper(DBROWCOUNT iRow, DBROWCOUNT cRows, BOOL fBefore)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::DeletedRows(%p {%u %u})",
          this, iRow, cRows) );

    HRESULT hr = S_OK;
    HROW *aDeletedHROWs = NULL;
    DBCOUNTITEM cDeletedHROWs = 0;
    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;

    if (!pRowset)                       // just in case
        goto Cleanup;

    // ignore notifications about 0 rows
    if (cRows <= 0)
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);
    
    aDeletedHROWs = new(Mt(COSPDataCSTDEventsDeleteRowsHelper_aDeletedHROWs)) HROW[cRows];
    if (!aDeletedHROWs)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pRowset->GenerateHRowsFromHRowNumber(hChapter,
                                                  iRow, 0, cRows, &cDeletedHROWs,
                                                  &aDeletedHROWs));
    Assert(hr || ((LONG)cDeletedHROWs == cRows && "Got wrong number of rows"));

    if (hr || cDeletedHROWs == 0)
        goto Cleanup;
    
    if (fBefore)
    {
        hr = pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_OKTODO);
        if (!hr)
            hr = pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_ABOUTTODO);
        if (hr)
            pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO);
    }
    else
    {
        // Fix up the rowmap that is used to implement bookmark stability
        pRowset->DeleteRows(iRow, (int) cDeletedHROWs, pOSPData);
        pRowset->_cRows -= (LONG)cDeletedHROWs;     // reduce rows in global rowset
        pOSPData->_cSTDRows -= (LONG)cDeletedHROWs; // reduce rows in this OSP
        
        TraceTag((tagOSPRowDelta, "Deleted %ld rows.  Rowset %p has %ld rows, chapter %p has %ld rows",
                    cDeletedHROWs, pRowset, pRowset->_cRows, pOSPData, pOSPData->_cSTDRows));

        pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_SYNCHAFTER);
        pRowset->FireRowEvent(cDeletedHROWs, aDeletedHROWs,
                              DBREASON_ROW_DELETE, DBEVENTPHASE_DIDEVENT);
    }

Cleanup:
    delete [] aDeletedHROWs;
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     InsertedRowsHelper
//
//  Synopsis:   Rows in the STD have been inserted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//              eReason                 so we can handle both insertedRows
//                                      and rowsAvailable events
//              fBefore                 which phases to signal
//
//  Returns:    Returns success.
//
STDMETHODIMP
COSPData::CSTDEvents::InsertRowsHelper(DBROWCOUNT iRow, DBROWCOUNT cRows,
                           INSERT_REASONS reason, BOOL fBefore)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::InsertedRows(%p {%u %u})",
          this, iRow, cRows) );

    HRESULT hr = S_OK;
    DBCOUNTITEM cInsertedHROWs = 0;
    HROW *aInsertedHROWs = NULL;
    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;

    // True iff insertion at end of rowset
    BOOL fAtEnd = (iRow >= (LONG)pOSPData->_cSTDRows);

    if (!pRowset)                       // just in case
        goto Cleanup;

    // ignore notifications about 0 rows
    if (cRows <= 0)
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);
    
    // If this is After phase, it's time to actually do the work!
    if (!fBefore)
    {
        // RowsAvailable events may fire well beyond our current idea
        // of the row array extent.
        if (iRow > (LONG) pOSPData->_cSTDRows+1)
        {
            // Fill in rowmap array to catch up
            LONG cRowsGap = iRow - 1 - pOSPData->_cSTDRows;
            pRowset->InsertRows(pOSPData->_cSTDRows, cRowsGap, pOSPData);
            pRowset->_cRows += cRowsGap;
            pOSPData->_cSTDRows += cRowsGap;
            TraceTag((tagOSPRowDelta, "Inserted gap of %ld rows.  Rowset %p has %ld rows, chapter %p has %ld rows",
                        cRowsGap, pRowset, pRowset->_cRows, pOSPData, pOSPData->_cSTDRows));
        }
        pRowset->_cRows += (ULONG)cRows;       // increase rows in global rowset
        pOSPData->_cSTDRows += (ULONG)cRows;   // increase rows in this OSP
        pRowset->InsertRows(iRow, (int) cRows, pOSPData);
        TraceTag((tagOSPRowDelta, "Inserted %ld rows.  Rowset %p has %ld rows, chapter %p has %ld rows",
                    cRows, pRowset, pRowset->_cRows, pOSPData, pOSPData->_cSTDRows));
    }

    aInsertedHROWs = new(Mt(COSPDataCSTDEventsInsertRowsHelper_aInsertedHROWs)) HROW[cRows];
    if (!aInsertedHROWs)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(pRowset->GenerateHRowsFromHRowNumber(hChapter,
                                                  iRow, 0, cRows,
                                                  &cInsertedHROWs,
                                                  &aInsertedHROWs));
    if (cInsertedHROWs == 0)
        goto Cleanup;

    // Distinguish between ROWS_ADDED at end, and Asynch Rows added in
    // in the middle.
    if (ROWS_ADDED == reason)
        reason = (fAtEnd ? ROWS_ADDED : ROWS_ASYNCHINSERTED);

    // There are four different paths through this code:

    //  1. reason == ROWS_ADDED  (fBefore irrelevant)
    //     We got a rowsAvailable notification from the OSP for rows at the
    //     end of the Rowset . --> send a POPULATION notification on the
    //     IDBAsynchNotify interface.  This notification has no phases.
    //
    //  2. reason == ROWS_ASYNCHINSERTED (fBefore irrelevant)
    //     We got a rowsAvailable notification from the OSP for rows in
    //     the middle of the rowset.  --> send a ROW_ASYNCHINSERT event
    //     on the IRowsetNotify interface, for just the DIDEVENT phase.
    //     Also send a POPULATION notification on IDBAsyncNotify, to allow
    //     listeners to keep their progress bars up to date.

    //  3. reason == ROWS_INSERTED, fBefore == TRUE
    //     We got an aboutToInsertRows notification from the OSP.  
    //     --> send ROW_INSERT events for OKTODO & ABOUTODO phases.

    // 4.  reason == ROWS_INSERTED, fBefore == FALSE
    //     We got an InsertedRows notification from the OSP.
    //     --> send ROW_INSERT events for SYNCHAFTER and DIDEVENT phases.

    if (ROWS_ADDED == reason || ROWS_ASYNCHINSERTED == reason)
    {
        DBROWCOUNT ulProgressMax;

        IGNORE_HR(pOSPData->_pSTD->getEstimatedRows(&ulProgressMax));

        pRowset->FireAsynchOnProgress(pOSPData->_cSTDRows,
                                      ulProgressMax,
                                      DBASYNCHPHASE_POPULATION);
    }
    
    if (ROWS_INSERTED==reason || ROWS_ASYNCHINSERTED==reason)
    {
        if (ROWS_INSERTED==reason)
        {
            if (fBefore)
            {
                hr = pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_OKTODO);
                if (!hr)
                    hr = pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_ABOUTTODO);
                if (hr)
                    pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_FAILEDTODO);
            }
            else
            {
                pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                      DBREASON_ROW_INSERT, DBEVENTPHASE_SYNCHAFTER);
            }
        }

        // By spec, ROW_ASYNCINSERT fires only DIDEVENT
        if (!fBefore)
            pRowset->FireRowEvent(cRows, aInsertedHROWs,
                                  reason==ROWS_INSERTED ? DBREASON_ROW_INSERT :
                                  (DBREASONENUM)DBREASON_ROW_ASYNCHINSERT,
                                  DBEVENTPHASE_DIDEVENT);
    }

Cleanup:
    delete [] aInsertedHROWs;
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     aboutToInsertRows
//
//  Synopsis:   About To phase of InsertedRows
//              
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::aboutToInsertRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::InsertedRows(%p {%u %u})",
          this, iRow, cRows) );
    TraceTag((tagOSPEvents, "OSP %x aboutToInsertRows(%ld,%ld)", MyOSP(), iRow, cRows));

    return InsertRowsHelper(iRow, cRows, ROWS_INSERTED, TRUE);
}

//+---------------------------------------------------------------------------
//  Member:     insertedRows
//
//  Synopsis:   Rows in the STD have been inserted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::insertedRows(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::InsertedRows(%p {%u %u})",
          this, iRow, cRows) );
    TraceTag((tagOSPEvents, "OSP %x insertedRows(%ld,%ld)", MyOSP(), iRow, cRows));

    return InsertRowsHelper(iRow, cRows, ROWS_INSERTED, FALSE);
}

//+---------------------------------------------------------------------------
//  Member:     AsyncRowsArrived
//
//  Synopsis:   Rows in the STD have been inserted.  Therefore,
//              this function cleans up the rowset to reflect this change.
//
//  Arguments:  iRow                    first row inserted
//              cRows                   number of rows inserted
//
//  Returns:    Returns success.
//

STDMETHODIMP
COSPData::CSTDEvents::rowsAvailable(DBROWCOUNT iRow, DBROWCOUNT cRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::AsyncRowsArrived(%p {%u %u})",
          this, iRow, cRows) );
    TraceTag((tagOSPEvents, "OSP %x rowsAvailable(%ld,%ld)", MyOSP(), iRow, cRows));

    return InsertRowsHelper(iRow, cRows, ROWS_ADDED, FALSE);
}


STDMETHODIMP
COSPData::CSTDEvents::transferComplete(OSPXFER stdxfer)
{
    HRESULT hrStatus;

    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::PopulationComplete(%p)", this) );
    TraceTag((tagOSPEvents, "OSP %x transferComplete(%s)", MyOSP(),
                stdxfer==OSPXFER_COMPLETE ? "complete" :
                stdxfer==OSPXFER_ABORT ? "abort" :
                stdxfer==OSPXFER_ERROR ? "error" :
                                        "**unknown**"
                ));

    COSPData *pOSPData;
    pOSPData = MyOSP();
    CImpIRowset *pRowset = pOSPData->_pRowset;
    HCHAPTER hChapter;

    if (!pRowset)                       // just in case
        goto Cleanup;

    hChapter = pRowset->HChapterFromOSPData(pOSPData);
    pOSPData->_fPopulationComplete = TRUE;

    // Good time to update our impression of the final STD size..
    DBROWCOUNT cRowsTemp;
    IGNORE_HR(pOSPData->_pSTD->getRowCount(&cRowsTemp));
    pOSPData->_cSTDRows = (ULONG)cRowsTemp;

    // Fire rowset event
    IGNORE_HR(pRowset->FireAsynchOnProgress(pOSPData->_cSTDRows,
                                            pOSPData->_cSTDRows,
                                            DBASYNCHPHASE_COMPLETE));

    switch (stdxfer)
    {
        case OSPXFER_ABORT:
            hrStatus = DB_E_CANCELED;
            break;
        case OSPXFER_ERROR:
            hrStatus = E_FAIL;
            break;
        case OSPXFER_COMPLETE:
        default:                        // there shouldn't be a default, but
            hrStatus = S_OK;            // having all cases makes compiler happy.
            break;
    }

    IGNORE_HR(pRowset->FireAsynchOnStop(hrStatus));

Cleanup:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\seek.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      seek.cxx
//  Author:    Ted Smith  (tedsmith@microsoft.com)
//
//  Contents:  Implementation of RowsetFind
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetFind specific interface
//
////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------
//
//  Member:    FindNextRows (public member)
//
//  Synopsis:  Given a bookmark and comparison spec, returns cRows HROWs
//             matching.
//
//  Arguments: hChapter         chapter handle
//             hAccessor        accessor for value to be matched
//             pValue           pointer to the value to be matched
//             CompareOp        comparison operation to be used
//             cbBookmark       length of bookmark in bytes
//             pBookmark        pointer to bookmark vector
//             fSkipCurrent     skip current row if TRUE
//             cRows            number of consecutive rows requested to fetch
//             pcRowsObtained   number of consecutive rows actually fetched (OUT)
//             paRows           array of HROWs returned (OUT)
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_EROWLIMITEDEXCEEDED if cRows is > # rows in rowset
//             DB_E_BADINFO     hAccessor specified binding for more than one
//                              column, or was otherwise gubbish
//             DB_S_ENDOFROWSET if we straddled the end of the rowset
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//

STDMETHODIMP
CImpIRowset::FindNextRow(HCHAPTER hChapter, HACCESSOR hAccessor, void * pValue,
                          DBCOMPAREOP CompareOp, DBBKMARK cbBookmark,
                          const BYTE *pBookmark, DBROWOFFSET  lRowsOffset,
                          DBROWCOUNT  cRows, DBCOUNTITEM *pcRowsObtained, HROW  **pahRows)
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetRowsByValues(%p {%u %p %i %i})",
          this, cbBookmark, pBookmark, cRows) );

    HRESULT hr;
    DBCOUNTITEM ulHRow, ulIndex;  // holds HRowNumber, index
    DBROWCOUNT  lIndex2;
    LONG    iter=1;             // -1 for backwards, 1 for forwards
    OSPFIND stdFind=(OSPFIND)0; // stdFind flags for ISimpleTabularData Find function
    OSPCOMP stdComp;
    VARIANT var;
    BOOL    fRowsAllocated=FALSE; // TRUE iff we allocated memory for pahRows
    DBBINDING       *pBinding;
    ULONG           cBindings;
    AccessorFormat  *pAccessor;
    COSPData        *pOSPData = GetpOSPData(hChapter);

    Assert(hAccessor);
    pAccessor = (AccessorFormat *)hAccessor;

    cBindings = pAccessor->cBindings;
    pBinding  = pAccessor->aBindings;

    // Binding must be for one column, and must have a value part..
    // (anything else we should add here??)
    if (cBindings != 1)
    {
        hr = DB_E_BADBINDINFO;
        goto Cleanup;
    }

    if (pcRowsObtained == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    *pcRowsObtained = 0;

    // NULL bookmark argument means use internal cursor
    if (!pBookmark)
    {
        pBookmark = (BYTE *)&pOSPData->_iFindRowsCursor;
        cbBookmark = sizeof(ULONG);
        if (pOSPData->_iFindRowsCursor==DBBMK_INITIAL)
        {
            pOSPData->_iFindRowsCursor = cRows > 0 ? DBBMK_FIRST : DBBMK_LAST;
        }
    }

    hr = THR(Bookmark2HRowNumber(hChapter, cbBookmark, pBookmark, ulHRow));
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }

    // Convert OLE-DB compareOps to STD compType.
    switch (CompareOp)
    {
        case DBCOMPAREOPS_LT:
            stdComp = OSPCOMP_LT; 
            break;
        case DBCOMPAREOPS_LE:
            stdComp = OSPCOMP_LE;
            break;
        case DBCOMPAREOPS_EQ:
            stdComp = OSPCOMP_EQ;
            break;
        case DBCOMPAREOPS_GE:
            stdComp = OSPCOMP_GE;
            break;
        case DBCOMPAREOPS_GT:
            stdComp = OSPCOMP_GT;
            break;

//        case DBCOMPAREOPS_PARTIALEQ:    // special case
//            hr = E_FAIL;                // not yet implemented
//            goto Cleanup;
//            stdComp = OSPCOMP_EQ;       // TODO - partial not done yet.
//            break;

        case DBCOMPAREOPS_NE:
            stdComp = OSPCOMP_NE;
            break;
        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    ulHRow += lRowsOffset;

    // range check rowIndex, esp after above compuation.
    if ((LONG) ulHRow < 1 || ulHRow > pOSPData->_cSTDRows)
    {
        hr = DB_S_ENDOFROWSET;
        goto Cleanup;
    }

    if (cRows < 0)
    {
        stdFind = OSPFIND_UP;
        cRows = -cRows;     // now its an iteration count, not a direction
        iter = -1;
    }

    // If we were asked to, allocate a block of memory large enough to hold all
    // the rows requested (even though our match might not turn up this many).
    if (!*pahRows)
    {
        *pahRows = (HROW *)CoTaskMemAlloc(sizeof(HROW) * cRows);
        if (!*pahRows)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        fRowsAllocated = TRUE;
    }

    ulIndex = ulHRow;

    // NOTE:: We depend on OLEDB types and Variant types to be the same here.
    // This is true at least through DBYTE_UI8 == VT_UI8
    if (pBinding->wType > DBTYPE_UI8)
    {
        hr = DB_E_UNSUPPORTEDCONVERSION;
        goto Cleanup;
    }

    // special case NULL binding
    if (pBinding->dwPart&DBPART_STATUS &&
        DBSTATUS_S_ISNULL==*(DBSTATUS *)((BYTE *)pValue+pBinding->obStatus))
    {
        var.vt = VT_NULL;
    }
    else if (pBinding->dwPart&DBPART_VALUE)
    {
        CVarToVARIANTARG((void *)((BYTE *)pValue+pBinding->obValue),
                         pBinding->wType, (VARIANTARG *)&var);
    }
    else
    {
        // We were passed neither a NULL binding nor a value.
        hr = DB_E_BADBINDINFO;
        goto Cleanup;
    }

 
    // See if we can find a matching row.
    hr = GetpOSP(hChapter)->find(ulIndex,  pBinding->iOrdinal, var, stdFind, stdComp,
                                 &lIndex2);
    // -1 is returned for not found
    if (lIndex2==-1)
    {
        hr = DB_S_ENDOFROWSET;          // by spec
        goto Cleanup;
    }

    if (FAILED(hr))
    {
        // Do some conversion of OLE error codes to OLE-DB error codes if we
        // know how, otherwise clamp to E_UNEXPECTED
        if (DISP_E_TYPEMISMATCH==hr)
            hr = DB_E_UNSUPPORTEDCONVERSION;
        else
            hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Get the next cRows rows.. cRows might even be zero
    while (cRows--)
    {
        // Convert our hRowIndex to a real hRow and put it in the result array
        Index2HROW(hChapter, (ULONG)lIndex2, *pahRows[*pcRowsObtained]);

        (*pcRowsObtained)++;
        lIndex2 += iter;

        // About to step off the beginning?
        if (iter<0 && lIndex2==0)
        {
            hr = DB_S_ENDOFROWSET;
            break;
        }

    }

    // Spec says we set internal cursor to bookmark of last row found,
    // not the last row returned!
    if (cRows)
    {
        pOSPData->_iFindRowsCursor = *pahRows[0];
    }

Cleanup:
    if (fRowsAllocated && !*pcRowsObtained)
    {
        CoTaskMemFree((void *)pahRows);
        *pahRows = NULL;
    }

    // We don't need to set a whole clamp list here, since standard OLE-DB error
    // codes are handled by RRETURN now.
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dlay\nile2std\scroll.cxx ===
//+-----------------------------------------------------------------------
//  Microsoft OLE/DB to STD Mapping Layer
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:      scroll.cxx
//  Author:    Ido Ben-Shachar (t-idoben@microsoft.com)
//
//  Contents:  Implementation of RowsetExactScroll
//             Implementation of RowsetScroll
//
//------------------------------------------------------------------------

#include <dlaypch.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include "rowset.hxx"
#endif

////////////////////////////////////////////////////////////////////////////////
//
// IRowsetScroll specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    GetApproximatePosition (public member)
//
//  Synopsis:  Given a bookmark, returns the corresponding row number.
//
//  Arguments: hChapter         chapter handle
//             cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             pulPosition      row number                       (OUT)
//             pcRows           total number of rows             (OUT)
//
//  Returns:   Success          if inputs are valid.
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark is invalid.
//             DB_E_NOTREENTRANT if illegal reentrancy (nested delete)
//

STDMETHODIMP
CImpIRowset::GetApproximatePosition (HCHAPTER hChapter,
                                     DBBKMARK cbBookmark,   const BYTE *pBookmark,
                                     DBCOUNTITEM *pulPosition, DBCOUNTITEM *pcRows )
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetApproximatePosition(%p {%u %p %p %p})",
          this, cbBookmark, pBookmark, pulPosition, pcRows) );

    HRESULT hr = S_OK;
    DBCOUNTITEM ulPosition;
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (cbBookmark && pBookmark==NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }
    
    if (pcRows)
        *pcRows = pOSPData->_cSTDRows; // get rows in table

    if (cbBookmark == 0)
        goto Cleanup;                   // no position desired, just size

    hr = THR(Bookmark2HRowNumber(hChapter, cbBookmark, pBookmark, ulPosition));
    if (hr)
    {
        if (hr != DB_S_BOOKMARKSKIPPED) goto Cleanup;
        hr = S_OK;      // this call does not return DB_S_BOOKMARKSKIPPED
    }
    
    if (ulPosition > pOSPData->_cSTDRows && cbBookmark != 1) // Predefined bmks OK
    {
        hr = DB_E_BADBOOKMARK;
    }

    if (pOSPData->_cSTDRows == 0) // if rowset is empty, always return 0 position
        ulPosition = 0;
	
    if (pulPosition)
    	*pulPosition = ulPosition;

Cleanup:
    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    GetRowsAtRatio (public member)
//
//  Synopsis:  Returns a set of contiguous rows within the rowset, starting
//             at a certain ratio into the rowset.  The user can allocate
//             memory for the returned row handles by setting pahRows
//             to a block of memory.  If it is NULL, this function will
//             allocate that memory.
//
//  Arguments: hChapter         chapter handle
//             ulNumberator     numerator of ratio
//             ulDenominator    denominator of ratio
//             cRows            rows to fetch and direction to fetch in
//             pcRowsObtained   rows obtained
//             pahRows          handles of rows obtained
//
//  Returns:   S_OK             if all rows could be fetched.
//             DB_S_ENDOFROWSET if we straddled the end of the rowset
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark was invalid.
//

STDMETHODIMP
CImpIRowset::GetRowsAtRatio (HWATCHREGION,
                             HCHAPTER hChapter,
                             DBCOUNTITEM ulNumerator,
                             DBCOUNTITEM ulDenominator,
                             DBROWCOUNT cRows,
                             DBCOUNTITEM *pcRowsObtained,
                             HROW **pahRows )
{
    TraceTag((tagNileRowsetProvider,
             "CImpIRowset::GetRowsAtRatio(%p {%u %u %d %p %p})",
             this, ulNumerator, ulDenominator, cRows,
             pcRowsObtained, pahRows) );

    HRESULT hr;
    LONG    iRowFirst;                   // row to start fetching at
    COSPData *pOSPData = GetpOSPData(hChapter);

    if (pOSPData == NULL)
    {
        hr = DB_E_BADCHAPTER;
        goto Cleanup;
    }

    // Find row to start fetching at.  Note that this function returns -1
    //   on overflow or division by 0, so the error checking, in checking
    //   bounds, catches this.
    // Note the +1 because ulNumerator is zero-based, and we're 1-based.
    iRowFirst = MulDiv(pOSPData->_cSTDRows,
                       ulNumerator, ulDenominator) + 1;

    if (pOSPData->_cSTDRows < (ULONG)iRowFirst)
    {
        hr = DB_E_BADRATIO;
        goto Cleanup;
    }

    // GenerateHRowsFromHRowNumber fails NULL args
    hr = THR(GenerateHRowsFromHRowNumber(hChapter, iRowFirst, 0, cRows,
                                         pcRowsObtained, pahRows ));
    Assert(FAILED(hr) || (pcRowsObtained != NULL && pahRows != NULL));
    if (hr)
    {
        // We can't return DB_S_BOOKMARKSKIPPED; figure out if that was
        //  masking a DB_S_ENDOFROWSET.
        if (hr == DB_S_BOOKMARKSKIPPED)
        {
            hr = (*pcRowsObtained == (ULONG) abs(cRows)
                    ? S_OK : DB_S_ENDOFROWSET);
        }
        else if (FAILED(hr))
        {
            // We can't return DB_E_BADBOOMARK, either
            if (hr == DB_E_BADBOOKMARK)
            {
                hr = DB_E_BADRATIO;
            }
            goto Cleanup;
        }
    }                                
            

    FireRowEvent(*pcRowsObtained, *pahRows,
                 DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT);

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// IRowsetExactScroll specific interfaces
//
////////////////////////////////////////////////////////////////////////////////


//+-----------------------------------------------------------------------
//
//  Member:    GetExactPosition (public member)
//
//  Synopsis:  Given a bookmark, returns the corresponding row number.
//
//  Arguments: hChapter         hChapter
//             cbBookmark       number of bytes in the bookmark
//             pBookmark        pointer to bookmark
//             pulPosition      row number                       (OUT)
//             pcRows           total number of rows             (OUT)
//
//  Returns:   Success          if inputs are valid.
//             E_INVALIDARG     if output pointers are null.
//             DB_E_BADCHAPTER  if chapter passed in
//             DB_E_BADBOOKMARK if bookmark is invalid.
//

STDMETHODIMP
CImpIRowset::GetExactPosition (HCHAPTER hChapter,
                               DBBKMARK cbBookmark,
                               const BYTE *pBookmark,
                               DBCOUNTITEM *pulPosition,
                               DBCOUNTITEM *pcRows )
{
    TraceTag((tagNileRowsetProvider,
          "CImpIRowset::GetExactPosition(%p {%u %p %p %p})",
          this, cbBookmark, pBookmark, pulPosition, pcRows) );

    return GetApproximatePosition(hChapter, cbBookmark, pBookmark,
                                  pulPosition, pcRows );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\core.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF

DXTROOT = $(SUBPROJROOT:\core=)
ROOT    = $(SUBPROJROOT:\src\dxt\core=)

# Trident's common.inc says to treat level 4 warnings as errors.  We wish.

WARNING_LEVEL       = W3

!include $(ROOT)\common.inc


USE_ATL=1
ATL_VER=21


INCLUDES = \
    $(INCLUDES);                \
    $(DXTROOT)\idl\$(O);        \
    $(SUBPROJROOT)\inc;         \
    $(SUBPROJROOT)\src;         \
    $(SUBPROJROOT)\mscanner;    \
    $(ROOT)\src\core\include;   \
    $(SHELL_INC_PATH);

C_DEFINES=$(C_DEFINES) -D_DXTRANSIMPL -D_WINDOWS -D_WINDLL

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
    atlbase.h       \
    atlcom.h        \
    atlctl.h        \
    atlctl.cpp      \
    atlimpl.cpp     \
    macapi.h        \
    macnam1.h       \
    macname2.h      \
    macocidl.h      \
    macpub.h        \
    new             \
    rpcerr.h        \
    rpcmac.h        \
    statreg.cpp     \
    statreg.h       \
    thunk.h         \
    winwlm.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes the standard includes

#include "common.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <dtbase.cpp>
#include <dxsurfb.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\dll\dxtrans.cpp ===
// DXTrans.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DXTransps.mk in the project directory.

#include "common.h"
#include "resource.h"
#include "TranFact.h"
#include "TaskMgr.h"
#include "Scale.h"
#include "Label.h"
#include "Geo2D.h"
#include "DXSurf.h"
#include "SurfMod.h"
#include "surfmod.h"
#include "DXRaster.h"
#include "Gradient.h"
#include "dxtfilter.h"
#include "dxtfilterbehavior.h"
#include "dxtfiltercollection.h"
#include "dxtfilterfactory.h"
#ifdef _DEBUG
#include <crtdbg.h>
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DXTransformFactory,  CDXTransformFactory )
    OBJECT_ENTRY(CLSID_DXTaskManager,       CDXTaskManager      )
    OBJECT_ENTRY(CLSID_DXTScale,            CDXTScale           )
    OBJECT_ENTRY(CLSID_DXTLabel,            CDXTLabel           )
    OBJECT_ENTRY(CLSID_DX2D,                CDX2D               )
    OBJECT_ENTRY(CLSID_DXSurface,           CDXSurface          )
    OBJECT_ENTRY(CLSID_DXSurfaceModifier,   CDXSurfaceModifier  )
    OBJECT_ENTRY(CLSID_DXRasterizer,        CDXRasterizer       )
    OBJECT_ENTRY(CLSID_DXGradient,          CDXGradient         )
    OBJECT_ENTRY(CLSID_DXTFilter,           CDXTFilter          )
    OBJECT_ENTRY(CLSID_DXTFilterBehavior,   CDXTFilterBehavior  )
    OBJECT_ENTRY(CLSID_DXTFilterCollection, CDXTFilterCollection)
    OBJECT_ENTRY(CLSID_DXTFilterFactory,    CDXTFilterFactory   )
END_OBJECT_MAP()


//+-----------------------------------------------------------------------------
//
//  This section was added when moving code over to the Trident tree.  The
//  following global variables and functions are required to link properly.
//
//------------------------------------------------------------------------------

// lint !e509 
// g_hProcessHeap is set by the CRT in dllcrt0.c

EXTERN_C HANDLE     g_hProcessHeap      = NULL;
LCID                g_lcidUserDefault   = 0;
DWORD               g_dwFALSE           = 0;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
#ifdef _DEBUG
        // Turn on memory leak checking
//        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
//        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
//        _CrtSetDbgFlag( tmpFlag );

//      ::GdiSetBatchLimit( 1 );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

//
//  Table of categories and resourece IDs to register
//
typedef struct tagDXCATINFO
{
    const GUID * pCatId;
    int ResourceId;
} DXCATINFO;

const DXCATINFO g_aDXCats[] = 
{
    { &CATID_DXImageTransform, IDS_DXIMAGETRANSFORM },
    { &CATID_DX3DTransform, IDS_DX3DTRANSFORM },
    { &CATID_DXAuthoringTransform, IDS_DXAUTHORINGTRANSFORM },
    { NULL, 0 }
};

//
//  Code to register transition categories
//
HRESULT RegisterTransitionCategories(bool bRegister)
{
    HRESULT         hr          = S_OK;
    char            szLCID[20];
    const HINSTANCE hinst       = _Module.GetResourceInstance();

    if (LoadStringA(hinst, IDS_LCID, szLCID, sizeof(szLCID)) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        CComPtr<ICatRegister>   pCatRegister;
        LCID                    lcid            = atol(szLCID);
        const DXCATINFO *       pNextCat        = g_aDXCats;

        hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, 
                              CLSCTX_INPROC, IID_ICatRegister, 
                              (void **)&pCatRegister);

        while (SUCCEEDED(hr) && pNextCat->pCatId) 
        {
            if (bRegister)
            {
                CATEGORYINFO catinfo;

                catinfo.catid   = *(pNextCat->pCatId);
                catinfo.lcid    = lcid;

                LoadString(hinst, pNextCat->ResourceId,
                           catinfo.szDescription, 
                           (sizeof(catinfo.szDescription) / sizeof(catinfo.szDescription[0])));

                hr = pCatRegister->RegisterCategories(1, &catinfo);
            }
            else
            {
                hr = pCatRegister->UnRegisterCategories(1, (CATID *)pNextCat->pCatId);
            }
            pNextCat++;
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = RegisterTransitionCategories(true);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = _Module.RegisterServer(TRUE);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    RegisterTransitionCategories(false);

    _Module.UnregisterServer();

    // Manually un-register type library, we don't really care if this
    // call fails.

    ::UnRegisterTypeLib(LIBID_DXTRANSLib, 
                        DXTRANS_TLB_MAJOR_VER, DXTRANS_TLB_MINOR_VER, 
                        LOCALE_NEUTRAL, SYS_WIN32);

    return S_OK;
}


//
//
//
STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(ObjectMap)/sizeof(ObjectMap[0])) - 1)
    {
        return S_FALSE;
    }

    *pclsid = *(ObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\inc\dassert.h ===
//************************************************************
//
// FileName:	        DAssert.h
//
// Created:	        1998
//
// Author:	        Paul Nash
// 
// Abstract:	        Defines DEBUG Assertion macro
//
// Change History:
// 11/09/98 PaulNash    Port from Trident3D -- don't bother with debug strings
//
// Copyright 1998, Microsoft
//************************************************************

#ifdef _DEBUG

#ifdef _X86_
// On X86 platforms, break with an int3 if the condition is not met.
#define DASSERT(x)      {if (!(x)) _asm {int 3} }

#else // !_X86_
// If we're not on X86, use the cross-platform version of an int 3.
#define DASSERT(x)      {if (!(x)) DebugBreak(); }

#endif !_X86_

#else !_DEBUG

#define DASSERT(x)

#endif _!DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DXTrans.rc
//
#define IDS_PROJNAME                    100
#define IDR_DXTRANSFORMFACTORY          101
#define IDS_LCID                        102
#define IDR_DXOBJECTCACHE               103
#define IDS_DXIMAGETRANSFORM            104
#define IDR_DXTASKMANAGER               105
#define IDS_DX3DTRANSFORM               106
#define IDR_DXTSCALE                    107
#define IDS_DXAUTHORINGTRANSFORM        108
#define IDR_DXTLABEL                    110
#define IDR_DX2D                        111
#define IDR_DXRASTERIZER                112
#define IDR_SURFTRAN                    113
#define IDR_DXSURFACE                   114
#define IDR_DXSURFACEMODIFIER           115
#define IDR_DXGRADIENT                  116
#define IDR_DXWARP                      117
#define IDR_DXTFILTERBEHAVIOR           118
#define IDR_DXTFILTERFACTORY            119 
#define IDR_DXTFILTER                   120
#define IDR_DXTFILTERCOLLECTION         121
#define IDB_BITMAP1                     200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mcoverage.cpp ===
//************************************************************
//
// FileName:	    mcoverage.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Sub-pixel coverage buffer implementation file
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
// 08/07/99 a-matcal    Replaced calls to calloc with malloc and ZeroMemory to
//                      use the IE crt.
//
// Copyright 1998, Microsoft
//************************************************************

#include "precomp.h"
#include "MSupport.h"
#include "MCoverage.h"

// =================================================================================================================
// CoverageTables
// =================================================================================================================

// NOTE: These static variables have logically the same values; so even if multiple
// threads try to generate the data. We only set the "fGenerated" flag at the
// end to prevent any thread from using the data before it is ready.
ULONG CoverageBuffer::lefttable8[32];
ULONG CoverageBuffer::righttable8[32];
ULONG CoverageBuffer::splittable8[1024];

bool CoverageBuffer::g_fCoverageTablesGenerated = false;

void CoverageBuffer::GenerateCoverageTables()
{
    // Only regenerate them if we need to
    if (g_fCoverageTablesGenerated)
        return;

    // These three tables are only used to generate 
    // the 'real' left/right/split tables
    ULONG lefttable[32];
    ULONG righttable[32];
    ULONG countbits[256];

    // =================================================================================================================
    // 1 bit tables:
    //      These are indexed from 0 to 31. And indicate which bits would
    //      be turned on for certain kinds of segments.
    //
    //      Remember that DWORDs are in reverse order, i.e. Index 0 is to the right.
    //
    //      For better visual quality, I'm going to assume that the left edge
    //      is inclusive and the right edge is exclusive. The old meta code,
    //      wasn't consistent.
    //
    //      The left table indicates that if an segment starts at i and goes to
    //      bit 31; then which bits would be on? Hence 
    //      lefttable[0] = 0xffffffff and lefttable[31] = 0x80000000.
    //
    //      The right table indicates that if an segment ended at i but started at the
    //      bit zero; then which bits would be on? Hence
    //      righttable[0] = 0x00000000 and righttable[31] = 0x7fffffff;
    //
    //
    // =================================================================================================================
    ULONG left = 0xffffffff;
    ULONG right	= 0x00000000;
    for (ULONG i = 0; i < 32; i++)
    { 
        righttable[i] = right;
        right <<= 1;
        right |= 0x00000001;

        // These shifts are unsigned
        lefttable[i] = left;
        left <<= 1;
    }

    // Check boundary cases
    DASSERT(lefttable[0] == 0xFFFFFFFF);
    DASSERT(lefttable[31] == 0x80000000);
    DASSERT(righttable[0] == 0x00000000);
    DASSERT(righttable[31] == 0x7FFFFFFF);

    // Now, we want to have a lookup table to count how
    // bits are on for any particular 8-bit value
    // Hence countbits[0] = 0, countbits[255] = 8, countbits[0x0F] = 4.
    // (There are faster ways; but this is only done once per the lifetime
    // the DLL.)
    for (ULONG j = 0; j < 256; j++)
    {
        ULONG val = j;
        ULONG count = 0;
        while (val)
        {
            count += val & 1; 
            val >>=1;
        }
        DASSERT(count <= 8);
        countbits[j] = count;
    }

    // Sanity check some cases
    DASSERT(countbits[0] == 0);
    DASSERT(countbits[255] == 8);
    DASSERT(countbits[0xF0] == 4);
    DASSERT(countbits[0x0F] == 4);
    
    // =================================================================================================================
    // 8 bit tables -
    //      For 8-bit coverage buffers (which is the way this file is implemented), we
    //  need to imagine that a run of 32 sub pixels is split into 4 cells of 8 sub-pixels.
    //  Each cell is a byte in size; the whole run is in a DWORD. For each byte, we want
    //  to place a count in that byte indicating how many of the sub-pixels were hit.
    //
    //  Remember that DWORDs are in reverse order, i.e. Index 0 is to the right. Also,
    //  the left edge is inclusive and right edge is exclusive.
    //
    //  lefttable8 indicates, if an edge started at i, and continued to 
    //  bit 31, then how many sub-pixels for each cell are hit?
    //  Hence, lefttable8[0] should be 0x08080808 and lefttable8[31] = 0x01000000.
    //  Lefttable[16] = 0x08080000
    //  
    //  righttable8 indicates if an edge ended at i, and started at 
    //  bit zero, then how many sub-pixels for each cell are hit?
    //  Hence righttable8[0] should be 0x00000000 and righttable8[31] = 0x07080808
    //  Righttable8[16] = 0x00000808
    //
    //  The way that this is computed is that we look at the one-bit left and right
    //  tables and for each byte, we run it through count bits. Then we pack into
    //  the DWORD for each lefttable8 and righttable8 entry.
    //
    // =================================================================================================================
    for (LONG k = 0; k < 32; k++)
    {
        // Take the top byte, shift it to the base position, count the bits,
        // then move it back to the top-most byte.
        lefttable8[k] = countbits[(lefttable[k] & 0xff000000) >> 24] << 24;
        lefttable8[k] |= countbits[(lefttable[k] & 0x00ff0000) >> 16] << 16;
        lefttable8[k] |= countbits[(lefttable[k] & 0x0000ff00) >> 8] << 8;
        lefttable8[k] |= countbits[(lefttable[k] & 0x000000ff) >> 0] << 0;

        // Take the top byte, shift it to the base position, count the bits,
        // then move it back to the top-most byte.
        righttable8[k] = countbits[(righttable[k]&0xff000000)>>24]<<24;
        righttable8[k] |= countbits[(righttable[k]&0x00ff0000)>>16]<<16;
        righttable8[k] |= countbits[(righttable[k]&0x0000ff00)>>8 ]<<8;
        righttable8[k] |= countbits[(righttable[k]&0x000000ff)>>0 ]<<0;
    }

    // Sanity check values
    DASSERT(lefttable8[0] == 0x08080808);
    DASSERT(lefttable8[0x10] == 0x08080000);
    DASSERT(lefttable8[0x1f] == 0x01000000);
    DASSERT(righttable8[0] == 0x00000000);
    DASSERT(righttable8[0x10] == 0x00000808);
    DASSERT(righttable8[0x1f] == 0x07080808);

    // Now this is complicated case; what if an segment starts and
    // ends inside the same 32 sub-pixel run? Then we have
    // a special table that is indexed by a start and stop pair
    // of offsets. (i is the starting and j is the ending index; the entry is (i<<5 + j));
    // 
    // So if we AND lefttable[i] and righttable[j], then we get the bit mask
    // that indicates which bits are on for that segment. And we only care about (i <= j).
    //
    // Remember that the zero bit is the right-most bit in a DWORD; and that we treat
    // the starting offset as inclusive and the ending offset as exclusive
    //
    // Examples:
    // Splittable8[0, 31] = 0x07080808
    // Splittable8[1, 31] = 0x07080807
    // Splittable8[16,16] = 0x00000000
    // Splittable8[16,17] = 0x00010000
    //
    // So if we bit-wise AND the one-bit lefttable and righttable together, 
    // we get the mask of which bits would be on; so then we use countbits to
    // convert into the 8-bit cell format.
    for (i = 0; i < 32; i++)
    {
        for (j = i; j < 32; j++)
        {
            DASSERT(i <= j);

            ULONG bits = (lefttable [i]) & (righttable[j]);
            ULONG value;
            value = countbits[(bits & 0xff000000) >> 24] << 24;
            value |= countbits[(bits & 0x00ff0000) >> 16] << 16;
            value |= countbits[(bits & 0x0000ff00) >> 8] << 8;
            value |= countbits[(bits & 0x000000ff) >> 0] << 0;

            splittable8[(i << 5) + j] = value;
        }
    }
    
    // Check our assumptions
    DASSERT(splittable8[(0 << 5) + 31] == 0x07080808);
    DASSERT(splittable8[(1 << 5) + 31] == 0x07080807);
    DASSERT(splittable8[(16 << 5) + 16] == 0x00000000);
    DASSERT(splittable8[(16 << 5) + 17] == 0x00010000);

    // Set this flag only at the end to prevent threads
    // for getting all messed up.
    g_fCoverageTablesGenerated = true;

} // GenerateCoverageTables

// =================================================================================================================
// Constructor
// =================================================================================================================
CoverageBuffer::CoverageBuffer(void) :
    m_pbScanBuffer(NULL),
    m_cbScanWidth(0)
{
    GenerateCoverageTables();
} // CoverageBuffer

// =================================================================================================================
// Destructor
// =================================================================================================================
CoverageBuffer::~CoverageBuffer()
{
    if (m_pbScanBuffer)	
    {
        ::free(m_pbScanBuffer);
        m_pbScanBuffer = NULL;
    }
} // ~CoverageBuffer

// =================================================================================================================
// AllocSubPixelBuffer
// =================================================================================================================
bool CoverageBuffer::AllocSubPixelBuffer(ULONG cbWidth, ULONG cpixelOverSampling)
{
    if (!IsPowerOf2(cpixelOverSampling))	
    {
        DASSERT(false);	
        return false;
    }

    // Check if no changes to the width or sub-sampling resolution
    if (cbWidth == m_cbScanWidth && m_pbScanBuffer && (cpixelOverSampling == m_cpixelOverSampling))
    {
        // Zero our buffer
        ZeroMemory(m_pbScanBuffer, cbWidth);

        // Initialize to outside values
        // so that we will always update them to
        // the correct min/max as we render
        m_idwPixelMin = m_cbScanWidth;
        m_idwPixelMax = 0;

        return true;
    }

    // Capture some useful state
    m_cbScanWidth = cbWidth;
    m_cSubPixelWidth = cbWidth * cpixelOverSampling;
    m_cpixelOverSampling = cpixelOverSampling;
    m_dwSubPixelShift = Log2(cpixelOverSampling);

    // We expect scanRowBytes to be a multiple of 4
    ULONG scanRowBytes = (m_cbScanWidth+3)&(~3); // long aligned
    DASSERT((scanRowBytes & 3) == 0);

    if (m_pbScanBuffer)
    {
        ::free(m_pbScanBuffer);
        m_pbScanBuffer = NULL;
    }
    
    if (!m_pbScanBuffer)
    {
        // Allocate and Zero some memory

        m_pbScanBuffer = (BYTE *)::malloc(scanRowBytes);

        if (!m_pbScanBuffer)	
        {
            DASSERT (0);	
            return false;
        }

        ZeroMemory(m_pbScanBuffer, scanRowBytes);
    }
    
    // Initialize to outside values
    // so that we will always update them to
    // the correct min/max as we render
    m_idwPixelMin = m_cbScanWidth;
    m_idwPixelMax = 0;

    ExtentsClearAndReset();
    
    return true;
} // AllocSubPixelBuffer

//
//  Optimize for speed here
//
#ifndef _DEBUG
#pragma optimize("ax", on)
#endif

// =================================================================================================================
// ExtentsClearAndReset
//      The main purpose of this function is to Zero out our coverage buffer array. It 
//      gets called every Destination scan-line.
// =================================================================================================================
void CoverageBuffer::ExtentsClearAndReset(void)
{
    // Minimum Byte index that was touched in the coverage array
    ULONG start = MinPix();
    DASSERT(start >= 0);

    // Approximate maximum Byte index that was touched in the array
    ULONG end = MaxPix();
    DASSERT(end <= m_cbScanWidth);

    LONG range = end - start;

    if ((range <= 0) || ((ULONG)range > m_cbScanWidth))	
        return;
    
    // This is optimization to reduce how much memory
    // we clear out.
    ZeroMemory(m_pbScanBuffer + start, range);

#ifdef DEBUG
    {
        // To check that the optimization is correct;
        // we check that all the bytes in the scan buffer are now zero'ed
        for (ULONG i = 0; i < m_cbScanWidth; i++)
        {
            if (m_pbScanBuffer[i] != 0)
            {
                DASSERT(m_pbScanBuffer[i] == 0);
            }
        }
    }
#endif // DEBUG

    m_idwPixelMin = m_cbScanWidth;	
    m_idwPixelMax = 0;
} // ExtentsClearAndReset


//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mcoverage.h ===
//************************************************************
//
// FileName:	    mcoverage.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Sub-pixel coverage buffer header file
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef _Coverage_H // for entire file
#define _Coverage_H

#include "msupport.h"

// =================================================================================================================
// CoverageBuffer
// =================================================================================================================
class CoverageBuffer
{
protected:
    BYTE *m_pbScanBuffer;           // eight-bit scanning buffer
    ULONG m_cbScanWidth;	    // width in pixels
    ULONG m_cSubPixelWidth;	    // width in subpixels
    ULONG m_dwSubPixelShift;        // Shift value for the sub-sampling
    ULONG m_cpixelOverSampling;     // Degree of horizontal sub-pixel accuracy

    // Optimization values; keeps track of the least/greatest
    // DWORDs that were touched during the BlastScanLine process
    ULONG m_idwPixelMin;
    ULONG m_idwPixelMax;

    // Internal static arrays for keeping track of various bitmask
    // and counts
    static ULONG lefttable8[32];
    static ULONG righttable8[32];

    // This table is so large that we optimize to reduce
    // memory bandwidth instead of code-size
    static ULONG splittable8[1024];

    // Flag indicating if these are initialized
    static bool g_fCoverageTablesGenerated;

    // Static function to initialize these arrays
    static void GenerateCoverageTables();
    
public:
    // =================================================================================================================
    // Constructor/Destructor
    // =================================================================================================================
    CoverageBuffer();
    ~CoverageBuffer();
    
    bool AllocSubPixelBuffer(ULONG width, ULONG cpixelOverSampling);
    
    // =================================================================================================================
    // Members
    // =================================================================================================================
    ULONG Width()			
    {
        return m_cbScanWidth;
    } // Width

    ULONG MinPix()			
    {
        // Our cached value is a DWORD index; but
        // we need to return a byte pointer offset
        // Note that this is exactly the offset of 
        // the first touched byte i.e. inclusive
        return (m_idwPixelMin * sizeof(DWORD));
    } // MinPix

    ULONG MaxPix()			
    {
        // Our cached value is a DWORD index; but
        // we need to return a byte pointer offset. 
        // (Also, we need to clamp to our max byte since
        // we rely on letting the DWORD stuff overshoot.)

        // Note that this is 1 byte past the end i.e. exclusive
        ULONG ibPixelMax = (m_idwPixelMax + 1) * sizeof(DWORD);
        if (ibPixelMax > m_cbScanWidth)
            ibPixelMax = m_cbScanWidth;
        return ibPixelMax;
    } // MaxPix

    BYTE *Buffer()		
    {
        return m_pbScanBuffer;
    } // Buffer

    // =================================================================================================================
    // Functions
    // =================================================================================================================
    void ExtentsClearAndReset(void);
    void BlastScanLine(ULONG x1, ULONG x2);
}; // CoverageBuffer

// Inlines (for performance)
// BlastScanLine is only called from one place; and it on the
// critical path. 
// NOTE: x1 is inclusive and x2 is exclusive
inline void CoverageBuffer::BlastScanLine(ULONG x1, ULONG x2)
{
    // Sanity check state and parameters
    DASSERT(m_pbScanBuffer);
    DASSERT(m_cSubPixelWidth > 0);

    // Caller is responsible for these checks; beccause
    // the caller can do them more efficiently
    DASSERT(x1 < x2);
    DASSERT(x2 <= m_cSubPixelWidth);
    DASSERT(x1 >= 0);

    // blast scanline
    ULONG *pdwScanline = (ULONG*)m_pbScanBuffer;

    // X1, X2 are in sub-pixel space; so we need
    // shift by m_dwSubPixelShift to get into Byte-space
    // and then we need to shift by 2 to get into Dword-space
    ULONG left = x1 >> (m_dwSubPixelShift + 2);		
    ULONG right = x2 >> (m_dwSubPixelShift + 2);	
    ULONG width = right - left;

    // Update our min and max coverage limits (this is kept in
    // dword offsets.) This is done to reduce the time
    // spent generating the RLE for RenderScan and to reduce
    // the cost of ExtentsClearAndReset
    if (left < m_idwPixelMin)		
        m_idwPixelMin = left;
    if (right > m_idwPixelMax)		
        m_idwPixelMax = right;

    // <kd> I'm not sure that I fully understand this logic here..
    //
    // This is the magic that let's us always use SolidColor8 = 0x08080808
    // even when the horiz. sub-sampling degree doesn't equal 8.
    //
    //  subsample  -> shift  => Result
    //  8               0       x1, and x2 are masked down their last 5 bits
    //  4               1       x1, and x2 are masked down to their low 4 bits (but it is
    //                          shifted to the left once to double their weights)
    //  2               2       x1 and x2 are masked down to their low 3 bits (but it is
    //                          shifted to the left twice to quadruple their weights)
    //  16              -1   => x1 and x2 are masked down to their low 6 bits (but it is
    //                          shifted once more to the right losing that last bit of detail)
    // 

    LONG shift = 3 - m_dwSubPixelShift;
    if (shift >= 0)	
    {
        x1 = (x1 << shift) & 31;
        x2 = (x2 << shift) & 31;
    }
    else
    {
        shift = -shift;
        x1 = (x1 >> shift) & 31;
        x2 = (x2 >> shift) & 31;
    }

    // For wide runs, we have a left/optional solid/right components
    // that are entirely lookup table based. (Lookup tables
    // are generated in GenerateCoverageTables.)
    if (width > 0) //more than a longword
    {
        ULONG solidColor8 = 0x08080808;

        // Assert that we haven't gone too far in our buffer
        DASSERT(left*4 < ((m_cbScanWidth+3)&(~3)));

        pdwScanline [left++] += lefttable8[x1];
        while (left < right)	
        {
            // Assert that we haven't gone too far in our buffer
            DASSERT(left*4 < ((m_cbScanWidth+3)&(~3)));

            // This is the solid portion of the run
            pdwScanline[left++] += solidColor8;
        }
        
        // Since "right" is supposed to be exclusive;
        // we don't want to write to our buffer unless
        // necessary.
        DASSERT(righttable8[0] == 0);
        DASSERT(righttable8[1] > 0);
        if (x2 != 0)
        {
            // Assert that we haven't gone too far in our buffer
            DASSERT(right*4 < ((m_cbScanWidth+3)&(~3)));
            pdwScanline [right] += righttable8[x2];
        }
    }
    else
    {
        // For runs that don't cross a dword; it gets
        // computed via this 'split table'.

        // Assert that we haven't gone too far in our buffer
        DASSERT(left*4 < ((m_cbScanWidth+3)&(~3)));

        pdwScanline [left] += splittable8[(x1<<5) + x2];
    }
} // BlastScanLine

#endif // for entire file

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\inc\common.h ===
// common.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_COMMON_H__DB8FA385_F7A6_11D0_883A_3C8B00C10000__INCLUDED_)
#define AFX_COMMON_H__DB8FA385_F7A6_11D0_883A_3C8B00C10000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <w95wraps.h>


#define ATLTRACE    1 ? (void)0 : AtlTrace
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <shlwapi.h>
#include <shlwapip.h>


#include <d3drm.h>

#pragma intrinsic(memset, memcpy)

// Include the private version of DXTrans.h with extra interfaces and structures
#include <dxtransp.h>

// INCMSG defined for f3debug.h
#define INCMSG(X)

#include "f3debug.h"

#include <dxtmpl.h>
#include <ddrawex.h>
#include <dxtdbg.h>
#include <dxbounds.h>
#include <dxatlpb.h>
#include <mshtml.h>
#include <htmlfilter.h>
#include <ocmm.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMMON_H__DB8FA385_F7A6_11D0_883A_3C8B00C10000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mscanner2d.cpp ===
//************************************************************
//
// FileName:	    mscanner2d.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Scan-based AA polygon renderer
//
// Change History:
// ??/??/97 sree kotay  Wrote AA poly scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#include "precomp.h"
#include "msupport.h"
#include "MScanner2d.h"
#include "MLineScan.h"

// =================================================================================================================
// Constructor
// =================================================================================================================
CFillScanner::CFillScanner () :
    m_proc(NULL),
    m_scanlineProcData(NULL),
    m_vertspace(0),
    m_heightspace(0),
    m_cursortcount(0),
    m_fWinding(true),
    m_subpixelscale(4)
{
    SetAlpha			(255);
} // CFillScanner

// =================================================================================================================
// Destructor
// =================================================================================================================
CFillScanner::~CFillScanner ()
{
    m_vertspace			= 0;
} // ~CFillScanner


//
//  Optimize for speed here
//
#ifndef _DEBUG
#pragma optimize("ax", on)
#endif


// =================================================================================================================
// SetVertexSpace
// =================================================================================================================
bool CFillScanner::SetVertexSpace (LONG maxverts, LONG height)
{
    m_vertspace	= 0;
    maxverts	= max (maxverts, 3);
    
    if (!m_sortedge.SetElemCount(height))	
        return false;
    if (!m_sortcount.SetElemCount(height))	
        return false;
    if (!m_nextedge.SetElemCount(maxverts))	
        return false;
    
    if (!m_xarray.SetElemCount(maxverts))	
        return false;
    if (!m_xiarray.SetElemCount(maxverts))	
        return false;

    if (!m_ysarray.SetElemCount(maxverts))	
        return false;
    if (!m_yearray.SetElemCount(maxverts))	
        return false;
    if (!m_veflags.SetElemCount(maxverts))	
        return false;

    // Allocate enough space for our sections array
    if (!m_sectsarray.SetElemCount(maxverts))
        return false;

    m_cursortcount	= 0;

    // Initialize array pointers; these 'shortcuts'
    // allow direct dereferencing from the array.
    //
    // TODO: Would be nice to have some debug wrapper for this
    // to check array bounds
    m_nexte		= m_nextedge.Pointer(0);
    m_sorte		= m_sortedge.Pointer(0);
    m_sortc		= m_sortcount.Pointer(0);
    
    m_x			= m_xarray.Pointer(0);
    m_xi                = m_xiarray.Pointer(0);

    m_ys		= m_ysarray.Pointer(0);
    m_ye	        = m_yearray.Pointer(0);
    m_ef		= m_veflags.Pointer(0);
    
    m_vertspace	        = maxverts;
    m_heightspace	= height;
    
    
    return true;
} // SetVertexSpace

// =================================================================================================================
// SetAlpha
// =================================================================================================================
void CFillScanner::SetAlpha (ULONG a)
{
    // Clamp to a reasonable range
    DASSERT(a >= 0);
    if (a > 255)
        m_alpha = 255;
    else
        m_alpha = (BYTE)a;
   
    m_alphatable[0] = 0;
    for (LONG i=1; i < 256; i++)		
    {
        m_alphatable[i]	= (BYTE)((m_alpha*(i+1))>>8);
    }
    m_alphatable[256] = m_alpha;
} // SetAlpha

// =================================================================================================================
// BeginPoly
// =================================================================================================================
bool CFillScanner::BeginPoly (LONG maxverts)
{
    // compute shift
    m_subpixelshift		= Log2(m_subpixelscale);
    
    if (m_subpixelshift)
    {
        if (!m_coverage.AllocSubPixelBuffer (m_cpixTargetWidth, m_subpixelscale))
        {
            m_subpixelscale	= 1;
            m_subpixelshift	= 0;
        }
        else
        {
            // Cache these values to reduce the cost
            // of DrawScanLine
            m_clipLeftSubPixel = m_rectClip.left<<m_subpixelshift;
            m_clipRightSubPixel = m_rectClip.right<<m_subpixelshift;
        }
    }
    
    // Check to see if we need to reallocate our buffers
    LONG newheight	= m_cpixTargetHeight<< m_subpixelshift;
    if ((m_vertspace < maxverts) || (m_heightspace < newheight))
    {
        if (!SetVertexSpace (maxverts, newheight))	
            return false;
    }
    
    // Set some flags indicating whether all the vertices seen
    // so far are to the left/right/top/bottom. If all of them
    // are off to one side, then we can safely
    // ignore the poly.
    m_leftflag = true;
    m_rightflag = true;
    m_topflag = true;
    m_bottomflag= true;
    
    m_ystart		= _maxint32;
    m_yLastStart        = _minint32;
    m_yend		= _minint32;
    m_edgecount	        = 0;
    
    m_xstart		= _maxint32;
    m_xend		= _minint32;
    
    // Count of polygons that we have processed 
    // (if it exceeds some big number; we reset it)
    if (m_cursortcount > (1<<30))	
        m_cursortcount = 0;
    
    // By keeping track of which is the current polygon that
    // we are processing; we can eliminate the cost of
    // clearing the m_sorte array every polygon. Instead,
    // we just set m_sortc to indicate the current polygon count;
    // and that tells us if the corresponding entry in m_sorte is valid.
    if (!m_cursortcount)
    {
        // reset y sort buckets
        // (This happens the very first time; and it happens
        // if we hit a big number of polygons.)
        for (LONG i = 0; i < newheight; i++)
            m_sortc[i]	= -1;	
    }
    
    m_cursortcount++;
    
    return true;
} // BeginPoly

// =================================================================================================================
// AddEdge
//      This function adds edges to our edge array. It excludes lines that lie entirely
// above or below our top and bottom clip planes. It also excludes horinzontal edges.
//
//      For optimization purposes, it keeps track whether all of the edges seen are all to
// to one side of the clipRect. It also creates and maintains a linked list of each edge
// that starts at a particular y location. (The linked lists are maintained in m_sorte, m_nexte.)
// =================================================================================================================
bool CFillScanner::AddEdge (float x1, float y1, float x2, float y2)
{
    // Exclude nearly horizontal lines quickly
    if (IsRealEqual(y1, y2))
        return false;

    if (m_leftflag)	
        m_leftflag	= x1 < m_rectClip.left;
    if (m_rightflag)	
        m_rightflag	= x1 > m_rectClip.right;
    if (m_topflag)	
        m_topflag	= y1 < m_rectClip.top;
    if (m_bottomflag)	
        m_bottomflag	= y1 > m_rectClip.bottom;
    
    if (m_subpixelshift)
    {
        x1		*=  m_subpixelscale;
        y1		*=  m_subpixelscale;
        x2		*=  m_subpixelscale;
        y2		*=  m_subpixelscale;
    }

    // This hack prevents the numbers from getting too large
    PB_OutOfBounds(&x1);
    PB_OutOfBounds(&x2);

    // Round our Y values first
    LONG yi1 = PB_Real2IntSafe (y1 + .5f);	
    LONG yi2 = PB_Real2IntSafe (y2 + .5f);

    // Do a quick check for horizontal lines
    if (yi1 == yi2)
        return false;
    
    // compute dx, dy
    float ix = (x2 - x1);
    float dx;
    float iy = (y2 - y1);
    if (iy != 0)	
    {
        dx = ix/iy; 
    }		
    else 
    {   
        dx = 0;	
    }
    
    // edgesetup
    LONG miny = m_rectClip.top << m_subpixelshift;
    LONG maxy = m_rectClip.bottom << m_subpixelshift;

    // We flip edges so the Start is always the lesser of the y values
    LONG start, end;
    bool fFlipped;
    float xp, yp;
    if (y1 < y2)	
    {
        start = max (yi1, miny);	
        end = min (yi2, maxy);	
        xp = x1;  
        yp = y1;		
        fFlipped = false;
    }
    else
    {
        start = max (yi2, miny);	
        end = min (yi1, maxy);	
        xp = x2;  
        yp = y2;		
        fFlipped = true;
    }
    
    // Ignore lines that are clipped out
    // by the miny, maxy parameters.
    if (start >= end)
        return false;

    // Determine the data that we need to store in our edge array
    LONG count	= m_edgecount;
    float prestep = (float)start + .5f - yp;
    m_xi[count]	= PB_Real2Fix (dx);
    m_x[count] = PB_Real2FixSafe (xp + dx*prestep);
    
    m_ys[count] = start;	

    // Keep track of the top-most edge start
    if (start < m_ystart)		
    {
        m_ystart = start;	
    }

    // Keep track of the bottom-most edge start
    if (start > m_yLastStart)
    {
        m_yLastStart = start;
    }

    // Keep track of the bottom-most end
    m_ye[count] = end;		
    if (end > m_yend)			
    { 
        m_yend = end;		
    }

    // Remember if we have flipped this edge
    m_ef[count] = fFlipped ? -1 : 1;
    
    // <kd> What we now want to do is create a linked list of
    // edges that share the same startY. The head of the list of
    // the list for a particular startY is in m_sorte[startY].

    // m_sortc is a special (hacky) flag that checks if we have
    // initialized an entry for m_sorte. If it is initialized, then
    // we set the 'next' pointer for the current edge to point to the previous 
    // head pointer i..e m_sorte[start]. Else, we set it to -1, meaning null.
    if (m_sortc[start] == m_cursortcount)
    {
        // Sanity check data (-1 means null which is ok)
        DASSERT(m_sorte[start] >= -1);
        DASSERT(m_sorte[start] < count);

        // Set our next pointer to the previous head
        m_nexte[count] = m_sorte[start];
    }
    else
    {
        // Set our next to null
        m_nexte[count] = -1;
    }

    // Update the head pointer for this Y
    m_sorte[start] = count;

    // Mark the entry has having been initialized during this
    // polygon
    m_sortc[start] = m_cursortcount;
    
    m_edgecount++;
    
    return true;
} // AddEdge

// =================================================================================================================
// EndPoly
// =================================================================================================================
bool CFillScanner::EndPoly (void)
{
    // If all the points are all to the left/right/etc
    if (m_leftflag || m_rightflag || m_topflag || m_bottomflag)
        return false;

    // If our transparency is zero; then nothing to draw
    if (m_alpha == 0)
        return false;
    
    //scan edges
    if (m_edgecount > 1)	
        ScanEdges();
    m_edgecount	= 0;
    
    return true;
} // EndPoly

// =================================================================================================================
// SortSects
// =================================================================================================================
inline void SortSects(ULONG *sects, LONG *data, ULONG iEnd)
{
    DASSERT(iEnd < 0x10000000);
    if (iEnd < 2)
    {
        if (data[sects[0]] > data[sects[1]])
        {
            ULONG temp	= sects[0];
            sects[0]	= sects[1];
            sects[1]	= temp;
        }
        return;
    }
    
#ifdef USE_SELECTION_SORT
    for (LONG i = 0; i < iEnd; i++)
    {
        for (LONG j = i + 1; j <= iEnd; j++)
        {
            if (data[sects[i]] > data[sects[j]])
            {
                ULONG temp	= sects[i];
                sects[i]	= sects[j];
                sects[j]	= temp;
            }
        }    
    }
#else // !USE_SELECTION_SORT
    // From the nature of this usage; the array is almost
    // always sorted. And it is almost always small. So
    // we use a bubble-sort with an early out.
    //
    // CONSIDER: if there are lots of sects, then maybe we should qsort..
    //
    for (ULONG i = 0; i < iEnd; i++)
    {
        bool fSwapped = false;
        for (ULONG j = 0; j < iEnd; j++)
        {
            if (data[sects[j]] > data[sects[j+1]])
            {
                ULONG temp	= sects[j];
                sects[j]	= sects[j+1];
                sects[j+1]	= temp;
                fSwapped = true;
            }
        }    
        if (fSwapped == false)
        {
            // We ran through the entire list
            // and found that all elements were
            // already sorted.
            return;
        }
    }

#endif // !USE_SELECTION_SORT

} // SortSects

// =================================================================================================================
// DrawScanLine
// =================================================================================================================
void CFillScanner::DrawScanLine(LONG e1, LONG e2, LONG scanline)
{
    if (m_subpixelshift)
    {
        // =================================================================================================================
        // Sub pixel scanning
        // =================================================================================================================
        DASSERT((scanline >= 0) && ((ULONG)scanline < m_cpixTargetHeight<<m_subpixelshift));

        // Check that our cached values are what we thought are
        DASSERT(m_clipLeftSubPixel == m_rectClip.left<<m_subpixelshift);
        DASSERT(m_clipRightSubPixel == m_rectClip.right<<m_subpixelshift);

        // Convert our fixed point X coordinates into integers 
        LONG x1 = roundfix2int(m_x[e1]);
        LONG x2 = roundfix2int(m_x[e2]);

        // Clamp our range to left/right subpixels
        // Remember that x1 is inclusive; and x2 is exclusive
        if (x1 < m_clipLeftSubPixel)
            x1 = m_clipLeftSubPixel;
        if (x2 > m_clipRightSubPixel)
            x2 = m_clipRightSubPixel;

        // Did it get clipped away?
        if (x1 < x2)
        {
            // Check that casting to ULONG is safe now
            DASSERT(x1 >= 0);
            DASSERT(x2 >= 0);

            // Update the coverage buffers to account for this segment
            m_coverage.BlastScanLine((ULONG)x1, (ULONG)x2);
        }
    }
    else
    {
        // =================================================================================================================
        // Normal (aliased) drawing
        // =================================================================================================================
        DASSERT((scanline >= 0) && ((ULONG)scanline < m_cpixTargetHeight));

        // Convert our fixed point X coordinates into integers 
        LONG x1 = roundfix2int(m_x[e1]);
        LONG x2 = roundfix2int(m_x[e2]);

        // Clamp our range to left/right subpixels
        if (x1 < m_rectClip.left)
            x1 = m_rectClip.left;
        if (x2 > m_rectClip.right)
            x2 = m_rectClip.right;

        DASSERT(m_proc);
        m_proc(scanline, 
                x1, 
                x2, 
                m_coverage.Buffer(), 
                0 /* subpixelshift */, 
                1 /* cScan */, 
                m_scanlineProcData);
    }
    
    m_x[e1] += m_xi[e1];
    m_x[e2] += m_xi[e2];
    
} // DrawScanLine

// =================================================================================================================
// ScanEdges
// =================================================================================================================
void CFillScanner::ScanEdges(void)
{
    // Check that we don't go over our array of intersection edges
    DASSERT(m_sectsarray.GetElemSpace() >= (ULONG)m_edgecount);

    // Get a local pointer to the array 
    ULONG *sects = m_sectsarray.Pointer(0);

    // To optimize some checking in the core loop; we pre-compute
    // a quick way to check when we are done with a coverage buffer
    // We want a number X such that (cur+1 & X) == 0 indicates that
    // we gone far enough to render what we have sitting in the
    // coverage buffer.
    DWORD dwCoverageCompletionMask;
    if (m_subpixelshift)
    {
        DASSERT(m_subpixelscale > 1);
        DASSERT(m_subpixelshift == Log2(m_subpixelscale));

        // Whenever cur+1 reaches a multiple of m_subpixelscale
        // (which is guaranteed to be 2, 4, 8, 16). Then we
        // need to flush our coverage buffer.
        //
        // For example, when subpixelscale is 4, then 
        // if the cur+1 is 0 mod 4; then we need to flush.
        // The quick way to check that is ((cur+1) & 3) == 0
        dwCoverageCompletionMask = m_subpixelscale - 1;
    }
    else
    {
        // If no subpixel; then there is no coverage buffer;
        // since cur is always >=0; cur+1 is always > 0,
        // so 0xFFFFFFFF & cur+1 equals cur+1 and cur+1 is always non-zero
        dwCoverageCompletionMask = 0xFFFFFFFF;
    }
    
    // This is the index of the first edge in our active list
    LONG activeE = -1;

    // Keep track of the vertical distance until the next edge start/stops
    // (this lets us recognize stretches where the set of edges that
    // start/stop haven't changed).
    LONG nextystart = m_yend;

    // Keep track of the last active edge in our
    // active edge 'list'
    LONG iLastActiveEdge = -1;    

    // the current scan-line
    LONG cur = m_ystart;

    // For all scanlines
    do
    {
        // =================================================================================================================
        // find all edges that intersect this scanline
        //
        // The brute-force strategy is the following:
        //
        // for (LONG i = 0; i < m_edgecount; i++)
        // {
        //      if ((cur >= ys[i]) && (cur < ye[i]))	
        //          sects[cursects++] = i;
        // }            
        //
        // I.e. just iterate over all edges and see if any intersect
        // with this scanline. If so add them to our sects array.
        //

        // The actual algorithm takes advantage of information
        // that we built up during the AddEdge phase. For each scan-line
        // we have a "linked-list" of edges that start there. 
        //
        // So whenever we hit a new scan line, we just append those new
        // edges with our current Active list. Then we just run through the
        // Active list to determine which edges in Active list are still active.
        // 
        //
        // As a minor optimization, we keep track of the minimum scan-line where
        // something changes i.e. (edge should be added to our list or removed).

        ULONG cursects = 0;
        LONG nexty = m_yend;

        // Add edges to our active edge list if there are new ones to add
        // (This check sees if this scan-line was the start line for any edge 
        // during this this polygon; it's an optimization to prevent resetting this
        // array every polygon..)
        //
        if (m_sortc[cur] == m_cursortcount)
        {
            // There are edges that start at this scan-line
            DASSE