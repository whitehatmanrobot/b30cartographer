ce1(ERR, "Cannot set multiple Proxy interfaces. Proxy exists on %d",
                    g_ProxyIfIndex);
            IgmpAssertOnError(FALSE);
            Logerr0(PROXY_IF_EXISTS, Error);
                    
            GOTO_END_BLOCK1;
        }

        
        //
        // Process change in IgmpProtocolType (between proxy and router)
        // (no special processing for changes between ver-1 and ver-2)
        //
        if (pConfigSrc->IgmpProtocolType != pConfigDst->IgmpProtocolType)
        {
            bIgmpProtocolChanged = TRUE;
            GOTO_END_BLOCK1;
        }
        else 
            bIgmpProtocolChanged = FALSE;


        OldProtoType = pConfigDst->IgmpProtocolType;


        //
        // if interface enabled state has changed, then process that change
        // I dont have to look for version changes, etc
        //
        if (IGMP_ENABLED_FLAG_SET(pConfigSrc->Flags)
            != IGMP_ENABLED_FLAG_SET(pConfigDst->Flags)) 
        {

            bEnabledStateChanged = TRUE;

            pite->Info.OtherVerPresentTimeWarn = 0;
            
            bOldStateEnabled = IGMP_ENABLED_FLAG_SET(pConfigDst->Flags);
            GOTO_END_BLOCK1;
        }

        else 
            bEnabledStateChanged = FALSE;
            
        

            
        // copy the new config
        
        if (IS_IF_ACTIVATED(pite))
            CopyinIfConfigAndUpdate(pite, pConfigSrc, IfIndex);
        else
            CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);

        NewProtoType = pConfigDst->IgmpProtocolType;

        /*
        // 
        // if changing from V1 <-> V2
        //
        if ( ((OldProtoType==IGMP_ROUTER_V1) && (NewProtoType==IGMP_ROUTER_V2))
            || ((OldProtoType==IGMP_ROUTER_V2) && (NewProtoType==IGMP_ROUTER_V1)) )
        {
            pite->Info.OtherVerPresentTimeWarn = 0;
        }
        */
                    
    } END_BREAKOUT_BLOCK1;

    

    //
    // change the protocol and check for state changes. 
    // This function will effectively delete the interface with the old
    // protocol and create a new interface with the new protocol.
    //
    if ( (bIgmpProtocolChanged)&&(Error==NO_ERROR) )
        ProcessIfProtocolChange(IfIndex, pConfigSrc);


    //
    // Process State Change: enable or disable interface  
    //
    else if ( (bEnabledStateChanged)&&(Error==NO_ERROR) ) {

        //
        // disable the interface and then copy in the new config
        //
        if (bOldStateEnabled) {

            // old state enabled, new state disabled

            DisableInterface_ConfigChanged(IfIndex);

            //
            // copy the config 
            //
            // get the pite entry again, as disable creates a new one
            //
            
            pite = GetIfByIndex(IfIndex);
            CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);

            
        }
        //
        // copy the new config before enabling it
        //
        else {

            CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);
            
            //
            // set the enable state to false, so that the below call can
            // enable the interface.
            //
            pite->Config.Flags &= ~IGMP_INTERFACE_ENABLED_IN_CONFIG;


            // old state disabled, new state enabled

            EnableInterface_ConfigChanged(IfIndex);
        }
    }


    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_SetInterfaceConfigInfo");    
    RELEASE_IF_LIST_LOCK("_SetInterfaceConfigInfo");
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_SetInterfaceConfigInfo");


    
    Trace2(LEAVE, "leaving SetInterfaceConfigInfo(%d):%d\n", IfIndex, Error);

    LeaveIgmpApi();

    return Error;
    
} //end _SetInterfaceConfigInfo



//------------------------------------------------------------------------------
//          _ProcessProtocolChange
//
// Called when the interface protocol has changed (proxy<->router).
// First disables the old interface so that all old protocol data is cleaned up.
// then sets the new config, and enables the interface again (if it was
// enabled before). This process takes care of creation/deletion of sockets, etc
//
// Locks: no locks when called. Except for _Disable(_Enable)Interface, all work
//          is done inside an exclusive IfLock.
// Calls: _DisableInterface(), _EnableInterface() if required.
//------------------------------------------------------------------------------
DWORD
ProcessIfProtocolChange(
    DWORD               IfIndex,
    PIGMP_MIB_IF_CONFIG pConfigSrc
    )
{
    DWORD                   Error=NO_ERROR, dwDisabled;
    PIGMP_IF_CONFIG         pConfigDst;
    PIF_TABLE_ENTRY         pite = NULL;


    Trace1(ENTER, "Entered _ProcessIfProtocolChange(%d)", IfIndex);

    
    //
    // disable the interface so that all protocol specific data is lost
    //
    dwDisabled = DisableIfEntry(IfIndex, TRUE);


    //
    // find the interface specified and copy the config info. The config
    // has already been validated.
    //
    
    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_ProcessIfProtocolChange");


    BEGIN_BREAKOUT_BLOCK1 {

        // get interface again
        
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }    

        pConfigDst = &pite->Config;



        //
        // if old interface was Proxy, then remove it from the Global Struct
        // and delete the Proxy_HT related structures
        //
        if (IS_PROTOCOL_TYPE_PROXY(pite)) {

            // _DisableIfEntry would have deleted all the entries in the proxy
            // Hash table
            
            IGMP_FREE(pite->pProxyHashTable);

            InterlockedExchange(&g_ProxyIfIndex, 0);
            InterlockedExchangePointer(&g_pProxyIfEntry, NULL);
        }


        
        //
        // copy the new config values
        //
        CopyinIfConfig(&pite->Config, pConfigSrc, IfIndex);



        //
        // if new interface is Proxy, then add it to the Global Struct
        // and create the Proxy_HT structures
        //

        if (IS_PROTOCOL_TYPE_PROXY(pite)) {
        
            DWORD       dwSize = PROXY_HASH_TABLE_SZ * sizeof(LIST_ENTRY);
            DWORD       i;
            PLIST_ENTRY pProxyHashTable;
            
            pProxyHashTable = pite->pProxyHashTable = IGMP_ALLOC(dwSize, 0x80,IfIndex);

            PROCESS_ALLOC_FAILURE2(pProxyHashTable,
                    "error %d allocating %d bytes for interface table",
                    Error, dwSize,
                    GOTO_END_BLOCK1);


            for (i=0;  i<PROXY_HASH_TABLE_SZ;  i++) {
                InitializeListHead(pProxyHashTable+i);
            }


            InterlockedExchangePointer(&g_pProxyIfEntry, pite);
            InterlockedExchange(&g_ProxyIfIndex, IfIndex);

            pite->CreationFlags |= CREATED_PROXY_HASH_TABLE;

        }

    } END_BREAKOUT_BLOCK1;
    

    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_ProcessIfProtocolChange");


    //
    // enable the interface if the new state requires
    // it to be enabled.
    //
    if ( (Error==NO_ERROR) && (dwDisabled==NO_ERROR) )
        Error = EnableIfEntry(IfIndex, TRUE);


    Trace2(LEAVE, "Leaving _ProcessIfProtocolChange(%d): %d\n", 
            IfIndex, Error);
    return Error;
    
} //end _ProcessIfProtocolChange



//------------------------------------------------------------------------------
//          _GetInterfaceConfigInfo
//
// The Router Manager calls us with a NULL config and ZERO size. We return
// the required size to it.  It then allocates the needed memory and calls
// us a second time with a valid buffer.  We validate parameters each time
// and copy out our config if we can
//
// Return Value
//    ERROR_INSUFFICIENT_BUFFER If the size of the buffer is too small
//    ERROR_INVALID_PARAMETER    ERROR_INVALID_DATA      NO_ERROR
//------------------------------------------------------------------------------

DWORD
WINAPI
GetInterfaceConfigInfo(
    IN     DWORD  IfIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize,
    IN OUT PULONG pulStructureVersion,
    IN OUT PULONG pulStructureSize,
    IN OUT PULONG pulStructureCount
    )
{

    DWORD                   Error = NO_ERROR;
    PIF_TABLE_ENTRY         pite = NULL;
    PIGMP_MIB_IF_CONFIG     pConfigDst;
    PIGMP_IF_CONFIG         pConfigSrc;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace3(ENTER1, 
        "entering _GetInterfaceConfigInfo(%d): ConfigPrt(%08x) SizePrt(%08x)",
        IfIndex, pvConfig, pdwSize
        );


    ACQUIRE_IF_LOCK_SHARED(IfIndex, "_GetInterfaceConfigInfo");

    BEGIN_BREAKOUT_BLOCK1 {

        //
        // check the arguments
        //
        if (pdwSize == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        //
        // find the interface specified
        //
        pite = GetIfByIndex(IfIndex);

        if (pite == NULL) {
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }


        pConfigSrc = &pite->Config;


        // get the size of the interface config
        

        //
        // check the buffer size
        //

        if (*pdwSize < pConfigSrc->ExtSize) {
            Error = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
        

            pConfigDst = (PIGMP_MIB_IF_CONFIG)pvConfig;


            //
            // copy the interface config, and set the IP address
            //
            CopyoutIfConfig(pConfigDst, pite);

        }

        *pdwSize = pConfigSrc->ExtSize;

    } END_BREAKOUT_BLOCK1;


    RELEASE_IF_LOCK_SHARED(IfIndex, "_GetInterfaceConfigInfo");

    if (pulStructureCount)
        *pulStructureCount = 1;
    if (pulStructureSize)
        *pulStructureSize = *pdwSize;
    if (pulStructureVersion)
        *pulStructureVersion = IGMP_CONFIG_VERSION_500;

    Trace2(LEAVE1, "leaving _GetInterfaceConfigInfo(%d): %d\n", IfIndex, Error);
    LeaveIgmpApi();

    return Error;
}


DWORD
WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  bIfActive,
    DWORD dwStatusType,
    PVOID pvStatusInfo
    )
{
    DWORD Error = NO_ERROR;
    
    switch(dwStatusType)
    {
        case RIS_INTERFACE_ADDRESS_CHANGE:
        {
            PIP_ADAPTER_BINDING_INFO pBindInfo
                                    = (PIP_ADAPTER_BINDING_INFO)pvStatusInfo;
            
            if(pBindInfo->AddressCount)
            {
                Error = BindInterface(IfIndex, pvStatusInfo);
            }
            else 
            {
                Error = UnBindInterface(IfIndex);
            }

            break;
        }

        case RIS_INTERFACE_ENABLED:
        {
            Error = EnableInterface(IfIndex);
            break;
        }

        case RIS_INTERFACE_DISABLED:
        {
            Error = DisableInterface(IfIndex);
            break;
        }

    }

    return Error;
}

DWORD
WINAPI
IgmpMibIfConfigSize(
    PIGMP_MIB_IF_CONFIG pConfig
    )
{
    DWORD Size = sizeof(IGMP_MIB_IF_CONFIG);

    if (pConfig->NumStaticGroups && !IS_CONFIG_IGMP_V3(pConfig)) {
        Size += pConfig->NumStaticGroups*sizeof(IGMP_STATIC_GROUP);
    }
    else if (pConfig->NumStaticGroups && IS_CONFIG_IGMP_V3(pConfig)) {

        DWORD i;
        PSTATIC_GROUP_V3 pStaticGroupV3 = GET_FIRST_STATIC_GROUP_V3(pConfig);
                                
        for (i=0;  i<pConfig->NumStaticGroups;  i++) {
            DWORD EntrySize = sizeof(STATIC_GROUP_V3)
                                + pStaticGroupV3->NumSources*sizeof(IPADDR);
            Size += EntrySize;            
            pStaticGroupV3 = (PSTATIC_GROUP_V3)
                             ((PCHAR)(pStaticGroupV3) + EntrySize);
        }
    }

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\igmptimer.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: igmptimer.h
//
// Abstract:
//      This module contains declarations related to igmptimer.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//
//=============================================================================

#ifndef _IGMP_TIMER_H_
#define _IGMP_TIMER_H_

VOID
DebugCheckTimerContexts(
    );

//
// set the debug timer flags, so that I can control the amount of tracing 
// printed out.
//
#if DBG
    #ifndef DEBUG_TIMER_LEVEL
    #define DEBUG_TIMER_LEVEL 0x0
    #endif
#else
    #ifdef DEBUG_TIMER_LEVEL
    #undef DEBUG_TIMER_LEVEL
    #endif
    #define DEBUG_TIMER_LEVEL 0x0
#endif
#define DBG_Y TRUE
#define DBG_N FALSE

#define DEBUG_TIMER_ACTIVITY        (DEBUG_TIMER_LEVEL & 0x00000001)
#define DEBUG_TIMER_TIMERID         (DEBUG_TIMER_LEVEL & 0x00000010)
#define DEBUG_FLAGS_SIGNATURE       (DEBUG_TIMER_LEVEL & 0x00000010)
#define DEBUG_TIMER_PROCESSQUEUE1   (DEBUG_TIMER_LEVEL & 0x00000020)
#define DEBUG_TIMER_PROCESSQUEUE2   (DEBUG_TIMER_LEVEL & 0x00000040)
#define DEBUG_TIMER_RESYNCTIMER     (DEBUG_TIMER_LEVEL & 0x00000080)

#define DEBUG_TIMER_REMOVETIMER1    (DEBUG_TIMER_LEVEL & 0x00000100)
#define DEBUG_TIMER_REMOVETIMER2    (DEBUG_TIMER_LEVEL & 0x00000200)
#define DEBUG_TIMER_INSERTTIMER1    (DEBUG_TIMER_LEVEL & 0x00001000)
#define DEBUG_TIMER_INSERTTIMER2    (DEBUG_TIMER_LEVEL & 0x00002000)
#define DEBUG_TIMER_UPDATETIMER1    (DEBUG_TIMER_LEVEL & 0x00010000)
#define DEBUG_TIMER_PACKET          (DEBUG_TIMER_LEVEL & 0x00020000)

//------------------------------------------------------------------------------
// GLOBAL DEFINITIONS
//

// number of buckets in Timer Table
// 0-14,14-28,28-42,... last bucket has >63*14=882 secs (all approx)
//
#define NUM_TIMER_BUCKETS         64

#if DEBUG_TIMER_TIMERID
    extern DWORD TimerId;
#endif






typedef struct _IGMP_TIMER_ENTRY {

    LIST_ENTRY          Link;

    LONGLONG            Timeout;
    LPTHREAD_START_ROUTINE   Function;
    PVOID               Context;
    UCHAR               Status;
            
    #if DEBUG_TIMER_TIMERID
    DWORD               Id; 
    DWORD               Id2;
    DWORD               IfIndex;
    DWORD               Group;
    DWORD               Source;
    DWORD               Signature; //0xfadfad01
    #endif
        
} IGMP_TIMER_ENTRY, *PIGMP_TIMER_ENTRY;


#if DEBUG_FLAGS_SIGNATURE && DEBUG_TIMER_TIMERID
#define CHECK_TIMER_SIGNATURE(pte) {\
    if ((pte)->Signature != 0xfadfad01)\
        DbgBreakPoint();\
    }
#else
#define CHECK_TIMER_SIGNATURE(pte)
#endif

typedef struct _IGMP_TIMER_GLOBAL {

    HANDLE              WTTimer;         // timer set with wait server
    HANDLE              WTTimer1;
    
    LONGLONG            WTTimeout;       // timeout value set with wait server
    LONGLONG            SyncTime;        // time when time queue last reordered
    LARGE_INTEGER       CurrentTime;
    DWORD               NumTimers;
    
    DWORD               TableLowIndex;
    LIST_ENTRY          TimesTable[NUM_TIMER_BUCKETS];    // array of times
    
    UCHAR               Status;
    
    CRITICAL_SECTION    CS;
    BOOL                CSFlag;
    
} IGMP_TIMER_GLOBAL, *PIGMP_TIMER_GLOBAL;

#define GET_IGMP_CURRENT_TIME( ) igmp.WTTimer.CurrentTime.QuadPart


// TIMER_STATUS
#define TIMER_STATUS_CREATED           0x01
#define TIMER_STATUS_INACTIVE          0x02
#define TIMER_STATUS_ACTIVE            0x04
#define TIMER_STATUS_FIRED             0x08
#define TIMER_STATUS_DELETED           0x80


//
// MACROS
//

#define IS_TIMER_ACTIVE(pTimer)         ((pTimer).Status & TIMER_STATUS_ACTIVE)


#define SET_TIMER_INFINITE(time) \
    time = 0
    

#define IS_TIMER_INFINITE(time) \
    (time == 0)

#if DEBUG_FLAGS_SIGNATURE //deldel
#define ACQUIRE_TIMER_LOCK(proc)  { \
        ENTER_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        ++g_TimerStruct.CSFlag; \
        }

#define RELEASE_TIMER_LOCK(proc)  {\
        --g_TimerStruct.CSFlag; \
        LEAVE_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        }
#define CHECK_IF_ACQUIRED_TIMER_LOCK() {\
        if (g_TimerStruct.CSFlag<=0) DbgBreakPoint();\
        }
        
#else
#define ACQUIRE_TIMER_LOCK(proc)  { \
        ENTER_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        }

#define RELEASE_TIMER_LOCK(proc)  {\
        LEAVE_CRITICAL_SECTION(&g_TimerStruct.CS, "g_TimerStruct.CS1", proc); \
        }
#define CHECK_IF_ACQUIRED_TIMER_LOCK()
#endif


#define SET_TIMER_ID(_pTimer, _Id1, _IfIndex, _Group, _Source) {\
    (_pTimer)->Id = _Id1; \
    (_pTimer)->Id2 = TimerId++;\
    (_pTimer)->IfIndex = _IfIndex;\
    (_pTimer)->Group = _Group; \
    (_pTimer)->Source = _Source; \
    (_pTimer)->Signature = 0xfadfad01; \
    }
//
// currently all times mentioned in the config structure are in seconds
//
#define CONV_CONFIG_TO_INTERNAL_TIME(time) \
        (time *= 1000)
#define CONFIG_TO_INTERNAL_TIME(time) \
        ((time) * 1000)
#define CONV_INTERNAL_TO_CONFIG_TIME(time) \
        (time /= 1000);
#define CONFIG_TO_SYSTEM_TIME(time) \
        (time)
#define SYSTEM_TIME_TO_SEC(time) \
        ((DWORD)((time) / (LONGLONG)1000L))
#define SYSTEM_TIME_TO_MSEC(time) \
        ((DWORD)(time))


        
//
//FUNCTION PROTOTYPES
//

LONGLONG
GetCurrentIgmpTime(
    );    

VOID    
UpdateLocalTimer (
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llNewTime,
    BOOL                bDbgPrint
    );

VOID
RemoveTimer (
    PIGMP_TIMER_ENTRY   pte,
    BOOL bDbg
    );

DWORD
InsertTimer (
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llNewTime,
    BOOL                bResync,
    BOOL                bDbg
    );

ULONG
QueryRemainingTime(
    PIGMP_TIMER_ENTRY pte,
    LONGLONG        llCurTime
    );


DWORD
InitializeTimerGlobal (
    );

VOID
DeInitializeTimerGlobal (
    );


VOID
DebugPrintTimerEntry (
    PIGMP_TIMER_ENTRY   pte,
    DWORD               dwBucket,
    LONGLONG            llCurTime
    );
VOID
GetTimerDebugInfo(
    CHAR                str1[20],
    CHAR                str2[20],
    DWORD              *pdwDiffTime,
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llCurtime
    );

DWORD
DebugScanTimerQueue(
    DWORD Id
    );

VOID
DebugPrintTimerQueue (
    );    

#endif //ifndef _IGMP_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\igmptrace.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: igmptrace.h
//
// Abstract:
//      This module contains declarations related to tracing.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
//=============================================================================

#ifndef _IGMPTRACE_H_
#define _IGMPTRACE_H_

#ifdef MIB_DEBUG
    #if !DBG 
    #undef MIB_DEBUG
    #endif
#endif

//kslksl remove below
#define DBG1 0
//deldel

// constants and macros used for tracing 
//

#define IGMP_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)

#define IGMP_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)

#define IGMP_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IGMP_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IGMP_TRACE_START           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IGMP_TRACE_STOP            ((DWORD)0x00020000 | TRACE_USE_MASK)

#define IGMP_TRACE_IF              ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IGMP_TRACE_CONFIG          ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IGMP_TRACE_RECEIVE         ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IGMP_TRACE_SEND            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IGMP_TRACE_QUERIER         ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IGMP_TRACE_GROUP           ((DWORD)0x00200000 | TRACE_USE_MASK) 
#define IGMP_TRACE_MGM             ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IGMP_TRACE_SOURCES         ((DWORD)0x00800000 | TRACE_USE_MASK)
//kslksl deldel
#define IGMP_TRACE_TIMER           ((DWORD)0x10000000 | TRACE_USE_MASK)
#if DBG
#define IGMP_TRACE_TIMER1          ((DWORD)0x40000000 | TRACE_USE_MASK)
#define IGMP_TRACE_ENTER1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MEM             ((DWORD)0x80000000 | TRACE_USE_MASK)
#else
#define IGMP_TRACE_TIMER1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_ENTER1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MEM             ((DWORD)0x00000000 | TRACE_USE_MASK)
#endif

#if DBG1

#define IGMP_TRACE_KSL             ((DWORD)0x01000000 | TRACE_USE_MASK)

#define IGMP_TRACE_WORKER          ((DWORD)0x01000000 | TRACE_USE_MASK)
//#define IGMP_TRACE_ENTER1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_LEAVE1          ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MIB             ((DWORD)0x04000000 | TRACE_USE_MASK) 

#define IGMP_TRACE_DYNLOCK         ((DWORD)0x08000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS              ((DWORD)0x20000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS1             ((DWORD)0x80000000 | TRACE_USE_MASK)

#else

#define IGMP_TRACE_KSL             ((DWORD)0x00000000 | TRACE_USE_MASK)

#define IGMP_TRACE_WORKER          ((DWORD)0x00000000 | TRACE_USE_MASK)
//#define IGMP_TRACE_ENTER1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_LEAVE1          ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_MIB             ((DWORD)0x00000000 | TRACE_USE_MASK) 

#define IGMP_TRACE_DYNLOCK         ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS              ((DWORD)0x00000000 | TRACE_USE_MASK)
#define IGMP_TRACE_CS1             ((DWORD)0x00000000 | TRACE_USE_MASK)

#endif




#ifdef LOCK_DBG

#define ENTER_CRITICAL_SECTION(pcs, type, proc)             \
            Trace2(CS,"----To enter %s in %s", type, proc);    \
            EnterCriticalSection(pcs);                         \
            Trace2(CS1,"----Entered %s in %s", type, proc)
            
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)         \
            Trace2(CS1,"----Left %s in %s", type, proc);    \
            LeaveCriticalSection(pcs)

#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        Trace2(EVENT, "++++To wait for singleObj %s in %s", type, proc);    \
        WaitForSingleObject(event, time);    \
        Trace2(EVENT, "++++WaitForSingleObj returned %s in %s", type, proc)

#define SET_EVENT(event, type, proc) \
        Trace2(EVENT, "++++SetEvent %s in %s", type, proc);    \
        SetEvent(event)
        
#else 
#define ENTER_CRITICAL_SECTION(pcs, type, proc) \
            EnterCriticalSection(pcs)
            
#define LEAVE_CRITICAL_SECTION(pcs, type, proc)    \
            LeaveCriticalSection(pcs)
            
#define WAIT_FOR_SINGLE_OBJECT( event, time, type, proc) \
        WaitForSingleObject(event, time)
        
#define SET_EVENT(event, type, proc) \
        SetEvent(event)
            
#endif // LOCK_DBG


#define TRACEID         g_TraceId


#define Trace0(l,a)             \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g)
#define Trace7(l,a,b,c,d,e,f,g,h)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g,h)
#define Trace8(l,a,b,c,d,e,f,g,h,i)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g,h,i)
#define Trace9(l,a,b,c,d,e,f,g,h,i,j)   \
            if (g_TraceId!=INVALID_TRACEID) TracePrintfEx(TRACEID, IGMP_TRACE_ ## l, a, b, c, d, e, f,g,h,i,j)


#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)
            



#ifdef ENTER_DBG

#define TraceEnter(X)  TracePrintfEx(TRACEID, IGMP_TRACE_ENTER, "Entered: "X)
#define TraceLeave(X)  TracePrintfEx(TRACEID, IGMP_TRACE_ENTER, "Leaving: "X"\n")
#else   

#define TraceEnter(X)
#define TraceLeave(X)

#endif // ENTER_DBG

//
// Event logging macros
//

#define LOGLEVEL        g_Config.LoggingLevel
#define LOGHANDLE       g_LogHandle

// Error logging

#define Logerr0(msg,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg, "")
#define Logerr1(msg,Format,a,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a))
#define Logerr2(msg,Format,a,b,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b)); \
        }
#define Logerr3(msg,Format,a,b,c,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b),(c)); \
        }
#define Logerr4(msg,Format,a,b,c,d,err) \
        if (LOGLEVEL >= IGMP_LOGGING_ERROR) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_ERROR_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b),(c),(d)); \
        }


// Warning logging
#define Logwarn0(msg,err) \
        if (LOGLEVEL >= IGMP_LOGGING_WARN) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_WARNING_TYPE,\
                (err),IGMPLOG_ ## msg, "")
#define Logwarn1(msg,Format,a,err) \
        if (LOGLEVEL >= IGMP_LOGGING_WARN) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_WARNING_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a))
#define Logwarn2(msg,Format,a,b,err) \
        if (LOGLEVEL >= IGMP_LOGGING_WARN) { \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_WARNING_TYPE,\
                (err),IGMPLOG_ ## msg,Format,(a),(b)); \
        }

// Information logging
#define Loginfo0(msg,err) \
        if (LOGLEVEL >= IGMP_LOGGING_INFO) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_INFORMATION_TYPE,\
                (err),IGMPLOG_ ## msg, "")

#define Loginfo1(msg,Format,a,err) \
        if (LOGLEVEL >= IGMP_LOGGING_INFO) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_INFORMATION_TYPE,\
                (err),IGMPLOG_ ## msg, Format,(a))

#define Loginfo2(msg,Format,a,b,err) \
        if (LOGLEVEL >= IGMP_LOGGING_INFO) \
            RouterLogEventEx(LOGHANDLE,EVENTLOG_INFORMATION_TYPE,\
                (err),IGMPLOG_ ## msg, Format,(a),(b))



//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )
#define INET_COPY(p1, p2) {\
    LPSTR tmp;\
    tmp = INET_NTOA(p2); \
    if ((tmp)) lstrcpy((p1),tmp); \
    else *(p1) = '\0'; \
    }
    
#define INET_CAT(p1, p2) {\
    LPSTR tmp; \
    tmp = INET_NTOA(p2); \
    if ((tmp)) lstrcat((p1),tmp);\
    }
#endif // _IGMPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\if.h ===
#ifndef _IGMP_IF_H_
#define _IGMP_IF_H_

//=============================================================================
//
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: If.h
//
// Abstract:
//      This file contains declarations for if.c
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//
//=============================================================================

//
// API PROTOTYPES
//
DWORD
WINAPI
AddInterface(
    IN PWCHAR               pwszInterfaceName,//not used
    IN ULONG                IfIndex,
    IN NET_INTERFACE_TYPE   dwIfType,
    IN DWORD                dwMediaType,
    IN WORD                 wAccessType,
    IN WORD                 wConnectionType,
    IN PVOID                pvConfig,
    IN ULONG                ulStructureVersion,
    IN ULONG                ulStructureSize,
    IN ULONG                ulStructureCount
    );

DWORD
WINAPI
DeleteInterface(
    IN DWORD IfIndex
    );  

DWORD
WINAPI
ConnectRasClient (
    DWORD       IfIndex,
    PVOID       pvNHAddr 
    );
    
DWORD
WINAPI
DisconnectRasClient (
    DWORD       IfIndex,
    PVOID       pvNHAddr
    );

DWORD
WINAPI
SetInterfaceConfigInfo(
    IN DWORD IfIndex,
    IN PVOID pvConfig,
    IN ULONG ulStructureVersion,
    IN ULONG ulStructureSize,
    IN ULONG ulStructureCount
    );


DWORD
WINAPI
GetInterfaceConfigInfo(
    IN     DWORD  IfIndex,
    IN OUT PVOID  pvConfig,
    IN OUT PDWORD pdwSize,
    IN OUT PULONG pulStructureVersion,
    IN OUT PULONG pulStructureSize,
    IN OUT PULONG pulStructureCount
    );
    
DWORD
WINAPI
InterfaceStatus(
    ULONG IfIndex,
    BOOL  bIfActive,
    DWORD dwStatusType,
    PVOID pvStatusInfo
    );

DWORD
WINAPI
IgmpMibIfConfigSize(
    PIGMP_MIB_IF_CONFIG pConfig
    );

//
// EXPORTED PROTOTYPES
//

VOID
CompleteIfDeletion (
    PIF_TABLE_ENTRY     pite
    );

DWORD
ActivateInterface (
    PIF_TABLE_ENTRY     pite
    );
    
VOID
DeActivateInterfaceComplete (
    PIF_TABLE_ENTRY     pite
    );

DWORD
CreateRasClient (
    PIF_TABLE_ENTRY     pite,      
    PRAS_TABLE_ENTRY   *prteNew,
    DWORD               NHAddr
    );

//
// INTERNAL PROTOTYPES
//

DWORD
BindInterface(
    IN DWORD IfIndex,
    IN PVOID pBinding
    );

DWORD
UnBindInterface(
    IN DWORD IfIndex
    );

DWORD
EnableInterface(
    IN DWORD IfIndex
    );

DWORD
DisableInterface(
    IN DWORD IfIndex
    );
    
DWORD
AddIfEntry(
    DWORD IfIndex,
    NET_INTERFACE_TYPE dwIfType,
    PIGMP_MIB_IF_CONFIG pConfig,
    ULONG ulStructureVersion,
    ULONG ulStructureSize    
    );
    
DWORD
DeleteIfEntry (
    PIF_TABLE_ENTRY pite
    );
    
DWORD
BindIfEntry(
    DWORD IfIndex,
    PIP_ADAPTER_BINDING_INFO pBinding
    );

DWORD
UnBindIfEntry(
    DWORD IfIndex
    );

DWORD
EnableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr // changed by rtrmgr or by SetInterfaceConfigInfo
    );

DWORD
DisableIfEntry(
    DWORD IfIndex,
    BOOL  bChangedByRtrmgr // changed by rtrmgr or by SetInterfaceConfigInfo
    );

DWORD
ProcessIfProtocolChange(
    DWORD               IfIndex,
    PIGMP_MIB_IF_CONFIG pConfigSrc
    );

DWORD
DeActivationDeregisterFromMgm(
    PIF_TABLE_ENTRY pite
    );

#endif // _IGMP_IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\log.h ===
#define IGMPLOG_BASE                           41000

#define IGMPLOG_INIT_CRITSEC_FAILED            (IGMPLOG_BASE + 1)
/*
 * IGMP was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IGMPLOG_HEAP_CREATE_FAILED             (IGMPLOG_BASE + 2)
/*
 * IGMP was unable to create a heap.
 * The data is the error code.
 */

#define IGMPLOG_HEAP_ALLOC_FAILED              (IGMPLOG_BASE + 3)
/*
 * IGMP was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IGMPLOG_IGMP_ALREADY_STARTED           (IGMPLOG_BASE + 4)
/*
 * IGMP received a start request when it was already running.
 */

#define IGMPLOG_WSASTARTUP_FAILED              (IGMPLOG_BASE + 5)
/*
 * IGMP was unable to start Windows Sockets.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_RWL_FAILED              (IGMPLOG_BASE + 6)
/*
 * IGMP was unable to create a synchronization object.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_EVENT_FAILED            (IGMPLOG_BASE + 7)
/*
 * IGMP was unable to create an event.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_SEMAPHORE_FAILED        (IGMPLOG_BASE + 8)
/*
 * IGMP was unable to create a semaphore.
 * The data is the error code.
 */

#define IGMPLOG_CREATE_SOCKET_FAILED           (IGMPLOG_BASE + 9)
/*
 * IGMP was unable to create a socket.
 * The data is the error code.
 */

#define IGMPLOG_IGMP_STARTED                   (IGMPLOG_BASE + 10)
/*
 * IGMP has started successfully.
 */

#define IGMPLOG_QUEUE_WORKER_FAILED            (IGMPLOG_BASE + 11)
/*
 * IGMP could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IGMPLOG_RECVFROM_FAILED                (IGMPLOG_BASE + 12)
/*
 * IGMP was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_PACKET_TOO_SMALL               (IGMPLOG_BASE + 13)
/*
 * IGMP received a packet which was smaller than the minimum size
 * allowed for IGMP packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IGMPLOG_PACKET_VERSION_INVALID         (IGMPLOG_BASE + 14)
/*
 * IGMP received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 

#define IGMPLOG_PACKET_HEADER_CORRUPT          (IGMPLOG_BASE + 15)
/*
 * IGMP received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IGMPLOG_QUERY_FROM_RAS_CLIENT          (IGMPLOG_BASE + 16)
/*
 * Router received a general query from RAS Client(%1) on interface
 * with IP address %2.
 * RAS clients are not supposed to send queries.
 */

#define IGMPLOG_VERSION_QUERY                 (IGMPLOG_BASE + 17)
/*
 * Different version router with IP Address %1
 * exists on the interface with IP address %2.
 */
 
#define IGMPLOG_SENDTO_FAILED                  (IGMPLOG_BASE + 19)
/*
 * IGMP was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define IGMPLOG_PACKET_VERSION_MISMATCH        (IGMPLOG_BASE + 20)
/*
 * IGMP discarded a version %1 packet received on the interface
 * with IP address %2 from a neighbor with IP address %3.
 * The above interface is configured to accept only version %4 packets.
 */

#define IGMPLOG_ENUM_NETWORK_EVENTS_FAILED     (IGMPLOG_BASE + 21)
/*
 * Igmpv2 was unable to enumerate network events on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_INPUT_RECORD_ERROR             (IGMPLOG_BASE + 22)
/*
 * Igmpv2 detected an error on the local interface with IP address %1.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define IGMPLOG_EVENTSELECT_FAILED             (IGMPLOG_BASE + 23)
/*
 * Igmpv2 was unable to request notification of events
 * on the socket for the local interface with IP address %1.
 * The data is the error code.
 */
 
#define IGMPLOG_CREATE_SOCKET_FAILED_2         (IGMPLOG_BASE + 24)
/*
 * IGMP was unable to create a socket for the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_BIND_FAILED                    (IGMPLOG_BASE + 25)
/*
 * IGMP could not bind to port 520 on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_CONNECT_FAILED                 (IGMPLOG_BASE + 26)
/*
 * IGMP could not connect Ras Client %1 to the interface with
 * index %2.
 * The data is the error code.
 */
 
#define IGMPLOG_DISCONNECT_FAILED              (IGMPLOG_BASE + 27)
/*
 * IGMP could not disconnect Ras Client %1 from the interface with
 * index %2.
 * The data is the error code.
 */
 
#define IGMPLOG_SET_MCAST_IF_FAILED            (IGMPLOG_BASE + 28)
/*
 * IGMP could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IGMPLOG_SET_ROUTER_ALERT_FAILED        (IGMPLOG_BASE + 29)
/*
 * IGMP could not set router alert option on the local interface
 * with IP address %1.
 * The data is the error code.
 */
 
#define IGMPLOG_SET_HDRINCL_FAILED             (IGMPLOG_BASE + 30)
/*
 * IGMP could not set the IP header include option on interface
 * with IP address %1.
 * The data is the error code.
 */
 
#define IGMPLOG_JOIN_GROUP_FAILED              (IGMPLOG_BASE + 31)
/*
 * IGMP could not join the multicast group %1
 * on the local interface with IP address %2.
 * The data is the error code.
 */
 
#define IGMPLOG_LEAVE_GROUP_FAILED             (IGMPLOG_BASE + 32)
/*
 * IGMP could not leave the multicast group %1
 * on the local interface with IP address %2.
 * The data is the error code.
 */

#define IGMPLOG_PROTO_ALREADY_STOPPING         (IGMPLOG_BASE + 33)
/*
 * StopProtocol() called to stop Igmp when it is 
 * already being stopped.
 * The data is the error code.
 */

#define IGMPLOG_PROXY_IF_EXISTS                (IGMPLOG_BASE + 34)
/*
 * AddInterface() called to add an Igmp Proxy interface.
 * Igmp proxy already owns another interface.
 * The data is the error code.
 */

#define IGMPLOG_RAS_IF_EXISTS                  (IGMPLOG_BASE + 35)
/*
 * AddInterface() called to add an Igmp Ras interface.
 * Ras Server cannot exist on multiple interfaces.
 * The data is the error code.
 */

#define IGMPLOG_MGM_REGISTER_FAILED             (IGMPLOG_BASE + 36)
/*
 * IGMP Router failed to register with MGM.
 * The data is the error code.
 */

#define IGMPLOG_MGM_PROXY_REGISTER_FAILED       (IGMPLOG_BASE + 37)
/*
 * IGMP Proxy failed to register with MGM.
 * The data is the error code.
 */


 #define IGMPLOG_MGM_TAKE_IF_OWNERSHIP_FAILED   (IGMPLOG_BASE + 38)
/*
 * MgmTakeInterfaceOwnership() failed.
 * The data is the error code.
 */

 #define IGMPLOG_ROBUSTNESS_VARIABLE_EQUAL_1    (IGMPLOG_BASE + 39)
/*
 * The robustness variable is being set to 1 for Igmp router 
 * on Interface %1.
 * You should avoid setting it to 1.
 */

 #define IGMPLOG_INVALID_VALUE                 (IGMPLOG_BASE + 40)
/*
 * One of the values passed to Igmp is invalid.
 * %1
 */

#define IGMPLOG_REGISTER_WAIT_SERVER_FAILED    (IGMPLOG_BASE + 41)
/*
 * The wait-events-timers could not be registered with the 
 * wait server thread. Alertable threads might not have 
 * been initialized in Rtutils.
 * The data is the error code.
 */

#define IGMPLOG_IGMP_STOPPED                   (IGMPLOG_BASE + 42)
/*
 * IGMP has stopped.
 */
 
 #define IGMPLOG_CAN_NOT_COMPLETE              (IGMPLOG_BASE + 43)
 /*
  * Fatal error. Could not complete.
  * The data is the error code.
  */

 #define IGMPLOG_INVALID_VERSION               (IGMPLOG_BASE + 44)
 /*
  * The version field in the IGMP config field is incorrect.
  * Delete and create the IGMP config again.
  */

 #define IGMPLOG_INVALID_PROTOTYPE              (IGMPLOG_INVALID_VERSION+1)
/*
 * IGMP Protocol type for interface %1 has invalid value %2.
 * The data is the error code.
 */

 #define IGMPLOG_PROXY_ON_RAS_SERVER        (IGMPLOG_INVALID_PROTOTYPE+1)
/*
 * Cannot configure Proxy on RAS server interface %1.
 */

 #define IGMPLOG_INVALID_STATIC_GROUP        (IGMPLOG_PROXY_ON_RAS_SERVER+1)
/*
 * Static group %1 configured on Interface%2 not a valid MCast address.
 */

 #define IGMPLOG_INVALID_STATIC_MODE        (IGMPLOG_INVALID_STATIC_GROUP+1)
/*
 * Static group %1 configured on Interface:%2 does not have valid mode.
 */

 #define IGMPLOG_INVALID_STATIC_FILTER        (IGMPLOG_INVALID_STATIC_MODE+1)
/*
 * Static group %1 configured on Interface:%2 has invalid filter.
 */

 #define IGMPLOG_INVALID_ROBUSTNESS        (IGMPLOG_INVALID_STATIC_FILTER+1)
/*
 * Invalid robustness variable:%1 configured on Interface:%2. Max 7.
 */

 #define IGMPLOG_INVALID_STARTUPQUERYCOUNT        (IGMPLOG_INVALID_ROBUSTNESS+1)
/*
 * Invalid Startup Query Count:%1 configured on Interface:%2.
 */

 #define IGMPLOG_INTERFACE_RTR_ACTIVATED        (IGMPLOG_INVALID_STARTUPQUERYCOUNT+1)
/*
 * IGMP-Rtr-V%1 activated on Interface:%2.
 */

 #define IGMPLOG_INTERFACE_PROXY_ACTIVATED        (IGMPLOG_INTERFACE_RTR_ACTIVATED+1)
/*
 * IGMP Proxy activated on Interface:%1.
 */

 #define IGMPLOG_ACTIVATION_FAILURE_PROXY        (IGMPLOG_INTERFACE_PROXY_ACTIVATED+1)
/*
 * Failed to install IGMP Proxy on interface:%1.
 */

 #define IGMPLOG_ACTIVATION_FAILURE_RTR        (IGMPLOG_ACTIVATION_FAILURE_PROXY+1)
/*
 * Failed to install IGMP Rtr-V-%1 on interface:%2.
 */

 #define IGMPLOG_RTR_DEACTIVATED        (IGMPLOG_ACTIVATION_FAILURE_RTR+1)
/*
 * Failed to install IGMP Rtr-V-%1 on interface:%2.
 */

 #define IGMPLOG_PROXY_DEACTIVATED        (IGMPLOG_RTR_DEACTIVATED+1)
/*
 * Failed to install IGMP Rtr-V-%1 on interface:%2.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\makefile.inc ===
$(O)\igmpmsg.mc: log.h
    mapmsg NET IGMPLOG_BASE log.h > $(O)\igmpmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\macros.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File Name: macros.h
//
// Abstract:
//      This file contains many macros and #defines.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//
//=============================================================================

#ifndef _MACROS_H_
#define _MACROS_H

//------------------------------------------------------------------------------
// DEBUG FLAGS
//------------------------------------------------------------------------------

//kslksl
#define SET_MOST_DEBUG  0

// check for memory leaks
#define DEBUG_FLAGS_MEM_ALLOC (1 | SET_MOST_DEBUG)
#define DEUBG_FLAGS_MEM_LEAK (DBG | DEBUG_FLAGS_MEM_ALLOC)

// assert on error
#define DEBUG_FLAGS_ASSERT_ON_ERRORS (0 | SET_MOST_DEBUG)


//------------------------------------------------------------------------------
// TMP DEBUGGING //DebugCheck
//------------------------------------------------------------------------------
extern DWORD DEBUG_CHECK_LOW_INDEX_ARRAY[100][2];
extern DWORD DebugIgmpIndex;

#define DEBUG_CHECK_LOW_INDEX(i) {\
    DebugIgmpIndex = (++DebugIgmpIndex) % 100; \
    DEBUG_CHECK_LOW_INDEX_ARRAY[DebugIgmpIndex][0] = i;\
    DEBUG_CHECK_LOW_INDEX_ARRAY[DebugIgmpIndex][1] = g_TimerStruct.TableLowIndex;\
    if (g_TimerStruct.TableLowIndex>64 && g_TimerStruct.TableLowIndex!=~0) DbgBreakPoint();\
    }
//    Trace2(ENTER, "%%%%%%LowIndex:(%d) %0x:%d", i, g_TimerStruct.TableLowIndex); \



//------------------------------------------------------------------------------
// some global definitions
//------------------------------------------------------------------------------

#ifndef IPADDR
typedef DWORD   IPADDR;
#endif

#define PROTO_IP_IGMP_PROXY  11

#define INTERSECTION        3
#define RULE5               5


//------------------------------------------------------------------------------
// interface table macros
//------------------------------------------------------------------------------


#define IF_HASH_VALUE(_index) ((_index) % g_pIfTable->NumBuckets)



#define ACQUIRE_IF_LOCK_EXCLUSIVE(_IfIndex, _proc) \
        AcquireDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)],\
                                LOCK_MODE_WRITE, \
                                &g_DynamicRWLStore)
#define RELEASE_IF_LOCK_EXCLUSIVE(_IfIndex, _proc) \
        ReleaseDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)], \
                                LOCK_MODE_WRITE, \
                                &g_DynamicRWLStore)
        
#define ACQUIRE_IF_LOCK_SHARED(_IfIndex, _proc) \
        AcquireDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)], \
                                LOCK_MODE_READ, \
                                &g_DynamicRWLStore)
#define RELEASE_IF_LOCK_SHARED(_IfIndex, _proc) \
        ReleaseDynamicRWLock(&g_pIfTable->aIfBucketDRWL[IF_HASH_VALUE(_IfIndex)], \
                                LOCK_MODE_READ, \
                                &g_DynamicRWLStore)



#define ACQUIRE_IF_LIST_LOCK(_proc) \
        ENTER_CRITICAL_SECTION(&g_pIfTable->IfLists_CS, "g_IfListsCS", _proc);

#define RELEASE_IF_LIST_LOCK(_proc) \
        LEAVE_CRITICAL_SECTION(&g_pIfTable->IfLists_CS, "g_IfListsCS", _proc);


        
#define ACQUIRE_IF_GROUP_LIST_LOCK(_IfIndex, _proc) \
        AcquireDynamicCSLock(&g_pIfTable->aIfBucketDCS[IF_HASH_VALUE(_IfIndex)],\
                                &g_DynamicCSStore)
#define RELEASE_IF_GROUP_LIST_LOCK(_IfIndex, _proc) \
        ReleaseDynamicCSLock(&g_pIfTable->aIfBucketDCS[IF_HASH_VALUE(_IfIndex)],\
                                &g_DynamicCSStore) 


                
//------------------------------------------------------------------------------
// Proxy table macros
//------------------------------------------------------------------------------

#define PROXY_HASH_VALUE(_group) \
        (( ((_group)&0xFF000000)+((_group)&0xFF)) % (PROXY_HASH_TABLE_SZ))



//------------------------------------------------------------------------------
// protocol type macros/interface type macros
//------------------------------------------------------------------------------

#define IS_PROTOCOL_TYPE_PROXY(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_PROXY \
                ||(_pite)->Config.IgmpProtocolType==IGMP_PROXY_V3)

#define IS_PROTOCOL_TYPE_PROXY_V2(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_PROXY)
                
#define IS_PROTOCOL_TYPE_PROXY_V3(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_PROXY_V3)
                
#define IS_PROTOCOL_TYPE_IGMPV1(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_ROUTER_V1)

#define IS_PROTOCOL_TYPE_IGMPV2(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_ROUTER_V2)

#define IS_PROTOCOL_TYPE_IGMPV3(_pite) \
                ((_pite)->Config.IgmpProtocolType==IGMP_ROUTER_V3)

#define IS_PROTOCOL_TYPE_ROUTER(_pite) \
                (!IS_PROTOCOL_TYPE_PROXY(_pite))


#define IGMP_MIB_IF_CONFIG_SIZE_V3(pConfig) \
    IgmpMibIfConfigSize(pConfig)

// internally, FfType does not have protocol type, but when I expose it outside,
// I have to add proxy type if it is a proxy interface.

#define GET_EXTERNAL_IF_TYPE(_pite)  \
    IS_PROTOCOL_TYPE_PROXY(_pite) ? ((_pite->IfType)|IGMP_IF_PROXY) \
                                : (_pite)->IfType


#define ACQUIRE_PROXY_ALERT_LOCK(proc) \
    ENTER_CRITICAL_SECTION(&g_ProxyAlertCS, "g_ProxyAlertCS", proc)
#define RELEASE_PROXY_ALERT_LOCK(proc) \
    LEAVE_CRITICAL_SECTION(&g_ProxyAlertCS, "g_ProxyAlertCS", proc)


//-------------------------------------------------------------------
// ENUM MACROS
//-------------------------------------------------------------------
#define ACQUIRE_ENUM_LOCK_EXCLUSIVE(_proc) \
    ACQUIRE_WRITE_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);

#define RELEASE_ENUM_LOCK_EXCLUSIVE(_proc) \
    RELEASE_WRITE_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);

#define ACQUIRE_ENUM_LOCK_SHARED(_proc) \
    ACQUIRE_READ_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);

#define RELEASE_ENUM_LOCK_SHARED(_proc) \
    RELEASE_READ_LOCK(&g_EnumRWLock, "g_EnumRWLock", _proc);
    
//------------------------------------------------------------------------------
// group table macros
//------------------------------------------------------------------------------

#define GROUP_HASH_VALUE(_group) \
        (((_group) & 0xFF)%GROUP_HASH_TABLE_SZ)

        
#define ACQUIRE_GROUP_LOCK(_group, _proc) {\
    ACQUIRE_ENUM_LOCK_SHARED(_proc);\
    AcquireDynamicCSLockedList( \
            &g_pGroupTable->HashTableByGroup[GROUP_HASH_VALUE(_group)],\
            &g_DynamicCSStore);\
}

#define RELEASE_GROUP_LOCK(_group, _proc) {\
    ReleaseDynamicCSLockedList( \
            &g_pGroupTable->HashTableByGroup[GROUP_HASH_VALUE(_group)],\
            &g_DynamicCSStore);\
    RELEASE_ENUM_LOCK_SHARED(_proc);\
}

        
#define ACQUIRE_GROUP_LIST_LOCK(_proc) { \
            ACQUIRE_LIST_LOCK(&g_pGroupTable->ListByGroup, \
                                "g_pGroupTable->ListByGroup", _proc);\
        }

#define RELEASE_GROUP_LIST_LOCK(_proc) { \
            RELEASE_LIST_LOCK(&g_pGroupTable->ListByGroup, \
                                "g_pGroupTable->ListByGroup", _proc);\
        }

//
// merge the groups list if the number of entries in the new list is more than 50
// or if the size of new list is greater than 4 times the size of actual list
// but in any case not smaller than 10
//
#define MERGE_GROUP_LISTS_REQUIRED() \
    ( (g_pGroupTable->NumGroupsInNewList > 50) \
     || ( (g_pGroupTable->NumGroupsInNewList > \
          g_Info.CurrentGroupMemberships/4)  \
          && (g_pGroupTable->NumGroupsInNewList>10) ))


// insert all elements in l2 at the end of l1, and reinitialize l2
#define CONCATENATE_LISTS(l1, l2) { \
    l2.Flink->Blink = l1.Blink;      \
    l1.Blink->Flink = l2.Flink;      \
    l2.Blink->Flink = &l1;           \
    l1.Blink = l2.Blink;            \
    InitializeListHead(&l2);        \
    }


#define MERGE_IF_GROUPS_LISTS_REQUIRED(_pite)    \
    (_pite->NumGIEntriesInNewList > 20)

#define MERGE_PROXY_LISTS_REQUIRED(_pite)    \
    (_pite->NumGIEntriesInNewList > 20)



//------------------------------------------------------------------------------
// SOCKETS MACROS
//------------------------------------------------------------------------------
#define ACQUIRE_SOCKETS_LOCK_EXCLUSIVE(_proc) \
    ACQUIRE_WRITE_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);

#define RELEASE_SOCKETS_LOCK_EXCLUSIVE(_proc) \
    RELEASE_WRITE_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);

#define ACQUIRE_SOCKETS_LOCK_SHARED(_proc) \
    ACQUIRE_READ_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);

#define RELEASE_SOCKETS_LOCK_SHARED(_proc) \
    RELEASE_READ_LOCK(&g_SocketsRWLock, "g_SocketsRWLock", _proc);





//------------------------------------------------------------------------------
// RAS MACROS
//------------------------------------------------------------------------------

#define IS_NOT_RAS_IF(flag)    ((flag) == IGMP_IF_NOT_RAS)
#define IS_RAS_SERVER_IF(flag) ((flag) == IGMP_IF_RAS_SERVER)
#define IS_RAS_CLIENT_IF(flag) ((flag) == IGMP_IF_RAS_CLIENT)
#define IS_RAS_ROUTER_IF(flag) ((flag) == IGMP_IF_RAS_ROUTER)

#define RAS_HASH_VALUE(ClientAddr) \
    (((ClientAddr) & 0xFF)%(RAS_HASH_TABLE_SZ))



//------------------------------------------------------------------------------
// PACKET MACROS
//------------------------------------------------------------------------------

// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))


#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)


            

//------------------------------------------------------------------------------
// Interface #defines and Macros
//------------------------------------------------------------------------------

//
// status flags
//
#define IF_CREATED_FLAG     0x00000001
#define CREATED_FLAG        0x00000001
#define IF_BOUND_FLAG       0x00000002
#define IF_ENABLED_FLAG     0x00000004
#define IF_DELETED_FLAG     0x80000000
#define DELETED_FLAG        0x80000000

#define MGM_ENABLED_IGMPRTR_FLAG        0x00001000
#define IGMPRTR_MPROTOCOL_PRESENT_FLAG  0x00002000

// interface timers etc have not been set. socket not activated. so enumeration
// might not be correct. Further, if deleting the entry, timers/sockets can
// be ignored
#define IF_ACTIVATED_FLAG    0x00000008
#define IF_DEACTIVATE_DELETE_FLAG   0x00000010


//
// macros for status flags
//

#define IS_IGMPRTR_ENABLED_BY_MGM(pite)    \
                            (pite->Status & MGM_ENABLED_IGMPRTR_FLAG)
#define MGM_ENABLE_IGMPRTR(pite)           \
                            (pite->Status |= MGM_ENABLED_IGMPRTR_FLAG)
#define MGM_DISABLE_IGMPRTR(pite) {\
                            (pite->Status &= ~MGM_ENABLED_IGMPRTR_FLAG);    \
                            (pite->Status &= ~IGMPRTR_MPROTOCOL_PRESENT_FLAG);\
                            }

#define IS_MPROTOCOL_PRESENT_ON_IGMPRTR(pite)    \
                            (pite->Status & IGMPRTR_MPROTOCOL_PRESENT_FLAG)
#define SET_MPROTOCOL_PRESENT_ON_IGMPRTR(pite)           \
                            (pite->Status |= IGMPRTR_MPROTOCOL_PRESENT_FLAG)
#define SET_MPROTOCOL_ABSENT_ON_IGMPRTR(pite) \
                            (pite->Status &= ~IGMPRTR_MPROTOCOL_PRESENT_FLAG)


#define IS_IF_BOUND(pite) \
        ((pite)->Status&IF_BOUND_FLAG)

#define IS_IF_ENABLED_BY_RTRMGR(pite) \
        ((pite)->Status&IF_ENABLED_FLAG)

#define IS_IF_ENABLED_IN_CONFIG(pite) \
        (IGMP_ENABLED_FLAG_SET((pite)->Config.Flags))
        
#define IS_IF_ENABLED(pite) \
        ( IS_IF_ENABLED_BY_RTRMGR(pite) && IS_IF_ENABLED_IN_CONFIG(pite) )


#define IS_IF_ENABLED_BOUND(pite) \
        (IS_IF_ENABLED(pite)&&IS_IF_BOUND(pite))

#define IS_IF_DELETED(pite) \
        ((pite)->Status&IF_DELETED_FLAG)

#define IS_IF_NOT_DELETED(pite) \
        (!((pite)->Status&IF_DELETED_FLAG))


#define IS_IF_ACTIVATED(pite) \
        ( !((pite)->Status&IF_DELETED_FLAG) && ((pite)->Status&IF_ACTIVATED_FLAG) )



//-------------------------------
// QUERIER STATES 0x<Querier><0>
//-------------------------------

#define QUERIER               0x10


#define IS_IF_VER2(pite)        IS_PROTOCOL_TYPE_IGMPV2(pite)
#define IS_IF_VER1(pite)        IS_PROTOCOL_TYPE_IGMPV1(pite)
#define IS_IF_VER3(pite)        IS_PROTOCOL_TYPE_IGMPV3(pite)
#define GET_IF_VERSION(_pite)    (_pite)->Config.IgmpProtocolType
#define IS_QUERIER(pite)        ((pite)->Info.QuerierState & QUERIER)

//
// interlocked operations not required, as state is of type uchar
//
#define SET_QUERIER_STATE_QUERIER(state)         (state |= 0x10)
#define SET_QUERIER_STATE_NON_QUERIER(state)     (state &= 0x01)


#define IF_PROCESS_GRPQUERY(pite) \
    ( (IS_IF_VER2(pite)||IS_IF_VER3(pite)) && !IS_RAS_SERVER_IF(pite->IfType) )

#define IF_PROCESS_LEAVES(pite)  \
    ( IS_IF_VER2(pite) && (IS_QUERIER(pite)) && !IS_RAS_SERVER_IF(pite->IfType))

#define GI_PROCESS_GRPQUERY(pite, pgie) \
    ( IF_PROCESS_GRPQUERY(pite)&& ((pgie->Version==2)||(pgie->Version==3)) )


#define CAN_ADD_GROUPS_TO_MGM(pite)         \
        ( (IS_IGMPRTR_ENABLED_BY_MGM(pite)) \
        && (IS_MPROTOCOL_PRESENT_ON_IGMPRTR(pite) || (IS_QUERIER(pite))) \
        )


//
// INTERFACE STATE
//
#define GET_EXTERNAL_IF_STATE(pite, State) {\
    State = 0;\
    if (IS_IF_ENABLED_BY_RTRMGR(pite)) \
        State |= IGMP_STATE_ENABLED_BY_RTRMGR; \
    if (IS_IF_ENABLED_IN_CONFIG(pite))\
        State |= IGMP_STATE_ENABLED_IN_CONFIG; \
    if (IS_PROTOCOL_TYPE_ROUTER(pite)) {\
        if (IS_IGMPRTR_ENABLED_BY_MGM(pite)) \
            State |= IGMP_STATE_ENABLED_BY_MGM; \
        if (CAN_ADD_GROUPS_TO_MGM(pite)) \
            State |= IGMP_STATE_MGM_JOINS_ENABLED; \
    } \
    else \
        State |= IGMP_STATE_ENABLED_BY_MGM; \
    \
    if (IS_IF_BOUND(pite)) \
        State |= IGMP_STATE_BOUND;\
}

//
//filter macros
//

#define GMI     TRUE
#define LMI     FALSE
#define STATIC  0xff
#define MGM_YES TRUE
#define MGM_NO  FALSE


//------------------------------------------------------------------------------
// other locking macros
//------------------------------------------------------------------------------

#define ACQUIRE_GLOBAL_LOCK(proc) ENTER_CRITICAL_SECTION(&g_CS, "g_CS", proc)
#define RELEASE_GLOBAL_LOCK(proc) LEAVE_CRITICAL_SECTION(&g_CS, "g_CS", proc)



// 
// instead of using goto:end to go to the end of the block, use the following 
//
#define BEGIN_BREAKOUT_BLOCK1    do
#define GOTO_END_BLOCK1          goto END_BREAKOUT_BLOCK_1
#define END_BREAKOUT_BLOCK1      while(FALSE); END_BREAKOUT_BLOCK_1:
#define BEGIN_BREAKOUT_BLOCK2    do
#define GOTO_END_BLOCK2          goto END_BREAKOUT_BLOCK_2
#define END_BREAKOUT_BLOCK2      while(FALSE); END_BREAKOUT_BLOCK_2:


//------------------------------------------------------------------------------
// memory allocation/deallocation macros
//------------------------------------------------------------------------------

#if DEBUG_FLAGS_MEM_ALLOC

typedef struct _MEM_HDR {
    LIST_ENTRY Link;
    ULONG Signature;
    ULONG Id;
    ULONG IfIndex;
    PDWORD Tail;
} MEM_HDR, *PMEM_HDR;    

PVOID
IgmpDebugAlloc(
    DWORD sz,
    DWORD Flags,
    DWORD Id,
    DWORD IfIndex
    );

VOID
IgmpDebugFree(
    PVOID mem
    );
VOID
DebugScanMemory(
    );
VOID
DebugScanMemoryInterface(
    DWORD IfIndex
    );

#define IGMP_ALLOC(sz,Id,If)    IgmpDebugAlloc((sz),0,Id,If)

#define IGMP_ALLOC_AND_ZERO(sz,Id,If) IgmpDebugAlloc((sz),HEAP_ZERO_MEMORY,Id,If)
#define IGMP_FREE(p)            {\
    IgmpDebugFree(p);\
    }
#define IGMP_FREE_NOT_NULL(p)   if (p) IGMP_FREE(p)



#else
#define IGMP_ALLOC(sz,Id,If)          HeapAlloc(g_Heap,0,(sz))

#define IGMP_ALLOC_AND_ZERO(sz,Id,If) HeapAlloc(g_Heap,HEAP_ZERO_MEMORY,(sz))

//deldel
//#define IGMP_FREE(p)            HeapFree(g_Heap, 0, (p))
//#define IGMP_FREE_NOT_NULL(p)   ((p) ? IGMP_FREE(p) : TRUE)

#define IGMP_FREE(p)            {\
    HeapFree(g_Heap, 0, (p));\
    }
//    Trace1(ENTER1, "Freed heap:%0x", PtrToUlong(p));\

    
#define IGMP_FREE_NOT_NULL(p)   if (p)IGMP_FREE(p)

#define IgmpDebugAlloc(sz,Flags,Id,IfIndex)
#define IgmpDebugFree(mem)
#define DebugScanMemoryInterface(IfIndex)
#define DebugScanMemory()


#endif



#define PROCESS_ALLOC_FAILURE2(ptr, TraceMsg, Error,arg2, GotoStmt) \
    if (ptr==NULL) {\
        Error = ERROR_NOT_ENOUGH_MEMORY;\
        Trace2(ERR, TraceMsg, Error, arg2); \
        GotoStmt;\
    }


#define PROCESS_ALLOC_FAILURE3(ptr, TraceMsg, Error,arg2,arg3, GotoStmt) \
    if (ptr==NULL) {\
        Error = ERROR_NOT_ENOUGH_MEMORY;\
        Trace3(ERR, TraceMsg, Error, arg2, arg3); \
        GotoStmt;\
    }



//
// assert macros
//
#if DBG

#define IgmpAssert(exp){                                                \
    if(!(exp))                                                          \
    {                                                                   \
        TracePrintf(TRACEID,                                            \
                    "Assertion failed in %s : %d \n",__FILE__,__LINE__);\
        RouterAssert(#exp,__FILE__,__LINE__,NULL);                      \
    }                                                               \
}
#if DEBUG_FLAGS_ASSERT_ON_ERRORS
#define IgmpAssertOnError(exp) IgmpAssert(exp)
#else
#define IgmpAssertOnError(exp)
#endif

#else
#define IgmpAssert(exp)
#define IgmpAssertOnError(exp)
#endif


#define INSERT_IN_SORTED_LIST(_pInsertList, _pEntry, _Field, _STRUCT, _Link) {\
    \
    _STRUCT *pTmp;\
    PLIST_ENTRY pHead, ple;\
    \
    pHead = _pInsertList;\
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {\
    \
        pTmp = CONTAINING_RECORD(ple, _STRUCT, _Link);\
        if (pTmp->_Field > _pEntry->_Field)\
            break;\
    }\
    \
    InsertTailList(ple, &_pEntry->_Link);\
}

#define SEARCH_IN_SORTED_LIST(_pList,_Value,_Field,_STRUCT,_Link,_pEntry) {\
    PLIST_ENTRY ple;\
    _pEntry = NULL;\
    \
    for (ple=(_pList)->Flink;  ple!=_pList;  ple=ple->Flink) {\
        _pEntry = CONTAINING_RECORD(ple, _STRUCT, _Link);\
        if ((_Value >= _pEntry)->_Field) {\
            if ((_pEntry)->_Field != _Value) \
                _pEntry = NULL;\
            break;\
        }\
    }\
}


//
// NETWORK_TO_LITTLE_ENDIAN macro
//

#define NETWORK_TO_LITTLE_ENDIAN(Group) ( (((Group)&0x000000ff)<<24) \
                                         +(((Group)&0x0000ff00)<<8)  \
                                         +(((Group)&0x00ff0000)>>8)  \
                                         +(((Group)&0xff000000)>>24) )


#define MIN(a,b) ((a)<(b) ? (a) : (b))
#define MAX(a,b) ((a)>(b) ? (a) : (b))

#define IS_NOT_EQ_ANY2(a, A,B) ((a!=A)&&(a!=B))
#define IS_EQ_ANY(a,A,B) ((a==A)||(a==B))

//
// signature macros for Interface-Group lists enumeration
//
#define GET_NEXT_SIGNATURE()  (g_GlobalIfGroupEnumSignature++ | 0x10 )
//#define SET_SIGNATURE(a,b) ((a) = ((b)<<16) | (a&0x00FF))
#define SET_SIGNATURE(a,b) (a = (b))




//
// define enum values
//
#define ADD_FLAG       1
#define DELETE_FLAG    0


#define NON_QUERIER_FLAG        1
#define QUERIER_FLAG            2
#define QUERIER_CHANGE_V1_ONLY  4


#define STATIC_GROUP     1
#define NOT_STATIC_GROUP 0
#define ANY_GROUP_TYPE   2

#define NOT_RAS_CLIENT   0
#define RAS_CLIENT       1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\igmptimer.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: igmptimer.c
//
// Abstract: This module implements the igmptimer
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================



#include "pchigmp.h"


//DebugCheck //ksltodo
//DWORD MyDebug = 0x0;
DWORD MyDebug = 0x0; //DebugScanTimerQueue while running
DWORD DebugIgmpVersion = 13;
ULONG g_DebugPrint = 0; //flag to enable DebugPrintTimerQueue while running

DWORD DEBUG_CHECK_LOW_INDEX_ARRAY[100][2]; //deldel
DWORD DebugIgmpIndex; //deldel


#if DEBUG_TIMER_LEVEL & DEBUG_TIMER_TIMERID
    DWORD TimerId =0;
#endif
ULONG g_Fire = 0; // global variable



//------------------------------------------------------------------------------
//
// FUNCTION PROTOTYPES USED ONLY IN THIS FILE
//

VOID
SetNextTime(
    DWORD        dwLowIndex
    );

VOID
ResyncTimerBuckets(
    LONGLONG llCurTime
    );
VOID
InsertTimerInSortedList(
    PIGMP_TIMER_ENTRY    pteNew,
    PLIST_ENTRY          pHead
    );


//------------------------------------------------------------------------------
//
// #DEFINES USED ONLY IN THIS FILE
//

//
//approx 16 secs in each bucket: 
//it is approx not accurate as I divide by 2^10 instead of 1000
//TIMER_BUCKET_GRANULARITY should be 2^TIMER_BUCKET_GRANULARITY_SHIFT
//
#define TIMER_BUCKET_GRANULARITY        16
#define TIMER_BUCKET_GRANULARITY_SHIFT   4


#define SEC_CONV_SHIFT                  10
#define TIMER_BUCKET_GRANULARITY_ABS    \
        ((LONGLONG) (1 << (TIMER_BUCKET_GRANULARITY_SHIFT + SEC_CONV_SHIFT) ))


#define MAP_TO_BUCKET(dwBucket, ilTime) \
    dwBucket = (DWORD) (((ilTime)-g_TimerStruct.SyncTime) \
                        >> (TIMER_BUCKET_GRANULARITY_SHIFT+SEC_CONV_SHIFT)); \
    dwBucket = dwBucket>NUM_TIMER_BUCKETS-1? NUM_TIMER_BUCKETS-1:  dwBucket


// I fire a timer even if it is set to 10 millisec in the future.
#define FORWARD_TIMER_FIRED 10

//------------------------------------------------------------------------------


ULONG
QueryRemainingTime(
    PIGMP_TIMER_ENTRY pte,
    LONGLONG        llCurTime
    )
{
    if (llCurTime==0)
        llCurTime = GetCurrentIgmpTime();
    return llCurTime>pte->Timeout ? 0 : (ULONG)(pte->Timeout-llCurTime);
}

// DebugCheck

VOID
DebugCheckLowTimer(
    DWORD Flags
    )
{
    PIGMP_TIMER_GLOBAL    ptg = &g_TimerStruct;
    DWORD i;
    PIGMP_TIMER_ENTRY     pte, pteMin;
    LONGLONG              ilMinTime;
    PLIST_ENTRY           pHead, ple;

    Trace0(ENTER1, "In _DebugCheckLowTimer");
    
    if (ptg->NumTimers==0)
        return;
        
    for (i=0;  i<=ptg->TableLowIndex;  i++) {
    
        pHead = &ptg->TimesTable[i];
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
            CHECK_TIMER_SIGNATURE(pte);

            if (Flags & 1) {
                if (pte->Timeout<ptg->WTTimeout) {
                    DbgBreakPoint();
                }
            }
            if (i<ptg->TableLowIndex)
                DbgBreakPoint();
        }

    }
    return;
}



//------------------------------------------------------------------------------
//          _InsertTimer
//
// Inserts a timer into the local timer queue. Time should always be relative.
//
// Locks: Assumes lock taken on ptg->CS
//------------------------------------------------------------------------------

DWORD
InsertTimer (
    PIGMP_TIMER_ENTRY    pte,
    LONGLONG             llNewTime,
    BOOL                 bResync,
    BOOL                 bDbg
    )
{
    LONGLONG             llCurTime = GetCurrentIgmpTime();
    PIGMP_TIMER_GLOBAL   ptg;
    DWORD                dwBucket, Error = NO_ERROR;
    

    CHECK_TIMER_SIGNATURE(pte);
    CHECK_IF_ACQUIRED_TIMER_LOCK();
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(1);//deldel

    if (pte->Status & TIMER_STATUS_ACTIVE) {
        UpdateLocalTimer(pte, llNewTime, bDbg);
        return NO_ERROR;
    }

    // deldel
    if (MyDebug&0x1) DebugScanTimerQueue(1);
    


    
    Trace0(ENTER1, "_InsertTimer()");


    // print the queue before inserting the timer
    
    #if DEBUG_TIMER_INSERTTIMER1
        Trace0(TIMER1, "Printing Timer Queue before InsertTimer");
        DebugPrintTimerQueue();
    #endif


    ptg = &g_TimerStruct;
    


    // convert relative time to absolute time
    llNewTime += llCurTime;

    
    pte->Timeout = llNewTime;

    
    MAP_TO_BUCKET(dwBucket, pte->Timeout);


    // print info about the timer being inserted
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD   dwBucket, dwDiffTime;
        CHAR    str1[20], str2[20];

        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace7(TIMER, "Inserting timer  <%d><%d><%d> Timeout:%lu   <%s> "
                "<%s> Status:%d", dwBucket, pte->Id, pte->Id2, dwDiffTime, 
                str1, str2, pte->Status);
    }
    #endif

    
    //
    // insert timer in appropriate list
    //
    
    if (dwBucket==0) {    // bucket 0 contains a sorted list
    
        InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
    }
    else {
        InsertTailList(&ptg->TimesTable[dwBucket], &pte->Link);

    }

    DEBUG_CHECK_LOW_INDEX(2);//deldel


    ptg->NumTimers++;
    ptg->TableLowIndex = ptg->TableLowIndex<dwBucket
                            ? ptg->TableLowIndex : dwBucket;

    DEBUG_CHECK_LOW_INDEX(3);//deldel

    //resynchronize timer list
    
    if (bResync) {
        if ( (ptg->TableLowIndex!=0) 
                && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS < llCurTime) ) {
            
            ResyncTimerBuckets(llCurTime);
        }
    }

    DEBUG_CHECK_LOW_INDEX(4);//deldel

    //
    // if time being inserted is lower than the minimum, then update wait timer
    //
    if ((IS_TIMER_INFINITE(ptg->WTTimeout)) || (pte->Timeout<=ptg->WTTimeout)) {
        ptg->WTTimeout = pte->Timeout;

        if (!IS_TIMER_INFINITE(ptg->WTTimeout)) {

            BOOL bSuccess ;

            bSuccess = ChangeTimerQueueTimer(ptg->WTTimer, ptg->WTTimer1,
                        llCurTime<ptg->WTTimeout
                            ?(ULONG) ((ptg->WTTimeout - llCurTime))
                            : 0,
                        1000000                   // set a periodic timer
                        );
            
            if (!bSuccess) {
                Error = GetLastError();
                Trace1(ERR, "ChangeTimerQueueTimer returned error:%d", Error);
                IgmpAssertOnError(FALSE);
            }
            else {
                #if DEBUG_TIMER_ACTIVITY
                Trace1(TIMER1, "ChangeTimerQueueTimer set to %lu",
                            (ULONG) ((ptg->WTTimeout - llCurTime))/1000);
                #if DEBUG_TIMER_ID
                g_Fire = (ULONG) ((ptg->WTTimeout - llCurTime)/1000);
                #endif
                #endif
            }
        }
    }

    pte->Status = TIMER_STATUS_ACTIVE;


    #if DEBUG_TIMER_INSERTTIMER2
        if (bDbg||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after _InsertTimer");
            DebugPrintTimerQueue();
        }
    #endif


    //kslksl
    if (MyDebug&0x2) DebugScanTimerQueue(2);
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(5);//deldel
    
    Trace0(LEAVE1, "Leaving _InsertTimer()");
    return NO_ERROR;
    
} //end _InsertTimer



//------------------------------------------------------------------------------
//            _UpdateLocalTimer
//
// Change the time in a timer structure and (re)insert it in the timer queue.
// Locks: Assumes lock on the global timer
//------------------------------------------------------------------------------

VOID    
UpdateLocalTimer (
    PIGMP_TIMER_ENTRY    pte,
    LONGLONG             llNewTime,
    BOOL                bDbgPrint
    )
{

    Trace0(ENTER1, "_UpdateLocalTimer():");

    CHECK_TIMER_SIGNATURE(pte);
    CHECK_IF_ACQUIRED_TIMER_LOCK();
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(6);//deldel

    // print info about the timer being updated
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD       dwBucket, dwDiffTime;
        CHAR        str1[20], str2[20];
        LONGLONG    llCurTime = GetCurrentIgmpTime();

        
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace0(TIMER, "   \n");
        Trace8(TIMER, "Updating timer  <%d><%d><%d> Timeout:%lu   <%s> <%s> "
                    "to %d Status:%d\n", dwBucket, pte->Id, pte->Id2, dwDiffTime,
                    str1, str2, (DWORD)llNewTime, pte->Status);
    }
    #endif


    // first remove the timer
    
    if (pte->Status&TIMER_STATUS_ACTIVE) {
        RemoveTimer(pte, DBG_N);
    }
    DEBUG_CHECK_LOW_INDEX(7);//deldel


    // now insert the timer back into the timer queue. Resync flag is set
    
    InsertTimer(pte, llNewTime, TRUE, DBG_N);

    #if DEBUG_TIMER_UPDATETIMER1
        if (bDbgPrint||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after _UpdateTimer");
            DebugPrintTimerQueue();
        }
    #endif

    //kslksl
    if (MyDebug&0x4) DebugScanTimerQueue(4);
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(8);//deldel

    Trace0(LEAVE1, "_UpdateLocalTimer()");
    return;    
}




//------------------------------------------------------------------------------
//            _RemoveTimer
//
// Removes the timer from the list. Changes the status of the timer to CREATED.
// Assumes global timer lock.
//------------------------------------------------------------------------------

VOID
RemoveTimer (
    PIGMP_TIMER_ENTRY    pte,
    BOOL    bDbg
    )
{
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    

    Trace0(ENTER1, "_RemoveTimer()");

    CHECK_TIMER_SIGNATURE(pte);
    CHECK_IF_ACQUIRED_TIMER_LOCK();
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(9);//deldel

    // print info about the timer being removed
    
    #if DEBUG_TIMER_ACTIVITY
    {    
        DWORD   dwBucket, dwDiffTime;
        CHAR    str1[20], str2[20];

        
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
        GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

        Trace7(TIMER, "Removing timer  <%d><%d><%d> Timeout:%lu   <%s> <%s> "
                    "Status:%d", dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, 
                    str2, pte->Status);
    }
    #endif
    


    // remove the timer from the timer queue and decrement the number of timers
    
    RemoveEntryList(&pte->Link);
    ptg->NumTimers--;
    


    // reset the minimum timeout for the timer queue, if this timer was the min
    
    if (pte->Timeout==ptg->WTTimeout) {
        
        SetNextTime(ptg->TableLowIndex);
    }
    DEBUG_CHECK_LOW_INDEX(10);//deldel


    // reset the timer status to created
    
    pte->Status = TIMER_STATUS_CREATED;


    // print timer queue
    
    #if DEBUG_TIMER_REMOVETIMER2
        if (bDbg||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after _RemoveTimer");
            DebugPrintTimerQueue();
        }
    #endif

    //kslksl
    if (MyDebug&0x8) DebugScanTimerQueue(8);

    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(11);//deldel
    
    Trace0(LEAVE1, "Leaving _RemoveTimer()");
    return;
}


//------------------------------------------------------------------------------
//          _SetNextTime
// called when a timer==WTTimeout has been removed or fired,used to set the
// next min time.
//------------------------------------------------------------------------------
VOID
SetNextTime (
    DWORD        dwLowIndex
    )
{
    PIGMP_TIMER_GLOBAL    ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY     pte, pteMin=NULL;
    LONGLONG              ilMinTime;
    PLIST_ENTRY           pHead, ple;
    DWORD                 Error = NO_ERROR;
    LONGLONG              llCurTime=GetCurrentIgmpTime();

    //kslksl
    //Trace0(TIMER1, "entering _SetNextTime()");
    DEBUG_CHECK_LOW_INDEX(12);//deldel

    //kslksl
    if (MyDebug&0x11) DebugScanTimerQueue(0x11);

    //
    // if timer list empty, set lowIndex, and timer to infinite, and return.
    //
    if (ptg->NumTimers==0) {
        ptg->TableLowIndex = (DWORD)~0;
        SET_TIMER_INFINITE(ptg->WTTimeout);
        ptg->Status = TIMER_STATUS_INACTIVE;    
        return;
    }

    DEBUG_CHECK_LOW_INDEX(13);//deldel


    //
    // find lowest table index having an entry
    //
    if (dwLowIndex>NUM_TIMER_BUCKETS-1) 
        dwLowIndex = 0;

    for (;  dwLowIndex<=NUM_TIMER_BUCKETS-1;  dwLowIndex++) {
        if (IsListEmpty(&ptg->TimesTable[dwLowIndex]) )
            continue;
        else
            break;
    }
    DEBUG_CHECK_LOW_INDEX(14);//deldel

    ptg->TableLowIndex = dwLowIndex;
    DEBUG_CHECK_LOW_INDEX(15);//deldel


    //kslksl
    if (dwLowIndex==NUM_TIMER_BUCKETS)
        DbgBreakPoint();
        

    //
    // find timer entry with the lowest time
    //
    if (dwLowIndex==0) {
        pteMin = CONTAINING_RECORD(ptg->TimesTable[0].Flink, 
                                    IGMP_TIMER_ENTRY, Link);
    }
    else {

        // except bucket[0], other buckets are not sorted
        
        pHead = &ptg->TimesTable[dwLowIndex];
        ilMinTime = (((LONGLONG)0x7FFFFFF)<<32)+ ~0;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
            if (pte->Timeout<ilMinTime) {
                ilMinTime = pte->Timeout;
                pteMin = pte;
            }
        }
    }


    //
    // update global time
    //
    if ((IS_TIMER_INFINITE(ptg->WTTimeout)) 
            || (pteMin->Timeout<=ptg->WTTimeout)) 
    {
        ptg->WTTimeout = pteMin->Timeout;


        if (!IS_TIMER_INFINITE(ptg->WTTimeout)) {

            BOOL bSuccess ;
            
            bSuccess = ChangeTimerQueueTimer(ptg->WTTimer, ptg->WTTimer1,
                        llCurTime<ptg->WTTimeout
                            ?(ULONG) ((ptg->WTTimeout - llCurTime))
                            : 0,
                        1000000                   // set a periodic timer
                        );
            if (!bSuccess) {
                Error = GetLastError();
                Trace1(ERR, "ChangeTimerQueueTimer returned error:%d in SetNextTime",
                        Error);
                IgmpAssertOnError(FALSE);
            }
            else {
                #if DEBUG_TIMER_ACTIVITY
                Trace1(TIMER1, "ChangeTimerQueueTimer set to %lu",
                            (ULONG) ((ptg->WTTimeout - llCurTime))/1000);
                #if DEBUG_TIMER_ID
                g_Fire = (ULONG) ((ptg->WTTimeout - llCurTime)/1000);
                #endif
                #endif
            }
        }
            
        ptg->Status = TIMER_STATUS_ACTIVE;
    }
    DEBUG_CHECK_LOW_INDEX(16);//deldel


    //
    // resynchronize timer list if required
    //
    if ( (ptg->TableLowIndex!=0) 
            && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS > llCurTime) ) {
        
        ResyncTimerBuckets(llCurTime);
    }

    //kslksl
    if (MyDebug&0x12) DebugScanTimerQueue(0x12);
    DebugCheckLowTimer(1);//deldel
    DEBUG_CHECK_LOW_INDEX(17);//deldel

    Trace0(LEAVE1, "_SetNextTime()");
    return; 
    
} //end _SetNextTime



//------------------------------------------------------------------------------
//          _InitializeIgmpTime
// Initialize the igmp absolute timer
//------------------------------------------------------------------------------

VOID
InitializeIgmpTime(
    )
{
    g_TimerStruct.CurrentTime.HighPart = 0;
    g_TimerStruct.CurrentTime.LowPart = GetTickCount();
    return;
}


//------------------------------------------------------------------------------
//          _GetCurrentIgmpTimer
// uses GetTickCount(). converts it into 64 bit absolute timer.
//------------------------------------------------------------------------------
LONGLONG
GetCurrentIgmpTime(
    )
{
    ULONG   ulCurTimeLow = GetTickCount();


    //
    // see if timer has wrapped
    //
    // since multi-threaded, it might get preempted and CurrentTime
    // might get lower than the global variable g_TimerStruct.CurrentTime.LowPart
    // which might be set by another thread. So we also explicitly verify the
    // switch from a very large DWORD to a small one.
    // (code thanks to murlik&jamesg)
    //
    
    if ( (ulCurTimeLow < g_TimerStruct.CurrentTime.LowPart) 
        && ((LONG)g_TimerStruct.CurrentTime.LowPart < 0)
        && ((LONG)ulCurTimeLow > 0) )
    {


        // use global CS instead of creating a new CS
        
        ACQUIRE_GLOBAL_LOCK("_GetCurrentIgmpTime");


        // make sure that the global timer has not been updated meanwhile
        
        if ( (LONG)g_TimerStruct.CurrentTime.LowPart < 0) 
        {
            g_TimerStruct.CurrentTime.HighPart++;
            g_TimerStruct.CurrentTime.LowPart = ulCurTimeLow;
        }
        
        RELEASE_GLOBAL_LOCK("_GetCurrentIgmpTime");
    
    }    
    g_TimerStruct.CurrentTime.LowPart = ulCurTimeLow;


    return g_TimerStruct.CurrentTime.QuadPart;
}



//------------------------------------------------------------------------------
//        _WF_ProcessTimerEvent
//
// Processes the timer queue, firing events and sets the next timer at the end.
// Is queued by the Wait Server Thread.
// 
// Locks: Acquires global timer lock before entering into the timer queue.
//------------------------------------------------------------------------------
VOID
WF_ProcessTimerEvent (
    PVOID    pContext
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    LONGLONG            ilDiffTime, llCurTime = GetCurrentIgmpTime();
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         pHead, ple;
    PIGMP_TIMER_ENTRY   pte;
    LONGLONG            llFiredTimeout;
    #if  DEBUG_TIMER_PROCESSQUEUE2
    BOOL                bDbg = FALSE;
    #endif

    if (!EnterIgmpWorker()) {return;}
    
    Trace0(ENTER1, "Entering _WF_ProcessTimerEvent");


    // acquire timer lock
    
    ACQUIRE_TIMER_LOCK("_WF_ProcessTimerEvent");


    // print the timer queue

    #if  DEBUG_TIMER_PROCESSQUEUE1
        Trace0(TIMER1, "Printing Timer Queue before processing the timer queue");
        DebugPrintTimerQueue();
    #endif
    

    BEGIN_BREAKOUT_BLOCK1 {
    
            
        // I fire a timer if it is set to within + FORWARD_TIMER_FIRED from now
        llFiredTimeout = llCurTime + FORWARD_TIMER_FIRED;
        
        

        // if there are no timers, then I am done
        
        if (ptg->NumTimers<1) {
            Trace1(TIMER1, "Num timers%d less than 1 in _WF_ProcessTimerEvent", 
                    ptg->NumTimers);
            GOTO_END_BLOCK1;
        }


        
        //
        // find all the timers with lower timeouts and fire callbacks in my context
        //
        for ( ;  ptg->TableLowIndex <= NUM_TIMER_BUCKETS-1;  ptg->TableLowIndex++) {

            pHead = &ptg->TimesTable[ptg->TableLowIndex];
        
            for (ple=pHead->Flink;  ple!=pHead;  ) {
            
                pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                
                ple = ple->Flink;

                // this timer is fired
                if (pte->Timeout < llFiredTimeout) {
                
                    RemoveEntryList(&pte->Link);
                    pte->Status = TIMER_STATUS_FIRED;
                    ptg->NumTimers --;

                    //or should i queue to other worker threads
                            
                    (pte->Function)(pte->Context);

                    #if  DEBUG_TIMER_PROCESSQUEUE2
                    if (pte->Function!=WT_MibDisplay && pte->Function!=T_QueryTimer)
                        bDbg = TRUE;
                    #endif
                    
                }
                else {

                    if (ptg->TableLowIndex==0) //only the 1st bucket is sorted
                        break;
                }
            }

            // if any bucket is empty, then I am done, as I start with LowIndex
            if (!IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex])) 
                break;  
                
        } //end for loop


        if ( (ptg->TableLowIndex!=0) 
                && (ptg->SyncTime + TIMER_BUCKET_GRANULARITY_ABS < llCurTime) ) {
            
            ResyncTimerBuckets(llCurTime);
        }

        
        //
        // set the next lowest time
        //
        SET_TIMER_INFINITE(ptg->WTTimeout);
        SetNextTime(ptg->TableLowIndex);


    } END_BREAKOUT_BLOCK1;


    // print the timer queue

    #if  DEBUG_TIMER_PROCESSQUEUE2
        if (bDbg||g_DebugPrint) {
            Trace0(TIMER1, "   ");
            Trace0(TIMER1, "Printing Timer Queue after processing the timer queue");
            DebugPrintTimerQueue();
        }
    #endif

    //kslksl
    if (MyDebug&0x14) DebugScanTimerQueue(0x14);

    RELEASE_TIMER_LOCK("_WF_ProcessTimerEvent");

    Trace0(LEAVE1, "Leaving _WF_ProcessTimerEvent()");
    LeaveIgmpWorker();
    return ;
    
} //end _WF_ProcessTimerEvent



//------------------------------------------------------------------------------
//                WT_ProcessTimerEvent
// 
// Callback: fired when the timer set by this dll is timed out by the NtdllTimer
//------------------------------------------------------------------------------

VOID
WT_ProcessTimerEvent (
    PVOID    pContext,
    BOOLEAN  Unused
    )
{    
    //enter/leaveIgmpApi not required as the timer queue is persistent

    Trace0(ENTER1, "Entering _WT_ProcessTimerEvent()");

    QueueIgmpWorker((LPTHREAD_START_ROUTINE)WF_ProcessTimerEvent, pContext);
    
    Trace0(LEAVE1, "Leaving _WT_ProcessTimerEvent()");

    return;
}



//------------------------------------------------------------------------------
//            _InsertTimerInSortedList
// Used to insert a timer in the sorted bucket=0 
//------------------------------------------------------------------------------
VOID    
InsertTimerInSortedList(
    PIGMP_TIMER_ENTRY    pteNew,
    PLIST_ENTRY          pHead
    )
{
    PLIST_ENTRY             ple;
    PIGMP_TIMER_ENTRY       pte;
    LONGLONG                llNewTime;


    llNewTime = pteNew->Timeout;
    
    
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        if (llNewTime<= pte->Timeout)
            break;
    }

    InsertTailList(ple, &pteNew->Link);

    return;
}



//------------------------------------------------------------------------------
//          _ResyncTimerBuckets
//
// Called during insert: when the 1st bucket is empty, and other buckets have
// to be moved left   
//------------------------------------------------------------------------------

VOID 
ResyncTimerBuckets( 
    LONGLONG llCurTime
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PLIST_ENTRY         pHead, ple, pleCur;
    LIST_ENTRY          le;
    PIGMP_TIMER_ENTRY   pte;
    LONGLONG            lastBucketTime;
    DWORD               numShift, dwCount, dwBucket, i, j;

    Trace0(TIMER1, "entering _ResyncTimerBuckets()");

    DebugCheckLowTimer(0);//deldel
    DEBUG_CHECK_LOW_INDEX(21);//deldel

    Trace0(TIMER1, "Printing Timer Queue before _ResyncTimerBuckets"); //deldel
    DebugPrintTimerQueue(); //deldel


    if (ptg->NumTimers == 0)
        return;
        
    //kslksl
    if (MyDebug&0x18) DebugScanTimerQueue(0x18);

    //
    // SyncTime should always be <= to currentTime
    //
    numShift = 0;
    while (numShift<NUM_TIMER_BUCKETS
        && (ptg->SyncTime+TIMER_BUCKET_GRANULARITY_ABS <= llCurTime)
        ) {
        if (!IsListEmpty(&ptg->TimesTable[numShift]))
            break;
            
        ptg->SyncTime += TIMER_BUCKET_GRANULARITY_ABS;
        numShift++;
    }

    if (numShift==0 || numShift==NUM_TIMER_BUCKETS)
        return;


    //
    // shift all buckets left, except for the last bucket and reinitialize the 
    // list heads
    //
    for (i=0,j=numShift;  i<NUM_TIMER_BUCKETS-1-numShift;  i++,j++) {
        if (IsListEmpty(&ptg->TimesTable[j])) {
            ptg->TimesTable[j].Flink = ptg->TimesTable[j].Blink 
                                         = &ptg->TimesTable[i];
        }
        else {
            ptg->TimesTable[j].Flink->Blink = &ptg->TimesTable[i];
            ptg->TimesTable[j].Blink->Flink = &ptg->TimesTable[i];
        }
    }

    
    MoveMemory( (PVOID)&(ptg->TimesTable[0]),  
                (VOID *)&(ptg->TimesTable[numShift]),
                 (sizeof(LIST_ENTRY) * (NUM_TIMER_BUCKETS-1-numShift))
                 );

    for (dwCount=1;  dwCount<=numShift;  dwCount++)
        InitializeListHead(&ptg->TimesTable[NUM_TIMER_BUCKETS-1-dwCount]);



    //
    // go through the last bucket and redistribute it
    //
    lastBucketTime = ptg->SyncTime
                        + (TIMER_BUCKET_GRANULARITY_ABS*(NUM_TIMER_BUCKETS-1));
    
    pHead = &ptg->TimesTable[NUM_TIMER_BUCKETS-1];

    for (ple=pHead->Flink;  ple!=pHead;  ) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        pleCur = ple;
        ple = ple->Flink;

        if (pte->Timeout<lastBucketTime) {
            RemoveEntryList(pleCur);
            MAP_TO_BUCKET(dwBucket, pte->Timeout);
            if (dwBucket==0) {
                InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
            }
            else {
                InsertTailList(&ptg->TimesTable[dwBucket], pleCur);
            }
        }
    }
    
    DEBUG_CHECK_LOW_INDEX(22);//deldel


    //    
    // sort the times in the first bucket
    //
    InitializeListHead(&le);
    InsertHeadList(&ptg->TimesTable[0], &le);
    RemoveEntryList(&ptg->TimesTable[0]);
    InitializeListHead(&ptg->TimesTable[0]);

    for (ple=le.Flink; ple!=&le;  ) {
        pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
        RemoveEntryList(ple);
        ple = ple->Flink;
        InsertTimerInSortedList(pte, &ptg->TimesTable[0]);
    }

    DEBUG_CHECK_LOW_INDEX(23);//deldel


    //
    // set the TableLowIndex
    //
    if (ptg->TableLowIndex>=NUM_TIMER_BUCKETS-1) {
        for (ptg->TableLowIndex=0;  ptg->TableLowIndex<=NUM_TIMER_BUCKETS-1;  
                    ptg->TableLowIndex++) 
        {
            if (IsListEmpty(&ptg->TimesTable[ptg->TableLowIndex]) )
                continue;
            else
                break;
        }
        DEBUG_CHECK_LOW_INDEX(24);//deldel

    } 
    else {
        ptg->TableLowIndex -= numShift;
        DEBUG_CHECK_LOW_INDEX(25);//deldel
    }


    //#if DEBUG_TIMER_RESYNCTIMER deldel
    Trace0(TIMER1, "Printing Timer Queue after _ResyncTimerBuckets");
    DebugPrintTimerQueue();
    //#endif deldel


    //kslksl
    if (MyDebug&0x21) DebugScanTimerQueue(0x21);
    DebugCheckLowTimer(0);//deldel
    DEBUG_CHECK_LOW_INDEX(26);//deldel

    // debugdebug
    if (g_TimerStruct.TableLowIndex>=64 && g_TimerStruct.TableLowIndex!=~0) {
        DbgBreakPoint();
        g_TimerStruct.TableLowIndex = 0;
        SetNextTime(0);
        ResyncTimerBuckets(llCurTime);
    }
    
    Trace0(LEAVE1, "leaving _ResyncTimerBuckets()");
    return;
    
} //end _ResyncTimerBuckets



//------------------------------------------------------------------------------
//          _InitializeTimerGlobal
//
// create the timer CS and WaitTimer. registers a queue and timer with NtdllTimer.
// 
// Called by: _StartProtocol()    
// Locks: no locks taken here.
//------------------------------------------------------------------------------

DWORD
InitializeTimerGlobal (
    )
{
    DWORD               Error = NO_ERROR, i;
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    BOOL                bErr;
    LONGLONG            llCurTime = GetTickCount();

    
    
    Trace0(ENTER1, "Entering _InitializeTimerGlobal()");

    
    bErr = TRUE;
    
    BEGIN_BREAKOUT_BLOCK1 {


        // initialize igmp timer used to get tick count

        InitializeIgmpTime();


        
        //
        // initialize timer critical section
        //
        try {
            InitializeCriticalSection(&ptg->CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Error = GetExceptionCode();
            Trace1(
                ANY, "exception %d initializing global timer critical section",
                Error
                );
            Logerr0(INIT_CRITSEC_FAILED, Error);

            GOTO_END_BLOCK1;
        }
        
        #if DEBUG_FLAGS_SIGNATURE
        ptg->CSFlag = 0; //deldel
        #endif
        
        // create WaitTimer for igmp
        ptg->WTTimer = CreateTimerQueue();
        
        if ( ! ptg->WTTimer) {
            Error = GetLastError();
            Trace1(ERR, "CreateTimerQueue() failed:%d", Error);
            IgmpAssertOnError(FALSE);
            GOTO_END_BLOCK1;
        }
        


        //
        // create a periodic timer which does not get deletd
        //
        
        if (! CreateTimerQueueTimer(
                    &ptg->WTTimer1,
                    ptg->WTTimer, WT_ProcessTimerEvent,
                    NULL, //context
                    1000000,
                    1000000,
                    0
                    ))
        {
            Error = GetLastError();
            Trace1(ERR, "CreateTimerQueue() failed:%d", Error);
            IgmpAssertOnError(FALSE);
            GOTO_END_BLOCK1;
        }


        
        // set initial timeout to infinite, and SyncTime to the current time
        
        SET_TIMER_INFINITE(ptg->WTTimeout);
        ptg->SyncTime = llCurTime;
        ptg->CurrentTime.QuadPart = llCurTime;

        ptg->NumTimers = 0;



        // initialize the timer buckets
        
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            InitializeListHead(&ptg->TimesTable[i]);
        }


        // set the TableLowIndex
        ptg->TableLowIndex = (DWORD)~0;


        // set the status of the global timer
        ptg->Status = TIMER_STATUS_CREATED;
        
        bErr = FALSE;

    } END_BREAKOUT_BLOCK1;

    if (bErr) {
        DeInitializeTimerGlobal();
        Trace0(LEAVE1, "Leaving. Could not _InitializeTimerGlobal():");
        return ERROR_CAN_NOT_COMPLETE;
    } 
    else {
        Trace0(LEAVE1, "Leaving _InitializeTimerGlobal()");
        return NO_ERROR;
    }
    
} //end _InitializeTimerGlobal



//------------------------------------------------------------------------------
//        _DeInitializeTimerGlobal
//
// deinitializes the timer CS, and deletes the timer queue with Rtl
//------------------------------------------------------------------------------
VOID
DeInitializeTimerGlobal (
    )
{
    
    DeleteCriticalSection(&g_TimerStruct.CS);


    DeleteTimerQueueEx(g_TimerStruct.WTTimer, NULL);

    
    return;
    
} //end _DeInitializeTimerGlobal



//------------------------------------------------------------------------------
//              _DebugPrintTimerEntry
//
// Assumes DEBUG_TIMER_TIMERID is true
//------------------------------------------------------------------------------
VOID
DebugPrintTimerEntry (
    PIGMP_TIMER_ENTRY   pte,
    DWORD               dwBucket,
    LONGLONG            llCurTime
    )
{
    DWORD               dwDiffTime;
    CHAR                str1[20], str2[20];
    
    #if DEBUG_TIMER_TIMERID

    CHECK_TIMER_SIGNATURE(pte);

    //deldel
    //if (pte->Id==920)
      //  return;
    
    if (dwBucket==(DWORD)~0) {
        MAP_TO_BUCKET(dwBucket, pte->Timeout);
    }

    GetTimerDebugInfo(str1, str2, &dwDiffTime, pte, llCurTime);

    if (pte->Timeout - llCurTime > 0) {
        Trace8(TIMER, "----  <%2d><%d><%d> Timeout:%lu   <%s> <%s> Status:%d %x",
                dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, str2, 
                pte->Status, pte->Context);
    }
    else {
        Trace8(TIMER, "----  <%d><%d><%d> Timeout:--%lu <%s> <%s> Status:%d %x %x",
                dwBucket, pte->Id, pte->Id2, dwDiffTime, str1, str2, 
                pte->Status, pte->Context);
    }

    #endif //#if DEBUG_TIMER_TIMERID

    return;
}


//------------------------------------------------------------------------------
//          _GetTimerDebugInfo
//
// returns info regarding what type of timer it is
//------------------------------------------------------------------------------

VOID
GetTimerDebugInfo(
    CHAR                str1[20],
    CHAR                str2[20],
    DWORD              *pdwDiffTime,
    PIGMP_TIMER_ENTRY   pte,
    LONGLONG            llCurTime
    )
{
    LONGLONG    diffTime;

#if DEBUG_TIMER_TIMERID

    diffTime = (pte->Timeout - llCurTime > 0)
                ? pte->Timeout - llCurTime 
                : llCurTime - pte->Timeout;

        
    diffTime /= (LONGLONG)1000; //in seconds
    *pdwDiffTime = (DWORD)diffTime;


    strcpy(str2, "          ");
    switch (pte->Id) {
        case 110: 
        case 120: strcpy(str1, "iGenQuery   "); break;
        case 210: 
        case 220: strcpy(str1, "iOtherQry   "); break;
        case 211: strcpy(str1, "iOtherQry*  "); break;
        case 331:
        case 321: strcpy(str1, "gMemTimer*  "); INET_COPY(str2, pte->Group); break;
        case 300:
        case 320:
        case 330:
        case 340: strcpy(str1, "gMemTimer   "); INET_COPY(str2, pte->Group); break;
        case 400:
        case 410: 
        case 420: strcpy(str1, "gGrpSpQry   "); INET_COPY(str2, pte->Group); break;
        case 510: 
        case 520: strcpy(str1, "gLstV1Rpt   "); INET_COPY(str2, pte->Group); break;
        case 511: strcpy(str1, "gLstV1Rpt*  "); INET_COPY(str2, pte->Group); break;
        case 550: 
        case 560: strcpy(str1, "gLstV2Rpt   "); INET_COPY(str2, pte->Group); break; 
        case 610:
        case 620: strcpy(str1, "gGSrcExp    "); INET_COPY(str2, pte->Group);
                  lstrcat(str2, ":"); INET_CAT(str2, pte->Source); break;
        case 720: 
        case 740: strcpy(str1, "iV1Router   "); break;
        case 741: strcpy(str1, "iV1Router*  "); break;
        case 920:
        case 910: strcpy(str1, "_MibTimer   "); break;
        case 1001: strcpy(str1, "_gSrcQry   "); INET_COPY(str2, pte->Group); break;
        default:  strcpy(str1, "????        "); break;
    
    }

#endif //DEBUG_TIMER_TIMERID

    return;
}

VOID
DebugCheckTimerContexts(
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY   pte;
    PLIST_ENTRY         pHead, ple;
    DWORD               i;

    
    ACQUIRE_TIMER_LOCK("_DebugPrintTimerQueue");
    //Trace0(ERR, "%d*************", Id);
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            
            pHead = &ptg->TimesTable[i];
            if (IsListEmpty(pHead)) 
                continue;
            else {    
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                    pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                    if ( ((ULONG_PTR)pte->Context) & 0x3)
                        DbgBreakPoint();
                }
            }
        }
    RELEASE_TIMER_LOCK("_DebugPrintTimerQueue");
    return;
}

DWORD g_igmp1, g_igmp2, g_igmp3;
PLIST_ENTRY g_ple1, g_pHead;
PIGMP_TIMER_ENTRY g_pte;

//DebugCheck
DWORD
DebugScanTimerQueue(
    DWORD Id
    )
{
    Trace1(TIMER1, "_TimerQueue:%d", Id);

    #if DEBUG_TIMER_TIMERID
    if ( (g_igmp3++ & 0x7) == 0x7) { //deldel
    //if ( 1){
        DebugPrintTimerQueue();
        return 0;
    }

    for (g_igmp1=0;  g_igmp1<NUM_TIMER_BUCKETS;  g_igmp1++) {
            
        g_pHead = &g_TimerStruct.TimesTable[g_igmp1];
        if (IsListEmpty(g_pHead)) 
            continue;
        else {    
            for (g_ple1=g_pHead->Flink;  g_ple1!=g_pHead;  g_ple1=g_ple1->Flink) {
                g_pte = CONTAINING_RECORD(g_ple1, IGMP_TIMER_ENTRY, Link);
                CHECK_TIMER_SIGNATURE(g_pte);
                g_igmp2 = g_pte->Id;
            }
        }
    }

    return g_igmp1+g_igmp2;
    #else
    return 0;
    #endif
}

//------------------------------------------------------------------------------
//          _DebugPrintTimerQueue
// takes the timer lock
//------------------------------------------------------------------------------
VOID
APIENTRY
DebugPrintTimerQueue (
    )
{
    PIGMP_TIMER_GLOBAL  ptg = &g_TimerStruct;
    PIGMP_TIMER_ENTRY   pte;
    PLIST_ENTRY         pHead, ple;
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    DWORD               Error=NO_ERROR, i, count;


    //kslksl
    /*if (g_Info.CurrentGroupMemberships > 240)
        return;
  */
#if DEBUG_TIMER_TIMERID
    
    ENTER_CRITICAL_SECTION(&g_CS, "g_CS", "_DebugPrintTimerQueue");
    if (g_RunningStatus != IGMP_STATUS_RUNNING) {
        Error = ERROR_CAN_NOT_COMPLETE;
    }
    else {
        ++g_ActivityCount;
    }
    LEAVE_CRITICAL_SECTION(&g_CS, "g_CS", "_DebugPrintTimerQueue");
    if (Error!=NO_ERROR)
        return;


    if (!EnterIgmpWorker()) {return;}
    


    ACQUIRE_TIMER_LOCK("_DebugPrintTimerQueue");

    
    if (g_TimerStruct.NumTimers==0) {
        Trace0(TIMER, "No timers present in the timer queue");

    }
    else {
        Trace0(TIMER, "---------------------LOCAL-TIMER-QUEUE-------------------------");
        Trace6(TIMER, "-- LastFire:%d FireAfter:%d  WTTimeout<%d:%lu>    SyncTime<%d:%lu>",
                g_Fire, (DWORD)(ptg->WTTimeout - llCurTime),
                TIMER_HIGH(ptg->WTTimeout), TIMER_LOW(ptg->WTTimeout), 
                TIMER_HIGH(ptg->SyncTime), TIMER_LOW(ptg->SyncTime) );
        Trace3(TIMER, "--  NumTimers:<%d>     TableLowIndex:<%lu>        Status:<%d>",
                ptg->NumTimers, ptg->TableLowIndex, ptg->Status);
        Trace0(TIMER, "---------------------------------------------------------------");
        
        count =0;
        for (i=0;  i<NUM_TIMER_BUCKETS;  i++) {
            
            pHead = &ptg->TimesTable[i];
            if (IsListEmpty(pHead)) 
                continue;
            else {    
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                    pte = CONTAINING_RECORD(ple, IGMP_TIMER_ENTRY, Link);
                    DebugPrintTimerEntry(pte, i, llCurTime);
                    count ++;
                }
            }
        }

        Trace0(TIMER, 
        "---------------------------------------------------------------\n\n");
    }
    RELEASE_TIMER_LOCK("_DebugPrintTimerQueue");


    LeaveIgmpWorker();

#endif //DEBUG_TIMER_TIMERID

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\mgmigmp.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: mgmigmp.c
//
// Abstract:
//      This file the calls and callbacks with respect to mgm
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================

#include "pchigmp.h"
#pragma hdrstop

VOID
DebugPrintProxyGroupTable (
    );


    
#define DISABLE_FLAG    0
#define ENABLE_FLAG     1



//------------------------------------------------------------------------------
//          _MgmDisableIgmprtrCallback
//
// This call is made by mgm to igmp. After this call, till igmp is enabled 
// again, no more AddMembership calls will be made to Mgm. However, igmp
// will be owning the interface and will be functioning normally.
//------------------------------------------------------------------------------

DWORD
MgmDisableIgmprtrCallback(
    DWORD   IfIndex,
    DWORD   NHAddr  //not used
    )
{
    return MgmChangeIgmprtrStatus(IfIndex, DISABLE_FLAG);
}



//------------------------------------------------------------------------------
//          _MgmEnableIgmprtrCallback
//
// This call is made by mgm to igmprtr. igmprtr should refresh all group joins.
//------------------------------------------------------------------------------

DWORD
MgmEnableIgmprtrCallback(
    DWORD   IfIndex,
    DWORD   NHAddr  //not used
    )
{
    return MgmChangeIgmprtrStatus(IfIndex, ENABLE_FLAG);
}



//------------------------------------------------------------------------------
//          MgmChangeIgmprtrStatus
//------------------------------------------------------------------------------
DWORD
MgmChangeIgmprtrStatus (
    DWORD   IfIndex,
    BOOL    Flag
    )
{    
    PIF_TABLE_ENTRY     pite;
    DWORD               Error=NO_ERROR, dwRetval;
    BOOL                PrevCanAddGroupsToMgm;
    
    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }
    Trace0(ENTER1, "Entering MgmDisableIgmpCallback");


    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "MgmDisableIgmpCallback");

    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // retrieve the interface entry
        //
        pite = GetIfByIndex(IfIndex);


        //
        // return error if interface does not exist, or it is not activated
        // or is already in that state
        //
        if ( (pite == NULL)||(!IS_IF_ACTIVATED(pite))
            || ((Flag==ENABLE_FLAG)&&(IS_IGMPRTR_ENABLED_BY_MGM(pite)))
            || ((Flag==DISABLE_FLAG)&&(!IS_IGMPRTR_ENABLED_BY_MGM(pite)))
            ) 
        {
            if (Flag==ENABLE_FLAG) {
                Trace1(ERR, 
                    "MgmEnableIgmpCallback(): interface:%0x nonexistant or active",
                    IfIndex);
                IgmpAssertOnError(FALSE);
            }
            else {
                Trace1(ERR, 
                    "MgmDisableIgmpCallback(): interface:%0x nonexistant or inactive",
                    IfIndex);
                IgmpAssertOnError(FALSE);
            }
            
            Error = ERROR_INVALID_PARAMETER;
            GOTO_END_BLOCK1;
        }
        
        

        PrevCanAddGroupsToMgm = CAN_ADD_GROUPS_TO_MGM(pite);

        
        if (Flag==ENABLE_FLAG) {
            DWORD   dwProtoId, dwComponentId;
            
            // set the status field to enabled.
            MGM_ENABLE_IGMPRTR(pite);

            MgmGetProtocolOnInterface(IfIndex, 0, &dwProtoId, &dwComponentId);
            
            if (dwProtoId!=PROTO_IP_IGMP)
                SET_MPROTOCOL_PRESENT_ON_IGMPRTR(pite);
                
        }
        else {
            // set the flag to disabled and also reset MProtocol present field
            MGM_DISABLE_IGMPRTR(pite);
            
        }            

        if (PrevCanAddGroupsToMgm & !CAN_ADD_GROUPS_TO_MGM(pite))
            Trace1(MGM, "Igmp Router stop propagating groups to MGM on If:%0x",
                        IfIndex);

        if (!PrevCanAddGroupsToMgm & CAN_ADD_GROUPS_TO_MGM(pite))
            Trace1(MGM, "Igmp Router start propagating groups to MGM on If:%0x",
                        IfIndex);
                        

        //
        // for all the groups for this interface, call MgmDeleteGroupMembershipEntry
        //

        if (CAN_ADD_GROUPS_TO_MGM(pite)) {

            if (Flag==ENABLE_FLAG)
                RefreshMgmIgmprtrGroups(pite, ADD_FLAG);
            else 
                RefreshMgmIgmprtrGroups(pite, DELETE_FLAG);

        }         
        

                                            
    } END_BREAKOUT_BLOCK1;


    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "MgmDisableIgmpCallback");

    Trace1(LEAVE1, "Leaving MgmDisableIgmpCallback(%d)", Error);
    LeaveIgmpApi();
    return Error;
}


//------------------------------------------------------------------------------
//          RefreshMgmIgmprtrGroups
//------------------------------------------------------------------------------

DWORD
RefreshMgmIgmprtrGroups (
    PIF_TABLE_ENTRY pite,
    BOOL            Flag
    )
{
    PLIST_ENTRY         pHead, ple;
    PGI_ENTRY           pgie;
    DWORD               Error=NO_ERROR;
    PGI_SOURCE_ENTRY pSourceEntry;
    

    ACQUIRE_ENUM_LOCK_EXCLUSIVE("_RefreshMgmIgmprtrGroups");
    ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_RefreshMgmIgmprtrGroups");

    pHead = &pite->ListOfSameIfGroups;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);


        if (Flag==ADD_FLAG) {

            if (pgie->Version==1 || pgie->Version==2
                || (pgie->Version==3 && pgie->FilterType==EXCLUSION) )
            {
                MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr, 0, 0,
                    pgie->pGroupTableEntry->Group,
                    0xffffffff, MGM_JOIN_STATE_FLAG);
            }
            else {//ver3 inclusion

                PLIST_ENTRY pSourceHead, pSourceLE;
                
                pSourceHead = &pgie->V3InclusionListSorted;
                for (pSourceLE=pSourceHead->Flink;  pSourceLE!=pSourceHead;  
                    pSourceLE=pSourceLE->Flink)
                {
                    pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSourcesInclListSorted);
                    MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr, pSourceEntry->IpAddr, 0xffffffff,
                        pgie->pGroupTableEntry->Group,
                        0xffffffff, MGM_JOIN_STATE_FLAG);
                }

            }
        }
        else {

            if (pgie->Version==1 || pgie->Version==2
                || (pgie->Version==3 && pgie->FilterType==EXCLUSION) )
            {
                MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr, 0, 0,
                    pgie->pGroupTableEntry->Group,
                    0xffffffff, MGM_JOIN_STATE_FLAG);
            }
            else {//ver3 inclusion

                PLIST_ENTRY pSourceHead, pSourceLE;

                pSourceHead = &pgie->V3InclusionListSorted;
                for (pSourceLE=pSourceHead->Flink;  pSourceLE!=pSourceHead;  
                    pSourceLE=pSourceLE->Flink)
                {
                    pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSourcesInclListSorted);
                    MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite, pgie->NHAddr,
                        pSourceEntry->IpAddr, 0xffffffff,
                        pgie->pGroupTableEntry->Group, 0xffffffff, MGM_JOIN_STATE_FLAG);
                }
            }
        }
    }

    RELEASE_ENUM_LOCK_EXCLUSIVE("_RefreshMgmIgmprtrGroups");
    RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_RefreshMgmIgmprtrGroups");


    return Error;
}


//------------------------------------------------------------------------------
//              RegisterProtocolWithMgm
//------------------------------------------------------------------------------
DWORD
RegisterProtocolWithMgm(
    DWORD   ProxyOrRouter
    )
{
    DWORD                       Error=NO_ERROR;
    ROUTING_PROTOCOL_CONFIG     rpiInfo; //for mgm

    
    // register router with mgm
    
    if (ProxyOrRouter==PROTO_IP_IGMP) {

        ZeroMemory(&rpiInfo, sizeof(rpiInfo));
        rpiInfo.dwCallbackFlags = 0;
        rpiInfo.pfnRpfCallback 
                    = (PMGM_RPF_CALLBACK)IgmpRpfCallback;
        rpiInfo.pfnCreationAlertCallback 
                    = (PMGM_CREATION_ALERT_CALLBACK)IgmpRtrCreationAlertCallback;
        rpiInfo.pfnPruneAlertCallback 
                    = NULL;
        rpiInfo.pfnJoinAlertCallback 
                    = NULL;
        rpiInfo.pfnWrongIfCallback 
                    = NULL;
        rpiInfo.pfnLocalJoinCallback 
                    = NULL;
        rpiInfo.pfnLocalLeaveCallback 
                    = NULL;
        rpiInfo.pfnEnableIgmpCallback
                    = MgmEnableIgmprtrCallback;
                    
        rpiInfo.pfnDisableIgmpCallback
                    = MgmDisableIgmprtrCallback;

                    
                    
        Error = MgmRegisterMProtocol( &rpiInfo, PROTO_IP_IGMP, IGMP_ROUTER_V2,
                                        &g_MgmIgmprtrHandle);
        if (Error!=NO_ERROR) {
            Trace1(ERR, "Error:%d registering IGMP Router with MGM", Error);
            IgmpAssertOnError(FALSE);
            Logerr0(MGM_REGISTER_FAILED, Error);
            return Error;
        }
    }

    // register proxy with mgm
    
    else {

        //
        // register Igmp proxy with MGM. I register Proxy irrespective of whether
        // this router might be setup as a proxy or not.
        //
        
        rpiInfo.dwCallbackFlags = 0;
        rpiInfo.pfnRpfCallback 
                    = (PMGM_RPF_CALLBACK)ProxyRpfCallback;
        rpiInfo.pfnCreationAlertCallback 
                    = (PMGM_CREATION_ALERT_CALLBACK)ProxyCreationAlertCallback;
        rpiInfo.pfnPruneAlertCallback 
                    = (PMGM_PRUNE_ALERT_CALLBACK)ProxyPruneAlertCallback;
        rpiInfo.pfnJoinAlertCallback 
                    = (PMGM_JOIN_ALERT_CALLBACK)ProxyJoinAlertCallback;
        rpiInfo.pfnWrongIfCallback 
                    = NULL;
        rpiInfo.pfnLocalJoinCallback 
                    = NULL;
        rpiInfo.pfnLocalLeaveCallback 
                    = NULL;


        Error = MgmRegisterMProtocol( &rpiInfo, PROTO_IP_IGMP_PROXY, IGMP_PROXY,
                                        &g_MgmProxyHandle);
                                        
        if (Error!=NO_ERROR) {
            Trace1(ERR, "Error:%d registering Igmp Proxy with Mgm", Error);
            IgmpAssertOnError(FALSE);
            Logerr0(MGM_PROXY_REGISTER_FAILED, Error);            
            return Error;
        }
    }

    return Error;
}


//------------------------------------------------------------------------------
//          IgmpRpfCallback
//------------------------------------------------------------------------------
DWORD
IgmpRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    PDWORD          dwInIfIndex,
    PDWORD          dwInIfNextHopAddr,
    PDWORD          dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    )
/*++
Routine Description:
    Called by MGM when a packet is received on an interface owned by Igmp to see
    if it can go ahead and create an MFE. Igmp does an Rpf check with RTM 
    and returns the value. No check is done to see if the interface is really
    owned by igmp. It doesnt matter if the interface is activated or not.
--*/
{
    DWORD   Error = NO_ERROR;
    
#if RTMv2
    return Error;
#else


    PRTM_IP_ROUTE   prirRpfRoute = (PRTM_IP_ROUTE) pbBuffer; 

    // enterIgmpApi not required, as this call cannot be made when igmp is not up    
    
    //
    // Perform Rpf check with Rtm 
    //
    if (RtmLookupIPDestination(dwSourceAddr, prirRpfRoute)==TRUE) {
    
        if (prirRpfRoute->RR_InterfaceID!=*dwInIfIndex) {

            *dwInIfIndex = prirRpfRoute->RR_InterfaceID;
            
            // the route was found, but the interface is incorrect
            Error = ERROR_INVALID_PARAMETER;
        }
        else {
            // rpf check successful
            Error = NO_ERROR;
        }
    }
    else {
        // route not found
        Error = ERROR_NOT_FOUND;
    }
    
    Trace4(MGM, 
        "Rpf callback for MGroup(%d.%d.%d.%d) Src(%d.%d.%d.%d) IncomingIf(%d):%d",
        PRINT_IPADDR(dwGroupAddr), PRINT_IPADDR(dwSourceAddr), *dwInIfIndex, Error);


    return Error;
#endif
}



//------------------------------------------------------------------------------
//          ProxyRpfCallback
//------------------------------------------------------------------------------
DWORD
ProxyRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           *dwInIfIndex,
    DWORD           *dwInIfNextHopAddr,
    DWORD           *dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    )
/*++
Routine Description:
    Called by MGM when a packet is received on an interface owned by Proxy to see
    if it can go ahead and create an MFE. Proxy does an Rpf check with RTM 
    and returns the value. No check is done to see if the interface is really
    owned by igmp. It doesnt matter if the interface is activated or not.
--*/
{
    DWORD   Error = NO_ERROR;
    
#if RTMv2
    return Error;
#else
    // enterIgmpApi not required, as this call cannot be made when igmp is not up    
    

    PRTM_IP_ROUTE   prirRpfRoute = (PRTM_IP_ROUTE) pbBuffer; 

    //
    // Perform Rpf check with Rtm 
    //
    if (RtmLookupIPDestination(dwSourceAddr, prirRpfRoute)==TRUE) {
    
        if (prirRpfRoute->RR_InterfaceID!=*dwInIfIndex) {

            *dwInIfIndex = prirRpfRoute->RR_InterfaceID;

        
            // the route was found, but the interface is incorrect
            Error = ERROR_INVALID_PARAMETER;
        }
            
        else {
            // rpf check successful
            Error = NO_ERROR;
        }
    }
    else {
        // route not found
        Error = ERROR_NOT_FOUND;
    }
    
    Trace4(MGM, 
        "Rpf callback for MGroup(%d.%d.%d.%d) Src(%d.%d.%d.%d) IncomingIf(%d):%d",
        PRINT_IPADDR(dwGroupAddr), PRINT_IPADDR(dwSourceAddr), *dwInIfIndex, Error);


    return Error;
#endif
}

//------------------------------------------------------------------------------
//          IgmpRtrCreationAlertCallback
//------------------------------------------------------------------------------
DWORD
IgmpRtrCreationAlertCallback ( 
    DWORD           Source,
    DWORD           dwSourceMask,
    DWORD           Group,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   Oif
    )
/*++
Routine Description:
    Called when the first interface owned by some other protocol joins any group.
    This routine does nothing, as igmp does not send any joins upstream.
Return Value:
    NO_ERROR
--*/
{
    DWORD       i, IfIndex, NextHop;
    DWORD       Error=NO_ERROR;
    PIF_TABLE_ENTRY         pite;
    PGROUP_TABLE_ENTRY      pge;
    PGI_ENTRY               pgie;
    PGI_SOURCE_ENTRY        pSourceEntry;

    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    for (i=0;  i<dwIfCount;  i++) {

        IfIndex = Oif[i].dwIfIndex;
        NextHop = Oif[i].dwIfNextHopAddr;
        if (!Oif[i].bIGMP)
            continue;


        ACQUIRE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");

        //
        // retrieve the interface
        //
        pite = GetIfByIndex(IfIndex);
        if ( (pite==NULL) || !IS_IF_ACTIVATED(pite) ) {

            Oif[i].bIsEnabled = FALSE;
            
            Trace1(IF,
                "_IgmpRtrCreationAlertCallback: interface %d not found/activated", 
                IfIndex);
            RELEASE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");
            continue;
        }

        // if interface is not version 3, then return true immediately
        if (!IS_IF_VER3(pite)) {
            Oif[i].bIsEnabled = TRUE;
            RELEASE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");
            continue;
        }
        
        
        ACQUIRE_GROUP_LOCK(Group, "_IgmpRtrCreationAlertCallback");

        BEGIN_BREAKOUT_BLOCK1 {
        
            pge = GetGroupFromGroupTable(Group, NULL, 0);
            if (pge==NULL) {
                Oif[i].bIsEnabled = FALSE;
                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }

            pgie = GetGIFromGIList(pge, pite, NextHop, FALSE, NULL, 0);
            if (pgie==NULL) {
                Oif[i].bIsEnabled = FALSE;
                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }

            // if pgie not ver3 return true immediately
            if (pgie->Version != 3) {
                Oif[i].bIsEnabled = TRUE;
                GOTO_END_BLOCK1;
            }

            
            pSourceEntry = GetSourceEntry(pgie, Source,
                    pgie->FilterType, NULL, 0, 0);
    
            if ( (pgie->FilterType==INCLUSION && pSourceEntry==NULL)
                || (pgie->FilterType==EXCLUSION && pSourceEntry!=NULL) )
            {
                Oif[i].bIsEnabled = FALSE;
            }
            else {
                Oif[i].bIsEnabled = TRUE;
            }
            
        } END_BREAKOUT_BLOCK1;

        RELEASE_GROUP_LOCK(Group, "_IgmpRtrCreationAlertCallback");
        RELEASE_IF_LOCK_SHARED(IfIndex, "_IgmpRtrCreationAlertCallback");
        
    }//for all IFs in Oif

    for (i=0;  i<dwIfCount;  i++) {
        Trace6(MGM,
            "[%d] IGMP-Rtr Creation Alert: <%d.%d.%d.%d : %d.%d.%d.%d> : <%0x:%0x> : :bIgmp:%d",
            Oif[i].bIsEnabled, PRINT_IPADDR(Group), PRINT_IPADDR(Source),
            Oif[i].dwIfIndex, Oif[i].dwIfNextHopAddr, 
            Oif[i].bIGMP, 
            );
    }
    
    LeaveIgmpApi();

    return NO_ERROR;
}


//------------------------------------------------------------------------------
//          ProxyCreationAlertCallback
//------------------------------------------------------------------------------
DWORD
ProxyCreationAlertCallback ( 
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   pmieOutIfList
    )
/*++
Routine Description:
    Called when the first interface owned by some other protocol joins any group.
    This routine does nothing, as igmp does not send any joins upstream.
Return Value:
    NO_ERROR
--*/
{
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    LeaveIgmpApi();

    return NO_ERROR;
}

//------------------------------------------------------------------------------
//          ProxyPruneAlertCallback
//------------------------------------------------------------------------------
DWORD
ProxyPruneAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,//not used
    BOOL            bMemberDelete,
    PDWORD          pdwTimeout
    )
/*++
Routine Description:
    Called by MGM when the outgoing interface list of an MFE becomes empty,
    or when the last interface for a group goes off.
    Proxy owns the incoming interface. Proxy leaves the Group on the incoming
    interface if no more members exist for that group. Also sets the timeout 
    value for the negative MFE.
--*/
{
    DWORD           Error=NO_ERROR;
    PPROXY_ALERT_ENTRY pProxyAlertEntry;

        
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    if (pdwTimeout!=NULL)
        *pdwTimeout = 300000;

    // ignoring ProxyPruneAlertCallback for MFE deletion
    if (!bMemberDelete) {
        LeaveIgmpApi();
        return NO_ERROR;
    }

    ACQUIRE_PROXY_ALERT_LOCK("_ProxyPruneAlertCallback");

    BEGIN_BREAKOUT_BLOCK1 {
    
        pProxyAlertEntry = IGMP_ALLOC(sizeof(PROXY_ALERT_ENTRY), 0xa00,g_ProxyIfIndex);

        PROCESS_ALLOC_FAILURE2(pProxyAlertEntry,
            "error %d allocating %d bytes",
            Error, sizeof(PROXY_ALERT_ENTRY),
            GOTO_END_BLOCK1);

        pProxyAlertEntry->Group = dwGroupAddr;
        pProxyAlertEntry->Source = dwSourceAddr;
        pProxyAlertEntry->bPrune = TRUE;

        InsertTailList(&g_ProxyAlertsList, &pProxyAlertEntry->Link);
        
        Trace0(WORKER, "Queueing _WF_ProcessProxyAlert() to prune");
        QueueIgmpWorker(WF_ProcessProxyAlert, NULL);

    } END_BREAKOUT_BLOCK1;
    
    RELEASE_PROXY_ALERT_LOCK("_ProxyPruneAlertCallback");

    LeaveIgmpApi();
    return NO_ERROR;
}


VOID
WF_ProcessProxyAlert (
    PVOID pContext
    )
{
    DWORD           ProxyIfIndex, Error = NO_ERROR;
    PIF_TABLE_ENTRY pite;

    
    if (!EnterIgmpWorker()) return;

    Trace0(ENTER1, "Entering WF_ProcessProxyAlert()");


    //
    // acquire lock on the interface and make sure that it exists
    //
    while (1) {
        ProxyIfIndex = g_ProxyIfIndex;
    
        ACQUIRE_IF_LOCK_EXCLUSIVE(ProxyIfIndex, "_Wf_ProcessProxyAlert");

        // the interface was a proxy interface
        if (ProxyIfIndex==g_ProxyIfIndex)
            break;

        // someone changed the proxy interface. so try to access it again.
        else {
            RELEASE_IF_LOCK_EXCLUSIVE(ProxyIfIndex, 
                "_Wf_ProcessProxyAlert");
        }
    }

    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // make sure that the Proxy handle is correct
        //
            
        pite = g_pProxyIfEntry;

        if ( (g_ProxyIfIndex==0)||(pite==NULL) ) 
        {
            Trace1(ERR, 
                "Proxy(Deletion/Creation)Alert Callback by MGM for "
                "interface(%d) not owned by Igmp-Proxy",
                g_ProxyIfIndex);
            IgmpAssertOnError(FALSE);
            Error = ERROR_NO_SUCH_INTERFACE;
            GOTO_END_BLOCK1;
        }

        if (!(IS_IF_ACTIVATED(g_pProxyIfEntry))) {
            Trace1(ERR, 
                "Proxy(Deletion/Creation)Alert Callback by MGM for "
                "inactivated Proxy interface(%d)",
                g_ProxyIfIndex);
            IgmpAssertOnError(FALSE);
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }

        while (TRUE) {

            PPROXY_ALERT_ENTRY pProxyAlertEntry;
            DWORD           Group, Source;
            BOOL            bPrune;
            
            
            ACQUIRE_PROXY_ALERT_LOCK("_WF_ProcessProxyAlert");

            if (IsListEmpty(&g_ProxyAlertsList)) {
                RELEASE_PROXY_ALERT_LOCK("_WF_ProcessProxyAlert");
                break;
            }

            pProxyAlertEntry = CONTAINING_RECORD(g_ProxyAlertsList.Flink, 
                                    PROXY_ALERT_ENTRY, Link);
            Group = pProxyAlertEntry->Group;
            Source = pProxyAlertEntry->Source;
            bPrune = pProxyAlertEntry->bPrune;
            RemoveEntryList(&pProxyAlertEntry->Link);
            IGMP_FREE(pProxyAlertEntry);


            Trace3(MGM, "Received %s for Grp(%d.%d.%d.%d), Src(%d.%d.%d.%d)",
                (bPrune)? "ProxyPruneAlertCallback"
                    :"ProxyJoinAlertCallback",
                PRINT_IPADDR(Group), PRINT_IPADDR(Source)
                );
                
            RELEASE_PROXY_ALERT_LOCK("_WF_ProcessProxyAlert");


            //
            // delete/add group from Proxy's group list. decrement/increment refcount
            //
            ProcessProxyGroupChange(Source, Group, 
                bPrune?DELETE_FLAG:ADD_FLAG, NOT_STATIC_GROUP);
        }
        
    } END_BREAKOUT_BLOCK1;


    RELEASE_IF_LOCK_EXCLUSIVE(g_ProxyIfIndex, "_ProcessProxyGroupChange");

    
    LeaveIgmpWorker();    
    Trace0(LEAVE1, "Leaving _Wf_ProcessProxyAlert()");
    return;
    
} //_wf_processProxyAlert



//------------------------------------------------------------------------------
//          _ProxyNewMemberCallback
//------------------------------------------------------------------------------
DWORD 
ProxyJoinAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    BOOL            bMemberDelete
    )
{
    DWORD           Error=NO_ERROR;
    PPROXY_ALERT_ENTRY pProxyAlertEntry;

    
    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }


    // ignoring ProxyJoinAlertCallback for MFE deletion
    if (!bMemberDelete) {
        LeaveIgmpApi();
        return NO_ERROR;
    }

    ACQUIRE_PROXY_ALERT_LOCK("_ProxyJoinAlertCallback");

    BEGIN_BREAKOUT_BLOCK1 {
    
        pProxyAlertEntry = IGMP_ALLOC(sizeof(PROXY_ALERT_ENTRY), 0x200,g_ProxyIfIndex);

        PROCESS_ALLOC_FAILURE2(pProxyAlertEntry,
            "error %d allocating %d bytes",
            Error, sizeof(PROXY_ALERT_ENTRY),
            GOTO_END_BLOCK1);

        pProxyAlertEntry->Group = dwGroupAddr;
        pProxyAlertEntry->Source = dwSourceAddr;
        pProxyAlertEntry->bPrune = FALSE;

        InsertTailList(&g_ProxyAlertsList, &pProxyAlertEntry->Link);
        
        Trace0(WORKER, "Queueing _WF_ProcessProxyAlert() to Join");
        QueueIgmpWorker(WF_ProcessProxyAlert, NULL);

    } END_BREAKOUT_BLOCK1;
    
    RELEASE_PROXY_ALERT_LOCK("_ProxyJoinAlertCallback");

    LeaveIgmpApi();
    return NO_ERROR;
}



//------------------------------------------------------------------------------
//          ProcessProxyGroupChange
//------------------------------------------------------------------------------
DWORD 
ProcessProxyGroupChange (
    DWORD       dwSourceAddr,
    DWORD       dwGroup,
    BOOL        bAddFlag,
    BOOL        bStaticGroup
    )
/*++
Routine Description:
    Called when a group is being joined/left by some interface. As proxy acts
    as an igmp host on that interface, it does a join/leave for that group
    on that interface. 
    There can be both static and dynamic joins. There is no distinction between 
    them. They will just bump up the refcount.
Return Value:
    ERROR_NO_SUCH_INTERFACE, ERROR_CAN_NOT_COMPLETE, NO_ERROR
Called by:
    
--*/
{
    PIF_TABLE_ENTRY        pite;
    PLIST_ENTRY            ple, pHead;
    DWORD                  Error = NO_ERROR;
    DWORD                  GroupLittleEndian = NETWORK_TO_LITTLE_ENDIAN(dwGroup);
    PLIST_ENTRY pHeadSrc, pleSrc;
    PPROXY_SOURCE_ENTRY pSourceEntry = NULL;


    
    //
    // if Proxy does not exist, or is not activated, then return error
    //
    if ( (g_pProxyIfEntry==NULL) 
            || (!(IS_IF_ACTIVATED(g_pProxyIfEntry))) ) 
    {
        Trace0(ERR, "Leaving ProcessProxyGroupChange(): Proxy not active");
        IgmpAssertOnError(FALSE);
        
        if (g_pProxyIfEntry==NULL)
            return ERROR_NO_SUCH_INTERFACE;
        else
            return ERROR_CAN_NOT_COMPLETE;
    }
        

    pite = g_pProxyIfEntry;


    BEGIN_BREAKOUT_BLOCK1 {
    
        PPROXY_GROUP_ENTRY  ppge, ppgeNew;

        pHead = &pite->pProxyHashTable[PROXY_HASH_VALUE(dwGroup)];

        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            ppge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, HT_Link);
            if ( GroupLittleEndian <= ppge->GroupLittleEndian )
                break;
        }

        //
        // adding group to proxy
        //     
        if (bAddFlag) {

            //new group addition

            //
            // the group entry does not exist
            //
            //ppge may not be valid(if ple==pHead)
            if ( (ple==pHead)||(dwGroup!=ppge->Group) ) {
                         
                ppgeNew = IGMP_ALLOC(sizeof(PROXY_GROUP_ENTRY), 0x400,0xaaaa);

                PROCESS_ALLOC_FAILURE2(ppgeNew, 
                        "error %d allocating %d bytes for Proxy group entry",
                        Error, sizeof(PROXY_GROUP_ENTRY),
                        GOTO_END_BLOCK1);

                InitializeListHead(&ppgeNew->ListSources);
                ppgeNew->NumSources = 0;
                ppgeNew->Group = dwGroup;
                ppgeNew->GroupLittleEndian = GroupLittleEndian;
                ppgeNew->RefCount = 0;

                InsertTailList(ple, &ppgeNew->HT_Link);

                InsertInProxyList(pite, ppgeNew);

                // set the time when the entry was created.
                ppgeNew->InitTime = GetCurrentIgmpTime();

                ppgeNew->bStaticGroup = (dwSourceAddr==0)? bStaticGroup : FALSE;

                
                //
                // update stats
                //
                InterlockedIncrement(&pite->Info.CurrentGroupMemberships);
                InterlockedIncrement(&pite->Info.GroupMembershipsAdded);

                ppge = ppgeNew;

                // join the group
                if (dwSourceAddr==0) {
                    Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 0);
                    ppgeNew->RefCount = 1;
                }
                // else process source entry later
                
                ppge->FilterType = (dwSourceAddr==0)? EXCLUSION : INCLUSION;
                
            } //end new group entry created

            // increase group refcount
            else if (dwSourceAddr==0) {

                //
                // leave all source mode joins and join *,G
                //
                if (ppge->RefCount==0) {
                    pHeadSrc = &ppge->ListSources;
                    for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                        pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                            PROXY_SOURCE_ENTRY, LinkSources);
                        Error = LeaveMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                pSourceEntry->IpAddr);
                        pSourceEntry->JoinMode = IGMP_GROUP_NO_STATE;
                        pSourceEntry->JoinModeIntended = IGMP_GROUP_ALLOW;
                    }
                    
                    Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                pite->IfIndex, pite->IpAddr, 0);
                    ppge->FilterType = EXCLUSION;
                }
                
                ppge->RefCount++;
                ppge->bStaticGroup |= bStaticGroup;
                
            } //group entry exists. group join

            if (dwSourceAddr!=0) {

                // check if source already present
                            
                pHeadSrc = &ppge->ListSources;
                for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                    pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                        PROXY_SOURCE_ENTRY, LinkSources);
                    if (pSourceEntry->IpAddr >= dwSourceAddr)
                        break;
                }

                // create new source
                if (pleSrc==pHeadSrc || pSourceEntry->IpAddr!=dwSourceAddr) {

                    pSourceEntry = (PPROXY_SOURCE_ENTRY) IGMP_ALLOC_AND_ZERO(sizeof(PROXY_SOURCE_ENTRY), 
                                                                            0x800,g_ProxyIfIndex);
                    PROCESS_ALLOC_FAILURE2(pSourceEntry,
                        "error %d allocating %d bytes",
                        Error,
                        sizeof(PROXY_SOURCE_ENTRY),
                        GOTO_END_BLOCK1);
                        
                    InsertTailList(pleSrc, &pSourceEntry->LinkSources);
                    pSourceEntry->IpAddr = dwSourceAddr;
                    pSourceEntry->RefCount = 1;
                    pSourceEntry->bStaticSource = bStaticGroup;
                    ppge->NumSources++;

                    //
                    // if not joined the whole group. have to join individual 
                    // sources
                    //
                    if (ppge->FilterType==INCLUSION) {
                        Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                dwSourceAddr);
                        pSourceEntry->JoinMode = IGMP_GROUP_ALLOW;
                    }
                    else {
                        pSourceEntry->JoinMode = IGMP_GROUP_NO_STATE;
                    }
                    pSourceEntry->JoinModeIntended = IGMP_GROUP_ALLOW;

                } //end new source

                // join: source already exists
                else {
                    //
                    // join back an excluded source
                    //
                    if (pSourceEntry->JoinMode==IGMP_GROUP_BLOCK) {

                        if (!pSourceEntry->bStaticSource) {

                            UnBlockSource(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                dwSourceAddr);
                            RemoveEntryList(&pSourceEntry->LinkSources);
                            IGMP_FREE(pSourceEntry);
                        }

                    }

                    else {//fix this
                        if (bStaticGroup)
                            pSourceEntry->bStaticSource = TRUE;

                        pSourceEntry->RefCount++;
                    }
                }//end: join when existing source
            }
        }

        //
        // deleting group from proxy
        //
        else {

            if ((ple==pHead) || (dwGroup>ppge->Group) ) {
                Error = ERROR_CAN_NOT_COMPLETE;
                GOTO_END_BLOCK1;
            }
            else {

                // leave source
                
                if (dwSourceAddr!=0) {

                    pHeadSrc = &ppge->ListSources;
                    for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                        pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                            PROXY_SOURCE_ENTRY, LinkSources);
                        if (pSourceEntry->IpAddr >= dwSourceAddr)
                            break;
                    }

                    // leave source: source does not exist
                    if ((pleSrc==pHeadSrc) || (pSourceEntry->IpAddr!=dwSourceAddr)) {

                        // if in exclude mode then create an exclusion entry
                        if (ppge->FilterType==EXCLUSION) {

                            pSourceEntry = (PPROXY_SOURCE_ENTRY) IGMP_ALLOC_AND_ZERO(sizeof(PROXY_SOURCE_ENTRY), 
                                                                                    0x800,g_ProxyIfIndex);
                            PROCESS_ALLOC_FAILURE2(pSourceEntry,
                                "error %d allocating %d bytes",
                                Error,
                                sizeof(PROXY_SOURCE_ENTRY),
                                GOTO_END_BLOCK1);
                                
                            InsertTailList(pleSrc, &pSourceEntry->LinkSources);
                            pSourceEntry->IpAddr = dwSourceAddr;
                            pSourceEntry->RefCount = 1;
                            pSourceEntry->bStaticSource = bStaticGroup;
                            ppge->NumSources++;
                            Error = BlockSource(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                dwSourceAddr);
                            pSourceEntry->JoinMode = IGMP_GROUP_BLOCK;
                            pSourceEntry->JoinModeIntended = IGMP_GROUP_BLOCK;

                        }
                        else { //include mode. trying to leave non-existing source
                            IgmpAssert(FALSE);
                        }
                            
                        GOTO_END_BLOCK1;
                    }

                    // leave source: source exists
                    else {

                        if ( (pSourceEntry->JoinMode==IGMP_GROUP_ALLOW)
                            ||(pSourceEntry->JoinMode==IGMP_GROUP_NO_STATE)
                            ) {
                            if (--pSourceEntry->RefCount==0) {
                                if (pSourceEntry->JoinMode==IGMP_GROUP_ALLOW) {
                                    Error = LeaveMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, dwSourceAddr);
                                }
                                RemoveEntryList(&pSourceEntry->LinkSources);
                                IGMP_FREE(pSourceEntry);
                                
                                if (--ppge->NumSources==0) {

                                    if (ppge->RefCount==0) {
                                        RemoveEntryList(&ppge->HT_Link);
                                        RemoveEntryList(&ppge->LinkBySameIfGroups);
                                        IGMP_FREE(ppge);
                                        InterlockedDecrement(&pite->Info.CurrentGroupMemberships); 
                                    }
                                }
                            }
                            else {
                                if (bStaticGroup)
                                    pSourceEntry->bStaticSource = FALSE;
                            }
                        }
                        else {
                            //if (!pSourceEntry->bStaticSource || ++pSourceEntry->RefCount>2)
                                //IgmpAssert(FALSE);
                                // do nothing. this might happen
                        }
                    }
                } // end leave source

                // leave group
                else  if (--ppge->RefCount == 0) {
                
                    Error = LeaveMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                pite->IfIndex, pite->IpAddr, 0);

                    // if no S,G then delete this group, else join the 
                    // individual sources

                    if (ppge->NumSources==0) {
                        RemoveEntryList(&ppge->HT_Link);
                        RemoveEntryList(&ppge->LinkBySameIfGroups);
                        
                        IGMP_FREE(ppge);

                        //
                        // update stats
                        //
                        InterlockedDecrement(&pite->Info.CurrentGroupMemberships);
                    }
                    else {

                        pHeadSrc = &ppge->ListSources;
                        for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc; pleSrc=pleSrc->Flink) {

                            pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                                PROXY_SOURCE_ENTRY, LinkSources);
                                                
                            Error = JoinMulticastGroup(pite->SocketEntry.Socket, dwGroup, 
                                                pite->IfIndex, pite->IpAddr, 
                                                pSourceEntry->IpAddr);
                            pSourceEntry->JoinMode = IGMP_GROUP_ALLOW;
                            pSourceEntry->JoinModeIntended = IGMP_GROUP_ALLOW;
                        }
                    }
                }
                else {
                    if (bStaticGroup)
                        ppge->bStaticGroup = FALSE;
                }
            }
        }
          
    } END_BREAKOUT_BLOCK1;


    return NO_ERROR;
    
} //end ProcessProxyGroupChange


VOID
DebugPrintProxyGroupTable (
    )
{
    PIF_TABLE_ENTRY        pite;
    PLIST_ENTRY            ple, pHead;
    DWORD                  Error = NO_ERROR, dwCount;
    PPROXY_GROUP_ENTRY     ppge;
    

    //
    // if Proxy does not exist, or is not activated, then return error
    //
    if ( (g_pProxyIfEntry==NULL) 
            || (!(IS_IF_ACTIVATED(g_pProxyIfEntry))) ) 
    {
            return;
    }
        

    pite = g_pProxyIfEntry;

    pHead = &pite->ListOfSameIfGroups; 

    Trace0(KSL, "---------------------------");
    Trace0(KSL, "Printing Proxy GroupTable");
    Trace0(KSL, "---------------------------");

    for (ple=pHead->Flink,dwCount=1;  ple!=pHead;  ple=ple->Flink,dwCount++) {

        ppge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, LinkBySameIfGroups);

        Trace3(KSL, "%2d. %d.%d.%d.%d %10d", 
                    dwCount, PRINT_IPADDR(ppge->Group), ppge->RefCount);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\pchigmp.h ===
// Precompiled header for IGMP

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define FD_SETSIZE      256
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <rtm.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <crt\stddef.h>
#include <TCHAR.H>
// defines SIO_RCVALL_IGMPCAST
#include <mstcpip.h>
#include <iprtrmib.h>
#include <mgm.h>
#include <igmprm.h>
#include <iphlpapi.h>
#include "macros.h"
#include "igmptimer.h"
#include "sync.h"
#include "table.h"
#include "table2.h"
#include "global.h"
#include "api.h"
#include "if.h"
#include "mgmigmp.h"
#include "mib.h"
#include "work.h"
#include "log.h"
#include "igmptrace.h"
#include "packet.h"
#include "work1.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\mib.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: mib.h
//
// Abstract:
//      This module contains declarations related to mibs.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================


#ifndef _MIB_H_
#define _MIB_H_



#define MIB_PROXY_GROUP_INFO   IGMP_MIB_GROUP_INFO
#define PMIB_PROXY_GROUP_INFO  PIGMP_MIB_GROUP_INFO
#define MIB_PROXY_GROUP_INFO_V3  MIB_GROUP_INFO_V3
#define PMIB_PROXY_GROUP_INFO_V3 PMIB_GROUP_INFO_V3

#define GETMODE_EXACT   0
#define GETMODE_FIRST   1
#define GETMODE_NEXT    2




//
// EXTERNAL PROTOTYPES
//
DWORD
WT_MibDisplay (
    PVOID   pContext
    );

    
DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

//
// Local prototype
//
DWORD
MibGetInternal(
    PIGMP_MIB_GET_INPUT_DATA pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA pResponse,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    );
    
PIF_TABLE_ENTRY
GetIfByListIndex(
    DWORD     	IfIndex,
    DWORD     	dwGetMode,
    PDWORD     	pdwErr
    );

VOID
WF_MibDisplay(
    PVOID pContext
    );

VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    );
    
VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA pResponse
    );

    
VOID
PrintIfConfig(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );
    

VOID
PrintIfStats(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

    
VOID
PrintIfBinding(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

VOID
PrintIfGroupsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

VOID    
PrintGroupIfsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    );

VOID
PrintProxyIfIndex(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    );
    
PGROUP_TABLE_ENTRY
GetGroupByAddr (
    DWORD       Group, 
    DWORD     	dwGetMode,
    PDWORD     	pdwErr
    );

DWORD
GetIfOrRasForEnum(
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    DWORD                       dwGetMode,
    PIF_TABLE_ENTRY             *ppite,
    PRAS_TABLE                  *pprt,
    PRAS_TABLE_ENTRY            *pprte,
    BOOL                        *bRasIfLock,
    DWORD                       Flags
    );

DWORD
MibGetInternalIfStats (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );
DWORD
MibGetInternalIfConfig (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );
DWORD
MibGetInternalIfBindings (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );
DWORD
MibGetInternalIfGroupsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );

DWORD
MibGetInternalGroupIfsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    );

DWORD
ListLength(
    PLIST_ENTRY pHead
    );
    
#endif //_MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\packet.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File: packet.c
//
// Abstract:
//      This module defines SendPacket, JoinMulticastGroup, LeaveMulticastGroup,
//      and xsum.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#include "pchigmp.h"
#pragma hdrstop

UCHAR
GetMaxRespCode(
    PIF_TABLE_ENTRY pite,
    DWORD val
    );


UCHAR GetQqic (
    DWORD val
    );
    
//------------------------------------------------------------------------------
//            _SendPacket
//
// Sends the packet. Called for ras server interfaces only for general queries.
// Locks: assumes IfRead lock
// for ver2 group specific query, send packet irrespective of pgie state.
//------------------------------------------------------------------------------
DWORD
SendPacket (
    PIF_TABLE_ENTRY  pite,
    PGI_ENTRY        pgie,        //null for gen query, and group_query_v2
    DWORD            PacketType,  //MSG_GEN_QUERY, 
                                  //MSG_GROUP_QUERY_V2,MSG_GROUP_QUERY_V3
                                  // MSG_SOURCES_QUERY
    DWORD            Group        //destination McastGrp
    )
{
    DWORD                   Error = NO_ERROR;
    SOCKADDR_IN             saSrcAddr, saDstnAddr;
    BYTE                    *SendBufPtr;
    DWORD                   SendBufLen, IpHdrLen=0, NumSources, Count;
    IGMP_HEADER UNALIGNED  *IgmpHeader;
    INT                     iLength;
    BOOL                    bHdrIncl = IS_RAS_SERVER_IF(pite->IfType);
    UCHAR                   RouterAlert[4] = {148, 4, 0, 0};

    //MSG_SOURCES_QUERY
    PIGMP_HEADER_V3_EXT     pSourcesQuery;
    LONGLONG                llCurTime;
    DWORD                   Version;


    Trace0(ENTER1, "Entering _SendPacket()");

    if (PacketType==MSG_GEN_QUERY)
        Version = GET_IF_VERSION(pite);
    else if (PacketType==MSG_GROUP_QUERY_V2)
        Version =2;
    else
        Version = pgie->Version;


    //
    // make sure that the pgie->version has not meanwhile changed
    //
    if ( ((PacketType==MSG_SOURCES_QUERY)||(PacketType==MSG_GROUP_QUERY_V3))
        && pgie->Version!=3
        ) {
        return NO_ERROR;    
    }
    if ( (PacketType==MSG_GROUP_QUERY_V2) && pgie!=NULL && pgie->Version!=2)
        return NO_ERROR;

        
    //source query and list is empty
    if (PacketType==MSG_SOURCES_QUERY && IsListEmpty(&pgie->V3SourcesQueryList))
        return NO_ERROR;


    SendBufLen = sizeof(IGMP_HEADER)
                    + ((Version==3)?sizeof(IGMP_HEADER_V3_EXT):0);
    IpHdrLen = (bHdrIncl) 
                ? sizeof(IP_HEADER) + sizeof(RouterAlert) : 0;

    if (PacketType==MSG_SOURCES_QUERY) {
        SendBufPtr = (PBYTE) IGMP_ALLOC(SendBufLen + IpHdrLen
                                + sizeof(IPADDR)*pgie->V3SourcesQueryCount, 
                                0x4000,pite->IfIndex);
    }
    else {
        SendBufPtr = (PBYTE) IGMP_ALLOC(SendBufLen+IpHdrLen, 0x8000,pite->IfIndex);
    }
    if (!SendBufPtr) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    
    //
    // set destination multicast addr (general queries sent to ALL_HOSTS_MCAST
    // and group specific queries sent to the GroupAddr
    //
    ZeroMemory((PVOID)&saDstnAddr, sizeof(saDstnAddr));
    saDstnAddr.sin_family = AF_INET;
    saDstnAddr.sin_port = 0;    
    saDstnAddr.sin_addr.s_addr = (PacketType==MSG_GEN_QUERY) ? 
                                    ALL_HOSTS_MCAST : Group;


    //
    // set igmp header
    //
    
    IgmpHeader = (IGMP_HEADER UNALIGNED*)
                (bHdrIncl
                ? &SendBufPtr[IpHdrLen]
                : SendBufPtr);


    IgmpHeader->Vertype = IGMP_QUERY;

    // have to divide GenQueryInterval by 100, as it should be in units of 100ms   
    if (PacketType==MSG_GEN_QUERY) {

        // for gen query, set response time if the IF-Ver2 else set it to 0
        IgmpHeader->ResponseTime = GetMaxRespCode(pite,
                                        pite->Config.GenQueryMaxResponseTime/100);
    }
    else {
        IgmpHeader->ResponseTime = GetMaxRespCode(pite,
                                        pite->Config.LastMemQueryInterval/100);
    }

    if (Version==3) {

        llCurTime = GetCurrentIgmpTime();
        pSourcesQuery = (PIGMP_HEADER_V3_EXT)
                                            ((PBYTE)IgmpHeader+sizeof(IGMP_HEADER));

        pSourcesQuery->Reserved =  0;
        pSourcesQuery->QRV = (UCHAR)pite->Config.RobustnessVariable;
        pSourcesQuery->QQIC = GetQqic(pite->Config.GenQueryInterval);

        pSourcesQuery->NumSources = 0;

        if (PacketType==MSG_GROUP_QUERY_V3) {
            pSourcesQuery->SFlag =
                (QueryRemainingTime(&pgie->GroupMembershipTimer, llCurTime)
                           <=pite->Config.LastMemQueryInterval)
                ? 0 : 1;
        }
        // first send gen query and 1st sources query packet without suppress bit
        else {
            pSourcesQuery->SFlag = 0;
        }
    }

    // twice in loop for sources query
    Count = (PacketType==MSG_SOURCES_QUERY)? 0 : 1;

    
    for (  ;  Count<2;  Count++) {

        IgmpHeader->Xsum = 0;
                    

        if (PacketType==MSG_SOURCES_QUERY) {

            PLIST_ENTRY pHead, ple;

            if (Count==1 && (PacketType==MSG_SOURCES_QUERY))
                pSourcesQuery->SFlag = 1;
                

            pHead = &pgie->V3SourcesQueryList;
            for (NumSources=0,ple=pHead->Flink;  ple!=pHead;  ) {

                PGI_SOURCE_ENTRY pSourceEntry = 
                        CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, V3SourcesQueryList);
                ple = ple->Flink;

                if ( (pSourcesQuery->SFlag
                        &&(QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)
                           >GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryInterval))
                    || (!pSourcesQuery->SFlag
                        &&(QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)
                           <=GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryInterval)) )
                {
                    if (NumSources==0) {
                        Trace4(SEND, 
                            "Sent Sources Query  on IfIndex(%0x) IpAddr(%d.%d.%d.%d) "
                            "for Group(%d.%d.%d.%d) SFlag:%d",
                            pite->IfIndex, PRINT_IPADDR(pite->IpAddr), 
                            PRINT_IPADDR(Group),pSourcesQuery->SFlag
                            );
                    }
                
                    pSourcesQuery->Sources[NumSources++] = pSourceEntry->IpAddr;

                    Trace1(SEND, "      Source:%d.%d.%d.%d", 
                            PRINT_IPADDR(pSourceEntry->IpAddr));
                            
                    if (--pSourceEntry->V3SourcesQueryLeft==0) {
                        RemoveEntryList(&pSourceEntry->V3SourcesQueryList);
                        pSourceEntry->bInV3SourcesQueryList = FALSE;
                        pgie->V3SourcesQueryCount--;
                    }
                }
            }

            if (NumSources==0)
                continue;
            
            pSourcesQuery->NumSources = htons((USHORT)NumSources);
            
            SendBufLen += sizeof(IPADDR)*NumSources;
        }

        IgmpHeader->Group = (PacketType==MSG_GEN_QUERY) ? 0 : Group;

        IgmpHeader->Xsum = ~xsum((PVOID)IgmpHeader, SendBufLen);

    

        //
        // send the packet 
        //
        if (!bHdrIncl) {

            Error = NO_ERROR;
            
            iLength = sendto(pite->SocketEntry.Socket, SendBufPtr, 
                            SendBufLen+IpHdrLen, 0,
                            (PSOCKADDR) &saDstnAddr, sizeof(SOCKADDR_IN)
                            );
                            
            //
            // error messages and statistics updates
            //
            if ( (iLength==SOCKET_ERROR) || ((DWORD)iLength<SendBufLen+IpHdrLen) ) {
                Error = WSAGetLastError();
                Trace4(ERR, 
                    "error %d sending query on McastAddr %d.%d.%d.%d on "
                    "interface %d(%d.%d.%d.%d)",
                    Error, PRINT_IPADDR(saDstnAddr.sin_addr.s_addr), pite->IfIndex, 
                    PRINT_IPADDR(pite->IpAddr));
                IgmpAssertOnError(FALSE);
                Logwarn2(SENDTO_FAILED, "%I%I", pite->IpAddr, saDstnAddr.sin_addr, Error);
            }
        }

                            
        //
        // for RAS server interface, use HDRINCL option. Build up the ip header and 
        // send the packet to all RAS clients.
        //
        else {

            PIP_HEADER IpHdr;
            DWORD      IpHdrLen = sizeof(IP_HEADER) + sizeof(RouterAlert);
            
            //
            // igmp follows the ip header containing the routerAlert option
            //

            IpHdr = (IP_HEADER *)((PBYTE)SendBufPtr);

            #define wordsof(x)  (((x)+3)/4) /* Number of 32-bit words */
            
            // Set IP version (4) and IP header length
            IpHdr->Hl = (UCHAR) (IPVERSION * 16 
                            + wordsof(sizeof(IP_HEADER) + sizeof(RouterAlert)));
        
            // No TOS bits are set
            IpHdr->Tos = 0;

            // Total IP length is set in host order
            IpHdr->Len = (USHORT)(IpHdrLen+sizeof(IGMP_HEADER));

            // Stack will fill in the ID
            IpHdr->Id = 0;

            // No offset
            IpHdr->Offset = 0;

            // Set the TTL to 1
            IpHdr->Ttl = 1;

            // Protocol is IGMP
            IpHdr->Protocol = IPPROTO_IGMP;

            // Checksum is set by stack
            IpHdr->Xsum = 0;

            // Set source and destination address
            IpHdr->Src.s_addr = pite->IpAddr;
            IpHdr->Dstn.s_addr = ALL_HOSTS_MCAST;


            // set the router alert option, but still set it
            memcpy( (void *)((UCHAR *)IpHdr + sizeof(IP_HEADER)),
                    (void *)RouterAlert, sizeof(RouterAlert));


            // send packet to all RAS clients, with the destination address in sendto
            // set to the unicast addr of the client
            {
                PLIST_ENTRY         pHead, ple;
                PRAS_TABLE_ENTRY    prte;
                pHead = &pite->pRasTable->ListByAddr;

                Error = NO_ERROR;
                
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                    // get address of ras client
                    prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, LinkByAddr);
                    saDstnAddr.sin_addr.s_addr = prte->NHAddr;


                    // send the packet to the client
                    iLength = sendto(pite->SocketEntry.Socket, SendBufPtr, 
                                        SendBufLen+IpHdrLen, 0,
                                        (PSOCKADDR) &saDstnAddr, sizeof(SOCKADDR_IN)
                                    ); 


                    // print error if sendto failed
                    if ((iLength==SOCKET_ERROR) || ((DWORD)iLength<SendBufLen+IpHdrLen) ) {
                        Error = WSAGetLastError();
                        Trace4(ERR, 
                            "error %d sending query to Ras client %d.%d.%d.%d on "
                            "interface %d(%d.%d.%d.%d)",
                            Error, PRINT_IPADDR(saDstnAddr.sin_addr.s_addr), pite->IfIndex, 
                            PRINT_IPADDR(pite->IpAddr)
                            );
                        IgmpAssertOnError(FALSE);
                        Logwarn2(SENDTO_FAILED, "%I%I", pite->IpAddr,
                            saDstnAddr.sin_addr.s_addr, Error);
                    }
                    else {
                        Trace1(SEND, "sent general query to ras client: %d.%d.%d.%d",
                            PRINT_IPADDR(prte->NHAddr));
                    }
                                                
                }//for loop:sent packet to a RAS client
            }//sent packets to all ras clients
        }//created IPHeader and sent packets to all ras clients
            
    }; //for loop. send both packets

    if (PacketType==MSG_SOURCES_QUERY) {

        pgie->bV3SourcesQueryNow = FALSE;

        // set timer for next sources query
        if (pgie->V3SourcesQueryCount>0) {

            ACQUIRE_TIMER_LOCK("_SendPacket");

            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&pgie->V3SourcesQueryTimer,1001, pite->IfIndex,
                            Group, 0);
            #endif

            if (IS_TIMER_ACTIVE(pgie->V3SourcesQueryTimer)) {
                UpdateLocalTimer(&pgie->V3SourcesQueryTimer,
                    (pite->Config.LastMemQueryInterval/pite->Config.LastMemQueryCount),
                    DBG_Y);
            }
            else {
                InsertTimer(&pgie->V3SourcesQueryTimer,
                    (pite->Config.LastMemQueryInterval/pite->Config.LastMemQueryCount),
                    TRUE, DBG_Y);
            }
            RELEASE_TIMER_LOCK("_SendPacket");
        }
    }
    
    //
    // if successful, print trace and update statistics
    //
    if (Error==NO_ERROR) {

        if (PacketType==MSG_GEN_QUERY) {
        
            Trace2(SEND, "Sent GenQuery  on IfIndex(%0x) IpAddr(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pite->IpAddr));
                    
            InterlockedIncrement(&pite->Info.GenQueriesSent);
        } 
        else if (PacketType==MSG_GROUP_QUERY_V2 || PacketType==MSG_GROUP_QUERY_V3) {
            Trace3(SEND, 
                "Sent Group Query  on IfIndex(%0x) IpAddr(%d.%d.%d.%d) "
                "for Group(%d.%d.%d.%d)",
                pite->IfIndex, PRINT_IPADDR(pite->IpAddr), PRINT_IPADDR(Group));
                    
            InterlockedIncrement(&pite->Info.GroupQueriesSent);
        } 
    }

    IGMP_FREE_NOT_NULL(SendBufPtr);
    
    Trace0(LEAVE1, "Leaving _SendPacket()");
    return Error;
    
} //end _SendPacket

DWORD
BlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;
  
    
   struct ip_mreq_source imr;
   imr.imr_multiaddr.s_addr  = dwGroup;
   imr.imr_sourceaddr.s_addr = Source;
   imr.imr_interface.s_addr  = IpAddr;
   dwRetval = setsockopt(Sock, IPPROTO_IP, IP_BLOCK_SOURCE,
                    (PCHAR)&imr, sizeof(imr));

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "ERROR %d BLOCKING MULTICAST GROUP(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d ON INTERFACE (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);
    }

    Trace2(MGM, "Blocking MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));
    return Error;
}


DWORD
UnBlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;
   
    
   struct ip_mreq_source imr;
   imr.imr_multiaddr.s_addr  = dwGroup;
   imr.imr_sourceaddr.s_addr = Source;
   imr.imr_interface.s_addr  = IpAddr;
   dwRetval = setsockopt(Sock, IPPROTO_IP, IP_UNBLOCK_SOURCE,
                    (PCHAR)&imr, sizeof(imr));

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "ERROR %d UN-BLOCKING MULTICAST GROUP(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d ON INTERFACE (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);
    }

    Trace2(MGM, "UnBlocking MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));
    return Error;
}

   
//------------------------------------------------------------------------------
//            _JoinMulticastGroup
//------------------------------------------------------------------------------
DWORD
JoinMulticastGroup (
    SOCKET    Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    )
{
    struct ip_mreq   imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;

    if (Source==0) {
        imOption.imr_multiaddr.s_addr = dwGroup;
        imOption.imr_interface.s_addr = IpAddr;

        dwRetval = setsockopt(Sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                            (PBYTE)&imOption, sizeof(imOption));

        
    }
    else {
       struct ip_mreq_source imr;

       imr.imr_multiaddr.s_addr  = dwGroup;
       imr.imr_sourceaddr.s_addr = Source;
       imr.imr_interface.s_addr  = IpAddr;
       dwRetval = setsockopt(Sock, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP,
                        (PCHAR)&imr, sizeof(imr));
    }

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "ERROR %d JOINING MULTICAST GROUP(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d ON INTERFACE (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);

        Logerr2(JOIN_GROUP_FAILED, "%I%I", dwGroup, IpAddr, Error);
    }

    Trace2(MGM, "Joining MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));
    return Error;
}



//------------------------------------------------------------------------------
//            _LeaveMulticastGroup
//------------------------------------------------------------------------------
DWORD
LeaveMulticastGroup (
    SOCKET  Sock,
    DWORD   dwGroup,
    DWORD   IfIndex,
    IPADDR  IpAddr,
    IPADDR  Source
    )
{
    struct ip_mreq     imOption;
    DWORD            Error = NO_ERROR;
    DWORD            dwRetval;

    if (Source==0) {
        imOption.imr_multiaddr.s_addr = dwGroup;
        imOption.imr_interface.s_addr = IpAddr;

        dwRetval = setsockopt(Sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,
                            (PBYTE)&imOption, sizeof(imOption));
    }
    else {
       struct ip_mreq_source imr;

       imr.imr_multiaddr.s_addr  = dwGroup;
       imr.imr_sourceaddr.s_addr = Source;
       imr.imr_interface.s_addr  = IpAddr;
       dwRetval = setsockopt(Sock, IPPROTO_IP, IP_DROP_SOURCE_MEMBERSHIP,
                        (PCHAR)&imr, sizeof(imr));
    }

    if (dwRetval == SOCKET_ERROR) {

        Error = WSAGetLastError();

        Trace5(ERR, 
            "error %d leaving multicast group(%d.%d.%d.%d) "
            "Source:%d.%d.%d.%d on interface (%d) %d.%d.%d.%d",
            Error, PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source),
            IfIndex, PRINT_IPADDR(IpAddr));
        IgmpAssertOnError(FALSE);
    }
    
    Trace2(MGM, "Leaving MCAST: (%d.%d.%d.%d) SOURCE (%d.%d.%d.%d)",
        PRINT_IPADDR(dwGroup), PRINT_IPADDR(Source));

    return Error;
}


//------------------------------------------------------------------------------
//          _McastSetTtl
// set the ttl value for multicast data. the default ttl for multicast is 1.
//------------------------------------------------------------------------------

DWORD
McastSetTtl(
    SOCKET sock,
    UCHAR ttl
    )
{
    INT         dwTtl = ttl;
    DWORD       Error=NO_ERROR;

    Error = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL,
                                        (char *)&dwTtl, sizeof(dwTtl));
    if (Error != 0) {
        Error = WSAGetLastError();
        Trace1(ERR, "error:%d: unable to set ttl value", Error);
        IgmpAssertOnError(FALSE);
        return Error;
    }

    return Error;
}


UCHAR
GetMaxRespCode(
    PIF_TABLE_ENTRY pite,
    DWORD val
    )
{
    if (IS_IF_VER1(pite))
        return 0;

    if (IS_IF_VER2(pite))
        return val>255 ? 0 : (UCHAR)val;

    //version 3
    if (val < 128)
        return (UCHAR)val;
        
    {
        DWORD n,mant, exp;

        n = val;
        exp = mant = 0;
        while (n) {
            exp++;
            n = n>>1;
        }
        exp=exp-2-3-3;
        mant = 15;

        if ( ((mant+16)<<(exp+3)) < val)
            exp++;

        mant = (val >> (exp+3)) - 15;

        IgmpAssert(mant<16 && exp <8); //deldel
        Trace4(KSL, "\n=======exp: LMQI:%d:%d exp:%d  mant:%d\n",
                val, (mant+16)<<(exp+3), exp, mant); //deldel
        return (UCHAR)(0x80 + (exp<<4) + mant);
    }
    

}


UCHAR
GetQqic (
    DWORD val
    )
{
    val = val/1000;
    if ((val) > 31744)
        return 0;

    if (val<128)
        return (UCHAR)val;

    {
        DWORD n,mant, exp;

        n = val;
        exp = mant = 0;
        while (n) {
            exp++;
            n = n>>1;
        }
        exp=exp-2-3-3;
        mant = 15;

        if ( ((mant+16)<<(exp+3)) < val)
            exp++;

        mant = (val >> (exp+3)) - 15;

        IgmpAssert(mant<16 && exp <8); //deldel
        Trace4(KSL, "\n=======exp: QQic:%d:%d exp:%d  mant:%d\n",
                val, (mant+16)<<(exp+3), exp, mant); //deldel
        return (UCHAR)(0x80 + (exp<<4) + mant);
    }    
}


//------------------------------------------------------------------------------
// xsum: copied from ipxmit.c
//------------------------------------------------------------------------------

USHORT
xsum(PVOID Buffer, INT Size)
{
    USHORT  UNALIGNED *Buffer1 = (USHORT UNALIGNED *)Buffer; // Buffer expressed as shorts.
    ULONG   csum = 0;

    while (Size > 1) {
        csum += *Buffer1++;
        Size -= sizeof(USHORT);
    }

    if (Size)
        csum += *(UCHAR *)Buffer1;              // For odd buffers, add in last byte.

    csum = (csum >> 16) + (csum & 0xffff);
    csum += (csum >> 16);
    return (USHORT)csum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\mgmigmp.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File Name: mgmigmp.h
//
// Abstract:
//      This file contains prototypes for functions implemented in mgmigmp.h
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//=============================================================================


#ifndef _MGMIGMP_H_
#define _MGMIGMP_H_

                
#define  MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite,NHAddr, Src,Mask1,Group,Mask2,Flag) {\
    DWORD RetVal;\
    if (CAN_ADD_GROUPS_TO_MGM(pite)) {\
        RetVal = MgmAddGroupMembershipEntry(g_MgmIgmprtrHandle,\
                    Src, Mask1, Group, Mask2, (pite)->IfIndex, NHAddr, Flag);\
        Trace5(MGM, "Add <%d.%d.%d.%d: %d.%d.%d.%d> If:%0x to MGM Mode:%d [%d]",\
            PRINT_IPADDR(Group), PRINT_IPADDR(Src), pite->IfIndex, Flag, RetVal);\
    }\
}

#define  MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite,NHAddr, Src,Mask1,Group,Mask2,Flag){\
    DWORD RetVal;\
    if (CAN_ADD_GROUPS_TO_MGM(pite)){\
        RetVal = MgmDeleteGroupMembershipEntry(g_MgmIgmprtrHandle,\
                    Src, Mask1, Group, Mask2, (pite)->IfIndex, NHAddr, Flag);\
        Trace5(MGM, "Delete <%d.%d.%d.%d: %d.%d.%d.%d> If:%0x from MGM Mode:%d [%d]",\
            PRINT_IPADDR(Group), PRINT_IPADDR(Src), pite->IfIndex,Flag,RetVal);\
    }\
}

typedef struct _PROXY_ALERT_ENTRY {
    LIST_ENTRY Link;
    DWORD   Group;
    DWORD   Source;
    DWORD   bPrune;
} PROXY_ALERT_ENTRY, *PPROXY_ALERT_ENTRY;

VOID
WF_ProcessProxyAlert (
    PVOID pContext
    );


DWORD
RegisterProtocolWithMgm(
    DWORD   ProxyOrRouter
    );

    
DWORD
IgmpRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    PDWORD          dwInIfIndex,
    PDWORD          dwInIfNextHopAddr,
    PDWORD          dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    );


DWORD
ProxyRpfCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           *dwInIfIndex,
    DWORD           *dwInIfNextHopAddr,
    DWORD           *dwUpstreamNeighbor,
    DWORD           dwHdrSize,
    PBYTE           pbPacketHdr,
    PBYTE           pbBuffer
    );

DWORD
IgmpRtrCreationAlertCallback ( 
    DWORD           Source,
    DWORD           dwSourceMask,
    DWORD           Group,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   Oif
    );

DWORD
ProxyCreationAlertCallback ( 
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwInIfIndex,
    DWORD           dwInIfNextHopAddr,
    DWORD           dwIfCount,     
    PMGM_IF_ENTRY   pmieOutIfList
    );

DWORD
ProxyPruneAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    DWORD           dwIfIndex,
    DWORD           dwIfNextHopAddr,
    BOOL            bMemberDelete,
    PDWORD          pdwTimeout
    );

DWORD 
ProxyJoinAlertCallback (
    DWORD           dwSourceAddr,
    DWORD           dwSourceMask,
    DWORD           dwGroupAddr,
    DWORD           dwGroupMask,
    BOOL            bMemberUpdate
    );

DWORD 
ProcessProxyGroupChange (
    DWORD           dwSourceAddr,
    DWORD           dwGroup,
    BOOL            bAddFlag,
    BOOL            bStaticGroup
    );


DWORD
RefreshAllMembersCallback (
    DWORD           IfIndex
    );
    
DWORD
IgmpRefreshJoinsCallback (
    DWORD           dwIfIndex,
    DWORD           dwNHAddr
);

DWORD
MgmChangeIgmprtrStatus (
    DWORD   IfIndex,
    BOOL    Flag
    );

DWORD
RefreshMgmIgmprtrGroups (
    PIF_TABLE_ENTRY pite,
    BOOL            Flag
    );
    
#endif //_MGMIGMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\mib.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// Module Name: Mib.c
//
// Abstract:
//      This module implements the mib API's:
//          MibGet, MibGetFirst and MibGetNext. 
//      It also implements the Mib Display tracing, which displays the mib
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================
 

#include "pchigmp.h"
#pragma hdrstop

DWORD g_IgmpMibDisplay = 1;


//------------------------------------------------------------------------------
// Functions to display the MibTable on the TraceWindow periodically
//------------------------------------------------------------------------------


#ifdef MIB_DEBUG



#define ClearScreen(h) {                                                    \
    DWORD _dwin,_dwout;                                                     \
    COORD _c = {0, 0};                                                      \
    CONSOLE_SCREEN_BUFFER_INFO _csbi;                                       \
    GetConsoleScreenBufferInfo(h,&_csbi);                                   \
    _dwin = _csbi.dwSize.X * _csbi.dwSize.Y;                                \
    FillConsoleOutputCharacter(h,' ',_dwin,_c,&_dwout);                     \
}

#define WRITELINE(h,c,fmt,arg) {                                            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg);                                                 \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITE_NEWLINE(h,c)      \
    WRITELINE(                  \
        hConsole, c, "%s",      \
        ""                      \
        );    

#define WRITELINE2(h,c,fmt,arg1, arg2) {                                    \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2);                                          \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE3(h,c,fmt,arg1, arg2, arg3) {                              \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, (arg2), (arg3));                                    \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE4(h,c,fmt,arg1, arg2, arg3, arg4) {                        \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4);                              \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE5(h,c,fmt,arg1, arg2, arg3, arg4, arg5) {                  \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5);                        \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE6(h,c,fmt,arg1, arg2, arg3, arg4, arg5, arg6) {            \
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6);                  \
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE7(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE8(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}
#define WRITELINE9(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

#define WRITELINE10(h,c,fmt,arg1, arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)  {\
    DWORD _dw;                                                              \
    CHAR _sz[200], _fmt[200];                                               \
    wsprintf(_fmt,"%-100s",fmt);                                            \
    wsprintf(_sz,_fmt,arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,arg10);\
    WriteConsoleOutputCharacter(h,_sz,lstrlen(_sz),c,&_dw);                 \
    ++(c).Y;                                                                \
}

DWORD
WT_MibDisplay (
    PVOID   pContext
    )
{
    //enter/leaveIgmpApi not required as the timer queue is persistent
    QueueIgmpWorker(WF_MibDisplay, NULL);

    return 0;
}


//------------------------------------------------------------------------------
//          _WF_MibDisplay
//------------------------------------------------------------------------------    

VOID
WF_MibDisplay(
    PVOID pContext
    ) 
{
    COORD                       c;
    HANDLE                      hConsole;
    DWORD                       Error=NO_ERROR, dwTraceId, dwCurTableId=0, dwEnumCount;
    DWORD                       dwExactSize, dwInSize, dwBufferSize, dwOutSize;
    IGMP_MIB_GET_INPUT_DATA     Query;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;
    LARGE_INTEGER               llCurrentTime;
    BOOL                        bChanged, bEndOfTables;
    
    if (!EnterIgmpWorker()) { return; }

    if (g_IgmpMibDisplay==0) {

        ACQUIRE_TIMER_LOCK("_WF_MibDisplay");

        g_MibTimer.Status = TIMER_STATUS_CREATED;
        
        #if DEBUG_TIMER_TIMERID
            SET_TIMER_ID(&g_MibTimer, 920, 0, 0, 0);
        #endif

        if (g_Info.CurrentGroupMemberships<=20)
            InsertTimer(&g_MibTimer, 30000, TRUE, DBG_Y);//kslksl
        else if (g_Info.CurrentGroupMemberships<=320)
            InsertTimer(&g_MibTimer, 120000, TRUE, DBG_N);//kslksl
        else
            InsertTimer(&g_MibTimer, 1200000, TRUE, DBG_N);
        RELEASE_TIMER_LOCK("_WF_MibDisplay");

        LeaveIgmpWorker();
        return;
    }
    else if (g_IgmpMibDisplay==0xff) {
        LeaveIgmpWorker();
        return;
    }
    
    TraceGetConsole(g_MibTraceId, &hConsole);


    if (hConsole == NULL) {
        LeaveIgmpWorker();
        return;
    }



    ClearScreen(hConsole);

    Sleep(200);
    c.X = c.Y = 0;


    dwInSize = sizeof(Query);

    Query.GroupAddr = 0;
    Query.TypeId = IGMP_GLOBAL_CONFIG_ID;

    Query.Flags = IGMP_ENUM_ALL_INTERFACES_GROUPS | IGMP_ENUM_ALL_TABLES
                    | IGMP_ENUM_SUPPORT_FORMAT_IGMPV3;
                    
    Query.Count = 20;
    pResponse = NULL;


    //
    // get size of the first entry in the first table
    //

    Query.Count = 20;

    dwOutSize = dwBufferSize = 0;
    Error = MibGetFirst(dwInSize, &Query, &dwOutSize, pResponse);


    if (Error == ERROR_INSUFFICIENT_BUFFER) {

        //
        // allocate a buffer, and set its size
        //
        dwOutSize = dwBufferSize = (dwOutSize<MIB_DEFAULT_BUFFER_SIZE) 
                                    ? MIB_DEFAULT_BUFFER_SIZE : dwOutSize;
        pResponse = IGMP_ALLOC(dwOutSize, 0x801,0);

        PROCESS_ALLOC_FAILURE2(pResponse, 
            "error %d allocating %d bytes. stopping mib display",
            Error, dwOutSize, return);
                

        //
        // perform the query again
        //

        Error = MibGetFirst(dwInSize, &Query, &dwOutSize, pResponse);

    }



    //
    // now that we have the first element in the first table,
    // we can enumerate the elements in the remaining tables using GetNext
    //

    for (dwEnumCount=1;  dwEnumCount<=3;  dwEnumCount++) {
    
        while (Error==NO_ERROR) {

            //bEndOfTables = FALSE;
            //while(bEndOfTables==FALSE) {

            if (dwCurTableId!=pResponse->TypeId) {

                //
                // move to the next line on the console
                //

                ++c.Y;

                WRITELINE(
                    hConsole, c, "%s",
                    "---------------------------------------------------------------",
                    );
                dwCurTableId = pResponse->TypeId;
                bChanged = TRUE;
            }
            else
                bChanged = FALSE;

            
            //
            // print the current element and set up the query
            // for the next element (the display functions  change Query
            // so that it can be used to query the next element)
            //

            switch(pResponse->TypeId) {
                
                case IGMP_GLOBAL_CONFIG_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Global Configuration",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "--------------------",
                                );
                    }
                    
                    PrintGlobalConfig(hConsole,&c, &Query, pResponse);
                    break;
                }
                
                case IGMP_GLOBAL_STATS_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Global Statistics Information",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "-----------------------------",
                                );
                    }
                    PrintGlobalStats(hConsole, &c, &Query, pResponse);
                    break;
                }
                
                case IGMP_IF_CONFIG_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface Config Table",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "----------------------",
                                );
                    }
                    
                    PrintIfConfig(hConsole, &c, &Query, pResponse);
                    break;
                }

                case IGMP_IF_STATS_ID:
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface Statistics Table",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "--------------------------",
                                );
                    }
                    PrintIfStats(hConsole, &c, &Query, pResponse);
                    break;

                case IGMP_IF_BINDING_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface Binding Table",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "-----------------------",
                                );
                    }
                    PrintIfBinding(hConsole, &c, &Query, pResponse);
                    break;
                }
                
                case IGMP_IF_GROUPS_LIST_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "Interface-MulticastGroups Table",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "--------------------------------",
                                );
                    }
                    
                    PrintIfGroupsList(hConsole, &c, &Query, pResponse);

                    break;
                }
                
                case IGMP_GROUP_IFS_LIST_ID:
                {
                    if (bChanged) {
                        WRITELINE(
                                hConsole, c, "%s",
                                "MulticastGroups-Interface Table",
                                );
                        WRITELINE(
                                hConsole, c, "%s",
                                "-------------------------------",
                                );
                        WRITELINE(
                            hConsole, c, "%s",
                            "(Ver) GroupAddr            (Up/Exp)Time Flg <IfIndex:IpAddr>      LastReporter  "
                            " V1Host V2Host"
                        );

                        WRITE_NEWLINE(hConsole, c);

                    }

                    PrintGroupIfsList(hConsole, &c, &Query, pResponse);
                    
                    break;
                }

                case IGMP_PROXY_IF_INDEX_ID:
                {
                    WRITELINE(
                            hConsole, c, "%s",
                            "Proxy Interface Index",
                            );
                    WRITELINE(
                            hConsole, c, "%s",
                            "---------------------",
                            );
                    PrintProxyIfIndex(hConsole, &c, &Query, pResponse);

                    break;
                }
                    
                default:
                    bEndOfTables = TRUE;
                    break;
            }


            //
            // query the next MIB element
            //

            Query.Count = 20;

            //kslksl
            IGMP_FREE(pResponse);
            pResponse = IGMP_ALLOC(dwBufferSize, 0xb000,0);


            dwOutSize = dwBufferSize;
            Error = MibGetNext(dwInSize, &Query, &dwOutSize, pResponse);


            if (Error == ERROR_INSUFFICIENT_BUFFER) {

                //
                // allocate a new buffer, and set its size
                //
                dwOutSize = dwBufferSize = (dwOutSize<MIB_DEFAULT_BUFFER_SIZE) 
                                            ? MIB_DEFAULT_BUFFER_SIZE : dwOutSize;

                IGMP_FREE(pResponse);
                pResponse = IGMP_ALLOC(dwOutSize, 0x2000,0);
                PROCESS_ALLOC_FAILURE2(pResponse, 
                    "error %d allocating %d bytes. stopping mib display",
                    Error, dwOutSize, return);


        
                // perform the query again

                Error = MibGetNext(dwInSize, &Query, &dwOutSize, pResponse);

            }
            
        } // while no_error: print all tables

        Query.Flags = IGMP_ENUM_FOR_RAS_CLIENTS;
        Query.IfIndex = g_ProxyIfIndex;
        Query.TypeId = dwEnumCount==1? IGMP_IF_STATS_ID : IGMP_IF_GROUPS_LIST_ID;
        bChanged = TRUE;
    }


    //
    // if memory was allocated, free it now    
    //
    if (pResponse != NULL) { IGMP_FREE(pResponse); }


    //
    // schedule next MIB display
    //

    ACQUIRE_TIMER_LOCK("_WF_MibDisplay");
    
    g_MibTimer.Status = TIMER_STATUS_CREATED;
    
    #if DEBUG_TIMER_TIMERID
        SET_TIMER_ID(&g_MibTimer, 920, 0, 0, 0);
    #endif

    if (g_Info.CurrentGroupMemberships<=20)
        InsertTimer(&g_MibTimer, 20000, TRUE, DBG_N);
    else if (g_Info.CurrentGroupMemberships<=320)
        InsertTimer(&g_MibTimer, 120000, TRUE, DBG_N);
    else
        InsertTimer(&g_MibTimer, 1200000, TRUE, DBG_N);

    RELEASE_TIMER_LOCK("_WF_MibDisplay");

    LeaveIgmpWorker();
    
} //end _WF_MibDisplay





//------------------------------------------------------------------------------
//          _PrintGlobalStats
//------------------------------------------------------------------------------
VOID
PrintGlobalStats(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    ) 
{
    PIGMP_GLOBAL_STATS pgs;


    pgs = (PIGMP_GLOBAL_STATS)pResponse->Buffer;

    WRITELINE(
        hConsole, *pc, "Current Group Memberships:            %d",
        pgs->CurrentGroupMemberships
        );
    WRITELINE(
        hConsole, *pc, "Group Memberships Added:              %d",
        pgs->GroupMembershipsAdded
        );

    pQuery->TypeId = IGMP_GLOBAL_STATS_ID;
}


//------------------------------------------------------------------------------
//          _PrintProxyIfIndex
//------------------------------------------------------------------------------
VOID
PrintProxyIfIndex(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA       pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA      pResponse
    ) 
{
    DWORD   *pProxyIfIndex = (PDWORD)pResponse->Buffer;

    WRITELINE(
        hConsole, *pc, "Proxy Interface Index:                0x%0x",
        *pProxyIfIndex
        );

    pQuery->TypeId = IGMP_PROXY_IF_INDEX_ID;
}


//------------------------------------------------------------------------------
//          _PrintGlobalConfig
//------------------------------------------------------------------------------
VOID
PrintGlobalConfig(
    HANDLE hConsole,
    PCOORD pc,
    PIGMP_MIB_GET_INPUT_DATA pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA pResponse
    ) 
{

    PIGMP_MIB_GLOBAL_CONFIG     pConfig;
    LARGE_INTEGER               llTime;
    static  DWORD               dwCount;
    
    llTime.QuadPart = GetCurrentIgmpTime();
    
    pConfig = (PIGMP_MIB_GLOBAL_CONFIG)pResponse->Buffer;

    WRITELINE2(
        hConsole, *pc, "%d. Seconds since start: %lu",
        ++dwCount, 
        (ULONG)((llTime.QuadPart - g_Info.TimeWhenRtrStarted.QuadPart)/1000)
        );

    WRITELINE(
        hConsole, *pc, "Version:                              %x",
        pConfig->Version
        );

    WRITELINE(
        hConsole, *pc, "Logging Level:                        %d",
        pConfig->LoggingLevel
        );
    WRITELINE(
        hConsole, *pc, "Ras Client Stats kept:                %d",
        pConfig->RasClientStats
        );
    

    pQuery->TypeId = IGMP_GLOBAL_CONFIG_ID;
}


//------------------------------------------------------------------------------
//          _PrintIfConfig
//------------------------------------------------------------------------------
VOID
PrintIfConfig(
    HANDLE                     hConsole,
    PCOORD                     pc,
    PIGMP_MIB_GET_INPUT_DATA   pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA  pResponse
    ) 
{
    PIGMP_MIB_IF_CONFIG     pConfig;
    CHAR                    szIfType[50], szProtoType[50];
    DWORD                   LastIfIndex=0, Count;
    

    pConfig = (PIGMP_MIB_IF_CONFIG)pResponse->Buffer;


    for (Count=0;  Count<pResponse->Count;  Count++) {


        WRITE_NEWLINE(hConsole, *pc);

            
        LastIfIndex = pConfig->IfIndex;


            
        switch (pConfig->IfType) {
        
            case IGMP_IF_NOT_RAS :
                lstrcpy(szIfType, "Permanent"); 
                break;
                
            case IGMP_IF_RAS_ROUTER :
                lstrcpy(szIfType, "Demand-dial (Ras router)"); 
                break;
                
            case IGMP_IF_RAS_SERVER :
                lstrcpy(szIfType, 
                        "LocalWorkstation-dial (Ras server)"); 
                break;

            //ras client config will never be returned    

            // is proxy type.
            default :
                if (IS_IFTYPE_PROXY(pConfig->IfType)) {
                    if (pConfig->IfType&IGMP_IF_NOT_RAS)
                        lstrcpy(szIfType, "Permanent (Igmp Proxy)");
                    else
                        lstrcpy(szIfType, "Demand-dial (Igmp Proxy)");
                }
                else
                    lstrcpy(szIfType, "Unknown type");
                break;
        }


        WRITELINE(
            hConsole, *pc, "Interface Index:                      0x%0x",
            pConfig->IfIndex
            );

        WRITELINE(
            hConsole, *pc, "Interface Ip Address:                 %s",
            INET_NTOA(pConfig->IpAddr)
            );

        WRITELINE(
            hConsole, *pc, "Interface Type:                       %s",
            szIfType
            );
        
        switch (pConfig->IgmpProtocolType) {
        
            case IGMP_ROUTER_V1 :
                lstrcpy(szProtoType, "Igmp Router ver-1"); break;
            case IGMP_ROUTER_V2 :
                lstrcpy(szProtoType, "Igmp Router ver-2"); break;
            case IGMP_ROUTER_V3 :
                lstrcpy(szProtoType, "Igmp Router ver-3"); break;
            case IGMP_PROXY :
            case IGMP_PROXY_V3 :
                lstrcpy(szProtoType, "Igmp Proxy"); break;
            default:
            {
                BYTE    str[40];
                sprintf(str, "Illegal protocol Id: %d", pConfig->IgmpProtocolType);
                lstrcpy(szProtoType, str); 
                break;
            }
        }
        
        WRITELINE(
            hConsole, *pc, "Protocol:                             %s",
            szProtoType
            );


        //
        // No config info for proxy
        //
        if (IS_CONFIG_IGMPPROXY(pConfig)) {

            ;
        }


        //
        // print igmp-router config info
        //
        else {


            WRITELINE(
                hConsole, *pc, "Robustness variable:                  %d",
                pConfig->RobustnessVariable
                );
        
            WRITELINE(
                hConsole, *pc, "Startup query interval:               %d",
                pConfig->StartupQueryInterval
                );

            WRITELINE(
                hConsole, *pc, "Startup query count:                  %d",
                pConfig->StartupQueryCount
                );

            WRITELINE(
                hConsole, *pc, "General query interval:               %d",
                pConfig->GenQueryInterval
                );

            WRITELINE(
                hConsole, *pc, "General query max response time:      %d",
                pConfig->GenQueryMaxResponseTime
                );

            WRITELINE(
                hConsole, *pc, "Last member query interval:           %d (ms)",
                pConfig->LastMemQueryInterval
                );

            WRITELINE(
                hConsole, *pc, "Last member query count:              %d",
                pConfig->LastMemQueryCount
                );

            WRITELINE(
                hConsole, *pc, "Other querier present interval:       %d",
                pConfig->OtherQuerierPresentInterval
                );
        
            WRITELINE(
                hConsole, *pc, "Group membership timeout:             %d",
                pConfig->GroupMembershipTimeout
                );

        } //end if not proxy interface

        //
        // print static groups
        //
        if (pConfig->NumStaticGroups>0) {

            PIGMP_STATIC_GROUP  pStaticGroup;
            DWORD               i;
            PCHAR   StaticModes[3] = {"", "IGMP_HOST_JOIN", "IGMPRTR_JOIN_MGM_ONLY"};
                                    
            WRITELINE(
                hConsole, *pc, "NumStaticGroups:                      %d",
                pConfig->NumStaticGroups
                );
            pStaticGroup = GET_FIRST_IGMP_STATIC_GROUP(pConfig);
            for (i=0;  i<pConfig->NumStaticGroups;  i++,pStaticGroup++) {
                WRITELINE3(
                    hConsole, *pc, "    %d. %-15s  %s",
                    i+1, INET_NTOA(pStaticGroup->GroupAddr), 
                    StaticModes[pStaticGroup->Mode]
                );
            }
        }
                

        pConfig = (PIGMP_MIB_IF_CONFIG) 
                    ((PBYTE)(pConfig) + IGMP_MIB_IF_CONFIG_SIZE(pConfig));

    } //end for loop; print each global config

    
    pQuery->TypeId = IGMP_IF_CONFIG_ID;
    pQuery->IfIndex = LastIfIndex;

    return;
} //end _PrintIfConfig





//------------------------------------------------------------------------------
//          _PrintIfStats
//------------------------------------------------------------------------------
VOID
PrintIfStats(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{
    PIGMP_MIB_IF_STATS          pStats;
    CHAR                        szIfType[50];
    CHAR                        szProtoType[50], szState[100];
    DWORD                       LastIfIndex=0, Count;


    pStats = (PIGMP_MIB_IF_STATS)pResponse->Buffer;


    for (Count=0;  Count<pResponse->Count;  Count++,pStats++) {


        WRITE_NEWLINE(hConsole, *pc);

            
        LastIfIndex = pStats->IfIndex;

            
        switch (pStats->IfType) {
        
            case IGMP_IF_NOT_RAS :
                lstrcpy(szIfType, "Permanent"); 
                break;
                
            case IGMP_IF_RAS_ROUTER :
                lstrcpy(szIfType, "Demand-dial (Ras router)"); 
                break;
                
            case IGMP_IF_RAS_SERVER :
                lstrcpy(szIfType, 
                        "LocalWorkstation-dial (Ras server)"); 
                break;

            case IGMP_IF_RAS_CLIENT :
                lstrcpy(szIfType, 
                        "RemoteWorkstation-dial (Ras client)");
                break;

            // is proxy type.
            default :
                if (IS_IFTYPE_PROXY(pStats->IfType)) {
                    if (pStats->IfType&IGMP_IF_NOT_RAS)
                        lstrcpy(szIfType, "Permanent (Igmp Proxy)");
                    else
                        lstrcpy(szIfType, "Demand-dial (Igmp Proxy)");
                }
                else
                    lstrcpy(szIfType, "Unknown type");
                break;
        }


        WRITELINE(
            hConsole, *pc, "Interface Index:                      0x%0x",
            pStats->IfIndex
            );
            

        WRITELINE(
            hConsole, *pc, "Interface Type:                       %s",
            szIfType
            );

            
        WRITELINE(
            hConsole, *pc, "Interface Ip Address:                 %s",
            INET_NTOA(pStats->IpAddr)
            );



        //
        // print the protocol type
        //
       
        switch (pStats->IgmpProtocolType) {
        
            case IGMP_ROUTER_V1 :
                lstrcpy(szProtoType, "Igmp Router ver-1"); break;
            case IGMP_ROUTER_V2 :
                lstrcpy(szProtoType, "Igmp Router ver-2"); break;
            case IGMP_ROUTER_V3 :
                lstrcpy(szProtoType, "Igmp Router ver-3"); break;
            case IGMP_PROXY :
            case IGMP_PROXY_V3 :
                lstrcpy(szProtoType, "Igmp Proxy"); break;
        
        }
        
        WRITELINE(
            hConsole, *pc, "Protocol:                             %s",
            szProtoType
            );




        //
        // print the state
        //
        {
            PCHAR szBool[2] = {"N", "Y"};
            szState[0] = '\0';
            if (!(pStats->State&IGMP_STATE_BOUND))
                lstrcat(szState, "<NotBound> ");
                
            lstrcat(szState, "<Enabled-By:");
            lstrcat(szState, " Rtrmgr-");
            lstrcat(szState, szBool[(pStats->State&IGMP_STATE_ENABLED_BY_RTRMGR)>0]);
            lstrcat(szState, " Config-");
            lstrcat(szState, szBool[(pStats->State&IGMP_STATE_ENABLED_IN_CONFIG)>0]);
            lstrcat(szState, " MGM-");
            lstrcat(szState, szBool[(pStats->State&IGMP_STATE_ENABLED_BY_MGM)>0]);
            lstrcat(szState, "> ");
            
            if (!IS_IFTYPE_PROXY(pStats->IfType)) {
                if ( (pStats->State&IGMP_STATE_MGM_JOINS_ENABLED)
                        ==IGMP_STATE_MGM_JOINS_ENABLED )
                {
                    lstrcat(szState, "JoinsFwdToMGM-Y");
                }
                else
                    lstrcat(szState, "JoinsFwdToMGM-N");
            }
        }
        
        WRITELINE(
            hConsole, *pc, "If-Status:                            %s",
            szState
            );


        //
        // if state is not both bound & enabled, I am done
        //
        if ((pStats->State&IGMP_STATE_ACTIVATED)!=IGMP_STATE_ACTIVATED)
            continue;

            
        WRITELINE(
                hConsole, *pc, "Uptime:                               %d",
                pStats->Uptime
                );

                
        ///////////////////
        // Stats for proxy
        ///////////////////
        
        if (IS_IFTYPE_PROXY(pStats->IfType)) {
            
            WRITELINE(
                hConsole, *pc, "Num current group members:            %d",
                pStats->CurrentGroupMemberships
                );

            WRITELINE(
                hConsole, *pc, "Num group memberships added:          %d",
                pStats->GroupMembershipsAdded
                );

        }


        ////////////////////////////////////////////////////////////////
        // print igmp-router/ras-server/ras-router/ras client Stats info
        ////////////////////////////////////////////////////////////////
        
        else  {

            //
            // if Not ras client, print these
            //
            
            if (pStats->IfType!=IGMP_IF_RAS_CLIENT) {
            
                //querier or not querier
                
                if (pStats->QuerierState&QUERIER) 
                {

                    WRITELINE(
                        hConsole, *pc, "State:                                %s",
                        "Querier"
                        );


                    // querier ip addr
                    WRITELINE(
                        hConsole, *pc, "Querier Ip Addr:                      %s",
                        INET_NTOA(pStats->QuerierIpAddr)
                        );
                }
                
                else {

                    WRITELINE(
                        hConsole, *pc, "State:                                %s",
                        "Not Querier"
                        );

                    // querier ip addr
                    WRITELINE(
                        hConsole, *pc, "Querier Ip Addr:                      %s",
                        INET_NTOA(pStats->QuerierIpAddr)
                        );

                        
                    // querier present time left
                    
                    WRITELINE(
                        hConsole, *pc, "QuerierPresentTimeLeft:               %d",
                        pStats->QuerierPresentTimeLeft
                        );
                }

                WRITELINE(
                    hConsole, *pc, "LastQuerierChangeTime:                %d",
                    pStats->LastQuerierChangeTime
                    );
    
                if (pStats->V1QuerierPresentTimeLeft) {
                
                    WRITELINE(
                        hConsole, *pc, "V1QuerierPresentTime:                 %d",
                        pStats->V1QuerierPresentTimeLeft
                        );
                }
                
            } //end not ras-client
            


            WRITELINE(
                hConsole, *pc, "Num current group members:            %d",
                pStats->CurrentGroupMemberships
                );

            WRITELINE(
                hConsole, *pc, "Num group memberships added:          %d",
                pStats->GroupMembershipsAdded
                );

            WRITELINE(
                hConsole, *pc, "Num of Igmp packets received:         %d",
                pStats->TotalIgmpPacketsReceived
                );
        
            WRITELINE(
                hConsole, *pc, "Num Igmp-router proto packets recv:   %d",
                pStats->TotalIgmpPacketsForRouter
                );

            WRITELINE(
                hConsole, *pc, "Num general queries received:         %d",
                pStats->GeneralQueriesReceived
                );

            WRITELINE(
                hConsole, *pc, "Num wrong version queries:            %d",
                pStats->WrongVersionQueries
                );

            WRITELINE(
                hConsole, *pc, "Num Joins received:                   %d",
                pStats->JoinsReceived
                );

            WRITELINE(
                hConsole, *pc, "Num leaves received:                  %d",
                pStats->LeavesReceived
                );
        
            WRITELINE(
                hConsole, *pc, "Num wrong checksum packets:           %d",
                pStats->WrongChecksumPackets
                );

            WRITELINE(
                hConsole, *pc, "Num short packets received:           %d",
                pStats->ShortPacketsReceived
                );

            WRITELINE(
                hConsole, *pc, "Num long packets received:            %d",
                pStats->LongPacketsReceived
                );
        
            WRITELINE(
                hConsole, *pc, "Num packets without RtrAlert:         %d",
                pStats->PacketsWithoutRtrAlert
                );
        
                
        } //end print igmp-router/ras-router/ras-server Stats info



    } //end for loop; print each stats info

    
    pQuery->TypeId = IGMP_IF_STATS_ID;
    pQuery->IfIndex = LastIfIndex;
    
    return;
    
}//end _PrintIfStats


//------------------------------------------------------------------------------
//          _PrintIfBinding
//------------------------------------------------------------------------------
VOID
PrintIfBinding(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{

    DWORD                   NumIfs, NumAddrs, NumClients, LastIfIndex;
    CHAR                    szAddr[64];
    PIGMP_MIB_IF_BINDING    pib;
    PIGMP_MIB_IP_ADDRESS    paddr;
    PDWORD                  pRasClientAddr;
    PBYTE                   ptr; //pointer to next binding


    ptr = pResponse->Buffer;
    
    if (pResponse->Count<=0) //prefast
        return;

    for (NumIfs=0;  NumIfs<pResponse->Count;  NumIfs++) {
    
        pib = (PIGMP_MIB_IF_BINDING)ptr;

        WRITE_NEWLINE(hConsole, *pc);
        
        WRITELINE(
            hConsole, *pc, "Interface Index:                      0x%0x",
            pib->IfIndex
        );


        WRITELINE(
            hConsole, *pc, "Address Count:                        %d",
            pib->AddrCount
        );



        //
        // Not ras client
        //
        if (pib->IfType!=IGMP_IF_RAS_CLIENT) {
        
            paddr = IGMP_BINDING_FIRST_ADDR(pib);
            
            for (NumAddrs=0;  NumAddrs<pib->AddrCount;  NumAddrs++,paddr++) {
                INET_COPY(szAddr, paddr->IpAddr);
                
                lstrcat(szAddr, " - ");
                INET_CAT(szAddr, paddr->SubnetMask);
                WRITELINE(
                    hConsole, *pc, "Address Entry:                        %s",
                    szAddr
                    );

                INET_COPY(szAddr, paddr->IpAddr);
                lstrcat(szAddr, " - ");
                INET_CAT(szAddr, paddr->SubnetMask);
                WRITELINE(
                    hConsole, *pc, "Address Entry:                        %s",
                    szAddr
                    );
            }


            //Set pointer to the next Interface binding
            ptr = (PBYTE) (paddr);

        } //end if not ras client



        //
        // Ras client. Print address of ras server, followed by the clients
        //
        else {

            // print ras server address
        
            paddr = IGMP_BINDING_FIRST_ADDR(pib);
            INET_COPY(szAddr, paddr->IpAddr);
            lstrcat(szAddr, " - ");
            INET_CAT(szAddr, paddr->SubnetMask);
            WRITELINE(
                hConsole, *pc, "Ras server Addr                           %s",   
                szAddr
                );



            // print addresses of ras clients
            
            pRasClientAddr = (PDWORD)(paddr+1);

            for (NumClients= 0; NumClients<pib->AddrCount-1; NumClients++,pRasClientAddr++) {
                WRITELINE(
                    hConsole, *pc, "Ras client Addr:                  %s",
                    INET_NTOA(*pRasClientAddr)
                    );
            }


            //Set pointer to the next Interface binding
            ptr = (PBYTE) (pRasClientAddr);
        }
    
            
    } //end print statistics of the interface
    
    
    LastIfIndex = pib->IfIndex;

    pQuery->TypeId = IGMP_IF_BINDING_ID;
    pQuery->IfIndex = LastIfIndex;

    return;
    
}//end _PrintIfBinding



//------------------------------------------------------------------------------
//          _PrintIfGroupsList
//------------------------------------------------------------------------------

VOID
PrintIfGroupsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{
    DWORD                       i, j, LastIfIndex, Flags;
    CHAR                        szAddr[64], szFlags[4];
    PIGMP_MIB_IF_GROUPS_LIST    pIfGroupList;
    PBYTE                       ptr;
    PMIB_GROUP_INFO_V3          pGIInfo;
    PMIB_PROXY_GROUP_INFO_V3    pGIProxyInfo;
    BOOL                        bProxy;
    DWORD                       bVer3;

    
    ptr = pResponse->Buffer;
    

    pIfGroupList = (PIGMP_MIB_IF_GROUPS_LIST) ptr;
    bProxy = IS_IFTYPE_PROXY(pIfGroupList->IfType);
    bVer3 = pResponse->Flags & IGMP_ENUM_FORMAT_IGMPV3;


    if (pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_BEGIN) {
    
        WRITE_NEWLINE(hConsole, *pc);
        
        if (bProxy) {
            WRITELINE(
                hConsole, *pc, "%s",
                "ProxyInterface"
            );
        }
        
        WRITELINE(
            hConsole, *pc, "Interface Index: %0x",
            pIfGroupList->IfIndex
        );

        if (pIfGroupList->NumGroups!=0) {
            if (bProxy) {
                WRITELINE(
                    hConsole, *pc, "   %s",
                    "GroupAddr             UpTime Flags"
                );
            }
            else {
                if (!bVer3) {
                    WRITELINE(
                        hConsole, *pc, "   %s",
                        "(Ver)GroupAddr       LastReporter      (Up/Exp)Time Flags V1Host(TimeLeft)"
                    );
                }
                else {
                    WRITELINE(
                        hConsole, *pc, "%s",
                        "(Ver)  GroupAddr            (Up/Exp)Time   Flags V1Host V2Host"
                    );
                }
            }
        }

    }
    
    //
    // print all groups which are members on this interface
    //
    if (bProxy)
        pGIProxyInfo = (PMIB_PROXY_GROUP_INFO_V3)pIfGroupList->Buffer;        
    else
        pGIInfo = (PMIB_GROUP_INFO_V3)pIfGroupList->Buffer;          
    

    for (j=0;  j<pIfGroupList->NumGroups;  j++) {

        Flags = (bProxy)? pGIProxyInfo->Flags: pGIInfo->Flags;
        sprintf(szFlags, "   ");
        
        if (Flags&IGMP_GROUP_TYPE_NON_STATIC)
            szFlags[0] = 'L';
        if (Flags&IGMP_GROUP_TYPE_STATIC)
            szFlags[1] = 'S';
        if (Flags&IGMP_GROUP_FWD_TO_MGM)
            szFlags[2] = 'F';

            
        //
        // proxy interface
        //
        if (bProxy) {

            WRITELINE3(
                hConsole, *pc, "   %-15s  %10d  %s",
                INET_NTOA(pGIProxyInfo->GroupAddr), pGIProxyInfo->GroupUpTime, szFlags
            );

            if (bVer3) {
                DWORD SrcCnt;
                CHAR JoinMode = ' ';
                CHAR JoinModeIntended = ' ';
                
                for (SrcCnt=0;  SrcCnt<pGIProxyInfo->NumSources;  SrcCnt++) {
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & IGMP_GROUP_ALLOW)
                        JoinMode = 'A';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & IGMP_GROUP_BLOCK)
                        JoinMode = 'B';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & IGMP_GROUP_NO_STATE)
                        JoinMode = '-';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & (IGMP_GROUP_ALLOW<<4))
                        JoinModeIntended = 'A';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & (IGMP_GROUP_BLOCK<<4))
                        JoinModeIntended = 'B';
                    if (pGIProxyInfo->Sources[SrcCnt].Flags & (IGMP_GROUP_NO_STATE<<4))
                        JoinModeIntended = '-';

                    WRITELINE3(
                        hConsole, *pc, "   - %-15s:%c:%c",
                        INET_NTOA(pGIProxyInfo->Sources[SrcCnt].Source),
                        JoinMode,JoinModeIntended
                    );
                }
            }
        }
        
        //
        // non-proxy interface
        //
        else if (!bProxy && !bVer3){
        
            CHAR    szGroupAddr[64], szLastReporter[64], szExpTime[50];
            DWORD   GroupVersion = (pGIInfo->V1HostPresentTimeLeft)?1:2;
            CHAR    szV1HostPresent[10];
            
            INET_COPY(szGroupAddr, pGIInfo->GroupAddr);
            INET_COPY(szLastReporter, pGIInfo->LastReporter);
            
            szV1HostPresent[0] = 'N'; szV1HostPresent[1] = '\0';
            if (pGIInfo->V1HostPresentTimeLeft!=0)
                sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);
                
            sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);
            if ( (Flags&IGMP_GROUP_TYPE_STATIC) 
                    && !(Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                sprintf(szExpTime, "inf");
                sprintf(szLastReporter, "      -");
            }

            WRITELINE7(
                hConsole, *pc, "[%d]   %-13s %-15s %7d|%3s   %3s    %-10s",
                GroupVersion, szGroupAddr, szLastReporter, pGIInfo->GroupUpTime, 
                    szExpTime, szFlags, szV1HostPresent
            );
        }
        else if (!bProxy && bVer3) {

            CHAR    szGroupAddr[64], szExpTime[50], szFilter[10];
            CHAR    szV1HostPresent[10], szV2HostPresent[10];
            DWORD   GroupVersion = pGIInfo->Version, SrcCnt=0;
            
            INET_COPY(szGroupAddr, pGIInfo->GroupAddr);
            
            szV1HostPresent[0] = szV2HostPresent[0] = 'N';
            szV1HostPresent[1] = szV2HostPresent[1] = '\0';
            
            if (pGIInfo->V1HostPresentTimeLeft!=0)
                sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);
            if (pGIInfo->V2HostPresentTimeLeft!=0)
                sprintf(szV2HostPresent, "%d", pGIInfo->V2HostPresentTimeLeft);


            if (GroupVersion==3 && pGIInfo->FilterType==INCLUSION)
                sprintf(szExpTime, "-na");
            else //if (pGIInfo->FilterType==exclusion)
                sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);


            if ( (Flags&IGMP_GROUP_TYPE_STATIC) 
                    && !(Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                sprintf(szExpTime, "inf");
            }
            if (GroupVersion==3) {
                sprintf(szFilter, "%s", pGIInfo->FilterType==INCLUSION? "[IN]" : 
                        "[EX]");
            }
            else
                strcpy(szFilter, "    ");
                
            WRITELINE8(
                hConsole, *pc, "[%d]   %-13s%s    %7d|%3s   %3s    %5s    %-5s",
                GroupVersion, szGroupAddr, szFilter, pGIInfo->GroupUpTime, 
                    szExpTime, szFlags, szV1HostPresent, szV2HostPresent
            );

            if (GroupVersion==3) {
                for (SrcCnt=0;  SrcCnt<pGIInfo->NumSources;  SrcCnt++) {
                    if (pGIInfo->Sources[SrcCnt].SourceExpiryTime==~0)
                        sprintf(szExpTime, "%s", "inf");
                    else {
                        sprintf(szExpTime, "%d", 
                            pGIInfo->Sources[SrcCnt].SourceExpiryTime/1000);
                    }
                    WRITELINE3(
                        hConsole, *pc, "    - %-13s        %7d|%-s",
                        INET_NTOA(pGIInfo->Sources[SrcCnt].Source),
                        pGIInfo->Sources[SrcCnt].SourceUpTime,
                        szExpTime
                    );
                }
            }
        }
        

        //
        // increment pGIInfo/pGIProxyInfo
        //
        if (bProxy) {
            if (bVer3)
                pGIProxyInfo = (PMIB_PROXY_GROUP_INFO_V3)
                                    &pGIProxyInfo->Sources[pGIProxyInfo->NumSources];
            else
                pGIProxyInfo = (PMIB_PROXY_GROUP_INFO_V3)
                                    ((PMIB_PROXY_GROUP_INFO)pGIProxyInfo+1);
        }
        else {
            if (bVer3) 
                pGIInfo = (PMIB_GROUP_INFO_V3) 
                            &pGIInfo->Sources[pGIInfo->NumSources];
            else
                pGIInfo = (PMIB_GROUP_INFO_V3) ((PMIB_GROUP_INFO)pGIInfo+1);
        }
    }
    
    
    pQuery->TypeId = IGMP_IF_GROUPS_LIST_ID;
    pQuery->IfIndex = pIfGroupList->IfIndex;

    return;
    
}//end _PrintIfGroupsList



//------------------------------------------------------------------------------
//          _PrintGroupIfsList
//------------------------------------------------------------------------------
VOID
PrintGroupIfsList(
    HANDLE                      hConsole,
    PCOORD                      pc,
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse
    ) 
{
    DWORD                       i, j, LastGroupAddr;
    CHAR                        szGroupAddr[22];
    PIGMP_MIB_GROUP_IFS_LIST    pGroupIfsList;
    PMIB_GROUP_INFO_V3          pGIInfo;    
    PBYTE                       ptr;
    DWORD                       bVer3;


    ptr = pResponse->Buffer;
    bVer3 = pResponse->Flags & IGMP_ENUM_FORMAT_IGMPV3;

    if (pResponse->Count<=0) //prefast
        return;
        
    for (i=0;  i<pResponse->Count;  i++) {
    
        pGroupIfsList = (PIGMP_MIB_GROUP_IFS_LIST) ptr;
    
        INET_COPY(szGroupAddr, pGroupIfsList->GroupAddr);
        

        //
        // print all GIs which are members on this group
        //
        pGIInfo = (PMIB_GROUP_INFO_V3)pGroupIfsList->Buffer;

        for (j=0;  j<pGroupIfsList->NumInterfaces;  j++) {
            CHAR    szIpAddr[16], szLastReporter[16], szV1Host[4], 
                    szV1HostTimeLeft[10], szFlags[5], szGroupExpTime[10];

                    
            sprintf(szFlags, "   ");        
            if (pGIInfo->Flags&IGMP_GROUP_TYPE_NON_STATIC)
                szFlags[0] = 'L';
            if (pGIInfo->Flags&IGMP_GROUP_TYPE_STATIC)
                szFlags[1] = 'S';
            if (pGIInfo->Flags&IGMP_GROUP_FWD_TO_MGM)
                szFlags[2] = 'F';
                
            INET_COPY(szIpAddr, pGIInfo->IpAddr);

            if (!bVer3){

                CHAR    szLastReporter[64], szExpTime[50];
                DWORD   GroupVersion = (pGIInfo->V1HostPresentTimeLeft)?1:2;
                CHAR    szV1HostPresent[10];

                INET_COPY(szGroupAddr, pGIInfo->GroupAddr);
                INET_COPY(szLastReporter, pGIInfo->LastReporter);

                szV1HostPresent[0] = '\0';
                if (pGIInfo->V1HostPresentTimeLeft!=0)
                    sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);

                sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);
                if ( (pGIInfo->Flags&IGMP_GROUP_TYPE_STATIC)
                        && !(pGIInfo->Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                    sprintf(szExpTime, "inf");
                    sprintf(szLastReporter, "      -");
                }

                WRITELINE9(
                    hConsole, *pc,
                    "[%d]   %-12s      %7d|%-3s   %3s  <%d:%-14s> %-12s %5s",
                    GroupVersion, szGroupAddr,
                    pGIInfo->GroupUpTime, szExpTime, szFlags,
                    pGIInfo->IfIndex, szIpAddr, 
                    szLastReporter, szV1HostPresent
                );
            }
            else {

                CHAR    szGroupAddr[64], szExpTime[50], szFilter[10];
                CHAR    szV1HostPresent[10], szV2HostPresent[10];
                DWORD   GroupVersion = pGIInfo->Version, SrcCnt=0;

                INET_COPY(szGroupAddr, pGroupIfsList->GroupAddr);

                szV1HostPresent[0] = szV2HostPresent[0] = 'N';
                szV1HostPresent[1] = szV2HostPresent[1] = '\0';
                
                if (pGIInfo->V1HostPresentTimeLeft!=0)
                    sprintf(szV1HostPresent, "%d", pGIInfo->V1HostPresentTimeLeft);
                if (pGIInfo->V2HostPresentTimeLeft!=0)
                    sprintf(szV2HostPresent, "%d", pGIInfo->V2HostPresentTimeLeft);

                if (GroupVersion==3 && pGIInfo->FilterType==INCLUSION)
                    sprintf(szExpTime, "-na");
                else //if (pGIInfo->FilterType==exclusion)
                    sprintf(szExpTime, "%d", pGIInfo->GroupExpiryTime);

                if ( (pGIInfo->Flags&IGMP_GROUP_TYPE_STATIC)
                        && !(pGIInfo->Flags&IGMP_GROUP_TYPE_NON_STATIC) ) {
                    sprintf(szExpTime, "inf");
                }
                if (GroupVersion==3) {
                    sprintf(szFilter, "%s", pGIInfo->FilterType==INCLUSION? "[IN]" :
                            "[EX]");
                }
                else
                    strcpy(szFilter, "    ");

                WRITELINE10(
                    hConsole, *pc,
                    "[%d]   %-12s%s  %7d|%-3s   %3s   <%d:%-14s>  %20s   %5s",
                    GroupVersion, szGroupAddr, szFilter,
                    pGIInfo->GroupUpTime, szExpTime, szFlags, 
                    pGIInfo->IfIndex, szIpAddr,
                    szV1HostPresent, szV2HostPresent
                );

                if (GroupVersion==3) {
                    for (SrcCnt=0;  SrcCnt<pGIInfo->NumSources;  SrcCnt++) {
                        if (pGIInfo->Sources[SrcCnt].SourceExpiryTime==~0)
                            sprintf(szExpTime, "%s", "inf");
                        else {
                            sprintf(szExpTime, "%d", 
                                pGIInfo->Sources[SrcCnt].SourceExpiryTime/1000);
                        }
                        WRITELINE3(
                            hConsole, *pc, "    - %-12s      %7d|%s",
                            INET_NTOA(pGIInfo->Sources[SrcCnt].Source),
                            pGIInfo->Sources[SrcCnt].SourceUpTime,
                            szExpTime
                        );
                    }
                }
            }

            if (bVer3)
                pGIInfo = (PMIB_GROUP_INFO_V3)
                            &pGIInfo->Sources[pGIInfo->NumSources];
            else
                pGIInfo = (PMIB_GROUP_INFO_V3) ((PMIB_GROUP_INFO)pGIInfo+1);
                
        } //for loop: end print all GIs

        ptr = (PBYTE)pGIInfo;

    }
    
    LastGroupAddr= pGroupIfsList->GroupAddr;

    
    pQuery->TypeId = IGMP_GROUP_IFS_LIST_ID;
    pQuery->GroupAddr = LastGroupAddr;

    return;
    
}//end _PrintGroupIfsList


#endif MIB_DEBUG




DWORD
ListLength(
    PLIST_ENTRY pHead
    )
{
    DWORD Len=0;
    PLIST_ENTRY ple;
    
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink,Len++)
        ;
    return Len;
}


//------------------------------------------------------------------------------
//          _MibGet
//
// Called by an admin (SNMP) utility.  It actually passes through the
// IP Router Manager, but all that does is demux the call to the
// desired routing protocol
//
// Calls: _MibGetInternal() with GETMODE_EXACT.
// Locks: Takes no locks. _MibGetInternal() will get the locks it requires
//------------------------------------------------------------------------------
DWORD
APIENTRY
MibGet(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error=NO_ERROR;
    PIGMP_MIB_GET_INPUT_DATA    pQuery;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }



    Trace1(MIB, "entering _MibGet(): dwInputSize(%d)", dwInputSize);


    if ( (pInputData == NULL)
        || (dwInputSize < sizeof(IGMP_MIB_GET_INPUT_DATA))
        || (pdwOutputSize == NULL)
       ) 
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {

        pQuery = (PIGMP_MIB_GET_INPUT_DATA)pInputData;

        // with GETMODE_EXACT you can get only one
        pQuery->Count = 1;
        
        pResponse = (PIGMP_MIB_GET_OUTPUT_DATA)pOutputData;

        Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, GETMODE_EXACT);

    }


    Trace1(MIB, "leaving _MibGet(): %d", Error);
    LeaveIgmpApi();

    return Error;
}


//------------------------------------------------------------------------------
//        MibGetFirst
//
// Calls: _MibGetInternal() with GETMODE_FIRST
// Locks: No locks taken here. _MibGetInternal() takes the locks it requires
//------------------------------------------------------------------------------
DWORD
APIENTRY
MibGetFirst(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error=NO_ERROR;
    PIGMP_MIB_GET_INPUT_DATA    pQuery;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;


    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    Trace4(MIB, "entering _MibGetFirst(): dwInputSize(%d) pInputData(%08x)"
            "pdwOutputSize(%08x) pOutputData(%08x)",
            dwInputSize, pInputData, pdwOutputSize, pOutputData);


    if ( (pInputData == NULL) 
        || (dwInputSize < sizeof(IGMP_MIB_GET_INPUT_DATA))
        || (pdwOutputSize == NULL)
        )
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        pQuery = (PIGMP_MIB_GET_INPUT_DATA)pInputData;
        if (pQuery->Count<=0)
            pQuery->Count = 1;

        pResponse = (PIGMP_MIB_GET_OUTPUT_DATA)pOutputData;

        Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, GETMODE_FIRST);
    }


    Trace1(MIB, "leaving _MibGetFirst: %d", Error);
    LeaveIgmpApi();

    return Error;
}



//------------------------------------------------------------------------------
//         _MibGetNext
//
// This call returns the entry in the table AFTER the one specified in the input.
// If the end of the table being queried has been reached, this function will
// return the FIRST entry from the NEXT table, where "NEXT" here means the
// table whose ID is one greater than the ID passed in.
// In any case, this function writes the required size to pdwOutputSize and
// writes the ID of the object that WOULD have been returned into the output
// buffer.
//
// Calls:
//      _MibGetInternal() with GETMODE_NEXT. If end of table reached, calls
//      _MibGetInternal() again with GETMODE_FIRST for the next table.
//------------------------------------------------------------------------------
DWORD
APIENTRY
MibGetNext(
    IN     DWORD  dwInputSize,
    IN     PVOID  pInputData,
    IN OUT PDWORD pdwOutputSize,
       OUT PVOID  pOutputData
    )
{
    DWORD                       Error = NO_ERROR;
    DWORD                       dwOutSize = 0, dwBufSize = 0;
    PIGMP_MIB_GET_INPUT_DATA    pQuery;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;



    if (!EnterIgmpApi()) { return ERROR_CAN_NOT_COMPLETE; }

    Trace4(MIB, "entering _MibGetNext(): dwInputSize(%d) pInputData(%08x) "
            "pdwOutputSize(%08x)  pOutputData(%08x)",
            dwInputSize, pInputData, pdwOutputSize, pOutputData);



    if (pInputData == NULL ||
        dwInputSize < sizeof(IGMP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {

        pQuery = (PIGMP_MIB_GET_INPUT_DATA)pInputData;
        pResponse = (PIGMP_MIB_GET_OUTPUT_DATA)pOutputData;
        if (pQuery->Count<=0)
            pQuery->Count = 1;
            
        dwOutSize = *pdwOutputSize;

        Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, GETMODE_NEXT);


        if ((Error==ERROR_NO_MORE_ITEMS) && (pQuery->Flags&IGMP_ENUM_ALL_TABLES) )
        {

            //
            // need to wrap to the first entry in the next table,
            // if there is a next table
            //
            *pdwOutputSize = dwOutSize;

            //
            // wrap to next table by incrementing the type ID
            //
            do {
                ++pQuery->TypeId;

                Error = MibGetInternal(pQuery, pResponse, pdwOutputSize, 
                                        GETMODE_FIRST);
                
            } while ( (Error==ERROR_INVALID_PARAMETER)&&(pQuery->TypeId<=IGMP_LAST_TABLE_ID) );
            
            --pQuery->TypeId;
        }

    }


    Trace1(MIB, "leaving _MibGetNext(): %d", Error);

    LeaveIgmpApi();

    return Error;
}


//------------------------------------------------------------------------------
// Function:    _MibGetInternal
//
// This handles the actual structure access required to read MIB data.
// Each table supported by IGMP supports three modes of querying;
// EXACT, FIRST, and NEXT, which correspond to the functions _MibGet(),
// _MibGetFirst(), and _MibGetNext() respectively.
//------------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode
    ) 
{
    DWORD     Error = NO_ERROR, dwBufferSize;

    
    //
    // first we use pdwOutputSize to compute the size of the buffer
    // available for storing returned structures (the size of Buffer)
    //

    if (pResponse == NULL) {
        dwBufferSize = 0;
    }
    else {
        if (*pdwOutputSize < sizeof(IGMP_MIB_GET_OUTPUT_DATA)) {
            dwBufferSize = 0;
        }
        else {
            dwBufferSize = *pdwOutputSize
                            - sizeof(IGMP_MIB_GET_OUTPUT_DATA) + 1;

            //kslksl
            if (dwBufferSize>150)
                dwBufferSize -= 150;
        }
    }

    *pdwOutputSize = 0;


    // set flag for ras stats if pQuery has it and config supports it
    if (pResponse!=NULL) {
        pResponse->Flags = 0;
        if ( (pQuery->Flags&IGMP_ENUM_FOR_RAS_CLIENTS) 
            && (g_Config.RasClientStats) ) 
        {
            pResponse->Flags |= IGMP_ENUM_FOR_RAS_CLIENTS;
        }
    }
    
    
    //
    // determine which type of data is to be returned
    //

    switch (pQuery->TypeId) {

    case IGMP_GLOBAL_STATS_ID: 
    {

        //
        // there is only one global config object,
        // so GETMODE_NEXT will return ERROR_NO_MORE_ITEMS
        //

        if (pResponse!=NULL) 
            pResponse->TypeId = IGMP_GLOBAL_STATS_ID; 

        if (dwGetMode == GETMODE_NEXT) {
            Error = ERROR_NO_MORE_ITEMS;
            break;
        }

        *pdwOutputSize = sizeof(IGMP_MIB_GLOBAL_STATS);


        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER; 
            break; 
        }


        // make sure that the buffer size is big enough
        
        if (dwBufferSize < sizeof(IGMP_MIB_GLOBAL_STATS)) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        // set the values
        
        else {

            PIGMP_MIB_GLOBAL_STATS   pGlobalStats;

            pGlobalStats = (PIGMP_MIB_GLOBAL_STATS)pResponse->Buffer;


            pGlobalStats->CurrentGroupMemberships 
                    = g_Info.CurrentGroupMemberships;
                    
            pGlobalStats->GroupMembershipsAdded
                    = g_Info.GroupMembershipsAdded;
                                
        }

        pResponse->Count = 1;
        
        break;
        
    }//end case IGMP_GLOBAL_STATS_ID


    case IGMP_GLOBAL_CONFIG_ID: {

        //
        // there is only one global config object,
        // so GETMODE_NEXT will return ERROR_NO_MORE_ITEMS
        //

        if (pResponse!=NULL) 
            pResponse->TypeId = IGMP_GLOBAL_CONFIG_ID; 

        if (dwGetMode == GETMODE_NEXT) {
            Error = ERROR_NO_MORE_ITEMS;
            break;
        }

        *pdwOutputSize = sizeof(IGMP_MIB_GLOBAL_CONFIG);


        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER; 
            break; 
        }

        if (dwBufferSize < sizeof(IGMP_MIB_GLOBAL_CONFIG)) {
            Error = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
        
            CopyMemory(pResponse->Buffer, &g_Config,
                        sizeof(IGMP_MIB_GLOBAL_CONFIG));
        }


        pResponse->Count = 1;

        break;
            
    } //end case IGMP_GLOBAL_CONFIG_ID


    case IGMP_PROXY_IF_INDEX_ID :
    {
        //
        // there can be only one proxy interface.
        // so GETMODE_NEXT will return ERROR_NO_MORE_ITEMS
        //

        if (pResponse!=NULL) 
            pResponse->TypeId = IGMP_PROXY_IF_INDEX_ID; 

        if (dwGetMode == GETMODE_NEXT) {
            Error = ERROR_NO_MORE_ITEMS;
            break;
        }

        *pdwOutputSize = sizeof(DWORD);


        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER; 
            break; 
        }


        // make sure that the buffer size is big enough
        
        if (dwBufferSize < sizeof(DWORD)) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        // set the values
        
        else {

            DWORD  *pProxyIndex;

            pProxyIndex = (DWORD*)pResponse->Buffer;

            *pProxyIndex = g_ProxyIfIndex;                                
        }

        pResponse->Count = 1;
        
        break;

    } //end case IGMP_PROXY_IF_INDEX_ID


    
    case IGMP_IF_BINDING_ID :
    {

        Error = MibGetInternalIfBindings(pQuery, pResponse, pdwOutputSize, 
                                        dwGetMode, dwBufferSize);
        
        break;
    }


    case IGMP_IF_STATS_ID: {
        //
        // set the size needed. It will be set again at the end to the 
        // exact size used.
        //
            
        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        Error = MibGetInternalIfStats(pQuery, pResponse, pdwOutputSize, dwGetMode,
                                dwBufferSize);
        
        break;
        
    } //end case IGMP_IF_STATS_ID



    case IGMP_IF_CONFIG_ID: 
    {

        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }


        Error = MibGetInternalIfConfig(pQuery, pResponse, pdwOutputSize, 
                                dwGetMode, dwBufferSize);

        break;
        
    } //end case IGMP_IF_CONFIG_ID
    

    // I cant get the list of groups for a RAS server interface
    
    case IGMP_IF_GROUPS_LIST_ID :
    {
        PIGMP_MIB_IF_GROUPS_LIST pIfGroupList;

        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        while (1) {
            
            Error = MibGetInternalIfGroupsInfo(pQuery, pResponse, pdwOutputSize, 
                                            dwGetMode, dwBufferSize);

            if ( (Error!=NO_ERROR) || (pResponse==NULL) )
                break;
                
            pIfGroupList = (PIGMP_MIB_IF_GROUPS_LIST)pResponse->Buffer;

            if ( (pIfGroupList->NumGroups==0)
                && (pQuery->Flags&IGMP_ENUM_ALL_INTERFACES_GROUPS)
                && (pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_END)
                && !(pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_BEGIN)
                && !(pQuery->Flags&IGMP_ENUM_INTERFACE_TABLE_CONTINUE) )
            {
                continue;
            }
            else
                break;
        }
        
        break;
        
    } //end case IGMP_IF_GROUPS_LIST_ID
                        
       
    case IGMP_GROUP_IFS_LIST_ID :
    {
        if (pQuery->Count==0) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }
        
        Error = MibGetInternalGroupIfsInfo(pQuery, pResponse, pdwOutputSize, 
                                        dwGetMode, dwBufferSize);

        break;
        
    } //end  case IGMP_GROUP_IFS_LIST_ID


    // set this for group statistics        ERROR_NO_MORE_ITEMS
    default: {
  
        Error = ERROR_INVALID_PARAMETER;
    }
    
    } //end switch


    if (pdwOutputSize)
        *pdwOutputSize += sizeof(IGMP_MIB_GET_OUTPUT_DATA);

    //kslksl
    if (pdwOutputSize && Error==ERROR_INSUFFICIENT_BUFFER)
        *pdwOutputSize = *pdwOutputSize+500;

    
    return Error;
    
} //_MibGetInternal                       


    
//------------------------------------------------------------------------------
//              MibGetInternalIfBindings
//
// Returns the binding info of pQuery->Count number of interfaces.
//
//Locks: 
//  Takes the IfLists lock so that the InterfaceList does not change in between.
//  It also prevents the bindings from being changed, as (Un)Bind If takes this lock.
//------------------------------------------------------------------------------

DWORD
MibGetInternalIfBindings (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    ) 
{
    PIF_TABLE_ENTRY             pite;
    PIGMP_MIB_IF_BINDING        pBindingDst;
    PIGMP_IF_BINDING            pBindingSrc;
    DWORD                       dwSize, dwSizeCur=0, dwCount, Error=NO_ERROR;

    
    Trace0(MIB, "Entering _MibGetInternalIfBinding");

    if (pResponse!=NULL) { 
        pResponse->TypeId = IGMP_IF_BINDING_ID; 
        pBindingDst = (PIGMP_MIB_IF_BINDING)pResponse->Buffer;
    }



    ACQUIRE_IF_LIST_LOCK("_MibGetInternalBindings");


    
    for (dwCount=0, dwSize=0;  dwCount<pQuery->Count;  ) {
        //
        // retrieve the interface whose binding is to be read
        //

        pite = GetIfByListIndex(pQuery->IfIndex, dwGetMode, &Error);        

        //
        // if the interface was found, it may mean that the index
        // specified was invalid, or it may mean that a GETMODE_NEXT
        // retrieval was attempted on the last interface, in which case
        // ERROR_NO_MORE_ITEMS would have been returned.
        //

        if (pite == NULL) {
         
            if (dwCount>0) 
                Error = NO_ERROR;
                
            // count==0
            else {
                if (Error == NO_ERROR)
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }

            break; //from for loop
        }


        // dont have to take the interface lock, as IfLists lock is
        // taken before bindings are changed.


        //
        // compute the size of the interface binding retrieved,
        // and write it over the caller's supplied size
        //

        pBindingSrc = pite->pBinding;
        dwSizeCur = (pBindingSrc
                        ? sizeof(IGMP_MIB_IF_BINDING)
                            +pBindingSrc->AddrCount*(sizeof(IGMP_MIB_IP_ADDRESS))
                        : sizeof(IGMP_MIB_IF_BINDING));
                    
         


        //
        // if no buffer was specified, indicate one should be allocated
        //

        if (pResponse == NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break; //for loop
        }



        //
        // if the buffer is not large enough,
        // indicate that it should be enlarged
        //

        if (dwBufferSize < dwSize + dwSizeCur) {
            if (dwCount==0)
                Error = ERROR_INSUFFICIENT_BUFFER;

            break; //from for loop
        }


        //
        // copy the binding
        //

        if (pBindingSrc!=NULL) {

            pBindingDst->AddrCount = pBindingSrc->AddrCount;

            CopyMemory(pBindingDst+1, pBindingSrc+1, 
                pBindingSrc->AddrCount*(sizeof(IGMP_MIB_IP_ADDRESS)));
        }
        
        else {
            pBindingDst->AddrCount = 0;
        }


        pBindingDst->IfIndex = pite->IfIndex;
        pBindingDst->IfType = GET_EXTERNAL_IF_TYPE(pite);

        GET_EXTERNAL_IF_STATE(pite, pBindingDst->State);

        pQuery->IfIndex = pite->IfIndex;
        pQuery->RasClientAddr = 0;

        dwCount++;
        dwSize += dwSizeCur;
        pBindingDst = (PIGMP_MIB_IF_BINDING) ((PBYTE)pBindingDst + dwSizeCur);


        // if GetMode==GETMODE_FIRST change it to GETMODE_NEXT.
        if (dwGetMode==GETMODE_FIRST) 
            dwGetMode = GETMODE_NEXT; 

    }//end for loop

    //set size if bindings have been copied. else it has already been set
    if (dwCount>0) {
        *pdwOutputSize = dwSize;
    } 
    else {
        *pdwOutputSize = dwSizeCur;
    }

    
    if (pResponse!=NULL) {
        pResponse->Count = dwCount;
    }


    RELEASE_IF_LIST_LOCK("_MibGetInternalBindings");


    Trace0(MIB, "Leaving _MibGetInternalIfBinding");
    return Error;
    
} //end _MibGetInternalIfBindings


//------------------------------------------------------------------------------
//              _MibGetInternalGroupIfsInfo
//------------------------------------------------------------------------------
DWORD
MibGetInternalGroupIfsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    ) 
{
    LONGLONG                    llCurTime = GetCurrentIgmpTime();
    BOOL                        bRasTableLock=FALSE, bGroupBucketLock=FALSE;
    PIGMP_MIB_GROUP_IFS_LIST    pHeader;
    PMIB_GROUP_INFO_V3          pGIInfo;
    PGI_ENTRY                   pgie;
    PLIST_ENTRY                 pHead, ple;
    DWORD                       dwSize, dwCurSize, Error=NO_ERROR, dwCount, dwNumIfs, i;
    DWORD                       PrevGroup, Group, dwNumIfsCopied;
    PRAS_TABLE_ENTRY            prte;
    PRAS_TABLE                  prt, prtOld;
    PGROUP_TABLE_ENTRY          pge;
    BOOL                        bEnumV3;

    //Trace3(MEM, "_MibGetInternalGroupIfsInfo buffer: %0x -> %0x: %d", 
    //(DWORD)pResponse->Buffer, ((DWORD)pResponse->Buffer)+dwBufferSize, dwBufferSize);//deldel
    
    Trace0(MIB, "Entering _MibGetInternalGroupIfsInfo()");

    bEnumV3 = pQuery->Flags & IGMP_ENUM_SUPPORT_FORMAT_IGMPV3;
    
    //
    // The data returned for each Interface is variable length
    //
    if (pResponse!=NULL) {
        pResponse->TypeId = IGMP_GROUP_IFS_LIST_ID;
        pHeader = (PIGMP_MIB_GROUP_IFS_LIST) pResponse->Buffer;

        //
        //  if GETMODE_FIRST: merge the new and main group lists
        //
        if (dwGetMode==GETMODE_FIRST) {
        
            ACQUIRE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");
            MergeGroupLists();
            RELEASE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");
        }
    }

    
    PrevGroup = pQuery->GroupAddr;
    
    for (dwCount=0, dwSize=0;  dwCount<pQuery->Count;  ) {

        ACQUIRE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");
        bRasTableLock = FALSE;

        //
        // retrieve the groups whose information is to be retrieved
        //
        pge = GetGroupByAddr(PrevGroup, dwGetMode, &Error);

        if (pge == NULL) {

            if (dwCount>0)
                Error = NO_ERROR;
            else {
                if (Error==NO_ERROR)  
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }

                
            RELEASE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");

            break;
        }

        Group = pge->Group;


        if (!IS_MCAST_ADDR(Group)) {

            Trace0(ERR, "==========================================================");
            Trace2(ERR, "bad group(%d.%d.%d.%d)(pge:%0x) MibGetInternalGroupIfsInfo",
                        PRINT_IPADDR(pge->Group), (ULONG_PTR)pge);
            Trace0(ERR, "==========================================================");

            IgmpAssert(FALSE);
        }
        
        RELEASE_GROUP_LIST_LOCK("_MibGetInternalGroupIfsInfo");


        //
        // have to release the group list lock before I acquire the group bucket
        // lock to prevent deadlock.
        //
       
        //
        // take group bucket lock
        //
        ACQUIRE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
        bGroupBucketLock = TRUE;

        
        // get the group again as it could have been deleted.
        pge = GetGroupFromGroupTable (Group, NULL, 0);

        // if the group has been meanwhile deleted, then continue
        if (pge==NULL) {
            RELEASE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
            bGroupBucketLock = FALSE;
            continue;
        }

        
        //
        // compute the size of the data returned
        //
        dwNumIfs = pge->NumVifs;

        if (bEnumV3) {
        
            pHead = &pge->ListOfGIs;
            
            dwCurSize = sizeof(IGMP_MIB_GROUP_IFS_LIST) +
                                dwNumIfs*sizeof(MIB_GROUP_INFO_V3);

            i = 0;
            for (ple=pHead->Flink;  (ple!=pHead)&&(i<dwNumIfs);  
                    ple=ple->Flink,i++) 
            {
                pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);

                if (pgie->Version==3) {
                    dwCurSize += ( (pgie->NumSources + 
                                        ListLength(&pgie->V3ExclusionList))
                                    *sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3) );
                }
            }

        }
        else {
            dwCurSize = sizeof(IGMP_MIB_GROUP_IFS_LIST) +
                                dwNumIfs*sizeof(IGMP_MIB_GROUP_INFO);
                                
            if (pResponse == NULL) {
                Error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }      
        }

        //
        // if the buffer is not large enough, break from the loop
        //

        if (dwBufferSize < dwSize + dwCurSize) {

            if (dwCount==0)
                Error = ERROR_INSUFFICIENT_BUFFER;

            break;//from for loop
        }
        

        // set fields for group info
        
        pHeader->GroupAddr = pge->Group;
        pHeader->NumInterfaces = dwNumIfs;

        //
        // set groupAddr in pQuery so that in the next query, the info for other groups will
        // be passed
        //
        pQuery->GroupAddr = pge->Group;


        //
        // copy stats for interfaces that have joined the group.
        //
        pGIInfo = (PMIB_GROUP_INFO_V3)pHeader->Buffer;

        pHead = &pge->ListOfGIs;
        dwNumIfsCopied = 0;
        for (ple=pHead->Flink;  (ple!=pHead)&&(dwNumIfsCopied<dwNumIfs);  
                ple=ple->Flink,dwNumIfsCopied++) 
        {
            DWORD GIVersion;
            
            pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);

            GIVersion = pgie->Version;
            
            pGIInfo->IfIndex = pgie->IfIndex;
            
            //
            // if rasServerIf, then I return the NHAddr in IpAddr field
            // else return the IpAddr of this field
            //
            pGIInfo->IpAddr = (IS_RAS_SERVER_IF(pgie->pIfTableEntry->IfType))
                                ? pgie->NHAddr
                                : pgie->pIfTableEntry->IpAddr;


            pGIInfo->GroupExpiryTime
                            = (pgie->Info.GroupExpiryTime==~0)
                            ? ~0
                            : SYSTEM_TIME_TO_SEC(pgie->Info.GroupExpiryTime-llCurTime);
            pGIInfo->LastReporter = pgie->Info.LastReporter;


            pGIInfo->GroupUpTime = 
                        SYSTEM_TIME_TO_SEC(llCurTime-pgie->Info.GroupUpTime);

                        
            if (llCurTime<pgie->Info.V1HostPresentTimeLeft)
                pGIInfo->V1HostPresentTimeLeft = 
                    SYSTEM_TIME_TO_SEC(pgie->Info.V1HostPresentTimeLeft-llCurTime);
            else
                pGIInfo->V1HostPresentTimeLeft = 0;

            if ( llCurTime>=pgie->Info.V2HostPresentTimeLeft)
                pGIInfo->V2HostPresentTimeLeft = 0;
            else {
                pGIInfo->V2HostPresentTimeLeft = 
                        SYSTEM_TIME_TO_SEC(pgie->Info.V2HostPresentTimeLeft-llCurTime);
            }

            
            pGIInfo->Flags = 0;
            if (pgie->bStaticGroup)
                pGIInfo->Flags |= IGMP_GROUP_TYPE_STATIC;
            if (pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE)
                pGIInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
            if (CAN_ADD_GROUPS_TO_MGM(pgie->pIfTableEntry))
                pGIInfo->Flags |= IGMP_GROUP_FWD_TO_MGM;

            if (bEnumV3) {

                PGI_SOURCE_ENTRY pSourceEntry;
                DWORD i, V3NumSources, V3SourcesSize;
                PLIST_ENTRY pHeadSrc, pLESrc;



                V3NumSources = pgie->NumSources + ListLength(&pgie->V3ExclusionList);
                V3SourcesSize = sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3)*V3NumSources;
                pGIInfo->Version = pgie->Version;
                pGIInfo->Size = sizeof(MIB_GROUP_INFO_V3) + V3SourcesSize;
                pGIInfo->FilterType = pgie->FilterType;
                pGIInfo->NumSources = V3NumSources;

                pHeadSrc = &pgie->V3InclusionListSorted;
                i = 0;
                for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc; pLESrc=pLESrc->Flink,i++) {


                    pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY,
                                        LinkSourcesInclListSorted);
                    pGIInfo->Sources[i].Source = pSourceEntry->IpAddr;

                    pGIInfo->Sources[i].SourceExpiryTime
                            = (pSourceEntry->bInclusionList)
                            ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                            : ~0;

                    pGIInfo->Sources[i].SourceUpTime
                        = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                }

                pHeadSrc = &pgie->V3ExclusionList;
                for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc;  pLESrc=pLESrc->Flink,i++){

                    pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY, LinkSources);
                    pGIInfo->Sources[i].Source = pSourceEntry->IpAddr;

                    pGIInfo->Sources[i].SourceExpiryTime
                            = (pSourceEntry->bInclusionList)
                            ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                            : ~0;

                    pGIInfo->Sources[i].SourceUpTime
                        = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                }

                pGIInfo = (PMIB_GROUP_INFO_V3)
                             ((PCHAR)pGIInfo + pGIInfo->Size);
                //Trace1(MEM, "NextPGIInfo: %0x:", (DWORD)pGIInfo);//deldel
            }
            else {
                pGIInfo = (PMIB_GROUP_INFO_V3)((PMIB_GROUP_INFO)pGIInfo + 1);
                //Trace1(MEM, "NextPGIInfo: %0x:", (DWORD)pGIInfo);//deldel
            }
            
        }

        //
        // everything fine. Copied one more stats struct
        //
        dwCount++;
        dwSize += dwCurSize;
        pHeader = (PIGMP_MIB_GROUP_IFS_LIST) pGIInfo;
        PrevGroup = pge->Group;


        // release the group bucket lock
        RELEASE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
        bGroupBucketLock = FALSE;


        // if GetMode==GETMODE_FIRST change it to GETMODE_NEXT.
        if (dwGetMode==GETMODE_FIRST) 
            dwGetMode = GETMODE_NEXT; 
            
    } //end for loop


    // check if group bucket lock has to be released
    if (bGroupBucketLock==TRUE) {
        RELEASE_GROUP_LOCK(Group, "_MibGetInternalGroupIfsInfo");
        bGroupBucketLock = FALSE;
    }
        
    if (pResponse!=NULL) {
        pResponse->Count = dwCount;
        pResponse->Flags |= IGMP_ENUM_FORMAT_IGMPV3;
    }

    
    //
    // set the actual size if some info was copied, else let size
    // remain
    //
    if (dwCount>0) 
        *pdwOutputSize = dwSize;
    else
        *pdwOutputSize = dwCurSize;
 


    Trace0(MIB, "Leaving _MibGetInternalGroupIfsInfo");
    return Error;
    
} //end _MibGetInternalGroupIfsInfo



//------------------------------------------------------------------------------
//          _MibGetInternalIfConfig
//
// no locks assumed. takes IfList lock
//------------------------------------------------------------------------------

DWORD
MibGetInternalIfConfig (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    )
{

    //
    // the interface config struct is variable size.
    // there may be multiple instances.
    //

    PIGMP_IF_TABLE          pTable = g_pIfTable;
    PIF_TABLE_ENTRY         pite;
    PIGMP_MIB_IF_CONFIG     pIfConfigDst;
    PIGMP_IF_CONFIG         pIfConfigSrc;
    DWORD                   dwCount, dwSize, dwSizeCur=0, Error = NO_ERROR;
    
        
    if (pResponse!=NULL) {
        pResponse->TypeId = IGMP_IF_CONFIG_ID; 
        
        pIfConfigDst = (PIGMP_MIB_IF_CONFIG)pResponse->Buffer;
    }

    // acquire IfLists lock so that you can access the interface lists
    ACQUIRE_IF_LIST_LOCK("MibGetInternalIfConfig");
    


    for (dwCount=0,dwSize=0;  dwCount<pQuery->Count;  ) {

        
        //
        // retrieve the interface whose config are to be read
        //

        pite = GetIfByListIndex(pQuery->IfIndex, dwGetMode, &Error);


        // I dont have to take the interface lock, as the IfLists lock is 
        // taken before interface config is changed or interface is deleted.
        //ACQUIRE_IF_LOCK_SHARED(IfIndex, "MibGetInternal");
        

        //
        // if the interface was not found, it may mean
        // the specified index was invalid, or it may mean
        // that the GETMODE_NEXT was called on the last interface
        // in which case ERROR_NO_MORE_ITEMS was returned.
        // In any case, we make sure Error indicates an error
        // and then return the value.
        //
        // if the interface was found but no output buffer was passed,
        // indicate in the error that memory needs to be allocated.
        //
        // otherwise, copy the config struct of the interface
        //

        if (pite == NULL) {
            if (dwCount>0) {
                Error = NO_ERROR;
            }
            // count==0
            else {
                if (Error == NO_ERROR)
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }

            break; //from for loop
        }

        pIfConfigSrc = &pite->Config;

        dwSizeCur = pIfConfigSrc->ExtSize;


        //
        // if no buffer was specified, indicate one should be allocated
        //        
        if (pResponse==NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }
        
        //
        // see if adequate buffer is left for the next struct
        //
        if (dwBufferSize < dwSize+dwSizeCur) {
            if (dwCount==0) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            }
            break;//from for loop
        }

        
        
        //
        // copy the interface config, and set the IP address
        //
        CopyoutIfConfig(pIfConfigDst, pite);

        pQuery->IfIndex = pite->IfIndex;
        pQuery->RasClientAddr = 0;
            
        dwCount++;
        dwSize += dwSizeCur;
        pIfConfigDst = (PIGMP_MIB_IF_CONFIG) (((PBYTE)pIfConfigDst)+ dwSizeCur);

        // if GetMode==GETMODE_FIRST change it to GETMODE_NEXT.
        if (dwGetMode==GETMODE_FIRST) 
            dwGetMode = GETMODE_NEXT; 

    }//end for loop

    //
    //set the actual size if some info was copied, else let size set earlier
    //remain
    //
    if (dwCount>0) {
        *pdwOutputSize = dwSize;
    } 
    else {
        *pdwOutputSize = dwSizeCur;
    }


    if (pResponse!=NULL)
        pResponse->Count = dwCount;
    
    
    RELEASE_IF_LIST_LOCK("_MibGetInternalIfConfig");

    Trace0(MIB, "Leaving _MibGetInternalIfConfig");
    return Error;

} //end _MibGetInternalIfConfig



//------------------------------------------------------------------------------
//              _MibGetInternalIfGroupsInfo
//
// Enumerates the list of GIs hanging from an interface
// Locks: no locks assumed.
//------------------------------------------------------------------------------
DWORD
MibGetInternalIfGroupsInfo (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    )
{
    LONGLONG                    llCurTime = GetCurrentIgmpTime();
    PIGMP_MIB_IF_GROUPS_LIST    pHeader;
    PMIB_GROUP_INFO_V3          pGroupInfo;
    PMIB_PROXY_GROUP_INFO_V3  pProxyGroupInfo;
    PGI_ENTRY                   pgie;
    PLIST_ENTRY                 pHead, ple;
    DWORD                       dwCurSize=0, Error=NO_ERROR, dwNumGroups, 
                                dwNumIfGroups, dwNumGroupsCopied, SizeofGroupEntry,
                                PrevQueryFlags = pQuery->Flags;
    PIF_TABLE_ENTRY             pite;
    PRAS_TABLE_ENTRY            prte;
    PRAS_TABLE                  prt;    
    BOOL                        bCopied, bProxy=FALSE, 
                                bRasClientEnum=FALSE, bRasServerEnum=FALSE, bRasIfLock=FALSE;
    DWORD                       lePrevGroup = NETWORK_TO_LITTLE_ENDIAN(pQuery->GroupAddr);
    USHORT                      PrevEnumSignature = pQuery->Signature;
    BOOL                        bEnumV3, bInsufficientBuffer=FALSE;



                    //kslksl
                    PPROXY_GROUP_ENTRY  pProxyEntry;
                    PLIST_ENTRY pHeadSrc, pleSrc;
                    DWORD SrcCnt;
                    PPROXY_SOURCE_ENTRY pSourceEntry;


    //Trace3(MEM, "_MibGetInternalIfGroupsInfo buffer: %0x -> %0x: %d", 
    //(DWORD)pResponse->Buffer, ((DWORD)pResponse->Buffer)+dwBufferSize, dwBufferSize);//deldel
            
    Trace0(MIB, "Entering _MibGetInternalIfGroupsInfo()");

    bEnumV3 = PrevQueryFlags & IGMP_ENUM_SUPPORT_FORMAT_IGMPV3; 

    CLEAR_IGMP_ENUM_INTERFACE_TABLE_FLAGS(pQuery->Flags);


    if ( (PrevQueryFlags & IGMP_ENUM_INTERFACE_TABLE_END)
        && !(PrevQueryFlags & IGMP_ENUM_ALL_INTERFACES_GROUPS)
        && !(PrevQueryFlags & IGMP_ENUM_FOR_RAS_CLIENTS) )
    {

        pQuery->GroupAddr = 0;
        pQuery->Signature = 0;
        return ERROR_NO_MORE_ITEMS;
    }


    
    //
    // Initialize 
    //
    if (pResponse!=NULL) {
        pResponse->TypeId = IGMP_IF_GROUPS_LIST_ID;
        pHeader = (PIGMP_MIB_IF_GROUPS_LIST) pResponse->Buffer;
    }



    //
    // acquire IfLists lock so that the interfaces list can be accessed
    //
    ACQUIRE_IF_LIST_LOCK("_MibGetInternalIfGroupsInfo");
    

    //
    // retrieve the interface (and ras client)
    //

    if (PrevQueryFlags & IGMP_ENUM_FOR_RAS_CLIENTS) {

        if (pQuery->IfIndex==0)
            pQuery->IfIndex = g_RasIfIndex;

        Error = GetIfOrRasForEnum(pQuery, pResponse, dwGetMode,
                                        &pite, &prt, &prte, &bRasIfLock, 
                                        IGMP_ENUM_FOR_RAS_CLIENTS);
    }
    
    else if ( (PrevQueryFlags & IGMP_ENUM_INTERFACE_TABLE_CONTINUE) 
            || ((pQuery->IfIndex!=0)&&(pQuery->GroupAddr!=0)&&
                (!(PrevQueryFlags & IGMP_ENUM_INTERFACE_TABLE_END)) ) )
    {


        // continuing from the previous call. so get the same interface again.
        
        Error = GetIfOrRasForEnum(pQuery, pResponse, GETMODE_EXACT,
                                            &pite, &prt, &prte, &bRasIfLock, 0);


        // 
        // if the interface has meanwhile been deleted, then get the next interface
        // only if all interface group lists are  being enumerated.
        //
        if ( (pite==NULL) && (pQuery->Flags&IGMP_ENUM_ALL_INTERFACES_GROUPS) ) {
        
            // the interface was deleted. so I continue with the next interface
        
            Error = GetIfOrRasForEnum(pQuery, pResponse, GETMODE_NEXT,
                            &pite, &prt, &prte, &bRasIfLock, 0);
        

            if (pResponse) {
                pResponse->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
            }
        }
            
    }

    else {

        // enumerating a new interface
        
        Error = GetIfOrRasForEnum(pQuery, pResponse, dwGetMode,
                            &pite, &prt, &prte, &bRasIfLock, 0);

        if (pResponse) {
            pResponse->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
            pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_BEGIN;
        }
    }

    
    //
    // The required interface or the next interface not found. Return error.
    //
    if (pite == NULL) {

        //
        // GetIfOrRasForEnum returns no_error if there are no interfaces.
        // but I will return invalid_parameter
        //
        if (Error == NO_ERROR)
            Error = ERROR_INVALID_PARAMETER;
            
        *pdwOutputSize = 0;

        if (pResponse)
            pResponse->Count = 0;

        RELEASE_IF_LIST_LOCK("_MibGetInternalIfGroupsInfo");

        Trace1(MIB, "Leaving _MibGetInternalIfGroupsInfo(%d)", Error);
        return Error;
    }


    //
    // get the shared interface lock so that its fields can no longer be
    // changed. As IF_LISTS lock is taken, the inteface state cannot get changed
    //
    if (!bRasIfLock)
        ACQUIRE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfGroupsInfo");

    ACQUIRE_ENUM_LOCK_EXCLUSIVE("_MibGetInternalIfGroupsInfo");

    bRasClientEnum = prte != NULL;
    bRasServerEnum = IS_RAS_SERVER_IF(pite->IfType) && !bRasClientEnum;
    bEnumV3 = bEnumV3 && (IS_PROTOCOL_TYPE_IGMPV3(pite)||IS_PROTOCOL_TYPE_PROXY(pite));

    
    BEGIN_BREAKOUT_BLOCK1 {

        bProxy = IS_PROTOCOL_TYPE_PROXY(pite);


        // set size for groupEntry

        SizeofGroupEntry = (bProxy)
                            ? (bEnumV3?sizeof(MIB_PROXY_GROUP_INFO_V3):sizeof(MIB_PROXY_GROUP_INFO))
                            : (bEnumV3?sizeof(MIB_GROUP_INFO_V3):sizeof(IGMP_MIB_GROUP_INFO));


        
        //
        // if no buffer passed or buffer less than that required for 1 group entry, 
        // set the required buffer size to MIB_DEFAULT_BUFFER_SIZE and break.
        //

        if ( (pResponse==NULL) 
            || (!bEnumV3 && !bRasClientEnum&&
                (dwBufferSize < sizeof(IGMP_MIB_IF_GROUPS_LIST) + SizeofGroupEntry))
            || (!bEnumV3 && bRasClientEnum
                &&(dwBufferSize<sizeof(IGMP_MIB_IF_GROUPS_LIST) 
                    + SizeofGroupEntry*prte->Info.CurrentGroupMemberships) ) 
            || (bEnumV3 && (dwBufferSize<MIB_DEFAULT_BUFFER_SIZE)) )
        {
        
            Error = ERROR_INSUFFICIENT_BUFFER;

            if (bEnumV3) {
                dwCurSize = MIB_DEFAULT_BUFFER_SIZE;
            }
            else {
                dwCurSize = (pQuery->Flags&IGMP_ENUM_ONE_ENTRY) 
                        ? sizeof(IGMP_MIB_IF_GROUPS_LIST) + sizeof(IGMP_MIB_GROUP_INFO)
                        : bRasClientEnum
                            ? sizeof(IGMP_MIB_IF_GROUPS_LIST) 
                                 + SizeofGroupEntry*(prte->Info.CurrentGroupMemberships+5)
                            : MIB_DEFAULT_BUFFER_SIZE;
            }
            
            // dont change pQuery->GroupAddr
            bCopied = FALSE;
            bInsufficientBuffer = TRUE;
            GOTO_END_BLOCK1;
        }



        //
        // set dwNumIfGroups
        //
        if (!IS_IF_ACTIVATED(pite)) {
            dwNumIfGroups = 0;
        }    
        
        else {
        
            if (bProxy) {
                dwNumIfGroups = pite->Info.CurrentGroupMemberships;
            }    
            
            //
            // if no ras client stats (if flag not set in the query, or ras
            // stats not being kept).
            //
            else if ( bRasClientEnum && !g_Config.RasClientStats )
            {
                dwNumIfGroups = 0;
            }

            else {
                dwNumIfGroups = (bRasClientEnum)
                                ? prte->Info.CurrentGroupMemberships
                                : pite->Info.CurrentGroupMemberships;
            }
        }
        

        
        //
        // calculate how many group entries will fit in the buffer left.
        // dwNumGroups cannot be greater than dwNumIfGroups and 
        // enumerate only 1 group if IGMP_ENUM_ONE_ENTRY flag set.
        //

        // note: dwNumGroups can be 0, only if dwNumIfGroups is 0

       
        dwNumGroups = bEnumV3? 100
                      : (dwBufferSize - sizeof(IGMP_MIB_IF_GROUPS_LIST)) 
                        / SizeofGroupEntry;

        dwNumGroups = MIN(dwNumIfGroups, dwNumGroups);

        if (pQuery->Flags&IGMP_ENUM_ONE_ENTRY)
            dwNumGroups = MIN(dwNumGroups, 1);

        

        // initialize size required for this interface groups
        
        dwCurSize = sizeof(IGMP_MIB_IF_GROUPS_LIST);



        // 
        // set fields in the Interface header that will be returned to the caller
        //
        
        pHeader->IfIndex = pite->IfIndex;

        if (bRasClientEnum) {
            pHeader->IpAddr = prte->NHAddr;
            pHeader->IfType = IGMP_IF_RAS_CLIENT;        
        }
        else {
            pHeader->IpAddr = pite->IpAddr;
            pHeader->IfType = GET_EXTERNAL_IF_TYPE(pite);
            
        }
        


        //
        // set fields in pQuery
        //
        
        pQuery->IfIndex = pite->IfIndex;
        pQuery->RasClientAddr = (bRasClientEnum) ? prte->NHAddr : 0;



        //
        // if not activated, just copy the interface header and return with 0 groups
        //
        
        if (!IS_IF_ACTIVATED(pite)) {
        
            dwNumGroupsCopied = 0;
    
            // set pQuery fields
            pQuery->GroupAddr = 0;
            pQuery->Flags |= (IGMP_ENUM_INTERFACE_TABLE_BEGIN
                             | IGMP_ENUM_INTERFACE_TABLE_END);
            pResponse->Flags |= (IGMP_ENUM_INTERFACE_TABLE_BEGIN
                             | IGMP_ENUM_INTERFACE_TABLE_END);

            // set interface header fields
            pHeader->NumGroups = 0;

            dwCurSize = sizeof(IGMP_MIB_IF_GROUPS_LIST);
            bCopied = TRUE;
            GOTO_END_BLOCK1;
        }

        ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_MibGetInternalIfGroupsInfo");

        ple = NULL;

        //--------------------------------------------------
        // if interface not proxy, then copy the group info.
        //---------------------------------------------------
        if (!bProxy) {

            pGroupInfo = (PMIB_GROUP_INFO_V3)(pHeader->Buffer);


            // merge the lists if this interface is being enumerated for the first time.
            if (lePrevGroup==0)
                MergeIfGroupsLists(pite);
                
            
            pHead = (bRasClientEnum) ? &prte->ListOfSameClientGroups 
                                 : &pite->ListOfSameIfGroups;



            // if continuing enumeration, then walk down to the next group
            // ras client wont get into this block
            
            if (lePrevGroup!=0)  {

                //
                // get next entry from where we left off last time
                //
                if ( (PrevEnumSignature==pite->PrevIfGroupEnumSignature)
                    && (PrevEnumSignature!=0) ){

                    // had reached end of enumeration
                    if (pite->pPrevIfGroupEnumPtr==NULL)
                        dwNumGroups = 0;

                    else 
                        ple = &((PGI_ENTRY)pite->pPrevIfGroupEnumPtr)->LinkBySameIfGroups;
                    
                }

                //
                // get next entry by searching through the list
                //
                else {

                    for (ple=pHead->Flink;  (ple!=pHead); ple=ple->Flink) {
                        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
                        if (lePrevGroup<pgie->pGroupTableEntry->GroupLittleEndian)
                            break;
                    }
                }
            }

            //
            // starting enumeration from the beginning of the list
            //
            else {
                ple = pHead->Flink;
            }

            

            // 
            // finally copy the groups(!proxy)
            //
            
            dwNumGroupsCopied = 0;
            for ( ;  (ple!=pHead)&&(dwNumGroupsCopied<dwNumGroups);  
                    ple=ple->Flink,dwNumGroupsCopied++) 
            {
                PLIST_ENTRY pleNext;
                DWORD       LastReporter, GroupUpTime, GroupExpiryTime;
                DWORD       V3SourcesSize=0, i;
                DWORD       IncrementSize=0, V3NumSources=0;
                
                pgie = bRasClientEnum
                            ? CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups)
                            : CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);

                if (bEnumV3){
                    V3NumSources = pgie->NumSources + ListLength(&pgie->V3ExclusionList);
                    V3SourcesSize = sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3)*V3NumSources;
                }

                IncrementSize = SizeofGroupEntry+V3SourcesSize;
                
                if (dwCurSize+IncrementSize > dwBufferSize){
                    if (dwNumGroupsCopied==0) {
                        dwCurSize += IncrementSize;
                        bCopied = FALSE;
                        bInsufficientBuffer = TRUE;
                    }
                    break;
                }



                dwCurSize += IncrementSize;
                
                pGroupInfo->GroupAddr = pgie->pGroupTableEntry->Group;
                pGroupInfo->IpAddr = pgie->pIfTableEntry->IpAddr;

                GroupUpTime = SYSTEM_TIME_TO_SEC(llCurTime-pgie->Info.GroupUpTime);
                GroupExpiryTime = (pgie->Info.GroupExpiryTime==~0)
                                ? ~0
                                : SYSTEM_TIME_TO_SEC(pgie->Info.GroupExpiryTime-llCurTime);
                LastReporter = pgie->Info.LastReporter;

                
                if (bRasServerEnum) {

                    DWORD GroupExpiryTimeTmp;
                    PGI_ENTRY   pgieNext;

                    for (pleNext=ple->Flink; pleNext!=pHead;  pleNext=pleNext->Flink) {
                    
                        pgieNext = CONTAINING_RECORD(pleNext, GI_ENTRY, LinkBySameIfGroups);
                        
                        if (pgieNext->pGroupTableEntry->Group != pgie->pGroupTableEntry->Group)
                            break;
                            
                        GroupUpTime = MAX(GroupUpTime, 
                                        SYSTEM_TIME_TO_SEC(llCurTime-pgieNext->Info.GroupUpTime));
                        GroupExpiryTimeTmp = (pgieNext->Info.GroupExpiryTime==~0)
                                        ? ~0
                                        : SYSTEM_TIME_TO_SEC(pgieNext->Info.GroupExpiryTime-llCurTime);
                        if (GroupExpiryTimeTmp > GroupExpiryTime) {
                            GroupExpiryTime = GroupExpiryTimeTmp;
                            LastReporter = pgieNext->Info.LastReporter;
                        }
                    }

                    ple = pleNext->Blink;
                }
                
                pGroupInfo->GroupUpTime = GroupUpTime;
                pGroupInfo->GroupExpiryTime = GroupExpiryTime;
                pGroupInfo->LastReporter = LastReporter;

                if ( (llCurTime>=pgie->Info.V1HostPresentTimeLeft) || bRasServerEnum)
                    pGroupInfo->V1HostPresentTimeLeft = 0;
                else {
                    pGroupInfo->V1HostPresentTimeLeft = 
                            SYSTEM_TIME_TO_SEC(pgie->Info.V1HostPresentTimeLeft-llCurTime);
                }
                if ( (llCurTime>=pgie->Info.V2HostPresentTimeLeft) || bRasServerEnum)
                    pGroupInfo->V2HostPresentTimeLeft = 0;
                else {
                    pGroupInfo->V2HostPresentTimeLeft = 
                            SYSTEM_TIME_TO_SEC(pgie->Info.V2HostPresentTimeLeft-llCurTime);
                }

                pGroupInfo->Flags = 0;
                if ( (pgie->bStaticGroup) && (!bRasServerEnum) )
                    pGroupInfo->Flags |= IGMP_GROUP_TYPE_STATIC;
                if ( (pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE) || (bRasServerEnum) )
                    pGroupInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
                if (CAN_ADD_GROUPS_TO_MGM(pite))
                    pGroupInfo->Flags |= IGMP_GROUP_FWD_TO_MGM;


                if (bEnumV3) {

                    PGI_SOURCE_ENTRY pSourceEntry;
                    DWORD i=0;
                    PLIST_ENTRY pHeadSrc, pLESrc;
                    
                    pGroupInfo->Version = pgie->Version;
                    pGroupInfo->Size = sizeof(MIB_GROUP_INFO_V3) + V3SourcesSize;
                    pGroupInfo->FilterType = pgie->FilterType;
                    pGroupInfo->NumSources = V3NumSources;

                    pHeadSrc = &pgie->V3InclusionListSorted;
                    for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc;  pLESrc=pLESrc->Flink,i++) {

                        
                        pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY,
                                            LinkSourcesInclListSorted);
                        pGroupInfo->Sources[i].Source = pSourceEntry->IpAddr;

                        //kslksl
                        ASSERT(pGroupInfo->Sources[i].Source !=0);
                            
                        pGroupInfo->Sources[i].SourceExpiryTime
                                = (pSourceEntry->bInclusionList)
                                ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                                : ~0;
                            
                        pGroupInfo->Sources[i].SourceUpTime
                            = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                    }
                    
                    pHeadSrc = &pgie->V3ExclusionList;
                    for (pLESrc=pHeadSrc->Flink;  pLESrc!=pHeadSrc;  pLESrc=pLESrc->Flink,i++) {

                        pSourceEntry = CONTAINING_RECORD(pLESrc, GI_SOURCE_ENTRY, LinkSources);
                        pGroupInfo->Sources[i].Source = pSourceEntry->IpAddr;

                        pGroupInfo->Sources[i].SourceExpiryTime
                                = (pSourceEntry->bInclusionList)
                                ? QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                                : ~0;
                            
                        pGroupInfo->Sources[i].SourceUpTime
                            = (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000;
                    }
                    
                    pGroupInfo = (PMIB_GROUP_INFO_V3)
                                 ((PCHAR)pGroupInfo + pGroupInfo->Size);
                }
                else
                    pGroupInfo = (PMIB_GROUP_INFO_V3)((PMIB_GROUP_INFO)pGroupInfo + 1);

                //Trace1(MEM, "NextpGroupInfo:%0x", (DWORD)pGroupInfo);//deldel
            }



            //
            // if reached the end of the group list or the group list is empty
            //
            if (((ple==pHead&&dwNumGroupsCopied!=0) || (dwNumIfGroups==0)||(dwNumGroups==0))
                &&!bInsufficientBuffer && !bRasClientEnum)
            {

                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_END;
                pQuery->GroupAddr = 0;

    
                // reset pointers for next enumeration
                pite->pPrevIfGroupEnumPtr = NULL;
                pite->PrevIfGroupEnumSignature = 0;
            }
            
            //
            // else have more GI entries to enumerate
            //
            else if (!bRasClientEnum) {
                
                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_CONTINUE;

                if (ple!=pHead) {

                    PGI_ENTRY   pgieNext;
                    
                    // get the next entry from which enum should continue
                    pgieNext = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
                
                
                    // update pQuery->GroupAddr
                    pQuery->GroupAddr = pgieNext->pGroupTableEntry->Group;


                    // update pointers for next enumeration
                    pite->pPrevIfGroupEnumPtr  = pgieNext;
                }
                else {
                    pQuery->GroupAddr = 0xffffffff;
                    pite->pPrevIfGroupEnumPtr  = NULL;
                }

                
                pite->PrevIfGroupEnumSignature = GET_NEXT_SIGNATURE();

                SET_SIGNATURE(pQuery->Signature, pite->PrevIfGroupEnumSignature);

            }
        }


        //--------------------------
        // proxy interface
        //--------------------------
        else {
            //kslksl
            //PPROXY_GROUP_ENTRY  pProxyEntry;
            

            pProxyGroupInfo = (PMIB_PROXY_GROUP_INFO_V3)(pHeader->Buffer);


            // merge the lists if this interface is being enumerated for the first time.
            if (lePrevGroup==0)
                MergeProxyLists(pite);
                
            
            pHead = &pite->ListOfSameIfGroups;

            

            // if continuing enumeration, then walk down to the next group
            
            if (lePrevGroup!=0)  {

                //
                // get next entry from where we left off last time
                //
                if ( (PrevEnumSignature==pite->PrevIfGroupEnumSignature)
                    && (PrevEnumSignature!=0) )
                {

                    // had reached end of enumeration
                    if (pite->pPrevIfGroupEnumPtr==NULL)
                        dwNumGroups = 0;

                    else 
                        ple = &((PPROXY_GROUP_ENTRY)pite->pPrevIfGroupEnumPtr)->LinkBySameIfGroups;
                    
                }

                //
                // get next entry by searching through the list
                //
                else {

                    for (ple=pHead->Flink;  (ple!=pHead); ple=ple->Flink) {
                        pProxyEntry = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                                        LinkBySameIfGroups);
                        if (lePrevGroup<pProxyEntry->GroupLittleEndian)
                            break;
                    }
                }
            }

            //
            // starting enumeration from the beginning of the list
            //
            else {
                ple = pHead->Flink;
            }

            

            // 
            // finally copy the groups
            //
            
            dwNumGroupsCopied = 0;
            for ( ;  (ple!=pHead)&&(dwNumGroupsCopied<dwNumGroups);  
                    ple=ple->Flink,dwNumGroupsCopied++) 
            {
                DWORD V3SourcesSize=0, IncrementSize;
                
                pProxyEntry= CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                                LinkBySameIfGroups);


                if (bEnumV3){
                    V3SourcesSize
                        = pProxyEntry->NumSources*sizeof(IGMP_MIB_GROUP_SOURCE_INFO_V3);
                }

                IncrementSize = SizeofGroupEntry+V3SourcesSize;
                
                if (dwCurSize+IncrementSize > dwBufferSize){
                    if (dwNumGroupsCopied==0) {
                        dwCurSize += IncrementSize;
                        bCopied = FALSE;
                        bInsufficientBuffer = TRUE;
                    }
                    break;
                }



                dwCurSize += IncrementSize;

                
                pProxyGroupInfo->GroupAddr = pProxyEntry->Group;
                pProxyGroupInfo->GroupUpTime
                         = SYSTEM_TIME_TO_SEC(llCurTime-pProxyEntry->InitTime);

                pProxyGroupInfo->Flags = 0;
                if (pProxyEntry->bStaticGroup) {
                    pProxyGroupInfo->Flags |= IGMP_GROUP_TYPE_STATIC;
                    if (pProxyEntry->RefCount>0)
                        pProxyGroupInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
                }
                else {
                    pProxyGroupInfo->Flags |= IGMP_GROUP_TYPE_NON_STATIC;
                }

                if (!bEnumV3) {
                    pProxyGroupInfo = (PMIB_PROXY_GROUP_INFO_V3)
                        ((PMIB_PROXY_GROUP_INFO)pProxyGroupInfo+1);
                }
                else {

                    //kslksl
/*                    PLIST_ENTRY pHeadSrc, pleSrc;
                    DWORD SrcCnt;
                    PPROXY_SOURCE_ENTRY pSourceEntry;
*/

                    pProxyGroupInfo->NumSources = pProxyEntry->NumSources;
                    pProxyGroupInfo->Size = IncrementSize; 

                    pHeadSrc = &pProxyEntry->ListSources;
                    for (pleSrc=pHeadSrc->Flink,SrcCnt=0;  pleSrc!=pHeadSrc; 
                            pleSrc=pleSrc->Flink,SrcCnt++) 
                    {

                        pSourceEntry = CONTAINING_RECORD(pleSrc, 
                                            PROXY_SOURCE_ENTRY, LinkSources);
                        pProxyGroupInfo->Sources[SrcCnt].Source
                                = pSourceEntry->IpAddr;
                        pProxyGroupInfo->Sources[SrcCnt].Flags = pSourceEntry->JoinMode;
                        pProxyGroupInfo->Sources[SrcCnt].Flags += 
                                            (pSourceEntry->JoinModeIntended<<4);

                    }

                    
                    pProxyGroupInfo = (PMIB_PROXY_GROUP_INFO_V3)
                        &pProxyGroupInfo->Sources[pProxyGroupInfo->NumSources];
                    //Trace1(MEM, "next proxy: %0x:", (DWORD)pProxyGroupInfo);//deldel
                }
            }//copy all sources



            //
            // if reached the end of the group list or the group list is empty
            //
            if ( ((ple==pHead&&dwNumGroupsCopied!=0)||(dwNumIfGroups==0)||(dwNumGroups==0))
                && !bInsufficientBuffer)
                //||(ple->Flink==pHead))  
            {

                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_END;
                pQuery->GroupAddr = 0;

    
                // reset pointers for next enumeration
                pite->pPrevIfGroupEnumPtr = NULL;
                pite->PrevIfGroupEnumSignature = 0;
            }
            
            //
            // else have more GI entries to enumerate
            //
            else {
                PPROXY_GROUP_ENTRY   pProxyNext;

                
                pQuery->Flags |= IGMP_ENUM_INTERFACE_TABLE_CONTINUE;


                if (ple!=pHead) {
                    // get the next entry from which enum should continue
                    pProxyNext = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                                    LinkBySameIfGroups);
                    
                    
                    // update pQuery->GroupAddr
                    pQuery->GroupAddr = pProxyNext->Group;


                    // update pointers for next enumeration
                    pite->pPrevIfGroupEnumPtr  = pProxyNext;
                    
                }
                else {
                    pQuery->GroupAddr = 0xffffffff;
                    pite->pPrevIfGroupEnumPtr = NULL;
                }

                pite->PrevIfGroupEnumSignature = GET_NEXT_SIGNATURE();

                SET_SIGNATURE(pQuery->Signature, pite->PrevIfGroupEnumSignature);
            }

        } //end proxy interface



        //
        // if only one interface is being enumerated, and the number of groups being
        // enumerated is 0 inspite of adequate buffer, then return NO_MORE_ITEMS
        //
        
        if ( !bInsufficientBuffer && (dwNumGroupsCopied==0)
            &&(!(pQuery->Flags&IGMP_ENUM_ALL_INTERFACES_GROUPS)) ) 
        {
        
            pQuery->GroupAddr = 0;
            Error = ERROR_NO_MORE_ITEMS;
        }    


        
        RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_MibGetInternalIfGroupsInfo");
            
        if (!bInsufficientBuffer)
            bCopied = TRUE;

        
    } END_BREAKOUT_BLOCK1; // inside shared interface lock.

    // release the shared interface lock
    
    RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfGroupsInfo");
    RELEASE_ENUM_LOCK_EXCLUSIVE("_MibGetInternalIfGroupsInfo");


    if (pResponse!=NULL) {

        pResponse->Count = (bCopied) ? 1 : 0;

        if (bCopied)
            pHeader->NumGroups = dwNumGroupsCopied;
        if (bEnumV3)
            pResponse->Flags |= IGMP_ENUM_FORMAT_IGMPV3;
    }        

    if (bInsufficientBuffer)
        pQuery->Flags |= PrevQueryFlags;


        
    //
    //set the actual size if some info was copied, else let size
    //remain
    //
    *pdwOutputSize = dwCurSize;
    

    RELEASE_IF_LIST_LOCK("_MibGetInternalIfGroupsInfo");


    Trace0(MIB, "Leaving _MibGetInternalIfGroupsInfo()");
    return Error;
    
} //end _MibGetInternalIfGroupsInfo
    
   

//------------------------------------------------------------------------------
//              MibGetInternalIfStats
//------------------------------------------------------------------------------
DWORD
MibGetInternalIfStats (
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    PDWORD                      pdwOutputSize,
    DWORD                       dwGetMode,
    DWORD                       dwBufferSize
    ) 
{
    DWORD               Error = NO_ERROR, dwCount, dwSize;
    PIGMP_IF_TABLE      pTable = g_pIfTable;
    PIF_TABLE_ENTRY     pite;
    PRAS_TABLE_ENTRY    prte;
    PRAS_TABLE          prt;
    PIGMP_MIB_IF_STATS  pStatsDst;
    PIF_INFO            pIfStatsSrc;
    LONGLONG            llCurTime = GetCurrentIgmpTime();
    BOOL                bDone, bCopied, bRasIfLock;
    
    

    Trace0(MIB, "Entering _MibGetInternalIfStats()");

    
    *pdwOutputSize = pQuery->Count*sizeof(IGMP_MIB_IF_STATS);
                     

    //
    // the interface statistics struct is fixed-length.
    // there may be multiple instances.
    //

    if (pResponse!=NULL) {    
        pResponse->TypeId = IGMP_IF_STATS_ID; 
        pStatsDst = (PIGMP_MIB_IF_STATS) pResponse->Buffer;
    }
    

    // acquire IfLists lock so that the interfaces list can be accessed
    ACQUIRE_IF_LIST_LOCK("_MibGetInternalIfStats");


    for (dwCount=0, dwSize=0;  dwCount<pQuery->Count;  ) {

        //
        // retrieve the interface. If the ras flag was set and ras statistics
        // are kept, then ras client statistics are also returned.
        // If no more relevant structures, then return ERROR_NO_MORE_ITEMS.
        //

        //
        // the pResponse IfIndex,RasClientAddr fields are updated appropriately.
        // if a lock is acquired on the ras table, then bRasIfLock is set to
        // TRUE;
        //

        bRasIfLock = FALSE;
        Error = GetIfOrRasForEnum(pQuery, pResponse, dwGetMode, 
                                    &pite, &prt, &prte, &bRasIfLock, 0);

        if (pite == NULL) {
            if (dwCount>0) {
                Error = NO_ERROR;
            }
            // count==0
            else {
                if (Error == NO_ERROR)
                    Error = ERROR_INVALID_PARAMETER;
                *pdwOutputSize = 0;
            }
            break; //from for loop
        }


        //
        // if no buffer was specified, indicate one should be allocated
        // the required buffer size has already been set.
        //
        if (pResponse==NULL) {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        
        //
        // acquire IfLists locks so that interfaces list cannot be changed
        //
        if (!bRasIfLock)
            ACQUIRE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfStats");

        
        BEGIN_BREAKOUT_BLOCK1 {
            //
            // if the buffer is not large enough, break from the loop
            //

            if (dwBufferSize < dwSize+sizeof(IGMP_MIB_IF_STATS)) {
                if (dwCount==0)
                    Error = ERROR_INSUFFICIENT_BUFFER;

                bDone = TRUE;
                bCopied = FALSE;
                GOTO_END_BLOCK1;
            }

            

            
            //
            // copy the interface stats. Copy field by field as access to this 
            // structure is not synchronized
            //

            //
            // copy interface stats
            //
            if (prte==NULL) {

                pIfStatsSrc = &pite->Info;

                if (!IS_IF_ACTIVATED(pite))
                    ZeroMemory(pStatsDst, sizeof(*pStatsDst));
                    

                //
                //copy if index, addr
                //
                pStatsDst->IfIndex = pite->IfIndex;
                pStatsDst->IpAddr = pite->IpAddr;
                pStatsDst->IfType = GET_EXTERNAL_IF_TYPE(pite);
                GET_EXTERNAL_IF_STATE(pite, pStatsDst->State);

                
                pQuery->IfIndex = pite->IfIndex;
                pQuery->RasClientAddr = 0;
                

                pStatsDst->IgmpProtocolType =
                        pite->Config.IgmpProtocolType;
                        
                //
                // if this interface is not activated, then continue from the
                // next one
                //
                if (!IS_IF_ACTIVATED(pite)) {
                    bDone = FALSE; bCopied = TRUE;
                    GOTO_END_BLOCK1;
                }

                
                pStatsDst->QuerierState = pIfStatsSrc->QuerierState;
                

                pStatsDst->QuerierIpAddr =
                        pIfStatsSrc->QuerierIpAddr;

                pStatsDst->ProxyIfIndex = g_ProxyIfIndex;

                
                //if I am the querier set to 0 
                pStatsDst->QuerierPresentTimeLeft = IS_QUERIER(pite) ?
                        0 :
                        SYSTEM_TIME_TO_SEC(pIfStatsSrc->QuerierPresentTimeout - llCurTime);

                pStatsDst->LastQuerierChangeTime
                        = SYSTEM_TIME_TO_SEC(llCurTime - pIfStatsSrc->LastQuerierChangeTime);

                pStatsDst->V1QuerierPresentTimeLeft = 
                    (IS_IF_VER2(pite) && (pIfStatsSrc->V1QuerierPresentTime > llCurTime))
                    ? SYSTEM_TIME_TO_SEC(pIfStatsSrc->V1QuerierPresentTime - llCurTime)
                    : 0;

                {
                    LARGE_INTEGER liUptime;
                    liUptime.QuadPart = (llCurTime-pIfStatsSrc->TimeWhenActivated)/1000;
                    pStatsDst->Uptime = liUptime.LowPart;
                }
                
                pStatsDst->TotalIgmpPacketsReceived
                        = pIfStatsSrc->TotalIgmpPacketsReceived;
                pStatsDst->TotalIgmpPacketsForRouter
                        = pIfStatsSrc->TotalIgmpPacketsForRouter;
                pStatsDst->GeneralQueriesReceived
                        = pIfStatsSrc->GenQueriesReceived;
                pStatsDst->WrongVersionQueries
                        = pIfStatsSrc->WrongVersionQueries;
                pStatsDst->JoinsReceived 
                        = pIfStatsSrc->JoinsReceived;
                pStatsDst->LeavesReceived
                        = pIfStatsSrc->LeavesReceived;
                pStatsDst->CurrentGroupMemberships
                        = pIfStatsSrc->CurrentGroupMemberships;
                pStatsDst->GroupMembershipsAdded
                        = pIfStatsSrc->GroupMembershipsAdded;
                pStatsDst->WrongChecksumPackets 
                        = pIfStatsSrc->WrongChecksumPackets;
                pStatsDst->ShortPacketsReceived
                        = pIfStatsSrc->ShortPacketsReceived;
                pStatsDst->LongPacketsReceived
                        = pIfStatsSrc->LongPacketsReceived;
                pStatsDst->PacketsWithoutRtrAlert
                        = pIfStatsSrc->PacketsWithoutRtrAlert;
            }


            //
            // copy ras client statistics
            //
            else {

                ZeroMemory(pStatsDst, sizeof(*pStatsDst));

                pStatsDst->IfIndex = pite->IfIndex;
                pStatsDst->IpAddr = pite->IpAddr;
                pStatsDst->IfType = IGMP_IF_RAS_CLIENT;
                GET_EXTERNAL_IF_STATE(pite, pStatsDst->State);
 
                pQuery->IfIndex = pite->IfIndex;
                pQuery->RasClientAddr = prte->NHAddr;


                //
                // if this interface is not activated, then continue from the
                // next one
                //
                if (!IS_IF_ACTIVATED(pite)) {
                    bDone = FALSE; bCopied = TRUE;
                    GOTO_END_BLOCK1;
                }
                
                    
                pStatsDst-> TotalIgmpPacketsReceived
                        = prte->Info.TotalIgmpPacketsReceived;
                pStatsDst->TotalIgmpPacketsForRouter
                        = prte->Info.TotalIgmpPacketsForRouter;
                pStatsDst->GeneralQueriesReceived
                        = prte->Info.GenQueriesReceived;
                pStatsDst->JoinsReceived 
                        = prte->Info.JoinsReceived;
                pStatsDst->LeavesReceived
                        = prte->Info.LeavesReceived;
                pStatsDst->CurrentGroupMemberships
                        = prte->Info.CurrentGroupMemberships;
                pStatsDst->GroupMembershipsAdded
                        = prte->Info.GroupMembershipsAdded;
                pStatsDst->WrongChecksumPackets 
                        = prte->Info.WrongChecksumPackets;
                pStatsDst->ShortPacketsReceived
                        = prte->Info.ShortPacketsReceived;
                pStatsDst->LongPacketsReceived
                        = prte->Info.LongPacketsReceived;
            }

            bCopied = TRUE;

            bDone = FALSE;
            
        } END_BREAKOUT_BLOCK1;

        RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfStats");
        bRasIfLock = FALSE;

        
        if (bCopied) {
            //
            // everything fine. Copied one more stats struct
            //
            dwCount++;
            dwSize += sizeof(IGMP_MIB_IF_STATS);
            pStatsDst++;
        }

        
        // if current mode is get first, then change it to get next
        if (dwGetMode==GETMODE_FIRST)
            dwGetMode = GETMODE_NEXT;


                
        if (bDone)
            break;

    }//end for loop

    if (pResponse!=NULL)
        pResponse->Count = dwCount;

    //
    //set the actual size if some info was copied, else let size set earlier
    //remain
    //
    if (dwCount>0) {
        *pdwOutputSize = dwSize;
    }
        
        
    // release interface lock

    if (bRasIfLock && pite)
        RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_MibGetInternalIfStats");
        
    RELEASE_IF_LIST_LOCK("_MibGetInternalIfStats");


    Trace0(MIB, "Leaving _MibGetInternalIfStats()");
    return Error;
    
} //end _MibGetInternalIfStats



//------------------------------------------------------------------------------
//      GetIfOrRasForEnum
// First gets the required interface. If ras stats enabled and asked,
// then gets the ras client.
//
// Locks On return:
//      if *bRasTableLock==TRUE then this procedure has taken read lock on the
//      ras table and has not released it.
//      Assumes shared interface lock.
//------------------------------------------------------------------------------

DWORD
GetIfOrRasForEnum(
    PIGMP_MIB_GET_INPUT_DATA    pQuery,
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse,
    DWORD                       dwGetMode,
    PIF_TABLE_ENTRY             *ppite,
    PRAS_TABLE                  *pprt,
    PRAS_TABLE_ENTRY            *pprte,  // on return set to null if no ras stats
    BOOL                        *bRasIfLock,
    DWORD                       dwEnumForRasClients
    )
{
    DWORD  Error = NO_ERROR, 
           bRasClientsEnum = dwEnumForRasClients & IGMP_ENUM_FOR_RAS_CLIENTS;


    *ppite = NULL;
    *pprt = NULL;
    *pprte = NULL;

    
    //
    // get the interface depending on the mode
    //
    if (bRasClientsEnum)
        *ppite = GetIfByListIndex(pQuery->IfIndex, GETMODE_EXACT, &Error);
    else
        *ppite = GetIfByListIndex(pQuery->IfIndex, dwGetMode, &Error);

    //
    // return if valid interface could not be found or not rasClient
    //
    if ( (*ppite==NULL) || (Error!=NO_ERROR) || !bRasClientsEnum)
        return Error;
    
    //
    // do ras client processing
    //
    
    BEGIN_BREAKOUT_BLOCK1 {


        ACQUIRE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");
        *bRasIfLock = TRUE;

        //
        // current interface not ras server interface. So done.
        //
        if (!IS_RAS_SERVER_IF((*ppite)->IfType))
            GOTO_END_BLOCK1;
        
        //
        // no ras client stats (if flag not set in the query, or ras
        // stats not being kept). So done.
        //
        if ( !bRasClientsEnum || !g_Config.RasClientStats )
        {
            GOTO_END_BLOCK1;
        }


        //
        // if mode: GETMODE_EXACT: then search for the ras client.
        // if ras client not found, then I set the interface to null
        //
        if (dwGetMode==GETMODE_EXACT) {

            // if pQuery->RasClientAddr==0, then he is not asking for ras client
            // So done.

            if (pQuery->RasClientAddr==0)
                GOTO_END_BLOCK1;

                        
            *pprte = GetRasClientByAddr(pQuery->RasClientAddr, 
                                        (*ppite)->pRasTable);

            //                          
            // if ras client not found in GETMODE_EXACT, then dont return IF
            // and release read lock on ras table.
            //
            if (*pprte==NULL) {
                *ppite = NULL;
                GOTO_END_BLOCK1;
            }

            *pprt = (*ppite)->pRasTable;
        }

        
        //
        // GETMODE_NEXT : if pQuery->RasClientAddr, then find the first ras
        // client, else find the next ras client
        //
        
        else if ( (dwGetMode==GETMODE_NEXT) || (dwGetMode==GETMODE_FIRST) ){
        
            BOOL    bFoundRasClient = FALSE;

            *pprt = (*ppite)->pRasTable;
            
            //
            // if the pQuery->RasClientAddr==0, then get the first ras client
            //
            if (pQuery->RasClientAddr==0) {

                if (!IsListEmpty(&(*pprt)->ListByAddr)) {
                
                    bFoundRasClient = TRUE;
                    *pprte = CONTAINING_RECORD((*pprt)->ListByAddr.Flink,
                                               RAS_TABLE_ENTRY, LinkByAddr);
                }
            }

            else {
                PRAS_TABLE_ENTRY    prtePrev, prteCur;
                PLIST_ENTRY         pHead, ple;

                
                // get the prev ras client through hash table
                prtePrev = GetRasClientByAddr(pQuery->RasClientAddr, 
                                        (*ppite)->pRasTable);

                //                        
                // if ras client not found, then go through the ordered list
                // and get a ras client with next higher addr
                //
                if (prtePrev==NULL) {

                    pHead = &(*pprt)->ListByAddr;
                    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                        prteCur = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, 
                                                    LinkByAddr);
                        if (pQuery->RasClientAddr>prteCur->NHAddr)
                            break;
                    }

                    if (ple!=pHead) {
                        bFoundRasClient = TRUE;
                        *pprte = prteCur;
                    }

                }

                //
                // get the next ras client through the ras client list
                //
                else {
                    ple = prtePrev->LinkByAddr.Flink;

                    // more entries present. found next ras client entry
                    if (ple != &(*pprt)->ListByAddr) {

                        bFoundRasClient = TRUE;
                        *pprte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, 
                                                    LinkByAddr);
                        *pprt = (*ppite)->pRasTable;
                    }
                }
            }

            // if ras client is not found, then I set the interface also to NULL
            if (bFoundRasClient==FALSE) {

                if (*bRasIfLock)
                    RELEASE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");

                *bRasIfLock = FALSE;
                *ppite = NULL;
                *pprte = NULL;
                *pprt = NULL;

                Error = ERROR_NO_MORE_ITEMS;
            }
            else 
                *pprt = (*ppite)->pRasTable;
                
        } //getmode==GETMODE_NEXT
        
    } END_BREAKOUT_BLOCK1;

    if ( (Error!= NO_ERROR) && (*bRasIfLock) ) {
        *bRasIfLock = FALSE;
        RELEASE_IF_LOCK_SHARED((*ppite)->IfIndex, "_GetIfOrRasForEnum");
    }
    
    return Error;
    
} //end _GetIfOrRasForEnum


//------------------------------------------------------------------------------
// Function:    _GetIfByListIndex
//
// if GETMODE_FIRST: retrieves the 1st entry in the list ordered by index.
// if GETMODE_EXACT: retrieves the entry from the hash table
// if GETMODE_NEXT:  retrieves the prev entry from hash table, and then
//                   retrieves the next entry from the list ordered by index.
//
// Locks: Assumes IfList lock.
//------------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByListIndex(
    DWORD         IfIndex,
    DWORD         dwGetMode,
    PDWORD        pdwErr
    )
{

    PIF_TABLE_ENTRY pite;
    PLIST_ENTRY     ple, pHead;


    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    pite = NULL;


    //
    // GETMODE_FIRST: return record at head of list;
    // if list is empty, return NULL.
    //
    if (dwGetMode == GETMODE_FIRST) {

        if (IsListEmpty(&g_pIfTable->ListByIndex)) { 
            //*pdwErr = ERROR_NO_MORE_ITEMS;
            return NULL; 
        }
        else {
            ple = g_pIfTable->ListByIndex.Flink;
            return CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
        }
    }


    //
    // get the entry requested from the hash table.
    //
    pite = GetIfByIndex(IfIndex);


    //
    // GETMODE_EXACT: return the entry 
    //
    if (dwGetMode==GETMODE_EXACT)
        return pite;

        
    //
    // GETMODE_NEXT: return the item after the one retrieved
    //
    if (dwGetMode==GETMODE_NEXT) {

        // the previous entry was found. return the next one.
        
        if (pite!=NULL) {

            ple = &pite->LinkByIndex;

            //
            // if entry found is last one, return NULL,
            // otherwise return the following entry
            //

            if (ple->Flink == &g_pIfTable->ListByIndex) {
                if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
                pite = NULL;
            }
            else {
                ple = ple->Flink;
                pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
            }
        }

        //
        // the previous entry was not found.
        // go throught the list of interfaces ordered by index, and retrieve the 
        // interface with next higher index
        //
        else {
            pHead = &g_pIfTable->ListByIndex;
            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByIndex);
                if (pite->IfIndex>IfIndex)
                    break;
            }
        }
    }

    return pite;
    
}//end _GetIfByListIndex


//------------------------------------------------------------------------------
//          _GetGroupByAddr
//
// Locks: assumes lock on the group list
//------------------------------------------------------------------------------
PGROUP_TABLE_ENTRY
GetGroupByAddr (
    DWORD       Group, 
    DWORD       dwGetMode,
    PDWORD      pdwErr
    )
{
    PLIST_ENTRY         ple, pHead;
    PGROUP_TABLE_ENTRY  pge;
    DWORD               GroupLittleEndian = NETWORK_TO_LITTLE_ENDIAN(Group);
    
    

    if (pdwErr != NULL) { *pdwErr = NO_ERROR; }

    pHead = &g_pGroupTable->ListByGroup.Link;
    pge = NULL;

    //
    // return record at head of list if mode is GETMODE_FIRST;
    // if list is empty, return NULL.
    //

    if (dwGetMode == GETMODE_FIRST) {
        if (pHead->Flink == pHead) { return NULL; }
        else {
            ple = pHead->Flink;
            return CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
        }
    }

    
    // get the entry requested

    pge = GetGroupFromGroupTable (Group, NULL, 0);



    //
    // if mode is GETMODE_NEXT, return the item after the one retrieved
    //

    if (dwGetMode == GETMODE_NEXT) {

        //
        // if the previous group was found, then return the one following it in the list
        //
        if (pge != NULL) {
        
            ple = &pge->LinkByGroup;

            //
            // if entry found is last one, return NULL,
            // otherwise return the following entry
            //

            if (ple->Flink == pHead) {
                if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
                pge = NULL;
            }
            else {
                ple = ple->Flink;
                pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
            }
        }
        //
        // previous group was not found. Go through the list and return the greater group.
        //
        else {
    
            pHead = &g_pGroupTable->ListByGroup.Link;

            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
                
                if (pge->GroupLittleEndian > GroupLittleEndian)
                    break;
            }

            if (ple==pHead) {
                if (pdwErr != NULL) { *pdwErr = ERROR_NO_MORE_ITEMS; }
                pge = NULL;
            }
            // else pge points to the entry to be returned.
        }
    }

    return pge;
    
}//end _GetGroupByAddr




DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{

      //
    // Not supported
    //

    return NO_ERROR;

}
    

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{
    //
    // Not supported
    //

    return NO_ERROR;
}


DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    )
{
    //
    // Not supported
    //

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\sync.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
// File:    sync.c
//
// History:
//  Abolade Gbadegesin
//  K.S.Lokesh (added Dynamic locking)
//
// Synchronization routines used by IGMP.
//============================================================================


#include "pchigmp.h"


// for debugging, Set ids for each dynamic lock

#ifdef LOCK_DBG
    DWORD   DynamicCSLockId;
    DWORD   DynamicRWLockId;
#endif;





//----------------------------------------------------------------------------
// Function:    QueueIgmpWorker  
//
// This function is called to queue a Igmp function in a safe fashion;
// if cleanup is in progress or if Igmp has stopped, this function
// discards the work-item.
//----------------------------------------------------------------------------

DWORD
QueueIgmpWorker(
    LPTHREAD_START_ROUTINE pFunction,
    PVOID pContext
    ) {

    DWORD Error = NO_ERROR;
    BOOL bSuccess;

    
    EnterCriticalSection(&g_CS);

    if (g_RunningStatus != IGMP_STATUS_RUNNING) {

        //
        // cannot queue a work function when Igmp has quit or is quitting
        //

        Error = ERROR_CAN_NOT_COMPLETE;
    }
    else {

        ++g_ActivityCount;
        bSuccess = QueueUserWorkItem(pFunction, pContext, 0);

        if (!bSuccess) {

            Error = GetLastError();
            
            Trace1(ERR, "Error: Attempt to queue work item returned:%d",    
                    Error);
            IgmpAssertOnError(FALSE);
                    
            --g_ActivityCount;
        }
    }

    LeaveCriticalSection(&g_CS);

    return Error;
}



//----------------------------------------------------------------------------
// Function:    EnterIgmpAPI
//
// This function is called to when entering a Igmp api, as well as
// when entering the input thread and timer thread.
// It checks to see if Igmp has stopped, and if so it quits; otherwise
// it increments the count of active threads.
//----------------------------------------------------------------------------

BOOL
EnterIgmpApi(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&g_CS);

    if (g_RunningStatus == IGMP_STATUS_RUNNING) {

        //
        // Igmp is running, so the API may continue
        //

        ++g_ActivityCount;

        bEntered = TRUE;
    }
    else {

        //
        // Igmp is not running, so the API exits quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&g_CS);

    return bEntered;
}




//----------------------------------------------------------------------------
// Function:    EnterIgmpWorker
//
// This function is called when entering a Igmp worker-function.
// Since there is a lapse between the time a worker-function is queued
// and the time the function is actually invoked by a worker thread,
// this function must check to see if Igmp has stopped or is stopping;
// if this is the case, then it decrements the activity count, 
// releases the activity semaphore, and quits.
//----------------------------------------------------------------------------

BOOL
EnterIgmpWorker(
    ) {

    BOOL bEntered;

    EnterCriticalSection(&g_CS);

    if (g_RunningStatus == IGMP_STATUS_RUNNING) {

        //
        // Igmp is running, so the function may continue
        //

        bEntered = TRUE;
    }
    else
    if (g_RunningStatus == IGMP_STATUS_STOPPING) {

        //
        // Igmp is not running, but it was, so the function must stop.
        // 

        --g_ActivityCount;

        ReleaseSemaphore(g_ActivitySemaphore, 1, NULL);

        bEntered = FALSE;
    }
    else {

        //
        // Igmp probably never started. quit quietly
        //

        bEntered = FALSE;
    }

    LeaveCriticalSection(&g_CS);

    return bEntered;
}


//----------------------------------------------------------------------------
// Function:    LeaveIgmpWorkApi
//
// This function is called when leaving a Igmp API. 
// It in turn calls LeaveIgmpWorker
//----------------------------------------------------------------------------
VOID
LeaveIgmpApi(
    ) {
    LeaveIgmpWorker();
    return;
}



//----------------------------------------------------------------------------
// Function:    LeaveIgmpWorker
//
// This function is called when leaving a Igmp API or worker function.
// It decrements the activity count, and if it detects that Igmp has stopped
// or is stopping, it releases the activity semaphore.
//----------------------------------------------------------------------------

VOID
LeaveIgmpWorker(
    ) {

    EnterCriticalSection(&g_CS);

    --g_ActivityCount;

    if (g_RunningStatus == IGMP_STATUS_STOPPING) {

        ReleaseSemaphore(g_ActivitySemaphore, 1, NULL);
    }

    LeaveCriticalSection(&g_CS);

}




//----------------------------------------------------------------------------
// Function:    CreateReadWriteLock
//
// Initializes a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

DWORD
CreateReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;

    try {
        InitializeCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    pRWL->RWL_ReaderDoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (pRWL->RWL_ReaderDoneEvent != NULL) {
        return GetLastError();
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    DeleteReadWriteLock
//
// Frees resources used by a multiple-reader/single-writer lock object
//----------------------------------------------------------------------------

VOID
DeleteReadWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    CloseHandle(pRWL->RWL_ReaderDoneEvent);
    pRWL->RWL_ReaderDoneEvent = NULL;
    DeleteCriticalSection(&pRWL->RWL_ReadWriteBlock);
    pRWL->RWL_ReaderCount = 0;
}




//----------------------------------------------------------------------------
// Function:    AcquireReadLock
//
// Secures shared ownership of the lock object for the caller.
//
// readers enter the read-write critical section, increment the count,
// and leave the critical section
//----------------------------------------------------------------------------

VOID
AcquireReadLock(
    PREAD_WRITE_LOCK pRWL
    ) {
    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock); 
    InterlockedIncrement(&pRWL->RWL_ReaderCount);
    LeaveCriticalSection(&pRWL->RWL_ReadWriteBlock);
}



//----------------------------------------------------------------------------
// Function:    ReleaseReadLock
//
// Relinquishes shared ownership of the lock object.
//
// the last reader sets the event to wake any waiting writers
//----------------------------------------------------------------------------

VOID
ReleaseReadLock (
    PREAD_WRITE_LOCK pRWL
    ) {

    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) < 0) {
        SetEvent(pRWL->RWL_ReaderDoneEvent); 
    }
}



//----------------------------------------------------------------------------
// Function:    AcquireWriteLock
//
// Secures exclusive ownership of the lock object.
//
// the writer blocks other threads by entering the ReadWriteBlock section,
// and then waits for any thread(s) owning the lock to finish
//----------------------------------------------------------------------------

VOID
AcquireWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    EnterCriticalSection(&pRWL->RWL_ReadWriteBlock);
    if (InterlockedDecrement(&pRWL->RWL_ReaderCount) >= 0) { 
        WaitForSingleObject(pRWL->RWL_ReaderDoneEvent, INFINITE);
    }
}






//----------------------------------------------------------------------------
// Function:    ReleaseWriteLock
//
// Relinquishes exclusive ownership of the lock object.
//
// the writer releases the lock by setting the count to zero
// and then leaving the ReadWriteBlock critical section
//----------------------------------------------------------------------------

VOID
ReleaseWriteLock(
    PREAD_WRITE_LOCK pRWL
    ) {

    pRWL->RWL_ReaderCount = 0;
    LeaveCriticalSection(&(pRWL)->RWL_ReadWriteBlock);
}





//------------------------------------------------------------------------------
//          _InitializeDynamicLocksStore
//
// Initialize the global struct from which dynamic CS or RW locks are allocated
//------------------------------------------------------------------------------

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE   pDLStore //ptr to Dynamic CS Store
    )
{
    DWORD Error = NO_ERROR;

    BEGIN_BREAKOUT_BLOCK1 {

        //
        // initialize the main CS lock which protects the list of free locks
        //
        
        try {
            InitializeCriticalSection(&pDLStore->CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Error = GetExceptionCode();
            Trace1(ERR, "Error initializing critical section in IGMPv2.dll",
                        Error);
            IgmpAssertOnError(FALSE);
            Logerr0(INIT_CRITSEC_FAILED, Error);
            
            GOTO_END_BLOCK1;
        }


        // initialize list of free locks
        
        InitializeListHead(&pDLStore->ListOfFreeLocks);


        // initialize counts for number of locks free and allocated to 0.
        
        pDLStore->CountAllocated = pDLStore->CountFree = 0;

        
    } END_BREAKOUT_BLOCK1;

    return Error;
}


//------------------------------------------------------------------------------
//          _DeInitializeDynamicLocksStore
//
// Delete the main CS lock and the other free locks. Print warning if any
// locks have been allocated and not freed.
//------------------------------------------------------------------------------
VOID
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pDLStore,
    LOCK_TYPE               LockType  //if True, then store of CS, else of RW locks
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock;
    PDYNAMIC_RW_LOCK    pDRWLock;
    PLIST_ENTRY         pHead, ple;

    
    Trace0(ENTER1, "Entering _DeInitializeDynamicLocksStore()");
    
    if (pDLStore==NULL)
        return;


        
    // delete the main CS lock
    
    DeleteCriticalSection(&pDLStore->CS);


    // print warning if any dynamic lock has not been freed
    
    if (pDLStore->CountAllocated>0) {
        Trace1(ERR, 
            "%d Dynamic locks have not been freed during Deinitialization",
            pDLStore->CountAllocated);
        IgmpAssertOnError(FALSE);
    }


    
    // delete all dynamic CS/RW locks. I dont free the memory (left to heapDestroy)
    
    pHead = &pDLStore->ListOfFreeLocks;
    for (ple=pHead->Flink;  ple!=pHead;  ) {
        
        // if bCSLocks flag, then it is a store of CS locks
        if (LockType==LOCK_TYPE_CS) {
        
            pDCSLock = CONTAINING_RECORD(ple, DYNAMIC_CS_LOCK, Link);
            ple = ple->Flink;

            DeleteCriticalSection(&pDCSLock->CS);
            IGMP_FREE(pDCSLock);
        }

        // delete the RW lock
        else {
        
            pDRWLock = CONTAINING_RECORD(ple, DYNAMIC_RW_LOCK, Link);
            ple = ple->Flink;

            DELETE_READ_WRITE_LOCK(&pDRWLock->RWL);
            IGMP_FREE(pDRWLock);
        }
    }

    Trace0(LEAVE1, "Leaving _DeInitializeDynamicLocksStore()");
    return;
}



//------------------------------------------------------------------------------
//          _AcquireDynamicCSLock
//
// Acquires the MainLock associated with the table, Acquires a new dynamic
// lock if required, increments the count, releases the MainLock and 
// locks the LockedList.
//------------------------------------------------------------------------------

DWORD
AcquireDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    )
{
    // acquire the main lock for the Dynamic CS store
    
    ENTER_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
            "_AcquireDynamicCSLock");


    //
    // If it is not already locked then allocate a lock
    //
    if (*ppDCSLock==NULL) {

        *ppDCSLock = GetDynamicCSLock(pDCSStore);


        // if could not get a lock, then igmp is in serious trouble
        
        if (*ppDCSLock==NULL) {
        
            LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                    "_AcquireDynamicCSLock");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    
    // increment Count in the Dynamic Lock

    (*ppDCSLock)->Count++;
    DYNAMIC_LOCK_CHECK_SIGNATURE_INCR(*ppDCSLock);


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                            "_AcquireDynamicCSLock");


    //
    // enter dynamic lock's CS lock
    //
    ENTER_CRITICAL_SECTION(&(*ppDCSLock)->CS, "pDynamicLock", 
        "_AcquireDynamicCSLock");
        
    
    return NO_ERROR;
    
} //end _AcquireDynamicCSLock



//------------------------------------------------------------------------------
//          _GetDynamicCSLock
//
// If a free lock is available, returns it. Else allocates a new CS lock
// Lock: Assumes the DCSStore MainLock
//------------------------------------------------------------------------------

PDYNAMIC_CS_LOCK
GetDynamicCSLock (
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock;
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         ple;
    
    
    //
    // free dynamic lock available. Return it
    //
    if (!IsListEmpty(&pDCSStore->ListOfFreeLocks)) {

        pDCSStore->CountFree--;
        pDCSStore->CountAllocated++;

        ple = RemoveTailList(&pDCSStore->ListOfFreeLocks);

        pDCSLock = CONTAINING_RECORD(ple, DYNAMIC_CS_LOCK, Link);
        
        /*Trace1(LEAVE1, "Leaving GetDynamicCSLock.1(%d):reusing lock", 
                pDCSLock->Id);
        */

        return pDCSLock;
    }


    // allocate memory for a new dynamic lock
    
    pDCSLock = IGMP_ALLOC(sizeof(DYNAMIC_CS_LOCK), 0x20000,0);

    PROCESS_ALLOC_FAILURE2(pDCSLock,
        "error %d allocating %d bytes for dynamic CS lock",
        Error, sizeof(DYNAMIC_CS_LOCK), 
        return NULL);


    pDCSStore->CountAllocated++;

    //
    // initialize the fields
    //
    
    try {
        InitializeCriticalSection(&pDCSLock->CS);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Error = GetExceptionCode();
        Trace1(ERR, 
            "Error(%d) initializing critical section for dynamic CS lock", 
            Error);
        IgmpAssertOnError(FALSE);
        Logerr0(INIT_CRITSEC_FAILED, Error);

        return NULL;
    }

    // no need to initialize the link field
    //InitializeListEntry(&pDCSLock->List);
    
    pDCSLock->Count = 0;
    #ifdef LOCK_DBG
        pDCSLock->Id = ++DynamicCSLockId;
    #endif
    DYNAMIC_LOCK_SET_SIGNATURE(pDCSLock);


    //Trace1(LEAVE1, "Leaving _GetDynamicCSLock(%d:%d):new lock", DynamicCSLockId);
    //Trace2(DYNLOCK, "CS: %d %d", pDCSLock->Id, DynamicCSLockId);

    return pDCSLock;
    
} //end _GetDynamicCSLock




//------------------------------------------------------------------------------
//          _ReleaseDynamicCSLock
//
// Acquires the MainLock associated with the table, decrements the count, 
// releases the DynamicLock if count becomes 0 and releases the MainLock.
//------------------------------------------------------------------------------
VOID
ReleaseDynamicCSLock (
    PDYNAMIC_CS_LOCK    *ppDCSLock,
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    PDYNAMIC_CS_LOCK    pDCSLock = *ppDCSLock;
    
    
    // acquire the main lock for the Dynamic CS store
    
    ENTER_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
                        "_ReleaseDynamicCSLock");

    DYNAMIC_LOCK_CHECK_SIGNATURE_DECR(pDCSLock);


    // leave the dynamic lock CS
    
    LEAVE_CRITICAL_SECTION(&pDCSLock->CS, "pDynamicLock", 
                        "_ReleaseDynamicCSLock");


          
    // Decrement Count in the Dynamic Lock. Free the dynamic lock if count==0
  
    if (--pDCSLock->Count==0) {

        FreeDynamicCSLock(pDCSLock, pDCSStore);

        // make the pDCSLock NULL so that it is known that it is not locked
        *ppDCSLock = NULL;
        
    }


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDCSStore->CS, "pDCSStore->CS", 
            "_ReleaseDynamicCSLock");

            
    //Trace0(LEAVE1, "Leaving _ReleaseDynamicCSLock()");

    return;
    
} //end _ReleaseDynamicCSLock


//------------------------------------------------------------------------------
//          _FreeDynamicCSLock
//------------------------------------------------------------------------------
VOID
FreeDynamicCSLock (
    PDYNAMIC_CS_LOCK    pDCSLock,
    PDYNAMIC_LOCKS_STORE   pDCSStore
    )
{
    // decrement count of allocated locks
    
    pDCSStore->CountAllocated--;

    // if there are too many dynamic CS locks, then free this lock
    
    if (pDCSStore->CountFree+1 
            > DYNAMIC_LOCKS_HIGH_THRESHOLD) 
    {
        DeleteCriticalSection(&pDCSLock->CS);
        IGMP_FREE(pDCSLock);
    }

    // else put it into the list of free locks
    
    else {
        InsertHeadList(&pDCSStore->ListOfFreeLocks, &pDCSLock->Link);
        pDCSStore->CountFree++;
    }

    return;
}


    

//------------------------------------------------------------------------------
//          _AcquireDynamicRWLock
//
// Acquires the MainLock associated with the table, Acquires a new dynamic
// lock if required, increments the count, releases the MainLock and 
// locks the LockedList.
//------------------------------------------------------------------------------
DWORD
AcquireDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    )
{
    //Trace0(ENTER1, "Entering _AcquireDynamicRWLock()");


    // acquire the main lock for the Dynamic RW store
    
    ENTER_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
            "AcquireDynamicRWLock");


    //
    // If it is not already locked then allocate a lock
    //
    if (*ppDRWLock==NULL) {

        *ppDRWLock = GetDynamicRWLock(pDRWStore);

    //Trace1(DYNLOCK, "Acquired dynamicRWLock(%d)", (*ppDRWLock)->Id);


        // if could not get a lock, then igmp is in serious trouble
        
        if (*ppDRWLock==NULL) {
        
            LEAVE_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
                    "AcquireDynamicRWLock");

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    else
        ;//Trace1(DYNLOCK, "Acquired existing dynamicRWLock(%d)", (*ppDRWLock)->Id);

    
    // increment Count in the Dynamic Lock

    (*ppDRWLock)->Count++;
    DYNAMIC_LOCK_CHECK_SIGNATURE_INCR(*ppDRWLock);
    

    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
                        "_AcquireDynamicRWLock");


    //
    // acquire dynamic lock
    //
    if (LockMode==LOCK_MODE_READ) {
        ACQUIRE_READ_LOCK(&(*ppDRWLock)->RWL, "pDynamicLock(Read)", 
            "_AcquireDynamicRWLock");
    }
    else {
        ACQUIRE_WRITE_LOCK(&(*ppDRWLock)->RWL, "pDynamicLock(Write)", 
            "_AcquireDynamicRWLock");
    }
    
    return NO_ERROR;
    
} //end _AcquireDynamicRWLock


//------------------------------------------------------------------------------
//          _GetDynamicRWLock
//
// If a free lock is available, returns it. Else allocates a new CS lock
// Lock: assumes the DRWStore MainLock
//------------------------------------------------------------------------------
PDYNAMIC_RW_LOCK
GetDynamicRWLock (
    PDYNAMIC_LOCKS_STORE   pDRWStore
    )
{
    PDYNAMIC_RW_LOCK    pDRWLock;
    DWORD               Error = NO_ERROR;
    PLIST_ENTRY         ple;
    

    //
    // free dynamic lock available. Return it
    //
    if (!IsListEmpty(&pDRWStore->ListOfFreeLocks)) {

        pDRWStore->CountFree--;
        pDRWStore->CountAllocated++;

        ple = RemoveTailList(&pDRWStore->ListOfFreeLocks);

        pDRWLock = CONTAINING_RECORD(ple, DYNAMIC_RW_LOCK, Link);

        /*Trace1(LEAVE1, "Leaving GetDynamicRWLock(%d):reusing lock", 
                pDRWLock->Id);
        Trace2(DYNLOCK, "--------------------%d %d", pDRWLock->Id, DynamicRWLockId);
        */
        return pDRWLock;
    }


    // allocate memory for a new dynamic lock
    
    pDRWLock = IGMP_ALLOC(sizeof(DYNAMIC_RW_LOCK), 0x40000,0);

    PROCESS_ALLOC_FAILURE2(pDRWLock,
        "error %d allocating %d bytes for dynamic RW lock",
        Error, sizeof(DYNAMIC_RW_LOCK),
        return NULL);


    //
    // initialize the fields
    //
    
    try {
        CREATE_READ_WRITE_LOCK(&pDRWLock->RWL);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Error = GetExceptionCode();
        Trace1(ERR, 
            "Error(%d) initializing critical section for dynamic RW lock", Error);
        IgmpAssertOnError(FALSE);
        Logerr0(INIT_CRITSEC_FAILED, Error);

        return NULL;
    }

    // no need to initialize the link field
    //InitializeListEntry(&pDRWLock->List);
    
    pDRWLock->Count = 0;
    #ifdef LOCK_DBG
        pDRWLock->Id = ++DynamicRWLockId;
    #endif
    DYNAMIC_LOCK_SET_SIGNATURE(pDRWLock);
    
    pDRWStore->CountAllocated++;

    //Trace1(LEAVE1, "Leaving GetDynamicRWLock(%d):new lock", DynamicRWLockId);
    //Trace2(DYNLOCK, "--------------------%d %d", pDRWLock->Id, DynamicRWLockId);

    return pDRWLock;
    
} //end _GetDynamicRWLock




//------------------------------------------------------------------------------
//          _ReleaseDynamicRWLock
//
// Acquires the MainLock associated with the table, decrements the count, 
// releases the DynamicLock if count becomes 0 and releases the MainLock.
//------------------------------------------------------------------------------

VOID
ReleaseDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    )
{
    PDYNAMIC_RW_LOCK    pDRWLock = *ppDRWLock;
    
    
    // acquire the main lock for the Dynamic RW store
    
    ENTER_CRITICAL_SECTION(&pDRWStore->CS, "pDRWStore->CS", 
                            "_ReleaseDynamicRWLock");

    IgmpAssert(pDRWLock!=NULL);//deldel
    #if DBG
    if (pDRWLock==NULL)
        DbgBreakPoint();
    #endif
    DYNAMIC_LOCK_CHECK_SIGNATURE_DECR(pDRWLock);

    
    // leave the dynamic RW lock
    if (LockMode==LOCK_MODE_READ) {
        RELEASE_READ_LOCK(&pDRWLock->RWL, "pDynamicLock(read)", 
                            "_ReleaseDynamicRWLock");
    }
    else {
        RELEASE_WRITE_LOCK(&pDRWLock->RWL, "pDynamicLock(write)", 
                            "_ReleaseDynamicRWLock");
    }                        
          
    // Decrement Count in the Dynamic Lock. Free the dynamic lock if count==0

    if (--pDRWLock->Count==0) {

        FreeDynamicRWLock(pDRWLock, pDRWStore);

        // make the pDRWLock NULL so that it is known that it is not locked
        *ppDRWLock = NULL;
        
    }


    // leave main CS lock
    
    LEAVE_CRITICAL_SECTION(&pDRWStore->CS, "pDCSStore->CS", 
            "_ReleaseDynamicRWLock");

    return;
    
} //end _ReleaseDynamicRWLock


//------------------------------------------------------------------------------
//          _FreeDynamicRWLock
//------------------------------------------------------------------------------

VOID
FreeDynamicRWLock (
    PDYNAMIC_RW_LOCK        pDRWLock,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    )
{
    // decrement count of allocated locks
    
    pDRWStore->CountAllocated--;


    // if there are too many dynamic RW locks, then free this lock
    
    if (pDRWStore->CountFree+1 
            > DYNAMIC_LOCKS_HIGH_THRESHOLD) 
    {
        DELETE_READ_WRITE_LOCK(&pDRWLock->RWL);
        IGMP_FREE(pDRWLock);
    }

    // else put it into the list of free locks
    
    else {
        InsertHeadList(&pDRWStore->ListOfFreeLocks, &pDRWLock->Link);
        pDRWStore->CountFree++;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\packet.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: packet.c
//
// Abstract:
//      This module contains declarations for packet.c
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#ifndef _PACKET_H_
#define _PACKET_H_

DWORD
SendPacket (
    PIF_TABLE_ENTRY  pite,
    PGI_ENTRY        pgie,
    DWORD            PacketType,  //MSG_GEN_QUERY, MSG_GROUP_QUERY_V2(v3),SOURCES_Q
    DWORD            Group        //destination McastGrp
    );    

DWORD
JoinMulticastGroup (
    SOCKET   Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    DWORD    dwIpAddr,
    IPADDR   Source
    );    

    
DWORD
LeaveMulticastGroup (
    SOCKET    Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    DWORD    dwIpAddr,
    IPADDR   Source
    );
    
DWORD
BlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    );

DWORD
UnBlockSource (
    SOCKET Sock,
    DWORD    dwGroup,
    DWORD    IfIndex,
    IPADDR   IpAddr,
    IPADDR   Source
    );

DWORD
McastSetTtl(
    SOCKET sock,
    UCHAR ttl
    );

//
//    packet context struct
//
typedef struct _PACKET_CONTEXT {

    DWORD           IfIndex;
    DWORD           DstnMcastAddr;
    DWORD           InputSrc;
    DWORD           Length;
    DWORD           Flags;
    BYTE            Packet[1];

} PACKET_CONTEXT, *PPACKET_CONTEXT;

#define CREATE_PACKET_CONTEXT(ptr, pktLen, Error) {\
    ptr = IGMP_ALLOC(sizeof(PACKET_CONTEXT)+(pktLen)-1,0xa0000,0xaaaa);\
    if (ptr==NULL) {    \
        Error = GetLastError();    \
        Trace2(ANY, "Error %d allocating %d bytes for Work context", \
                Error, sizeof(PACKET_CONTEXT)+(pktLen)-1); \
        Logerr0(HEAP_ALLOC_FAILED, Error); \
    } \
}


#pragma pack(1)

// Structure of an IGMP header.
typedef struct _IGMP_HEADER {

    UCHAR       Vertype;              //  Type of igmp message
    UCHAR       ResponseTime;         // max. resp. time for igmpv2 messages; will be 0
    USHORT      Xsum;
    union {
        DWORD       Group;
        struct {
            USHORT      Reserved;
            USHORT      NumGroupRecords;
        };
    };
} IGMP_HEADER, *PIGMP_HEADER;


#define MIN_PACKET_SIZE     sizeof(IGMP_HEADER)
#define INPUT_PACKET_SZ     1000
#define IPVERSION           4


typedef struct _IGMP_HEADER_V3_EXT {
    BYTE        QRV      :3;
    BYTE        SFlag    :1;
    BYTE        Reserved :4;
    BYTE        QQIC;
    USHORT      NumSources;
    IPADDR      Sources[0];
    
} IGMP_HEADER_V3_EXT, *PIGMP_HEADER_V3_EXT;


#define GET_QQIC_FROM_CODE(qqic) qqic <= 127? qqic : ((qqic&0x0f) + 16) << ((qqic&0x70) + 3)

//
// GROUP_RECORD
//
typedef struct _GROUP_RECORD {

    UCHAR       RecordType;
    UCHAR       AuxDataLength;
    USHORT      NumSources;
    IPADDR      Group;
    IPADDR      Sources[0];

} GROUP_RECORD, *PGROUP_RECORD;

#define GET_GROUP_RECORD_SIZE(pGroupRecord) \
    (pGroupRecord->NumSources+2)*sizeof(IPADDR))

#define GET_FIRST_GROUP_RECORD(pHdr) \
    (PGROUP_RECORD)((PCHAR)(pHdr)+MIN_PACKET_SIZE)
    
#define GET_NEXT_GROUP_RECORD(pGroupRecord) \
    ((PGROUP_RECORD) ((UCHAR)pGroupRecord + \
                    GET_GROUP_RECORD_SIZE(pGroupRecord)))

#define IS_IN    1
#define IS_EX   2
#define TO_IN   3
#define TO_EX   4
#define ALLOW  5
#define BLOCK     6


typedef struct _IP_HEADER {

    UCHAR              Hl;              // Version and length.
    UCHAR              Tos;             // Type of service.
    USHORT             Len;             // Total length of datagram.
    USHORT             Id;              // Identification.
    USHORT             Offset;          // Flags and fragment offset.
    UCHAR              Ttl;             // Time to live.
    UCHAR              Protocol;        // Protocol.
    USHORT             Xsum;            // Header checksum.
    struct in_addr     Src;             // Source address.
    struct in_addr     Dstn;            // Destination address.
    
} IP_HEADER, *PIP_HEADER;

#pragma pack()


//
//    MACROS
//

//
// message types// work types
//
#define MSG_GEN_QUERY           1
#define MSG_GROUP_QUERY_V2         2
#define MSG_REPORT              3
#define MSG_LEAVE               4
#define MSG_SOURCES_QUERY       5
#define MSG_GROUP_QUERY_V3      6

#define DELETE_MEMBERSHIP       11
#define DELETE_SOURCE           12
#define SHIFT_TO_V3             13
#define MOVE_SOURCE_TO_EXCL     14

#define PROXY_PRUNE             100
#define PROXY_JOIN              101


//
// igmp type field
//
#define     IGMP_QUERY          0x11    //Membership query
#define     IGMP_REPORT_V1      0x12    //Version 1 membership report
#define     IGMP_REPORT_V2      0x16    //Version 2 membership report
#define     IGMP_LEAVE          0x17    //Leave Group
#define     IGMP_REPORT_V3      0x22    //Version 3 membership report

//
// igmp version
//
#define     IGMPV1              2       //IGMP version 1
#define     IGMPV2              3       //IGMP version 2



//
// igmp multicast groups
//
#define     ALL_HOSTS_MCAST      0x010000E0
#define     ALL_ROUTERS_MCAST    0x020000E0
#define     ALL_IGMP_ROUTERS_MCAST  0x160000E0


//
// message macros
//
#define SEND_GEN_QUERY(pite) \
    SendPacket(pite, NULL, MSG_GEN_QUERY, 0)

#define SEND_GROUP_QUERY_V2(pite, Group) \
    SendPacket(pite, NULL, MSG_GROUP_QUERY_V2, Group)
    
#define SEND_GROUP_QUERY_V3(pite, pgie, Group) \
    SendPacket(pite, pgie, MSG_GROUP_QUERY_V3, Group)

#define SEND_SOURCES_QUERY(pgie) \
    SendPacket((pgie)->pIfTableEntry, pgie, MSG_SOURCES_QUERY, (pgie)->pGroupTableEntry->Group)
    

// 224.0.0.0 < group <240.0.0.0
// 
#define IS_MCAST_ADDR(Group) \
    ( (0x000000E0!=(Group))  \
      && (0x000000E0 <= ((Group)&0x000000FF) ) \
      && (0x000000F0 >  ((Group)&0x000000FF) ) ) 


//
// is the group 224.0.0.x
//
#define LOCAL_MCAST_GROUP(Group) \
    (((Group)&0x00FFFFFF) == 0x000000E0)

#define SSM_MCAST_GROUP(Group) \
    (((Group)&0x000000FF) == 0x000000E8)

USHORT
xsum(
    PVOID Buffer, 
    INT Size
    );


#endif //_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\sync.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
// File: sync.h
//
// History:
//      Abolade Gbadegesin
//      K.S.Lokesh (added Dynamic Locking)
//
// Contains structures and macros used to implement synchronization.
//============================================================================

#ifndef _SYNC_H_
#define _SYNC_H_


//
// type definition for multiple-reader/single-writer lock
// Note: there is a similar facility provided by nturtl.h
// through the structure RTL_RESOURCE and several functions.
// However, that implementation has the potential for starving
// a thread trying to acquire write accesss, if there are a large
// number of threads interested in acquiring read access.
// Such a scenario is avoided in the implementation given in this
// header. However, a mapping is also given to the RTL_RESOURCE
// functionality, so that IGMP can be compiled to use either form
//

#ifdef IGMP_RWL

//
// use IGMP's definitions
//

typedef struct _READ_WRITE_LOCK {

    CRITICAL_SECTION    RWL_ReadWriteBlock;
    LONG                RWL_ReaderCount;
    HANDLE              RWL_ReaderDoneEvent;

} READ_WRITE_LOCK, *PREAD_WRITE_LOCK;


DWORD CreateReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID DeleteReadWriteLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireReadLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseReadLock(PREAD_WRITE_LOCK pRWL);
VOID AcquireWriteLock(PREAD_WRITE_LOCK pRWL);
VOID ReleaseWriteLock(PREAD_WRITE_LOCK pRWL);


//
// macro functions for manipulating a read-write lock
//

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
    CreateReadWriteLock(pRWL)
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
    DeleteReadWriteLock(pRWL)

#define READ_WRITE_LOCK_CREATED(pRWL)                                       \
            ((pRWL)->RWL_ReaderDoneEvent != NULL)


// print locks.
#ifdef LOCK_DBG

#define ACQUIRE_READ_LOCK(pRWL, type, proc)   {\
    Trace2(CS,"----to AcquireReadLock %s in %s", type, proc); \
    AcquireReadLock(pRWL); \
    Trace2(CS,"----GotReadLock %s in %s", type, proc); \
    }


#define RELEASE_READ_LOCK(pRWL, type, proc)    {\
    Trace2(CS,"----Released ReadLock %s in %s", type, proc); \
    ReleaseReadLock(pRWL); \
    }
    

#define ACQUIRE_WRITE_LOCK(pRWL, type, proc)      {\
    Trace2(CS,"----to AcquireWriteLock %s in %s", type, proc); \
    AcquireWriteLock(pRWL);    \
    Trace2(CS,"----AcquiredWriteLock %s in %s", type, proc);\
    }
    

#define RELEASE_WRITE_LOCK(pRWL, type, proc)     {\
    Trace2(CS,"----Released WriteLock %s in %s", type, proc); \
    ReleaseWriteLock(pRWL);\
    }


#else //LOCK_DBG
#define ACQUIRE_READ_LOCK(pRWL, type, proc)   \
    AcquireReadLock(pRWL)


#define RELEASE_READ_LOCK(pRWL, type, proc)    \
    ReleaseReadLock(pRWL)
    

#define ACQUIRE_WRITE_LOCK(pRWL, type, proc)      \
    AcquireWriteLock(pRWL)
    

#define RELEASE_WRITE_LOCK(pRWL, type, proc)     \
    ReleaseWriteLock(pRWL)


#endif //LOCK_DBG
#define READ_LOCK_TO_WRITE_LOCK(pRWL, type, proc)                                       \
    (RELEASE_READ_LOCK(pRWL, type, proc), ACQUIRE_WRITE_LOCK(pRWL, type, proc))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
    (RELEASE_WRITE_LOCK(pRWL, type, proc), ACQUIRE_READ_LOCK(pRWL, type, proc))

#else // i.e. !IGMP_RWL


//
// use the RTL_RESOURCE mechanism
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))
#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))
#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)
#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)
#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))
#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)
#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))
#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))
#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

#endif // IGMP_RWL



//
// type definition for generic locked list
// access is sychronized with a critical section
//

typedef struct _LOCKED_LIST {
    LIST_ENTRY          Link;
    CRITICAL_SECTION    Lock;
    DWORD               CreatedFlag;
} LOCKED_LIST, *PLOCKED_LIST;



//
// macro functions for manipulating the locked list
//

#define CREATE_LOCKED_LIST(pLL)      {\
            InitializeListHead(&(pLL)->Link);        \
            InitializeCriticalSection(&(pLL)->Lock);  \
            (pLL)->CreatedFlag = 0x12345678; \
            }

#define LOCKED_LIST_CREATED(pLL)                            \
            ((pLL)->CreatedFlag == 0x12345678)

#define DELETE_LOCKED_LIST(pLL,type,field) {                \
            PLIST_ENTRY _ple;                               \
            (pLL)->CreatedFlag = 0;                          \
            DeleteCriticalSection(&(pLL)->Lock);         \
            while (!IsListEmpty(&(pLL)->Link)) {         \
                _ple = RemoveHeadList(&(pLL)->Link);     \
                IGMP_FREE(CONTAINING_RECORD(_ple,type,field));\
            }                                               \
        }

        

#define ACQUIRE_LIST_LOCK(pLL, type, name)                              \
            ENTER_CRITICAL_SECTION(&(pLL)->Lock, type, name)

#define RELEASE_LIST_LOCK(pLL, type, name)                              \
            LEAVE_CRITICAL_SECTION(&(pLL)->Lock, type, name)

















// for debugging, Set ids for each dynamic lock

#ifdef LOCK_DBG
    extern DWORD    DynamicCSLockId;
    extern DWORD    DynamicRWLockId;
#endif;

typedef enum {
    LOCK_TYPE_CS, LOCK_TYPE_RW, LOCK_MODE_READ, LOCK_MODE_WRITE
} LOCK_TYPE; 

    
//-----------------------------------------------------------------
//          struct DYNAMIC_CS_LOCK
//
// the dynamic lock struct which is allocated to anyone requesting it
//-----------------------------------------------------------------
typedef struct _DYNAMIC_CS_LOCK {

    CRITICAL_SECTION    CS;

    DWORD               Count; // number of threads waiting
    LIST_ENTRY          Link;  // link in list of free entries
    
    #ifdef LOCK_DBG
    DWORD               Id;
    #endif

    #if DEBUG_FLAGS_SIGNATURE
    DWORD               Signature;//0xfadfad03
    DWORD               InAndOut;
    #endif
    
} DYNAMIC_CS_LOCK, *PDYNAMIC_CS_LOCK;

#if DEBUG_FLAGS_SIGNATURE

#define DYNAMIC_LOCK_SET_SIGNATURE(pDCSLock) {\
    (pDCSLock)->Signature = 0xfadfad03;\
    (pDCSLock)->InAndOut = 0;\
    }
#define DYNAMIC_LOCK_CHECK_SIGNATURE_DECR(pDCSLock) {\
    if ((pDCSLock)->Signature!=0xfadfad03) \
        DbgBreakPoint(); \
    if ((pDCSLock)->InAndOut--<=0) DbgBreakPoint(); \
    }
#define DYNAMIC_LOCK_CHECK_SIGNATURE_INCR(pDCSLock) \
    if (++(pDCSLock)->InAndOut == 0) DbgBreakPoint();
#else
#define DYNAMIC_LOCK_SET_SIGNATURE(pDCSLock)
#define DYNAMIC_LOCK_CHECK_SIGNATURE_DECR(pDCSLock)
#define DYNAMIC_LOCK_CHECK_SIGNATURE_INCR(pDCSLock)
#endif //DEBUG_FLAGS_SIGNATURE


//---------------------------------------
// DYNAMICALLY_LOCKED_HASH_TABLE
// AcquireDynamicCSLockedList and ReleaseDynamicCSLock depend on this struct defn
//---------------------------------------
typedef struct _DYNAMIC_CS_LOCKED_LIST {

    LIST_ENTRY          Link;
    PDYNAMIC_CS_LOCK    pDCSLock;

} DYNAMIC_CS_LOCKED_LIST, *PDYNAMIC_CS_LOCKED_LIST;



#define InitDynamicCSLockedList(pDCSLockedList) { \
            InitializeListHead(&(pDCSLockedList)->Link); \
            (pDCSLockedList)->pDCSLock = NULL; \
        } 


        
//
// if more than DYNAMIC_LOCKS_HIGH_THRESHOLD CS locks allocated
// then any locks that are freed are destroyed
//
#define DYNAMIC_LOCKS_HIGH_THRESHOLD 7



//-----------------------------------------------------------------
//          struct DYNAMIC_LOCKS_STORE
//
// Contains the store of free dynamic CS locks which can be 
// allocated when required. Protected by a CS
//-----------------------------------------------------------------
typedef struct _DYNAMIC_LOCKS_STORE {

    CRITICAL_SECTION    CS;
    LIST_ENTRY          ListOfFreeLocks;

    DWORD               CountAllocated;
    DWORD               CountFree;
    
} DYNAMIC_LOCKS_STORE, *PDYNAMIC_LOCKS_STORE;



#define AcquireDynamicCSLockedList(pDCSLockedList, pDCSStore) \
            AcquireDynamicCSLock(&((pDCSLockedList)->pDCSLock), pDCSStore)

#define ReleaseDynamicCSLockedList(pDCSLockedList, pDCSStore) \
            ReleaseDynamicCSLock(&(pDCSLockedList)->pDCSLock, pDCSStore)









//-----------------------------------------------------------------
//          struct DYNAMIC_RW_LOCK
//
// the dynamic lock struct which is allocated to anyone requesting it
//-----------------------------------------------------------------
typedef struct _DYNAMIC_RW_LOCK {

    READ_WRITE_LOCK     RWL;

    DWORD               Count; // number of threads waiting
    LIST_ENTRY          Link;  // link in list of free entries
    
    #ifdef LOCK_DBG
    DWORD               Id;
    #endif
    #if DEBUG_FLAGS_SIGNATURE
    DWORD               Signature;//0xfadfad03
    DWORD               InAndOut;
    #endif
    
} DYNAMIC_RW_LOCK, *PDYNAMIC_RW_LOCK;


//---------------------------------------
// DYNAMICALLY_LOCKED_HASH_TABLE
// AcquireDynamicRWLockedList and ReleaseDynamicRWLock depend on this struct defn
//---------------------------------------
typedef struct _DYNAMIC_RW_LOCKED_LIST {

    LIST_ENTRY          Link;
    PDYNAMIC_RW_LOCK    pDRWLock;

} DYNAMIC_RW_LOCKED_LIST, *PDYNAMIC_RW_LOCKED_LIST;



#define InitDynamicRWLockedList(pDRWLockedList) { \
            InitializeListHead(&(pDRWLockedList)->Link); \
            (pDRWLockedList)->pDRWLock = NULL; \
        } 


#define AcquireDynamicRWLockedList(pDRWLockedList, pDRWStore) \
            AcquireDynamicCSLock(&((pDRWLockedList)->pDRWLock), pDRWStore)

#define ReleaseDynamicRWLockedList(pDRWLockedList, pDRWStore) \
            ReleaseDynamicRWLock(&(pDRWLockedList)->pDRWLock, pDRWStore)





//
// PROTOTYPES
//

DWORD
InitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pDLStore //ptr to Dynamic CS Store
    );

VOID
DeInitializeDynamicLocksStore (
    PDYNAMIC_LOCKS_STORE    pDCSStore,
    LOCK_TYPE               LockType  //if True, then store of CS, else of RW locks
    );

DWORD
AcquireDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );

PDYNAMIC_CS_LOCK
GetDynamicCSLock (
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );

VOID
ReleaseDynamicCSLock (
    PDYNAMIC_CS_LOCK        *ppDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );

VOID
FreeDynamicCSLock (
    PDYNAMIC_CS_LOCK        pDCSLock,
    PDYNAMIC_LOCKS_STORE    pDCSStore
    );


DWORD
AcquireDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    );

PDYNAMIC_RW_LOCK
GetDynamicRWLock (
    PDYNAMIC_LOCKS_STORE   pDRWStore
    );

VOID
ReleaseDynamicRWLock (
    PDYNAMIC_RW_LOCK        *ppDRWLock,
    LOCK_TYPE               LockMode,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    );
    
VOID
FreeDynamicRWLock (
    PDYNAMIC_RW_LOCK        pDRWLock,
    PDYNAMIC_LOCKS_STORE    pDRWStore
    );
    
BOOL  EnterIgmpApi();
VOID  LeaveIgmpApi();
DWORD QueueIgmpWorker();
BOOL  EnterIgmpWorker();
VOID  LeaveIgmpWorker();









#endif // _SYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\table.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: table.h
//
// Abstract:
//      This module contains declarations for interface and group table 
//      structures, related macros, and function prototypes.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#ifndef _IGMP_TABLE_H_
#define _IGMP_TABLE_H_


//
// forward declarations
//
struct _IF_TABLE_ENTRY;
struct _GROUP_TABLE_ENTRY;
struct _GI_ENTRY;


//
// struct:   GLOBAL_CONFIG (same as mib structs in igmprm.h)   
//
typedef  IGMP_MIB_GLOBAL_CONFIG      GLOBAL_CONFIG;
typedef  PIGMP_MIB_GLOBAL_CONFIG     PGLOBAL_CONFIG; 




//---------------------------------------------------
// struct:    IGMP_GLOBAL_STATS
//---------------------------------------------------

typedef struct _GLOBAL_STATS {

    DWORD                CurrentGroupMemberships;
    DWORD                GroupMembershipsAdded;
    LARGE_INTEGER        TimeWhenRtrStarted;

} IGMP_GLOBAL_STATS, *PIGMP_GLOBAL_STATS;





//-------------------------------------------------
// static group structures(external)
//-------------------------------------------------

typedef struct _STATIC_GROUP_V3 {
    IGMP_STATIC_GROUP_V3;
    DWORD       Sources[0];
    
} STATIC_GROUP_V3, *PSTATIC_GROUP_V3;

typedef struct _MIB_GROUP_INFO_V3 {
    IGMP_MIB_GROUP_INFO_V3;
    IGMP_MIB_GROUP_SOURCE_INFO_V3      Sources[0];
    
} MIB_GROUP_INFO_V3, *PMIB_GROUP_INFO_V3;

typedef PIGMP_MIB_GROUP_INFO PMIB_GROUP_INFO;
typedef IGMP_MIB_GROUP_INFO MIB_GROUP_INFO;


#define GET_FIRST_STATIC_GROUP_V3(pConfig) \
                        ((PSTATIC_GROUP_V3)((PIGMP_MIB_IF_CONFIG)(pConfig)+1))

#define GET_NEXT_STATIC_GROUP_V3(pStaticGroupV3) \
    ((PSTATIC_GROUP_V3) ((PCHAR)pStaticGroupV3+sizeof(IGMP_STATIC_GROUP_V3) \
                            +sizeof(IPADDR)*pStaticGroupV3->NumSources))

//----------------------------------------------------------------------------
// struct:      IF_STATIC_GROUP
//----------------------------------------------------------------------------

typedef struct _IF_STATIC_GROUP {

    LIST_ENTRY              Link;
    STATIC_GROUP_V3;
    
} IF_STATIC_GROUP, *PIF_STATIC_GROUP;




//---------------------------------------------------------------
// struct:    IGMP_IF_CONFIG (same as mib structs in igmprm.h)
//
// if they are made different, then CopyMemory should not be used
//---------------------------------------------------------------

typedef struct _IGMP_IF_CONFIG {

    IGMP_MIB_IF_CONFIG;

    //v3: NonQuerier saves old values
    DWORD               RobustnessVariableOld;
    DWORD               GenQueryIntervalOld;
    DWORD               OtherQuerierPresentIntervalOld;
    DWORD               GroupMembershipTimeoutOld;

    DWORD       ExtSize;
    LIST_ENTRY  ListOfStaticGroups;

} IGMP_IF_CONFIG, *PIGMP_IF_CONFIG;



//---------------------------------------------------
// struct:     IF_INFO
//---------------------------------------------------
typedef struct _IF_INFO {

    UCHAR               QuerierState;       //if made DWORD, then change to interlocked operations
    DWORD               QuerierIpAddr;
    
    LONGLONG            QuerierPresentTimeout;    //when the last query was heard. only if I am not querier
    LONGLONG            LastQuerierChangeTime;       // when the last querier was changed
    LONGLONG            V1QuerierPresentTime; //when the last v1 query was heard
    LONGLONG            OtherVerPresentTimeWarn; //when the last warning was given
        
    DWORD               StartupQueryCountCurrent;

    DWORD               GroupQueriesSent;
    DWORD               GroupQueriesReceived;

    LONGLONG            TimeWhenActivated;
    DWORD               TotalIgmpPacketsReceived;
    DWORD               TotalIgmpPacketsForRouter;
    DWORD               GenQueriesSent;
    DWORD               GenQueriesReceived;
    DWORD               WrongVersionQueries;
    DWORD               JoinsReceived;
    DWORD               LeavesReceived;
    DWORD               CurrentGroupMemberships;
    DWORD               GroupMembershipsAdded;
    DWORD               WrongChecksumPackets;
    DWORD               ShortPacketsReceived;
    DWORD               LongPacketsReceived;
    DWORD               PacketsWithoutRtrAlert;
    DWORD               PacketSize;
    
} IF_INFO, *PIF_INFO;


//---------------------------------------------------
// struct      RAS_CLIENT_INFO
//---------------------------------------------------

typedef struct _RAS_CLIENT_INFO {

    DWORD               SendFailures;
    DWORD               TotalIgmpPacketsReceived;
    DWORD               TotalIgmpPacketsForRouter;
    DWORD               GenQueriesReceived;
    DWORD               JoinsReceived;
    DWORD               LeavesReceived;
    DWORD               CurrentGroupMemberships;
    DWORD               GroupMembershipsAdded;
    DWORD               GroupMembershipsRemoved;
    DWORD               WrongChecksumPackets;
    DWORD               ShortPacketsReceived;
    DWORD               LongPacketsReceived;
    DWORD               WrongVersionQueries;
    
} RAS_CLIENT_INFO, *PRAS_CLIENT_INFO;


//---------------------------------------------------
// struct:         RAS_TABLE_ENTRY
//---------------------------------------------------

typedef struct _RAS_TABLE_ENTRY {

    LIST_ENTRY              LinkByAddr;
    LIST_ENTRY              HTLinkByAddr;
    LIST_ENTRY              ListOfSameClientGroups;

    DWORD                   NHAddr;
    struct _IF_TABLE_ENTRY *IfTableEntry;
    
    DWORD                   Status;
    RAS_CLIENT_INFO         Info;

} RAS_TABLE_ENTRY, *PRAS_TABLE_ENTRY;



//---------------------------------------------------
// struct:        RAS_TABLE
//---------------------------------------------------

#define RAS_HASH_TABLE_SZ    256
typedef struct _RAS_TABLE {

    LIST_ENTRY              ListByAddr;                         //links ras clients
    LIST_ENTRY              HashTableByAddr[RAS_HASH_TABLE_SZ];
        
    struct _IF_TABLE_ENTRY  *pIfTable;          //ptr to interface table entry

    DWORD                   RefCount;
    DWORD                   Status;

} RAS_TABLE, *PRAS_TABLE;





//---------------------------------------------------
// struct:    SOCKET_EVENT_ENTRY
//---------------------------------------------------

typedef struct _SOCKET_EVENT_ENTRY {

    LIST_ENTRY          LinkBySocketEvents;

    LIST_ENTRY          ListOfInterfaces;
    DWORD               NumInterfaces;

    HANDLE              InputWaitEvent;
    HANDLE              InputEvent;
    
} SOCKET_EVENT_ENTRY, *PSOCKET_EVENT_ENTRY;    




//---------------------------------------------------
// struct:    SOCKET_ENTRY
//---------------------------------------------------

typedef struct _SOCKET_ENTRY {

    LIST_ENTRY              LinkByInterfaces;

    SOCKET                  Socket;
    PSOCKET_EVENT_ENTRY     pSocketEventsEntry;
    
} SOCKET_ENTRY, *PSOCKET_ENTRY;    
    




//------------------------------------------------------------------------------
// struct:      IF_TABLE_ENTRY
//
// IF-table:Table_RWL          protects LinkByAddr, LinkByIndex, HTLinkByIndex
//                                      IpAddr, Status, pBinding
// IF-table:IfTableBucketCS protects ListOfSameIfGroups
// Interlocked operations      protect  Info, Config
//------------------------------------------------------------------------------

typedef struct _IF_TABLE_ENTRY {

    LIST_ENTRY          LinkByAddr;             // sorted by Ipaddr.only activated interfaces
    LIST_ENTRY          LinkByIndex;            // sorted by Index. all interfaces
    LIST_ENTRY          HTLinkByIndex;          // not sorted within bucket

    LIST_ENTRY          ListOfSameIfGroups;     // sorted by GroupAddr. GI entries for IF (all GIs of Ras clients)
    LIST_ENTRY          ListOfSameIfGroupsNew;  // unmerged list. sorted by GroupAddr. GI entries same as above
    DWORD               NumGIEntriesInNewList;  // used to decide if lists should be merged


    UCHAR               IfType;                 // IGMP_IF_ (NOT_RAS,RAS_ROUTER,RAS_SERVER). for external calls, IGMP_IF_PROXY might be set
                                                // set when interface is created. cannot be changed again.
    DWORD               IfIndex;                
    IPADDR              IpAddr;                 // set when IF is bound. ==0 for un-numbered IFs.

    DWORD               Status;                 // IF_(CREATED/BOUND/ENABLED/ACTIVATED),
                                                // IF_DEACTIVATE_DELETE_FLAG, 
                                                // MGM_ENABLED_IGMPRTR_FLAG, IGMPRTR_MPROTOCOL_PRESENT_FLAG

    PRAS_TABLE          pRasTable;              // null if not IGMP_IF_RAS_SERVER. created in _AddIfEntry()
    PLIST_ENTRY         pProxyHashTable;        // g_pProxyHashTable: contains the proxy entries. They are also linked in
                                                // order using the LinkBySameIfGroups field accessed through pite.

    IGMP_IF_CONFIG      Config;
    PIGMP_IF_BINDING    pBinding;               // null if not bound or unNumbered interface.
    IF_INFO             Info;

    SOCKET_ENTRY        SocketEntry;            // used by igmpRouter for getting input, and binding to waitEvent
                                                // used by proxy to join the igmp groups as a host.
                                                
    IGMP_TIMER_ENTRY    QueryTimer;             // Querier mode: used for sending general query.

    IGMP_TIMER_ENTRY    NonQueryTimer;          // used when in NonQuerier mode: used for detecting other queriers

    HANDLE              pPrevIfGroupEnumPtr;    // points to the next GI entry to be enumerated.
    USHORT              PrevIfGroupEnumSignature;//used in enumerating interface GI list in order

    SOCKET              StaticGroupSocket;      // used only by igmp Router. created in _CreateIfSockets and 
                                                // closed in _DeleteIfSockets.
                                                // Static groups in proxy are joined on SocketEntry.
    DWORD               CreationFlags;          // see below.
    
} IF_TABLE_ENTRY, *PIF_TABLE_ENTRY;


//
// values for CreationFlags
//

#define REGISTERED_PROTOCOL_WITH_MGM        0x0001
#define TAKEN_INTERFACE_OWNERSHIP_WITH_MGM  0x0002
#define DONE_STAR_STAR_JOIN                 0x0004
#define SOCKETS_CREATED                     0x0008

// the above flags are cleared during deactivation, while below flags
// are retained across deactivations.
#define CREATION_FLAGS_DEACTIVATION_CLEAR   0x00FF


#define CREATED_PROXY_HASH_TABLE            0x0100





// expand the table if the number of interface is greater than 16        
#define IF_HASHTABLE_SZ1     256
#define IF_EXPAND_THRESHOLD1 256

#define IF_HASHTABLE_SZ2     512

//---------------------------------------------------
// struct:      IGMP_IF_TABLE
//---------------------------------------------------

typedef struct _IF_TABLE {

    LIST_ENTRY          ListByAddr;
    LIST_ENTRY          ListByIndex;

    DWORD               Status;
    DWORD               NumBuckets;
    DWORD               NumInterfaces;
    
    PLIST_ENTRY         HashTableByIndex;
    PDYNAMIC_CS_LOCK   *aIfBucketDCS;
    PDYNAMIC_RW_LOCK   *aIfBucketDRWL;

    CRITICAL_SECTION    IfLists_CS;    // CS protecting the 1st two lists

} IGMP_IF_TABLE, *PIGMP_IF_TABLE;


        

//---------------------------------------------------
// struct:     GI_INFO
//---------------------------------------------------

typedef struct _GROUP_INFO {

    DWORD               LastReporter;
    LONGLONG            GroupUpTime;
    LONGLONG            GroupExpiryTime;
    LONGLONG            V1HostPresentTimeLeft;

    // version 3 fields
    LONGLONG            V2HostPresentTimeLeft;
    
} GI_INFO, *PGROUP_INFO;




//---------------------------------------------------
// struct:      GI_ENTRY (group-Interface entry)
//---------------------------------------------------

typedef struct _GI_ENTRY {

    LIST_ENTRY          LinkByGI;
    LIST_ENTRY          LinkBySameIfGroups;
    LIST_ENTRY          LinkBySameClientGroups; //links all ras client groups

    DWORD               IfIndex;
    DWORD               Status;     //bound,enabled,deleted,activated
    BOOL                bRasClient; //rasclient or not
    BOOL                bStaticGroup;
    
    PIF_TABLE_ENTRY     pIfTableEntry;    
    struct _GROUP_TABLE_ENTRY    *pGroupTableEntry;

    //below two fields valid only for ras    
    DWORD               NHAddr;
    PRAS_TABLE_ENTRY    pRasTableEntry;


    IGMP_TIMER_ENTRY    GroupMembershipTimer;

    /*timerlock*///LastMemQueryCount left to be sent
    DWORD               LastMemQueryCount;
    IGMP_TIMER_ENTRY    LastMemQueryTimer;
        
    IGMP_TIMER_ENTRY    LastVer1ReportTimer;/*timelock*/
    BYTE                Version;    //ver1, ver2, ver3

    GI_INFO             Info;

    // igmpv3 fields. ignored for rest.
    IGMP_TIMER_ENTRY    LastVer2ReportTimer;/*timelock*/
    DWORD               FilterType;
    DWORD               NumSources;
    LIST_ENTRY          *V3InclusionList;
    LIST_ENTRY          V3InclusionListSorted;
    LIST_ENTRY          V3ExclusionList;

    //query sources
    LIST_ENTRY          V3SourcesQueryList;
    DWORD               V3SourcesQueryCount;
    BOOL                bV3SourcesQueryNow;
    IGMP_TIMER_ENTRY    V3SourcesQueryTimer;

    #if DEBUG_FLAGS_SIGNATURE
    DWORD               Signature;//0xfadfad02
    #endif
    
} GI_ENTRY, *PGI_ENTRY;

//kslksl1 10
#define SOURCES_BUCKET_SZ 1

//---------------------------------------------------
// struct:      GI_SOURCE_ENTRY
//---------------------------------------------------

typedef struct _GI_SOURCE_ENTRY {

    LIST_ENTRY          LinkSources;
    LIST_ENTRY          LinkSourcesInclListSorted;
    LIST_ENTRY          V3SourcesQueryList;
    PGI_ENTRY           pGIEntry;
    
    BOOL                bInclusionList;
    
    IPADDR              IpAddr;

    //how many more src queries left to be sent
    DWORD               V3SourcesQueryLeft;
    BOOL                bInV3SourcesQueryList;
    
    //timeout sources in inc list
    IGMP_TIMER_ENTRY    SourceExpTimer;
    LONGLONG            SourceInListTime;

    BOOL                bStaticSource;
    
} GI_SOURCE_ENTRY, *PGI_SOURCE_ENTRY;

#define GET_IF_CONFIG_FOR_SOURCE(pSourceEntry) \
    pSourceEntry->pGIEntry->pIfTableEntry->Config
    
#define GET_IF_ENTRY_FOR_SOURCE(pSourceEntry) \
    pSourceEntry->pGIEntry->pIfTableEntry
    
    
//---------------------------------------------------
// struct:      GROUP_TABLE_ENTRY
//---------------------------------------------------

typedef struct _GROUP_TABLE_ENTRY {

    LIST_ENTRY          HTLinkByGroup;
    LIST_ENTRY          LinkByGroup; //ordered list of groups
    LIST_ENTRY          ListOfGIs;
    
    DWORD               Group;
    DWORD               GroupLittleEndian;
    
    DWORD               NumVifs;
    
    DWORD               Status;
    
    LONGLONG            GroupUpTime;

    #if DEBUG_FLAGS_SIGNATURE
    DWORD               Signature; //0xfadfad01
    #endif

} GROUP_TABLE_ENTRY, *PGROUP_TABLE_ENTRY;




#define GROUP_HASH_TABLE_SZ     256
//---------------------------------------------------
// struct:      GROUP_TABLE
//---------------------------------------------------

typedef struct _GROUP_TABLE {
        
    LOCKED_LIST             ListByGroup;
    LIST_ENTRY              ListByGroupNew;
    DWORD                   NumGroupsInNewList;

    DWORD                   Status;

    LONG                    NumIfs;    //Interlocked Operations

    DYNAMIC_CS_LOCKED_LIST  HashTableByGroup[GROUP_HASH_TABLE_SZ];
    
} GROUP_TABLE, *PGROUP_TABLE;




//-------------------------------------------------
// Proxy group entry
//-------------------------------------------------
typedef struct _PROXY_GROUP_ENTRY {

    LIST_ENTRY          HT_Link;
    LIST_ENTRY          LinkBySameIfGroups;

    //v3
    LIST_ENTRY          ListSources;
    
    DWORD               Group;
    DWORD               GroupLittleEndian;
    DWORD               RefCount;
    LONGLONG            InitTime;
    BOOL                bStaticGroup;

    //v3
    DWORD               NumSources;
    DWORD               FilterType;
    
} PROXY_GROUP_ENTRY, *PPROXY_GROUP_ENTRY;

typedef struct _PROXY_SOURCE_ENTRY {
    LIST_ENTRY          LinkSources;
    IPADDR              IpAddr;
    DWORD               RefCount;
    BOOL                bStaticSource;
    DWORD               JoinMode;//ALLOW,BLOCK, NO_STATE
    DWORD               JoinModeIntended;
} PROXY_SOURCE_ENTRY, *PPROXY_SOURCE_ENTRY;



//-------------------------------------------------
// prototypes
//-------------------------------------------------

DWORD 
CreateIfSockets (
    PIF_TABLE_ENTRY    pite
    );

VOID
DeleteIfSockets (
    PIF_TABLE_ENTRY pite
    );

VOID
DeleteAllTimers (
    PLIST_ENTRY     pHead,
    DWORD           bEntryType //RAS_CLIENT, NOT_RAS_CLIENT
    );


DWORD
DeleteGIEntry (
    PGI_ENTRY   pgie,   //group interface entry
    BOOL        bUpdateStats,
    BOOL        bCallMgm
    );

VOID
DeleteAllGIEntries(
    PIF_TABLE_ENTRY pite
    );
    
VOID
DeleteGIEntryFromIf (
    PGI_ENTRY   pgie   //group interface entry
    );
    
VOID
MergeGroupLists(
    );

VOID
MergeIfGroupsLists(
    PIF_TABLE_ENTRY pite
    );

VOID
MergeProxyLists(
    PIF_TABLE_ENTRY pite
    );

DWORD
CopyinIfConfig (
    PIGMP_IF_CONFIG     pConfig,
    PIGMP_MIB_IF_CONFIG pConfigExt,
    DWORD               IfIndex
    );
    
DWORD
CopyinIfConfigAndUpdate (
    PIF_TABLE_ENTRY     pite,
    PIGMP_MIB_IF_CONFIG pConfigExt,
    ULONG               IfIndex
    );
    
VOID
CopyoutIfConfig (
    PIGMP_MIB_IF_CONFIG pConfigExt,
    PIF_TABLE_ENTRY     pite
    );
    
DWORD 
ValidateIfConfig (
    PIGMP_MIB_IF_CONFIG pConfigExt,
    DWORD               IfIndex,
    DWORD               IfType,
    ULONG               StructureVersion,
    ULONG               StructureSize
    );
    
DWORD    
InitializeIfTable (
    );

VOID    
DeInitializeIfTable (
    );

DWORD    
InitializeGroupTable (
    );

VOID    
DeInitializeGroupTable (
    );

DWORD
InitializeRasTable(
    DWORD               IfIndex,
    PIF_TABLE_ENTRY     pite
    );

VOID
DeInitializeRasTable (
    PIF_TABLE_ENTRY     pite,
    BOOL                bFullCleanup
    );


#endif // _IGMP_TABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\table.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File: table.c
//
// Abstract:
//      This module implements some of the routines associated with creating,
//      initializing, deleting timers, GI entries, table entries etc
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#include "pchigmp.h"
#pragma hdrstop



//------------------------------------------------------------------------------
//            _CreateIfSockets
//
// Creates the sockets.
// for proxy: a raw IPPROTO_IP socket so that igmp host functionality will
//     take over for all groups added on that interface.
// for router: a raw IPPROTO_IGMP socket so that it receives all igmp packets
//     A router never does Add Memberships
//
// Called by:  _ActivateInterface()
// Locks: assumes exclusive lock on the interface, and socketsList
//------------------------------------------------------------------------------

DWORD
CreateIfSockets (
    PIF_TABLE_ENTRY    pite
    )
{
    DWORD           Error = NO_ERROR, dwRetval, SockType;
    DWORD           IpAddr = pite->IpAddr;
    DWORD           IfIndex = pite->IfIndex;
    SOCKADDR_IN     saLocalIf;
    BOOL            bProxy = IS_PROTOCOL_TYPE_PROXY(pite);
    PSOCKET_ENTRY   pse = &pite->SocketEntry;



    BEGIN_BREAKOUT_BLOCK1 {

        //
        // for proxy, create a IPPROTO_IP socket so that igmp host functionality
        //      takes over.
        // for igmp router, create a raw IPPROTO_IGMP socket
        //
        SockType = (bProxy)? IPPROTO_IP : IPPROTO_IGMP;


        //
        // create input socket
        //
        pse->Socket = WSASocket(AF_INET, SOCK_RAW, SockType, NULL, 0, 0);

        if (pse->Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            Trace3(IF,
                "error %d creating socket for interface %d (%d.%d.%d.%d)",
                Error, IfIndex, PRINT_IPADDR(IpAddr));
            Logerr1(CREATE_SOCKET_FAILED_2, "%I", IpAddr, Error);

            GOTO_END_BLOCK1;
        }



        //
        // bind socket to local interface. If I dont bind multicast may
        // not work.
        //

        ZeroMemory(&saLocalIf, sizeof(saLocalIf));
        saLocalIf.sin_family = PF_INET;
        saLocalIf.sin_addr.s_addr = IpAddr;
        saLocalIf.sin_port = 0;        //port shouldnt matter

        // bind the input socket

        Error = bind(pse->Socket, (SOCKADDR FAR *)&saLocalIf, sizeof(SOCKADDR));

        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
            Trace3(IF, "error %d binding on socket for interface %d (%d.%d.%d.%d)",
                    Error, IfIndex, PRINT_IPADDR(IpAddr));
            Logerr1(BIND_FAILED, "%I", IpAddr, Error);

            GOTO_END_BLOCK1;
        }



        //
        // A proxy never sends/receives any packets. It is just expected to enable
        // igmp host functionality to take over for the groups on which it joins.
        //

        //------------------------------
        // if proxy then done
        //------------------------------

        if (bProxy)
            GOTO_END_BLOCK1;



        //------------------------------
        // NOT PROXY INTERFACE
        //------------------------------

        if (!bProxy) {

            // set ttl to 1: not required as it is set to 1 by default.

            McastSetTtl(pse->Socket, 1);


            //
            // disable multicast packets from being loopedback.
            // This may not work due to promiscuous mode,
            // so you still have to check the input packets
            //

            {
                BOOL bLoopBack = FALSE;
                DWORD   dwRetval;

                dwRetval = setsockopt(pse->Socket, IPPROTO_IP, IP_MULTICAST_LOOP,
                                       (char *)&bLoopBack, sizeof(BOOL));

                if (dwRetval==SOCKET_ERROR) {
                    Trace2(ERR, "error %d disabling multicast loopBack on IfIndex %d",
                        WSAGetLastError(), IfIndex);
                    IgmpAssertOnError(FALSE);
                }
            }



            //
            // if RasServerInterface, then activate hdrInclude option so that I can
            // send GenQuery to all RAS clients
            //
            if (IS_RAS_SERVER_IF(pite->IfType)) {

                INT iSetHdrIncl = 1;

                Error = setsockopt( pse->Socket, IPPROTO_IP, IP_HDRINCL,
                                (char *) &iSetHdrIncl, sizeof(INT));

                if (Error!=NO_ERROR) {
                    Error = WSAGetLastError();
                    Trace2(ERR, "error %d unable to set IP_HDRINCL option on interface %d",
                            Error, IfIndex,);
                    IgmpAssertOnError(FALSE);
                    Logerr1(SET_HDRINCL_FAILED, "%I", pite->IpAddr, Error);
                    GOTO_END_BLOCK1;
                }
            }
            else {

                //
                // set the interface on which multicasts must be sent
                // set only for non rasserver (not internal) interfaces
                //

                dwRetval = setsockopt(pse->Socket, IPPROTO_IP, IP_MULTICAST_IF,
                                    (PBYTE)&saLocalIf.sin_addr, sizeof(IN_ADDR));

                if (dwRetval == SOCKET_ERROR) {
                    Error = WSAGetLastError();
                    Trace3(IF, "error %d setting interface %d (%d.%d.%d.%d) to send multicast",
                            Error, IfIndex, PRINT_IPADDR(pite->IpAddr));
                    Logerr1(SET_MCAST_IF_FAILED, "%I", pite->IpAddr, Error);
                    Error = SOCKET_ERROR;
                    GOTO_END_BLOCK1;
                }

                {
                    //
                    // set router alert option for packets sent. dont have to set it for
                    // RasServerInterface where I do hdrInclude.
                    //

                    u_char        Router_alert[4] = {148, 4, 0, 0};

                    dwRetval = setsockopt(pse->Socket, IPPROTO_IP, IP_OPTIONS,
                                         (void *)Router_alert, sizeof(Router_alert));

                    if (dwRetval!=0) {
                        dwRetval = WSAGetLastError();
                        Trace2(ERR,
                            "error %d unable to set router alert option on interface %d",
                            dwRetval, IfIndex
                            );
                        IgmpAssertOnError(FALSE);
                        Logerr1(SET_ROUTER_ALERT_FAILED, "%I", pite->IpAddr, dwRetval);
                        Error = dwRetval;
                        GOTO_END_BLOCK1;
                    }
                }
            }



            //
            // set the interface in promiscuous igmp multicast mode.
            //

            {
                DWORD   dwEnable = 1;
                DWORD   dwNum;

                dwRetval = WSAIoctl(pse->Socket, SIO_RCVALL_IGMPMCAST, (char *)&dwEnable,
                                    sizeof(dwEnable), NULL , 0, &dwNum, NULL, NULL);

                if (dwRetval !=0) {
                    dwRetval = WSAGetLastError();
                    Trace2(IF, "error %d setting interface %d as promiscuous multicast",
                            dwRetval, IfIndex);
                    Logerr1(SET_ROUTER_ALERT_FAILED, "%I", pite->IpAddr, dwRetval);
                    Error = dwRetval;
                    GOTO_END_BLOCK1;
                }
                else {
                    Trace1(IF, "promiscuous igmp multicast enabled on If (%d)",
                            IfIndex);
                }
            }


            //
            // Router doesnt have to join any group as it is in promiscuous mode
            //


            //
            // create entry in the SocketsEvents list
            //
            {
                BOOLEAN             bCreateNewEntry;
                PLIST_ENTRY         ple, pHead = &g_ListOfSocketEvents;
                PSOCKET_EVENT_ENTRY psee;


                bCreateNewEntry = TRUE;


                //
                // see if a new socket-event entry has to be created
                //
                if (g_pIfTable->NumInterfaces>NUM_SINGLE_SOCKET_EVENTS) {

                    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                        psee = CONTAINING_RECORD(ple, SOCKET_EVENT_ENTRY,
                                                    LinkBySocketEvents);

                        if (psee->NumInterfaces < MAX_SOCKETS_PER_EVENT) {
                            bCreateNewEntry = FALSE;
                            break;
                        }
                    }
                }



                //
                // create a new socket-event entry and insert in the list
                // register the event entry with the wait thread
                //
                if (bCreateNewEntry) {

                    psee = IGMP_ALLOC(sizeof(SOCKET_EVENT_ENTRY), 
                                    0x80000,pite->IfIndex);

                    PROCESS_ALLOC_FAILURE2(psee,
                        "error %d allocating %d bytes for SocketEventEntry",
                        Error, sizeof(SOCKET_EVENT_ENTRY),
                        GOTO_END_BLOCK1);

                    InitializeListHead(&psee->ListOfInterfaces);
                    psee->NumInterfaces = 0;
                    InsertHeadList(pHead, &psee->LinkBySocketEvents);


                    psee->InputEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
                    if (psee->InputEvent == NULL) {
                        Error = GetLastError();
                        Trace1(ERR,
                            "error %d creating InputEvent in CreateIfSockets",
                            Error);
                        IgmpAssertOnError(FALSE);
                        Logerr0(CREATE_EVENT_FAILED, Error);
                        GOTO_END_BLOCK1;
                    }


                    if (! RegisterWaitForSingleObject(
                                &psee->InputWaitEvent,
                                psee->InputEvent,
                                WT_ProcessInputEvent, psee,
                                INFINITE,
                                (WT_EXECUTEINWAITTHREAD)|(WT_EXECUTEONLYONCE)
                                ))
                    {
                        Error = GetLastError();
                        Trace1(ERR, "error %d RegisterWaitForSingleObject", Error);
                        IgmpAssertOnError(FALSE);
                        GOTO_END_BLOCK1;
                    }
                }



                //
                // put the socketEntry in the list
                //
                InsertTailList(&psee->ListOfInterfaces, &pse->LinkByInterfaces);
                pse->pSocketEventsEntry = psee;



                //
                // if the socket-event entry cannot take any more sockets,
                // then put it at end of list
                //
                if (++psee->NumInterfaces==MAX_SOCKETS_PER_EVENT) {
                    RemoveEntryList(&psee->LinkBySocketEvents);
                    InsertTailList(pHead, &psee->LinkBySocketEvents);
                }
            } //end:create entry in the sockets list

            //
            // create socket for static joins.
            //
            {
                pite->StaticGroupSocket =
                        WSASocket(AF_INET, SOCK_RAW, IPPROTO_IP, NULL, 0, 0);
                if (pite->StaticGroupSocket == INVALID_SOCKET) {
                    Error = WSAGetLastError();
                    Trace3(IF,
                        "error %d creating static group socket for interface "
                        "%d (%d.%d.%d.%d)",
                        Error, pite->IfIndex, PRINT_IPADDR(pite->IpAddr));
                    Logerr1(CREATE_SOCKET_FAILED_2, "%I", pite->IpAddr, Error);

                    GOTO_END_BLOCK1;
                }
                //
                // bind socket to local interface. If I dont bind multicast may
                // not work.
                //
                saLocalIf.sin_family = PF_INET;
                saLocalIf.sin_addr.s_addr = pite->IpAddr;
                saLocalIf.sin_port = 0;        //port shouldnt matter

                Error = bind(pite->StaticGroupSocket, (SOCKADDR FAR *)&saLocalIf,
                                        sizeof(SOCKADDR));
            }
        } // end: not proxy interface


    } END_BREAKOUT_BLOCK1;

    if (Error!=NO_ERROR)
        DeleteIfSockets(pite);

    return Error;

} //end _CreateIfSockets




//------------------------------------------------------------------------------
//            _DeleteIfSockets
//
// Called by: _DeActivateInterfaceComplete()
//------------------------------------------------------------------------------
VOID
DeleteIfSockets (
    PIF_TABLE_ENTRY    pite
    )
{
    PSOCKET_ENTRY       pse = &pite->SocketEntry;
    PSOCKET_EVENT_ENTRY psee = pse->pSocketEventsEntry;
    BOOL                bProxy = IS_PROTOCOL_TYPE_PROXY(pite);


    // close input socket

    if (pse->Socket!=INVALID_SOCKET) {

        if (closesocket(pse->Socket) == SOCKET_ERROR) {
            Trace1(IF, "error %d closing socket", WSAGetLastError());
        }

        pse->Socket = INVALID_SOCKET;
    }

    //
    // if router interface. delete socket from socketEventList
    // and free the socketEventEntry only if they were initialized.
    //
    if ((!bProxy)&&(pse->pSocketEventsEntry!=NULL)) {

        PSOCKET_EVENT_ENTRY psee = pse->pSocketEventsEntry;

        RemoveEntryList(&pse->LinkByInterfaces);

        if (--psee->NumInterfaces==0) {

            if (psee->InputWaitEvent) {

                HANDLE WaitHandle ;

                WaitHandle = InterlockedExchangePointer(&psee->InputWaitEvent, NULL);

                if (WaitHandle)
                    UnregisterWaitEx( WaitHandle, NULL ) ;
            }
            CloseHandle(psee->InputEvent);

            RemoveEntryList(&psee->LinkBySocketEvents);
            IGMP_FREE(psee);
        }
        if (pite->StaticGroupSocket!=INVALID_SOCKET) {
            closesocket(pite->StaticGroupSocket);
            pite->StaticGroupSocket = INVALID_SOCKET;
        }
    }
    return;
}




//------------------------------------------------------------------------------
//            _DeleteAllTimers
//
// Deletes all timers associated with a GI entry.
//
// Called by: _DeActivateInterfaceComplete()
// Locks: Assumes Timer lock and GroupBucket lock.
//------------------------------------------------------------------------------

VOID
DeleteAllTimers (
    PLIST_ENTRY     pHead,
    DWORD           bEntryType
    )
{
    PLIST_ENTRY         ple;
    PGI_ENTRY           pgie;

    Trace0(ENTER1, "entering _DeleteAllTimers()");

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {


        pgie = (bEntryType==RAS_CLIENT)
                ? CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups)
                : CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);

        if (IS_TIMER_ACTIVE(pgie->GroupMembershipTimer))
            RemoveTimer(&pgie->GroupMembershipTimer, DBG_N);


        if (IS_TIMER_ACTIVE(pgie->LastMemQueryTimer))
            RemoveTimer(&pgie->LastMemQueryTimer, DBG_N);

        if (IS_TIMER_ACTIVE(pgie->LastVer1ReportTimer))
            RemoveTimer(&pgie->LastVer1ReportTimer, DBG_N);

        if (IS_TIMER_ACTIVE(pgie->LastVer2ReportTimer))
            RemoveTimer(&pgie->LastVer2ReportTimer, DBG_N);

        if (IS_TIMER_ACTIVE(pgie->V3SourcesQueryTimer))
            RemoveTimer(&pgie->V3SourcesQueryTimer, DBG_N);


        // delete all sources timers

        if (pgie->Version==3) {
            PLIST_ENTRY pleSrc, pHeadSrc;

            pHeadSrc = &pgie->V3InclusionListSorted;
            for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc;  pleSrc=pleSrc->Flink){
                PGI_SOURCE_ENTRY  pSourceEntry;
                pSourceEntry = CONTAINING_RECORD(pleSrc, GI_SOURCE_ENTRY, LinkSourcesInclListSorted);
                if (IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer))
                    RemoveTimer(&pSourceEntry->SourceExpTimer, DBG_Y);
            }
            pHeadSrc = &pgie->V3ExclusionList;
            for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc;  pleSrc=pleSrc->Flink){
                PGI_SOURCE_ENTRY  pSourceEntry;
                pSourceEntry = CONTAINING_RECORD(pleSrc, GI_SOURCE_ENTRY, LinkSources);
                if (IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer))
                    RemoveTimer(&pSourceEntry->SourceExpTimer, DBG_Y);
            }
        }
    }

    Trace0(LEAVE1, "Leaving _DeleteAllTimers()");

    return;
}


//------------------------------------------------------------------------------
//            _DeleteGIEntry
//
// Locks: Assumes lock on the group bucket. takes lock on IfGroup list.
//  takes lock on groupList if group being deleted.
//------------------------------------------------------------------------------

DWORD
DeleteGIEntry (
    PGI_ENTRY                       pgie,   //group interface entry
    BOOL                            bUpdateStats,
    BOOL                            bCallMgm
    )
{
    PIF_TABLE_ENTRY                 pite = pgie->pIfTableEntry;
    PRAS_TABLE_ENTRY                prte = pgie->pRasTableEntry;
    PGROUP_TABLE_ENTRY              pge = pgie->pGroupTableEntry;
    PGI_ENTRY                       pgieCur;
    BOOL                            bRas = (prte!=NULL);
    DWORD                           NHAddr;
    DWORD                           dwRetval;


    Trace0(ENTER1, "Entering _DeleteGIEntry()");

    NHAddr = (bRas) ? prte->NHAddr : 0;

    Trace4(GROUP, "Deleting group(%d.%d.%d.%d) on Interface(%d)(%d.%d.%d.%d) "
            "NHAddr(%d.%d.%d.%d)",
            PRINT_IPADDR(pge->Group), pite->IfIndex,
            PRINT_IPADDR(pite->IpAddr), PRINT_IPADDR(NHAddr));


    bCallMgm = bCallMgm && (CAN_ADD_GROUPS_TO_MGM(pite));
        
    //
    // exclusion mode. remove all exclusion entries
    // dont have to call MGM as it still has to be excluded
    //
    if (pgie->Version==3) {
        PLIST_ENTRY pleSrc, pHeadSrc;

        pHeadSrc = &pgie->V3InclusionListSorted;
        for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc;  ){
            PGI_SOURCE_ENTRY  pSourceEntry;
            pSourceEntry = CONTAINING_RECORD(pleSrc, GI_SOURCE_ENTRY, LinkSources);
            pleSrc=pleSrc->Flink;
            DeleteSourceEntry(pSourceEntry, bCallMgm);
        }

        pHeadSrc = &pgie->V3ExclusionList;
        for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc;  ){
            PGI_SOURCE_ENTRY  pSourceEntry;
            pSourceEntry = CONTAINING_RECORD(pleSrc, GI_SOURCE_ENTRY, LinkSources);
            pleSrc=pleSrc->Flink;
            DeleteSourceEntry(pSourceEntry, bCallMgm);
        }
    }

    //
    // call mgm to remove this group
    //

    if ( bCallMgm ) {
        if ( (pgie->Version==3 && pgie->FilterType==EXCLUSION)
            || pgie->Version!=3)
        {
            MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pite, NHAddr,
                        0, 0,
                        pge->Group, 0xffffffff, MGM_JOIN_STATE_FLAG);
        }
    }
    
    //
    // remove all timers
    //

    ACQUIRE_TIMER_LOCK("_DeleteGIEntry");


    if (IS_TIMER_ACTIVE(pgie->GroupMembershipTimer))
        RemoveTimer(&pgie->GroupMembershipTimer, DBG_N);


    if (IS_TIMER_ACTIVE(pgie->LastMemQueryTimer))
        RemoveTimer(&pgie->LastMemQueryTimer, DBG_N);

    if (IS_TIMER_ACTIVE(pgie->LastVer1ReportTimer))
        RemoveTimer(&pgie->LastVer1ReportTimer, DBG_N);

    if (IS_TIMER_ACTIVE(pgie->LastVer2ReportTimer))
        RemoveTimer(&pgie->LastVer2ReportTimer, DBG_N);

    if (IS_TIMER_ACTIVE(pgie->V3SourcesQueryTimer))
        RemoveTimer(&pgie->V3SourcesQueryTimer, DBG_Y);

    RELEASE_TIMER_LOCK("_DeleteGIEntry");



    //
    // Remove from IfGroupList.  needs lock on IfGroupList
    //
    ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DeleteGIEntry");

    // if interface being deleted, then return from here

    if (IS_IF_DELETED(pgie->pIfTableEntry)) {
        RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DeleteGIEntry");
        return NO_ERROR;
    }

    // remove GI entry from group's GI list

    RemoveEntryList(&pgie->LinkByGI);


    //
    // remove entry from interface list
    //
    RemoveEntryList(&pgie->LinkBySameIfGroups);
    if (bRas)
        RemoveEntryList(&pgie->LinkBySameClientGroups);


    RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DeleteGIEntry");



    //
    // decrement the number of virtual interfaces. I have to do
    // interlocked decrement as I dont take group_list lock
    //
    InterlockedDecrement(&pge->NumVifs);

    //
    // if group has no more interfaces hanging from it, then delete it
    // and update statistics
    //
    if (IsListEmpty(&pge->ListOfGIs)) {

        // take groupList lock before deleting it from the group list

        ACQUIRE_GROUP_LIST_LOCK("_DeleteGIEntry");
        RemoveEntryList(&pge->LinkByGroup);
        RELEASE_GROUP_LIST_LOCK("_DeleteGIEntry");



        // remove group entry from the group hash table

        RemoveEntryList(&pge->HTLinkByGroup);


        IGMP_FREE(pge);
        pge = NULL;


        //global stats (has to be updated even if bUpdateStats==FALSE)

        InterlockedDecrement(&g_Info.CurrentGroupMemberships);

        #if DBG
        DebugPrintGroupsList(1);
        #endif
    }

    //
    // update statistics
    //
    if (bUpdateStats) {

        //
        // ras interface statistics (decrement only if last GI for ras)
        //
        if (bRas) {

            // see if GI entry exists for that ras client. very inefficient
            if (pge!=NULL) {
                PLIST_ENTRY                     pHead, ple;
                pHead = &pge->ListOfGIs;
                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                    pgieCur = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);
                    if (pgieCur->IfIndex>=pite->IfIndex)
                        break;
                }
                if ( (ple==pHead)||(pgieCur->IfIndex!=pite->IfIndex) ) {
                    InterlockedDecrement(&pite->Info.CurrentGroupMemberships);
                }
            }

            // last GI entry
            else {
                InterlockedDecrement(&pite->Info.CurrentGroupMemberships);
            }

            // update ras client stats
            if (g_Config.RasClientStats) {
                InterlockedDecrement(&prte->Info.CurrentGroupMemberships);
            }
        }

        //  not ras interace
        else {
            InterlockedDecrement(&pite->Info.CurrentGroupMemberships);
        }
    }

    IGMP_FREE_NOT_NULL(pgie->V3InclusionList);
    IGMP_FREE(pgie);

    Trace0(LEAVE1, "Leaving _DeleteGIEntry");
    return NO_ERROR;

}//end _DeleteGIEntry


//------------------------------------------------------------------------------
//          _DeleteAllGIEntries
//
// Repeatedly calls _DeleteGIEntryFromIf() to delete each GI entry from the list.
// If there are a lot of GI entries, optimizes on the GroupBucket locks
// by grouping all GI entries hashing to the same bucket and then acquiring
// GroupBucket locks to delete them.
//
// Locks:  interface_group_list lock not req. exclusive interface lock not req.
//      as the interface has been removed from external lists.
// Calls: Repeatedly calls _DeleteGIEntryFromIf() to remove each GI entry
// Called by: _DeActivateInterfaceComplete()
//------------------------------------------------------------------------------

VOID
DeleteAllGIEntries(
    PIF_TABLE_ENTRY pite
    )
{
    PLIST_ENTRY                 pHead, ple, pleOld;
    PGI_ENTRY                   pgie;
    DWORD                       dwGroup;


    //
    // concatenate ListOfSameIfGroupsNew at the end of ListOfSameIfGroups so
    // that I have to delete only one list
    //

    CONCATENATE_LISTS(pite->ListOfSameIfGroups, pite->ListOfSameIfGroupsNew);

    // if ras interface then return as list will be deleted through RAS clients

    if (IS_RAS_SERVER_IF(pite->IfType))
        return;


    pHead = &pite->ListOfSameIfGroups;
    if (IsListEmpty(pHead))
        return;


    //--------------------------------------------------------
    // do optimization only if there are lots of GI entries
    //--------------------------------------------------------

    if (pite->Info.CurrentGroupMemberships > GROUP_HASH_TABLE_SZ*2) {

        DWORD       i;
        LIST_ENTRY  TmpGroupTable[GROUP_HASH_TABLE_SZ];


        // initialize the temp group table

        for (i=0;  i<GROUP_HASH_TABLE_SZ;  i++) {

            InitializeListHead(&TmpGroupTable[i]);
        }


        // move the GI entries to the temp group table using LinkBySameIfGroups
        // LinkBySameIfGroups is not used anymore

        pHead = &pite->ListOfSameIfGroups;

        for (ple=pHead->Flink;  ple!=pHead;  ) {

            // remove from old list
            pleOld = ple;
            ple = ple->Flink;

            RemoveEntryList(pleOld);


            pgie = CONTAINING_RECORD(pleOld, GI_ENTRY, LinkBySameIfGroups);

            dwGroup = pgie->pGroupTableEntry->Group;


            // put in appropriate bucket

            InsertHeadList(&TmpGroupTable[GROUP_HASH_VALUE(dwGroup)],
                            &pgie->LinkBySameIfGroups);

        }


        //
        // now delete GI entries going by all groups which hash to same bucket
        //
        for (i=0;  i<GROUP_HASH_TABLE_SZ;  i++) {

            if (IsListEmpty(&TmpGroupTable[i]))
                continue;


            //
            // LOCK GROUP BUCKET (done use ACQUIRE_GROUP_LOCK macros)
            //
            ACQUIRE_GROUP_LOCK(i, "_DeleteAllGIEntries");

            pHead = &TmpGroupTable[i];


            // delete all GI entries that hash to that bucket

            for (ple=pHead->Flink;  ple!=pHead;  ) {

                pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
                ple=ple->Flink;

                //
                // remove the entry from the group's GI list and update
                // statistics. If group's GI list becomes empty, removes group
                //
                DeleteGIEntryFromIf(pgie);
            }


            RELEASE_GROUP_LOCK(i, "_DeleteAllGIEntries");

        }

        InitializeListHead(&pite->ListOfSameIfGroups);

        return;
    }




    //-----------------------------------------------------------
    // NO OPTIMIZATION
    //-----------------------------------------------------------

    pHead = &pite->ListOfSameIfGroups;

    //
    // delete all GI entries hanging from that interface.
    //
    for (ple=pHead->Flink;  ple!=pHead;  ) {


        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
        ple=ple->Flink;

        dwGroup = pgie->pGroupTableEntry->Group;


        // LOCK GROUP BUCKET

        ACQUIRE_GROUP_LOCK(dwGroup,
                            "_DeActivateInterfaceComplete");

        DeleteGIEntryFromIf(pgie);


        RELEASE_GROUP_LOCK(dwGroup, "_DeActivateInterfaceComplete");

    }


    InitializeListHead(&pite->ListOfSameIfGroups);

    return;
}


//------------------------------------------------------------------------------
//          _DeleteGIEntryFromIf
//
// Called to delete a GI entry when an interface/RAS client is being deleted.
// The GI entries cannot be accessed from anywhere except through enumeration of
// group list.
//
// Locks:  Assumes lock on the group bucket. lock on IfGroup list not req.
// Called by: _DeleteAllGIEntries() which in turn called by
//      _DeActivateInterfaceComplete().
//------------------------------------------------------------------------------

VOID
DeleteGIEntryFromIf (
    PGI_ENTRY                       pgie   //group interface entry
    )
{
    PIF_TABLE_ENTRY         pite = pgie->pIfTableEntry;
    PGROUP_TABLE_ENTRY      pge = pgie->pGroupTableEntry;
    PLIST_ENTRY             pHead, ple;
    DWORD                   IfIndex = pite->IfIndex;



    Trace1(ENTER1, "Entering _DeleteGIEntryFromIf(): IfIndex(%0x)", IfIndex);


    //
    // delete sources
    //
    if (pgie->Version==3) {
        PLIST_ENTRY pleSrc, pHeadSrc;

        pHeadSrc = &pgie->V3InclusionListSorted;
        for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc;  ){
            PGI_SOURCE_ENTRY  pSourceEntry;
            pSourceEntry = CONTAINING_RECORD(pleSrc, GI_SOURCE_ENTRY, LinkSourcesInclListSorted);
            pleSrc=pleSrc->Flink;
            IGMP_FREE(pSourceEntry);
        }

        pHeadSrc = &pgie->V3ExclusionList;
        for (pleSrc=pHeadSrc->Flink;  pleSrc!=pHeadSrc;  ){
            PGI_SOURCE_ENTRY  pSourceEntry;
            pSourceEntry = CONTAINING_RECORD(pleSrc, GI_SOURCE_ENTRY, LinkSources);
            pleSrc=pleSrc->Flink;
            IGMP_FREE(pSourceEntry);
        }
    }
    
    //
    // Remove pgie from gi list. Dont have to remove from ListBySameIfGroups
    //
    RemoveEntryList(&pgie->LinkByGI);

    InterlockedDecrement(&pge->NumVifs);


    //
    // if group has no more interfaces hanging from it, then delete it
    // and update statistics
    //
    if (IsListEmpty(&pge->ListOfGIs)) {


        // have to lock the group-list before deleting any group

        ACQUIRE_GROUP_LIST_LOCK("_DeleteGIEntryFromIf");

        RemoveEntryList(&pge->LinkByGroup);

        RELEASE_GROUP_LIST_LOCK("_DeleteGIEntryFromIf");


        RemoveEntryList(&pge->HTLinkByGroup);

        IGMP_FREE(pge);

        InterlockedDecrement(&g_Info.CurrentGroupMemberships);
    }

    IGMP_FREE_NOT_NULL(pgie->V3InclusionList);
    IGMP_FREE(pgie);

    Trace1(LEAVE1, "Leaving _DeleteGIEntryFromIf(%d)", IfIndex);

    return;

}//end _DeleteGIEntryFromIf




//------------------------------------------------------------------------------
//          DebugPrintIfConfig
//------------------------------------------------------------------------------
VOID
DebugPrintIfConfig (
    PIGMP_MIB_IF_CONFIG pConfigExt,
    DWORD               IfIndex
    )
{
    DWORD    i;
    PCHAR    StaticGroupStr[5];
    BOOL    bVersion3 = IS_CONFIG_IGMP_V3(pConfigExt);


    Trace1(CONFIG, "Printing Config Info for interface(%0x)", IfIndex);
    Trace1(CONFIG, "Version:                    0x%0x", pConfigExt->Version);
    Trace1(CONFIG, "IfType:                     %d", pConfigExt->IfType);


    {
        CHAR str[150];

        strcpy(str, "");
        if (pConfigExt->Flags&IGMP_INTERFACE_ENABLED_IN_CONFIG)
            strcat(str, "IF_ENABLED  ");
        else
            strcat(str, "IF_DISABLED  ");

        if (pConfigExt->Flags&IGMP_ACCEPT_RTRALERT_PACKETS_ONLY)
            strcat(str, "RTRALERT_PACKETS_ONLY  ");

        Trace1(CONFIG, "Flags:                      %s", str);

    }

    Trace1(CONFIG, "IgmpProtocolType:           %d", pConfigExt->IgmpProtocolType);
    Trace1(CONFIG, "RobustnessVariable:         %d", pConfigExt->RobustnessVariable);
    Trace1(CONFIG, "StartupQueryInterval:       %d",
                    pConfigExt->StartupQueryInterval);
    Trace1(CONFIG, "StartupQueryCount   :       %d",
                    pConfigExt->StartupQueryCount);
    Trace1(CONFIG, "GenQueryInterval:           %d", pConfigExt->GenQueryInterval);
    Trace1(CONFIG, "GenQueryMaxResponseTime:    %d",
                    pConfigExt->GenQueryMaxResponseTime);
    Trace1(CONFIG, "LastMemQueryInterval:       %d (ms)",
                    pConfigExt->LastMemQueryInterval);
    Trace1(CONFIG, "LastMemQueryCount:          %d", pConfigExt->LastMemQueryCount);
    Trace1(CONFIG, "OtherQuerierPresentInterval:%d",
                    pConfigExt->OtherQuerierPresentInterval);
    Trace1(CONFIG, "GroupMembershipTimeout:     %d",
                    pConfigExt->GroupMembershipTimeout);


    if (pConfigExt->NumStaticGroups>0) {

        PIGMP_STATIC_GROUP   pStaticGroup;
        PSTATIC_GROUP_V3   pStaticGroupV3;

        Trace1(CONFIG, "NumStaticGroups:            %d",
                    pConfigExt->NumStaticGroups);

        pStaticGroup = GET_FIRST_IGMP_STATIC_GROUP(pConfigExt);
        if (bVersion3) {
            pStaticGroupV3 = GET_FIRST_STATIC_GROUP_V3(pConfigExt);

            Trace0(CONFIG, "  Group     Mode(Host/MGM) Filter(In/Ex) "
                "NumSources");
        }
        else
            Trace0(CONFIG, "  Group     Mode(Host/MGM)");

        for (i=0;  i<pConfigExt->NumStaticGroups;  i++){

            if (bVersion3) {
                DWORD j;
                Trace5(CONFIG, "%d. %15s          %d    %d   %d",
                    i+1, INET_NTOA(pStaticGroupV3->GroupAddr),
                    pStaticGroupV3->Mode, pStaticGroupV3->FilterType,
                    pStaticGroupV3->NumSources
                    );
                for (j=0;  j<pStaticGroupV3->NumSources;  j++) {
                    Trace1(CONFIG, "                     %d.%d.%d.%d",
                        PRINT_IPADDR(pStaticGroupV3->Sources[j]));
                }
                pStaticGroupV3 = (PSTATIC_GROUP_V3)
                                    GET_NEXT_STATIC_GROUP_V3(pStaticGroupV3);
            }
            else {
                Trace3(CONFIG, "%d. %15s   Mode:%d",
                    i+1, INET_NTOA(pStaticGroup->GroupAddr),
                    pStaticGroup->Mode
                    );
                pStaticGroup++;
            }
        }
    }

    Trace0(CONFIG, "");

    return;
}



//------------------------------------------------------------------------------
//          CopyinIfConfigAndUpdate
//
// Copies the if config struct passed by mib to igmp and update the timers
// and does static joins if req.
// Called when the interface is activated
//------------------------------------------------------------------------------
DWORD
CopyinIfConfigAndUpdate (
    PIF_TABLE_ENTRY     pite,
    PIGMP_MIB_IF_CONFIG pConfigExt,
    ULONG               IfIndex
    )
{
    PIGMP_IF_CONFIG  pConfig = &pite->Config;
    BOOL        bGroupMembershipTimer=FALSE, bLastMemQueryTimer=FALSE;
    ULONG       NewStartupQueryInterval, NewGenQueryInterval,
                NewGenQueryMaxResponseTime, NewLastMemQueryInterval,
                NewOtherQuerierPresentInterval, NewGroupMembershipTimeout;
    BOOL        bFound;
    DWORD       Error=NO_ERROR;
    DWORD       bVer3=IS_CONFIG_IGMP_V3(pConfigExt);


    NewStartupQueryInterval
                    = CONFIG_TO_INTERNAL_TIME(pConfigExt->StartupQueryInterval);
    NewGenQueryInterval
                    = CONFIG_TO_INTERNAL_TIME(pConfigExt->GenQueryInterval);
    NewGenQueryMaxResponseTime
                    = CONFIG_TO_INTERNAL_TIME(pConfigExt->GenQueryMaxResponseTime);
    NewOtherQuerierPresentInterval
                = CONFIG_TO_INTERNAL_TIME(pConfigExt->OtherQuerierPresentInterval);
    NewLastMemQueryInterval = pConfigExt->LastMemQueryInterval; //already in ms
    NewGroupMembershipTimeout
                = CONFIG_TO_INTERNAL_TIME(pConfigExt->GroupMembershipTimeout);


    //
    // used only in ver3
    //
    pConfig->RobustnessVariableOld = pConfigExt->RobustnessVariable;
    pConfig->GenQueryIntervalOld = NewGenQueryInterval;
    pConfig->OtherQuerierPresentIntervalOld
        = NewOtherQuerierPresentInterval;
    pConfig->GroupMembershipTimeoutOld = NewGroupMembershipTimeout;



    //
    // update values only if it is ver1,ver2 or ver3&&Querier
    //

    if (!IS_IF_VER3(pite) || (IS_IF_VER3(pite) && IS_QUERIER(pite)) ){


        ACQUIRE_TIMER_LOCK("_CopyinIfConfigAndUpdate");


        //
        // change Info.StartupQueryCountCurrent if it was set to some very high value.
        // During startup, Info.StartupQueryCountCurrent is used, and not the Config value.
        //
        if (pConfigExt->StartupQueryCount < pite->Info.StartupQueryCountCurrent)
            InterlockedExchange(&pite->Info.StartupQueryCountCurrent,
                                    pConfigExt->StartupQueryCount);



        // in startup mode. StartupQueryInterval active and to be reduced
        if (pite->Info.StartupQueryCountCurrent>0) {

            if ( (NewStartupQueryInterval < pConfig->StartupQueryInterval)
                && (IS_TIMER_ACTIVE(pite->QueryTimer)) )
            {
                UpdateLocalTimer(&pite->QueryTimer, NewStartupQueryInterval, DBG_Y);
            }

        }

        // in querier mode. GenQueryInterval is active and to be updated
        else {

            if ( (NewGenQueryInterval < pConfig->GenQueryInterval)
                && (IS_TIMER_ACTIVE(pite->QueryTimer)) )
            {
                UpdateLocalTimer(&pite->QueryTimer, NewGenQueryInterval, DBG_Y);
            }

        }

        // OtherQuerierPresentInterval active and to be updated

        if ( (NewOtherQuerierPresentInterval<pConfig->OtherQuerierPresentInterval)
            && (IS_TIMER_ACTIVE(pite->NonQueryTimer)) )
        {
            UpdateLocalTimer(&pite->NonQueryTimer, NewOtherQuerierPresentInterval, DBG_Y);
        }


        // NewLastMemQueryInterval is to be processed only if in ver-2 mode and not
        // server
        if ( (pConfigExt->IgmpProtocolType==IGMP_ROUTER_V2)
                && (pite->IfType!=IGMP_IF_RAS_SERVER) )
        {
            if (NewLastMemQueryInterval < pConfig->LastMemQueryInterval)
                bLastMemQueryTimer = TRUE;
        }


        // check if GroupMembership timeout is reduced
        if (NewGroupMembershipTimeout < pConfig->GroupMembershipTimeout)
            bGroupMembershipTimer = TRUE;



        //
        // Go through the GI list for that interface (all ras clients) and update
        // their timers if they are higher
        //
        if ( ((bLastMemQueryTimer||bGroupMembershipTimer)&&(!IS_RAS_SERVER_IF(pite->IfType)))
            || ((bGroupMembershipTimer)&&(IS_RAS_SERVER_IF(pite->IfType))) )
        {
            PLIST_ENTRY     pHead, ple;
            PGI_ENTRY       pgie;
            LONGLONG        llNewLastMemQueryInterval, llNewGroupMembershipTimeout;
            LONGLONG        llMaxTime, llCurTime = GetCurrentIgmpTime();


            //
            // get the absolute timeout values
            //
            llNewLastMemQueryInterval = llCurTime
                                + CONFIG_TO_SYSTEM_TIME(NewLastMemQueryInterval);
            llNewGroupMembershipTimeout = llCurTime
                                + CONFIG_TO_SYSTEM_TIME(NewGroupMembershipTimeout);


            // if not ras interface, then go through the list from interface
            if ( !IS_RAS_SERVER_IF(pite->IfType)) {


                // merge the IfGroup lists
                MergeIfGroupsLists(pite);


                pHead = &pite->ListOfSameIfGroups;


                for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                    pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);


                    // update LastMemQueryTimer/V3SourcesQueryTimer if it is active and has a higher value

                    if (bLastMemQueryTimer && IS_TIMER_ACTIVE(pgie->LastMemQueryTimer)
                        && (llNewLastMemQueryInterval<pgie->LastMemQueryTimer.Timeout))
                    {
                        UpdateLocalTimer(&pgie->LastMemQueryTimer,
                                                NewLastMemQueryInterval, DBG_Y);
                    }

                    if (bLastMemQueryTimer && IS_TIMER_ACTIVE(pgie->V3SourcesQueryTimer)
                        && (llNewLastMemQueryInterval<pgie->V3SourcesQueryTimer.Timeout))
                    {
                        UpdateLocalTimer(&pgie->V3SourcesQueryTimer,
                                                NewLastMemQueryInterval, DBG_Y);
                    }


                    // update GroupMembershipTimeout if it is active and has a higher value

                    if (bGroupMembershipTimer
                        && IS_TIMER_ACTIVE(pgie->GroupMembershipTimer)
                        && (llNewGroupMembershipTimeout<pgie->GroupMembershipTimer.Timeout))
                    {
                        UpdateLocalTimer(&pgie->GroupMembershipTimer,
                                                NewGroupMembershipTimeout, DBG_Y);
                    }


                    // update LastVer1ReportTimer/LastVer2ReportTimer if it is active and has a higher value
                    // LastVer1ReportTimeout is set to GroupMembershipTimeout

                    if (bGroupMembershipTimer
                        && IS_TIMER_ACTIVE(pgie->LastVer1ReportTimer)
                        && (llNewGroupMembershipTimeout<pgie->LastVer1ReportTimer.Timeout))
                    {
                        UpdateLocalTimer(&pgie->LastVer1ReportTimer,
                                                NewGroupMembershipTimeout, DBG_Y);
                    }
                    if (bGroupMembershipTimer
                        && IS_TIMER_ACTIVE(pgie->LastVer2ReportTimer)
                        && (llNewGroupMembershipTimeout<pgie->LastVer2ReportTimer.Timeout))
                    {
                        UpdateLocalTimer(&pgie->LastVer2ReportTimer,
                                                NewGroupMembershipTimeout, DBG_Y);
                    }
                }
            }

            // IS_RAS_SERVER_IF: process for all clients. have to process
            // GroupMembershipTimeout only
            else {

                PLIST_ENTRY         pHeadClient, pleClient;
                PRAS_TABLE_ENTRY    prte;
                PRAS_TABLE          prt = pite->pRasTable;

                //
                // process GI list of each ras client
                //
                pHeadClient = &pite->pRasTable->ListByAddr;

                for (pleClient=pHeadClient->Flink;  pleClient!=pHeadClient;
                            pleClient=pleClient->Flink)
                {
                    prte = CONTAINING_RECORD(pleClient, RAS_TABLE_ENTRY, LinkByAddr);


                    pHead = &prte->ListOfSameClientGroups;

                    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

                        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups);

                        if (IS_TIMER_ACTIVE(pgie->GroupMembershipTimer)
                            && (llNewGroupMembershipTimeout
                                <pgie->GroupMembershipTimer.Timeout))
                        {
                            UpdateLocalTimer(&pgie->GroupMembershipTimer,
                                NewGroupMembershipTimeout, DBG_Y);
                        }
                    }
                }
            }
        }

        RELEASE_TIMER_LOCK("_CopyinIfConfigAndUpdate");


        //
        // finally copy the new values
        //
        CopyMemory(pConfig, pConfigExt, sizeof(IGMP_MIB_IF_CONFIG));

        pConfig->StartupQueryInterval = NewStartupQueryInterval;
        pConfig->GenQueryInterval = NewGenQueryInterval;
        pConfig->GenQueryMaxResponseTime = NewGenQueryMaxResponseTime;
        pConfig->LastMemQueryInterval = NewLastMemQueryInterval;
        pConfig->OtherQuerierPresentInterval = NewOtherQuerierPresentInterval;
        pConfig->GroupMembershipTimeout = NewGroupMembershipTimeout;
        pConfig->IfIndex = IfIndex;

    }

    pConfig->NumStaticGroups = 0;

    return Error;
    #if 0
    {
        PSTATIC_GROUP_V3    pStaticGroupExt;
        PIF_STATIC_GROUP    pStaticGroup;
        PLIST_ENTRY         ple, pHead;
        DWORD               i, GroupAddr;
        SOCKADDR_IN         saLocalIf;


        //
        // delete all static groups which are different in the old config
        //

        pHead = &pite->Config.ListOfStaticGroups;
        for (ple=pHead->Flink;  ple!=pHead;  ) {

            pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);
            GroupAddr = pStaticGroup->GroupAddr;
            ple = ple->Flink;

            bFound = FALSE;
            pStaticGroupExt = GET_FIRST_STATIC_GROUP_V3(pConfigExt);
            for (i=0;  i<pConfigExt->NumStaticGroups;  i++) {

                if ( (GroupAddr == pStaticGroupExt->GroupAddr)
                    && (pStaticGroup->Mode == pStaticGroupExt->Mode) )
                {
                    bFound = TRUE;
                    break;
                }

                pStaticGroupExt = GET_NEXT_STATIC_GROUP_V3(pStaticGroupExt);
            }


            //
            // group exists in old and new config. check for changes in sources.
            //
            if (bFound && bVer3) {

                if (pStaticGroupExt->NumSources==0) {
                    //delete all static sources
                }

                if (pStaticGroupExt->NumSources==0 &&
                    pStaticGroupExt->FilterType!=EXCLUSION) {

                    // delete the static group

                }

                // check for differences in sources
            }

            // if old static group not found in new list, delete it


            // Router

            if (IS_CONFIG_IGMPRTR(pConfig)) {

                if (pStaticGroup->Mode==IGMP_HOST_JOIN) {
                    LeaveMulticastGroup(pite->StaticGroupSocket,  GroupAddr,
                                        pite->IfIndex, pite->IpAddr, 0 );
                }
                else {
                    PGROUP_TABLE_ENTRY  pge;
                    PGI_ENTRY           pgie;

                    ACQUIRE_GROUP_LOCK(GroupAddr, "_CopyinIfConfigAndUpdate");

                    pge = GetGroupFromGroupTable(GroupAddr, NULL, 0);
                    pgie = GetGIFromGIList(pge, pite, 0, STATIC_GROUP, NULL, 0);

                    pgie->bStaticGroup = 0;

                    if (bVer3) {
                        PLIST_ENTRY pHead, ple;
                        PGI_SOURCE_ENTRY  pSourceEntry;

                        //
                        // delete all static source entries
                        //

                        pHead = &pgie->V3ExclusionList;
                        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSources);
                            // delete source entry (forward the packets)
                            if (pSourceEntry->bStaticSource) {
                                DeleteSourceEntry(pSourceEntry, MGM_YES);
                            }
                        }
                        pHead = &pgie->V3InclusionListSorted;
                        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSourcesInclListSorted);
                            if (pSourceEntry->bStaticSource) {
                                pSourceEntry->bStaticSource = FALSE;
                                if (!IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer))
                                    DeleteSourceEntry(pSourceEntry, MGM_YES);
                            }
                        }
                    }
                    else {
                        if (!(pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE))
                            DeleteGIEntry(pgie, TRUE, TRUE);
                    }

                    RELEASE_GROUP_LOCK(GroupAddr, "_CopyinIfConfigAndUpdate");
                }
            }

            // Proxy Interface
            else {
                if (bVer3){
                    for (i=0;  i<pStaticGroup->NumSources;  i++){
                        ProcessProxyGroupChange(pStaticGroup->Sources[i],
                            GroupAddr, DELETE_FLAG, STATIC_GROUP);
                    }
                }
                if (!bVer3 || pStaticGroup->NumSources==0)
                    ProcessProxyGroupChange(0,GroupAddr, DELETE_FLAG, STATIC_GROUP);
            }

            RemoveEntryList(&pStaticGroup->Link);
            IGMP_FREE(pStaticGroup);
        }


        //
        // for all new static groups, if not in old list, create it
        //
        pStaticGroupExt = GET_FIRST_STATIC_GROUP_V3(pConfigExt);
        for (i=0;  i<pConfigExt->NumStaticGroups;  i++,pStaticGroupExt++) {

            pHead = &pite->Config.ListOfStaticGroups;
            bFound = FALSE;
            for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
                pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);
                if (pStaticGroup->GroupAddr==pStaticGroupExt->GroupAddr) {
                    bFound = TRUE;
                    break;
                }
            }

            // not found: create the new static group
            if (!bFound) {

                pStaticGroup = IGMP_ALLOC(
                                    IGMP_MIB_STATIC_GROUP_SIZE(pConfigExt,
                                    pStaticGroupExt), 0x100000,IfIndex);

                PROCESS_ALLOC_FAILURE3(pStaticGroup,
                        "error %d allocating %d bytes for static group for IF:%0x",
                        Error, sizeof(IF_STATIC_GROUP), pite->IfIndex,
                        return Error);

                memcpy(pStaticGroup, pStaticGroupExt,
                    IGMP_MIB_STATIC_GROUP_SIZE(pConfigExt, pStaticGroupExt));


                InsertHeadList(&pConfig->ListOfStaticGroups, &pStaticGroup->Link);

                if (IS_IF_ACTIVATED(pite)) {

                    // if proxy
                    if (IS_CONFIG_IGMPPROXY(pConfig)) {
                        if (pStaticGroup->NumSources==0)
                            ProcessProxyGroupChange(0, pStaticGroup->GroupAddr,
                                                ADD_FLAG, STATIC_GROUP);
                        else {
                            for (i=0;  i<pStaticGroup->NumSources;  i++) {
                                ProcessProxyGroupChange(pStaticGroup->Sources[i],
                                    pStaticGroup->GroupAddr,
                                    ADD_FLAG, STATIC_GROUP);
                            }
                        }
                    }
                    // Add static group to Router
                    else {
                        if (pStaticGroup->Mode==IGMP_HOST_JOIN) {

                            if (!bVer3) {
                                JoinMulticastGroup(pite->StaticGroupSocket,
                                                pStaticGroup->GroupAddr,
                                                pite->IfIndex,
                                                pite->IpAddr,
                                                0
                                               );
                            }
                            else {
                                // include filter
                                if (pStaticGroup->FilterType==INCLUSION) {

                                    if (pStaticGroup->NumSources==0) {
                                        JoinMulticastGroup(pite->StaticGroupSocket,
                                                pStaticGroup->GroupAddr,
                                                pite->IfIndex,
                                                pite->IpAddr,
                                                0
                                               );
                                    }
                                    for (i=0;  i<pStaticGroup->NumSources;  i++) {
                                        JoinMulticastGroup(pite->StaticGroupSocket,
                                                pStaticGroup->GroupAddr,
                                                pite->IfIndex,
                                                pite->IpAddr,
                                                pStaticGroup->Sources[i]
                                               );
                                    }
                                }
                                // exclude filter
                                else {
                                    if (pStaticGroup->NumSources==0) {
                                        JoinMulticastGroup(pite->StaticGroupSocket,
                                                pStaticGroup->GroupAddr,
                                                pite->IfIndex,
                                                pite->IpAddr,
                                                0
                                               );
                                    }
                                    for (i=0;  i<pStaticGroup->NumSources;  i++) {
                                        BlockSource(pite->StaticGroupSocket,
                                                pStaticGroup->GroupAddr,
                                                pite->IfIndex,
                                                pite->IpAddr,
                                                pStaticGroup->Sources[i]
                                               );
                                    }
                                }
                            }
                        }

                        // IGMPRTR_MGM_ONLY

                        else {
                            PGROUP_TABLE_ENTRY  pge;
                            PGI_ENTRY           pgie;
                            BOOL bCreate;
                            PGI_SOURCE_ENTRY pSourceEntry;


                            GroupAddr = pStaticGroup->GroupAddr;

                            ACQUIRE_GROUP_LOCK(GroupAddr,
                                                    "_CopyinIfConfigAndUpdate");

                            bCreate = TRUE;
                            pge = GetGroupFromGroupTable(GroupAddr, &bCreate, 0);

                            bCreate = TRUE;
                            pgie = GetGIFromGIList(pge, pite, 0,
                                        (pStaticGroup->NumSources==0)
                                            ?STATIC_GROUP:NOT_STATIC_GROUP,
                                        &bCreate, 0);
                            for (i=0;  i<pStaticGroup->NumSources;  i++) {

                                if (pStaticGroup->FilterType!=pgie->FilterType) {

                                    pSourceEntry = GetSourceEntry(pgie,
                                                        pStaticGroup->Sources[i],
                                                        pStaticGroup->FilterType ^ 1,
                                                        NULL, 0, 0);

                                    if (pSourceEntry) {
                                        pSourceEntry->bStaticSource = TRUE;
                                        ChangeSourceFilterMode(pgie,
                                            pSourceEntry);

                                        continue;
                                    }
                                }
                                bCreate = TRUE;
                                pSourceEntry = GetSourceEntry(pgie,
                                                    pStaticGroup->Sources[i],
                                                    pStaticGroup->FilterType,
                                                    &bCreate, STATIC, MGM_YES);
                            }
                            RELEASE_GROUP_LOCK(GroupAddr,
                                                    "_CopyinIfConfigAndUpdate");
                        }
                    }
                }
            }
        }
    }

    return Error;
    #endif
} //end _CopyinIfConfigAndUpdate



//------------------------------------------------------------------------------
//          _CopyinIfConfig
// Copies the if config struct passed by mib to igmp.
// called after the interface is in disabled state
//------------------------------------------------------------------------------
DWORD
CopyinIfConfig (
    PIGMP_IF_CONFIG     pConfig,
    PIGMP_MIB_IF_CONFIG pConfigExt,
    ULONG               IfIndex
    )
{
    DWORD   Error=NO_ERROR;

    CopyMemory(pConfig, pConfigExt, sizeof(IGMP_MIB_IF_CONFIG));
    CONV_CONFIG_TO_INTERNAL_TIME(pConfig->StartupQueryInterval);
    CONV_CONFIG_TO_INTERNAL_TIME(pConfig->GenQueryInterval);
    CONV_CONFIG_TO_INTERNAL_TIME(pConfig->GenQueryMaxResponseTime);
    // already in ms
    //CONV_CONFIG_TO_INTERNAL_TIME(pConfig->LastMemQueryInterval);
    CONV_CONFIG_TO_INTERNAL_TIME(pConfig->OtherQuerierPresentInterval);
    CONV_CONFIG_TO_INTERNAL_TIME(pConfig->GroupMembershipTimeout);

    pConfig->RobustnessVariableOld = pConfig->RobustnessVariable;
    pConfig->GenQueryIntervalOld = pConfig->GenQueryInterval;
    pConfig->OtherQuerierPresentIntervalOld
        = pConfig->OtherQuerierPresentInterval;
    pConfig->GroupMembershipTimeoutOld = pConfig->GroupMembershipTimeout;

    pConfig->ExtSize = IgmpMibIfConfigSize(pConfigExt);

    pConfig->IfIndex = IfIndex ;


    pConfig->NumStaticGroups = 0;

    return Error;
#if 0
    {
        PIGMP_STATIC_GROUP  pStaticGroupExt;
        PSTATIC_GROUP_V3  pStaticGroupExtV3;
        PIF_STATIC_GROUP    pStaticGroup;
        DWORD               i;
        PLIST_ENTRY         ple;
        BOOL                bVersion3=IS_CONFIG_IGMP_V3(pConfigExt);

        // delete all old static groups

        for (ple=pConfig->ListOfStaticGroups.Flink;
               ple!=&pConfig->ListOfStaticGroups;  )
        {
            pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);
            ple = ple->Flink;
            IGMP_FREE(pStaticGroup);
        }


        // copy all static groups

        InitializeListHead(&pConfig->ListOfStaticGroups);
        if (bVersion3)
            pStaticGroupExtV3 = GET_FIRST_STATIC_GROUP_V3(pConfigExt);
        else
            pStaticGroupExt = GET_FIRST_IGMP_STATIC_GROUP(pConfigExt);

        for (i=0;  i<pConfig->NumStaticGroups;  i++) {

            DWORD Size = IGMP_MIB_STATIC_GROUP_SIZE(pConfigExt, pStaticGroupExtV3);

            pStaticGroup = IGMP_ALLOC(Size, 0x200000,IfIndex);

            PROCESS_ALLOC_FAILURE2(pStaticGroup,
                "error %d allocating %d bytes for static group for IF:%0x",
                Error, Size,return Error);

            if (!bVersion3) {
                pStaticGroup->GroupAddr = pStaticGroupExt->GroupAddr;
                pStaticGroup->Mode = pStaticGroupExt->Mode;
                pStaticGroupExt++;
            }
            else {
                memcpy(pStaticGroup, pStaticGroupExtV3, Size);

                pStaticGroupExtV3 = (PSTATIC_GROUP_V3)
                                        ((PCHAR)pStaticGroupExtV3 + Size);
            }

            InsertHeadList(&pConfig->ListOfStaticGroups, &pStaticGroup->Link);
        }
    }
#endif
}


//------------------------------------------------------------------------------
//          _CopyoutIfConfig
//------------------------------------------------------------------------------
VOID
CopyoutIfConfig (
    PIGMP_MIB_IF_CONFIG  pConfigMib,
    PIF_TABLE_ENTRY      pite
    )
{
    PIGMP_IF_CONFIG     pConfig = &pite->Config;
    BOOL    bVersion3 = IS_CONFIG_IGMP_V3(pConfig);

    //
    // the initial IGMP_MIB_IF_CONFIG size of struct is common
    //
    CopyMemory(pConfigMib, pConfig, sizeof(IGMP_MIB_IF_CONFIG));


    CONV_INTERNAL_TO_CONFIG_TIME(pConfigMib->StartupQueryInterval);
    CONV_INTERNAL_TO_CONFIG_TIME(pConfigMib->GenQueryInterval);
    CONV_INTERNAL_TO_CONFIG_TIME(pConfigMib->GenQueryMaxResponseTime);
    // keep in ms
    //CONV_INTERNAL_TO_CONFIG_TIME(pConfigMib->LastMemQueryInterval);
    CONV_INTERNAL_TO_CONFIG_TIME(pConfigMib->OtherQuerierPresentInterval);
    CONV_INTERNAL_TO_CONFIG_TIME(pConfigMib->GroupMembershipTimeout);
    pConfigMib->IfIndex = pite->IfIndex;
    pConfigMib->IpAddr = pite->IpAddr;

    // have to convert the Iftype to external type
    pConfigMib->IfType = GET_EXTERNAL_IF_TYPE(pite);


    {
        PLIST_ENTRY         pHead, ple;
        PIGMP_STATIC_GROUP  pStaticGroupExt;
        PSTATIC_GROUP_V3  pStaticGroupExtV3;
        PIF_STATIC_GROUP    pStaticGroup;

        if (bVersion3)
            pStaticGroupExtV3 = GET_FIRST_STATIC_GROUP_V3(pConfigMib);
        else
            pStaticGroupExt = GET_FIRST_IGMP_STATIC_GROUP(pConfigMib);

        pHead = &pConfig->ListOfStaticGroups;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pStaticGroup = CONTAINING_RECORD(ple, IF_STATIC_GROUP, Link);

            if (bVersion3) {
                memcpy(pStaticGroupExtV3,
                    (PCHAR)pStaticGroup+FIELD_OFFSET(IF_STATIC_GROUP,GroupAddr),
                    sizeof(STATIC_GROUP_V3)+pStaticGroup->NumSources*sizeof(IPADDR)
                    );
                pStaticGroupExtV3 = GET_NEXT_STATIC_GROUP_V3(pStaticGroupExtV3);
            }
            else {
                pStaticGroupExt->GroupAddr = pStaticGroup->GroupAddr;
                pStaticGroupExt->Mode = pStaticGroup->Mode;
                pStaticGroupExt++;
            }
        }
    }

    return;
}



//------------------------------------------------------------------------------
//          _ValidateIfConfig
//
// Corrects some values, and returns error for some others.
// Return:  ERROR_INVALID_DATA, NO_ERROR
//------------------------------------------------------------------------------
DWORD
ValidateIfConfig (
    PIGMP_MIB_IF_CONFIG pConfigExt,
    DWORD               IfIndex,
    DWORD               IfType,
    ULONG               ulStructureVersion,
    ULONG               ulStructureSize
    )
{
    DWORD       Error = NO_ERROR, i, Size;
    BOOL        bVersion3;


    //
    // verify config size
    //
/*kslksl
    if (ulStructureSize<sizeof(IGMP_MIB_IF_CONFIG)) {
        Trace2(ERR, "IGMP config size %d very small. Expected:%d", ulStructureSize,
            sizeof(IGMP_MIB_IF_CONFIG));
        return ERROR_INVALID_DATA;
    }
*/
    bVersion3 = IS_IGMP_VERSION_3(pConfigExt->Version);

    {
        if (!bVersion3) {
            Size = sizeof(IGMP_MIB_IF_CONFIG)
                   + pConfigExt->NumStaticGroups*sizeof(IGMP_STATIC_GROUP);
        }
        else {
            PSTATIC_GROUP_V3 pStaticGroupV3 = GET_FIRST_STATIC_GROUP_V3(pConfigExt);

            Size = sizeof(IGMP_MIB_IF_CONFIG)
                        +sizeof(STATIC_GROUP_V3)*pConfigExt->NumStaticGroups;

            for (i=0;  i<pConfigExt->NumStaticGroups;  i++) {
                Size += pStaticGroupV3->NumSources*sizeof(IPADDR);
                if (ulStructureSize<Size)
                    break;
                pStaticGroupV3 = GET_NEXT_STATIC_GROUP_V3(pStaticGroupV3);
            }
        }

/*kslksl
        if (ulStructureSize!=Size) {
            Trace0(ERR, "Invalid IGMP structure size");
            return ERROR_INVALID_DATA;
        }
*/
    }


    // DebugPrintIfConfig

    DebugPrintIfConfig(pConfigExt, IfIndex);

    // check version

    if (pConfigExt->Version >= IGMP_VERSION_3_5) {

        Trace1(ERR, "Invalid version in interface config.\n"
            "Create the Igmp configuration again", pConfigExt->Version);
        IgmpAssertOnError(FALSE);
        Logerr0(INVALID_VERSION, ERROR_INVALID_DATA);
        return ERROR_INVALID_DATA;
    }


    //
    // check the proxy/router common fields, and then check the router fields
    //


    //
    // check the protocolType
    //
    switch (pConfigExt->IgmpProtocolType) {
        case IGMP_ROUTER_V1 :
        case IGMP_ROUTER_V2 :
        {
            if ( (pConfigExt->Version<IGMP_VERSION_1_2)
                ||(pConfigExt->Version>=IGMP_VERSION_1_2_5) )
            {
                Trace1(ERR, "IGMP v1/v2 should have version %0x", IGMP_VERSION_1_2);
                IgmpAssertOnError(FALSE);
                return ERROR_INVALID_DATA;
            }
            break;
        }
        case IGMP_ROUTER_V3:
        {
            if (pConfigExt->Version<IGMP_VERSION_3 || pConfigExt->Version>=IGMP_VERSION_3_5) {
                Trace1(ERR, "IGMP v3 should have version %0x", IGMP_VERSION_3);
                IgmpAssertOnError(FALSE);
                return ERROR_INVALID_DATA;
            }
            break;
        }
        case IGMP_PROXY :
        case IGMP_PROXY_V3 :
            break;

        // if none of above, then return error
        default : {
            Trace2(ERR,
                "Error: IGMP protocol type(%d) for interface(%0x) invalid",
                pConfigExt->IgmpProtocolType, IfIndex);
            IgmpAssertOnError(FALSE);
            Logerr2(INVALID_PROTOTYPE, "%d%d", pConfigExt->IgmpProtocolType,
                IfIndex, ERROR_INVALID_DATA);
            return ERROR_INVALID_DATA;
        }
    }


    // cannot configure a proxy on a ras server interface

    if (IS_RAS_SERVER_IF(IfType) && IS_CONFIG_IGMPPROXY(pConfigExt)) {
        Trace1(ERR,
            "Error: Cannot configure Proxy on RAS server interface:%0x",
            IfIndex);
        IgmpAssertOnError(FALSE);
        Logerr1(PROXY_ON_RAS_SERVER, "%d",IfIndex, ERROR_INVALID_DATA);
        return ERROR_INVALID_DATA;
    }

    //
    // check for static joins
    //

    if (pConfigExt->NumStaticGroups>0) {

        DWORD               i;
        PIGMP_STATIC_GROUP  pStaticGroup = GET_FIRST_IGMP_STATIC_GROUP(pConfigExt);
        PSTATIC_GROUP_V3  pStaticGroupV3
                        = GET_FIRST_STATIC_GROUP_V3(pConfigExt);

        for (i=0;  i<pConfigExt->NumStaticGroups;  i++) {

            //
            // make sure that the static group is a multicast address
            //
            if (!IS_MCAST_ADDR(pStaticGroup->GroupAddr)) {
                Trace2(ERR,
                    "Error: Static group:%d.%d.%d.%d on IF:%0x not a multicast address",
                    PRINT_IPADDR(pStaticGroup->GroupAddr), IfIndex);
                IgmpAssertOnError(FALSE);
                Logerr2(INVALID_STATIC_GROUP, "%I%d", pStaticGroup->GroupAddr,
                    IfIndex, ERROR_INVALID_DATA);
                return ERROR_INVALID_DATA;
            }


            //
            // make sure that the mode of the static group is correct
            //

            if ( (pStaticGroup->Mode!=IGMP_HOST_JOIN
                    && pStaticGroup->Mode!=IGMPRTR_JOIN_MGM_ONLY)
                ||(IS_CONFIG_IGMPPROXY(pConfigExt)
                    && pStaticGroup->Mode!=IGMP_HOST_JOIN) )
            {
                Trace2(ERR,
                    "Error: Invalid mode for static group:%d.%d.%d.%d on IF:%0x",
                    PRINT_IPADDR(pStaticGroup->GroupAddr), IfIndex);
                IgmpAssertOnError(FALSE);
                Logerr2(INVALID_STATIC_MODE, "%I%d", pStaticGroup->GroupAddr,
                    IfIndex,  ERROR_INVALID_DATA);
                return ERROR_INVALID_DATA;
            }

            if (bVersion3) {

                DWORD EntrySize = sizeof(STATIC_GROUP_V3)
                                + pStaticGroupV3->NumSources*sizeof(IPADDR);

                // check filter mode

                if ( (pStaticGroupV3->FilterType!=INCLUSION)
                    && (pStaticGroupV3->FilterType!=EXCLUSION))
                {
                    Trace2(ERR,
                        "Error: Invalid filter type for static group:%d.%d.%d.%d on IF:%0x",
                        PRINT_IPADDR(pStaticGroup->GroupAddr), IfIndex);
                    IgmpAssertOnError(FALSE);
                    Logerr2(INVALID_STATIC_FILTER, "%I%d", pStaticGroup->GroupAddr,
                        IfIndex,  ERROR_INVALID_DATA);

                    return ERROR_INVALID_DATA;
                }

                // not checking source addresses

                pStaticGroupV3 = (PSTATIC_GROUP_V3)
                                    ((PCHAR)pStaticGroupV3 + EntrySize);
                pStaticGroup = (PIGMP_STATIC_GROUP)pStaticGroupV3;
            }
            else {
                pStaticGroup ++;
            }
        }
    }


    //
    // if it is a proxy interface, then none of the config variables other than
    // static group is used. I return no_error
    //
    if (IS_CONFIG_IGMPPROXY(pConfigExt))
        return NO_ERROR;



    // robustness variable must be greater than 0

    if (pConfigExt->RobustnessVariable<=0) {
        Trace1(ERR, "Error RobustnessVariable for Interface(%d) cannot be 0.",
            IfIndex);
        Logerr2(INVALID_ROBUSTNESS, "%d%d", pConfigExt->RobustnessVariable,
            IfIndex, ERROR_INVALID_DATA);

        return ERROR_INVALID_DATA;
    }

    // if robustness variable == 1, then log a warning

    if (pConfigExt->RobustnessVariable==1) {
        Trace1(ERR,
            "Warning: Robustness variable for interface (%d) being set to 1",
            IfIndex);
        Logwarn0(ROBUSTNESS_VARIABLE_EQUAL_1, NO_ERROR);
    }


    // if robustness variable > 7, then I correct it to 7 and log a warning

    if (pConfigExt->RobustnessVariable>7) {
        Trace2(ERR, "RobustnessVariable for Interface(%0x) too high(%d)."
            "Being set to 7", IfIndex, pConfigExt->RobustnessVariable);
        Logwarn2(INVALID_ROBUSTNESS, "%d%d", pConfigExt->RobustnessVariable,
            IfIndex, NO_ERROR);

        pConfigExt->RobustnessVariable = 7;
    }



    // default value of GenQueryInterval is 125 sec. I force a minimum
    // value of 10 secs to prevent trashing the network.
    // max of 31744 as possible by exp value
    
    if (pConfigExt->GenQueryInterval<10) {
        Trace2(ERR, "GetQueryInterval for Interface(%0x) too low(%d)."
            "Being set to 10", IfIndex, pConfigExt->GenQueryInterval);

        pConfigExt->GenQueryInterval = 10;
    }

    if (pConfigExt->GenQueryInterval>31744) {
        Trace2(ERR, "GetQueryInterval for Interface(%0x) too high(%d)."
            "Being set to 31744", IfIndex, pConfigExt->GenQueryInterval);

        pConfigExt->GenQueryInterval = 31744;
    }


    //
    // StartupQueryInterval: default is 1/4 of GenQueryInterval
    // I enforce a minimum of 1 sec and a max of GenQueryInterval
    //
    if (pConfigExt->StartupQueryInterval<1) {
        Trace2(ERR, "StartupQueryInterval for Interface(%0x) too low(%d)."
            "Being set to 1 sec", IfIndex, pConfigExt->StartupQueryInterval);

        pConfigExt->StartupQueryInterval = 1;
    }

    if (pConfigExt->StartupQueryInterval>pConfigExt->GenQueryInterval) {
        Trace3(ERR, "StartupQueryInterval(%d) for Interface(%0x) "
            "higher than GenQueryInterval(%d). StartupQueryInterval set "
            "to GenQueryInterval", pConfigExt->StartupQueryInterval, IfIndex,
            pConfigExt->GenQueryInterval
            );

        pConfigExt->StartupQueryInterval = pConfigExt->GenQueryInterval;
    }




    //
    // StartupQueryCount: default is Robustness variable
    // I enforce a max of 7. (I am allowing someone to set it to 0??)
    //
    if (pConfigExt->StartupQueryCount>7) {
        Trace2(ERR, "StartupQueryCount for IF(%0x) too high(%d). "
            "Being set to 7.", IfIndex, pConfigExt->StartupQueryCount);
        Logerr2(INVALID_STARTUPQUERYCOUNT, "%d%d",
            pConfigExt->StartupQueryCount, IfIndex, ERROR_INVALID_DATA);
        pConfigExt->StartupQueryCount = 7;
    }


    if ((int)pConfigExt->StartupQueryCount<0) {
        Trace2(ERR,
            "Error: StartupQueryCount(%d) for IF(%0x) cannot be < than 0.",
            pConfigExt->StartupQueryCount, IfIndex);
        Logerr2(INVALID_STARTUPQUERYCOUNT, "%d%d",
            pConfigExt->StartupQueryCount, IfIndex, ERROR_INVALID_DATA);

        return ERROR_INVALID_DATA;
    }



    //
    // GenQueryMaxResponseTime: default is 10.
    // Absurd if value is greater than GenQueryInterval.
    // I correct the values, if required
    //
    if (pConfigExt->GenQueryMaxResponseTime > pConfigExt->GenQueryInterval) {
        Trace3(ERR, "GenQueryMaxResponseTime(%d) for IF(%0x) "
            "higher than GenQueryInterval(%d). GenQueryMaxResponseTime "
            "set to GenQueryInterval", pConfigExt->GenQueryMaxResponseTime,
            IfIndex, pConfigExt->GenQueryInterval);

        pConfigExt->GenQueryMaxResponseTime = pConfigExt->GenQueryInterval;
    }
    if (pConfigExt->GenQueryMaxResponseTime > 3174) {
        Trace2(ERR, "GenQueryMaxResponseTime(%d) for IF(%0x) "
            "higher than 3174 "
            "set to 1sec", pConfigExt->GenQueryMaxResponseTime,
            IfIndex);

        pConfigExt->GenQueryMaxResponseTime = 1;
    }

    if (pConfigExt->GenQueryMaxResponseTime <= 0) {
        Trace2(ERR, "Error. GenQueryMaxResponseTime(%d) for Interface(%0x) "
            "should be greater than 0.", pConfigExt->GenQueryMaxResponseTime,
            IfIndex);
        return ERROR_INVALID_DATA;
    }


    //
    // check LastMemQueryCount and LastMemQueryInterval only if
    // protocol type is not IGMP-Router-ver1 and it is not a ras server interface
    //
    if ( (pConfigExt->IgmpProtocolType!=IGMP_ROUTER_V1) && (!IS_RAS_SERVER_IF(IfType)) ) {

        // LastMemQueryCount can be 0

        // set max LastMemQueryCount to 7
        if (pConfigExt->LastMemQueryCount>7) {
            Trace2(ERR, "Warning. LastMemQueryCount(%d) for IF(%0x) "
                "is too high. Resetting it to 10.", pConfigExt->LastMemQueryCount,
                IfIndex);
            pConfigExt->LastMemQueryCount = 10;
        }


        // limit LastMemQueryInterval(in ms) to GroupMembershipTimeout(in sec)
        if (pConfigExt->LastMemQueryInterval>pConfigExt->GroupMembershipTimeout*1000) {
            Trace3(ERR,
                "Warning. LastMemberQueryInterval(%d) for IF(%0x) "
                "is too high. Resetting it to GroupMembershipTimeout(%d ms).",
                pConfigExt->LastMemQueryCount, IfIndex,
                pConfigExt->GroupMembershipTimeout*1000
                );
            pConfigExt->LastMemQueryInterval = pConfigExt->GroupMembershipTimeout*1000;
        }
        // limit LastMemQueryInterval(in ms) to 3174(in sec)
        if (pConfigExt->LastMemQueryInterval>3174*1000) {
            Trace2(ERR,
                "Warning. LastMemberQueryInterval(%d) for IF(%0x) "
                "is too high. Resetting it to 1000ms).",
                pConfigExt->LastMemQueryCount, IfIndex
                );
            pConfigExt->LastMemQueryInterval = 1000;
        }
    }



    // check the value of OtherQuerierPresentInterval

    if (pConfigExt->OtherQuerierPresentInterval !=
        pConfigExt->RobustnessVariable*pConfigExt->GenQueryInterval
            + (pConfigExt->GenQueryMaxResponseTime)/2
       )
    {
        pConfigExt->OtherQuerierPresentInterval =
            pConfigExt->RobustnessVariable*pConfigExt->GenQueryInterval
            + (pConfigExt->GenQueryMaxResponseTime)/2;

        Trace0(ERR, "Warning: OtherQuerierPresentInterval's value should be "
            "RobustnessVariable*GenQueryInterval + (GenQueryMaxResponseTime)/2");
    }


    // check the value of GroupMembershipTimeout

    if (pConfigExt->GroupMembershipTimeout !=
            (pConfigExt->RobustnessVariable*pConfigExt->GenQueryInterval
            + pConfigExt->GenQueryMaxResponseTime) )
    {
        pConfigExt->GroupMembershipTimeout =
            pConfigExt->RobustnessVariable*pConfigExt->GenQueryInterval
            + pConfigExt->GenQueryMaxResponseTime;

        Trace0(ERR, "Warning: GroupMembershipTimeout's value should be "
            "RobustnessVariable*GenQueryInterval + GenQueryMaxResponseTime");
    }


    return Error;

} // _ValidateIfConfig




//------------------------------------------------------------------------------
//        InitializeIfTable
// Creates the Interface table.  The interface table size is dynamic
//------------------------------------------------------------------------------
DWORD
InitializeIfTable(
    )
{
    DWORD           Error = NO_ERROR;
    PIGMP_IF_TABLE  pTable;
    DWORD           NumBuckets, i;


    BEGIN_BREAKOUT_BLOCK1 {

        // set the initial size of the interface table to IF_HASHTABLE_SZ1

        NumBuckets = IF_HASHTABLE_SZ1;



        //
        // allocate memory for the interface table
        //
        g_pIfTable = IGMP_ALLOC(sizeof(IGMP_IF_TABLE), 0x400000,0);

        PROCESS_ALLOC_FAILURE2(g_pIfTable,
            "error %d allocating %d bytes for interface table",
            Error, sizeof(IGMP_IF_TABLE),
            GOTO_END_BLOCK1);

        pTable = g_pIfTable;


        // initialize NumBuckets and NumInterfaces

        pTable->NumBuckets = NumBuckets;
        pTable->NumInterfaces = 0;


        //
        // Initialize the IfTable lists
        //
        InitializeListHead(&pTable->ListByIndex);

        InitializeListHead(&pTable->ListByAddr);



        //
        // Initialize the list CS and proxyAlertCS
        //
        try {
            InitializeCriticalSection(&pTable->IfLists_CS);
            InitializeCriticalSection(&g_ProxyAlertCS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Error = GetExceptionCode();
            Trace1(ANY,
                    "exception %d initializing critical section in InitIfTable",
                    Error);
            Logerr0(INIT_CRITSEC_FAILED, Error);

            GOTO_END_BLOCK1;
        }



        //
        // allocate memory for the different buckets
        //
        pTable->HashTableByIndex = IGMP_ALLOC(sizeof(LIST_ENTRY)*NumBuckets, 
                                            0x800000,0);

        PROCESS_ALLOC_FAILURE2(pTable->HashTableByIndex,
                "error %d allocating %d bytes for interface table",
                Error, sizeof(LIST_ENTRY)*NumBuckets,
                GOTO_END_BLOCK1);


        //
        // allocate memory for the array of pointers to dynamic RWLs
        //
        pTable->aIfBucketDRWL
                = IGMP_ALLOC(sizeof(PDYNAMIC_RW_LOCK)*NumBuckets, 0x800001,0);

        PROCESS_ALLOC_FAILURE2(pTable->aIfBucketDRWL,
                "error %d allocating %d bytes for interface table",
                Error, sizeof(PDYNAMIC_RW_LOCK)*NumBuckets,
                GOTO_END_BLOCK1);



        //
        // allocate memory for the array of pointers to dynamic CSs
        //
        pTable->aIfBucketDCS
                = IGMP_ALLOC(sizeof(PDYNAMIC_CS_LOCK)*NumBuckets, 0x800002,0);

        PROCESS_ALLOC_FAILURE2(pTable->aIfBucketDCS,
                "error %d allocating %d bytes for interface table",
                Error, sizeof(PDYNAMIC_CS_LOCK)*NumBuckets,
                GOTO_END_BLOCK1);


        //
        // init locks to NULL, implying that the dynamic locks have not been
        // allocated. and initialize the list heads.
        //
        for (i=0;  i<NumBuckets;  i++) {

            InitializeListHead(&pTable->HashTableByIndex[i]);

            pTable->aIfBucketDRWL[i] = NULL;

            pTable->aIfBucketDCS[i] = NULL;
        }


        pTable->Status = 0;

    } END_BREAKOUT_BLOCK1;

    return Error;

} //end _InitializeIfTable




//------------------------------------------------------------------------------
//        _DeInitializeIfTable
//------------------------------------------------------------------------------
VOID
DeInitializeIfTable(
    )
{
    PIGMP_IF_TABLE      pTable = g_pIfTable;
    PLIST_ENTRY         pHead, ple;
    PIF_TABLE_ENTRY     pite;
    DWORD               i, dwRetval;


    if (pTable==NULL)
        return;


    //
    // for each active interface call deregister MGM.
    //

    // go through the list of active interfaces ordered by IpAddr

    pHead = &g_pIfTable->ListByAddr;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByAddr);


        // if not activated then continue

        if (!IS_IF_ACTIVATED(pite))
            continue;


        // deregister all interfaces, ras clients and proxy protocol from mgm
        DeActivationDeregisterFromMgm(pite);
    }



    // delete the IfLists CS
    DeleteCriticalSection(&pTable->IfLists_CS);

    IGMP_FREE_NOT_NULL(pTable->aIfBucketDCS);
    IGMP_FREE_NOT_NULL(pTable->aIfBucketDRWL);
    IGMP_FREE_NOT_NULL(pTable->HashTableByIndex);
    IGMP_FREE_NOT_NULL(g_pIfTable);
    
    // I dont delete the different dynamic locks. They should have been deleted
    // by now

    return;
}


//------------------------------------------------------------------------------
//            _InitializeGroupTable                                              //
//------------------------------------------------------------------------------
DWORD
InitializeGroupTable (
    )
{
    BOOL            bErr = TRUE;
    DWORD           Error = NO_ERROR;
    PGROUP_TABLE    pGroupTable;
    DWORD           i;


    BEGIN_BREAKOUT_BLOCK1 {

        //
        // allocate space for the group table
        //

        g_pGroupTable = IGMP_ALLOC(sizeof(GROUP_TABLE), 0x800004,0);

        PROCESS_ALLOC_FAILURE2(g_pGroupTable,
                "error %d allocating %d bytes for Group table",
                Error, sizeof(GROUP_TABLE),
                GOTO_END_BLOCK1);


        pGroupTable = g_pGroupTable;


        //
        // initialize group tables' dynamically locked lists
        //

        for (i=0;  i<GROUP_HASH_TABLE_SZ;  i++) {
            InitDynamicCSLockedList(&pGroupTable->HashTableByGroup[i]);
        }


        //
        // initialize list of all groups
        //
        try {
            CREATE_LOCKED_LIST(&pGroupTable->ListByGroup);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Error = GetExceptionCode();
            Trace1(ERR, "Exception %d creating locked list for Group Table",
                    Error);
            Logerr0(INIT_CRITSEC_FAILED, Error);
            GOTO_END_BLOCK1;
        }

        //
        // initialize the list of new groups
        //
        InitializeListHead(&pGroupTable->ListByGroupNew);
        pGroupTable->NumGroupsInNewList = 0;


        pGroupTable->Status = 0;

        bErr = FALSE;

    } END_BREAKOUT_BLOCK1;

    if (!bErr) {
        return Error==NO_ERROR ? ERROR_CAN_NOT_COMPLETE: Error;
    }
    else {
        return Error;
    }

} //end _InitializeGroupTable




//------------------------------------------------------------------------------
//            DeInitializeGroupTable                                                //
// Just delete the critical sections                                            //
//------------------------------------------------------------------------------
VOID
DeInitializeGroupTable (
    )
{
    PGROUP_TABLE    pGroupTable = g_pGroupTable;
    DWORD           i;


    if (pGroupTable==NULL)
        return;

    //
    // I dont try to delete the dynamically allocated locks as they should
    // have all been deleted by the last thread executing in that lock
    //


    DeleteCriticalSection(&pGroupTable->ListByGroup.Lock);
    IGMP_FREE_NOT_NULL(pGroupTable);
    
}


//------------------------------------------------------------------------------
//                _InitializeRasTable
// creates ras table and initializes the fields.
// called by _DeActivateInterfaceInitial() _AddIfEntry()
// The interface table is created during _AddIfEntry, as _ConnectRasClients can
//      be called even when the ras server interface is not activated
//------------------------------------------------------------------------------
DWORD
InitializeRasTable(
    DWORD           IfIndex,
    PIF_TABLE_ENTRY pite
    )
{
    DWORD            Error = NO_ERROR, i;
    PRAS_TABLE       prt;


    //
    // allocate Ras table
    //
    prt = IGMP_ALLOC(sizeof(RAS_TABLE), 0x800008,IfIndex);

    PROCESS_ALLOC_FAILURE2(prt, "error %d allocating %d bytes for Ras Table",
            Error, sizeof(RAS_TABLE),
            return Error);


    //set the ras table entry in pite
    pite->pRasTable = prt;


    // initialize list pointing to Ras Clients ordered by IpAddr
    InitializeListHead(&prt->ListByAddr);


    // initialize hash table containing lists pointing to Ras Clients
    // hashed on IpAddr

    for (i=0;  i<RAS_HASH_TABLE_SZ;  i++)
        InitializeListHead(&prt->HashTableByAddr[i]);


    // set backpointer to the interface table entry
    prt->pIfTable = pite;


    // set RefCount and Status
    prt->RefCount = 1;
    prt->Status = IF_CREATED_FLAG;


    return NO_ERROR;

} //end _InitializeRasTable


//todo:remove
//------------------------------------------------------------------------------
//              DeInitializeRasTable
//------------------------------------------------------------------------------
VOID
DeInitializeRasTable (
    PIF_TABLE_ENTRY     pite,
    BOOL                bFullCleanup
    )
{

    PRAS_TABLE          prt = pite->pRasTable;
    PRAS_TABLE_ENTRY    prte;
    PLIST_ENTRY         pHeadRas, pleRas;

    pHeadRas = &prt->ListByAddr;
    for (pleRas=pHeadRas->Flink;  pleRas!=pHeadRas;  pleRas=pleRas->Flink) {
        prte = CONTAINING_RECORD(pleRas, RAS_TABLE_ENTRY, LinkByAddr);

        MgmReleaseInterfaceOwnership(g_MgmIgmprtrHandle, pite->IfIndex,
                                        prte->NHAddr);
    }

    return;
}



//------------------------------------------------------------------------------
//          _MergeIfGroupsLists
//
// Merges the new GI list with the main GI list.
// Locks: Assumes the IF-GI list to be locked.
//------------------------------------------------------------------------------
VOID
MergeIfGroupsLists(
    PIF_TABLE_ENTRY pite
    )
{
    // sentinel is set at the end of the Main list so that all entries is inserted
    // before it. its group value is set to all 1's.
    GROUP_TABLE_ENTRY   pgeSentinel;
    GI_ENTRY            giSentinel;
    PGI_ENTRY           giNew, giMain;
    PLIST_ENTRY         pHeadNew, pHeadMain, pleMain, pleNew;

    Trace1(ENTER1, "Entering _MergeIfGroupLists(): IfIndex:%0x", pite->IfIndex);

    pHeadNew = &pite->ListOfSameIfGroupsNew;
    pHeadMain = &pite->ListOfSameIfGroups;


    //
    // if main list is empty, then just move the new list to main list
    // and I am done
    //
    if (IsListEmpty(pHeadMain)) {

        // insert pHeadMain into new list
        InsertHeadList(pHeadNew, pHeadMain);

        // remove new list header
        RemoveEntryList(pHeadNew);

        InitializeListHead(pHeadNew);

        return;
    }


    //
    // insert the sentinel at the end of the main list
    //
    pgeSentinel.GroupLittleEndian = ~0;
    giSentinel.pGroupTableEntry = &pgeSentinel;
    InsertTailList(pHeadMain, &giSentinel.LinkBySameIfGroups);



    pleMain = pHeadMain->Flink;
    giMain = CONTAINING_RECORD(pleMain, GI_ENTRY, LinkBySameIfGroups);



    // merge the lists by inserting the entries from new list into main list.

    for (pleNew=pHeadNew->Flink;  pleNew!=pHeadNew;  ) {

        giNew = CONTAINING_RECORD(pleNew, GI_ENTRY, LinkBySameIfGroups);
        pleNew=pleNew->Flink;


        while (giNew->pGroupTableEntry->GroupLittleEndian >
            giMain->pGroupTableEntry->GroupLittleEndian)
        {
            pleMain = pleMain->Flink;

            giMain = CONTAINING_RECORD(pleMain, GI_ENTRY, LinkBySameIfGroups);
        }

        InsertTailList(pleMain, &giNew->LinkBySameIfGroups);
    }

    //
    // reinitialize the New list
    //
    pite->NumGIEntriesInNewList = 0;
    InitializeListHead(&pite->ListOfSameIfGroupsNew);


    // remove the sentinel entry from the main list

    RemoveEntryList(&giSentinel.LinkBySameIfGroups);

    //DebugPrintIfGroups(pite, 0); //deldel

    Trace0(LEAVE1, "Leaving _MergeIfGroupsLists");
    return;

} //end _MergeIfGroupsLists



//------------------------------------------------------------------------------
//          _MergeProxyLists
//
// Merges the new GI list with the main GI list.
// Locks: Assumes the IF-GI list to be locked.
//------------------------------------------------------------------------------

VOID
MergeProxyLists(
    PIF_TABLE_ENTRY pite
    )
{
    // sentinel is set at the end of the Main list so that all entries is inserted
    // before it. its group value is set to all 1's.
    PROXY_GROUP_ENTRY   ProxySentinel, *pProxyNew, *pProxyMain;
    PLIST_ENTRY         pHeadNew, pHeadMain, pleMain, pleNew;

    Trace1(ENTER1, "Entering MergeProxyLists(): IfIndex:%0x", pite->IfIndex);

    pHeadNew = &pite->ListOfSameIfGroupsNew;
    pHeadMain = &pite->ListOfSameIfGroups;


    //
    // if main list is empty, then just move the new list to main list
    // and I am done
    //
    if (IsListEmpty(pHeadMain)) {

        CONCATENATE_LISTS(pite->ListOfSameIfGroups, pite->ListOfSameIfGroupsNew);

        pite->NumGIEntriesInNewList = 0;

        return;
    }


    //
    // insert the sentinel at the end of the main list
    //
    ProxySentinel.GroupLittleEndian = ~0;
    InsertTailList(pHeadMain, &ProxySentinel.LinkBySameIfGroups);



    pleMain = pHeadMain->Flink;
    pProxyMain = CONTAINING_RECORD(pleMain, PROXY_GROUP_ENTRY,
                                        LinkBySameIfGroups);



    // merge the lists by inserting the entries from new list into main list.

    for (pleNew=pHeadNew->Flink;  pleNew!=pHeadNew;  ) {

        pProxyNew = CONTAINING_RECORD(pleNew, PROXY_GROUP_ENTRY,
                                        LinkBySameIfGroups);
        pleNew=pleNew->Flink;


        while (pProxyNew->GroupLittleEndian > pProxyMain->GroupLittleEndian)
        {
            pleMain = pleMain->Flink;

            pProxyMain = CONTAINING_RECORD(pleMain, PROXY_GROUP_ENTRY,
                                            LinkBySameIfGroups);
        }

        InsertTailList(pleMain, &pProxyNew->LinkBySameIfGroups);
    }

    //
    // reinitialize the New list
    //
    pite->NumGIEntriesInNewList = 0;
    InitializeListHead(&pite->ListOfSameIfGroupsNew);


    // remove the sentinel entry from the main list

    RemoveEntryList(&ProxySentinel.LinkBySameIfGroups);

    Trace0(LEAVE1, "Leaving _MergeProxyLists");
    return;

} //end _MergeProxyLists




//------------------------------------------------------------------------------
//          _MergeGroupLists
//
// Merges the new group list with the main group list.
//
// Locks: Assumes the group list to be locked.
// Called by: MibGetInternalGroupIfsInfo() or InsertInGroupsList()
//------------------------------------------------------------------------------
VOID
MergeGroupLists(
    )
{
    // sentinel is set at the end of the Main list so that all entries is inserted
    // before it. its group value is set to all 1's.
    GROUP_TABLE_ENTRY   pgeSentinel;
    PGROUP_TABLE_ENTRY  pgeNew, pgeMain;
    PLIST_ENTRY         pHeadNew, pHeadMain, pleMain, pleNew;

    Trace0(ENTER1, "Entering _MergeGroupLists()");

#if DBG
    DebugPrintGroupsList(1);
#endif

    pHeadNew = &g_pGroupTable->ListByGroupNew;
    pHeadMain = &g_pGroupTable->ListByGroup.Link;


    //
    // if main list is empty, then just move the new list to main list
    // and I am done
    //
    if (IsListEmpty(pHeadMain)) {

        // insert pHeadMain into new list
        InsertHeadList(pHeadNew, pHeadMain);

        // remove new list header
        RemoveEntryList(pHeadNew);

        InitializeListHead(pHeadNew);

        return;
    }


    //
    // insert the sentinel at the end of the main list
    //
    pgeSentinel.GroupLittleEndian = ~0;
    InsertTailList(pHeadMain, &pgeSentinel.LinkByGroup);

    pleMain = pHeadMain->Flink;
    pgeMain = CONTAINING_RECORD(pleMain, GROUP_TABLE_ENTRY, LinkByGroup);


    // merge the lists by inserting the entries from new list into main list.

    for (pleNew=pHeadNew->Flink;  pleNew!=pHeadNew;  ) {

        pgeNew = CONTAINING_RECORD(pleNew, GROUP_TABLE_ENTRY, LinkByGroup);
        pleNew=pleNew->Flink;


        while (pgeNew->GroupLittleEndian > pgeMain->GroupLittleEndian) {

            pleMain = pleMain->Flink;

            pgeMain = CONTAINING_RECORD(pleMain, GROUP_TABLE_ENTRY,
                                        LinkByGroup);
        }

        InsertTailList(pleMain, &pgeNew->LinkByGroup);
    }

    //
    // reinitialize the New list
    //
    g_pGroupTable->NumGroupsInNewList = 0;
    InitializeListHead(&g_pGroupTable->ListByGroupNew);


    // remove the sentinel entry from the main list

    RemoveEntryList(&pgeSentinel.LinkByGroup);


    return;

} //end _MergeGroupLists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\work1.c ===
#include "pchigmp.h"
#pragma hdrstop


//deldel
#define PRINT_SOURCES_LIST 0

VOID
DebugSources(
    PGI_ENTRY pgie
    )
{
    PGI_SOURCE_ENTRY    pSourceEntry, pSourceEntry2;
    PLIST_ENTRY pHead, ple;

    DebugPrintSourcesList(pgie);

    pHead = &pgie->V3InclusionListSorted;
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSourcesInclListSorted);

        if (GetSourceEntry(pgie, pSourceEntry->IpAddr,EXCLUSION, NULL, 0, 0))
            DbgBreakPoint();

        if (ple->Flink!=pHead) {
            pSourceEntry2 = CONTAINING_RECORD(ple->Flink, GI_SOURCE_ENTRY,LinkSourcesInclListSorted);
            if (pSourceEntry2->IpAddr==pSourceEntry->IpAddr)
                DbgBreakPoint();
        }
    }

    pHead = &pgie->V3ExclusionList;
    for (ple=pHead->Flink;  ple!=pHead && ple->Flink!=pHead;  ple=ple->Flink) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSources);
        pSourceEntry2 = CONTAINING_RECORD(ple->Flink, GI_SOURCE_ENTRY,LinkSources);
        if (pSourceEntry->IpAddr == pSourceEntry2->IpAddr)
            DbgBreakPoint();
    }
    return;
}


DWORD
ProcessGroupQuery(
    PIF_TABLE_ENTRY     pite,
    IGMP_HEADER UNALIGNED   *pHdr,
    DWORD               InPacketSize,
    DWORD               InputSrcAddr,
    DWORD               DstnMcastAddr
    )
{
    PGROUP_TABLE_ENTRY          pge;    //group table entry
    PGI_ENTRY                   pgie;    //group interface entry
    BOOL                        bCreateGroup, bCreateGI;
    DWORD                       NHAddr =0, PacketSize, Group, i,RealPktVersion,
                                IfIndex=pite->IfIndex, PktVersion, GIVersion, IfVersion;
    BOOL                        bRas=FALSE, bUpdateGroupTimer=FALSE;
    DWORD                       NumGroupRecords;
    LONGLONG                    llCurTime = GetCurrentIgmpTime();
    PIGMP_IF_CONFIG             pConfig = &pite->Config;
    PIGMP_HEADER_V3_EXT         pSourcesRecord;
    
    Trace0(ENTER1, "Entering _ProcessGroupQuery()");
    
    RealPktVersion = InPacketSize>sizeof(IGMP_HEADER)?3:2;
    PktVersion = (InPacketSize>sizeof(IGMP_HEADER) && IS_IF_VER3(pite))?3:2;
    
    IfVersion = IS_IF_VER1(pite)? 1: (IS_IF_VER2(pite)?2:3);
    Group = pHdr->Group;
    
    Trace3(RECEIVE,
        "Group-specific-query(%d) received from %d.%d.%d.%d for "
        "group(%d.%d.%d.%d)",
        RealPktVersion, PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr));    

    if (RealPktVersion==3) {

        // validate packet size
        if (InPacketSize<sizeof(IGMP_HEADER)+sizeof(IGMP_HEADER_V3_EXT)) {
            Trace0(RECEIVE,
                "Group-specific-query dropped. Invalid packet size");
            return ERROR_CAN_NOT_COMPLETE;
        }

        pSourcesRecord = (PIGMP_HEADER_V3_EXT)(pHdr+1);
        //convert to host order
        pSourcesRecord->NumSources = ntohs(pSourcesRecord->NumSources);
        
        if (InPacketSize<sizeof(IGMP_HEADER)+sizeof(IGMP_HEADER_V3_EXT)
                         + pSourcesRecord->NumSources*sizeof(IPADDR))
        {
            Trace0(RECEIVE,
                "Group-specific-query dropped. Invalid packet size");
            return ERROR_CAN_NOT_COMPLETE;
        }

        for (i=0;  i<pSourcesRecord->NumSources;  i++) {
            Trace1(RECEIVE,"        %d.%d.%d.%d", 
                PRINT_IPADDR(pSourcesRecord->Sources[i]));
        }
    }
    
    // 
    // the multicast group should not be 224.0.0.x
    //
    if (LOCAL_MCAST_GROUP(DstnMcastAddr)) {
        Trace2(RECEIVE, 
            "Group-specific-query received from %d.%d.%d.%d for "
            "Local group(%d.%d.%d.%d)",
            PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr));    
        return ERROR_CAN_NOT_COMPLETE;
    }
    
        
    //
    // make sure that the dstn addr and the group fields match
    //
    if (Group!=DstnMcastAddr) {
        Trace4(RECEIVE, 
            "Received Igmp packet (%d) from(%d.%d.%d.%d) with "
            "Multicast(%d.%d.%d.%d) addr different from "
            "Group(%d.%d.%d.%d)",
            IfIndex,  PRINT_IPADDR(InputSrcAddr), 
            PRINT_IPADDR(DstnMcastAddr),
            PRINT_IPADDR(pHdr->Group)
            );
        return ERROR_CAN_NOT_COMPLETE;
    }


    // note that a querier can receive a group-Sp query from a non querier
    
            
    //
    // if Leave processing not enabled or currently version-1 or ras server interface
    // then ignore.
    //
    if ( !IF_PROCESS_GRPQUERY(pite) ) {
        Trace0(RECEIVE, "Ignoring the Group-Specific-Query");
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // Lock the group table
    //
    ACQUIRE_GROUP_LOCK(Group, "_ProcessGroupQuery");
    

    //
    // find the group entry. If entry not found then ignore the group query
    //
    pge = GetGroupFromGroupTable(Group, NULL, llCurTime);
    if (pge==NULL) {
        Trace2(ERR, "group sp-query received for nonexisting "
                "group(%d.%d.%d.%d) on IfIndex(%0x)",
                PRINT_IPADDR(Group), IfIndex);
        RELEASE_GROUP_LOCK(Group, "_ProcessGroupQuery");
        return ERROR_CAN_NOT_COMPLETE;
    }
    

    //
    // find the GI entry. If GI entry does not exist or has deletedFlag then
    // ignore the GroupSpQuery
    //
    pgie = GetGIFromGIList(pge, pite, InputSrcAddr, NOT_STATIC_GROUP, NULL, llCurTime);
    if ( (pgie==NULL)||(pgie->Status&DELETED_FLAG) ) {
        Trace2(ERR, "group sp-query received for group(%d.%d.%d.%d) on "
            "IfIndex(%0x). Not member.",
            PRINT_IPADDR(Group), IfIndex);
        RELEASE_GROUP_LOCK(Group, "_ProcessGroupQuery");
        return ERROR_CAN_NOT_COMPLETE;
    }

    GIVersion = pgie->Version;

    // treat it as ver 2 packet if group in ver-2 mode
    if (GIVersion==2 && PktVersion==3)
        PktVersion = 2;

    if (RealPktVersion==3 && PktVersion==2)
        Trace0(RECEIVE, "Processing the Version:3 GroupSpQuery as Version:2");
    
    //
    // if interface is ver-1 or its leave enabled flag is not set or
    // if v1-report received recently for that group, then ignore
    // LastMemQuery messages. 
    //
    if ( !GI_PROCESS_GRPQUERY(pite, pgie) )
    {
        Trace2(RECEIVE, 
            "Leave not processed for group(%d.%d.%d.%d) on IfIndex(%0x)"
            "(recent v1 report) or interface ver-1",
            PRINT_IPADDR(Group), IfIndex
            );
        RELEASE_GROUP_LOCK(Group, "_ProcessGroupQuery");
        return ERROR_CAN_NOT_COMPLETE;
    }


    
    ACQUIRE_TIMER_LOCK("_ProcessGroupQuery");

    BEGIN_BREAKOUT_BLOCK1 {

        if (PktVersion==2 && GIVersion==2) {
            //
            // if membership timer already expired then return. The group will be 
            // deleted by the expiry of the membership timer
            //
            if ( (!(pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE))
                ||(pgie->GroupMembershipTimer.Timeout<llCurTime) )
            {
                //DeleteGIEntry(pgie, TRUE);

                GOTO_END_BLOCK1;
            }

            //
            // if currently processing a leave then remove LeaveTimer if received
            // LastMemquery from lower Ip, else ignore the LastMemQuery
            //
            if (pgie->LastMemQueryCount>0) {
                INT cmp;
                if (INET_CMP(InputSrcAddr,pite->IpAddr, cmp)<0)  {
                    if (pgie->LastMemQueryTimer.Status==TIMER_STATUS_ACTIVE) {
                        RemoveTimer(&pgie->LastMemQueryTimer, DBG_Y);
                    }

                    pgie->LastMemQueryCount = 0;
                }
                
                GOTO_END_BLOCK1;
            }

            
            //
            // set membership timer to 
            // min{currentValue,MaxResponseTimeInPacket*LastMemQueryCount}
            //
            if (pgie->GroupMembershipTimer.Timeout >
                (llCurTime+( ((LONGLONG)pConfig->LastMemQueryCount)
                            *pHdr->ResponseTime*100 ))
               )
            {
                //divide by 10, as Response time in units of 100ms

                #if DEBUG_TIMER_TIMERID
                    SET_TIMER_ID(&pgie->GroupMembershipTimer, 330, 
                            pite->IfIndex, Group, 0);
                #endif

                if (IS_TIMER_ACTIVE(pgie->GroupMembershipTimer)) {
                    UpdateLocalTimer(&pgie->GroupMembershipTimer, 
                        pConfig->LastMemQueryCount*pHdr->ResponseTime*100, DBG_N);
                }
                else {
                    InsertTimer(&pgie->GroupMembershipTimer, 
                        pConfig->LastMemQueryCount*pHdr->ResponseTime*100, 
                        TRUE, DBG_N
                        );
                }

                // update GroupExpiryTime so that correct stats are displayed
                pgie->Info.GroupExpiryTime = llCurTime 
                        + CONFIG_TO_SYSTEM_TIME(pConfig->LastMemQueryCount
                                                *pHdr->ResponseTime*100);
            }
        }
        else if (PktVersion==2 && GIVersion==3){
            // ignore the packet
            Trace0(RECEIVE, "Ignoring the version-2 group specific query");
        }
        else if (PktVersion==3 && GIVersion==3) {
            
            // ignore it if SFlag set
            if (pSourcesRecord->SFlag == 1)
                GOTO_END_BLOCK1;

            for (i=0;  i<pSourcesRecord->NumSources;  i++) {

                IPADDR Source;
                PGI_SOURCE_ENTRY pSourceEntry;

                Source = pSourcesRecord->Sources[i];
                
                pSourceEntry = GetSourceEntry(pgie, Source, INCLUSION,
                                    NULL, 0, 0);
                if (!pSourceEntry)
                    continue;

                if ((QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                        >pgie->pIfTableEntry->Config.LastMemQueryInterval) )
                {
                    #if DEBUG_TIMER_TIMERID
                    pSourceEntry->SourceExpTimer.Id = 621;
                    pSourceEntry->SourceExpTimer.Id2 = TimerId++;
                    #endif
                    UpdateLocalTimer(&pSourceEntry->SourceExpTimer,
                        pite->Config.LastMemQueryInterval, DBG_N);
                }
            }
        }
        
    } END_BREAKOUT_BLOCK1;

    //
    //release timer and groupBucket locks
    //
    RELEASE_TIMER_LOCK("_ProcessGroupQuery");
    RELEASE_GROUP_LOCK(Group, "_ProcessGroupQuery");

    Trace0(LEAVE1, "Leaving _ProcessGroupQuery()");
    return NO_ERROR;
}

        
DWORD
ProcessReport(
    PIF_TABLE_ENTRY     pite,
    IGMP_HEADER UNALIGNED   *pHdr,
    DWORD               InPacketSize,
    DWORD               InputSrcAddr,
    DWORD               DstnMcastAddr
    )
{
    PGROUP_TABLE_ENTRY          pge;    //group table entry
    PGI_ENTRY                   pgie;    //group interface entry
    BOOL                        bCreateGroup, bCreateGI;
    DWORD                       NHAddr =0, PacketSize, Group, i, 
                                IfIndex=pite->IfIndex, PktVersion, GIVersion, IfVersion;
    BOOL                        bRas=FALSE, bUpdateGroupTimer=FALSE;
    DWORD                       NumGroupRecords;
    LONGLONG                    llCurTime = GetCurrentIgmpTime();
    PIGMP_IF_CONFIG             pConfig = &pite->Config;
    
    //v3
    PGROUP_RECORD               pGroupRecord;


    Trace0(ENTER1, "Entering _ProcessReport()");

    switch(pHdr->Vertype)
    {
        case IGMP_REPORT_V1: PktVersion=1; break;
        case IGMP_REPORT_V2: PktVersion=2; break;
        case IGMP_REPORT_V3: PktVersion=3; break;
    }
    IfVersion = IS_IF_VER1(pite)? 1: (IS_IF_VER2(pite)?2:3);

    Trace5(RECEIVE, 
        "IGMP-V%d Report from (%d.%d.%d.%d) on "
        "IfIndex(%0x)%d.%d.%d.%d dstaddr:%d.%d.%d.%d",
        PktVersion, PRINT_IPADDR(InputSrcAddr), IfIndex, 
        PRINT_IPADDR(pite->IpAddr), 
        PRINT_IPADDR(DstnMcastAddr)
        );


    //
    // the multicast group should not be 224.0.0.x or SSM
    //
    if (PktVersion!=3 && (LOCAL_MCAST_GROUP(pHdr->Group) || 
                        SSM_MCAST_GROUP(pHdr->Group)))
    {
        Trace3(RECEIVE, 
            "Igmp-v%d report received from %d.%d.%d.%d for Local/SSM group(%d.%d.%d.%d)",
            PktVersion, PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr));    
        return ERROR_CAN_NOT_COMPLETE;
    }

    if (PktVersion!=3)
        Trace1(RECEIVE, "      Group:%d.%d.%d.%d\n", PRINT_IPADDR(pHdr->Group));
    
    if (PktVersion==3) {

        //
        // validate packet size
        //

        // convert to host order
        pHdr->NumGroupRecords = ntohs(pHdr->NumGroupRecords);
        
        PacketSize = sizeof(IGMP_HEADER);
        NumGroupRecords = pHdr->NumGroupRecords;

        // min size of each group record is 2*ipaddr
        PacketSize += NumGroupRecords*2*sizeof(IPADDR);

        BEGIN_BREAKOUT_BLOCK1 {
            PCHAR StrRecordType[] = {"", "is_in", "is_ex", "to_in", 
                                    "to_ex", "allow", "BLOCK"};
            i = 0;
            if (PacketSize>InPacketSize) {
                GOTO_END_BLOCK1;
            }

            pGroupRecord = GET_FIRST_GROUP_RECORD(pHdr);
            for (;  i<NumGroupRecords;  i++) {

                DWORD j;
                
                // convert to host order
                pGroupRecord->NumSources = ntohs(pGroupRecord->NumSources);
                
                PacketSize += pGroupRecord->NumSources*sizeof(IPADDR);
                if (PacketSize>InPacketSize)
                    GOTO_END_BLOCK1;

                // print group record
                Trace3(RECEIVE,
                    "<      Group:%d.%d.%d.%d RecordType:%s NumSources:%d >",
                    PRINT_IPADDR(pGroupRecord->Group), 
                    StrRecordType[pGroupRecord->RecordType], 
                    pGroupRecord->NumSources
                    );
                for (j=0; j<pGroupRecord->NumSources;  j++)
                    Trace1(RECEIVE, "          %d.%d.%d.%d", 
                       PRINT_IPADDR(pGroupRecord->Sources[j]));

                //
                // error if local_mcast or ssm-exclude mode
                //
                if (LOCAL_MCAST_GROUP(pGroupRecord->Group) || 
                        (SSM_MCAST_GROUP(pGroupRecord->Group)
                        && (pGroupRecord->RecordType == IS_EX
                            || pGroupRecord->RecordType == TO_EX)) )
                {
                    Trace3(RECEIVE, 
                        "Igmp-v%d report received from %d.%d.%d.%d for Local/SSM group(%d.%d.%d.%d)",
                        PktVersion, PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr));    
                    return ERROR_CAN_NOT_COMPLETE;
                }

                 
                pGroupRecord = (PGROUP_RECORD) 
                                &(pGroupRecord->Sources[pGroupRecord->NumSources]);

            }
        } END_BREAKOUT_BLOCK1;
        
        if (i!=NumGroupRecords || PacketSize>InPacketSize) {
            Trace0(ERR, "Received IGMP-v3 report small size");
            InterlockedIncrement(&pite->Info.ShortPacketsReceived);
            return ERROR_CAN_NOT_COMPLETE;
        }
        if (PacketSize<InPacketSize){
            Trace0(ERR, "Received IGMP-v3 report large size");
            InterlockedIncrement(&pite->Info.LongPacketsReceived);
        }
        
        pGroupRecord = GET_FIRST_GROUP_RECORD(pHdr);
    }//pktversion==3
    
    // for v1 and v2, set num group records to 1 so that it will come out of 
    // loop
    else {
        NumGroupRecords = 1;
    }


    //
    // check that the dstn addr is correct.
    // should be same as group, or unicast ipaddr
    // or v3: could be All_Igmp_routers group
    //
    if (! ((DstnMcastAddr==pite->IpAddr)
          || (PktVersion!=3 && DstnMcastAddr==pHdr->Group)
          || (PktVersion==3 && DstnMcastAddr==ALL_IGMP_ROUTERS_MCAST)) )
    {
        Trace3(RECEIVE, 
            "received IGMP report packet on IfIndex(%0x) from "
            "SrcAddr(%d.%d.%d.%d) but invalid DstnMcastAddr(%d.%d.%d.%d)",
            IfIndex, PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr)
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // V1 router ignores V2/V3 reports. V2 router ignores v3 reports
    //
    if ( (IfVersion==1 && (PktVersion==2||PktVersion==3))
        ||(IfVersion==2 && PktVersion==3) )
    {
        Trace1(RECEIVE, "Ignoring higher version:%d IGMP report", PktVersion);
        return NO_ERROR;
    }

    //
    // update statistics
    //
    InterlockedIncrement(&pite->Info.JoinsReceived);


    // numgrouprecords==1 for v1,v2
    for (i=0;  i<NumGroupRecords;  i++) {

        Group = (PktVersion==3)? pGroupRecord->Group : pHdr->Group;

        if ( !IS_MCAST_ADDR(Group) ) {
            Trace4(RECEIVE, 
                "received IGMP Leave packet with illegal Group(%d.%d.%d.%d) field: "
                "IfIndex(%0x) SrcAddr(%d.%d.%d.%d) DstnMcastAddr(%d.%d.%d.%d)",
                PRINT_IPADDR(Group), IfIndex, PRINT_IPADDR(InputSrcAddr), 
                PRINT_IPADDR(DstnMcastAddr)
                );
        }
        
        if (LOCAL_MCAST_GROUP(Group)) {

            if (PktVersion==3){
                pGroupRecord = (PGROUP_RECORD) 
                        &(pGroupRecord->Sources[pGroupRecord->NumSources]);
                continue;
            }
            else
                break;
        }

        //kslksl
        if (PktVersion==3 && pGroupRecord->NumSources==0 && 
            pGroupRecord->RecordType==IS_IN)
        {
            pGroupRecord = (PGROUP_RECORD) 
                        &(pGroupRecord->Sources[pGroupRecord->NumSources]);
            continue;
        }

        
        //
        // Lock the group table
        //
        ACQUIRE_GROUP_LOCK(Group, "_ProcessReport");

        //
        // find the group entry and create one if not found
        // also increment GroupMembership count if req
        //
        bCreateGroup = TRUE; 
        pge = GetGroupFromGroupTable(Group, &bCreateGroup, llCurTime);
        if (pge==NULL) {
            RELEASE_GROUP_LOCK(Group, "_ProcessReport");
            return ERROR_CAN_NOT_COMPLETE;
        }


        //
        // find the GI entry and if not found create one.
        // the version in GI entry is same as that of interface
        //
        
        bCreateGI = TRUE;
        pgie = GetGIFromGIList(pge, pite, InputSrcAddr, NOT_STATIC_GROUP, 
                                &bCreateGI, llCurTime);
        if (pgie==NULL) {
            RELEASE_GROUP_LOCK(Group, "_ProcessReport");
            return ERROR_CAN_NOT_COMPLETE;
        }
        GIVersion = pgie->Version;


        
        // acquire timer lock
        ACQUIRE_TIMER_LOCK("_ProcessReport");

        
        //
        // update the ver-1, membership, and lastMemTimer.
        // Note: the GI entry might be a new one or old one
        //

        // 
        // shift to version 1 level processing
        //
        if (PktVersion==1) {
            
            if (GIVersion!=1) {
                pgie->Version = 1;

                if (GIVersion==3) {

                    if (pgie->FilterType!=EXCLUSION) {
                        // add (*,g) to MGM
                        MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite, NHAddr, 0, 0, Group, 
                            0xffffffff, MGM_JOIN_STATE_FLAG);
                    }
                    
                    GIDeleteAllV3Sources(pgie, TRUE);
                }

                // gi version from 2,3-> 1
                GIVersion = 1;
            }

            //
            // received v1 report when IF not v1. update v1host timer.
            //
            if (!IS_IF_VER1(pite)) {

                #if DEBUG_TIMER_TIMERID
                    SET_TIMER_ID(&pgie->LastVer1ReportTimer,510, pite->IfIndex, 
                                Group, 0);
                #endif 
                
                if (IS_TIMER_ACTIVE(pgie->LastVer1ReportTimer)) {
                    UpdateLocalTimer(&pgie->LastVer1ReportTimer, 
                            pConfig->GroupMembershipTimeout, DBG_N);
                }
                else {
                    InsertTimer(&pgie->LastVer1ReportTimer, 
                        pConfig->GroupMembershipTimeout, TRUE, DBG_N);
                }


                // set the V1HostPresentTimeLeft value for stats
                
                pgie->Info.V1HostPresentTimeLeft = llCurTime 
                             + CONFIG_TO_SYSTEM_TIME(pConfig->GroupMembershipTimeout);            
            }

            
            // update group timer for all versions
            bUpdateGroupTimer = TRUE;
        }

        //
        // shift to version 2 level processing
        //
        
        else if (PktVersion==2) {

            if (GIVersion==3) {

                pgie->Version = 2;

                if (pgie->FilterType!=EXCLUSION) {
                    // add (*,g) to MGM
                    MGM_ADD_GROUP_MEMBERSHIP_ENTRY(
                        pite, NHAddr, 0, 0, Group, 0xffffffff,
                        MGM_JOIN_STATE_FLAG);
                }
                
                GIDeleteAllV3Sources(pgie, TRUE);

                // gi version from 3->2
                GIVersion = 2;
            }

            //
            // received v2 report when in in v3 mode. update v2host timer.
            if (IS_IF_VER3(pite)) {

                #if DEBUG_TIMER_TIMERID
                    SET_TIMER_ID(&pgie->LastVer2ReportTimer,550, pite->IfIndex, 
                                Group, 0);
                #endif 
                
                if (IS_TIMER_ACTIVE(pgie->LastVer2ReportTimer)) {
                    UpdateLocalTimer(&pgie->LastVer2ReportTimer, 
                            pConfig->GroupMembershipTimeout, DBG_N);
                }
                else {
                    InsertTimer(&pgie->LastVer2ReportTimer, 
                        pConfig->GroupMembershipTimeout, TRUE, DBG_N);
                }


                // set the V2HostPresentTimeLeft value for stats
                
                pgie->Info.V2HostPresentTimeLeft = llCurTime 
                             + CONFIG_TO_SYSTEM_TIME(pConfig->GroupMembershipTimeout);
            }

            
            // update group timer for all versions
            bUpdateGroupTimer = TRUE;
        }
        else if (PktVersion==3) {

            if (GIVersion!=3) {
                // update timer only if it is not a v3 block message
                if (bCreateGI || pGroupRecord->RecordType!=BLOCK)
                    bUpdateGroupTimer = TRUE;
            }
            else {
                ProcessV3Report(pgie, pGroupRecord, &bUpdateGroupTimer);
            }
        }


        // NOTE: if giversion==3, then pgie may be invalid below here

        
        //
        // report received. so remove the lastMemTimer if pgie is not v3.
        //
        if (GIVersion!=3 && pgie->LastMemQueryCount>0) {

            if (pgie->LastMemQueryTimer.Status&TIMER_STATUS_ACTIVE) 
                RemoveTimer(&pgie->LastMemQueryTimer, DBG_Y);

            pgie->LastMemQueryCount = 0;
        }


        if (bUpdateGroupTimer) {
            //
            // update membership timer
            //
            #if DEBUG_TIMER_TIMERID
                (&pgie->GroupMembershipTimer)->Id = 320;
                (&pgie->GroupMembershipTimer)->IfIndex = 320;

                SET_TIMER_ID(&pgie->GroupMembershipTimer,320, pite->IfIndex, 
                        Group, 0);
            #endif
            
            if (IS_TIMER_ACTIVE(pgie->GroupMembershipTimer))  {
                UpdateLocalTimer(&pgie->GroupMembershipTimer, 
                    pite->Config.GroupMembershipTimeout, DBG_N);
            }
            else {
                InsertTimer(&pgie->GroupMembershipTimer, 
                    pite->Config.GroupMembershipTimeout, TRUE, DBG_N);
            }
            
            // update GroupExpiryTime
            {
                LONGLONG    tempTime;
                tempTime = llCurTime 
                       + CONFIG_TO_SYSTEM_TIME(pite->Config.GroupMembershipTimeout);
                pgie->Info.GroupExpiryTime = tempTime;
            }
        }


        if (pgie->Version==3 && pgie->FilterType==INCLUSION  && pgie->NumSources==0) {
            DeleteGIEntry(pgie, TRUE, TRUE);
        }
            
        RELEASE_TIMER_LOCK("_ProcessReport");
    
        //
        //update the last reporter field 
        //
        if (GIVersion!=3)
            InterlockedExchange(&pgie->Info.LastReporter, InputSrcAddr);
    
        //
        // Release the group table lock
        //
        RELEASE_GROUP_LOCK(Group, "_ProcessReport");

        if (PktVersion==3) {
            pGroupRecord = (PGROUP_RECORD) 
                        &(pGroupRecord->Sources[pGroupRecord->NumSources]);
        }
        else
            break;
    }//for all group records

    Trace0(LEAVE1, "Leaving _ProcessReport()");
    return NO_ERROR;
}


//------------------------------------------------------------------------------

DWORD
ProcessV3Report(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord,
    BOOL *bUpdateGroupTimer
    )
{
    BOOL                bCreate;
    PGI_SOURCE_ENTRY    pSourceEntry;
    DWORD               i,j;
    IPADDR              Source;
    PLIST_ENTRY         ple, pHead;

    Trace0(ENTER1, "Entering _Processv3Report()");

    *bUpdateGroupTimer = FALSE;

//deldel
//DebugPrintSourcesList(pgie);
//DebugPrintSourcesList1(pgie);
//DebugPrintIfGroups(pgie->pIfTableEntry,0);


    //kslksl
    if (pGroupRecord->NumSources==0 && pGroupRecord->RecordType==IS_IN)
        return NO_ERROR;

    switch(pGroupRecord->RecordType) {

    case IS_IN:
    {        
        //(11)---------------------------
        // INCLUSION(A), IS_IN(b): A=A+b,(B)=gmi
        
        if (pgie->FilterType==INCLUSION) {

            //
            // include all sources in groupRecord and update timers for them
            //
            
            for (i=0;  i<pGroupRecord->NumSources;  i++) {//sources in pkt

                //kslksl
                if (pGroupRecord->Sources[i]==0||pGroupRecord->Sources[i]==0xffffffff)
                    continue;
                

                Source = pGroupRecord->Sources[i];

                bCreate = TRUE;
                pSourceEntry = GetSourceEntry(pgie, Source, INCLUSION, 
                                    &bCreate, GMI, MGM_YES);
                if (pSourceEntry==NULL)
                    return ERROR_NOT_ENOUGH_MEMORY;

                
                // update source timer if already exists
                if (bCreate==FALSE) {
                    UpdateSourceExpTimer(pSourceEntry,
                        GMI,
                        FALSE //remove from lastmem list
                        );
                }
            }
        }
        else {
            //(13)--------------------------------(same as 6)
            // exclusion Mode(x,y), IS_IN pkt(a): (x+a,y-a), (a)=gmi

            MoveFromExcludeToIncludeList(pgie, pGroupRecord);
        }
        break;
    }//end case _IS_IN
    
    case IS_EX:
    {
        //(12)----------------------------------------
        //INCLUSION Mode(A), IS_EX(B): (A*B,B-A), 
        //Delete(A-B),GT=GMI,(b-a)=0
                
        if (pgie->FilterType==INCLUSION) {

            // change from in->ex
            pgie->FilterType = EXCLUSION;
            MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pgie->pIfTableEntry,pgie->NHAddr, 0, 0,
                    pgie->pGroupTableEntry->Group, 0xffffffff, MGM_JOIN_STATE_FLAG);

            // delete (A-B)
            SourcesSubtraction(pgie, pGroupRecord, INCLUSION);
            
            
            // create (B-A) in exclusion Mode
            
            for (j=0;  j<pGroupRecord->NumSources;  j++) {
                if (!GetSourceEntry(pgie, pGroupRecord->Sources[j],INCLUSION, 
                        NULL,0,0))
                {
                    BOOL bCreate=TRUE;

                    // IF already pruned from mfe. keep it that way
                    GetSourceEntry(pgie, pGroupRecord->Sources[j], EXCLUSION,
                        &bCreate,0, MGM_YES);
                }
            }

            // update group timer
            *bUpdateGroupTimer = TRUE;
        }

        //(14)--------------------------------------
        // EXCLUSION Mode(x,y), IS_EX(a); D(x-a),D(y-a),GT=gmi
        else {
            //(X-A), (y-a)
            SourcesSubtraction(pgie, pGroupRecord, INCLUSION);
            SourcesSubtraction(pgie, pGroupRecord, EXCLUSION);

            // if a not in y, then insert in x(IN) (a-x-y)=GMI
            for (j=0;  j<pGroupRecord->NumSources;  j++) {

                //kslksl
                if (pGroupRecord->Sources[j]==0||pGroupRecord->Sources[j]==0xffffffff)
                continue;
                

                pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], EXCLUSION,
                                    NULL,0,0);

                if (!pSourceEntry) {
                    bCreate = TRUE;
                    pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                                        INCLUSION, &bCreate, GMI, MGM_YES);
                }
            }

            // update group timer
            *bUpdateGroupTimer = TRUE;

        }//end4

        break;
        
    }//case IS_EX


    case ALLOW :
    {
        //(1)----------------------------------------
        // INCLUSION Mode(a), ALLOW pkt(b): (a+b), (b)=gmi
        
        if (pgie->FilterType==INCLUSION) {

            InclusionSourcesUnion(pgie, pGroupRecord);
        }
        
        //(6)----------------------------------------
        // EXCLUSION Mode(x,y), ALLOW pkt(a): (same as 13: (x+a, y-a)

        else {
            MoveFromExcludeToIncludeList(pgie, pGroupRecord);
        }

        break;
        
    }//case ALLOW


    case BLOCK :
    {
        //(2)----------------------------------------
        // INCLUSION Mode(x), BLOCK pkt(a): Send Q(G,A*B)
        
        if (pgie->FilterType==INCLUSION) {

            BuildAndSendSourcesQuery(pgie, pGroupRecord, INTERSECTION);
        }
        
        //(7)----------------------------------------
        // EXCLUSION Mode(x,y), BLOCK pkt(a): (x+(a-y),y),Send Q(a-y)
        else {
            
            BuildAndSendSourcesQuery(pgie, pGroupRecord, EXCLUSION);
        }

        break;
        
        
    }//case BLOCK

    case TO_EX :
    {
        //(4)----------------------------------------
        // INCLUSION Mode(x), TO_EX pkt(a)
        // move to EX mode: EX(A*b,b-a),Send Q(G,A*B)
        
        if (pgie->FilterType==INCLUSION) {

            pgie->FilterType = EXCLUSION;

            // exclusion mode: add (*,g) to MGM
            MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pgie->pIfTableEntry,pgie->NHAddr, 0, 0,
                pgie->pGroupTableEntry->Group, 0xffffffff, MGM_JOIN_STATE_FLAG);


            // delete (a-b) from IN list
            SourcesSubtraction(pgie, pGroupRecord, INCLUSION);

            //
            // add (b-a) to EX list. IF not added to mfe. so no mgm.
            //
            
            for (j=0;  j<pGroupRecord->NumSources;  j++) {

                //kslksl
                if (pGroupRecord->Sources[j]==0||pGroupRecord->Sources[j]==0xffffffff)
                    continue;
                

                pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                                    INCLUSION, NULL, 0, 0);

                if (!pSourceEntry) {
                    bCreate = TRUE;
                    GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                        EXCLUSION, &bCreate, 0, MGM_NO);
                }
            }

            // send Q for sources left in IN list
            BuildAndSendSourcesQuery(pgie, pGroupRecord, INCLUSION);

            // update group timer
            *bUpdateGroupTimer = TRUE;
            
        }
        //(9)----------------------------------------
        // EXCLUSION Mode(x,y), TO_EX pkt(a): (

        else {
            // delete (x-a) from IN list
            SourcesSubtraction(pgie, pGroupRecord, INCLUSION);

            // delete (y-a) from EX list
            SourcesSubtraction(pgie, pGroupRecord, EXCLUSION);

            // add x+(a-y) and send Q(a-y)
            BuildAndSendSourcesQuery(pgie, pGroupRecord, EXCLUSION);

            // update group timer
            *bUpdateGroupTimer = TRUE;
        }

        break;

    }//case TO_EX

    case TO_IN :
    {
        //(5)----------------------------------------
        // INCLUSION Mode(a), TO_IN(b): IN(a+b),Send Q(G,A*B)
        
        if (pgie->FilterType==INCLUSION) {

            // for all a not in b, send sources query
            BuildAndSendSourcesQuery(pgie, pGroupRecord, RULE5);
            
            // inc a+b
            InclusionSourcesUnion(pgie, pGroupRecord);
        }
        
        //(10)----------------------------------------
        // EXCLUSION Mode(x,y), TO_IN pkt(a): (
        else {
            PIGMP_IF_CONFIG     pConfig = &pgie->pIfTableEntry->Config;

            
            // for all x not in a, send sources query
            BuildAndSendSourcesQuery(pgie, pGroupRecord, RULE5);


            // x+a. a=gmi. if in ex list move it to in list
            InclusionSourcesUnion(pgie, pGroupRecord);

            // set group query count
            pgie->LastMemQueryCount = pConfig->LastMemQueryCount;


            ACQUIRE_TIMER_LOCK("_ProcessV3Report");

            // set group query timer
            #if DEBUG_TIMER_TIMERID
            SET_TIMER_ID(&pgie->LastMemQueryTimer, 410,
                pgie->pIfTableEntry->IfIndex, pgie->pGroupTableEntry->Group, 0);
            #endif

            InsertTimer(&pgie->LastMemQueryTimer, 
                pConfig->LastMemQueryInterval/pConfig->LastMemQueryCount, TRUE, 
                DBG_N);

            // update group expiry timer to LMQI
            UpdateLocalTimer(&pgie->GroupMembershipTimer, 
                pConfig->LastMemQueryInterval, DBG_Y);

            RELEASE_TIMER_LOCK("_ProcessV3Report");


            // send group query
            SendV3GroupQuery(pgie);
        }

        break;

    }//case TO_IN

    
    }//end switch


    #if PRINT_SOURCES_LIST
    DebugPrintSourcesList(pgie);
    #endif
    //DebugPrintIfGroups(pgie->pIfTableEntry,0);//deldel

    Trace0(LEAVE1, "Leaving _ProcessV3Report()");

    return NO_ERROR;
}

VOID
DebugPrintSourcesList(
    PGI_ENTRY pgie
    )
{
    PLIST_ENTRY pHead, ple;
    PGI_SOURCE_ENTRY  pSourceEntry;
    LONGLONG llCurTime = GetCurrentIgmpTime();
    DWORD Count=0;


    Trace2(SOURCES,
        "\nPrinting SourcesList for Group: %d.%d.%d.%d Mode:%s",
        PRINT_IPADDR(pgie->pGroupTableEntry->Group),
        pgie->FilterType==INCLUSION ? "inc" : "exc"
    );
    
    {
        DWORD Tmp;
        Trace1(SOURCES,
            "Num sources in query list:%d", pgie->V3SourcesQueryCount);
        pHead = &pgie->V3SourcesQueryList;
        Tmp = ListLength(&pgie->V3SourcesQueryList);
        pHead = &pgie->V3SourcesQueryList;
        for (ple=pHead->Flink; ple!=pHead;  ple=ple->Flink){
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, V3SourcesQueryList);
            Trace1(SOURCES, "%d.%d.%d.%d source in query list", 
                PRINT_IPADDR(pSourceEntry->IpAddr));
        }
    }
    
    
    pHead = &pgie->V3ExclusionList;
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSources);
        Trace5(SOURCES, "Src: %d.%d.%d.%d  %s  %d|%d SrcQueryLeft:%d",
            PRINT_IPADDR(pSourceEntry->IpAddr),
            pSourceEntry->bInclusionList? "INC":"EXC",
            (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000,
            (IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer)
                ?QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)/1000 : 
                0),
            pSourceEntry->V3SourcesQueryLeft
        );
    }


    pHead = &pgie->V3InclusionListSorted;
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSourcesInclListSorted);
        Trace5(SOURCES, "Src: %d.%d.%d.%d  %s  %d|%d SrcQueryLeft:%d",
            PRINT_IPADDR(pSourceEntry->IpAddr),
            pSourceEntry->bInclusionList? "INC":"EXC",
            IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer)
                ?QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)/1000 : 0,
            (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000,
            pSourceEntry->V3SourcesQueryLeft
        );
    }
    
    Trace0(SOURCES, "\n");
}


VOID
DebugPrintSourcesList1(
    PGI_ENTRY pgie
    )
{
    PLIST_ENTRY pHead, ple;
    PGI_SOURCE_ENTRY  pSourceEntry;
    LONGLONG llCurTime = GetCurrentIgmpTime();
    DWORD Count=0;


    {
        DWORD Tmp;
        Trace1(SOURCES,
            "Num sources in query list:%d", pgie->V3SourcesQueryCount);
        pHead = &pgie->V3SourcesQueryList;
        Tmp = ListLength(&pgie->V3SourcesQueryList);
        pHead = &pgie->V3SourcesQueryList;
        if (Tmp!=pgie->V3SourcesQueryCount) {
            for (ple=pHead->Flink; ple!=pHead;  ple=ple->Flink){
                pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, V3SourcesQueryList);
                Trace1(SOURCES, "%d.%d.%d.%d source in query list", 
                    PRINT_IPADDR(pSourceEntry->IpAddr));
            }
            DbgBreakPoint();
        }
    }
    
    Trace2(SOURCES,
        "\nPrinting SourcesList for Group: %d.%d.%d.%d Mode:%s",
        PRINT_IPADDR(pgie->pGroupTableEntry->Group),
        pgie->FilterType==INCLUSION ? "inc" : "exc"
    );
    
    pHead = &pgie->V3ExclusionList;
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
       pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSources);
       if (pSourceEntry->IpAddr <0x01010101 || pSourceEntry->IpAddr>0x3F010101) {
            Trace5(SOURCES, "Src: %d.%d.%d.%d  %s  %d|%d SrcQueryLeft:%d",
                PRINT_IPADDR(pSourceEntry->IpAddr),
                pSourceEntry->bInclusionList? "INC":"EXC",
                (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000,
                (IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer)
                    ?QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)/1000 : 
                    0),
                pSourceEntry->V3SourcesQueryLeft
            );
            DbgBreakPoint();
        }
    }


    if (ListLength(&pgie->V3InclusionListSorted)!=ListLength(&pgie->V3InclusionList[0]) 
        ||(ListLength(&pgie->V3InclusionListSorted)!=pgie->NumSources))
    {
        Trace0(SOURCES, "Sorted");
        pHead = &pgie->V3InclusionListSorted;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSourcesInclListSorted);
            Trace5(SOURCES, "Src: %d.%d.%d.%d  %s  %d|%d SrcQueryLeft:%d",
                PRINT_IPADDR(pSourceEntry->IpAddr),
                pSourceEntry->bInclusionList? "INC":"EXC",
                IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer)
                    ?QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)/1000 : 0,
                (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000,
                pSourceEntry->V3SourcesQueryLeft
            );
                    
        }

        Trace0(SOURCES, "NotSorted");
        pHead = &pgie->V3InclusionList[0];
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSources);
            Trace5(SOURCES, "Src: %d.%d.%d.%d  %s  %d|%d SrcQueryLeft:%d",
                PRINT_IPADDR(pSourceEntry->IpAddr),
                pSourceEntry->bInclusionList? "INC":"EXC",
                IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer)
                    ?QueryRemainingTime(&pSourceEntry->SourceExpTimer, llCurTime)/1000 : 0,
                (DWORD)(llCurTime - pSourceEntry->SourceInListTime)/1000,
                pSourceEntry->V3SourcesQueryLeft
            );
        }

        DbgBreakPoint();
    }
    
    Trace0(SOURCES, "\n");
}


//------------------------------------------------------------------------------
//            _SendV3GroupQuery
//------------------------------------------------------------------------------

VOID
SendV3GroupQuery(
    PGI_ENTRY pgie
    )
{
    PLIST_ENTRY pHead, ple;
    PGI_SOURCE_ENTRY    pSourceEntry;

    if (pgie->LastMemQueryCount==0 || pgie->Version!=3)
        return;

        
    Trace0(ENTER1, "Entering _SendV3GroupQuery()");

    // send group query
    SEND_GROUP_QUERY_V3(pgie->pIfTableEntry, pgie, pgie->pGroupTableEntry->Group);


    // set group query count
    if (--pgie->LastMemQueryCount) {

        ACQUIRE_TIMER_LOCK("_SendV3GroupQuery");

        // set group query timer
        #if DEBUG_TIMER_TIMERID
        SET_TIMER_ID(&pgie->LastMemQueryTimer, 410,
            pgie->pIfTableEntry->IfIndex, pgie->pGroupTableEntry->Group, 0);
        #endif

        InsertTimer(&pgie->LastMemQueryTimer, 
            pgie->pIfTableEntry->Config.LastMemQueryInterval
                /pgie->pIfTableEntry->Config.LastMemQueryCount,
            TRUE, DBG_Y);
        RELEASE_TIMER_LOCK("_SendV3GroupQuery");

    }
    
    
    // reduce pending source queries for those with S bit set
    pHead = &pgie->V3SourcesQueryList;
    for (ple=pHead->Flink;  ple!=pHead;  ) {
    
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, V3SourcesQueryList);
        ple = ple->Flink;

        if (QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
            >pgie->pIfTableEntry->Config.LastMemQueryInterval)
        {
            if (--pSourceEntry->V3SourcesQueryLeft == 0) {
                RemoveEntryList(&pSourceEntry->V3SourcesQueryList);
                pSourceEntry->bInV3SourcesQueryList = FALSE;
                pSourceEntry->V3SourcesQueryLeft--;
            }
        }
    }

    Trace0(LEAVE1, "Leaving _SendV3GroupQuery()");

    return;
}

VOID
ChangeSourceFilterMode(
    PGI_ENTRY pgie,
    PGI_SOURCE_ENTRY pSourceEntry
    )
{
    DWORD Mode = (pSourceEntry->bInclusionList) ? INCLUSION : EXCLUSION;

    Trace0(ENTER1, "Entering _ChangeSourceFilterMode()");
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    if (Mode==EXCLUSION) {

        // remove from exclusion list
        RemoveEntryList(&pSourceEntry->LinkSources);
        pSourceEntry->bInclusionList = TRUE;

        // insert in both inclusion lists
        INSERT_IN_SORTED_LIST(
            &pgie->V3InclusionList[pSourceEntry->IpAddr%SOURCES_BUCKET_SZ],
            pSourceEntry, IpAddr, GI_SOURCE_ENTRY, LinkSources
            ); 

        INSERT_IN_SORTED_LIST(
            &pgie->V3InclusionListSorted,
            pSourceEntry, IpAddr, GI_SOURCE_ENTRY, LinkSourcesInclListSorted
            );
    
        pgie->NumSources ++;

        // add to mgm. this will also remove any -ve state.
        MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pgie->pIfTableEntry,
                pgie->NHAddr, pSourceEntry->IpAddr, 0xffffffff,
                pgie->pGroupTableEntry->Group, 0xffffffff,
                MGM_JOIN_STATE_FLAG);
    }
    
    // remove source from inclusion state
    else {

        RemoveEntryList(&pSourceEntry->LinkSources);
        RemoveEntryList(&pSourceEntry->LinkSourcesInclListSorted);
        
        pSourceEntry->bInclusionList = FALSE;
        if (pSourceEntry->bInV3SourcesQueryList) {
            RemoveEntryList(&pSourceEntry->V3SourcesQueryList);
            pSourceEntry->bInV3SourcesQueryList = FALSE;
            pgie->V3SourcesQueryCount--;
            pSourceEntry->V3SourcesQueryLeft = 0;
        }
        pgie->NumSources--;

        INSERT_IN_SORTED_LIST(
            &pgie->V3ExclusionList,
            pSourceEntry, IpAddr, GI_SOURCE_ENTRY, LinkSources
            );


        ACQUIRE_TIMER_LOCK("_ChangeSourceFilterMode");

        // remove sourceexptimer
        if (IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer))
            RemoveTimer(&pSourceEntry->SourceExpTimer, DBG_N);

        RELEASE_TIMER_LOCK("_ChangeSourceFilterMode");
            
        
        // removing from inclusion list. so delete join state
        MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pgie->pIfTableEntry,
            pgie->NHAddr, pSourceEntry->IpAddr, 0xffffffff,
            pgie->pGroupTableEntry->Group, 0xffffffff,
            MGM_JOIN_STATE_FLAG);
        
        // dont have to delete any +ve mfe as the mgm call would have done that
    }
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    Trace0(LEAVE1, "Leaving _ChangeSourceFilterMode()");
    
    return;
}

//------------------------------------------------------------------------------

VOID
DeleteSourceEntry(
    PGI_SOURCE_ENTRY    pSourceEntry,
    BOOL bMgm
    )
{
    Trace0(ENTER1, "Entering _DeleteSourceEntry()");
    
    RemoveEntryList(&pSourceEntry->LinkSources);
    RemoveEntryList(&pSourceEntry->LinkSourcesInclListSorted);
    
    if (pSourceEntry->bInV3SourcesQueryList) {
        RemoveEntryList(&pSourceEntry->V3SourcesQueryList);
        pSourceEntry->pGIEntry->V3SourcesQueryCount--;
    }

    ACQUIRE_TIMER_LOCK("_DeleteSourceEntry");

    if (IS_TIMER_ACTIVE(pSourceEntry->SourceExpTimer))
        RemoveTimer(&pSourceEntry->SourceExpTimer, DBG_Y);

    RELEASE_TIMER_LOCK("_DeleteSourceEntry");


    //inclusion list
    if (pSourceEntry->bInclusionList) {
        pSourceEntry->pGIEntry->NumSources --;

        if (bMgm) {
            MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(
                pSourceEntry->pGIEntry->pIfTableEntry,
                pSourceEntry->pGIEntry->NHAddr,
                pSourceEntry->IpAddr, 0xffffffff,
                pSourceEntry->pGIEntry->pGroupTableEntry->Group, 0xffffffff,
                MGM_JOIN_STATE_FLAG);
        }
    }
    // exclusion list
    else {

        // join IF in MFE
        if (bMgm) {
            MGM_ADD_GROUP_MEMBERSHIP_ENTRY(
                pSourceEntry->pGIEntry->pIfTableEntry,
                pSourceEntry->pGIEntry->NHAddr,
                pSourceEntry->IpAddr, 0xffffffff,
                pSourceEntry->pGIEntry->pGroupTableEntry->Group, 0xffffffff,
                MGM_FORWARD_STATE_FLAG);
        }
    }
    
    IGMP_FREE(pSourceEntry);
    Trace0(LEAVE1, "Leaving _DeleteSourceEntry()");
}

//------------------------------------------------------------------------------

PGI_SOURCE_ENTRY
GetSourceEntry(
    PGI_ENTRY pgie,
    IPADDR Source,
    DWORD Mode,
    BOOL *bCreate,
    DWORD Gmi,
    BOOL bMgm
    )
{
    PLIST_ENTRY ple, pHead;
    PGI_SOURCE_ENTRY pSourceEntry;
    DWORD               Error = NO_ERROR;
    PIGMP_TIMER_ENTRY   SourceExpTimer;

    Trace0(ENTER1, "Entering _GetSourceEntry()");
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    pHead = (Mode==INCLUSION) ?
            &pgie->V3InclusionList[Source%SOURCES_BUCKET_SZ]
            : &pgie->V3ExclusionList;
    
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSources);
        if (pSourceEntry->IpAddr > Source)
            break;
        if (pSourceEntry->IpAddr==Source) {
            if (bCreate) *bCreate = FALSE;
            return pSourceEntry;
        }
    }
    
    if (!bCreate || *bCreate==FALSE)
        return NULL;


    *bCreate = FALSE;
    
    //
    // create new entry
    //
    
    pSourceEntry = (PGI_SOURCE_ENTRY) 
                    IGMP_ALLOC(sizeof(GI_SOURCE_ENTRY), 0x800200,
                            pgie->pIfTableEntry->IfIndex);
                    
    PROCESS_ALLOC_FAILURE2(pSourceEntry,
        "error %d allocating %d bytes for sourceEntry", Error,
        sizeof(GI_SOURCE_ENTRY),
        return NULL;
        );

    InsertTailList(ple, &pSourceEntry->LinkSources);
    
    InitializeListHead(&pSourceEntry->V3SourcesQueryList);
    pSourceEntry->pGIEntry = pgie;
    pSourceEntry->bInclusionList = Mode==INCLUSION;
    pSourceEntry->IpAddr = Source;
    pSourceEntry->V3SourcesQueryLeft = 0;
    pSourceEntry->bInV3SourcesQueryList = FALSE;
    pSourceEntry->SourceInListTime = GetCurrentIgmpTime();
    pSourceEntry->bStaticSource = (Gmi==STATIC);
    
    // initialize SourceExpTimer
    SourceExpTimer = &pSourceEntry->SourceExpTimer;
    SourceExpTimer->Function = T_SourceExpTimer;
    SourceExpTimer->Context = &SourceExpTimer->Context;
    SourceExpTimer->Timeout = (Gmi==GMI)
            ? pgie->pIfTableEntry->Config.GroupMembershipTimeout
            : pgie->pIfTableEntry->Config.LastMemQueryInterval;
            
    SourceExpTimer->Status = TIMER_STATUS_CREATED;
    #if DEBUG_TIMER_TIMERID
    SET_TIMER_ID(SourceExpTimer, 610, pgie->pIfTableEntry->IfIndex,
        pgie->pGroupTableEntry->Group, Source);
    #endif;

    if (Mode==INCLUSION) {
        INSERT_IN_SORTED_LIST(
            &pgie->V3InclusionListSorted,
            pSourceEntry, IpAddr, GI_SOURCE_ENTRY, LinkSourcesInclListSorted
            );

        pgie->NumSources++;

    }
    else {
        InitializeListHead(&pSourceEntry->LinkSourcesInclListSorted);
    }

    // insert in inclusion list and set timer. add to mgm
    
    if (Mode==INCLUSION) {
        
        // timer set only in inclusion list

        InsertTimer(SourceExpTimer,
            SourceExpTimer->Timeout,
            TRUE, DBG_N
            );

        if (!pSourceEntry->bStaticSource) {

            // insert in sources query list
            if (Gmi==LMI) {
                InsertSourceInQueryList(pSourceEntry);
            }
        }
        
        if (bMgm) {
            // add (s,g) to MGM
            MGM_ADD_GROUP_MEMBERSHIP_ENTRY(
                pgie->pIfTableEntry, pgie->NHAddr,
                Source, 0xffffffff, pgie->pGroupTableEntry->Group, 0xffffffff,
                MGM_JOIN_STATE_FLAG
                );
        }
    }
    else {
        if (bMgm) {
            // no timer set, but delete any +ve mfe

            MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(
                pgie->pIfTableEntry, pgie->NHAddr,
                Source, 0xffffffff, pgie->pGroupTableEntry->Group, 0xffffffff,
                MGM_FORWARD_STATE_FLAG
                );
        }
    }

    
    *bCreate = TRUE;
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    Trace0(LEAVE1, "Leaving _GetSourceEntry()");
    
    return pSourceEntry;
}

//------------------------------------------------------------------------------

VOID
GIDeleteAllV3Sources(
    PGI_ENTRY pgie,
    BOOL bMgm
    )
{
    PGI_SOURCE_ENTRY    pSourceEntry;
    DWORD               i;
    PLIST_ENTRY         ple, pHead;

    Trace0(ENTER1, "Entering _GIDeleteAllV3Sources()");

    pHead = &pgie->V3InclusionListSorted;
    for (ple=pHead->Flink;  ple!=pHead;  ) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,LinkSourcesInclListSorted);
        ple = ple->Flink;
        DeleteSourceEntry(pSourceEntry, bMgm);
    }

    InitializeListHead(&pgie->V3InclusionListSorted);
    
    pHead = &pgie->V3ExclusionList;
    for (ple=pHead->Flink;  ple!=pHead;  ) {
        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSources);
        ple = ple->Flink;
        DeleteSourceEntry(pSourceEntry, bMgm);
    }


    //
    // dont call delete (*,G) if in exclusion mode as I want to remain in that 
    // state
    //
    pgie->NumSources = 0;
    pgie->FilterType = INCLUSION;
    pgie->Info.LastReporter = 0;
    pgie->Info.GroupExpiryTime = ~0;

    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    Trace0(LEAVE1, "Leaving _GIDeleteAllV3Sources()");
    return;
}

//++------------------------------------------------------------------------------
// todo:remove 3rd field
DWORD
UpdateSourceExpTimer(
    PGI_SOURCE_ENTRY    pSourceEntry,
    DWORD               Gmi,
    BOOL                bRemoveLastMem
    )
{
    Trace0(ENTER1, "Entering _UpdateSourceExpTimer()");


    ACQUIRE_TIMER_LOCK("_UpdateSourceExpTimer");

    #if DEBUG_TIMER_TIMERID
    pSourceEntry->SourceExpTimer.Id = 620;
    pSourceEntry->SourceExpTimer.Id2 = TimerId++;
    #endif
    
    UpdateLocalTimer(&pSourceEntry->SourceExpTimer,
        Gmi==GMI? GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).GroupMembershipTimeout
                 :GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryInterval,
        DBG_Y
        );
    
    //remove from expiry list, and exp timer
    if (bRemoveLastMem && pSourceEntry->bInV3SourcesQueryList) {
        pSourceEntry->V3SourcesQueryLeft = 0;
        pSourceEntry->bInV3SourcesQueryList = FALSE;
        RemoveEntryList(&pSourceEntry->V3SourcesQueryList);
        pSourceEntry->pGIEntry->V3SourcesQueryCount--;
    }

    RELEASE_TIMER_LOCK("_UpdateSourceExpTimer");

    Trace0(LEAVE1, "Entering _UpdateSourceExpTimer()");
    return NO_ERROR;
}

//------------------------------------------------------------------------------        

DWORD
ChangeGroupFilterMode(
    PGI_ENTRY pgie,
    DWORD Mode
    )
{
    Trace0(ENTER1, "Entering _ChangeGroupFilterMode()");

    // shift from exclusion to inclusion mode

    if (Mode==INCLUSION) {

        if (pgie->NumSources == 0) {
            DeleteGIEntry(pgie, TRUE, TRUE);
        }
        else {
            PLIST_ENTRY pHead, ple;
            
            pgie->FilterType = INCLUSION;

            //
            // remove all sources in exclusion list
            //
            pHead = &pgie->V3ExclusionList;
            
            for (ple=pHead->Flink;  ple!=pHead;  ) {

                PGI_SOURCE_ENTRY pSourceEntry;
                pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, 
                                    LinkSources);
                ple = ple->Flink;

                // dont have to call mgm as it will remain in -ve mfe
                IGMP_FREE(pSourceEntry);
            }
            InitializeListHead(&pgie->V3ExclusionList);
            
            // remove (*,g) join. the entries in inclusion list are 
            // already joined
            MGM_DELETE_GROUP_MEMBERSHIP_ENTRY(pgie->pIfTableEntry, pgie->NHAddr,
                0, 0, pgie->pGroupTableEntry->Group,
                0xffffffff, MGM_JOIN_STATE_FLAG);
        }
    }

    Trace0(LEAVE1, "Leaving _ChangeGroupFilterMode()");
    return NO_ERROR;
}



//------------------------------------------------------------------------------
// if inclusion: create source in IN_List if not found in IN_LIST
// update timer if source already found
// if source present in exclusion list, move it to inclusion list
//------------------------------------------------------------------------------

VOID
InclusionSourcesUnion(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord
    )
{
    PGI_SOURCE_ENTRY    pSourceEntry;
    DWORD   j;
    BOOL    bCreate;

    Trace0(ENTER1, "Entering _InclusionSourcesUnion()");
    
    if (pGroupRecord->NumSources==0)
        return;
        
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    for (j=0;  j<pGroupRecord->NumSources;  j++) {

        //kslksl
        if (pGroupRecord->Sources[j]==0||pGroupRecord->Sources[j]==0xffffffff)
            continue;

        //
        // if in exclusion list, move it to inclusion list and continue
        // if static group, leave it in exclusion list
        //
        pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                            EXCLUSION, NULL, 0, 0);
        if (pSourceEntry!=NULL && !pSourceEntry->bStaticSource) {
            ChangeSourceFilterMode(pgie, pSourceEntry);
            continue;
        }
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);

                            
        bCreate = TRUE;
        pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                            INCLUSION, &bCreate, GMI, MGM_YES);

        if (!pSourceEntry)
            return;

        // if already in IN_LIST, update source exp timer
        if (!bCreate) {
            UpdateSourceExpTimer(pSourceEntry, GMI, FALSE);
        }
    }
    Trace0(LEAVE1, "Leaving _InclusionSourcesUnion()");

    return;
}


//------------------------------------------------------------------------------
// delete sources present in group record
VOID
SourcesSubtraction(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord,
    BOOL Mode
    )
{
    PGI_SOURCE_ENTRY    pSourceEntry;
    DWORD   i,j;
    PLIST_ENTRY pHead, ple;
    BOOL    bFound;

    Trace0(ENTER1, "Entering _SourcesSubtraction()");
    
    // note: num sources in groupRecord can be 0

    
    // delete sources in inclusion list which are not there in the packet
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);

    
    if (Mode==INCLUSION) {

        pHead = &pgie->V3InclusionListSorted;
        for (ple=pHead->Flink;  ple!=pHead;  ) {
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,
                                LinkSourcesInclListSorted);
            ple = ple->Flink;
            
            for (j=0, bFound=FALSE;  j<pGroupRecord->NumSources;  j++) {
                if (pSourceEntry->IpAddr == pGroupRecord->Sources[j]) {
                    bFound = TRUE;
                    break;
                }
            }

            if (!bFound)
                DeleteSourceEntry(pSourceEntry, MGM_YES);
        }
    }
    // delete sources in exclusion list which are not there in the packet
    else {
        pHead = &pgie->V3ExclusionList;
        for (ple=pHead->Flink;  ple!=pHead;  ) {
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, LinkSources);
            ple = ple->Flink;

            for (j=0, bFound=FALSE;  j<pGroupRecord->NumSources;  j++) {
                if (pSourceEntry->IpAddr == pGroupRecord->Sources[j]) {
                    bFound = TRUE;
                    break;
                }
            }
            if (!bFound){
                // dont have to process in mgm. IF not in mfe anyway
                DeleteSourceEntry(pSourceEntry, MGM_YES);
            }
        }
    }
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    Trace0(LEAVE1, "Leaving _SourcesSubtraction()");
    return;
}

//------------------------------------------------------------------------------
// intersection: rule(2)
// exclusion:    (7)(9)
// inclusion:(4)
// rule_5:(5)(10)
//------------------------------------------------------------------------------
DWORD
BuildAndSendSourcesQuery(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord,
    DWORD Type
    )
{
    PGI_SOURCE_ENTRY    pSourceEntry;
    DWORD   i,j;
    PLIST_ENTRY         ple, pHead;
    BOOL                bCreate;
    

    Trace0(ENTER1, "Entering _BuildAndSendSourcesQuery()");
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);

    
    // intersection of inclusion and group record
    if (Type==INTERSECTION) {
        if (pGroupRecord->NumSources==0)
            return NO_ERROR;

        for (j=0;  j<pGroupRecord->NumSources;  j++) {
            pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                                INCLUSION, NULL, 0, 0);
            if (pSourceEntry && !pSourceEntry->bStaticSource) {
                InsertSourceInQueryList(pSourceEntry);
            }
        }
    }
    //add a-y to x, and query(a-y)
    else if (Type==EXCLUSION) {
    
        for (j=0;  j<pGroupRecord->NumSources;  j++) {

            //kslksl
            if (pGroupRecord->Sources[j]==0||pGroupRecord->Sources[j]==0xffffffff)
                continue;
                
            // if found in EX list, then do nothing, else add to IN list and
            // send group query
            
            pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                                EXCLUSION, NULL, 0, 0);
            if (pSourceEntry) {
                continue;
            }
            
            bCreate = TRUE;
            pSourceEntry = GetSourceEntry(pgie, pGroupRecord->Sources[j], 
                                INCLUSION, &bCreate, LMI, MGM_YES);
            if (!pSourceEntry)
                return ERROR_NOT_ENOUGH_MEMORY;

            // if created, then already in query list as time==lmi
            if (!bCreate && !pSourceEntry->bStaticSource)
                InsertSourceInQueryList(pSourceEntry);
        }
    }
    // send queries for all sources in inclusion list
    else if (Type==INCLUSION) {

        pHead = &pgie->V3InclusionListSorted;
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,
                                LinkSourcesInclListSorted);
            
            InsertSourceInQueryList(pSourceEntry);
        }
    }
    // send for sources in IN list but not in packet
    else if (Type==RULE5) {

        pHead = &pgie->V3InclusionListSorted;
        for (ple=pHead->Flink;  ple!=pHead; ) {
            BOOL bFound;
            
            pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY,
                                LinkSourcesInclListSorted);
            ple = ple->Flink;
            
            for (j=0, bFound=FALSE;  j<pGroupRecord->NumSources;  j++) {
                if (pSourceEntry->IpAddr == pGroupRecord->Sources[j]) {
                    bFound = TRUE;
                    break;
                }
            }

            if (!bFound)
                InsertSourceInQueryList(pSourceEntry);
        }
    }
    
    if (pgie->bV3SourcesQueryNow) {

        SEND_SOURCES_QUERY(pgie);
    }
    //deldel
    //DebugPrintSourcesList(pgie);
    //DebugPrintSourcesList1(pgie);


    Trace0(LEAVE1, "Leaving _BuildAndSendSourcesQuery()");
    return NO_ERROR;
}

//------------------------------------------------------------------------------
VOID
InsertSourceInQueryList(
    PGI_SOURCE_ENTRY    pSourceEntry
    )
{
    Trace0(ENTER1, "Entering _InsertSourceInQueryList()");

    //already in sources query list. return
    if (pSourceEntry->bInV3SourcesQueryList) {
        if (QueryRemainingTime(&pSourceEntry->SourceExpTimer, 0)
                >GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryInterval)
        {
            // update exp timer to lmqi
            UpdateSourceExpTimer(pSourceEntry,
                LMI,
                FALSE //dont remove from last mem list
                );
                
            pSourceEntry->pGIEntry->bV3SourcesQueryNow = TRUE;
        }
        return;
    }
    
    pSourceEntry->V3SourcesQueryLeft = 
            GET_IF_CONFIG_FOR_SOURCE(pSourceEntry).LastMemQueryCount;


    //
    // insert in sources query list
    //
    
    InsertHeadList(&pSourceEntry->pGIEntry->V3SourcesQueryList, 
        &pSourceEntry->V3SourcesQueryList);        
    pSourceEntry->bInV3SourcesQueryList = TRUE;
    pSourceEntry->pGIEntry->V3SourcesQueryCount++;


    // update exp timer to lmqi
    UpdateSourceExpTimer(pSourceEntry,
        LMI,
        FALSE //dont remove from last mem list
        );

    pSourceEntry->pGIEntry->bV3SourcesQueryNow = TRUE;

    Trace0(LEAVE1, "Leaving _InsertSourceInQueryList()");
    return;
}




//------------------------------------------------------------------------------
//            _MoveFromExcludeToIncludeList
// EX(x,y), GrpRecord(a) -> EX(x+a,y-a), (a)=gmi
// used by rules (6) and (13)
//------------------------------------------------------------------------------

VOID
MoveFromExcludeToIncludeList(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord
    )
{
    PGI_SOURCE_ENTRY    pSourceEntry;
    DWORD               i;
    IPADDR              Source;

    Trace0(ENTER1, "Entering _MoveFromExcludeToIncludeList");

    // note:all a should be in x
    
    for (i=0;  i<pGroupRecord->NumSources;  i++) {

        //kslksl
        if (pGroupRecord->Sources[i]==0||pGroupRecord->Sources[i]==0xffffffff)
            continue;
                

        //
        // if in exclusion list remove it and place in inclusion list
        //
        
        Source = pGroupRecord->Sources[i];
        pSourceEntry = GetSourceEntry(pgie, Source, EXCLUSION, NULL,0,0);

        if (pSourceEntry) {

            if (!pSourceEntry->bStaticSource) {
                ChangeSourceFilterMode(pgie, pSourceEntry);

                UpdateSourceExpTimer(pSourceEntry,
                    GMI,
                    FALSE //dont have to process lastmem list
                    );
            }
        }
        else {
            // not found in exclusion list, so create new entry in IN
            BOOL bCreate = TRUE;
            
            pSourceEntry = GetSourceEntry(pgie, Source, INCLUSION, &bCreate, GMI, MGM_YES);

            // entry already exists. update it
            if (pSourceEntry && !bCreate) {
            
                UpdateSourceExpTimer(pSourceEntry,
                    GMI,
                    FALSE //wont be there in lastmem list
                    );                
            }
        }
    }

    Trace0(LEAVE1, "Leaving _MoveFromExcludeToIncludeList");
    return;
}


//------------------------------------------------------------------------------
DWORD
T_V3SourcesQueryTimer (
    PVOID    pvContext
    )
{
    DWORD                           Error=NO_ERROR;
    PIGMP_TIMER_ENTRY               pTimer; //ptr to timer entry
    PGI_ENTRY                       pgie;   //group interface entry
    PWORK_CONTEXT                   pWorkContext;
    PRAS_TABLE_ENTRY                prte;
    PIF_TABLE_ENTRY                 pite;

    Trace0(ENTER1, "Entering _T_V3SourcesQueryTimer()");

    //
    // get pointer to LastMemQueryTimer, GI entry, pite, prte
    //
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);
    pgie = CONTAINING_RECORD( pTimer, GI_ENTRY, V3SourcesQueryTimer);
    pite = pgie->pIfTableEntry;
    prte = pgie->pRasTableEntry;


    Trace2(TIMER, "_T_V3SourcesQueryTimer() called for If(%0x), Group(%d.%d.%d.%d)",
            pite->IfIndex, PRINT_IPADDR(pgie->pGroupTableEntry->Group));


    //
    // if GI or pite or prte has   flag already set, then exit
    //
    if ( (pgie->Status&DELETED_FLAG) || (pite->Status&DELETED_FLAG) ) 
        return NO_ERROR;
    
    if ( (prte!=NULL) && (prte->Status&DELETED_FLAG) ) 
        return NO_ERROR;

    if (pgie->Version!=3)
        return NO_ERROR;

        
    //
    // queue work item for sending the Sources query even if the router
    // is not a Querier
    //
    
    CREATE_WORK_CONTEXT(pWorkContext, Error);
    if (Error!=NO_ERROR) {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pWorkContext->IfIndex = pite->IfIndex;
    pWorkContext->Group = pgie->pGroupTableEntry->Group;
    pWorkContext->NHAddr = pgie->NHAddr;  //valid only for ras: should i use it?
    pWorkContext->WorkType = MSG_SOURCES_QUERY;
    
    Trace0(WORKER, "Queueing WF_TimerProcessing() to send SourcesQuery:");
    if (QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext)!=NO_ERROR)
        IGMP_FREE(pWorkContext);

    Trace0(LEAVE1, "Leaving _T_V3SourcesQueryTimer()");
    return NO_ERROR;
}

//------------------------------------------------------------------------------
//          _T_LastVer2ReportTimer
//
// For this GI entry, the last ver-1 report has timed out. Change to ver-3 if
// the interface is set to ver-3.
// Locks: Assumes timer lock.
//------------------------------------------------------------------------------

DWORD
T_LastVer2ReportTimer (
    PVOID    pvContext
    ) 
{
    PIGMP_TIMER_ENTRY               pTimer; //ptr to timer entry
    PGI_ENTRY                       pgie;   //group interface entry
    PIF_TABLE_ENTRY                 pite;
    LONGLONG                        llCurTime = GetCurrentIgmpTime();
    

    Trace0(ENTER1, "Entering _T_LastVer2ReportTimer()");


    //
    // get pointer to LastMemQueryTimer, GI entry, pite
    //
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);
    pgie = CONTAINING_RECORD( pTimer, GI_ENTRY, LastVer2ReportTimer);
    pite = pgie->pIfTableEntry;

    Trace2(TIMER, "T_LastVer2ReportTimer() called for If(%0x), Group(%d.%d.%d.%d)",
            pite->IfIndex, PRINT_IPADDR(pgie->pGroupTableEntry->Group));
            
    
    // set the state to ver-3, if ver1 time not active
    
    if (IS_PROTOCOL_TYPE_IGMPV3(pite) && 
        !IS_TIMER_ACTIVE(pgie->LastVer1ReportTimer)) 
    {
        PWORK_CONTEXT   pWorkContext;
        DWORD           Error=NO_ERROR;
        
        //
        // queue work item for shifting to v3 for that group
        //

        CREATE_WORK_CONTEXT(pWorkContext, Error);
        if (Error!=NO_ERROR) {
            return ERROR_CAN_NOT_COMPLETE;
        }
        pWorkContext->IfIndex = pite->IfIndex;
        pWorkContext->Group = pgie->pGroupTableEntry->Group;
        pWorkContext->NHAddr = pgie->NHAddr;  //valid only for ras: should i us
        pWorkContext->WorkType = SHIFT_TO_V3;

        Trace0(WORKER, "Queueing WF_TimerProcessing() to shift to v3");
        if (QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext)!=NO_ERROR)
            IGMP_FREE(pWorkContext);
    }

    Trace0(LEAVE1, "Leaving _T_LastVer2ReportTimer()");

    return NO_ERROR;
}

//------------------------------------------------------------------------------
DWORD
T_SourceExpTimer (
    PVOID    pvContext
    ) 
{
    PIGMP_TIMER_ENTRY           pTimer; //ptr to timer entry
    PGI_ENTRY                   pgie;   //group interface entry
    PGI_SOURCE_ENTRY            pSourceEntry;
    PWORK_CONTEXT               pWorkContext;
    DWORD                       Error=NO_ERROR;

    Trace0(ENTER1, "Entering _T_SourceExpTimer()");
    
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);
    pSourceEntry = 
        CONTAINING_RECORD(pTimer, GI_SOURCE_ENTRY, SourceExpTimer);

    pgie = pSourceEntry->pGIEntry;

    //IN entry. delete it
    if (pSourceEntry->bInclusionList) {
        CREATE_WORK_CONTEXT(pWorkContext, Error);
        if (Error!=NO_ERROR)
            return Error;

        pWorkContext->IfIndex = pgie->pIfTableEntry->IfIndex;
        pWorkContext->NHAddr = pgie->NHAddr;    
        pWorkContext->Group = pgie->pGroupTableEntry->Group;
        pWorkContext->Source = pSourceEntry->IpAddr;
        pWorkContext->WorkType = (pgie->FilterType==INCLUSION)
                                ? DELETE_SOURCE
                                : MOVE_SOURCE_TO_EXCL;

        Trace0(WORKER, "_T_SourceExpTimer queued _WF_TimerProcessing:");

        if (QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext)!=NO_ERROR)
            IGMP_FREE(pWorkContext);
    }

    Trace0(LEAVE1, "Leaving _T_SourceExpTimer()");
    return NO_ERROR;
}

#if DEBUG_FLAGS_MEM_ALLOC

LIST_ENTRY g_MemoryList;
CRITICAL_SECTION g_MemCS;

PVOID
IgmpDebugAlloc(
    DWORD sz,
    DWORD Flags,
    DWORD Id,
    DWORD IfIndex
    )
{
    static DWORD Initialize = TRUE;
    PMEM_HDR Ptr;

    if (Initialize) {
        InitializeListHead(&g_MemoryList);
        try {
            InitializeCriticalSection(&g_MemCS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            return NULL;
        }
        Initialize = FALSE;
    }

    // allign for 64 bit
    sz = (sz + 63) & 0xFFFFFFc0;
    
    Ptr = (PMEM_HDR)HeapAlloc(g_Heap,Flags,(sz)+sizeof(MEM_HDR)+sizeof(DWORD));
    if (Ptr==NULL)
        return NULL;
//    Trace1(ERR, "----- alloc:%0x", (ULONG_PTR)Ptr);
    EnterCriticalSection(&g_MemCS);
    Ptr->Signature = 0xabcdefaa;
    Ptr->IfIndex = IfIndex;
    Ptr->Tail =  (PDWORD)((PCHAR)Ptr + sz + sizeof(MEM_HDR));
    *Ptr->Tail = 0xabcdefbb;
    Ptr->Id = Id;
    InsertHeadList(&g_MemoryList, &Ptr->Link);
    LeaveCriticalSection(&g_MemCS);
Trace1(KSL, "Alloc heap:%0x", PtrToUlong(((PCHAR)Ptr+sizeof(MEM_HDR))));//deldel
    
    return (PVOID)((PCHAR)Ptr+sizeof(MEM_HDR));
}

VOID
IgmpDebugFree(
    PVOID mem
    )
{
    PMEM_HDR Ptr = (PMEM_HDR)((PCHAR)mem - sizeof(MEM_HDR));

    if (Ptr->Signature != 0xabcdefaa) {
        DbgBreakPoint();
        Trace2(KSL, "\n=======================\n"
                "Freeing Invalid memory:%0x:Id:%0x\n", (ULONG_PTR)Ptr, Ptr->Id);
    }
    if (*Ptr->Tail != 0xabcdefbb) {
        DbgBreakPoint();
        Trace2(KSL, "\n=======================\n"
                "Freeing Invalid memory:Tail corrupted:%0x:Id:%0x\n", (ULONG_PTR)Ptr, Ptr->Id);
    }

    EnterCriticalSection(&g_MemCS);
    Ptr->Signature = 0xaafedcba;
    *Ptr->Tail = 0xbbfedcba;
    RemoveEntryList(&Ptr->Link);
    LeaveCriticalSection(&g_MemCS);

Trace1(KSL, "Freed heap:%0x", PtrToUlong(mem));//deldel

    HeapFree(g_Heap, 0, Ptr);
}

VOID
DebugScanMemoryInterface(
    DWORD IfIndex
    )
{
    PMEM_HDR Ptr;
    PLIST_ENTRY ple;
    DWORD Count=0;

    Trace0(ENTER1, "InDebugScanMemoryInterface");
    EnterCriticalSection(&g_MemCS);
    for (ple=g_MemoryList.Flink;  ple!=&g_MemoryList;  ple=ple->Flink) {

        Ptr = CONTAINING_RECORD(ple, MEM_HDR, Link);
        if (Ptr->IfIndex==IfIndex) {
            if (Count++==0)
                Trace1(ERR, "\n\nMEMORY checking for interface: %0x", IfIndex);
            Trace2(ERR, "MEMORY: %0x  Id:%0x", (ULONG_PTR)Ptr, Ptr->Id);
        }
    }
    if (Count!=0) {
        Trace0(ERR, "\n\n");
        DbgBreakPoint();
    }
    LeaveCriticalSection(&g_MemCS);
}

VOID
DebugScanMemory(
    )
{
    PMEM_HDR Ptr;
    PLIST_ENTRY ple;

    Trace0(ENTER1, "InDebugScanMemory");
    EnterCriticalSection(&g_MemCS);
    for (ple=g_MemoryList.Flink;  ple!=&g_MemoryList;  ple=ple->Flink) {

        Ptr = CONTAINING_RECORD(ple, MEM_HDR, Link);
        Trace2(ERR, "MEMORY: %0x  Id:%0x", (ULONG_PTR)Ptr, Ptr->Id);
    }
    if (!(IsListEmpty(&g_MemoryList))) {
        DbgBreakPoint();
    }
    
    DeleteCriticalSection(&g_MemCS);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\table2.c ===
/*                dwRetval = MgmAddGroupMembershipEntry(g_MgmIgmprtrHandle, 0, 0, 
                                                pge->Group, 0, IfIndex, NHAddr);

dwRetval = MgmDeleteGroupMembershipEntry(g_MgmIgmprtrHandle, 0, 0, pge->Group,
                                0, pite->IfIndex, NHAddr);                                                
*/

//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File: table2.c
//
// Abstract:
//      This module implements some of the routines associated with getting
//      entries. and some debug routines
//
//      GetRasClientByAddr, GetIfByIndex, InsertIfByAddr, MatchIpAddrBinding,
//      GetGroupFromGroupTable, GetGIFromGIList, GetGIFromGIList.
//
//      DebugPrintGIList, DebugPrintGroups, DebugPrintLocks
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#include "pchigmp.h"
#pragma hdrstop



//------------------------------------------------------------------------------
//            _GetRasClientByAddr
// Returns pointer to Ras clients RasTableEntry
//------------------------------------------------------------------------------

PRAS_TABLE_ENTRY
GetRasClientByAddr (
    DWORD        NHAddr,
    PRAS_TABLE   prt
    )
{
    PRAS_TABLE_ENTRY    pite = NULL;
    PLIST_ENTRY         phead, ple;
    PRAS_TABLE_ENTRY    prte=NULL;

    phead = &prt->HashTableByAddr[RAS_HASH_VALUE(NHAddr)];

    for (ple=phead->Flink;  ple!=phead;  ple=ple->Flink) {

        prte = CONTAINING_RECORD(ple, RAS_TABLE_ENTRY, HTLinkByAddr);

        if (prte->NHAddr == NHAddr) {
            break;
        }
    }

    return  (ple == phead) ?  NULL:   prte;
    
}

//------------------------------------------------------------------------------
//          _GetIfByIndex
//
// returns the interface with the given index.
// assumes the interface bucket is either read or write locked
//------------------------------------------------------------------------------

PIF_TABLE_ENTRY
GetIfByIndex(
    DWORD    IfIndex
    )
{
    PIF_TABLE_ENTRY pite = NULL;
    PLIST_ENTRY     phead, ple;

    
    phead = &g_pIfTable->HashTableByIndex[IF_HASH_VALUE(IfIndex)];

    for (ple=phead->Flink;  ple!=phead;  ple=ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, HTLinkByIndex);

        if (pite->IfIndex == IfIndex) {
            break;
        }
    }

    return  (ple == phead) ?  NULL:   pite;
}

//------------------------------------------------------------------------------
//          _InsertIfByAddr
//
// inserts the activated interface into the list of interfaces sorted by address.
// assumes the table is locked for writing
//------------------------------------------------------------------------------

DWORD
InsertIfByAddr(
    PIF_TABLE_ENTRY piteInsert
    ) 
{

    PIF_TABLE_ENTRY     pite;
    INT                 cmp, cmp1;
    DWORD               InsertAddr;
    PLIST_ENTRY         phead, ple;


    phead = &g_pIfTable->ListByAddr;

    
    InsertAddr = piteInsert->IpAddr;

    //
    // search for the insertion point
    //

    for (ple=phead->Flink;  ple!=phead;  ple=ple->Flink) {

        pite = CONTAINING_RECORD(ple, IF_TABLE_ENTRY, LinkByAddr);

        if ( (cmp1 = INET_CMP(InsertAddr, pite->IpAddr, cmp)) < 0) 
            break;

        //
        // return error if there are duplicate addresses. 
        // no error for unnumbered interfaces, ie for addr==0
        //
        else if ( (cmp1==0) && (InsertAddr!=0) )
            return ERROR_ALREADY_EXISTS;
    }

    InsertTailList(ple, &piteInsert->LinkByAddr);

    return NO_ERROR;
}

//------------------------------------------------------------------------------
//            MatchIpAddrBinding                                                    //
// finds if the interface is bound to any address equal to IpAddr               //
//------------------------------------------------------------------------------
BOOL
MatchIpAddrBinding(
    PIF_TABLE_ENTRY        pite,
    DWORD                IpAddr
    )
{
    PIGMP_IP_ADDRESS        paddr;
    DWORD                    i;
    PIGMP_IF_BINDING        pib;

    pib = pite->pBinding;
    paddr = IGMP_BINDING_FIRST_ADDR(pib);

    
    for (i=0;  i<pib->AddrCount;  i++,paddr++) {
        if (IpAddr==paddr->IpAddr)
            break;
    }

    return (i<pib->AddrCount)? TRUE: FALSE;
}




//------------------------------------------------------------------------------
//          _InsertInGroupsList
//
// Inserts a newly created group in the New or Main group list.
// Calls: May call _MergeGroupLists() to merge the New and Main lists
//------------------------------------------------------------------------------
VOID
InsertInGroupsList (
    PGROUP_TABLE_ENTRY      pgeNew
    )
{
    PGROUP_TABLE_ENTRY      pgeTmp;
    PLIST_ENTRY             pHead, ple;
    DWORD                   GroupLittleEndian = pgeNew->GroupLittleEndian;
    BOOL                    bInsertInNew;
    
    //
    // insert the group in main list if less than 20 entries, else insert in
    // the New list
    //
    bInsertInNew = (g_Info.CurrentGroupMemberships > 20);

    pHead = bInsertInNew ?
            &g_pGroupTable->ListByGroupNew :
            &g_pGroupTable->ListByGroup.Link;


    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
    
        pgeTmp = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);
        if (GroupLittleEndian<pgeTmp->GroupLittleEndian)
            break;
    }
    
    InsertTailList(ple, &pgeNew->LinkByGroup);

    if (bInsertInNew) {

        // increment count of 
        g_pGroupTable->NumGroupsInNewList++;


        //
        // merge lists if required
        //
        if (MERGE_GROUP_LISTS_REQUIRED()) {

            MergeGroupLists();

        }
    }

    return;
}



//------------------------------------------------------------------------------
//          _InsertInIfGroupsList
// Inserts a newly created group in the New or Main group list.
// Calls: May call MergeIfGroupLists() to merge the New and Main lists
//------------------------------------------------------------------------------
VOID
InsertInIfGroupsList (
    PIF_TABLE_ENTRY pite,
    PGI_ENTRY       pgiNew
    )
{
    PGI_ENTRY           pgiTmp;
    PLIST_ENTRY         pHead, ple;
    DWORD               GroupLittleEndian = pgiNew->pGroupTableEntry->GroupLittleEndian;
    BOOL                bInsertInNew;

    
    //
    // insert the group in main list if less than 20 entries, else insert in
    // the New list
    //
    bInsertInNew = (pite->Info.CurrentGroupMemberships > 20);

    pHead = bInsertInNew ?
            &pite->ListOfSameIfGroupsNew :
            &pite->ListOfSameIfGroups;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
    
        pgiTmp = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
        if (GroupLittleEndian<pgiTmp->pGroupTableEntry->GroupLittleEndian)
            break;
    }
    
    InsertTailList(ple, &pgiNew->LinkBySameIfGroups);

    if (bInsertInNew) {

        // increment count of 
        pite->NumGIEntriesInNewList++;


        //
        // merge lists if required
        //
        if (MERGE_IF_GROUPS_LISTS_REQUIRED(pite)) {

            MergeIfGroupsLists(pite);

        }
    }

    return;
    
}//end _InsertInIfGroupsList



//------------------------------------------------------------------------------
//          InsertInProxyList
//------------------------------------------------------------------------------
VOID
InsertInProxyList (
    PIF_TABLE_ENTRY     pite,
    PPROXY_GROUP_ENTRY  pNewProxyEntry
    )
{
    PPROXY_GROUP_ENTRY  pTmpProxyEntry;
    PLIST_ENTRY         pHead, ple;
    DWORD               GroupLittleEndian = pNewProxyEntry->GroupLittleEndian;
    BOOL                bInsertInNew;

    
    //
    // dont insert in new list if less than 20 entries, else insert in
    // the New list
    //
    bInsertInNew = (pite->NumGIEntriesInNewList > 20);

    pHead = bInsertInNew ?
            &pite->ListOfSameIfGroupsNew :
            &pite->ListOfSameIfGroups;


    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
    
        pTmpProxyEntry = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, 
                                            LinkBySameIfGroups);
        if (GroupLittleEndian<pTmpProxyEntry->GroupLittleEndian)
            break;
    }
    
    InsertTailList(ple, &pNewProxyEntry->LinkBySameIfGroups);

    if (bInsertInNew) {

        // increment count of 
        pite->NumGIEntriesInNewList++;


        //
        // merge lists if required
        //
        if (MERGE_PROXY_LISTS_REQUIRED(pite)) {

            MergeProxyLists(pite);

        }
    }

    return;
}//end _InsertInProxyList





//------------------------------------------------------------------------------
//            _GetGroupFromGroupTable
// Returns the group entry. If group entry does not exist and bCreateFlag is
// set, then it will take a group-list lock and create a new entry.
// Locks:
//      Assumes lock on group bucket. 
//      takes group-list lock if new group is being created. 
//      If read only, assumes lock on group list
//------------------------------------------------------------------------------

PGROUP_TABLE_ENTRY
GetGroupFromGroupTable (
    DWORD       Group,
    BOOL        *bCreate, //set to true if new one created
    LONGLONG    llCurrentTime
    )
{
    PGROUP_TABLE_ENTRY      pge;    //group table entry
    PLIST_ENTRY             pHead, ple;
    DWORD                   Error = NO_ERROR;
    DWORD                   bCreateLocal;
    DWORD                   GroupLittleEndian = NETWORK_TO_LITTLE_ENDIAN(Group);
    
        
    
    bCreateLocal = (bCreate==NULL) ? FALSE : *bCreate;


    if (llCurrentTime==0)
        llCurrentTime = GetCurrentIgmpTime();

        
    BEGIN_BREAKOUT_BLOCK1 {
    
        // get pointer to the head of the group bucket
        
        pHead = &g_pGroupTable->HashTableByGroup[GROUP_HASH_VALUE(Group)].Link;


        // search for the group
        
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, HTLinkByGroup);
            if (GroupLittleEndian>=pge->GroupLittleEndian) {
                break;
            }
        }

        
        //
        // group entry not found
        //
        if ( (ple==pHead) || (pge->GroupLittleEndian!=GroupLittleEndian) ) {

            //
            // create and initialize new entry
            //
            if (bCreateLocal) {
            
                bCreateLocal = TRUE;
    
                pge = IGMP_ALLOC(sizeof(GROUP_TABLE_ENTRY), 0x800010,0xaaaa);

                PROCESS_ALLOC_FAILURE2(pge, 
                        "Error %d allocation %d bytes for Group table entry",
                        Error, sizeof(GROUP_TABLE_ENTRY),
                        GOTO_END_BLOCK1);


                InsertTailList(ple, &pge->HTLinkByGroup);
                InitializeListHead(&pge->LinkByGroup);

                
                pge->Group = Group;
                pge->GroupLittleEndian = GroupLittleEndian;
                pge->NumVifs = 0;
                pge->Status = CREATED_FLAG;
                pge->GroupUpTime = llCurrentTime;


                //
                // insert it into the list of all groups after taking the group
                // list lock
                //
                {
                    PGROUP_TABLE_ENTRY      pgeTmp;
                    PLIST_ENTRY             pHeadTmp, pleTmp;

                    // take group list lock
                    
                    ACQUIRE_GROUP_LIST_LOCK("_GetGroupFromGroupTable");


                    // initialize GI list head
                    
                    InitializeListHead(&pge->ListOfGIs);


                    // insert in group list
                    
                    InsertInGroupsList(pge);
                    

                    // release group lock
                    
                    RELEASE_GROUP_LIST_LOCK("_GetGroupFromGroupTable");
                }


                // update statistics
                
                InterlockedIncrement(&g_Info.CurrentGroupMemberships);
                InterlockedIncrement(&g_Info.GroupMembershipsAdded);
                
            }
            // not found group, and do not create new group. So return NULL.
            else {
                pge = NULL;
                GOTO_END_BLOCK1;
            }
        }
        //
        // group entry found
        //
        else {
            bCreateLocal = FALSE;
        }

    } END_BREAKOUT_BLOCK1;

    if (bCreate!=NULL)
        *bCreate = bCreateLocal;

#if DBG
    DebugPrintGroupsList(1);
#endif


    return pge;
    
} //end _GetGroupFromGroupTable



  
//------------------------------------------------------------------------------
//          _GetGIFromGIList
//
// returns the GI entry if it exists. If the bCreate flag is set, then it creates
// a new GI entry if it does not exist.
//
// Locks: Assumes shared interface lock. If ras interface, also assumes shared
//      Ras interface lock.
//      Assumes lock on group bucket.
//      Takes IF_GROUP_LIST_LOCK if new entry is to be created.
// On return: bCreate is set to TRUE if a new entry was created
//------------------------------------------------------------------------------

PGI_ENTRY
GetGIFromGIList (
    PGROUP_TABLE_ENTRY          pge, 
    PIF_TABLE_ENTRY             pite, 
    DWORD                       dwInputSrcAddr, //used for NHAddr
    BOOL                        bStaticGroup,
    BOOL                       *bCreate,
    LONGLONG                    llCurrentTime
    )
{
    DWORD               IfIndex = pite->IfIndex;
    BOOL                bRasClient;
    PLIST_ENTRY         pHead, ple;
    PGI_ENTRY           pgie;
    PRAS_TABLE_ENTRY    prte;
    PRAS_TABLE          prt;
    BOOL                bRasNewGroup = TRUE; //true if 1st ras group
    DWORD               NHAddr;
    DWORD               Error = NO_ERROR, dwRetval, i;
    BOOL                bFound = FALSE, bCreateLocal;

    

    Trace2(ENTER1, "Entering _GetGIFromGIList() IfIndex(%0x) Group(%d.%d.%d.%d)", 
            IfIndex, PRINT_IPADDR(pge->Group));

    //DebugPrintIfGroups(pite,0);//deldel

    bCreateLocal = (bCreate==NULL) ? FALSE : *bCreate;

    if (llCurrentTime==0)
        llCurrentTime = GetCurrentIgmpTime();
        
    BEGIN_BREAKOUT_BLOCK1 {
        //
        // find out if ras-server. 
        //
        bRasClient = IS_RAS_SERVER_IF(pite->IfType);
        if (bRasClient) {
            prt = pite->pRasTable;

            // get ras client
            
            prte = GetRasClientByAddr(dwInputSrcAddr, prt);
        }
            
        NHAddr = bRasClient ? dwInputSrcAddr : 0;


        //
        // search for GI entry
        //
        pHead = &pge->ListOfGIs;

        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
            pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);
            
            if (pgie->IfIndex>IfIndex) 
                break;

            //
            // GI with same interface index
            //
            else if (pgie->IfIndex==IfIndex) {

                // the GI entry might belong to some interface being deleted
                
                if ( (pite!=pgie->pIfTableEntry)
                        ||(IS_IF_DELETED(pgie->pIfTableEntry)) )
                    continue;

                    
                //multiple entries for ras clients
                
                if (bRasClient) {

                    //
                    // I set this even if the ras client is marked to be deleted
                    //
                    bRasNewGroup = FALSE;  

                    
                    // the GI entry might belong to some other ras interface
                    // being deleted

                    if ( (prte!=pgie->pRasTableEntry)
                            || (pgie->pRasTableEntry->Status&DELETED_FLAG) ) 
                        continue;


                    if (pgie->NHAddr>dwInputSrcAddr) {
                        break;
                    }
                    
                    // found GI entry for ras interface
                    else if (pgie->NHAddr==dwInputSrcAddr) {
                        bFound = TRUE;
                        break;
                    }
                }
                
                // found GI entry for non ras interface
                else {
                    bFound = TRUE;
                    break;
                }
            }
        }// end for loop:search through list of GIs

        //
        // GIentry not found
        //
        if ( !bFound) {            

            // dont create new GI entry. Hence, return NULL
            
            if (!bCreateLocal) {
                pgie = NULL;
                GOTO_END_BLOCK1;
            }


            //
            // create and initialize new GI-entry
            //
            pgie = IGMP_ALLOC_AND_ZERO(sizeof(GI_ENTRY), 0x800011, pite->IfIndex);

            PROCESS_ALLOC_FAILURE2(pgie,
                "Error %d allocating %d bytes for group-interface entry",
                Error, sizeof(GI_ENTRY),
                GOTO_END_BLOCK1);

            pgie->IfIndex = IfIndex;
            pgie->Status = CREATED_FLAG;
            pgie->bRasClient = bRasClient;


            // insert in GI list
            InsertTailList(ple, &pgie->LinkByGI);


            //
            // set back pointers to the interface entry, and group entry
            //
            pgie->pIfTableEntry = pite;
            pgie->pGroupTableEntry = pge;


            //
            // Take lock on Interface-Group List before inserting into it
            // for ras client, insert it into ras client list also
            //
            
            ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_GetGIFromGIList");

            // insert in ras client list
            if (bRasClient) {

                PLIST_ENTRY pleTmp, pHeadRasClient;
                PGI_ENTRY   pgieRasClient;

                pHeadRasClient = &prte->ListOfSameClientGroups;
                for (pleTmp=pHeadRasClient->Flink;  pleTmp!=pHeadRasClient;
                            pleTmp=pleTmp->Flink)
                {
                    pgieRasClient = CONTAINING_RECORD(pleTmp, GI_ENTRY, 
                                                    LinkBySameClientGroups);
                    if (pge->Group < pgieRasClient->pGroupTableEntry->Group)
                        break;
                }
                
                InsertTailList(pleTmp, &pgie->LinkBySameClientGroups);
            }
            

            InsertInIfGroupsList(pite, pgie);
            

            RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_GetGIFromGIList");



            //
            // if ras 
            //
            pgie->NHAddr = (bRasClient)? dwInputSrcAddr : 0;
            pgie->pRasTableEntry = (bRasClient)? prte : NULL;


            //
            // initialize GroupMembershipTimer
            //
            pgie->GroupMembershipTimer.Function = T_MembershipTimer;
            pgie->GroupMembershipTimer.Timeout = pite->Config.GroupMembershipTimeout;
            pgie->GroupMembershipTimer.Context = &pgie->GroupMembershipTimer.Context;
            pgie->GroupMembershipTimer.Status = TIMER_STATUS_CREATED;
            

            //
            // initialize LastMemQueryTimer timer
            //
            pgie->LastMemQueryCount = 0; //last member countdown inactive
            pgie->LastMemQueryTimer.Function = T_LastMemQueryTimer;
            pgie->LastMemQueryTimer.Context = &pgie->LastMemQueryTimer.Context;
            pgie->LastMemQueryTimer.Status = TIMER_STATUS_CREATED;
            

            //
            // initialize the LastVer1ReportTimer
            // the timeout value is set to GroupMembership timeout

            pgie->LastVer1ReportTimer.Function = T_LastVer1ReportTimer;            
            pgie->LastVer1ReportTimer.Timeout 
                                    = pite->Config.GroupMembershipTimeout;
            pgie->LastVer1ReportTimer.Context 
                                        = &pgie->LastVer1ReportTimer.Context;
            pgie->LastVer1ReportTimer.Status = TIMER_STATUS_CREATED;


            pgie->LastVer2ReportTimer.Function = T_LastVer2ReportTimer;            
            pgie->LastVer2ReportTimer.Timeout 
                                    = pite->Config.GroupMembershipTimeout;
            pgie->LastVer2ReportTimer.Context 
                                        = &pgie->LastVer2ReportTimer.Context;
            pgie->LastVer2ReportTimer.Status = TIMER_STATUS_CREATED;



            // set version based on current interface version
            pgie->Version = (IS_IF_VER1(pite)) ? 1 : ((IS_IF_VER2(pite))?2:3);


            //
            // initialize GI_INFO
            //
            ZeroMemory(&pgie->Info, sizeof(GI_INFO));
            pgie->Info.GroupUpTime = llCurrentTime;
            if (!bStaticGroup) {
                pgie->Info.GroupExpiryTime = llCurrentTime 
                        + CONFIG_TO_SYSTEM_TIME(pite->Config.GroupMembershipTimeout);
            }
            pgie->Info.V1HostPresentTimeLeft = 0;
            pgie->Info.V2HostPresentTimeLeft = 0;
            pgie->Info.LastReporter = dwInputSrcAddr;


            //
            // v3 fields
            //
            pgie->V3InclusionList = (PLIST_ENTRY)
                        IGMP_ALLOC(sizeof(LIST_ENTRY)*SOURCES_BUCKET_SZ, 
                        0x800020, pite->IfIndex);
            PROCESS_ALLOC_FAILURE2(pgie->V3InclusionList,
                "Error %d allocating sources table:%d bytes", Error,
                sizeof(LIST_ENTRY)*SOURCES_BUCKET_SZ,
                GOTO_END_BLOCK1);
            for (i=0;  i<SOURCES_BUCKET_SZ;  i++)
                InitializeListHead(&pgie->V3InclusionList[i]);
        
            InitializeListHead(&pgie->V3InclusionListSorted);
            pgie->NumSources = 0;
            pgie->FilterType = INCLUSION;
            InitializeListHead(&pgie->V3ExclusionList);
            InitializeListHead(&pgie->V3SourcesQueryList);
            pgie->V3SourcesQueryCount = 0;

            // V3SourcesQueryTimer
            pgie->V3SourcesQueryTimer.Function = T_V3SourcesQueryTimer;
            pgie->V3SourcesQueryTimer.Context = 
                                &pgie->V3SourcesQueryTimer.Context;
            pgie->V3SourcesQueryTimer.Status = TIMER_STATUS_CREATED;



            // set static group flag

            pgie->bStaticGroup = bStaticGroup;



            //
            // increment the count of number of If's for that group
            // I increment once for each virtual interface
            //
            InterlockedIncrement(&pge->NumVifs);

            if (!bRasClient||(bRasClient&bRasNewGroup) ) {
                InterlockedIncrement(&pite->Info.CurrentGroupMemberships);
                InterlockedIncrement(&pite->Info.GroupMembershipsAdded);
            }
            //
            // update stats for ras client
            //
            if ((bRasClient) && (g_Config.RasClientStats) ) {
                InterlockedIncrement(&prte->Info.CurrentGroupMemberships);
                InterlockedIncrement(&prte->Info.GroupMembershipsAdded);
            }
            
            //
            // Join the group to MGM
            //

            // call mgm to join the group only if the interface is
            // activated, enabled by mgm, either mprotocol exists or else
            // igmprtr is a querier on this interface

            if (CAN_ADD_GROUPS_TO_MGM(pite)
                && (pgie->bStaticGroup||!IS_IF_VER3(pite)) )
            {
                MGM_ADD_GROUP_MEMBERSHIP_ENTRY(pite, NHAddr, 0, 0,
                        pge->Group, 0xffffffff, MGM_JOIN_STATE_FLAG);
            }

            //
            // v3 no MGM calls, as I create an inclusion list with null members.
            //
            
        } // if GI entry not found

        // GI entry found
        else {
            if (bStaticGroup)
                pgie->bStaticGroup = TRUE;
                
            bCreateLocal = FALSE;
        }
        
    } END_BREAKOUT_BLOCK1;


    if (bCreate!=NULL)
        *bCreate = bCreateLocal;

        
    Trace0(LEAVE1, "Leaving _GetGIFromGIList()");

    //Trace1(ENTER1, "GetGiFromGiList returned:%0x", (DWORD)pgie);//deldel
    return pgie;

} //end _GetGIFromGIList



//------------------------------------------------------------------------------
//          _DebugPrintGIList
//------------------------------------------------------------------------------
VOID
DebugPrintGIList (
    PGROUP_TABLE_ENTRY  pge,
    LONGLONG            llCurTime
    )
{
    PGI_ENTRY            pgie;
    PLIST_ENTRY         pHead, ple;

    

    pHead = &pge->ListOfGIs;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkByGI);

        if (pgie->Status&IF_DELETED_FLAG)
            continue;

            
        //
        // GI info
        //
        Trace4(GROUP, 
            "---If(%d: %d.%d.%d.%d)   NHAddr(%d.%d.%d.%d)   GroupMembershipTimer(%d sec)",
            pgie->IfIndex, PRINT_IPADDR(pgie->pIfTableEntry->IpAddr), 
            PRINT_IPADDR(pgie->NHAddr),
            (pgie->GroupMembershipTimer.Timeout-llCurTime)/1000
            );


        //
        // if leave being processed
        //
        if (IS_TIMER_ACTIVE(pgie->LastMemQueryTimer)) {
            Trace2(GROUP, 
                "    *Leave received:  LastMemQueryCount:%d   LastMemQueryTimeLeft(%d ms)",
                pgie->LastMemQueryCount,  
                (DWORD) (pgie->LastMemQueryTimer.Timeout-llCurTime)
                );
        }
    }

    Trace0(GROUP, "");

    return;
}


//------------------------------------------------------------------------------
//          DebugPrintGroups
//------------------------------------------------------------------------------
VOID
APIENTRY
DebugPrintGroups (
    DWORD   Flags
    )
{
    
    DWORD                           Group, i, j, k;
    DWORD                           IfIndex;
    PLIST_ENTRY                     pHead, ple;
    DWORD                           Count;
    PGROUP_TABLE_ENTRY              pge;    //group table entry
    LONGLONG                        llCurTime = GetCurrentIgmpTime();

    
    
    j = 1;

    Trace0(GROUP, "");
    for (i=0;  i<GROUP_HASH_TABLE_SZ;  i++) {
    
        ACQUIRE_GROUP_LOCK(i, "_DebugPrintGroups");
        
        pHead = &g_pGroupTable->HashTableByGroup[i].Link;

        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        
            pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, HTLinkByGroup);

            //
            // print group info
            //
            Trace3(GROUP, "(%d) Group:%d.%d.%d.%d  UpTime(%lu sec)", 
                    j++, PRINT_IPADDR(pge->Group),
                    (llCurTime-pge->GroupUpTime)/1000);


            // print GI list
            DebugPrintGIList(pge, llCurTime);

        }

        RELEASE_GROUP_LOCK(i, "_DebugPrintGroups");

    }

    return;
}



VOID
DebugPrintIfGroups(
    PIF_TABLE_ENTRY pite,
    DWORD flag
    )
{   
    PGI_ENTRY           pgiTmp;
    PLIST_ENTRY         pHead, ple;
    BOOL                bInsertInNew;
    DWORD               count=0;
    PPROXY_GROUP_ENTRY  proxyge;
    
    ACQUIRE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DebugPrintIfGroups");

    Trace0(ERR, "---------------DebugPrintIfGroups---------------------");
    Trace1(ERR, "Ipaddr: %d.%d.%d.%d", PRINT_IPADDR(pite->IpAddr) );
    Trace1(ERR, "CurrentGroupMemberships: %d",pite->Info.CurrentGroupMemberships);

    pHead = &pite->ListOfSameIfGroups;

    for (ple=pHead->Flink;  ple!=pHead && count<300;  ple=ple->Flink) {

        if (!(flag&IGMP_IF_PROXY)) {
            pgiTmp = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
            Trace5(SOURCES, "%d: main list: %x:%x:%x: %d.%d.%d.%d", ++count, (ULONG_PTR)ple,
                        (ULONG_PTR)ple->Flink, (ULONG_PTR)ple->Blink,
                        PRINT_IPADDR(pgiTmp->pGroupTableEntry->Group));
        }
        else {
            proxyge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, LinkBySameIfGroups);
            Trace5(SOURCES, "%d: proxyMailList: %x:%x:%x: %d.%d.%d.%d", ++count,
                        (ULONG_PTR)ple,
                        (ULONG_PTR)ple->Flink, (ULONG_PTR)ple->Blink,
                        PRINT_IPADDR(proxyge->Group));
        }
        
    }


    pHead = &pite->ListOfSameIfGroupsNew;
    Trace1(ERR, "NumGIEntriesInNewList:%d", pite->NumGIEntriesInNewList);
    for (ple=pHead->Flink;  ple!=pHead && count<300;  ple=ple->Flink) {

        if (!(flag&IGMP_IF_PROXY)) {
            pgiTmp = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameIfGroups);
            Trace5(ERR, "%d: NewList: %x:%x:%x: %d.%d.%d.%d", ++count, (ULONG_PTR)ple,
                        (ULONG_PTR)ple->Flink, (ULONG_PTR)ple->Blink,
                        PRINT_IPADDR(pgiTmp->pGroupTableEntry->Group));
        }
        else {
            proxyge = CONTAINING_RECORD(ple, PROXY_GROUP_ENTRY, LinkBySameIfGroups);
            Trace5(ERR, "%d: ProxyNewList: %x:%x:%x: %d.%d.%d.%d", ++count, (ULONG_PTR)ple,
                        (ULONG_PTR)ple->Flink, (ULONG_PTR)ple->Blink,
                        PRINT_IPADDR(proxyge->Group));
        }
        
    }

    Trace0(ERR, "-------------------------------------------------------------");
    RELEASE_IF_GROUP_LIST_LOCK(pite->IfIndex, "_DebugPrintIfGroups");

    //ASSERT(count<300);//deldel
    
}




DWORD
APIENTRY
DebugPrintLocks(
    )
{
    DWORD   Group;

    Trace0(KSL, "QUEUEING WORKER THREAD TO DEBUGPRINTLOCKS");
    
    QueueIgmpWorker(DebugPrintLocks, NULL);
    
    Trace0(KSL, "QUEUED WORKER THREAD TO DEBUGPRINTLOCKS");

    return NO_ERROR;
}


VOID
DebugPrintLists(
    PLIST_ENTRY pHead
    )
{   DWORD   count=0;

    PLIST_ENTRY ple;
    for (ple=pHead->Flink;  (ple!=pHead)&&(count<16);  ple=ple->Flink,count++) {
        Trace3(ERR, "ple:%lu   ple->Flink:%lu:  ple->Blink:%lu",
            ple, ple->Flink, ple->Blink);

    }
    
}



//------------------------------------------------------------------------------
//          _ForcePrintGroupsList
//------------------------------------------------------------------------------
VOID
DebugForcePrintGroupsList (
    DWORD   Flags
    )
{
    BOOL        bMain = FALSE;
    CHAR        str[2][5] = {"new", "main"};
    LIST_ENTRY  *ple, *pHead;
    PGROUP_TABLE_ENTRY pge;

    if (g_Info.CurrentGroupMemberships > 40 && !(Flags&ENSURE_EMPTY) )
        return;
      

    Trace0(ENTER1, "Entering _ForcePrintGroupsList()");
    

    pHead = &g_pGroupTable->ListByGroupNew;

    if (Flags&ENSURE_EMPTY) {
        if (IsListEmpty(pHead))
            return;// list empty as expected

        DbgPrint("Cleanup: Group Lists should be empty\n");
        DbgBreakPoint();
    }

    
    do {
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);

            
            Trace3(KSL, "%s-group list: <%d.%d.%d.%d> pge:%0x", str[bMain], 
                                    PRINT_IPADDR(pge->Group), (ULONG_PTR)pge);


            if (!IS_MCAST_ADDR(pge->Group)) {

                #if DBG
                DbgBreakPoint();
                #endif
                Trace0(ERR, "===============================================================");
                Trace2(ERR, "bad group(%d.%d.%d.%d)(pge:%0x) while checking main-group",
                            PRINT_IPADDR(pge->Group), (ULONG_PTR)pge);
                Trace0(ERR, "===============================================================");
                return;
            }
        }

        if (!bMain) {
            pHead = &g_pGroupTable->ListByGroup.Link;
            bMain = TRUE;
        }
        else
            break;
    } while (1);
    
    Trace0(LEAVE1, "Leaving _ForcePrintGroupsList()");

}

//------------------------------------------------------------------------------
//          DebugPrintGroupsList
//------------------------------------------------------------------------------
VOID
DebugPrintGroupsList (
    DWORD   Flags
    )
{
    BOOL        bMain = FALSE;
    CHAR        str[2][5] = {"new", "main"};
    LIST_ENTRY  *ple, *pHead;
    PGROUP_TABLE_ENTRY pge;
    static DWORD StaticCount;    
    BOOL        bPrint = FALSE;


    if (StaticCount++==30) {
        bPrint = TRUE;
        StaticCount = 0;
    }

    
    if (g_Info.CurrentGroupMemberships > 40)
        return;
      
    pHead = &g_pGroupTable->ListByGroupNew;

    do {
        for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

            pge = CONTAINING_RECORD(ple, GROUP_TABLE_ENTRY, LinkByGroup);

            //if ((Flags)&&(bPrint))
            if (0)
                Trace3(KSL, "%s-group list: <%d.%d.%d.%d> pge:%0x", str[bMain], 
                                    PRINT_IPADDR(pge->Group), (ULONG_PTR)pge);


            if (!IS_MCAST_ADDR(pge->Group)) {
                
                if (!bPrint) {
                    DebugForcePrintGroupsList(1);
                    return;
                }
                
                #if DBG
                DbgBreakPoint();
                #endif
                Trace0(ERR, "===============================================================");
                Trace2(ERR, "bad group(%d.%d.%d.%d)(pge:%0x) while checking main-group",
                            PRINT_IPADDR(pge->Group), (ULONG_PTR)pge);
                Trace0(ERR, "===============================================================");
                return;
            }
        }

        if (!bMain) {
            pHead = &g_pGroupTable->ListByGroup.Link;
            bMain = TRUE;
        }
        else
            break;
    } while (1);
    
    //Trace0(LEAVE1, "Leaving _PrintGroupsList()");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\table2.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: table2.c
//
// Abstract:
//      This module contains function prototypes for table2.h.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================

#ifndef _IGMP_TABLE2_H_
#define _IGMP_TABLE2_H_


//
// function prototypes
//

PRAS_TABLE_ENTRY
GetRasClientByAddr (
    DWORD         NHAddr,
    PRAS_TABLE    prt
    );

PIF_TABLE_ENTRY    
GetIfByIndex(
    DWORD    IpAddr
    );
    

DWORD
InsertIfByAddr(
    PIF_TABLE_ENTRY piteInsert
    );

BOOL
MatchIpAddrBinding(
    PIF_TABLE_ENTRY        pite,
    DWORD                  IpAddr
    );


PGROUP_TABLE_ENTRY
GetGroupFromGroupTable (
    DWORD        Group,
    BOOL         *bCreate, //set to true if new one created
    LONGLONG     llCurrentTime
    );

    
PGI_ENTRY
GetGIFromGIList (
    PGROUP_TABLE_ENTRY          pge, 
    PIF_TABLE_ENTRY             pite, 
    DWORD                       dwInputSrcAddr,
    BOOL                        bStaticGroup,
    BOOL                        *bCreate,
    LONGLONG                    llCurrentTime
    );

VOID
InsertInProxyList (
    PIF_TABLE_ENTRY     pite,
    PPROXY_GROUP_ENTRY  pNewProxyEntry
    );
    
VOID
APIENTRY
DebugPrintGroups (
    DWORD   Flags
    );

VOID
DebugPrintLists(
    PLIST_ENTRY pHead
    );

VOID
DebugPrintGroupsList (
    DWORD   Flags
    );
    
VOID
DebugPrintIfGroups(
    PIF_TABLE_ENTRY pite,
    DWORD Flags
    );
    
VOID
DebugForcePrintGroupsList (
    DWORD   Flags
    );
#define ENSURE_EMPTY 0x1000    

#endif //_IGMP_TABLE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\work.c ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
// File: work.c
//
// Abstract:
//      Implements the work items that are queued by igmp routines.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================


#include "pchigmp.h"
#pragma hdrstop


//
// should each packet be queued to another work item again
//
#define BQUEUE_WORK_ITEM_FOR_PACKET 1



//------------------------------------------------------------------------------
//        _WT_ProcessInputEvent
// called in the wait worker thread when the packet event is set.
// Queues: _WF_ProcessInputEvent()
// Runs in: WaitServerThread context
//------------------------------------------------------------------------------
VOID
WT_ProcessInputEvent(
    PVOID   pContext, // psee entry. the entry might have been deleted.
    BOOLEAN NotUsed
    )
{   
    HANDLE WaitHandle ;

    //
    // set the InputWaitEvent to NULL so that UnregisterWaitEx is not called.
    // psee will be valid here, but might not be once queued to the worker Fn.
    //
    
    PSOCKET_EVENT_ENTRY     psee = (PSOCKET_EVENT_ENTRY) pContext;

    if (!EnterIgmpApi()) 
        return;
    
    Trace0(WORKER, "_WF_ProcessInputEvent queued by WaitThread");

    
    // make a non-blocking UnregisterWaitEx call

    WaitHandle = InterlockedExchangePointer(&psee->InputWaitEvent, NULL);
    
    if (WaitHandle)
        UnregisterWaitEx( WaitHandle, NULL ) ;


    QueueIgmpWorker(WF_ProcessInputEvent, pContext);

    LeaveIgmpApi();
    return;
}




//------------------------------------------------------------------------------
//            _WF_ProcessInputEvent
// Called by: _WT_ProcessInputEvent()
// Locks:
//      Acquire socketsLockShared. Either queue processing the packet to 
//      _WF_ProcessPacket() or take shared interface lock and process the packet.
//------------------------------------------------------------------------------

VOID
WF_ProcessInputEvent (
    PVOID pContext 
    )
{
    DWORD                   Error = NO_ERROR;
    PIF_TABLE_ENTRY         pite;
    PLIST_ENTRY             ple, pHead;
    WSANETWORKEVENTS        wsane;
    PSOCKET_EVENT_ENTRY     psee = (PSOCKET_EVENT_ENTRY) pContext,
                            pseeTmp;
    PSOCKET_ENTRY           pse;

    
    if (!EnterIgmpWorker()) return;
    Trace0(ENTER1, "Entering _WF_ProcessInputEvent");


    ACQUIRE_SOCKETS_LOCK_SHARED("_WF_ProcessInputEvent");

    //
    // make sure that the psee entry still exists
    //
    pHead = &g_ListOfSocketEvents;
    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {
        pseeTmp = CONTAINING_RECORD(ple, SOCKET_EVENT_ENTRY, LinkBySocketEvents);
        if (pseeTmp==psee)
            break;
    }

    if (ple==pHead) {
        RELEASE_SOCKETS_LOCK_SHARED("_WF_ProcessInputEvent");
        Trace0(ERR, "Input Event received on deleted SocketEvent. not an error");
        LeaveIgmpWorker();
        return;
    }

    
    //
    // go through the list of active interfaces
    // processing sockets which have input packets
    //

    pHead = &psee->ListOfInterfaces;

    for (ple=pHead->Flink;  ple!=pHead;  ple=ple->Flink) {

        pse = CONTAINING_RECORD(ple, SOCKET_ENTRY, LinkByInterfaces);
        pite = CONTAINING_RECORD(pse, IF_TABLE_ENTRY, SocketEntry);

        //
        // process only activated interfaces. (Proxy wont be on this list)
        //
        if (!IS_IF_ACTIVATED(pite))
            continue;


        //
        // process input event
        //
        BEGIN_BREAKOUT_BLOCK1 {
        
            if (pse->Socket == INVALID_SOCKET)
                GOTO_END_BLOCK1;


            //
            // enumerate network events to see whether
            // any packets have arrived on this interface
            //
            Error = WSAEnumNetworkEvents(pse->Socket, NULL, &wsane);
            
            if (Error != NO_ERROR) {
                Trace3(RECEIVE, 
                        "error %d checking for input on interface %d (%d.%d.%d.%d)",
                        Error, pite->IfIndex, PRINT_IPADDR(pite->IpAddr));
                Logwarn1(ENUM_NETWORK_EVENTS_FAILED, "%I", pite->IpAddr, Error);
                GOTO_END_BLOCK1;
            }

            if (!(wsane.lNetworkEvents & FD_READ)) 
                GOTO_END_BLOCK1;


            //
            // the input flag is set, now see if there was an error
            //

            if (wsane.iErrorCode[FD_READ_BIT] != NO_ERROR) {
                Trace3(RECEIVE, 
                        "error %d in input record for interface %d (%d.%d.%d.%d)",
                        wsane.iErrorCode[FD_READ_BIT], pite->IfIndex, 
                        PRINT_IPADDR(pite->IpAddr)
                       );
                Logwarn1(INPUT_RECORD_ERROR, "%I", pite->IpAddr, Error);

                GOTO_END_BLOCK1;
            }


            //
            // Process the packet received on the interface
            //

            ProcessInputOnInterface(pite);

        } END_BREAKOUT_BLOCK1;

    } //for loop: for each interface



    //
    // register the event with the wait thread for future receives
    //

    if (g_RunningStatus!=IGMP_STATUS_STOPPING) {

        DWORD   dwRetval;

        if (! RegisterWaitForSingleObject(
                    &psee->InputWaitEvent,
                    psee->InputEvent,
                    WT_ProcessInputEvent, 
                    (VOID*)psee,
                    INFINITE,
                    (WT_EXECUTEINWAITTHREAD)|(WT_EXECUTEONLYONCE)
                    ))
        {
            dwRetval = GetLastError();
            Trace1(ERR, "error %d RtlRegisterWait", dwRetval);
            IgmpAssertOnError(FALSE);
        }
    }


    
    RELEASE_SOCKETS_LOCK_SHARED("_WF_ProcessInputEvent");


    LeaveIgmpWorker();

    Trace0(LEAVE1, "leaving _WF_ProcessInputEvent()\n");
    Trace0(LEAVE, ""); //putting a newline
    return;
    
} //end _WF_ProcessInputEvent



//------------------------------------------------------------------------------
//            _ProcessInputOnInterface
// Does some minimal checking of packet length, etc. We can either queue to 
// work item(_WF_ProcessPacket) or run it here itself.
//
// Called by: _WF_ProcessInputEvent()
// Locks: Assumes socket lock. Either queues the packet to _WF_ProcessPacket or
//      takes shared interface lock and processes it here itself.
//------------------------------------------------------------------------------

VOID
ProcessInputOnInterface(
    PIF_TABLE_ENTRY pite
    )
{
    WSABUF                  WsaBuf;
    DWORD                   dwNumBytes, dwFlags, dwAddrLen;
    SOCKADDR_IN             saSrcAddr;
    DWORD                   dwSrcAddr, DstnMcastAddr;
    DWORD                   Error = NO_ERROR;
    UCHAR                   *pPacket;
    UCHAR                   IpHdrLen;
    PIP_HEADER              pIpHdr;
    BOOL                    bRtrAlertSet = FALSE;
    PBYTE                   Buffer;
    
    
    WsaBuf.len = pite->Info.PacketSize;
    WsaBuf.buf = IGMP_ALLOC(WsaBuf.len, 0x800040, pite->IfIndex);
    PROCESS_ALLOC_FAILURE2(WsaBuf.buf,
        "error %d allocating %d bytes for input packet",
        Error, WsaBuf.len,
        return);
    Buffer = WsaBuf.buf;

    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // read the incoming packet
        //

        dwAddrLen = sizeof(SOCKADDR_IN);
        
        dwAddrLen = sizeof (saSrcAddr);
        dwFlags = 0;

        
        Error = WSARecvFrom(pite->SocketEntry.Socket, &WsaBuf, 1, &dwNumBytes, 
                            &dwFlags, (SOCKADDR FAR *)&saSrcAddr, &dwAddrLen, 
                            NULL, NULL);

    
        // check if any error in reading packet
        
        if ((Error!=0)||(dwNumBytes == 0)) {
            Error = WSAGetLastError();
            Trace2(RECEIVE, "error %d receiving packet on interface %d)",
                    Error, pite->IfIndex);
            Logerr1(RECVFROM_FAILED, "%I", pite->IpAddr, Error);
            GOTO_END_BLOCK1;
        }

        

        //
        // dont ignore the packet even if it is from a local address
        //

        //
        // set packet ptr, IpHdr ptr, dwNumBytes, SrcAddr, DstnMcastAddr
        //
        
        // set source addr of packet
        dwSrcAddr = saSrcAddr.sin_addr.s_addr;
        
        IpHdrLen = (Buffer[0]&0x0F)*4;

        pPacket = &Buffer[IpHdrLen];
        dwNumBytes -= IpHdrLen;
        pIpHdr = (PIP_HEADER)Buffer;
        DstnMcastAddr = (ULONG)pIpHdr->Dstn.s_addr;


        //
        // verify that the packet has igmp type
        //
        if (pIpHdr->Protocol!=0x2) {
            Trace5(RECEIVE,
                "Packet received with IpDstnAddr(%d.%d.%d.%d) %d.%d.%d.%d from(%s) on "
                "IF:%0x is not of Igmp type(%d)",
                PRINT_IPADDR(pIpHdr->Dstn.s_addr), PRINT_IPADDR(pIpHdr->Src.s_addr),
                PRINT_IPADDR(dwSrcAddr), pite->IfIndex, pIpHdr->Protocol
                );
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        } 

        
        //
        // check if packet has router alert option
        //
        {
            PBYTE pOption = (PBYTE)(pIpHdr+1);
            UCHAR i;
            
            for (i=0;  i<IpHdrLen-20;  i+=4) {

                if ( (pOption[0]==148) && (pOption[1]==4) ) {
                    bRtrAlertSet = TRUE;
                    break;
                }
            }
        }    

        if (BQUEUE_WORK_ITEM_FOR_PACKET) {

            PACKET_CONTEXT          UNALIGNED *pPktContext;
            
            //
            // allocate and initialize a packet-context 
            //
            CREATE_PACKET_CONTEXT(pPktContext, dwNumBytes, Error);
            if (Error!=NO_ERROR) 
                GOTO_END_BLOCK1;

            
            pPktContext->IfIndex = pite->IfIndex;
            pPktContext->DstnMcastAddr = DstnMcastAddr;
            pPktContext->InputSrc = dwSrcAddr;
            pPktContext->Length = dwNumBytes;
            pPktContext->Flags = bRtrAlertSet;
            CopyMemory(pPktContext->Packet, pPacket, dwNumBytes);


            //
            // enqueue the work-item to process the packet
            //
            
            Error = QueueIgmpWorker(WF_ProcessPacket, (PVOID)pPktContext);

            Trace2(WORKER, "Queuing IgmpWorker function: %s in %s",
                    "WF_ProcessPacket:", "ProcessInputOnInterface");

            if (Error != NO_ERROR) {
                Trace1(ERR, "error %d queueing work-item for packet", Error);
                Logerr0(QUEUE_WORKER_FAILED, Error);
                IGMP_FREE(pPktContext);
                GOTO_END_BLOCK1;
            }
        }

        // 
        // process the packet here itself
        //
        else {

            ACQUIRE_IF_LOCK_SHARED(pite->IfIndex, "_ProcessInputOnInterface");

            ProcessPacket(pite, dwSrcAddr, DstnMcastAddr, dwNumBytes, pPacket, 
                            bRtrAlertSet);
                            
            RELEASE_IF_LOCK_SHARED(pite->IfIndex, "_ProcessInputOnInterface");

        }


     } END_BREAKOUT_BLOCK1;

    IGMP_FREE(WsaBuf.buf);
    
    return;
    
} //end _ProcessInputOnInterface



//------------------------------------------------------------------------------
//            _WF_ProcessPacket
// Queued by: _ProcessInputOnInterface()
// Locks: takes shared interface lock
// Calls: _ProcessPacket()
//------------------------------------------------------------------------------

VOID 
WF_ProcessPacket (
    PVOID        pvContext
    )
{
    PPACKET_CONTEXT     pPktContext = (PPACKET_CONTEXT)pvContext;
    DWORD               IfIndex = pPktContext->IfIndex;
    PIF_TABLE_ENTRY     pite;
    

    if (!EnterIgmpWorker()) { return; }
    Trace0(ENTER1, "Entering _WF_ProcessPacket()");

    ACQUIRE_IF_LOCK_SHARED(IfIndex, "_WF_ProcessPacket");

    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // retrieve the interface
        //
        pite = GetIfByIndex(IfIndex);
        if (pite == NULL) {
            Trace1(ERR, "_WF_ProcessPacket: interface %d not found", IfIndex);
            GOTO_END_BLOCK1;
        }

        
        //
        // make sure that the interface is activated
        //
        if (!(IS_IF_ACTIVATED(pite))) {
            Trace1(ERR,"_WF_ProcessPacket() called for inactive IfIndex(%0x)", 
                    IfIndex);
            GOTO_END_BLOCK1;
        }

        //
        // process the packet
        //
        ProcessPacket (pite, pPktContext->InputSrc, pPktContext->DstnMcastAddr, 
                        pPktContext->Length, pPktContext->Packet, pPktContext->Flags);

    } END_BREAKOUT_BLOCK1;
    

    RELEASE_IF_LOCK_SHARED(IfIndex, "_WF_ProcessPacket"); 

    IGMP_FREE(pPktContext);
        

    Trace0(LEAVE1, "Leaving _WF_ProcessPacket()");
    LeaveIgmpWorker();
    
    return;

} //end _WF_ProcessPacket




#define RETURN_FROM_PROCESS_PACKET() {\
        if (DEBUG_TIMER_PACKET&&bPrintTimerDebug) {\
            if (Error==NO_ERROR) {\
                Trace0(TIMER1, "   ");\
                Trace0(TIMER1, "Printing Timer Queue after _ProcessPacket");\
             DebugPrintTimerQueue();\
            }\
        }\
        if (ExitLockRelease&IF_LOCK) \
            RELEASE_IF_LOCK_SHARED(IfIndex, "_ProcessPacket"); \
        if (ExitLockRelease&GROUP_LOCK) \
            RELEASE_GROUP_LOCK(Group, "_ProcessPacket"); \
        if (ExitLockRelease&TIMER_LOCK) \
            RELEASE_TIMER_LOCK("_ProcessPacket");\
        Trace0(LEAVE1, "Leaving _ProcessPacket1()\n"); \
        return; \
    }



//------------------------------------------------------------------------------
//            _ProcessPacket
//
// Processes a packet received on an interface
//
// Locks: Assumes either shared Interface lock
//        or shared Socket Lock.
//      if ras interface, this procedure takes read lock on the ras table.
// Called by: _ProcessInputOnInterface() or _WF_ProcessPacket()
//------------------------------------------------------------------------------

VOID 
ProcessPacket (
    PIF_TABLE_ENTRY     pite,
    DWORD               InputSrcAddr,
    DWORD               DstnMcastAddr,
    DWORD               NumBytes,
    PBYTE               pPacketData,    // igmp packet hdr. data following it ignored
    BOOL                bRtrAlertSet
    )
{
    DWORD                   Error = NO_ERROR;
    DWORD                   IfIndex = pite->IfIndex, Group=0, IfVersion;
    IGMP_HEADER UNALIGNED   *pHdr;
    PIF_INFO                pInfo = &pite->Info;
    PIGMP_IF_CONFIG         pConfig = &pite->Config;

    PRAS_TABLE              prt;
    PRAS_TABLE_ENTRY        prte;
    PRAS_CLIENT_INFO        pRasInfo;
    BOOL                    bRasStats = FALSE, bPrintTimerDebug=TRUE;
    LONGLONG                llCurTime = GetCurrentIgmpTime();
    INT                     cmp;
    CHAR                    szPacketType[30];
    
    
    enum {
        NO_LOCK=0,
        IF_LOCK=0x1,
        RAS_LOCK=0x2,
        GROUP_LOCK=0x4,
        TIMER_LOCK=0x8
        } ExitLockRelease;

    ExitLockRelease = 0;

    IfVersion = IS_IF_VER1(pite)? 1: (IS_IF_VER2(pite)?2:3);

    Trace2(ENTER1, "Entering _ProcessPacket() IfIndex(%0x) DstnMcastAddr(%d.%d.%d.%d)",
            IfIndex, PRINT_IPADDR(DstnMcastAddr)
            );

    
    //
    // the packet must be at least some minimum length
    //
    if (NumBytes < MIN_PACKET_SIZE) {

        Trace4(RECEIVE,
            "%d-byte packet from %d.%d.%d.%d on If %0x (%d.%d.%d.%d) is too small",
              NumBytes, PRINT_IPADDR(InputSrcAddr), IfIndex, pite->IpAddr
              );
        Logwarn2(PACKET_TOO_SMALL, "%I%I", pite->IpAddr, InputSrcAddr, NO_ERROR);


        InterlockedIncrement(&pite->Info.ShortPacketsReceived);

        //todo: implement ras stats
        /*if (bRasStats) 
            InterlockedIncrement(&pRasInfo->ShortPacketsReceived);
        */
        bPrintTimerDebug = FALSE;
        RETURN_FROM_PROCESS_PACKET();
    }

    
    //
    // initialize packet fields
    //
    pHdr = (IGMP_HEADER UNALIGNED *) pPacketData;
    Group = pHdr->Group;


    //
    // Verify packet version
    //
    
    if ( (pHdr->Vertype==IGMP_QUERY)||(pHdr->Vertype==IGMP_REPORT_V1)
            || (pHdr->Vertype==IGMP_REPORT_V2) || (pHdr->Vertype==IGMP_REPORT_V3)
            || (pHdr->Vertype==IGMP_LEAVE) )
    {
        InterlockedIncrement(&pInfo->TotalIgmpPacketsForRouter);
        //if (bRasStats)
        //    InterlockedIncrement(&pRasInfo->TotalIgmpPacketsForRouter);
    }
    else {
        bPrintTimerDebug = FALSE;
        RETURN_FROM_PROCESS_PACKET();
    }

    switch(pHdr->Vertype) {
        case IGMP_QUERY:
            lstrcpy(szPacketType, "igmp-query"); break;
        case IGMP_REPORT_V1:
            lstrcpy(szPacketType, "igmp-report-v1"); break;
        case IGMP_REPORT_V2:
            lstrcpy(szPacketType, "igmp-report-v2"); break;
        case IGMP_REPORT_V3:
            lstrcpy(szPacketType, "igmp-report-v3"); break;
        case IGMP_LEAVE:
            lstrcpy(szPacketType, "igmp-leave"); break;
    };        
        
        


    //
    // check for router alert option
    //
    if (!bRtrAlertSet) {

        InterlockedIncrement(&pInfo->PacketsWithoutRtrAlert);

        if (pite->Config.Flags&IGMP_ACCEPT_RTRALERT_PACKETS_ONLY) {
            Trace3(RECEIVE, 
                "%s packet from %d ignored on IfIndex(%d%) due to no "
                "RtrAlert option",
                szPacketType, PRINT_IPADDR(InputSrcAddr), IfIndex
                );
                
            bPrintTimerDebug = FALSE;
            RETURN_FROM_PROCESS_PACKET();
        }
    }
        

    
    //
    // Make sure that the DstnMcastAddr is a valid multicast addr
    // or the unicast address of the router
    //
    
    if (!IS_MCAST_ADDR(DstnMcastAddr) && DstnMcastAddr!=pite->IpAddr) {
        Trace2(ERR, 
            "Error! Igmp router received packet from Src(%d.%d.%d.%d) with "
            "dstn addr(%d.%d.%d.%d) which is not valid",
            PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr)
            );
        IgmpAssertOnError(FALSE);

        bPrintTimerDebug = FALSE;
        RETURN_FROM_PROCESS_PACKET();
    }


    //
    // make sure that the interface is activated
    //
    if (!(IS_IF_ACTIVATED(pite))) {
    
        Trace1(ERR,"ProcessPacket() called for inactive IfIndex(%0x)", 
                IfIndex);
        bPrintTimerDebug = FALSE;
        RETURN_FROM_PROCESS_PACKET();
    }

    //
    //if ras-server, then get lock on ras table. 
    //
    if ( IS_RAS_SERVER_IF(pite->IfType) ) {

        prt = pite->pRasTable;


        //
        // retrieve ras client by addr
        //
        prte = GetRasClientByAddr(InputSrcAddr, prt);

        if (prte==NULL) {
            Trace3(ERR,
                "Got Igmp packet from an unknown ras client(%d.%d.%d.%d) on "
                "IF(%d:%d.%d.%d.%d)",
                PRINT_IPADDR(InputSrcAddr), IfIndex, PRINT_IPADDR(pite->IpAddr)
                );
            bPrintTimerDebug = FALSE;
            RETURN_FROM_PROCESS_PACKET();
        }

        #if 0
        // if the ras-client is not active, then return
        if (prte->Status&DELETED_FLAG)
             RETURN_FROM_PROCESS_PACKET();
        #endif

        // should I update ras client stats
        bRasStats = g_Config.RasClientStats;
        pRasInfo = &prte->Info;
    }

    
    //
    // increment count of total igmp packets received
    //
    InterlockedIncrement(&pInfo->TotalIgmpPacketsReceived);
    if (bRasStats)
        InterlockedIncrement(&pRasInfo->TotalIgmpPacketsReceived);



    //
    // long packet received. print trace if not v3. But it is not an error
    //
    if ( (NumBytes > MIN_PACKET_SIZE) && !IS_CONFIG_IGMP_V3(&pite->Config)) {

        Trace4( RECEIVE,
            "%d-byte packet from %d.%d.%d.%d on If %d (%d.%d.%d.%d) is too large",
              NumBytes, PRINT_IPADDR(InputSrcAddr), IfIndex, 
              PRINT_IPADDR(pite->IpAddr)
              );
        
        InterlockedIncrement(&pite->Info.LongPacketsReceived);
        if (bRasStats)
            InterlockedIncrement(&pRasInfo->LongPacketsReceived);
    }


        
    //
    // Verify Igmp checksum
    //
    if (xsum(pHdr, NumBytes) != 0xffff) {
        Trace0(RECEIVE, "Wrong checksum packet received");
        
        InterlockedIncrement(&pInfo->WrongChecksumPackets);
        if (bRasStats)
            InterlockedIncrement(&pRasInfo->WrongChecksumPackets);
        
        RETURN_FROM_PROCESS_PACKET();
    }

    


    switch (pHdr->Vertype) {


    //////////////////////////////////////////////////////////////////
    //                    IGMP-QUERY                                //
    //////////////////////////////////////////////////////////////////
    case IGMP_QUERY : 
    {
        //
        // ignore the query if it came from this interface
        //
        if (MatchIpAddrBinding(pite, InputSrcAddr)) {

            /*
            Trace3(RECEIVE, 
                "received query packet sent by myself: IfIndex(%0x)"
                "IpAddr(%d.%d.%d.%d) DstnMcastAddr(%d.%d.%d.%d)",
                IfIndex, PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr)
                );
            */
            bPrintTimerDebug = FALSE;
            RETURN_FROM_PROCESS_PACKET();
        }



        //
        // Error if interface type is IGMP_IF_RAS_SERVER. can be 
        // IGMP_IF_RAS_ROUTER or IS_NOT_RAS_IF
        //
        if (! ( (IS_NOT_RAS_IF(pite->IfType))||(IS_RAS_ROUTER_IF(pite->IfType) ) )
            )
        {

            Trace3(ERR, 
                "Error received Query on IfIndex(%d: %d.%d.%d.%d) from "
                "Ras client(%d.%d.%d.%d)",
                IfIndex, PRINT_IPADDR(pite->IpAddr), PRINT_IPADDR(InputSrcAddr)
                );
            IgmpAssertOnError(FALSE);

            bPrintTimerDebug = FALSE;
            RETURN_FROM_PROCESS_PACKET();

        }

        
        //////////////////////////////////////////////////////////////////
        // General Query
        //////////////////////////////////////////////////////////////////
        
        if (pHdr->Group==0) {

            DWORD Version,//Min(interface,pkt vertion)
                  RealVersion;//pkt version

            // get versions
            Version = ((pHdr->ResponseTime==0)||IS_IF_VER1(pite))
                      ? 1
                      : ( (NumBytes==sizeof(IGMP_HEADER)||IS_IF_VER2(pite)) ? 2 : 3);
                            
            RealVersion = (pHdr->ResponseTime==0)
                      ? 1
                      : (NumBytes==sizeof(IGMP_HEADER) ? 2 : 3);
                            
            Trace3(RECEIVE, 
                "General Query Version:%d received on interface(%d) from %d.%d.%d.%d", 
                IfIndex, RealVersion, PRINT_IPADDR(InputSrcAddr));    
            if (Version!=RealVersion){
                Trace2(RECEIVE, "Processing the Version:%d packet as Version:%d",
                    RealVersion, RealVersion);
            }
            
            //
            // check that the dstn addr was AllHostsAddr
            //
            if (DstnMcastAddr!=ALL_HOSTS_MCAST) {
                Trace3(RECEIVE, 
                    "received query packet not on AllHostsGroup: IfIndex(%0x)"
                    "SrcAddr(%d.%d.%d.%d) DstnMcastAddr(%d.%d.%d.%d)",
                    IfIndex, PRINT_IPADDR(InputSrcAddr), 
                    PRINT_IPADDR(DstnMcastAddr)
                    );
                RETURN_FROM_PROCESS_PACKET();
            }

            
            //
            // acquire timer lock
            //
            
            ACQUIRE_TIMER_LOCK("_ProcessPacket");
            ExitLockRelease |= TIMER_LOCK;
            

            //
            // log warning if incorrect version query received
            //

            
            if ( ((RealVersion==1)&&(!IS_PROTOCOL_TYPE_IGMPV1(pite)))
                || (RealVersion==2 && !IS_PROTOCOL_TYPE_IGMPV2(pite))
                || (RealVersion==3 && IS_PROTOCOL_TYPE_IGMPV3(pite)) )
            {                
                // get warn interval in system time
                    
                LONGLONG llWarnInterval = OTHER_VER_ROUTER_WARN_INTERVAL*60*1000;

                InterlockedIncrement(&pInfo->WrongVersionQueries);

                //
                // check if warn interval time has passed since last warning
                // I check if OtherVerPresentTimeWarn>llCurTime to take care 
                // of timer resets
                //
                if ( (pInfo->OtherVerPresentTimeWarn+llWarnInterval<llCurTime)
                    || (pInfo->OtherVerPresentTimeWarn>llCurTime) )
                {
                    if (pHdr->ResponseTime==0) {
                        Trace3(RECEIVE, 
                            "Detected ver-%d router(%d.%d.%d.%d) on "
                            "interface(%d.%d.%d.%d)",
                            Version, PRINT_IPADDR(InputSrcAddr), 
                            PRINT_IPADDR(pite->IpAddr));
                        Logwarn2(VERSION_QUERY, "%I%I", InputSrcAddr, 
                            pite->IpAddr, NO_ERROR);
                    }
                    pInfo->OtherVerPresentTimeWarn = llCurTime;
                }
            }

            if (Version==1)
                pite->Info.V1QuerierPresentTime = llCurTime 
                    + CONFIG_TO_SYSTEM_TIME(IGMP_VER1_RTR_PRESENT_TIMEOUT);
                    

            //
            // if IpAddress less than my address then I become NonQuerier
            // even if I am in Startup Mode
            //
            
            if (INET_CMP(InputSrcAddr, pite->IpAddr, cmp) <0) {

                DWORD QQIC=0,QRV=0;

                // last querier is being changed from myself to B, or from A to B.
                if (InputSrcAddr != pite->Info.QuerierIpAddr)
                    pite->Info.LastQuerierChangeTime = llCurTime;

                //
                // if (version 3, change robustness variable and query interval 
                // if required) (only if I am not querier. else it will be 
                // changed when I change to non-querier
                //
                if (Version==3 && !IS_QUERIER(pite)
                    &&(INET_CMP(InputSrcAddr, pite->Info.QuerierIpAddr, cmp)<=0))
                {                    
                    PIGMP_HEADER_V3_EXT pSourcesQuery;
                    
                    pSourcesQuery = (PIGMP_HEADER_V3_EXT)
                                    ((PBYTE)pHdr+sizeof(IGMP_HEADER));

                    if (pSourcesQuery->QRV!=0) {
                        if (pite->Config.RobustnessVariable!=pSourcesQuery->QRV)
                        {
                            Trace3(CONFIG,
                                "Changing Robustness variable from %d to %d. "
                                "Querier:%d.%d.%d.%d",
                                pite->Config.RobustnessVariable,
                                pSourcesQuery->QRV,
                                PRINT_IPADDR(InputSrcAddr)
                                );
                            pite->Config.RobustnessVariable = pSourcesQuery->QRV;
                        }
                    }

                    QQIC = GET_QQIC_FROM_CODE(pSourcesQuery->QQIC)*1000;
                    if (pSourcesQuery->QQIC!=0 && pite->Config.GenQueryMaxResponseTime < QQIC) {
                
                        if (pite->Config.GenQueryInterval!=QQIC)
                        {
                            Trace3(CONFIG,
                                "Changing General-Query-Interval from %d to %d. "
                                "Querier:%d.%d.%d.%d",
                                pite->Config.GenQueryInterval/1000,
                                QQIC/1000,
                                PRINT_IPADDR(InputSrcAddr)
                                );
                            pite->Config.GenQueryInterval
                                = QQIC;
                        }
                    }
                    pite->Config.GroupMembershipTimeout =
                        pite->Config.RobustnessVariable*pite->Config.GenQueryInterval
                        + pite->Config.GenQueryMaxResponseTime;

                    pite->Config.OtherQuerierPresentInterval
                        = pite->Config.RobustnessVariable*pite->Config.GenQueryInterval
                            + (pite->Config.GenQueryMaxResponseTime)/2;

                }

                
                
                // change from querier to non-querier
                if (IS_QUERIER(pite)) {

                    PQUERIER_CONTEXT pwi = IGMP_ALLOC(sizeof(QUERIER_CONTEXT), 
                                                    0x800080,pite->IfIndex);
                    if (pwi==NULL) 
                        RETURN_FROM_PROCESS_PACKET();

                    pwi->IfIndex = IfIndex;
                    pwi->QuerierIpAddr = InputSrcAddr;
                    pwi->NewRobustnessVariable = QRV;
                    pwi->NewGenQueryInterval = QQIC;
                    
                    // I have to queue a work item as I have to take an If write lock
                    QueueIgmpWorker(WF_BecomeNonQuerier, (PVOID)pwi);

                    Trace2(RECEIVE, "_ProcessPacket queued _WF_BecomeNonQuerier "
                            "on If:%0x Querier(%d.%d.%d.%d)",
                            IfIndex, PRINT_IPADDR(InputSrcAddr));
                }
                // I am non-querier already
                else {
                    InterlockedExchange(&pite->Info.QuerierIpAddr, InputSrcAddr);

                    #if DEBUG_TIMER_TIMERID
                    SET_TIMER_ID(&pite->NonQueryTimer, 211, pite->IfIndex, 0, 0);
                    #endif
                    
                    UpdateLocalTimer(&pite->NonQueryTimer, 
                        pite->Config.OtherQuerierPresentInterval, DBG_N);

                                            
                    // not using interlockedExchange
                    pite->Info.QuerierPresentTimeout = llCurTime
                        + CONFIG_TO_SYSTEM_TIME(pite->Config.OtherQuerierPresentInterval);
                }
            }
            //
            // Ignore query from querier with higher IpAddr
            //
            else {

            }


            RELEASE_TIMER_LOCK("_ProcessPacket");
            ExitLockRelease &= ~TIMER_LOCK;

            RETURN_FROM_PROCESS_PACKET();

        } //end general query
        
        
        //////////////////////////////////////////////////////////////////
        //     Group Specific Query
        //////////////////////////////////////////////////////////////////

        else {
            Error = ProcessGroupQuery(pite, pHdr, NumBytes, InputSrcAddr, DstnMcastAddr);
            RETURN_FROM_PROCESS_PACKET();
        }
        

        break;
        
    } //end query (groupSpecific or general)


    //////////////////////////////////////////////////////////////////
    //        IGMP_REPORT_V1, IGMP_REPORT_V2, IGMP_REPORT_V3        //
    //////////////////////////////////////////////////////////////////

    case IGMP_REPORT_V1 : 
    case IGMP_REPORT_V2 :
    case IGMP_REPORT_V3 :
    {
        Error = ProcessReport(pite, pHdr, NumBytes, InputSrcAddr, DstnMcastAddr);
        RETURN_FROM_PROCESS_PACKET();      
    }
   
    
    //////////////////////////////////////////////////////////////////
    //            IGMP_LEAVE                                        //
    //////////////////////////////////////////////////////////////////
    
    case IGMP_LEAVE :
    {
        PGROUP_TABLE_ENTRY  pge;    //group table entry
        PGI_ENTRY           pgie;   //group interface entry


        Trace3(RECEIVE, 
                "IGMP Leave for group(%d.%d.%d.%d) on IfIndex(%0x) from "
                "SrcAddr(%d.%d.%d.%d)",
                PRINT_IPADDR(Group), IfIndex, PRINT_IPADDR(InputSrcAddr)
                );


        // 
        // the multicast group should not be 224.0.0.x
        //
        if (LOCAL_MCAST_GROUP(DstnMcastAddr)) {
            Trace2(RECEIVE, 
                "Leave Report received from %d.%d.%d.%d for "
                "Local group(%d.%d.%d.%d)",
                PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr));
            RETURN_FROM_PROCESS_PACKET();
        }
        
        //
        // check that the dstn addr was AllRoutersAddr 
        // or dstn addr must match the group field
        //
        if ( (DstnMcastAddr!=ALL_ROUTERS_MCAST)&&(DstnMcastAddr!=Group) ) {
            Trace3(RECEIVE, 
                "received IGMP Leave packet not on AllRoutersGroup: IfIndex(%0x)"
                "SrcAddr(%d.%d.%d.%d) DstnMcastAddr(%d.%d.%d.%d)",
                IfIndex, PRINT_IPADDR(InputSrcAddr), PRINT_IPADDR(DstnMcastAddr)
                );
            RETURN_FROM_PROCESS_PACKET();
        }

        // 
        // check that the Group field is a valid multicast addr
        //
        if ( !IS_MCAST_ADDR(Group) ) {
            Trace4(RECEIVE, 
                "received IGMP Leave packet with illegal Group(%d.%d.%d.%d) field: "
                "IfIndex(%0x) SrcAddr(%d.%d.%d.%d) DstnMcastAddr(%d.%d.%d.%d)",
                PRINT_IPADDR(Group), IfIndex, PRINT_IPADDR(InputSrcAddr), 
                PRINT_IPADDR(DstnMcastAddr)
                );
            RETURN_FROM_PROCESS_PACKET();
        }
        
        
        //
        // update statistics
        //
        InterlockedIncrement(&pite->Info.LeavesReceived);
        if (bRasStats)
            InterlockedIncrement(&pRasInfo->LeavesReceived);


        //
        // if Leave processing not enabled or not querier then ignore Leave.
        //
        if ( !((IS_IF_VER2(pite)||IS_IF_VER3(pite)) && (IS_QUERIER(pite))) ) {
            Trace0(RECEIVE,"Ignoring the Leave Packet");
            break;
        }

        //
        // Lock the group table
        //
        ACQUIRE_GROUP_LOCK(Group, "_ProcessPacket");
        ExitLockRelease |= GROUP_LOCK;
        

        //
        // find the group entry. If entry not found then ignore the leave messg
        //
        pge = GetGroupFromGroupTable(Group, NULL, llCurTime);
        if (pge==NULL) {
            Error = ERROR_CAN_NOT_COMPLETE;
            Trace2(ERR, "Leave received for nonexisting group(%d.%d.%d.%d) on IfIndex(%0x)",
                    PRINT_IPADDR(Group), pite->IfIndex);
            RETURN_FROM_PROCESS_PACKET();
        }
        

        //
        // find the GI entry. If GI entry does not exist or has deletedFlag then
        // ignore the leave
        //
        pgie = GetGIFromGIList(pge, pite, InputSrcAddr, NOT_STATIC_GROUP, NULL, llCurTime);
        if ( (pgie==NULL)||(pgie->Status&DELETED_FLAG) ) {
            Error = ERROR_CAN_NOT_COMPLETE;
            Trace2(ERR, "leave received for nonexisting group(%d.%d.%d.%d) on IfIndex(%0x). Not member",
                    PRINT_IPADDR(Group), IfIndex);
            RETURN_FROM_PROCESS_PACKET();
        }


        // ignore leave if it is not in ver 2 mode
        if (pgie->Version!=2)
            RETURN_FROM_PROCESS_PACKET();

            
        
        // if static group, ignore leave
        if (pgie->bStaticGroup) {
            Trace2(ERR, 
                "Leave not processed for group(%d.%d.%d.%d) on IfIndex(%0x): "
                "Static group",
                PRINT_IPADDR(Group), IfIndex
                );
            RETURN_FROM_PROCESS_PACKET();
        }

        
            
        //
        // if v1-query received recently for that group, then ignore leaves
        //
        //
        if (pgie->Version==1) 
        {
            Error = ERROR_CAN_NOT_COMPLETE;
            Trace2(ERR, 
                "Leave not processed for group(%d.%d.%d.%d) on IfIndex(%0x)"
                "(recent v1 report)",
                PRINT_IPADDR(Group), IfIndex
                );

            bPrintTimerDebug = FALSE;
            RETURN_FROM_PROCESS_PACKET();
        }


        //
        // if ras server interface, then delete the group entry and I am done.
        // GroupSpecific Query is not sent to ras clients
        //
        // if pConfig->LastMemQueryCount==0 then the group is expected to be
        // deleted immediately
        //
        
        if ( IS_RAS_SERVER_IF(pite->IfType) || pConfig->LastMemQueryCount==0) {

            DeleteGIEntry(pgie, TRUE, TRUE); //updateStats, CallMgm

            RETURN_FROM_PROCESS_PACKET();
        }

        
        
        ACQUIRE_TIMER_LOCK("_ProcessPacket");
        ExitLockRelease |= TIMER_LOCK;

        
        //
        // if timer already expired return. 
        // Leave the group deletion to Membership timer
        //
        if ( !(pgie->GroupMembershipTimer.Status&TIMER_STATUS_ACTIVE)
            ||(pgie->GroupMembershipTimer.Timeout<llCurTime) )
        {
            RETURN_FROM_PROCESS_PACKET();
        }


        //
        // if currently processing a leave then exit.
        //
        if (pgie->LastMemQueryCount>0) {
            RETURN_FROM_PROCESS_PACKET();
        }

        //
        // in almost all places, I have to do this check.
        // change the way insert and update timers' timeout is set

        
        //
        // set a new leave timer. Set the new LastMemQueryCount left
        //
        if (pConfig->LastMemQueryCount) {

            pgie->LastMemQueryCount = pConfig->LastMemQueryCount - 1; 

            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&pgie->LastMemQueryTimer, 410, pite->IfIndex, 
                        Group, 0);
            #endif
            
            InsertTimer(&pgie->LastMemQueryTimer, pConfig->LastMemQueryInterval, TRUE, DBG_Y);
        }
        
        
        //
        // set membership timer to 
        // min{currentValue,LastMemQueryInterval*LastMemQueryCount}
        //

        if (pgie->GroupMembershipTimer.Timeout >
            (llCurTime+(pConfig->LastMemQueryCount
                        *CONFIG_TO_SYSTEM_TIME(pConfig->LastMemQueryInterval)))
           )
        {
            #if DEBUG_TIMER_TIMERID
                pgie->GroupMembershipTimer.Id = 340;
                pgie->GroupMembershipTimer.Id2 = TimerId++;
            #endif

            UpdateLocalTimer(&pgie->GroupMembershipTimer, 
                pConfig->LastMemQueryCount*pConfig->LastMemQueryInterval,
                DBG_N);

            // update GroupExpiryTime so that correct stats are displayed
            pgie->Info.GroupExpiryTime = llCurTime 
                    + CONFIG_TO_SYSTEM_TIME(pConfig->LastMemQueryCount
                                            *pConfig->LastMemQueryInterval);
        }



        //
        //release timer and groupBucket locks
        //I still have read lock on the IfTable/RasTable
        //
        RELEASE_TIMER_LOCK("_ProcessPacket");
        RELEASE_GROUP_LOCK(Group, "_ProcessPacket");

        ExitLockRelease &= ~TIMER_LOCK;
        ExitLockRelease &= ~GROUP_LOCK;


        //
        // send group specific query only if I am a querier
        //
        if (IS_QUERIER(pite))
            SEND_GROUP_QUERY_V2(pite, Group);


        //releae ifLock/RasLock and exit
        RETURN_FROM_PROCESS_PACKET();

    }//igmp leave

    default :
    {
        Error = ERROR_CAN_NOT_COMPLETE;
        Trace3(ERR, 
            "Incorrect Igmp type(%d) packet received on IfIndex(%d%) Group(%d.%d.%d.5d)",
            pHdr->Vertype, IfIndex, PRINT_IPADDR(Group)
            );
        IgmpAssertOnError(FALSE);
        RETURN_FROM_PROCESS_PACKET();

    }
    }


    RETURN_FROM_PROCESS_PACKET();

    
} //end _ProcessPacket


    

//------------------------------------------------------------------------------
//          _T_LastVer1ReportTimer
//
// For this GI entry, the last ver-1 report has timed out. Change to ver-2 if
// the interface is set to ver-2.
// Locks: Assumes timer lock.
//
// be careful as only timer lock held. make sure that the worker fn checks 
// everything. recheck igmp version, etc.
//------------------------------------------------------------------------------

DWORD
T_LastVer1ReportTimer (
    PVOID    pvContext
    ) 
{
    PIGMP_TIMER_ENTRY               pTimer; //ptr to timer entry
    PGI_ENTRY                       pgie;   //group interface entry
    PIF_TABLE_ENTRY                 pite;
    LONGLONG                        llCurTime = GetCurrentIgmpTime();
    

    Trace0(ENTER1, "Entering _T_LastVer1ReportTimer()");

    //
    // get pointer to LastMemQueryTimer, GI entry, pite
    //
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);
    pgie = CONTAINING_RECORD( pTimer, GI_ENTRY, LastVer1ReportTimer);
    pite = pgie->pIfTableEntry;

    //
    // if IfTable not activated, then break
    //
    if (!IS_IF_ACTIVATED(pite) || (pgie->Status&DELETED_FLAG))
        return NO_ERROR;


    Trace2(TIMER, "T_LastVer1ReportTimer() called for If(%0x), Group(%d.%d.%d.%d)",
            pite->IfIndex, PRINT_IPADDR(pgie->pGroupTableEntry->Group));
            
    
    // set the state to ver-2 unless the interface is ver-1, in which case
    // set the version-1 timer again. 
    
    if (IS_PROTOCOL_TYPE_IGMPV2(pite)) {
        pgie->Version = 2;
    }
    else if (IS_PROTOCOL_TYPE_IGMPV3(pite)) {

        if (IS_TIMER_ACTIVE(pgie->LastVer2ReportTimer))
            pgie->Version = 2;
        else {

            PWORK_CONTEXT   pWorkContext;
            DWORD           Error=NO_ERROR;
            
            //
            // queue work item for shifting to v3 for that group
            //

            CREATE_WORK_CONTEXT(pWorkContext, Error);
            if (Error!=NO_ERROR) {
                return ERROR_CAN_NOT_COMPLETE;
            }
            pWorkContext->IfIndex = pite->IfIndex;
            pWorkContext->Group = pgie->pGroupTableEntry->Group; //ptrs usage safe
            pWorkContext->NHAddr = pgie->NHAddr;  //valid only for ras: should i us
            pWorkContext->WorkType = SHIFT_TO_V3;

            Trace0(WORKER, "Queueing WF_TimerProcessing() to shift to v3");
            QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext);
        }
    }

    
    Trace0(LEAVE1, "Leaving _T_LastVer1ReportTimer()");

    return 0;
}



    



//------------------------------------------------------------------------------
//            _T_LastMemQueryTimer
// called when LastMemQueryTimer() has expired. This timer is not used to 
// time out memberships (GroupMembershipTimer is used for that). It is only
// used to send GroupSpecific Queries.
//
// Queues: WF_TimerProcessing() to send group specific query.
// Note:  WT_ProcessTimerEvent() makes sure the protocol is not stopp-ing/ed
// Locks: Assumes timer lock. does not need any other lock.
// be careful as only timer lock held. make sure that the worker fn checks 
// everything. recheck igmp version, etc.
//------------------------------------------------------------------------------

DWORD
T_LastMemQueryTimer (
    PVOID    pvContext
    )
{
    DWORD                           Error=NO_ERROR;
    PIGMP_TIMER_ENTRY               pTimer; //ptr to timer entry
    PGI_ENTRY                       pgie;   //group interface entry
    PWORK_CONTEXT                   pWorkContext;
    PIF_TABLE_ENTRY                 pite;
    PRAS_TABLE_ENTRY                prte;
    BOOL                            bCompleted = FALSE; //if false, set count to 0
    

    Trace0(ENTER1, "Entering _T_LastMemQueryTimer()");


    //
    // get pointer to LastMemQueryTimer, GI entry, pite, prte
    //
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);
    pgie = CONTAINING_RECORD( pTimer, GI_ENTRY, LastMemQueryTimer);
    pite = pgie->pIfTableEntry;
    prte = pgie->pRasTableEntry;

    //
    // if IfTable not activated, then break
    //
    if (!IS_IF_ACTIVATED(pite))
        return NO_ERROR;


    Trace2(TIMER, "_T_LastMemQueryTimer() called for If(%0x), Group(%d.%d.%d.%d)",
            pite->IfIndex, PRINT_IPADDR(pgie->pGroupTableEntry->Group));


    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // if GI or pite or prte has   flag already set, then exit
        //
        if ( (pgie->Status&DELETED_FLAG) || (pite->Status&DELETED_FLAG) ) 
            GOTO_END_BLOCK1;
        
        if ( (prte!=NULL) && (prte->Status&DELETED_FLAG) ) 
            GOTO_END_BLOCK1;
        

        if (pgie->Version!=3) {
            //
            // if LeaveEnabled FALSE then return
            //
            if (!GI_PROCESS_GRPQUERY(pite, pgie)) 
                GOTO_END_BLOCK1;
        }
        
        
        //
        // have sent the last GroupSpecific query. GroupMembershipTimer will take care
        // of deleting this GI entry
        //
        if (pgie->LastMemQueryCount==0) {
            bCompleted = TRUE;
            GOTO_END_BLOCK1;
        }
        
        //
        // decrement count.
        //
        if (InterlockedDecrement(&pgie->LastMemQueryCount) == (ULONG)-1) {
            pgie->LastMemQueryCount = 0;
        }


        
        // 
        // if count==0, dont insert timer again, but send the last groupSp Query
        //
        
        if (pgie->LastMemQueryCount>0) {                
        
            //reinsert the timer to send the next GroupSpQuery 
            
            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&pgie->LastMemQueryTimer, 420, pite->IfIndex,
                        pgie->pGroupTableEntry->Group, 0);
            #endif
            
            InsertTimer(&pgie->LastMemQueryTimer, 
                pite->Config.LastMemQueryInterval, FALSE, DBG_Y);
        }


        //
        // queue work item for sending the GroupSp query even if the router
        // is not a Querier
        //
        
        CREATE_WORK_CONTEXT(pWorkContext, Error);
        if (Error!=NO_ERROR) {
            GOTO_END_BLOCK1;
        }
        pWorkContext->IfIndex = pite->IfIndex;
        pWorkContext->Group = pgie->pGroupTableEntry->Group;
        pWorkContext->NHAddr = pgie->NHAddr;  //valid only for ras: should i use it?
        pWorkContext->WorkType = (pgie->Version==3) ? MSG_GROUP_QUERY_V3
                                                    : MSG_GROUP_QUERY_V2;
        
        Trace0(WORKER, "Queueing WF_TimerProcessing() to send GroupSpQuery:");
        QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext);

        
        bCompleted = TRUE;
        
    } END_BREAKOUT_BLOCK1;

       
    // there was some error somewhere. so set the LastMemQueryCount to 0
    
    if (!bCompleted)
        InterlockedExchange(&pgie->LastMemQueryCount, 0);


    Trace0(LEAVE1, "Leaving _T_LastMemQueryTimer()");
    return 0;

} //end _T_LastMemQueryTimer


//------------------------------------------------------------------------------
//            _T_MembershipTimer
//
// lock: has TimerLock
// called when the GroupMembershipTimer is fired
// delete the GI entry if it exists.
//
// be careful as only timer lock held. make sure that the worker fn checks 
// everything. recheck igmp version, etc.
//------------------------------------------------------------------------------
DWORD
T_MembershipTimer (
    PVOID    pvContext
    )
{
    DWORD                           Error=NO_ERROR;
    PIGMP_TIMER_ENTRY               pTimer; //ptr to timer entry
    PGI_ENTRY                       pgie;   //group interface entry

    PWORK_CONTEXT                   pWorkContext;
    PIF_TABLE_ENTRY                 pite;
    PRAS_TABLE_ENTRY                prte;

    
    Trace0(ENTER1, "Entering _T_MembershipTimer()");

    BEGIN_BREAKOUT_BLOCK1 {
    
        //
        // get pointer to Membership Timer, GI entry, pite, 
        //
        pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);
        pgie = CONTAINING_RECORD( pTimer, GI_ENTRY, GroupMembershipTimer);
        pite = pgie->pIfTableEntry;
        prte = pgie->pRasTableEntry;

        //
        // if IfTable not activated, then break
        //
        if (!IS_IF_ACTIVATED(pite))
            GOTO_END_BLOCK1;


        Trace2(TIMER, "_T_MembershipTimer() called for If(%0x), Group(%d.%d.%d.%d)",
            pite->IfIndex, PRINT_IPADDR(pgie->pGroupTableEntry->Group));

        //
        // if GI or pite or prte has deleted flag already set, then exit
        //
        if ( (pgie->Status&DELETED_FLAG) || (pite->Status&DELETED_FLAG) ) {
            GOTO_END_BLOCK1;
        }

        //
        // if Ras, and ras table being deleted then break
        //
        if ( (prte!=NULL) && (prte->Status&DELETED_FLAG) )
            GOTO_END_BLOCK1;

        //
        // if IfTable not activated, then break
        //
        if (!IS_IF_ACTIVATED(pite))
            GOTO_END_BLOCK1;

            

        //
        // if LastMemTimer is active, remove it(cant remove it in this function
        // as it is being processed by the timer queue simultaneously.
        if (pgie->LastMemQueryCount>0)
            pgie->LastMemQueryCount = 0;

            
        //
        // queue work item to delete the GI entry
        //
        
        CREATE_WORK_CONTEXT(pWorkContext, Error);
        if (Error!=NO_ERROR)
                GOTO_END_BLOCK1;
        pWorkContext->IfIndex = pite->IfIndex;
        pWorkContext->NHAddr = pgie->NHAddr;
        pWorkContext->Group = pgie->pGroupTableEntry->Group;
        pWorkContext->WorkType = DELETE_MEMBERSHIP;

        Trace0(WORKER, "_T_MembershipTimer queued _WF_TimerProcessing:");

        QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext);


    } END_BREAKOUT_BLOCK1;

    Trace0(LEAVE1, "Leaving _T_MembershipTimer()");


    return 0;
    
} //end _T_MembershipTimer


//------------------------------------------------------------------------------
//            _T_QueryTimer
// fired when a general query timer is fired. Sends a general query.
// The timer queue is currently locked
//
// be careful as only timer lock held. make sure that the worker fn checks 
// everything. recheck igmp version, etc.
//------------------------------------------------------------------------------
DWORD
T_QueryTimer (
    PVOID    pvContext
    )
{
    DWORD               Error=NO_ERROR;
    PIGMP_TIMER_ENTRY   pTimer;     //ptr to timer entry
    PWORK_CONTEXT       pWorkContext;
    PIF_INFO            pInfo;
    PIF_TABLE_ENTRY     pite;
    static ULONG        Seed = 123456;
    ULONG               ulTimeout;
    BOOL                bRandomize = FALSE; // [0,GenQueryInterval] for 1st gen query after startup.
    
    
    Trace0(ENTER1, "Entering _T_QueryTimer()");
    
    
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);

    pite = CONTAINING_RECORD( pTimer, IF_TABLE_ENTRY, QueryTimer);
    pInfo = &pite->Info;


    //
    // make sure that the interface is activated
    //
    if (!(IS_IF_ACTIVATED(pite))) {
        Trace2(ERR, "T_QueryTimer() called for inactive IfIndex(%0x), IfType(%d)",
            pite->IfIndex, pite->IfType);
        return 0;
    }

    
    Trace2(TIMER, "Processing T_QueryTimer() for IfIndex(%0x), IfType(%d)",
            pite->IfIndex, pite->IfType);


    //
    // check if still in startup Mode.
    //
    if (pInfo->StartupQueryCountCurrent>0) {
        InterlockedDecrement(&pInfo->StartupQueryCountCurrent);
        bRandomize = (pInfo->StartupQueryCountCurrent == 0);
    }    



    // if non-querier, then done if I have sent startupQueries
    if ( !IS_QUERIER(pite) && (pInfo->StartupQueryCountCurrent<=0) )
        return 0;


    // set the next query time
    ulTimeout = (pInfo->StartupQueryCountCurrent>0)
                ? pite->Config.StartupQueryInterval
                : (bRandomize ) 
                    ? (DWORD) ((RtlRandom(&Seed)/(FLOAT)MAXLONG)
                        *pite->Config.GenQueryInterval)
                    : pite->Config.GenQueryInterval;

        
    #if DEBUG_TIMER_TIMERID
        SET_TIMER_ID(&pite->QueryTimer, 120, pite->IfIndex, 0, 0);
    #endif

    InsertTimer(&pite->QueryTimer, ulTimeout, FALSE, DBG_Y);



    //
    // queue work item for sending the general query
    //
    
    CREATE_WORK_CONTEXT(pWorkContext, Error);
    if (Error!=NO_ERROR)
        return 0;
    pWorkContext->IfIndex = pite->IfIndex;
    pWorkContext->WorkType = MSG_GEN_QUERY;
    QueueIgmpWorker(WF_TimerProcessing, (PVOID)pWorkContext);

    Trace0(WORKER, 
        "_T_QueryTimer queued _WF_TimerProcessing: Querier State");
    


    Trace0(LEAVE1, "Leaving _T_QueryTimer()");        
    return 0;
    
} //end _T_QueryTimer


//------------------------------------------------------------------------------
//            _T_NonQueryTimer
// fired when it is in non-querier Mode and hasnt heard a query for a long time
//
// be careful as only timer lock held. make sure that the worker fn checks 
// everything. recheck igmp version, etc.
//------------------------------------------------------------------------------

DWORD
T_NonQueryTimer (
    PVOID    pvContext
    )
{
    DWORD               Error=NO_ERROR;
    PIGMP_TIMER_ENTRY   pTimer;     //ptr to timer entry
    PIF_TABLE_ENTRY     pite;
    
    
    Trace0(ENTER1, "Entering _T_NonQueryTimer()");
    
    
    pTimer = CONTAINING_RECORD( pvContext, IGMP_TIMER_ENTRY, Context);

    pite = CONTAINING_RECORD( pTimer, IF_TABLE_ENTRY, NonQueryTimer);


    //
    // make sure that the interface is activated
    //
    if (!(IS_IF_ACTIVATED(pite))) {
        /*Trace2(ERR, "T_NonQueryTimer() called for inactive IfIndex(%0x), IfType(%d)",
            pite->IfIndex, pite->IfType);
        IgmpAssertOnError(FALSE);*/
        return 0;
    }

    
    Trace2(TIMER, "Processing T_NonQueryTimer() for IfIndex(%0x), IfType(%d)",
            pite->IfIndex, pite->IfType);



    //
    // if non-querier, then queue work item to become querier
    //
    
    if (!IS_QUERIER(pite)) {

        QueueIgmpWorker(WF_BecomeQuerier, (PVOID)(DWORD_PTR)pite->IfIndex);
        
        Trace1(WORKER, "_T_NonQueryTimer queued _WF_BecomeQuerier on If:%0x",
                pite->IfIndex);
    }

    Trace0(LEAVE1, "Leaving _T_NonQueryTimer()");        
    return 0;
}



VOID
WF_BecomeQuerier(
    PVOID   pvIfIndex
    )
//Called by T_NonQueryTimer
{
    ChangeQuerierState(PtrToUlong(pvIfIndex), QUERIER_FLAG, 0, 0, 0);
}



VOID
WF_BecomeNonQuerier(
    PVOID   pvContext
    )
{
    PQUERIER_CONTEXT pwi = (PQUERIER_CONTEXT)pvContext;
    
    ChangeQuerierState(pwi->IfIndex, NON_QUERIER_FLAG, pwi->QuerierIpAddr,
            pwi->NewRobustnessVariable, pwi->NewGenQueryInterval);

    IGMP_FREE(pwi);
}    



VOID
ChangeQuerierState(
    DWORD   IfIndex,
    DWORD   Flag, //QUERIER_CHANGE_V1_ONLY,QUERIER_FLAG,NON_QUERIER_FLAG
    DWORD   QuerierIpAddr, // only when changing from querier-->nonquerier
    DWORD   NewRobustnessVariable, //only for v3:querier->non-querier
    DWORD   NewGenQueryInterval //only for v3:querier->non-querier
    )
{
    PIF_TABLE_ENTRY pite;
    BOOL            bPrevCanAddGroupsToMgm;

    
    if (!EnterIgmpWorker()) return;
    Trace0(ENTER1, "Entering _ChangeQuerierState");


    ACQUIRE_IF_LOCK_EXCLUSIVE(IfIndex, "_ChangeQuerierState");
    
    BEGIN_BREAKOUT_BLOCK1 {

        //
        // retrieve the interface entry
        //
        pite = GetIfByIndex(IfIndex);

        //
        // return error if interface does not exist, or it is not activated
        // or is already in that state
        //
        if ( (pite == NULL)||(!IS_IF_ACTIVATED(pite)) ) {
            Trace1(ERR, 
                "Warning: worker fn could not change querier state for If:%0x", 
                IfIndex
                );
            GOTO_END_BLOCK1;
        }

        //
        // if it is supposed to be a V1 interface, make sure that it is
        //
        if ( (Flag & QUERIER_CHANGE_V1_ONLY) 
                && (!IS_PROTOCOL_TYPE_IGMPV1(pite)) )
        {
            GOTO_END_BLOCK1;
        }
        
        bPrevCanAddGroupsToMgm = CAN_ADD_GROUPS_TO_MGM(pite);


        //
        // changing from non querier to querier
        //
        
        if (Flag & QUERIER_FLAG) {

            
            // if already querier, then done
            if (IS_QUERIER(pite))
                GOTO_END_BLOCK1;


            SET_QUERIER_STATE_QUERIER(pite->Info.QuerierState);

            Trace2(QUERIER, 
                "NonQuerier --> Querier. IfIndex(%0x), IpAddr(%d.%d.%d.%d) ",
                IfIndex, PRINT_IPADDR(pite->IpAddr)
                );


            // copy back the old robustness, genquery, etc values. for v3 
            // interface

            if (IS_IF_VER3(pite)) {
                pite->Config.RobustnessVariable = pite->Config.RobustnessVariableOld;
                pite->Config.GenQueryInterval = pite->Config.GenQueryIntervalOld;
                pite->Config.OtherQuerierPresentInterval
                    = pite->Config.OtherQuerierPresentIntervalOld;
                pite->Config.GroupMembershipTimeout = pite->Config.GroupMembershipTimeoutOld;
            }        


            // register all groups with MGM if I wasnt doing earlier
            
            if (CAN_ADD_GROUPS_TO_MGM(pite) && !bPrevCanAddGroupsToMgm) {
            
                RefreshMgmIgmprtrGroups(pite, ADD_FLAG);

                Trace1(MGM,
                    "Igmp Router start propagating groups to MGM on If:%0x",
                    pite->IfIndex
                    );
            }

            

            // I am the querier again. Set the addr in Info.
            InterlockedExchange(&pite->Info.QuerierIpAddr, pite->IpAddr);

            // update the time when querier was last changed
            pite->Info.LastQuerierChangeTime = GetCurrentIgmpTime();

            //
            // set the GenQuery timer and remove NonQueryTimer if set.
            //
            
            ACQUIRE_TIMER_LOCK("_ChangeQuerierState");

            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&pite->QueryTimer, 220, pite->IfIndex, 0, 0);
            #endif

            if (!IS_TIMER_ACTIVE(pite->QueryTimer))
                InsertTimer(&pite->QueryTimer, pite->Config.GenQueryInterval, FALSE, DBG_Y);

            if (IS_TIMER_ACTIVE(pite->NonQueryTimer))
                RemoveTimer(&pite->NonQueryTimer, DBG_Y);

            RELEASE_TIMER_LOCK("_ChangeQuerierState");



            // send general query

            SEND_GEN_QUERY(pite);
        }
        
        //
        // changing from querier to non querier
        //
        else {

            LONGLONG    llCurTime = GetCurrentIgmpTime();
            BOOL        bPrevAddGroupsToMgm;


            // if already non querier, then done
            if (!IS_QUERIER(pite))
                GOTO_END_BLOCK1;



            // change querier state
            
            SET_QUERIER_STATE_NON_QUERIER(pite->Info.QuerierState);
            
            Trace2(QUERIER, 
                "Querier --> NonQuerier. IfIndex(%0x), IpAddr(%d.%d.%d.%d) ",
                IfIndex, PRINT_IPADDR(pite->IpAddr)
                );
            
            InterlockedExchange(&pite->Info.QuerierIpAddr, QuerierIpAddr);



            //
            // if previously, groups were propagated to MGM, but should
            // not be propagated now, then deregister the groups from MGM
            //

            if (!CAN_ADD_GROUPS_TO_MGM(pite) && bPrevCanAddGroupsToMgm) {

                RefreshMgmIgmprtrGroups(pite, DELETE_FLAG);
                
                Trace1(MGM,
                    "Igmp Router stop propagating groups to MGM on If:%0x",
                    pite->IfIndex
                    );
            }

            
            if (IS_IF_VER3(pite)) {
                if (NewRobustnessVariable==0)
                    NewRobustnessVariable = pite->Config.RobustnessVariableOld;
                if (NewGenQueryInterval==0)
                    NewGenQueryInterval = pite->Config.GenQueryIntervalOld;

                if (pite->Config.GenQueryMaxResponseTime > NewGenQueryInterval)
                    NewGenQueryInterval = pite->Config.GenQueryIntervalOld;
                    
                if (NewRobustnessVariable != pite->Config.RobustnessVariable
                    || NewGenQueryInterval != pite->Config.RobustnessVariable
                    ) {
                    pite->Config.RobustnessVariable = NewRobustnessVariable;
                    pite->Config.GenQueryInterval = NewGenQueryInterval;
                        
                    pite->Config.OtherQuerierPresentInterval
                        = NewRobustnessVariable*NewGenQueryInterval
                            + (pite->Config.GenQueryMaxResponseTime)/2;
                        
                    pite->Config.GroupMembershipTimeout = NewRobustnessVariable*NewGenQueryInterval
                                            + pite->Config.GenQueryMaxResponseTime;

                    Trace3(CONFIG,
                        "Querier->NonQuerier: Robustness:%d GenQueryInterval:%d "
                        "GroupMembershipTimeout:%d. ",
                        NewRobustnessVariable, NewGenQueryInterval/1000,
                        pite->Config.GroupMembershipTimeout/1000
                        );
                }
            }        


            //
            // set other querier present timer, and remove querier timer if not
            // in startup query Mode
            //
            
            ACQUIRE_TIMER_LOCK("_ChangeQuerierState");
            
            #if DEBUG_TIMER_TIMERID
                SET_TIMER_ID(&pite->NonQueryTimer, 210, pite->IfIndex, 0, 0);
            #endif 
            if (!IS_TIMER_ACTIVE(pite->NonQueryTimer)) {
                InsertTimer(&pite->NonQueryTimer, 
                    pite->Config.OtherQuerierPresentInterval, TRUE, DBG_Y);
            }

            if (IS_TIMER_ACTIVE(pite->QueryTimer) && 
                    (pite->Info.StartupQueryCountCurrent<=0) )
            {
                RemoveTimer(&pite->QueryTimer, DBG_Y);
            }

            pite->Info.QuerierPresentTimeout = llCurTime
                  + CONFIG_TO_SYSTEM_TIME(pite->Config.OtherQuerierPresentInterval);


            RELEASE_TIMER_LOCK("_ChangeQuerierState");
        }


    } END_BREAKOUT_BLOCK1;

    
    RELEASE_IF_LOCK_EXCLUSIVE(IfIndex, "_ChangeQuerierState");

    
    Trace0(LEAVE1, "leaving _ChangeQuerierState\n");
    LeaveIgmpWorker();
    return;
    
}//end _ChangeQuerierState

//------------------------------------------------------------------------------
//            _WF_TimerProcessing
//------------------------------------------------------------------------------
VOID
WF_TimerProcessing (
    PVOID    pvContext
    )
{
    DWORD                   IfIndex;
    PWORK_CONTEXT           pWorkContext = (PWORK_CONTEXT)pvContext;
    PIF_TABLE_ENTRY         pite;
    DWORD                   Error = NO_ERROR;
    DWORD                   Group = pWorkContext->Group;
    BOOL                    bCreate;
    PRAS_TABLE              prt;
    PRAS_TABLE_ENTRY        prte;
    PGROUP_TABLE_ENTRY      pge;
    PGI_ENTRY               pgie;   //group interface entry

    enum {
        NO_LOCK=0x0,
        IF_LOCK=0x1,
        RAS_LOCK=0x2,
        GROUP_LOCK=0x4,
        TIMER_LOCK=0x8
    } ExitLockRelease;

    ExitLockRelease = NO_LOCK;

    //todo: remove the read lock get/release

    //used only for DELETE_MEMBERSHIP
    #define RETURN_FROM_TIMER_PROCESSING() {\
        IGMP_FREE(pvContext); \
        if (ExitLockRelease&IF_LOCK) \
            RELEASE_IF_LOCK_SHARED(IfIndex, "_WF_TimerProcessing"); \
        if (ExitLockRelease&GROUP_LOCK) \
            RELEASE_GROUP_LOCK(Group, "_WF_TimerProcessing"); \
        if (ExitLockRelease&TIMER_LOCK) \
            RELEASE_TIMER_LOCK("_WF_TimerProcessing"); \
        Trace0(LEAVE1, "Leaving _WF_TimerProcessing()\n");\
        LeaveIgmpWorker();\
        return;\
    }



    if (!EnterIgmpWorker()) { return; }
    Trace0(ENTER1, "Entering _WF_TimerProcessing");
    

    // take shared interface lock
    IfIndex = pWorkContext->IfIndex;
    
    
    ACQUIRE_IF_LOCK_SHARED(IfIndex, "_WF_TimerProcessing");
    ExitLockRelease |= IF_LOCK;

    
    BEGIN_BREAKOUT_BLOCK1 {
        //
        // retrieve the interface
        //
        pite = GetIfByIndex(IfIndex);
        if (pite == NULL) {
            Trace1(IF, "_WF_TimerProcessing: interface %d not found", IfIndex);
            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }


        //
        // exit quitely if the interface is not activated
        //
        if ( !(IS_IF_ACTIVATED(pite)) ) {
            Trace1(ERR, "Trying to send packet on inactive interface(%d)",
                    pite->IfIndex);

            Error = ERROR_CAN_NOT_COMPLETE;
            GOTO_END_BLOCK1;
        }


        switch (pWorkContext->WorkType) {

        //-----------------------------------------
        // GENERAL QUERY
        //-----------------------------------------
        
        case MSG_GEN_QUERY:
        {
            Trace2(TIMER, 
                "Timer fired leads to  General-query being sent on If(%0x)"
                "Group(%d.%d.%d.%d)",
                pite->IfIndex, PRINT_IPADDR(pWorkContext->Group));
            SEND_GEN_QUERY(pite);
            break;
        }

        //-----------------------------------------
        // GROUP SPECIFIC QUERY
        //-----------------------------------------
        
        case MSG_GROUP_QUERY_V2 :
        {
            Trace2(TIMER, 
                "Timer fired leads to group query being sent on If(%0x)"
                "Group(%d.%d.%d.%d)",
                pite->IfIndex, PRINT_IPADDR(pWorkContext->Group)
                );

            SEND_GROUP_QUERY_V2(pite, pWorkContext->Group);

            break;
        }


        //
        // MEMBERSHIP TIMED OUT
        //
        case DELETE_MEMBERSHIP:
        {
            //
            // Lock the group table bucket
            //
            ACQUIRE_GROUP_LOCK(Group, "_WF_TimerProcessing");
            ExitLockRelease |= GROUP_LOCK;


            //
            // find the group entry. If entry not found then ignore the timer
            //
            pge = GetGroupFromGroupTable(Group, NULL, 0); //llCurTime not req
            if (pge==NULL) {
                RETURN_FROM_TIMER_PROCESSING();
            }
            
            //
            // find the GI entry. If GI entry does not exist or has deletedFlag
            // or is static group, then ignore the timer
            //
            pgie = GetGIFromGIList(pge, pite, pWorkContext->NHAddr, FALSE, NULL, 0);
            if ( (pgie==NULL)||(pgie->bStaticGroup) ) {

                RETURN_FROM_TIMER_PROCESSING();
            }

            // gi entry might be deleted here
            if (pgie->Version==3 && pgie->FilterType==EXCLUSION) {

                if (pgie->bStaticGroup) {
            
                    PLIST_ENTRY pHead, ple;
                    
                    //
                    // remove all sources in exclusion list
                    //
                    pHead = &pgie->V3ExclusionList;
                    
                    for (ple=pHead->Flink;  ple!=pHead;  ) {

                        PGI_SOURCE_ENTRY pSourceEntry;
                        pSourceEntry = CONTAINING_RECORD(ple, GI_SOURCE_ENTRY, 
                                            LinkSources);
                        ple = ple->Flink;

                        // dont have to call mgm as it will remain in -ve mfe
                        if (!pSourceEntry->bStaticSource) {
                            RemoveEntryList(&pSourceEntry->LinkSources);
                            IGMP_FREE(pSourceEntry);
                        }
                    }
                    
                    break;
                }
                
                Trace2(TIMER, 
                    "Timer fired leads to group filter mode change If(%0x) "
                    "Group(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group)
                    );

                ChangeGroupFilterMode(pgie, INCLUSION);
            }
            else if (pgie->Version!=3) {
                if (pgie->bStaticGroup)
                    break;
                    
                Trace2(TIMER, 
                    "Timer fired leads to membership being timed out If(%0x) "
                    "Group(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group)
                    );
                
            
                //
                // finally delete the entry
                //
                Error = DeleteGIEntry(pgie, TRUE, TRUE); //updateStats, CallMgm
            }
            
            break;
            
        } //end case:DELETE_MEMBERSHIP

        //
        // SOURCE TIMED OUT
        //
        case DELETE_SOURCE:
        case MSG_SOURCES_QUERY:
        case MSG_GROUP_QUERY_V3:
        case SHIFT_TO_V3:
        case MOVE_SOURCE_TO_EXCL:
        {
            PGI_SOURCE_ENTRY    pSourceEntry;

            if ((pWorkContext->WorkType)==DELETE_SOURCE){
                Trace3(TIMER,
                    "Timer fired leads to membership being timed out If(%0x) "
                    "Group(%d.%d.%d.%d) Source(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group),
                    PRINT_IPADDR(pWorkContext->Source)
                    );
            }
            else if ((pWorkContext->WorkType)==MSG_SOURCES_QUERY){
                Trace2(TIMER,
                    "Timer fired leads to sources specific msg being sent If(%0x) "
                    "Group(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group));

            }
            else if ((pWorkContext->WorkType)==MSG_GROUP_QUERY_V3){
                Trace2(TIMER,
                    "Timer fired leads to group query being sent on If(%0x) "
                    "Group(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group)
                    );
            }
            else if ((pWorkContext->WorkType)==SHIFT_TO_V3){
                Trace2(TIMER,
                    "Timer fired leads to group shifting to v3 mode If(%0x) "
                    "Group(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group)
                    );
            }
            else if (pWorkContext->WorkType==MOVE_SOURCE_TO_EXCL){
                Trace3(TIMER,
                    "Timer fired leads to source shifting to exclList If(%0x) "
                    "Group(%d.%d.%d.%d) Source(%d.%d.%d.%d)",
                    pite->IfIndex, PRINT_IPADDR(pWorkContext->Group),
                    PRINT_IPADDR(pWorkContext->Source)
                    );
            }
            
            //
            // Lock the group table bucket
            //
            ACQUIRE_GROUP_LOCK(Group, "_WF_TimerProcessing");
            ExitLockRelease |= GROUP_LOCK;


            //
            // find the group entry. If entry not found then ignore the timer
            //
            pge = GetGroupFromGroupTable(Group, NULL, 0); //llCurTime not req
            if (pge==NULL) {
                RETURN_FROM_TIMER_PROCESSING();
            }
            
            //
            // find the GI entry. If GI entry does not exist or has deletedFlag
            // or is static group, then ignore the timer
            //
            pgie = GetGIFromGIList(pge, pite, pWorkContext->NHAddr, FALSE, NULL, 0);
            if ( (pgie==NULL)||(pgie->bStaticGroup) ) {

                RETURN_FROM_TIMER_PROCESSING();
            }


            ACQUIRE_TIMER_LOCK("_WF_Timer_Processing");
            ExitLockRelease |= TIMER_LOCK;

            //
            // if changeSourceMode to excl, but filtertype is not excl
            // then delete the source
            //
            
            if ( (pWorkContext->WorkType==MOVE_SOURCE_TO_EXCL)
                && (pgie->FilterType != EXCLUSION)
                ) {
                pWorkContext->WorkType = DELETE_SOURCE;
                Trace2(TIMER, "DeleteSource instead of moving to excl "
                    "Group(%d.%d.%d.%d) Source(%d.%d.%d.%d)",
                    PRINT_IPADDR(pWorkContext->Group),
                    PRINT_IPADDR(pWorkContext->Source)
                    );
            }
            
            if ((pWorkContext->WorkType)==DELETE_SOURCE){
            
                //
                // get the source entry from inclusion list
                //
                pSourceEntry = GetSourceEntry(pgie, pWorkContext->Source, 
                                    INCLUSION, NULL, 0, 0);
                if (pSourceEntry==NULL) {
                    Trace1(TIMER, "Source %d.%d.%d.%d not found",
                        PRINT_IPADDR(pWorkContext->Source));
                    RETURN_FROM_TIMER_PROCESSING();
                }

                if (!pSourceEntry->bStaticSource) {
                    DeleteSourceEntry(pSourceEntry, TRUE); //process mgm

                    if (pgie->NumSources==0) {
                        DeleteGIEntry(pgie, TRUE, TRUE);
                    }
                }
            }
            else if ((pWorkContext->WorkType)==MSG_SOURCES_QUERY) {
                SEND_SOURCES_QUERY(pgie);
            }
            else if ((pWorkContext->WorkType)==MSG_GROUP_QUERY_V3) {
                SendV3GroupQuery(pgie);
            }
            else if ((pWorkContext->WorkType)==SHIFT_TO_V3) {

                // make sure that version has not changed
                
                if (pgie->Version != 3 && IS_IF_VER3(pite)) {
                
                    // shift to v3 exclusion mode
                    // membership timer already running
                    pgie->Version = 3;
                    pgie->FilterType = EXCLUSION;
                    // dont have to join to mgm as already joined in v1,v2
                }
            }
            else if (pWorkContext->WorkType==MOVE_SOURCE_TO_EXCL) {
        
                pSourceEntry = GetSourceEntry(pgie, pWorkContext->Source, 
                                    INCLUSION, NULL, 0, 0);
                if (pSourceEntry==NULL) {
                    Trace1(TIMER, "Source %d.%d.%d.%d not found",
                        PRINT_IPADDR(pWorkContext->Source));
                    RETURN_FROM_TIMER_PROCESSING();
                }
                if (pSourceEntry->bInclusionList==TRUE) {
                    if (pSourceEntry==NULL)
                        RETURN_FROM_TIMER_PROCESSING();
                        
                    ChangeSourceFilterMode(pgie, pSourceEntry);
                }
            }
            
            break;
            
        } //end case:DELETE_SOURCE,MSG_SOURCES_QUERY
        
        } //end switch There should not be any code between here and 
          //endBreakout block
            
    } END_BREAKOUT_BLOCK1;


    RETURN_FROM_TIMER_PROCESSING();

    return;

} //end _WF_TimerProcessing


//------------------------------------------------------------------------------
//          DeleteRasClient
//
// Takes the if_group list lock and deletes all the GI entries associated with 
// the ras client. 
// Then takes write lock on the ras table and decrements the refCount. The 
// ras table and interface entries are deleted if the deleted flag is set on pite.
// also releases the ras client from MGM.
//
// Queued by:
//      DisconnectRasClient(), DeActivateInterfaceComplete() for ras server
// Locks:
//      Initially runs in IF_GROUP_LIST_LOCK
//      then runs in exclusive ras table lock.
//      assumes if exclusive lock
// May call: _CompleteIfDeletion()
//------------------------------------------------------------------------------

VOID
DeleteRasClient (
    PRAS_TABLE_ENTRY   prte
    )
{
    PLIST_ENTRY                 pHead, ple;
    PGI_ENTRY                   pgie;
    PIF_TABLE_ENTRY             pite = prte->IfTableEntry;
    PRAS_TABLE                  prt = prte->IfTableEntry->pRasTable;
    DWORD                       Error = NO_ERROR, IfIndex=pite->IfIndex;


    //
    // take exclusive lock on the If_Group List and remove all timers
    //

    ACQUIRE_IF_GROUP_LIST_LOCK(IfIndex, "_WF_DeleteRasClient");

    //
    // Remove all timers associtated with that ras client's GI list
    //
    ACQUIRE_TIMER_LOCK("_WF_DeleteRasClient");

    pHead = &prte->ListOfSameClientGroups;
    DeleteAllTimers(pHead, RAS_CLIENT);

    RELEASE_TIMER_LOCK("_WF_DeleteRasClient");


    RELEASE_IF_GROUP_LIST_LOCK(IfIndex, "_WF_DeleteRasClient");



    //
    // revisit the list and delete all GI entries. Need to take
    // exclusive lock on the group bucket before deleting the GI entry
    // No need to lock the If-Group list as no one can access it anymore
    //
    for (ple=pHead->Flink;  ple!=pHead;  ) {

        DWORD   dwGroup;


        pgie = CONTAINING_RECORD(ple, GI_ENTRY, LinkBySameClientGroups);
        ple=ple->Flink;

        dwGroup = pgie->pGroupTableEntry->Group;


        ACQUIRE_GROUP_LOCK(dwGroup, "_WF_DeleteRasClient");
        
        DeleteGIEntryFromIf(pgie); 
        
        RELEASE_GROUP_LOCK(dwGroup, "_WF_DeleteRasClient");

    }
    
    //
    // Take exclusive lock on the interface. If deleted flag set on interface 
    // and refcount==0 then delete the ras table and pite, else just decrement 
    // the refcount
    //


    // decrement Refcount
    
    prt->RefCount --;



    //
    // if deleted flag set and Refcount ==0 then delete Ras server completely
    //
    if ( (pite->Status&IF_DELETED_FLAG) &&(prt->RefCount==0) ){

        CompleteIfDeletion(pite);
    }

    
    IGMP_FREE(prte);


    return;
    
} //end _WF_DeleteRasClient





//------------------------------------------------------------------------------
//          _WF_CompleteIfDeactivateDelete
//
// Completes deactivation an activated interface.
//
// Locking:
//      does not require any lock on IfTable, as it is already removed from 
//      global interface lists.
//      takes lock on Sockets list, as socket is getting deactivated
// Calls:    
//      DeActivateInterfaceComplete(). That function will also call 
//      _CompleteIfDeletion if the delete flag is set.
// Called by:
//      _DeleteIfEntry() after it has called _DeActivationDeregisterFromMgm
//      _UnbindIfEntry() after it has called _DeActivateInterfaceInitial
//      _DisableIfEntry() after it has called _DeActivateInterfaceInitial
//------------------------------------------------------------------------------
VOID
CompleteIfDeactivateDelete (
    PIF_TABLE_ENTRY     pite
    )
{
    DWORD   IfIndex = pite->IfIndex;
    
    Trace1(ENTER1, "Entering _WF_CompleteIfDeactivateDelete(%d)", IfIndex);


    ACQUIRE_SOCKETS_LOCK_EXCLUSIVE("_WF_CompleteIfDeactivateDelete");

    DeActivateInterfaceComplete(pite);   

    RELEASE_SOCKETS_LOCK_EXCLUSIVE("_WF_CompleteIfDeactivateDelete");



    // dont have to call _CompleteIfDeletion as it will be called in
    // DeactivateInterface() as the delete flag is set.


    Trace1(LEAVE1, "Leaving _WF_CompleteIfDeactivateDelete(%d)", IfIndex);

    return;
    
} //end _WF_CompleteIfDeactivateDelete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\work.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: work.h
//
// Abstract:
//      Contains declarations and function prototypes related to work.c.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================


#ifndef _WORK_H_
#define _WORK_H_



//
// WORK_CONTEXT
//
typedef struct _WORK_CONTEXT {

    DWORD            IfIndex;
    DWORD            NHAddr;
    DWORD            Group;
    DWORD            Source; //v3
    
    // MSG_GEN_QUERY, MSG_GROUP_QUERY_V2(_V3), DELETE_MEMBERSHIP, DELETE_SOURCE
    // PROXY_PRUNE, PROXY_JOIN
    DWORD            WorkType;

} WORK_CONTEXT, *PWORK_CONTEXT;

#define CREATE_WORK_CONTEXT(ptr, Error) {\
    ptr = IGMP_ALLOC(sizeof(WORK_CONTEXT), 0x800100,0xaaaa);\
    if (ptr==NULL) {    \
        Error = ERROR_NOT_ENOUGH_MEMORY;    \
        Trace2(ANY, "Error %d allocating %d bytes for Work context", \
                Error, sizeof(WORK_CONTEXT)); \
    } \
}


//
// Used by work item to change the querier state
//
typedef struct _QUERIER_CONTEXT {

    DWORD           IfIndex;
    DWORD           QuerierIpAddr;
    DWORD           NewRobustnessVariable;
    DWORD           NewGenQueryInterval;
    
} QUERIER_CONTEXT, *PQUERIER_CONTEXT;




VOID
DeleteRasClient (
    PRAS_TABLE_ENTRY   prte
    );

VOID
WF_CompleteIfDeletion (
    PIF_TABLE_ENTRY     pite
    );

    

VOID
WT_ProcessInputEvent(
    PVOID   pContext, //NULL
    BOOLEAN NotUsed
    );

DWORD
ActivateInterface (
    PIF_TABLE_ENTRY pite
    );
    

    
DWORD
T_LastMemQueryTimer (
    PVOID   pvContext
    );

DWORD
T_MembershipTimer (
    PVOID   pvContext
    );

DWORD
T_LastVer1ReportTimer (
    PVOID    pvContext
    );
    
DWORD
T_RouterV1Timer (
    PVOID    pvContext
    );
    
//
// LOCAL PROTOTYPES
//

VOID
WF_ProcessInputEvent (
    PVOID pContext 
    );
    
VOID
ProcessInputOnInterface(
    PIF_TABLE_ENTRY pite
    );
    
        
DWORD
ProcessAddInterface(
    IN DWORD                IfIndex,
    IN NET_INTERFACE_TYPE   dwIfType,
    IN PVOID                pvConfig
    );

VOID
WF_TimerProcessing (
    PVOID    pvContext
    );
    
VOID
CompleteIfDeactivateDelete (
    PIF_TABLE_ENTRY     pite
    );
    

VOID
DeActivateInterfaceComplete (
    PIF_TABLE_ENTRY     pite
    );

DWORD
T_QueryTimer (
    PVOID    pvContext
    );

DWORD
T_NonQueryTimer (
    PVOID    pvContext
    );

VOID 
WF_ProcessPacket (
    PVOID        pvContext
    );

VOID 
ProcessPacket (
    PIF_TABLE_ENTRY     pite,
    DWORD               InputSrcAddr,
    DWORD               DstnMcastAddr,
    DWORD               NumBytes,
    PBYTE               pPacketData,    // igmp packet hdr. data following it ignored
    BOOL                bRtrAlertSet
    );

VOID
WF_BecomeQuerier(
    PVOID   pvIfIndex
    );

VOID
WF_BecomeNonQuerier(
    PVOID   pvIfIndex
    );    

DWORD
WF_FinishStopProtocol(
    PVOID pContext
    );
    
VOID
ChangeQuerierState(
    DWORD   IfIndex,
    DWORD   Flag,
    DWORD   QuerierIpAddr,
    DWORD   NewRobustnessVariable, //only for v3:querier->non-querier
    DWORD   NewGenQueryInterval //only for v3:querier->non-querier
    );    

#endif //_WORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\defs.h ===
#ifndef _IGMPAGNT_DEFS_H_
#define _IGMPAGNT_DEFS_H_

//------------------------------------------------------------------------------
// Global config default values
//------------------------------------------------------------------------------

#define IGMP_DEF_LOGGING_LEVEL          IGMP_LOGGING_ERROR
#define IGMP_DEF_RAS_CLIENT_STATS       FALSE

#define     IP_ADDRESS_LEN  4


//------------------------------------------------------------------------------
// Interface config default values
//------------------------------------------------------------------------------



//------------------------------------------------------------------------------
//  Memory allocation/deallocation macros
//------------------------------------------------------------------------------

#define IGMP_MIB_ALLOC(size)            HeapAlloc(GetProcessHeap(), 0, (size))
#define IGMP_MIB_FREE(ptr)              HeapFree(GetProcessHeap(), 0, (ptr))



//------------------------------------------------------------------------------
//  Macros to simplify use of DIM MIB functions
//------------------------------------------------------------------------------

#define CONNECT_TO_ROUTER(retval) \
    retval = (g_hMibServer) ? NO_ERROR : ConnectToRouter()



#define MIB_GET(type, pQuery, szQuery, ppResponse, pdwOutSize, dwErr)  {\
    CONNECT_TO_ROUTER(dwErr);               \
                                            \
    if ((dwErr) == NO_ERROR) {              \
        (dwErr) = MprAdminMIBEntry ## type( \
                        g_hMibServer,       \
                        PID_IP,             \
                        MS_IP_IGMP,         \
                        (LPVOID) (pQuery),  \
                        (szQuery),          \
                        (LPVOID *) (ppResponse),     \
                        (pdwOutSize)        \
                    );                      \
    }                                       \
}



#define IGMP_MIB_SET(x, y, retval) {        \
    CONNECT_TO_ROUTER(retval);              \
                                            \
    if ((retval)==NO_ERROR) {               \
        (retval) = MprAdminMIBEntrySet (    \
                        g_hMibServer,       \
                        PID_IP,             \
                        MS_IP_IGMP,         \
                        (LPVOID)(x),        \
                        (y)                 \
                        );                  \
    }                                       \
}

#define IGMP_MIB_GET(pQuery, szQuery, ppResponse, pdwOutSize, dwErr)    \
{                                                                       \
    MIB_GET(Get, pQuery, szQuery, ppResponse, pdwOutSize, dwErr)        \
                                                                        \
    if ( ( (dwErr) == RPC_S_SERVER_UNAVAILABLE ) ||                     \
         ( (dwErr) == RPC_S_UNKNOWN_IF )         ||                     \
         ( (dwErr) == ERROR_CAN_NOT_COMPLETE ) )                        \
    {                                                                   \
        TraceError( (dwErr) );                                          \
        (dwErr) = MIB_S_NO_MORE_ENTRIES;                                \
    }                                                                   \
}


#define IGMP_MIB_GETFIRST(pQuery, szQuery, ppResponse, pdwOutSize, dwErr)\
{                                                                       \
    MIB_GET(GetFirst, pQuery, szQuery, ppResponse, pdwOutSize, dwErr)   \
                                                                        \
    if ( ( (dwErr) == RPC_S_SERVER_UNAVAILABLE ) ||                     \
         ( (dwErr) == RPC_S_UNKNOWN_IF )         ||                     \
         ( (dwErr) == ERROR_CAN_NOT_COMPLETE ) )                        \
    {                                                                   \
        TraceError( (dwErr) );                                          \
        (dwErr) = MIB_S_NO_MORE_ENTRIES;                                \
    }                                                                   \
}


#define IGMP_MIB_GETNEXT(pQuery, szQuery, ppResponse, pdwOutSize, dwErr)\
{                                                                       \
    MIB_GET(GetNext, pQuery, szQuery, ppResponse, pdwOutSize, dwErr)    \
                                                                        \
    if ( ( (dwErr) == RPC_S_SERVER_UNAVAILABLE ) ||                     \
         ( (dwErr) == RPC_S_UNKNOWN_IF )         ||                     \
         ( (dwErr) == ERROR_CAN_NOT_COMPLETE ) )                        \
    {                                                                   \
        TraceError( (dwErr) );                                          \
        (dwErr) = MIB_S_NO_MORE_ENTRIES;                                \
    }                                                                   \
}
    
//------------------------------------------------------------------------------
//  Macros to convert between Asn and Win32 data types
//------------------------------------------------------------------------------

#define SET_ASN_INTEGER(dstBuf, val) {                  \
    if ((dstBuf)->asnType) {                            \
        ASSERT((dstBuf)->asnType==ASN_INTEGER);         \
        (dstBuf)->asnValue.number = (AsnInteger)(val);  \
    }                                                   \
}

#define FORCE_SET_ASN_INTEGER(dstBuf, val) {            \
    (dstBuf)->asnType = ASN_INTEGER;                    \
    (dstBuf)->asnValue.number = (AsnInteger)(val);      \
}

#define SET_ASN_COUNTER(dstBuf, val) {                  \
    if ((dstBuf)->asnType) {                            \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER); \
        (dstBuf)->asnValue.counter = (AsnCounter)(val); \
    }                                                   \
}


#define SET_ASN_GAUGE(dstBuf, val) {                    \
    if ((dstBuf)->asnType) {                            \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_GAUGE);   \
        (dstBuf)->asnValue.gauge = (AsnGauge)(val);     \
    }                                                   \
}


#define SET_ASN_TIME_TICKS(dstBuf, val) {               \
    if ((dstBuf)->asnType) {                            \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_TIMETICKS); \
        (dstBuf)->asnValue.ticks = (AsnTimeticks)(val); \
    }                                                   \
}


#define SET_ASN_OCTET_STRING(dstBuf, buffer, src, len) {\
    if ((dstBuf)->asnType) {                            \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);     \
        (dstBuf)->asnValue.string.length = len;         \
        (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
        (dstBuf)->asnValue.string.dynamic = FALSE;      \
    }                                                   \
}
        
#define SET_ASN_IP_ADDR(dstBuf, val) {                          \
    if ((dstBuf)->asnType)                                      \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if( (dstBuf)->asnValue.address.stream)                  \
        {                                                       \
            (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;\
        }                                                       \
    }                                                           \
}

#define SET_ASN_IP_ADDRESS(dstBuf,buffer,val){                  \
    if ((dstBuf)->asnType)                                      \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if(!(dstBuf)->asnValue.address.stream)                  \
        {                                                       \
           (dstBuf)->asnValue.address.stream = (PBYTE)buffer;   \
           (dstBuf)->asnValue.address.dynamic = FALSE;          \
        }                                                       \
        (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;   \
    }                                                           \
}

#define FORCE_SET_ASN_IP_ADDRESS(dstBuf,buffer,val){            \
    (dstBuf)->asnType = ASN_RFC1155_IPADDRESS;                  \
    (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;         \
    if(!((dstBuf)->asnValue.address.stream))                    \
    {                                                           \
       (dstBuf)->asnValue.address.stream = (PBYTE)buffer;       \
       (dstBuf)->asnValue.address.dynamic = FALSE;              \
    }                                                           \
    (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;       \
}



#define FORCE_ASN_USHORT(dstBuf,buffer,val){               \
    if ((dstBuf)->asnType)			                       \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);        \
        (dstBuf)->asnValue.string.length = 2;              \
        (buffer)[0] = (BYTE)(val&0xFF);                    \
        (buffer)[1] = (BYTE)((val>>8)&0xFF);               \
        (dstBuf)->asnValue.string.stream = (BYTE *)buffer; \
        (dstBuf)->asnValue.string.dynamic = FALSE;         \
    }                                                      \
}

#define SetAsnDispString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)			                       \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_RFC1213_DISPSTRING); \
        (dstBuf)->asnValue.string.length = strlen(src);    \
        if ((dstBuf)->asnValue.string.length>len)          \
        {                                                  \
            (dstBuf)->asnValue.string.length = len;        \
            (dstBuf)->asnValue.string.stream = (BYTE *)strncpy (buffer,src,\
                                                            (dstBuf)->asnValue.string.length);\
            (dstBuf)->asnValue.string.dynamic = FALSE;     \
        }                                                  \
    }                                                      \
}


#define SetToZeroOid(dstBuf,buffer){                       \
    if ((dstBuf)->asnType)			                       \
    {                                                      \
        ASSERT((dstBuf)->asnType==ASN_OBJECTIDENTIFIER);   \
        (dstBuf)->asnValue.object.idLength = NULL_OID_LEN; \
        (dstBuf)->asnValue.object.ids = buffer;            \
        (dstBuf)->asnValue.object.ids[0]   = 0;            \
        (dstBuf)->asnValue.object.ids[1]   = 0;            \
    }                                                      \
}

#define GET_ASN_INTEGER(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.number):(defVal))

#define GetAsnCounter(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.counter):(defVal))

#define GetAsnTimeTicks(srcBuf, defval) \
    ( ( (srcBuf)-> asnType ) ? (srcBuf)-> asnValue.ticks : (defval) )

#define GetAsnOctetString(dst,srcBuf)                                                   \
    (((srcBuf)->asnType)?		                                                        \
     (memcpy(dst,(srcBuf)->asnValue.string.stream,(srcBuf)->asnValue.string.length))    \
     :NULL)	

#define GET_ASN_IP_ADDRESS(srcBuf,defVal)                                  \
    (DWORD)(((srcBuf)->asnType && (srcBuf)->asnValue.string.length)?    \
            (*(DWORD*)((srcBuf)->asnValue.address.stream)) : (defVal))	

                
#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))
#define IsAsnIPAddressTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.address.length))



//------------------------------------------------------------------------------
// IP address comparison macros
//------------------------------------------------------------------------------

//
// LONG
// Cmp(DWORD dwFirst, DWORD dwSecond, LONG lResult)
//

#define Cmp(dwFirst,dwSecond,lResult) ((LONG)((lResult) = ((dwFirst) - (dwSecond))))


// The addresses are in Network order

//
// LONG
// InetCmp(DWORD IpAddr1, DWORD IpAddr2, LONG lResult)
//

#define InetCmp(dwIpAddr1,dwIpAddr2,res)                                                    \
    ((LONG)(((res) = (((dwIpAddr1) & 0x000000ff) - ((dwIpAddr2) & 0x000000ff))) ? (res)   : \
            (((res) = (((dwIpAddr1) & 0x0000ff00) - ((dwIpAddr2) & 0x0000ff00))) ? (res)  : \
             (((res) = (((dwIpAddr1) & 0x00ff0000) - ((dwIpAddr2) & 0x00ff0000))) ? (res) : \
              (((dwIpAddr1) & 0xff000000) - ((dwIpAddr2) & 0xff000000))))))                  




//------------------------------------------------------------------------------
// breakout from block macros
//------------------------------------------------------------------------------

#define BEGIN_BREAKOUT_BLOCK    do
#define END_BREAKOUT_BLOCK      while(FALSE)



//------------------------------------------------------------------------------
// Debug tracing macros
//------------------------------------------------------------------------------

#if DBG
#define TRACE0(Z)             TracePrintf(g_dwTraceId,Z)
#define TRACE1(Y,Z)           TracePrintf(g_dwTraceId,Y,Z)
#define TRACE2(X,Y,Z)         TracePrintf(g_dwTraceId,X,Y,Z)
#define TRACE3(W,X,Y,Z)       TracePrintf(g_dwTraceId,W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)     TracePrintf(g_dwTraceId,V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)   TracePrintf(g_dwTraceId,U,W,X,Y,Z)

#define TRACEW0(Z)            TracePrintfW(g_dwTraceId,Z)

#define TraceEnter(X)         TracePrintf(g_dwTraceId,"Entering " X)
#define TraceLeave(X)         TracePrintf(g_dwTraceId,"Leaving " X "\n")

#define TraceError(X) \
    TracePrintf( g_dwTraceId, "MprAdminMIB API returned : %d", (X) ); 

#define TraceError1(x)                              \
{                                                   \
    LPWSTR  __lpwszErr = NULL;                      \
                                                    \
    TRACE1( "MprAdminMIB API returned : %d", (x) ); \
    MprAdminGetErrorString( (x), &__lpwszErr );     \
                                                    \
    if ( __lpwszErr )                               \
    {                                               \
        TRACEW0( __lpwszErr );                      \
        LocalFree( __lpwszErr );                    \
    }                                               \
}                                               

#else
#define TRACE0(Z)
#define TRACE1(Y,Z)  
#define TRACE2(X,Y,Z)
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#define TRACEW0(Z)            
#define TraceEnter(X) 
#define TraceLeave(X)
#define TraceError(x)
#endif


#define EnterReader(X)
#define ReleaseLock(X)
#define ReaderToWriter(X)
#define EnterWriter(x)

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)
#endif //_IGMPAGNT_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\dllinit.c ===
/*++
Copyright (c) 1997 Microsoft Corporation

Module Name:
    load.c

Abstract:
    This module implements 

Author:
    K.S.Lokesh
    lokeshs@microsoft.com   
    
Revision History:
    Created 2-15-97
--*/


#include "precomp.h"
#pragma hdrstop


//------------------------------------------------------------------------------
// DEFINE GLOBAL VARIABLES
//------------------------------------------------------------------------------

MIB_SERVER_HANDLE   g_hMibServer = NULL;

//
// critical section to protect MibServerHandle
//
CRITICAL_SECTION    g_CS;

//
// handle to subagent framework
//
SnmpTfxHandle       g_tfxHandle = NULL;


//
// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  
//

DWORD g_uptimeReference = 0;


#if DBG
DWORD               g_dwTraceId = INVALID_TRACEID;
#endif


//--------------------------------------------------------------------------//
//          DllMain                                                         //
//--------------------------------------------------------------------------//
BOOL
WINAPI
DllMain (
    HINSTANCE   hModule,
    DWORD       dwReason,
    LPVOID      lpvReserved
    )
{
    switch (dwReason) {

        case DLL_PROCESS_ATTACH :
        {
            // no per thread initialization required for this dll
            
            DisableThreadLibraryCalls(hModule);

                        
            // initialize MibServerHandle CS

            InitializeCriticalSection(&g_CS);
            
            break;
        }

        case DLL_PROCESS_DETACH :
        {
            // disconnect from router
            
            if (g_hMibServer)
                MprAdminMIBServerDisconnect(g_hMibServer);


            // delete global critical section
            DeleteCriticalSection(&g_CS);

            
            // deregister MibTrace
            #if DBG
            if (g_dwTraceId!=INVALID_TRACEID)
                TraceDeregister(g_dwTraceId);
            #endif

            break;
        }

        default :
            break;

    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Subagent entry points                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{
    DWORD   dwErr;

    // register mib tracing
    #if DBG
    g_dwTraceId = TraceRegister("IGMPAgntMIB");
    #endif


    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    g_tfxHandle = SnmpTfxOpen(1,&v_igmp);

    // validate handle
    if (g_tfxHandle == NULL) {
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_igmp.viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;


    //
    // verify router service is running. if not running then
    // just return. 
    //
    if (!MprAdminIsServiceRunning(NULL)) {

        TRACE0("Router Service not running. "
                "IgmpAgent could not start");

        return TRUE;
    }

            
    //
    // connect to router. If failed, then connection can be
    // established later
    //
    dwErr = MprAdminMIBServerConnect(NULL, &g_hMibServer);

    if (dwErr!=NO_ERROR) {
        g_hMibServer = NULL;
        TRACE1("error:%d setting up IgmpAgent connection to MIB Server",
            dwErr);
        return FALSE;
    }

    return TRUE;    
}


BOOL
SnmpExtensionQuery(
    IN     BYTE                  requestType,
    IN OUT RFC1157VarBindList    *variableBindings,
    OUT    AsnInteger            *errorStatus,
    OUT    AsnInteger            *ErrorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(g_tfxHandle,
                        requestType,
                        variableBindings,
                        errorStatus,
                        ErrorIndex);
}


BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier   *enterprise,
    OUT AsnInteger            *genericTrap,
    OUT AsnInteger            *specificTrap,
    OUT AsnTimeticks          *timeStamp,
    OUT RFC1157VarBindList    *variableBindings
    )
{
    UNREFERENCED_PARAMETER(enterprise);
    UNREFERENCED_PARAMETER(genericTrap);
    UNREFERENCED_PARAMETER(specificTrap);
    UNREFERENCED_PARAMETER(timeStamp);
    UNREFERENCED_PARAMETER(variableBindings);

    // no traps
    return FALSE;
}


VOID
SnmpExtensionClose(
    )
{
    // release handle
    SnmpTfxClose(g_tfxHandle);

    // reinitialize
    g_tfxHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmp\work1.h ===
//=============================================================================
// Copyright (c) 1997 Microsoft Corporation
//
// File: work1.h
//
// Abstract:
//      Contains declarations and function prototypes related to work.c.
//
// Author: K.S.Lokesh (lokeshs@)   11-1-97
//
// Revision History:
//=============================================================================


#ifndef _WORK1_H_
#define _WORK1_H_

DWORD
ProcessGroupQuery(
    PIF_TABLE_ENTRY     pite,
    IGMP_HEADER UNALIGNED   *pHdr,
    DWORD               InPacketSize,
    DWORD               InputSrcAddr,
    DWORD               DstnMcastAddr
    );

DWORD
ProcessReport(
    PIF_TABLE_ENTRY     pite,
    IGMP_HEADER UNALIGNED   *pHdr,
    DWORD               InPacketSize,
    DWORD               InputSrcAddr,
    DWORD               DstnMcastAddr
    );

DWORD
ProcessV3Report(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord,
    BOOL *bUpdateGroupTimer
    );

VOID
SendV3GroupQuery(
    PGI_ENTRY pgie
    );


VOID
DeleteSourceEntry(
    PGI_SOURCE_ENTRY    pSourceEntry,
    BOOL bMgm
    );

PGI_SOURCE_ENTRY
GetSourceEntry(
    PGI_ENTRY pgie,
    IPADDR Source,
    DWORD Mode,
    BOOL *bCreate,
    DWORD Gmi,
    BOOL bMgm
    );
    

VOID
GIDeleteAllV3Sources(
    PGI_ENTRY pgie,
    BOOL bMgm
    );

DWORD
UpdateSourceExpTimer(
    PGI_SOURCE_ENTRY    pSourceEntry,
    DWORD               Gmi,
    BOOL                bRemoveLastMem
    );

DWORD
ChangeGroupFilterMode(
    PGI_ENTRY pgie,
    DWORD Mode
    );

VOID
ChangeSourceFilterMode(
    PGI_ENTRY pgie,
    PGI_SOURCE_ENTRY pSourceEntry
    );

VOID
InclusionSourcesUnion(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord
    );

VOID
SourcesSubtraction(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord,
    BOOL Mode
    );

DWORD
BuildAndSendSourcesQuery(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord,
    DWORD Mode
    );

VOID
InsertSourceInQueryList(
    PGI_SOURCE_ENTRY    pSourceEntry
    );

VOID
MoveFromExcludeToIncludeList(
    PGI_ENTRY pgie,
    PGROUP_RECORD pGroupRecord
    );

DWORD
T_V3SourcesQueryTimer (
    PVOID    pvContext
    );

DWORD
T_LastVer2ReportTimer (
    PVOID    pvContext
    );

DWORD
T_SourceExpTimer (
    PVOID    pvContext
    );

VOID
DebugPrintSourcesList(
    PGI_ENTRY pgie
    );
VOID
DebugPrintSourcesList1(
    PGI_ENTRY pgie
    );
   

#endif //_WORK1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\mibentry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.c

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#include <snmp.h>
#include <snmpexts.h>
#include "mibfuncs.h"
#include "mibentry.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// root oid                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_igmp[]                              = {1,3,6,1,3,59,1,1};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmp group (1,3,6,1,3,59,1,1)                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_igmpInterfaceTable[]                 = {1};
static UINT ids_igmpCacheTable[]                     = {2};



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmpInterfaceEntry table (1,3,6,1,3,59,1,1,1,1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_igmpInterfaceEntry[]                 = {1,1};
static UINT ids_igmpInterfaceIfIndex[]               = {1,1,1};
static UINT ids_igmpInterfaceQueryInterval[]         = {1,1,2};
static UINT ids_igmpInterfaceStatus[]                = {1,1,3};
static UINT ids_igmpInterfaceVersion[]               = {1,1,4};
static UINT ids_igmpInterfaceQuerier[]               = {1,1,5};
static UINT ids_igmpInterfaceQueryMaxResponseTime[]  = {1,1,6};
static UINT ids_igmpInterfaceVersion1QuerierTimer[]  = {1,1,9};
static UINT ids_igmpInterfaceWrongVersionQueries[]   = {1,1,10};
static UINT ids_igmpInterfaceJoins[]                 = {1,1,11};
static UINT ids_igmpInterfaceGroups[]                = {1,1,13};
static UINT ids_igmpInterfaceRobustness[]            = {1,1,14};
static UINT ids_igmpInterfaceLastMembQueryInterval[] = {1,1,15};
static UINT ids_igmpInterfaceProxyIfIndex[]          = {1,1,16};
static UINT ids_igmpInterfaceQuerierUpTime[]         = {1,1,17};
static UINT ids_igmpInterfaceQuerierExpiryTime[]     = {1,1,18};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmpCacheEntry table (1,3,6,1,3,59,1,1,2,1)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT ids_igmpCacheEntry[]                    = {2,1};
static UINT ids_igmpCacheAddress[]                  = {2,1,1};
static UINT ids_igmpCacheIfIndex[]                  = {2,1,2};
static UINT ids_igmpCacheSelf[]                     = {2,1,3};
static UINT ids_igmpCacheLastReporter[]             = {2,1,4};
static UINT ids_igmpCacheUpTime[]                   = {2,1,5};
static UINT ids_igmpCacheExpiryTime[]               = {2,1,6};
static UINT ids_igmpCacheStatus[]                   = {2,1,7};
static UINT ids_igmpCacheVersion1HostTimer[]        = {2,1,8};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_igmp[] = {
    MIB_TABLE_ROOT(igmpInterfaceTable),
        MIB_TABLE_ENTRY(igmpInterfaceEntry),
            MIB_INTEGER_NA(igmpInterfaceIfIndex),
            MIB_INTEGER_RW(igmpInterfaceQueryInterval),
            MIB_INTEGER_RW(igmpInterfaceStatus),
            MIB_INTEGER_RW(igmpInterfaceVersion),
            MIB_IPADDRESS(igmpInterfaceQuerier),
            MIB_INTEGER_RW(igmpInterfaceQueryMaxResponseTime),
            MIB_INTEGER(igmpInterfaceVersion1QuerierTimer),
            MIB_COUNTER(igmpInterfaceWrongVersionQueries),
            MIB_COUNTER(igmpInterfaceJoins),
            MIB_GAUGE(igmpInterfaceGroups),
            MIB_INTEGER_RW(igmpInterfaceRobustness),
            MIB_INTEGER_RW(igmpInterfaceLastMembQueryInterval),
            MIB_INTEGER_RW(igmpInterfaceProxyIfIndex),
            MIB_INTEGER(igmpInterfaceQuerierUpTime),
            MIB_INTEGER(igmpInterfaceQuerierExpiryTime),
    MIB_TABLE_ROOT(igmpCacheTable),
        MIB_TABLE_ENTRY(igmpCacheEntry),
            MIB_IPADDRESS_NA(igmpCacheAddress),
            MIB_INTEGER_NA(igmpCacheIfIndex),
            MIB_INTEGER_RW(igmpCacheSelf),
            MIB_IPADDRESS(igmpCacheLastReporter),
            MIB_TIMETICKS(igmpCacheUpTime),
            MIB_TIMETICKS(igmpCacheExpiryTime),
            MIB_INTEGER_RW(igmpCacheStatus),
            MIB_INTEGER(igmpCacheVersion1HostTimer),
    MIB_END()
};



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_igmp[] = {
    MIB_TABLE(igmp,igmpInterfaceEntry,NULL),
    MIB_TABLE(igmp,igmpCacheEntry,NULL)
};



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibView v_igmp = MIB_VIEW(igmp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\mibentry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibentry.h

Abstract:

    Sample subagent mib structures.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_igmpInterfaceTable                   0
#define mi_igmpInterfaceEntry                   mi_igmpInterfaceTable + 1
#define mi_igmpInterfaceIfIndex                 mi_igmpInterfaceEntry + 1
#define mi_igmpInterfaceQueryInterval           mi_igmpInterfaceIfIndex + 1
#define mi_igmpInterfaceStatus                  mi_igmpInterfaceQueryInterval + 1
#define mi_igmpInterfaceVersion                 mi_igmpInterfaceStatus + 1
#define mi_igmpInterfaceQuerier                 mi_igmpInterfaceVersion + 1
#define mi_igmpInterfaceQueryMaxResponseTime    mi_igmpInterfaceQuerier + 1
#define mi_igmpInterfaceVersion1QuerierTimer    mi_igmpInterfaceQueryMaxResponseTime + 1
#define mi_igmpInterfaceWrongVersionQueries     mi_igmpInterfaceVersion1QuerierTimer + 1
#define mi_igmpInterfaceJoins                   mi_igmpInterfaceWrongVersionQueries + 1
#define mi_igmpInterfaceGroups                  mi_igmpInterfaceJoins + 1
#define mi_igmpInterfaceRobustness              mi_igmpInterfaceGroups + 1
#define mi_igmpInterfaceLastMembQueryInterval   mi_igmpInterfaceRobustness + 1
#define mi_igmpInterfaceProxyIfIndex            mi_igmpInterfaceLastMembQueryInterval + 1
#define mi_igmpInterfaceQuerierUpTime           mi_igmpInterfaceProxyIfIndex + 1
#define mi_igmpInterfaceQuerierExpiryTime       mi_igmpInterfaceQuerierUpTime + 1

#define mi_igmpCacheTable                       mi_igmpInterfaceQuerierExpiryTime + 1
#define mi_igmpCacheEntry                       mi_igmpCacheTable + 1
#define mi_igmpCacheAddress                     mi_igmpCacheEntry + 1
#define mi_igmpCacheIfIndex                     mi_igmpCacheAddress + 1
#define mi_igmpCacheSelf                        mi_igmpCacheIfIndex + 1
#define mi_igmpCacheLastReporter                mi_igmpCacheSelf + 1
#define mi_igmpCacheUpTime                      mi_igmpCacheLastReporter + 1
#define mi_igmpCacheExpiryTime                  mi_igmpCacheUpTime + 1
#define mi_igmpCacheStatus                      mi_igmpCacheExpiryTime + 1
#define mi_igmpCacheVersion1HostTimer           mi_igmpCacheStatus + 1



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Declaration of table information                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define ne_igmpInterfaceEntry   15
#define ni_igmpInterfaceEntry   1

#define ne_igmpCacheEntry       8
#define ni_igmpCacheEntry       2



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Declaration of supported view                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern SnmpMibView v_igmp;

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\mibfuncs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.h

Abstract:

    Sample subagent instrumentation callbacks.

Note:

    This file is an example of the output to be produced from the 
    code generation utility.

--*/

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmpInterfaceEntry table (1,3,6,1,3,59,1,1,1,1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_igmpInterfaceEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    );

UINT
set_igmpInterfaceEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    );

typedef struct _buf_igmpInterfaceEntry {
    AsnAny igmpInterfaceIfIndex;
    AsnAny igmpInterfaceQueryInterval;
    AsnAny igmpInterfaceStatus;
    AsnAny igmpInterfaceVersion;
    AsnAny igmpInterfaceQuerier;
    AsnAny igmpInterfaceQueryMaxResponseTime;
    AsnAny igmpInterfaceVersion1QuerierTimer;
    AsnAny igmpInterfaceWrongVersionQueries;
    AsnAny igmpInterfaceJoins;
    AsnAny igmpInterfaceGroups;
    AsnAny igmpInterfaceRobustness;
    AsnAny igmpInterfaceLastMembQueryInterval;
    AsnAny igmpInterfaceProxyIfIndex;
    AsnAny igmpInterfaceQuerierUpTime;
    AsnAny igmpInterfaceQuerierExpiryTime;
    DWORD  igmpInterfaceQuerierBuf;
} buf_igmpInterfaceEntry;


typedef struct _sav_igmpInterfaceEntry {
    AsnAny igmpInterfaceIfIndex;
    AsnAny igmpInterfaceQueryInterval;
    AsnAny igmpInterfaceStatus;
    AsnAny igmpInterfaceVersion;
    AsnAny igmpInterfaceQueryMaxResponseTime;
    AsnAny igmpInterfaceRobustness;
    AsnAny igmpInterfaceLastMembQueryInterval;
    AsnAny igmpInterfaceProxyIfIndex;
} sav_igmpInterfaceEntry;


#define gf_igmpInterfaceIfIndex                 get_igmpInterfaceEntry
#define gf_igmpInterfaceQueryInterval           get_igmpInterfaceEntry
#define gf_igmpInterfaceStatus                  get_igmpInterfaceEntry
#define gf_igmpInterfaceVersion                 get_igmpInterfaceEntry
#define gf_igmpInterfaceQuerier                 get_igmpInterfaceEntry
#define gf_igmpInterfaceQueryMaxResponseTime    get_igmpInterfaceEntry
#define gf_igmpInterfaceVersion1QuerierTimer    get_igmpInterfaceEntry
#define gf_igmpInterfaceWrongVersionQueries     get_igmpInterfaceEntry
#define gf_igmpInterfaceJoins                   get_igmpInterfaceEntry
#define gf_igmpInterfaceGroups                  get_igmpInterfaceEntry
#define gf_igmpInterfaceRobustness              get_igmpInterfaceEntry
#define gf_igmpInterfaceLastMembQueryInterval   get_igmpInterfaceEntry
#define gf_igmpInterfaceProxyIfIndex            get_igmpInterfaceEntry
#define gf_igmpInterfaceQuerierUpTime           get_igmpInterfaceEntry
#define gf_igmpInterfaceQuerierExpiryTime       get_igmpInterfaceEntry

#define gb_igmpInterfaceIfIndex                 buf_igmpInterfaceEntry
#define gb_igmpInterfaceQueryInterval           buf_igmpInterfaceEntry
#define gb_igmpInterfaceStatus                  buf_igmpInterfaceEntry
#define gb_igmpInterfaceVersion                 buf_igmpInterfaceEntry
#define gb_igmpInterfaceQuerier                 buf_igmpInterfaceEntry
#define gb_igmpInterfaceQueryMaxResponseTime    buf_igmpInterfaceEntry
#define gb_igmpInterfaceVersion1QuerierTimer    buf_igmpInterfaceEntry
#define gb_igmpInterfaceWrongVersionQueries     buf_igmpInterfaceEntry
#define gb_igmpInterfaceJoins                   buf_igmpInterfaceEntry
#define gb_igmpInterfaceGroups                  buf_igmpInterfaceEntry
#define gb_igmpInterfaceRobustness              buf_igmpInterfaceEntry
#define gb_igmpInterfaceLastMembQueryInterval   buf_igmpInterfaceEntry
#define gb_igmpInterfaceProxyIfIndex            buf_igmpInterfaceEntry
#define gb_igmpInterfaceQuerierUpTime           buf_igmpInterfaceEntry
#define gb_igmpInterfaceQuerierExpiryTime       buf_igmpInterfaceEntry

#define sf_igmpInterfaceIfIndex                 set_igmpInterfaceEntry
#define sf_igmpInterfaceQueryInterval           set_igmpInterfaceEntry
#define sf_igmpInterfaceStatus                  set_igmpInterfaceEntry
#define sf_igmpInterfaceVersion                 set_igmpInterfaceEntry
#define sf_igmpInterfaceQueryMaxResponseTime    set_igmpInterfaceEntry
#define sf_igmpInterfaceRobustness              set_igmpInterfaceEntry
#define sf_igmpInterfaceLastMembQueryInterval   set_igmpInterfaceEntry
#define sf_igmpInterfaceProxyIfIndex            set_igmpInterfaceEntry

#define sb_igmpInterfaceIfIndex                 sav_igmpInterfaceEntry
#define sb_igmpInterfaceQueryInterval           sav_igmpInterfaceEntry
#define sb_igmpInterfaceStatus                  sav_igmpInterfaceEntry
#define sb_igmpInterfaceVersion                 sav_igmpInterfaceEntry
#define sb_igmpInterfaceQueryMaxResponseTime    sav_igmpInterfaceEntry
#define sb_igmpInterfaceRobustness              sav_igmpInterfaceEntry
#define sb_igmpInterfaceLastMembQueryInterval   sav_igmpInterfaceEntry
#define sb_igmpInterfaceProxyIfIndex            sav_igmpInterfaceEntry



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmpCacheEntry table (1,3,6,1,3,59,1,1,2,1)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_igmpCacheEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    );

UINT
set_igmpCacheEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    );

typedef struct _buf_igmpCacheEntry {
    AsnAny igmpCacheAddress;
    AsnAny igmpCacheIfIndex;
    AsnAny igmpCacheSelf;
    AsnAny igmpCacheLastReporter;
    AsnAny igmpCacheUpTime;
    AsnAny igmpCacheExpiryTime;
    AsnAny igmpCacheStatus;
    AsnAny igmpCacheVersion1HostTimer;
    DWORD  igmpCacheAddressBuf;
    DWORD  igmpCacheLastReporterBuf;
} buf_igmpCacheEntry;

typedef struct _sav_igmpCacheEntry {
    AsnAny igmpCacheAddress;
    AsnAny igmpCacheIfIndex;
    AsnAny igmpCacheSelf;
    AsnAny igmpCacheStatus;
} sav_igmpCacheEntry;

#define gf_igmpCacheAddress             get_igmpCacheEntry
#define gf_igmpCacheIfIndex             get_igmpCacheEntry
#define gf_igmpCacheSelf                get_igmpCacheEntry
#define gf_igmpCacheLastReporter        get_igmpCacheEntry
#define gf_igmpCacheUpTime              get_igmpCacheEntry
#define gf_igmpCacheExpiryTime          get_igmpCacheEntry
#define gf_igmpCacheStatus              get_igmpCacheEntry
#define gf_igmpCacheVersion1HostTimer   get_igmpCacheEntry

#define gb_igmpCacheAddress             buf_igmpCacheEntry
#define gb_igmpCacheIfIndex             buf_igmpCacheEntry
#define gb_igmpCacheSelf                buf_igmpCacheEntry
#define gb_igmpCacheLastReporter        buf_igmpCacheEntry
#define gb_igmpCacheUpTime              buf_igmpCacheEntry
#define gb_igmpCacheExpiryTime          buf_igmpCacheEntry
#define gb_igmpCacheStatus              buf_igmpCacheEntry
#define gb_igmpCacheVersion1HostTimer   buf_igmpCacheEntry

#define sf_igmpCacheAddress             set_igmpCacheEntry
#define sf_igmpCacheIfIndex             set_igmpCacheEntry
#define sf_igmpCacheSelf                set_igmpCacheEntry
#define sf_igmpCacheStatus              set_igmpCacheEntry

#define sb_igmpCacheAddress             sav_igmpCacheEntry
#define sb_igmpCacheIfIndex             sav_igmpCacheEntry
#define sb_igmpCacheSelf                sav_igmpCacheEntry
#define sb_igmpCacheStatus              sav_igmpCacheEntry

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\mibfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mibfuncs.c

Abstract:

    Sample subagent instrumentation callbacks.

--*/

#include    "precomp.h"
#pragma     hdrstop

// defined in iphlpapi.dll. This is a private api, which is 
// not declared in any header file.

DWORD
GetIgmpList(IN IPAddr NTEAddr,
    OUT IPAddr *pIgmpList,
    OUT PULONG dwOutBufLen
    );


//------------------------------------------------------------------------------
// local typedefs
//------------------------------------------------------------------------------

typedef enum {
    CONFIG_TYPE, STATS_TYPE
} INFO_TYPE;



//------------------------------------------------------------------------------
// Local Prototypes
//------------------------------------------------------------------------------

DWORD
ConnectToRouter(
    );

DWORD
GetInterfaceInfo(
    DWORD                       ActionId,
    DWORD                      *IfIndex,
    PIGMP_MIB_GET_OUTPUT_DATA  *ppResponse,
    INFO_TYPE                   InfoType
    );


DWORD
GetCacheEntry(
    DWORD                      ActionId,
    DWORD                      IfIndex,
    DWORD                      Group,
    DWORD                      *pNextGroup,
    PIGMP_MIB_GET_OUTPUT_DATA  *ppResponse
    );


//------------------------------------------------------------------------------
//      GetInterfaceInfo
//------------------------------------------------------------------------------

DWORD
GetInterfaceInfo(
    DWORD                       ActionId,
    DWORD                      *pIfIndex,
    PIGMP_MIB_GET_OUTPUT_DATA  *ppResponse,
    INFO_TYPE                   infoType
    )
/*++
Routine Description:
    Makes a call to igmp to get the interface config and stats and
    returns that info to mib.
Return values:
    MIB_S_ENTRY_NOT_FOUND MIB_S_NO_MORE_ENTRIES MIB_S_INVALID_PARAMETER
--*/
{
    IGMP_MIB_GET_INPUT_DATA Query;
    DWORD                   dwErr = NO_ERROR, dwOutSize;

    *ppResponse = NULL;

    ZeroMemory(&Query, sizeof(Query));
    Query.TypeId = (infoType==CONFIG_TYPE) ? IGMP_IF_CONFIG_ID: IGMP_IF_STATS_ID;
    Query.Flags = 0;
    Query.Count = 1;
    Query.IfIndex = *pIfIndex;

    if ( (*pIfIndex==0) && (ActionId==MIB_ACTION_GETNEXT) )
        ActionId = MIB_ACTION_GETFIRST;

    switch (ActionId) {

        //
        // ERROR_INVALID_PARAMETER is returned when there is no
        // interface with the given index
        // RPC_S_SERVER_UNAVAILABLE is returned when the router
        // isn't running.
        //

        case MIB_ACTION_GET :
        {
            IGMP_MIB_GET(&Query, sizeof(Query), ppResponse,
                            &dwOutSize, dwErr);

            if (dwErr==ERROR_INVALID_PARAMETER
                    || dwErr==RPC_S_SERVER_UNAVAILABLE
                    || dwErr==MIB_S_NO_MORE_ENTRIES)
            {
                dwErr = MIB_S_ENTRY_NOT_FOUND;
            }
            
            break;
        }

        case MIB_ACTION_GETFIRST :
        {
            IGMP_MIB_GETFIRST(&Query, sizeof(Query), ppResponse,
                                &dwOutSize, dwErr);

            if (dwErr==ERROR_INVALID_PARAMETER
                    || dwErr==RPC_S_SERVER_UNAVAILABLE
                    || dwErr==MIB_S_NO_MORE_ENTRIES)
            {
                dwErr = MIB_S_NO_MORE_ENTRIES;
            }
            
            break;
        }


        case MIB_ACTION_GETNEXT :
        {
            IGMP_MIB_GETNEXT(&Query, sizeof(Query), ppResponse,
                                &dwOutSize, dwErr);

            if (dwErr==ERROR_INVALID_PARAMETER
                    || dwErr==RPC_S_SERVER_UNAVAILABLE
                    || dwErr==MIB_S_NO_MORE_ENTRIES)
            {
                dwErr = MIB_S_NO_MORE_ENTRIES;
            }
            
            break;
        }

        default :
        {
            dwErr = MIB_S_INVALID_PARAMETER;

            break;
        }
    }

    if (dwErr!=NO_ERROR)
        *ppResponse = NULL;

    else
        *pIfIndex = Query.IfIndex;

    return dwErr;

} //end GetInterfaceInfo



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmpInterfaceEntry table (1,3,6,1,3,59,1,1,1,1)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_igmpInterfaceEntry(
    UINT     ActionId,
    AsnAny  *ObjectArray,
    UINT    *ErrorIndex
    )
/*++
Routine Description:
    Get the InterfaceEntry for snmp. Have to get the InterfaceConfig and
    InterfaceStats for the interface from igmp router.
--*/
{
    DWORD                       dwErr=NO_ERROR;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponseConfig, pResponseStats;
    PIGMP_MIB_IF_CONFIG         pConfig;
    PIGMP_MIB_IF_STATS          pStats;
    DWORD                       IfIndex, dwValue;
    buf_igmpInterfaceEntry     *pMibIfEntry
                                    = (buf_igmpInterfaceEntry*)ObjectArray;
    DWORD                       dwTmpActionId;



    TraceEnter("get_igmpInterfaceEntry");


    // get the interface index

    IfIndex   = GET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceIfIndex, 0);

    TRACE1("get_igmpInterfaceEntry called with IfIndex:%d", IfIndex);

    //
    // get interface config
    //

    dwTmpActionId = ActionId;

    while (1) {

        dwErr = GetInterfaceInfo(
                    dwTmpActionId,
                    &IfIndex,
                    &pResponseConfig,
                    CONFIG_TYPE
                    );


        // return if error

        if (dwErr!=NO_ERROR) {
            TraceError(dwErr);
            return dwErr;
        }

        pConfig = (PIGMP_MIB_IF_CONFIG) pResponseConfig->Buffer;


        //
        // should ignore proxy interface (unless the mode is MIB_ACTION_GET)
        //

        if ( (pConfig->IgmpProtocolType==IGMP_PROXY)
            && ( (ActionId==MIB_ACTION_GETFIRST)||(ActionId==MIB_ACTION_GETNEXT)) )
        {
            dwTmpActionId = MIB_ACTION_GETNEXT;
            MprAdminMIBBufferFree(pResponseConfig);
            continue;
        }
        else
            break;
    }

    //
    // get interface stats
    // use MIB_GET as IfIndex has been updated by the previous call
    //

    dwErr = GetInterfaceInfo(
                MIB_ACTION_GET,
                &IfIndex,
                &pResponseStats,
                STATS_TYPE
                );


    // return if error

    if (dwErr!=NO_ERROR) {
        MprAdminMIBBufferFree(pResponseConfig);
        TraceError(dwErr);
        return dwErr;
    }


    TRACE1("get_igmpInterfaceEntry returned info for interface:%d",
            IfIndex);


    //
    // fill in the required fields and return the MibIfEntry
    //

    pStats = (PIGMP_MIB_IF_STATS) pResponseStats->Buffer;


    //
    // set index for following getnext operation, (if any)
    //
    FORCE_SET_ASN_INTEGER(&(pMibIfEntry->igmpInterfaceIfIndex),
                        IfIndex);


    // get igmpInterfaceQueryInterval in seconds

    SET_ASN_INTEGER(&(pMibIfEntry->igmpInterfaceQueryInterval),
                        pConfig->GenQueryInterval);


    //
    // if Igmp is activated on that interface, then the state is set
    // to active(1), else it is set to notInService(2)
    //

    if ((pStats->State&IGMP_STATE_ACTIVATED) == IGMP_STATE_ACTIVATED) {
        SET_ASN_INTEGER(&(pMibIfEntry->igmpInterfaceStatus), 1);
    }
    else {
        SET_ASN_INTEGER(&(pMibIfEntry->igmpInterfaceStatus), 2);
    }


    // set igmpInterfaceVersion

    if (pConfig->IgmpProtocolType == IGMP_ROUTER_V1) {
        SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceVersion, 1);
    }
    else if (pConfig->IgmpProtocolType == IGMP_ROUTER_V2) {
        SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceVersion, 2);
    }



    // set igmpInterfaceQuerier

    SET_ASN_IP_ADDRESS(&pMibIfEntry->igmpInterfaceQuerier,
                        &pMibIfEntry->igmpInterfaceQuerierBuf,
                        pStats->QuerierIpAddr);


    // set igmpInterfaceQueryMaxResponseTime in seconds

    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceQueryMaxResponseTime,
                        pConfig->GenQueryMaxResponseTime);



    // todo: how can this value be set. This should be part of igmp host

    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceVersion1QuerierTimer,
                        pStats->V1QuerierPresentTimeLeft);

    SET_ASN_COUNTER(&pMibIfEntry->igmpInterfaceWrongVersionQueries,
                        pStats->WrongVersionQueries);


    // number of times a group entry was added to the group table

    SET_ASN_COUNTER(&pMibIfEntry->igmpInterfaceJoins,
                        pStats->GroupMembershipsAdded);

    SET_ASN_GAUGE(&pMibIfEntry->igmpInterfaceGroups,
                        pStats->CurrentGroupMemberships);

    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceRobustness,
                        pConfig->RobustnessVariable);


    // set igmpInterfaceLastMembQueryInterval in 10ths of secs
    // the value is initially in ms.

    dwValue = pConfig->LastMemQueryInterval / 100;
    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceLastMembQueryInterval,
                        dwValue);


    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceProxyIfIndex,
                        pStats->ProxyIfIndex);


    // seconds since igmpInterfaceQuerier was last changed
    
    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceQuerierUpTime,
                        pStats->LastQuerierChangeTime);

    SET_ASN_INTEGER(&pMibIfEntry->igmpInterfaceQuerierExpiryTime,
                        pStats->QuerierPresentTimeLeft);

    MprAdminMIBBufferFree(pResponseConfig);
    MprAdminMIBBufferFree(pResponseStats);

    TraceLeave("get_igmpInterfaceEntry");

    return dwErr;
}


DWORD
ValidateInterfaceConfig(
    IN  AsnAny *objectArray
)
{
    DWORD                   dwRes, IfIndex,
                            dwValue = 0, dwGenQueryInterval, dwMaxRespTime,
                            dwRobustness;
    sav_igmpInterfaceEntry *pIfConfig   = (sav_igmpInterfaceEntry*) objectArray;


    dwRes = MIB_S_INVALID_PARAMETER;

    BEGIN_BREAKOUT_BLOCK {


        //
        // get the interface index and make sure that it is not 0
        //
        IfIndex = GET_ASN_INTEGER(&pIfConfig->igmpInterfaceIfIndex, 0);

        if (IfIndex==0) {
            TRACE0("Call made for invalid interface index");
            break;
        }


        //
        // verify igmpInterfaceQueryInterval. Enforce min value of 10 sec
        // to prevent trashing the network.
        //
        dwGenQueryInterval = GET_ASN_INTEGER(
                                &pIfConfig->igmpInterfaceQueryInterval, 0
                                );

        if (dwGenQueryInterval<10) {
            TRACE2("IgmpInterfaceQueryInterval:%d for interface:%d less than "
                    "minimum value of 10 secs",
                    dwValue, IfIndex);
            break;
        }


        //
        // Ignore interface status. Do not allow interface being enabled through snmp
        //


        //
        // Igmp versions 1 and 2 currently supported
        //
        dwValue = GET_ASN_INTEGER(&pIfConfig->igmpInterfaceVersion, 0);

        if ( (dwValue!=1) && (dwValue!=2) ) {
            TRACE2("Invalid Igmp version:%d for interface:%d", dwValue, IfIndex);
            break;
        }



        //
        // check InterfaceQueryMaxResponseTime
        // NOTE: it is in units of 10ths of a second
        //
        dwMaxRespTime = GET_ASN_INTEGER(
                                &pIfConfig->igmpInterfaceQueryMaxResponseTime,
                                0);

        // Enforce a min of 1 sec

        if (dwValue<10) {
            TRACE2("igmpInterfaceQueryMaxResponseTime:%d for interface:%d"
                    "should not be less than 10", dwValue, IfIndex);
            break;
        }

        // Absurd if value greater than GenQueryInterval*10 (conv to 10th of sec).

        if (dwValue>dwGenQueryInterval*10) {
            TRACE3("QueryMaxResponseTime:%d for interface:%d "
                    "should not be less than GenQueryInterval:%d",
                    dwValue, IfIndex, dwGenQueryInterval);
            break;
        }



        //
        // igmpInterfaceRobustness must not be 0. If it is 1, print trace but
        // do not break.
        //
        dwRobustness = GET_ASN_INTEGER(&pIfConfig->igmpInterfaceRobustness, 0);

        if (dwValue==0) {
            TRACE1("IgmpInterfaceRobustness for interface:%d cannot be set to 0",
                    IfIndex);
            break;
        }

        if (dwValue!=1) {
            TRACE1("Warning: InterfaceRobustness for interface:%d being set to 1",
                    IfIndex);
        }

        // no check for igmpInterfaceProxyIfIndex.



        // limit max LastMemQueryInterval to GroupMembershipTimeout

        dwValue = GET_ASN_INTEGER(&pIfConfig->igmpInterfaceLastMembQueryInterval,
                                    0);
        if (dwValue>dwRobustness*dwGenQueryInterval + dwMaxRespTime) {
            TRACE3("LastMembQueryInterval:%d for interface:%d should not be "
                    "higher than GroupMembershipTimeout:%d",
                    dwValue, IfIndex,
                    dwRobustness*dwGenQueryInterval + dwMaxRespTime
                    );
            break;
        }

        // if reached here, then there is no error

        dwRes = NO_ERROR;
        
    } END_BREAKOUT_BLOCK;

    return dwRes;
}


DWORD
SetInterfaceConfig(
    IN  AsnAny *    objectArray
    )
{
    DWORD                           dwRes       = (DWORD) -1,
                                    dwGetSize   = 0,
                                    dwSetSize   = 0,
                                    IfIndex, dwValue;

    sav_igmpInterfaceEntry         *pNewIfConfig
                                    = (sav_igmpInterfaceEntry*) objectArray;

    PIGMP_MIB_IF_CONFIG             pCurIfConfig;
    PIGMP_MIB_SET_INPUT_DATA        pSetInputData = NULL;

    PIGMP_MIB_GET_OUTPUT_DATA       pResponse = NULL;
    IGMP_MIB_GET_INPUT_DATA         Query;


    BEGIN_BREAKOUT_BLOCK {

        //
        // retrieve existing interface config
        //

        dwRes = GetInterfaceInfo(MIB_ACTION_GET,
                                    &IfIndex, &pResponse, CONFIG_TYPE);

        if (dwRes != NO_ERROR) {
            TraceError(dwRes);
            break;
        }


        //
        // Update fields
        //

        pCurIfConfig = (PIGMP_MIB_IF_CONFIG) pResponse->Buffer;


        // set IfIndex

        pCurIfConfig->IfIndex = IfIndex;



        // update interface version

        dwValue = GET_ASN_INTEGER(&pNewIfConfig->igmpInterfaceVersion, 0);

        if (dwValue!=0)
            pCurIfConfig->IgmpProtocolType = (dwValue==1)
                                             ? IGMP_ROUTER_V1
                                             : IGMP_ROUTER_V2;


        // update RobustnessVariable

        pCurIfConfig->RobustnessVariable
                = GET_ASN_INTEGER(&pNewIfConfig->igmpInterfaceRobustness, 0);



        // calculate StartupQueryCount from RobustnessVariable

        pCurIfConfig->StartupQueryCount
                = pCurIfConfig->RobustnessVariable;



        // update igmpInterfaceQueryInterval

        pCurIfConfig->GenQueryInterval
                = GET_ASN_INTEGER(&pNewIfConfig->igmpInterfaceQueryInterval, 0);



        // calculate value of StartupQueryInterval from GenQueryInterval

        pCurIfConfig->StartupQueryInterval
                = (DWORD)(0.25*pCurIfConfig->GenQueryInterval);



        // update GenQueryMaxResponseTime

        pCurIfConfig->GenQueryMaxResponseTime
                = GET_ASN_INTEGER(
                        &pNewIfConfig->igmpInterfaceQueryMaxResponseTime, 0
                        );


        // update LastMemQueryInterval

        pCurIfConfig->LastMemQueryInterval
                = GET_ASN_INTEGER(
                        &pNewIfConfig->igmpInterfaceLastMembQueryInterval, 0
                        );



        // calculate LastMemQueryCount from RobustnessVariable

        pCurIfConfig->LastMemQueryCount = pCurIfConfig->RobustnessVariable;


        // LeaveEnabled is not changed



        //
        // Save interface config
        //

        dwSetSize = sizeof(IGMP_MIB_SET_INPUT_DATA) - 1 +
                            sizeof(IGMP_MIB_IF_CONFIG);

        pSetInputData = (PIGMP_MIB_SET_INPUT_DATA) IGMP_MIB_ALLOC(dwSetSize);

        if (!pSetInputData) {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            TRACE0( " Not enough memory " );
            break;
        }

        pSetInputData->TypeId     = IGMP_IF_CONFIG_ID;
        pSetInputData->Flags      = 0;

        pSetInputData->BufferSize = sizeof(IGMP_MIB_IF_CONFIG);

        CopyMemory(
            pSetInputData->Buffer,
            pCurIfConfig,
            pSetInputData->BufferSize
        );


        IGMP_MIB_SET(pSetInputData, dwSetSize, dwRes);

        if (dwRes!=NO_ERROR) {
            TraceError( dwRes );
            break;
        }

        dwRes = MIB_S_SUCCESS;

    } END_BREAKOUT_BLOCK;

    if (pResponse)
        MprAdminMIBBufferFree(pResponse);

    if (pSetInputData)
        IGMP_MIB_FREE(pSetInputData);


    return dwRes;
}


UINT
set_igmpInterfaceEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    )
{
    DWORD   dwRes = NO_ERROR;

    TraceEnter("set_igmpInterfaceEntry");

    switch (ActionId)
    {

        case MIB_ACTION_VALIDATE :

            dwRes = ValidateInterfaceConfig(ObjectArray);

            break;


        case MIB_ACTION_SET :

            dwRes = SetInterfaceConfig(ObjectArray);

            break;


        case MIB_ACTION_CLEANUP :

            dwRes = MIB_S_SUCCESS;

            break;


        default :

            TRACE0("set_ifConfigEntry - wrong action");

            dwRes = MIB_S_INVALID_PARAMETER;

            break;

    } //end switch(ActionId)


    TraceLeave("set_igmpInterfaceEntry");

    return dwRes;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// igmpCacheEntry table (1,3,6,1,3,59,1,1,2,1)                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_igmpCacheEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    )
{
    DWORD                       dwRes = NO_ERROR;
    PIGMP_MIB_GET_OUTPUT_DATA   pResponse;
    DWORD                       IfIndex, Group, ReturnedGroup, dwTmpActionId;
    buf_igmpCacheEntry         *pMibCacheEntry
                                    = (buf_igmpCacheEntry*)ObjectArray;
    PIGMP_MIB_GROUP_INFO        pGIEntry;
    PIGMP_MIB_GROUP_IFS_LIST    pGroupIfsList;


    TraceEnter("get_igmpCacheEntry");


    // get the interface index

    IfIndex = GET_ASN_INTEGER(&pMibCacheEntry->igmpCacheIfIndex, 0);



    // get the group address

    Group = GET_ASN_IP_ADDRESS(&pMibCacheEntry->igmpCacheAddress, 0);


    TRACE2("get_igmpCacheEntry called with IfIndex:%d, Group:%d.%d.%d.%d",
            IfIndex, PRINT_IPADDR(Group));


    dwTmpActionId = ActionId;

    if ( Group==0 && ActionId==MIB_ACTION_GETNEXT )
    {
        dwTmpActionId = MIB_ACTION_GETFIRST;
    }

    else if (ActionId==MIB_ACTION_GETNEXT)
    {
        dwTmpActionId = MIB_ACTION_GET;
    }

    pResponse = NULL;
    
    while (1) {

        if (pResponse)
            MprAdminMIBBufferFree(pResponse);                

        TRACE2("GetCacheEntry() called for Group: %d.%d.%d.%d, If:%d",
                PRINT_IPADDR(Group), IfIndex);

        //
        // retrieve the cache entry
        //
        dwRes = GetCacheEntry(
                    dwTmpActionId,
                    IfIndex,
                    Group,
                    &ReturnedGroup,
                    &pResponse
                    );


        if (Group!=ReturnedGroup)
            IfIndex = 0;
            
        dwTmpActionId = MIB_ACTION_GETNEXT;

        // return if error

        if (dwRes!=NO_ERROR) {
            TraceError(dwRes);
            TraceLeave("get_igmpCacheEntry");
            return dwRes;
        }

        
        pGroupIfsList = (PIGMP_MIB_GROUP_IFS_LIST)pResponse->Buffer;

        // no ifs for that group
        
        if (pGroupIfsList->NumInterfaces == 0) {

            // for GET return error
            
            if (ActionId==MIB_ACTION_GET || ActionId==MIB_ACTION_GETFIRST)
            {
                MprAdminMIBBufferFree(pResponse);                            
                return MIB_S_ENTRY_NOT_FOUND;
            }
            
            // for GETNEXT continue with next group
            else
            {
                Group = ReturnedGroup;
                continue;
            }
        }

        pGIEntry = (PIGMP_MIB_GROUP_INFO)pGroupIfsList->Buffer;

        // if GET, then try to find the exact entry
        
        if (ActionId==MIB_ACTION_GET)
        {
            DWORD i;
            for (i=0;  i<pGroupIfsList->NumInterfaces;  i++,pGIEntry++)
            {
                if (pGIEntry->IfIndex==IfIndex)
                    break;
            }

            // exact entry not found for GET
            
            if (i==pGroupIfsList->NumInterfaces)
            {
                MprAdminMIBBufferFree(pResponse);                
                return MIB_S_ENTRY_NOT_FOUND;
            }
        }
        else if (ActionId==MIB_ACTION_GETNEXT)
        {
            DWORD i;
            PIGMP_MIB_GROUP_INFO pNextGI = pGIEntry;

            for (i=0;  i<pGroupIfsList->NumInterfaces;  i++,pGIEntry++)
            {
                if (pGIEntry->IfIndex > IfIndex &&
                        pGIEntry->IfIndex < pNextGI->IfIndex)
                {
                    pNextGI = pGIEntry;
                }
            }
            if (pNextGI->IfIndex <= IfIndex)
            {
                Group = ReturnedGroup;
                continue;
            }
            else
                pGIEntry = pNextGI;
        }

        break;

    }


    //
    // fill in the required fields and return the MibCacheEntry
    //
    Group = ReturnedGroup;
    IfIndex = pGIEntry->IfIndex;
    
    TRACE2("GetCacheEntry() returned for Interface: %d for group(%d.%d.%d.%d)",
            IfIndex, PRINT_IPADDR(Group));


    //
    // set Group/IfIndex for following getnext operation, (if any)
    //

    FORCE_SET_ASN_IP_ADDRESS(
            &(pMibCacheEntry->igmpCacheAddress),
            &(pMibCacheEntry->igmpCacheAddressBuf),
            Group
    );

    FORCE_SET_ASN_INTEGER(&(pMibCacheEntry->igmpCacheIfIndex),
                            IfIndex);

    // find out if the group is added on the localhost interface
    {
        DWORD BufLen, Status;
        IPAddr *pIgmpList = NULL, *pIgmpEntry;


        // set all default values to false
        
        SET_ASN_INTEGER(&(pMibCacheEntry->igmpCacheSelf), 2);

        
        GetIgmpList(pGIEntry->IpAddr, NULL, &BufLen);

        pIgmpList = HeapAlloc(GetProcessHeap(), 0, BufLen);

            
        if (pIgmpList) {

            Status = GetIgmpList(pGIEntry->IpAddr, pIgmpList, &BufLen);
        
            if (Status == STATUS_SUCCESS)
            {
                ULONG Count = BufLen/sizeof(IPAddr);
                ULONG i;
            
                for (i=0,pIgmpEntry=pIgmpList;  i<Count;  i++,pIgmpEntry++)
                {
                    if (*pIgmpEntry == Group) {
                        SET_ASN_INTEGER(&(pMibCacheEntry->igmpCacheSelf), 1);
                        break;
                    }
                }
            }

            HeapFree(GetProcessHeap(), 0, pIgmpList);
        }
    }

    
    SET_ASN_IP_ADDRESS(&pMibCacheEntry->igmpCacheLastReporter,
                        &pMibCacheEntry->igmpCacheLastReporterBuf,
                        pGIEntry->LastReporter);


    // multiply GroupUpTime and GroupExpiryTime by 100 to get timeTicks

    SET_ASN_TIME_TICKS(&(pMibCacheEntry->igmpCacheUpTime),
                            pGIEntry->GroupUpTime*100);

    SET_ASN_TIME_TICKS(&(pMibCacheEntry->igmpCacheExpiryTime),
                            pGIEntry->GroupExpiryTime*100);



    // cache status is always active(1)

    SET_ASN_INTEGER(&(pMibCacheEntry->igmpCacheStatus), 1);

    SET_ASN_INTEGER(&(pMibCacheEntry->igmpCacheVersion1HostTimer),
                            pGIEntry->V1HostPresentTimeLeft);


    MprAdminMIBBufferFree(pResponse);                

    TraceLeave("get_igmpCacheEntry");
    return dwRes;
}



DWORD
GetCacheEntry(
    DWORD                      ActionId,
    DWORD                      IfIndex,
    DWORD                      Group,
    DWORD                      *pNextGroup,
    PIGMP_MIB_GET_OUTPUT_DATA  *ppResponse
    )
/*++
Routine Description:
    Get the Group-Interface entry from igmp.
--*/
{
    IGMP_MIB_GET_INPUT_DATA Query;
    DWORD                   dwErr = NO_ERROR, dwOutSize;


    *ppResponse = NULL;

    ZeroMemory(&Query, sizeof(Query));
    Query.TypeId = IGMP_GROUP_IFS_LIST_ID;
    Query.Flags = IGMP_ENUM_ONE_ENTRY | IGMP_ENUM_ALL_INTERFACES_GROUPS;
    Query.Count = 1;
    Query.IfIndex = IfIndex;
    Query.GroupAddr = Group;


    switch (ActionId) {

        //
        // ERROR_INVALID_PARAMETER is returned when there are no
        // interfaces with groups
        // RPC_S_SERVER_UNAVAILABLE is returned when the router
        // isn't running.
        //

        case MIB_ACTION_GET :
        {

            IGMP_MIB_GET(&Query, sizeof(Query), ppResponse,
                &dwOutSize, dwErr);

            if (dwErr==ERROR_INVALID_PARAMETER
                    || dwErr==RPC_S_SERVER_UNAVAILABLE)

                dwErr = MIB_S_ENTRY_NOT_FOUND;

            break;
        }


        case MIB_ACTION_GETFIRST :
        {
            IGMP_MIB_GETFIRST(&Query, sizeof(Query), ppResponse,
                                &dwOutSize, dwErr);

            if (dwErr==ERROR_INVALID_PARAMETER
                    || dwErr==RPC_S_SERVER_UNAVAILABLE)

                dwErr = MIB_S_NO_MORE_ENTRIES;


            break;
        }


        case MIB_ACTION_GETNEXT :
        {
            IGMP_MIB_GETNEXT(&Query, sizeof(Query), ppResponse,
                                &dwOutSize, dwErr);

            if (dwErr==ERROR_INVALID_PARAMETER
                    || dwErr==RPC_S_SERVER_UNAVAILABLE)

                dwErr = MIB_S_NO_MORE_ENTRIES;

            break;
        }

        default :
        {
            dwErr = MIB_S_INVALID_PARAMETER;

            break;
        }
    }


    if (dwErr!=NO_ERROR)
        *ppResponse = NULL;

    else
        *pNextGroup = Query.GroupAddr;


    return dwErr;
}




UINT
set_igmpCacheEntry(
    UINT     ActionId,
    AsnAny * ObjectArray,
    UINT *   ErrorIndex
    )
{
    return MIB_S_NOT_SUPPORTED;
}


DWORD
ConnectToRouter(
    )
{
    DWORD       dwRes = (DWORD) -1;


    EnterCriticalSection( &g_CS );

    do
    {
        MPR_SERVER_HANDLE hTmp;

        if ( g_hMibServer )
        {
            dwRes = NO_ERROR;
            break;
        }

        dwRes = MprAdminMIBServerConnect( NULL, &hTmp );

        if ( dwRes == NO_ERROR )
        {
            InterlockedExchangePointer(&g_hMibServer, hTmp );
        }
        else
        {
            TRACE1(
                "Error %d setting up DIM connection to MIB Server\n",
                dwRes
            );
        }

    } while ( FALSE );

    LeaveCriticalSection( &g_CS );

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\igmpagnt\precomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
        precomp.h

Abstract:
        Precompiled header for igmpv2 subagent

Author:
        K.S.Lokesh
        lokeshs@microsoft.com   2-15-97        

Revision History:
        Created 2-15-97
--*/

#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <winsock.h>
#include <snmp.h>
#include <snmpexts.h>
#include <mprapi.h>
#include <routprot.h>
#include <igmprm.h>
#include <ipexport.h>

#if defined( DBG )

#include <rtutils.h>
extern DWORD   g_dwTraceId;

#endif

#include "mibentry.h"
#include "mibfuncs.h"
#include "defs.h"

extern      MIB_SERVER_HANDLE       g_hMibServer;
extern      CRITICAL_SECTION        g_CS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\adapter.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\adapter.h

Abstract:

    Forward declarations for functions in adapter.c
    
Revision History:

    AmritanR

--*/


#ifndef __IPINIP_ADAPTER_H__
#define __IPINIP_ADAPTER_H__


#define TCPIP_INTERFACES_KEY    L"Tcpip\\Parameters\\Interfaces\\"


BOOLEAN
IsBindingPresent(
    PUNICODE_STRING pusBindName
    );


#if DBG
NTSTATUS
CreateTunnel(
    IN  PNDIS_STRING            pnsBindName,
    OUT TUNNEL                  **ppNewTunnel,
    IN  PANSI_STRING            pasAnsiName
    );

#else

NTSTATUS
CreateTunnel(
    IN  PNDIS_STRING            pnsBindName,
    OUT TUNNEL                  **ppNewTunnel
    );

#endif


VOID
IpIpOpenAdapter(
    PVOID   pvContext
    );

VOID
IpIpCloseAdapter(
    PVOID   pvContext
    );

UINT
IpIpAddAddress(
    PVOID       pvContext,
    UINT        uiType,
    DWORD       dwAddress,
    DWORD       dwMask,
    PVOID       pvUnused
    );

UINT
IpIpDeleteAddress(
    PVOID   pvContext,
    UINT    uiType,
    DWORD   dwAddress,
    DWORD   dwMask
    );

INT
IpIpQueryInfo(
    PVOID           pvIfContext,
    TDIObjectID     *pTdiObjId,
    PNDIS_BUFFER    pnbBuffer,
    PUINT           puiSize,
    PVOID           pvContext
    );


INT
IpIpSetInfo(
    PVOID       pvContext,
    TDIObjectID *pTdiObjId,
    PVOID       pvBuffer,
    UINT        uiSize
    );


INT
IpIpGetEntityList(
    PVOID       pvContext,
    TDIEntityID *pTdiEntityList,
    PUINT       puiCount
    );

INT
IpIpDynamicRegister(
    PNDIS_STRING            InterfaceName,
    PVOID                   pvIpInterfaceContext,
    struct _IP_HANDLERS *   IpHandlers,
    struct LLIPBindInfo *   ARPBindInfo,
    UINT                    uiInterfaceNumber
    );

NTSTATUS
AddInterfaceToIP(
    PTUNNEL      pTunnel,
    PNDIS_STRING pnsName,
    PVOID        pvSystemSpecific1,
    PVOID        pvSystemSpecific2
    );

VOID
DeleteTunnel(
    PTUNNEL pTunnel
    );

INT
IpIpBindAdapter(
    PNDIS_STATUS  pnsRetStatus,
    NDIS_HANDLE   nhBindContext,
    PNDIS_STRING  pnsAdapterName,
    PVOID         pvSS1,
    PVOID         pvSS2
    );

PTUNNEL
FindTunnel(
    PULARGE_INTEGER puliTunnelId
    );

PTUNNEL
FindTunnelGivenIndex(
    DWORD   dwIfIndex
    );

VOID
RemoveAllTunnels(
    VOID
    );

NTSTATUS
AddInterfaceToIP2(
    IN  PTUNNEL      pTunnel,
    IN  PNDIS_STRING pnsName
    );

NTSTATUS
IpIpCreateAdapter(
    IN  PIPINIP_CREATE_TUNNEL   pCreateInfo,
    IN  USHORT                  usKeyLength,
    OUT PDWORD                  pdwIfIndex
    );

#endif // __IPINIP_ADAPTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\adapter.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\adapter.c

Abstract:

    
    The file contains the section interface of the IP in IP tunnel driver
    to the TCP/IP stack that is involved with Binding Notification and
    Querying/Setting information for interfaces

    The code is a cleaned up version of wanarp\ipif.c which in turn
    was derived from HenrySa's ip\arp.c
    
Revision History:

    AmritanR

--*/

#define __FILE_SIG__    ADAPTER_SIG

#include "inc.h"



VOID
IpIpOpenAdapter(
    IN  PVOID pvContext
    )

/*++

Routine Description

    Called by IP when the adapter from it IPAddInterface() call

Locks


Arguments

    pvContext   Pointer to the TUNNEL structure

Return Value

    None
    
--*/

{
    TraceEnter(TUNN, "IpIpOpenAdapter");
    
    //
    // Nothing to be done here, really
    //

    TraceLeave(TUNN, "IpIpOpenAdapter");
}

VOID
IpIpCloseAdapter(
    IN  PVOID pvContext
    )

/*++

Routine Description

    Called by IP when it wants to close an adapter. Currently this is done
    from CloseNets() and IPDelInterface().

Locks


Arguments

    pvContext   Pointer to the TUNNEL

Return Value

    None

--*/

{
    TraceEnter(TUNN, "IpIpCloseAdapter");
    

    TraceLeave(TUNN, "IpIpCloseAdapter");
}


UINT
IpIpAddAddress(
    IN  PVOID   pvContext,
    IN  UINT    uiType,
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  PVOID   pvUnused
    )

/*++

Routine Description

    This routine is called by the upper layer to add an address as a local
    address, or specify the broadcast address for this Interface

Locks


Arguments


Return Value
    NO_ERROR

--*/

{
    TraceEnter(TUNN, "IpIpAddAddress");

    TraceLeave(TUNN, "IpIpAddAddress");
    
    return (UINT)TRUE;
}

UINT
IpIpDeleteAddress(
    IN  PVOID   pvContext,
    IN  UINT    uiType,
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask
    )

/*++

Routine Description

    Called to delete a local or proxy address.
    
Locks


Arguments


Return Value
    NO_ERROR

--*/

{
    TraceEnter(TUNN, "IpIpDeleteAddress");

    TraceLeave(TUNN, "IpIpDeleteAddress");
    
    return TRUE;
}

INT
IpIpQueryInfo(
    IN  PVOID           pvIfContext,
    IN  TDIObjectID     *pTdiObjId,
    IN  PNDIS_BUFFER    pnbBuffer,
    IN  PUINT           puiSize,
    IN  PVOID           pvContext
    )

/*++

Routine Description

    Routine is called by IP to query the MIB-II information related
    to the TUNNEL interface
    
Locks

    We acquire the TUNNEL lock. We dont need to refcount the tunnel as
    explained in ipinip.h

Arguments

    pvIfContext     The context we returned to IP, a pointer to the TUNNEL
    
Return Value
    

--*/

{
    PTUNNEL pTunnel;
    ULONG   ulOffset;
    ULONG   ulBufferSize;
    UINT    BytesCopied = 0;
    BYTE    rgbyInfoBuff[sizeof(IFEntry)];
    DWORD   dwEntity;
    DWORD	dwInstance;
    IFEntry *pIFE;
    NTSTATUS nStatus;
    
    pTunnel    = (PTUNNEL)pvIfContext;
    
    dwEntity   = pTdiObjId->toi_entity.tei_entity;
    dwInstance = pTdiObjId->toi_entity.tei_instance;
    
    //
    // We support only Interface MIBs - no address xlation - pretty much like
    // a loopback i/f (per Henry circa 1994)
    //

    if((dwEntity isnot IF_ENTITY) or
       (dwInstance isnot pTunnel->dwIfInstance))
    {
	    return TDI_INVALID_REQUEST;
    }

    if(pTdiObjId->toi_type isnot INFO_TYPE_PROVIDER)
    {
        Trace(TUNN, INFO,
              ("IpIpQueryInfo: toi_type is wrong 0x%x\n",
               pTdiObjId->toi_type));

	    return TDI_INVALID_PARAMETER;
    }

    //
    // a safe initialization.
    //

    ulBufferSize = *puiSize;
    *puiSize     = 0;
    ulOffset     = 0;

    if(pTdiObjId->toi_class is INFO_CLASS_GENERIC)
    {
	    if(pTdiObjId->toi_id isnot ENTITY_TYPE_ID)
        {
            Trace(TUNN, INFO,
                  ("IpIpQueryInfo: toi_id is wrong 0x%x\n",
                  pTdiObjId->toi_id));
        
            return TDI_INVALID_PARAMETER;
        }

        //
        // He's trying to see what type we are.
        //
        
        if(ulBufferSize < sizeof(DWORD))
        {
            Trace(TUNN, ERROR,
                  ("IpIpQueryInfo: Buffer size %d too small\n",
                   ulBufferSize));

	    	return TDI_BUFFER_TOO_SMALL;
        }    

        *(PDWORD)&rgbyInfoBuff[0] = (dwEntity is AT_ENTITY) ? 
                                    AT_ARP : IF_MIB;

#if NDISBUFFERISMDL
       
        nStatus = TdiCopyBufferToMdl(rgbyInfoBuff,
                                     0,
                                     sizeof(DWORD),
                                     (PMDL)pnbBuffer,
                                     0,
                                     &ulOffset);

#else
#error "Fix this"
#endif
        
        *puiSize = ulOffset;
        
        return nStatus;

    }


    if(pTdiObjId->toi_class isnot INFO_CLASS_PROTOCOL)
    {
        Trace(TUNN, INFO,
              ("IpIpQueryInfo: toi_class is wrong 0x%x\n",
              pTdiObjId->toi_class));

	    return TDI_INVALID_PARAMETER;
    }

    //
    // The usermust be asking for Interface level information.
    // See if we support what is being asked for
    //

    if(pTdiObjId->toi_id isnot IF_MIB_STATS_ID)
    {
        Trace(TUNN, INFO,
              ("IpIpQueryInfo: toi_id 0x%x is not MIB_STATS\n",
              pTdiObjId->toi_id));

        return TDI_INVALID_PARAMETER;
    }

    //
    // He's asking for statistics. Make sure his buffer is at least big
    // enough to hold the fixed part.
    //
    
    if(ulBufferSize < IFE_FIXED_SIZE)
    {
        Trace(TUNN, ERROR,
              ("IpIpQueryInfo: Buffer size %d smaller than IFE %d\n",
               ulBufferSize, IFE_FIXED_SIZE));

        return TDI_BUFFER_TOO_SMALL;
    }
   
    pIFE = (IFEntry *)rgbyInfoBuff;

    RtlZeroMemory(pIFE,
                  sizeof(IFEntry));
 
    //
    // He's got enough to hold the fixed part. Build the IFEntry structure,
    // and copy it to his buffer.
    //
    
    pIFE->if_index       = pTunnel->dwIfIndex;
    pIFE->if_type        = IF_TYPE_TUNNEL;
    pIFE->if_physaddrlen = ARP_802_ADDR_LENGTH;
    
    RtlCopyMemory(pIFE->if_physaddr,
                  pTunnel->rgbyHardwareAddr,
                  ARP_802_ADDR_LENGTH);
    
    pIFE->if_mtu     = pTunnel->ulMtu;
    pIFE->if_speed   = DEFAULT_SPEED;
    
    pIFE->if_adminstatus     = GetAdminState(pTunnel);
    pIFE->if_operstatus      = pTunnel->dwOperState;
    pIFE->if_lastchange      = pTunnel->dwLastChange;
    pIFE->if_inoctets        = pTunnel->ulInOctets;
    pIFE->if_inucastpkts     = pTunnel->ulInUniPkts;
    pIFE->if_innucastpkts    = pTunnel->ulInNonUniPkts;
    pIFE->if_indiscards      = pTunnel->ulInDiscards;
    pIFE->if_inerrors        = pTunnel->ulInErrors;
    pIFE->if_inunknownprotos = pTunnel->ulInUnknownProto;
    pIFE->if_outoctets       = pTunnel->ulOutOctets;
    pIFE->if_outucastpkts    = pTunnel->ulOutUniPkts;
    pIFE->if_outnucastpkts   = pTunnel->ulOutNonUniPkts;
    pIFE->if_outdiscards     = pTunnel->ulOutDiscards;
    pIFE->if_outerrors       = pTunnel->ulOutErrors;
    pIFE->if_outqlen         = pTunnel->ulOutQLen;
    
    pIFE->if_descrlen        = strlen(VENDOR_DESCRIPTION_STRING);
   
#if NDISBUFFERISMDL

    nStatus = TdiCopyBufferToMdl(pIFE,
                                 0,
                                 IFE_FIXED_SIZE,
                                 (PMDL)pnbBuffer,
                                 0,
                                 &ulOffset);

#else
#error "Fix this"
#endif
 
    //
    // See if he has room for the descriptor string.
    //
    
    if(ulBufferSize < (IFE_FIXED_SIZE + strlen(VENDOR_DESCRIPTION_STRING)))
    {
        Trace(TUNN, ERROR,
              ("IpIpQueryInfo: Buffer size %d too small for VENDOR string\n",
               ulBufferSize));

        //
        // Not enough room to copy the desc. string.
        //
        
        *puiSize = IFE_FIXED_SIZE;
        
        return TDI_BUFFER_OVERFLOW;
    }

#if NDISBUFFERISMDL

    nStatus = TdiCopyBufferToMdl(VENDOR_DESCRIPTION_STRING,
                                 0,
                                 strlen(VENDOR_DESCRIPTION_STRING),
                                 (PMDL)pnbBuffer,
                                 ulOffset,
                                 &ulOffset);

#else
#error "Fix this"
#endif
    
    *puiSize = IFE_FIXED_SIZE + strlen(VENDOR_DESCRIPTION_STRING);
    
    return TDI_SUCCESS;

}

INT
IpIpSetRequest(
    PVOID       pvContext,
    NDIS_OID    Oid,
    UINT        Type
    )
{
    return NDIS_STATUS_SUCCESS;
}

INT
IpIpSetInfo(
    IN  PVOID       pvContext,
    IN  TDIObjectID *pTdiObjId,
    IN  PVOID       pvBuffer,
    IN  UINT        uiSize
    )
{
    PTUNNEL     pTunnel;
    INT         iStatus;
    IFEntry     *pIFE;
    DWORD       dwEntity;
    DWORD       dwInstance;
    KIRQL       kiIrql;

    pIFE        = (IFEntry *)pvBuffer;
    pTunnel     = (PTUNNEL)pvContext;
    dwEntity    = pTdiObjId->toi_entity.tei_entity;
    dwInstance  = pTdiObjId->toi_entity.tei_instance;

    //
    // Might be able to handle this.
    //

    if((dwEntity isnot IF_ENTITY) or
       (dwInstance isnot pTunnel->dwIfInstance))
    {
        return TDI_INVALID_REQUEST;
    }
    
    //
    // It's for the I/F level, see if it's for the statistics.
    //
    
    if (pTdiObjId->toi_class isnot INFO_CLASS_PROTOCOL)
    {
        Trace(TUNN, INFO,
              ("IpIpSetInfo: toi_class is wrong 0x%x\n",
              pTdiObjId->toi_class));

        return TDI_INVALID_PARAMETER;
    }

    if (pTdiObjId->toi_id isnot IF_MIB_STATS_ID)
    {
        Trace(TUNN, INFO,
              ("IpIpSetInfo: toi_id 0x%x is not MIB_STATS\n",
              pTdiObjId->toi_id));

        return TDI_INVALID_PARAMETER;
    }
    
    //
    // It's for the stats. Make sure it's a valid size.
    //

    if(uiSize < IFE_FIXED_SIZE)
    {
        Trace(TUNN, ERROR,
              ("IpIpSetInfo: Buffer size %d too small\n",
               uiSize));

        return TDI_BUFFER_TOO_SMALL;
    }
    
    //
    // Good size
    //

    RtAcquireSpinLock(&(pTunnel->rlLock),
                      &kiIrql);

    switch(pIFE->if_adminstatus)
    {
        case IF_STATUS_UP:
        {
            iStatus = TDI_SUCCESS;

            if(GetAdminState(pTunnel) is IF_STATUS_UP)
            {
                //
                // Nothing to do
                //

                break;
            }

            pTunnel->dwAdminState =
                (pTunnel->dwAdminState & 0xFFFF0000) | IF_STATUS_UP;

            if(pTunnel->dwAdminState & TS_ADDRESS_PRESENT)
            {
                //
                // This will set the oper. status
                //

                UpdateMtuAndReachability(pTunnel);
            }

            break;
        }
        
        case IF_STATUS_DOWN:
        {
            iStatus = TDI_SUCCESS;

            if(GetAdminState(pTunnel) is IF_STATUS_DOWN)
            {
                //
                // Nothing to do
                //

                break;
            }

            pTunnel->dwAdminState =
                (pTunnel->dwAdminState & 0xFFFF0000) | IF_STATUS_DOWN;


            pTunnel->dwOperState = IF_OPER_STATUS_NON_OPERATIONAL;

            break;
        }
        
        case IF_STATUS_TESTING:
        {
            //
            // Not supported, just return SUCCESS
            //
            
            iStatus = TDI_SUCCESS;
            
            break;
        }
        
        default:
        {
            iStatus = TDI_INVALID_PARAMETER;
            
            break;
        }
    }

    RtReleaseSpinLock(&(pTunnel->rlLock),
                      kiIrql);

    return iStatus;
}

INT
IpIpGetEntityList(
    IN  PVOID       pvContext,
    IN  TDIEntityID *pTdiEntityList,
    IN  PUINT       puiCount
    )
{
    PTUNNEL     pTunnel;
    UINT		uiEntityCount;
    UINT		uiMyIFBase;
    UINT		i;
    TDIEntityID *pTdiIFEntity;
    KIRQL       kiIrql;


    pTunnel = (PTUNNEL)pvContext;
    
    //
	// Walk down the list, looking for existing IF entities, and
	// adjust our base instance accordingly.
    //
    

    uiMyIFBase   = 0;
    pTdiIFEntity = NULL;
    
	for(i = 0;
        i < *puiCount;
        i++, pTdiEntityList++)
    {
		if(pTdiEntityList->tei_entity is IF_ENTITY)
        {
            //
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            //
            
            if((pTdiEntityList->tei_instance is pTunnel->dwIfInstance) and
               (pTdiEntityList->tei_instance isnot INVALID_ENTITY_INSTANCE))
            {
                //
                // Matched our instance
                //
                
                pTdiIFEntity  = pTdiEntityList;
                
                break;
            }
            else
            {
                //
                // Take the max of the two
                //
                
                uiMyIFBase = uiMyIFBase > (pTdiEntityList->tei_instance + 1)?
                             uiMyIFBase : (pTdiEntityList->tei_instance + 1);
                
            }
        }
	}

    RtAcquireSpinLock(&(pTunnel->rlLock),
                      &kiIrql);

    if(pTdiIFEntity is NULL )
    {
        //
        // we are not on the list.
        // make sure we have the room for it.
        //
        
        if (*puiCount >= MAX_TDI_ENTITIES)
        {
            return FALSE;
        }
    
        pTunnel->dwIfInstance = uiMyIFBase;

        //
        // Now fill it in.
        //
        
        pTdiEntityList->tei_entity   = IF_ENTITY;
        pTdiEntityList->tei_instance = uiMyIFBase;
        
        (*puiCount)++;
        
    }
    else
    {
        if(pTunnel->dwAdminState & TS_DELETING)
        {
            pTunnel->dwIfInstance        = INVALID_ENTITY_INSTANCE;
            pTdiEntityList->tei_instance = INVALID_ENTITY_INSTANCE;
        }
    }

    RtReleaseSpinLock(&(pTunnel->rlLock),
                      kiIrql);

    return TRUE;
}



INT
IpIpBindAdapter(
    IN  PNDIS_STATUS  pnsRetStatus,
    IN  NDIS_HANDLE   nhBindContext,
    IN  PNDIS_STRING  pnsAdapterName,
    IN  PVOID         pvSS1,
    IN  PVOID         pvSS2
    )

/*++

Routine Description
  
    Called by IP to bind an adapter.

Locks
  
    The routine acquires the global adapter list lock, so it is not
    PAGEABLE.

Arguments


Return Value


--*/

{
#if 0

    DWORD           fFlags;
    PTUNNEL         pNewTunnel;          // Newly created adapter block.
    UNICODE_STRING  usTempUnicodeString;
    NTSTATUS        nStatus;
    KIRQL           irql;
    
#if DBG
    
    ANSI_STRING     asTempAnsiString;
    
#endif

    TraceEnter(TUNN, "IpIpBindAdapter");
    
    //
    // All our adapter names must be upper case
    //

    //
    // Increase length so we have space to null terminate
    //

    pnsAdapterName->Length += sizeof(WCHAR);

    //
    // Allocate memory for the string, instead of passing TRUE to RtlUpcase
    // because that allocates from the heap
    //

    usTempUnicodeString.Buffer = RtAllocate(NonPagedPool,
                                            pnsAdapterName->Length,
                                            STRING_TAG);

    if(usTempUnicodeString.Buffer is NULL)
    {
        Trace(TUNN, ERROR,
              ("IpIpBindAdapter: Unable to allocate %d bytes\n",
               pnsAdapterName->Length));


        return STATUS_INSUFFICIENT_RESOURCES;
    }

    usTempUnicodeString.MaximumLength = pnsAdapterName->Length;

#if DBG

    asTempAnsiString.Buffer = RtAllocate(NonPagedPool,
                                         (pnsAdapterName->Length + 1)/2,
                                         STRING_TAG);

    if(asTempAnsiString.Buffer is NULL)
    {
        Trace(TUNN, ERROR,
              ("IpIpBindAdapter: Unable to allocate %d bytes\n",
               (pnsAdapterName->Length + 1)/2));


        RtFree(usTempUnicodeString.Buffer);

        usTempUnicodeString.MaximumLength = 0;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    asTempAnsiString.MaximumLength = (pnsAdapterName->Length + 1)/2;

#endif

    RtlUpcaseUnicodeString(&usTempUnicodeString,
                           pnsAdapterName,
                           FALSE);

    pnsAdapterName->Length -= sizeof(WCHAR);


    //
    // Null terminate the temp string
    //

    usTempUnicodeString.Buffer[usTempUnicodeString.MaximumLength/sizeof(WCHAR) - 1] = UNICODE_NULL;

#if DBG

    //
    // This must be run at PASSIVE
    //

    RtlUnicodeStringToAnsiString(&asTempAnsiString,
                                 &usTempUnicodeString,
                                 FALSE);

    asTempAnsiString.Length -= sizeof(CHAR);
    
#endif

    usTempUnicodeString.Length -= sizeof(WCHAR);
    
    Trace(TUNN, INFO,
          ("IpIpBindAdapter: IP called to bind to adapter %S\n",
           usTempUnicodeString.Buffer));

    //
    // Lock the TUNNEL list - since we may be adding
    //

    EnterWriter(&g_rwlTunnelLock,
                &irql);

    //
    // Since we dont NdisOpenAdapter on the bindings we may
    // get duplicates. Check if this has already been indicated
    //
    
    if(IsBindingPresent(&usTempUnicodeString))
    {
        ExitWriter(&g_rwlTunnelLock,
                   irql);

        Trace(TUNN, WARN,
              ("IpIpBindAdapter: Adapter %S already present\n",
               usTempUnicodeString.Buffer));

        *pnsRetStatus = NDIS_STATUS_SUCCESS;

        RtFree(usTempUnicodeString.Buffer);

        usTempUnicodeString.MaximumLength = 0;

#if DBG
        
        RtFree(asTempAnsiString.Buffer);

        asTempAnsiString.MaximumLength = 0;
        
#endif

        TraceLeave(TUNN, "IpIpBindAdapter");
        
        return (int) TRUE;
    }


    pNewTunnel = NULL;

#if DBG
    
    nStatus = CreateTunnel(&usTempUnicodeString,
                           &pNewTunnel,
                           &asTempAnsiString);
    
#else
    
    nStatus = CreateTunnel(&usTempUnicodeString,
                           &pNewTunnel);
    
#endif

    ExitWriter(&g_rwlTunnelLock,
               irql);
    

#if DBG

    RtFree(asTempAnsiString.Buffer);

    asTempAnsiString.MaximumLength = 0;

#endif


    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("IpIpBindAdapter: CreateTunnel failed with  error %x for %w\n",
               nStatus,
               usTempUnicodeString.Buffer));

        *pnsRetStatus = NDIS_STATUS_FAILURE;

        RtFree(usTempUnicodeString.Buffer);

        usTempUnicodeString.MaximumLength = 0;

        TraceLeave(TUNN, "IpIpBindAdapter");
        
        return (int) TRUE;
    }

    InterlockedIncrement(&g_ulNumTunnels);

    //
    // The tunnel has been created with a ref count of 2
    //
    
    RtAssert(pNewTunnel);

    //
    // At this point the TUNNEL is ref counted , but not locked
    // We add it to IP (and keep a ref count because IP has a pointer to
    // the structure)
    //
    
    if(AddInterfaceToIP(pNewTunnel, 
                        &usTempUnicodeString, 
                        pvSS1, 
                        pvSS2) isnot STATUS_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("IpIpBindAdapter: Add interface to IP failed for adapter %S\n",
               usTempUnicodeString.Buffer));

        //
        // Remove the TUNNEL from the list
        //

        EnterWriter(&g_rwlTunnelLock,
                    &irql);
        
        RemoveEntryList(&(pNewTunnel->leTunnelLink));

        ExitWriter(&g_rwlTunnelLock,
                   irql);

        //
        // Since one ref count was kept because the list had a pointer,
        // deref it once
        //

        DereferenceTunnel(pNewTunnel);
        
        *pnsRetStatus = NDIS_STATUS_FAILURE;
    }
    else
    {
        //
        // We are done with the
        //
        
        *pnsRetStatus = NDIS_STATUS_SUCCESS;

        //
        // The tunnel was added to IP, so increment the ref count
        //
        
        ReferenceTunnel(pNewTunnel);
        
        Trace(TUNN, TRACE,
              ("IpIpBindAdapter: Successfully bound to adapter %ws\n",
               usTempUnicodeString.Buffer));
    }

    //
    // This bit of code is done with the TUNNEL.
    // If everything succeeded, the the current refcount is 3
    // One is because it is on the TUNNEL list, the second because it
    // is with IP and ofcourse the third because of this code
    // So we deref it here and the refcount is 2, as it should be
    //
    // If the add to IP failed, then the refcount is 1 (because we would
    // never incremented it for adding it to IP, and RemoveTunnel() would
    // have decremented the refcount by 1
    // So derefing it here will free the memory
    //
    
    DereferenceTunnel(pNewTunnel);

    RtFree(usTempUnicodeString.Buffer);

    usTempUnicodeString.MaximumLength = 0;

    TraceLeave(TUNN, "IpIpBindAdapter");

    return (int) TRUE;
}

NTSTATUS
AddInterfaceToIP(
    IN  PTUNNEL      pTunnel,
    IN  PNDIS_STRING pnsName,
    IN  PVOID        pvSystemSpecific1,
    IN  PVOID        pvSystemSpecific2
    )

/*++

Routine Description
  
    Adds an interface to IP. We add one interface for every adapter
    Code is pageable hence must be called at PASSIVE

Locks

    The TUNNEL must be ref counted BUT NOT LOCKED

Arguments

    

Return Value


--*/

{
    LLIPBindInfo    BindInfo;
    IP_STATUS       IPStatus;
    NDIS_STRING     IPConfigName = NDIS_STRING_CONST("IPConfig");
    NDIS_STRING     nsRemoteAddrName = NDIS_STRING_CONST("RemoteAddress");
    NDIS_STRING     nsLocalAddrName  = NDIS_STRING_CONST("LocalAddress");
    NDIS_STATUS     nsStatus;
    NDIS_HANDLE     nhConfigHandle;
 
    PNDIS_CONFIGURATION_PARAMETER   pParam;

    PAGED_CODE();
    
    TraceEnter(TUNN, "AddInterfaceToIP");

    //
    // Open the key for this "adapter"
    //
    
    NdisOpenProtocolConfiguration(&nsStatus,
                                  &nhConfigHandle,
                                  (PNDIS_STRING)pvSystemSpecific1);

    if(nsStatus isnot NDIS_STATUS_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("AddInterfaceToIP: Unable to Open Protocol Configuration %x\n",
               nsStatus));

        TraceLeave(TUNN, "AddInterfaceToIP");

        return nsStatus;
    }

    //
    //  Read in the IPConfig string. If this is not present,
    //  fail this call.
    //

    NdisReadConfiguration(&nsStatus,
                          &pParam,
                          nhConfigHandle,
                          &IPConfigName,
                          NdisParameterMultiString);

    if((nsStatus isnot NDIS_STATUS_SUCCESS) or
       (pParam->ParameterType isnot NdisParameterMultiString))
    {
        Trace(TUNN, ERROR,
              ("AddInterfaceToIP: Unable to Read Configuration. Status %x \n",
               nsStatus));

        NdisCloseConfiguration(nhConfigHandle);

        TraceLeave(TUNN, "AddInterfaceToIP");

        return STATUS_UNSUCCESSFUL;
    }

        
    //
    // We add one interface per adapter for IP
    //

    BindInfo.lip_context    = pTunnel;
    BindInfo.lip_mss        = pTunnel->ulMtu;
    BindInfo.lip_speed      = DEFAULT_SPEED;

    //
    // Our "ARP" header is an IPHeader
    //
    
    BindInfo.lip_txspace    = sizeof(IPHeader);

    BindInfo.lip_transmit   = IpIpSend;
    BindInfo.lip_transfer   = IpIpTransferData;
    BindInfo.lip_returnPkt  = IpIpReturnPacket;
    BindInfo.lip_close      = IpIpCloseAdapter;
    BindInfo.lip_addaddr    = IpIpAddAddress;
    BindInfo.lip_deladdr    = IpIpDeleteAddress;
    BindInfo.lip_invalidate = IpIpInvalidateRce;
    BindInfo.lip_open       = IpIpOpenAdapter;
    BindInfo.lip_qinfo      = IpIpQueryInfo;
    BindInfo.lip_setinfo    = IpIpSetInfo;
    BindInfo.lip_getelist   = IpIpGetEntityList;
    BindInfo.lip_flags      = LIP_COPY_FLAG | LIP_NOIPADDR_FLAG | LIP_P2P_FLAG;
    BindInfo.lip_addrlen    = ARP_802_ADDR_LENGTH;
    BindInfo.lip_addr       = pTunnel->rgbyHardwareAddr;

    BindInfo.lip_dowakeupptrn = NULL;
    BindInfo.lip_pnpcomplete  = NULL;
    BindInfo.lip_OffloadFlags = 0;

    BindInfo.lip_arpflushate    = NULL;
    BindInfo.lip_arpflushallate = NULL;
    BindInfo.lip_setndisrequest = NULL;

    IPStatus = g_pfnIpAddInterface(pnsName,
                                   &(pParam->ParameterData.StringData),
                                   NULL,
                                   pTunnel,
                                   IpIpDynamicRegister,
                                   &BindInfo,
                                   0);

    NdisCloseConfiguration(nhConfigHandle);

    if(IPStatus isnot IP_SUCCESS)
    {
        //
        // NB: freeing of resources not done.
        //
        
        Trace(TUNN, ERROR,
              ("AddInterfaceToIP: IPAddInterface failed for %w\n",
               pTunnel->usBindName.Buffer));

        TraceLeave(TUNN, "AddInterfaceToIP");

        return STATUS_UNSUCCESSFUL;
    }

    Trace(TUNN, TRACE,
          ("IPAddInterface succeeded for adapter %w\n",
           pTunnel->usBindName.Buffer));

    TraceLeave(TUNN, "AddInterfaceToIP");

#endif // 0

    return STATUS_SUCCESS;
}

NTSTATUS
IpIpCreateAdapter(
    IN  PIPINIP_CREATE_TUNNEL   pCreateInfo,
    IN  USHORT                  usKeyLength,
    OUT PDWORD                  pdwIfIndex
    )

/*++

Routine Description
  
    Our dynamic interface creation routine. Looks a bit like a bindadapter
    call

Locks
  
    The routine acquires the global adapter list lock, so it is not
    PAGEABLE.

Arguments

    pCreateInfo     Info from the ioctl
    usKeyLength     Length in bytes of the pwszKeyName (without the NULL)
    
Return Value

    STATUS_OBJECT_NAME_EXISTS

--*/

{
    DWORD           fFlags;
    PTUNNEL         pNewTunnel;
    UNICODE_STRING  usTempUnicodeString;
    NTSTATUS        nStatus;
    KIRQL           irql;
    USHORT          usOldLength;
    PWCHAR          pwszBuffer;

#if DBG
    
    ANSI_STRING     asTempAnsiString;
    
#endif

    TraceEnter(TUNN, "IpIpCreateAdapter");

    nStatus = RtlStringFromGUID(&(pCreateInfo->Guid),
                                &usTempUnicodeString);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("IpIpCreateAdapter: Unable to create GUID\n"));

        TraceLeave(TUNN, "IpIpCreateAdapter");

        return nStatus;
    }

    //
    // Now create a non-paged buffer to store the GUID string. This is because
    // the Rtl routines allocate memory from heap
    //

    usOldLength = usTempUnicodeString.Length;

    RtAssert((usOldLength % sizeof(WCHAR)) == 0);

    pwszBuffer = RtAllocate(NonPagedPool,
                            usOldLength + sizeof(WCHAR),
                            STRING_TAG);

    if(pwszBuffer is NULL)
    {
        Trace(TUNN, ERROR,
              ("IpIpCreateAdapter: Unable to allocate %d bytes\n",
               usOldLength + sizeof(WCHAR)));

        RtlFreeUnicodeString(&usTempUnicodeString);

        TraceLeave(TUNN, "IpIpCreateAdapter");

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(pwszBuffer,
                  usTempUnicodeString.Buffer,
                  usOldLength);

    //
    // Zero out the last bit
    //

    pwszBuffer[usOldLength/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Now free the old string, make usTempUnicodeString point to this
    // non paged buffer
    //

    RtlFreeUnicodeString(&usTempUnicodeString);

    usTempUnicodeString.Buffer          = pwszBuffer;
    usTempUnicodeString.MaximumLength   = usOldLength + sizeof(WCHAR);
    usTempUnicodeString.Length          = usOldLength;
    
    //
    // Increase the length of the unicode string so that
    // the ansi string is null terminated
    //

    usTempUnicodeString.Length += sizeof(WCHAR);
    
#if DBG

    //
    // This must be run at PASSIVE
    //

    asTempAnsiString.Buffer = RtAllocate(NonPagedPool,
                                         usTempUnicodeString.MaximumLength,
                                         STRING_TAG);

    if(asTempAnsiString.Buffer is NULL)
    {
        Trace(TUNN, ERROR,
              ("IpIpCreateAdapter: Unable to allocate %d bytes\n",
               usTempUnicodeString.MaximumLength));

        RtFree(usTempUnicodeString.Buffer);

        usTempUnicodeString.Buffer          = NULL;
        usTempUnicodeString.MaximumLength   = 0;
        usTempUnicodeString.Length          = 0;

        TraceLeave(TUNN, "IpIpCreateAdapter");

        return STATUS_INSUFFICIENT_RESOURCES;
    }

         
    RtlUnicodeStringToAnsiString(&asTempAnsiString,
                                 &usTempUnicodeString,
                                 FALSE);

    asTempAnsiString.Length -= sizeof(CHAR);
    
#endif

    usTempUnicodeString.Length -= sizeof(WCHAR);
    
    Trace(TUNN, INFO,
          ("IpIpCreateAdapter: IP called to bind to adapter %S\n",
           usTempUnicodeString.Buffer));

    //
    // Lock the TUNNEL list - since we may be adding
    //

    EnterWriter(&g_rwlTunnelLock,
                &irql);

    //
    // Make sure this is not a duplicate
    //
    
    if(IsBindingPresent(&usTempUnicodeString))
    {
        ExitWriter(&g_rwlTunnelLock,
                   irql);

        Trace(TUNN, WARN,
              ("IpIpCreateAdapter: Adapter %S already present\n",
               usTempUnicodeString.Buffer));

#if DBG
        
        RtFree(asTempAnsiString.Buffer);

        asTempAnsiString.Buffer          = NULL;
        asTempAnsiString.MaximumLength   = 0;
        asTempAnsiString.Length          = 0;
        
#endif

        RtFree(usTempUnicodeString.Buffer);

        usTempUnicodeString.Buffer          = NULL;
        usTempUnicodeString.MaximumLength   = 0;
        usTempUnicodeString.Length          = 0;

        TraceLeave(TUNN, "IpIpCreateAdapter");
        
        return STATUS_OBJECT_NAME_EXISTS;
    }


    pNewTunnel = NULL;

#if DBG
    
    nStatus = CreateTunnel(&usTempUnicodeString,
                           &pNewTunnel,
                           &asTempAnsiString);
    
#else
    
    nStatus = CreateTunnel(&usTempUnicodeString,
                           &pNewTunnel);
    
#endif

    ExitWriter(&g_rwlTunnelLock,
               irql);
    

#if DBG

    RtFree(asTempAnsiString.Buffer);

    asTempAnsiString.Buffer          = NULL;
    asTempAnsiString.MaximumLength   = 0;
    asTempAnsiString.Length          = 0;

#endif

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("IpIpCreateAdapter: CreateTunnel failed with  error %x for %w\n",
               nStatus,
               usTempUnicodeString.Buffer));

        RtFree(usTempUnicodeString.Buffer);

        usTempUnicodeString.Buffer          = NULL;
        usTempUnicodeString.MaximumLength   = 0;
        usTempUnicodeString.Length          = 0;
        
        TraceLeave(TUNN, "IpIpCreateAdapter");

        return nStatus;
    }

    InterlockedIncrement(&g_ulNumTunnels);

    //
    // The tunnel has been created with a ref count of 2
    //
    
    RtAssert(pNewTunnel);

    //
    // At this point the TUNNEL is ref counted , but not locked
    // We add it to IP (and keep a ref count because IP has a pointer to
    // the structure)
    //

    nStatus = AddInterfaceToIP2(pNewTunnel, 
                                &usTempUnicodeString);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("IpIpCreateAdapter: Add interface to IP failed for adapter %S\n",
               usTempUnicodeString.Buffer));

        //
        // Remove the TUNNEL from the list
        //

        EnterWriter(&g_rwlTunnelLock,
                    &irql);
        
        RemoveEntryList(&(pNewTunnel->leTunnelLink));

        ExitWriter(&g_rwlTunnelLock,
                   irql);

        //
        // Since one ref count was kept because the list had a pointer,
        // deref it once
        //

        DereferenceTunnel(pNewTunnel);
    }
    else
    {

        //
        // The tunnel was added to IP, so increment the ref count
        //
        
        ReferenceTunnel(pNewTunnel);
        
        Trace(TUNN, TRACE,
              ("IpIpCreateAdapter: Successfully bound to adapter %ws\n",
               usTempUnicodeString.Buffer));
    }

    *pdwIfIndex = pNewTunnel->dwIfIndex;

    //
    // This bit of code is done with the TUNNEL.
    // If everything succeeded, the the current refcount is 3
    // One is because it is on the TUNNEL list, the second because it
    // is with IP and ofcourse the third because of this code
    // So we deref it here and the refcount is 2, as it should be
    //
    // If the add to IP failed, then the refcount is 1 (because we would
    // never incremented it for adding it to IP, and RemoveTunnel() would
    // have decremented the refcount by 1
    // So derefing it here will free the memory
    //
    
    DereferenceTunnel(pNewTunnel);

    RtFree(usTempUnicodeString.Buffer);

    usTempUnicodeString.Buffer          = NULL;
    usTempUnicodeString.MaximumLength   = 0;
    usTempUnicodeString.Length          = 0;

    TraceLeave(TUNN, "IpIpCreateAdapter");

    return nStatus;
}


NTSTATUS
AddInterfaceToIP2(
    IN  PTUNNEL      pTunnel,
    IN  PNDIS_STRING pnsName
    )

/*++

Routine Description
  
    Adds an interface to IP. We add one interface for every adapter
    Code is pageable hence must be called at PASSIVE

Locks

    The TUNNEL must be ref counted BUT NOT LOCKED

Arguments

    

Return Value


--*/

{
    LLIPBindInfo    BindInfo;
    IP_STATUS       IPStatus;
    NDIS_STRING     nsIPConfigKey, nsIfName;
    NDIS_STATUS     nsStatus;
    ULONG           ulKeyLen, ulPrefixLen;
    PWCHAR          pwszKeyBuffer, pwszNameBuffer;
 
    PAGED_CODE();
    
    TraceEnter(TUNN, "AddInterfaceToIP2");

    //
    // Fake the key for the adapter
    //

    ulPrefixLen = wcslen(TCPIP_INTERFACES_KEY);
    
    ulKeyLen  = pnsName->Length + ((ulPrefixLen + 1) * sizeof(WCHAR));
    
    pwszKeyBuffer = RtAllocate(NonPagedPool,
                               ulKeyLen,
                               TUNNEL_TAG);

    if(pwszKeyBuffer is NULL)
    {
        Trace(TUNN, ERROR,
              ("AddInterfaceToIP2: Couldnt allocate %d bytes of paged pool\n",
               ulKeyLen));

        return STATUS_INSUFFICIENT_RESOURCES;
    }
     
    RtlZeroMemory(pwszKeyBuffer,
                  ulKeyLen);

    nsIPConfigKey.MaximumLength = (USHORT)ulKeyLen;
    nsIPConfigKey.Length        = (USHORT)ulKeyLen - sizeof(WCHAR);
    nsIPConfigKey.Buffer        = pwszKeyBuffer;

    //
    // Copy over the prefix
    //

    RtlCopyMemory(pwszKeyBuffer,
                  TCPIP_INTERFACES_KEY,
                  ulPrefixLen * sizeof(WCHAR));

    //
    // Cat the name
    //
    
    RtlCopyMemory(&(pwszKeyBuffer[ulPrefixLen]),
                  pnsName->Buffer,
                  pnsName->Length);
   
    //
    // TCPIP expects the name of the interface to be of the type \Device\<Name>
    // The name in pnsName is only <Name>, so create a new string
    //

    ulPrefixLen = wcslen(TCPIP_IF_PREFIX);

    ulKeyLen  = pnsName->Length + ((ulPrefixLen + 1) * sizeof(WCHAR));

    pwszNameBuffer = RtAllocate(NonPagedPool,
                                ulKeyLen,
                                TUNNEL_TAG);

    if(pwszNameBuffer is NULL)
    {
        Trace(TUNN, ERROR,
              ("AddInterfaceToIP2: Couldnt allocate %d bytes for name\n",
               ulKeyLen));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pwszNameBuffer,
                  ulKeyLen);

    nsIfName.MaximumLength = (USHORT)ulKeyLen;
    nsIfName.Length        = (USHORT)ulKeyLen - sizeof(WCHAR);
    nsIfName.Buffer        = pwszNameBuffer;

    //
    // Start with \Device\
    //

    RtlCopyMemory(pwszNameBuffer,
                  TCPIP_IF_PREFIX,
                  ulPrefixLen * sizeof(WCHAR));

    //
    // Cat the name
    //

    RtlCopyMemory(&(pwszNameBuffer[ulPrefixLen]),
                  pnsName->Buffer,
                  pnsName->Length);


    RtlZeroMemory(&BindInfo, 
                  sizeof(LLIPBindInfo));
 
    //
    // We add one interface per adapter for IP
    //

    BindInfo.lip_context    = pTunnel;
    BindInfo.lip_mss        = pTunnel->ulMtu;
    BindInfo.lip_speed      = DEFAULT_SPEED;

    //
    // Our "ARP" header is an IPHeader
    //
    
    BindInfo.lip_txspace    = sizeof(IPHeader);

    BindInfo.lip_transmit   = IpIpSend;
    BindInfo.lip_transfer   = IpIpTransferData;
    BindInfo.lip_returnPkt  = IpIpReturnPacket;
    BindInfo.lip_close      = IpIpCloseAdapter;
    BindInfo.lip_addaddr    = IpIpAddAddress;
    BindInfo.lip_deladdr    = IpIpDeleteAddress;
    BindInfo.lip_invalidate = IpIpInvalidateRce;
    BindInfo.lip_open       = IpIpOpenAdapter;
    BindInfo.lip_qinfo      = IpIpQueryInfo;
    BindInfo.lip_setinfo    = IpIpSetInfo;
    BindInfo.lip_getelist   = IpIpGetEntityList;
    BindInfo.lip_flags      = LIP_NOIPADDR_FLAG | LIP_P2P_FLAG | LIP_COPY_FLAG;
    BindInfo.lip_addrlen    = ARP_802_ADDR_LENGTH;
    BindInfo.lip_addr       = pTunnel->rgbyHardwareAddr;

    BindInfo.lip_dowakeupptrn = NULL;
    BindInfo.lip_pnpcomplete  = NULL;

    BindInfo.lip_setndisrequest = IpIpSetRequest;

    IPStatus = g_pfnIpAddInterface(&nsIfName,
                                   NULL,
                                   &nsIPConfigKey,
                                   NULL,
                                   pTunnel,
                                   IpIpDynamicRegister,
                                   &BindInfo,
                                   0,
                                   IF_TYPE_TUNNEL,
                                   IF_ACCESS_POINTTOPOINT,
                                   IF_CONNECTION_DEDICATED);

    RtFree(pwszKeyBuffer);
    RtFree(pwszNameBuffer);
        
    if(IPStatus isnot IP_SUCCESS)
    {
        Trace(TUNN, ERROR,
              ("AddInterfaceToIP2: IPAddInterface failed for %w\n",
               pTunnel->usBindName.Buffer));

        TraceLeave(TUNN, "AddInterfaceToIP2");

        return STATUS_UNSUCCESSFUL;
    }

    Trace(TUNN, TRACE,
          ("IPAddInterface succeeded for adapter %w\n",
           pTunnel->usBindName.Buffer));

    TraceLeave(TUNN, "AddInterfaceToIP2");

    return STATUS_SUCCESS;
}


INT
IpIpDynamicRegister(
    IN  PNDIS_STRING            InterfaceName,
    IN  PVOID                   pvIpInterfaceContext,
    IN  struct _IP_HANDLERS *   IpHandlers,
    IN  struct LLIPBindInfo *   ARPBindInfo,
    IN  UINT                    uiInterfaceNumber
    )
{
    PTUNNEL pTunnel;
    KIRQL   irql;

    
    TraceEnter(TUNN, "DynamicRegisterIp");

    
    pTunnel = (PTUNNEL)(ARPBindInfo->lip_context);

    RtAcquireSpinLock(&(pTunnel->rlLock),
                      &irql);
    
#if DBG
    
    Trace(TUNN, INFO,
          ("IP called out to dynamically register %s\n",
           pTunnel->asDebugBindName.Buffer));
    
#endif

    pTunnel->pvIpContext = pvIpInterfaceContext;
    pTunnel->dwIfIndex   = uiInterfaceNumber;

    if(g_pfnIpRcv is NULL)
    {
        g_pfnIpRcv          = IpHandlers->IpRcvHandler;
        g_pfnIpRcvComplete  = IpHandlers->IpRcvCompleteHandler;
        g_pfnIpSendComplete = IpHandlers->IpTxCompleteHandler;
        g_pfnIpTDComplete   = IpHandlers->IpTransferCompleteHandler;
        g_pfnIpStatus       = IpHandlers->IpStatusHandler;
        g_pfnIpRcvPkt       = IpHandlers->IpRcvPktHandler;
        g_pfnIpPnp          = IpHandlers->IpPnPHandler;
    }

    RtReleaseSpinLock(&(pTunnel->rlLock),
                      irql);
    
    TraceLeave(TUNN, "DynamicRegisterIp");

    return TRUE;
}

BOOLEAN
IsBindingPresent(
    IN  PUNICODE_STRING pusBindName
    )

/*++

Routine Description
    
    Code to catch duplicate bind notifications

Locks
    
    Must be called with the g_rwlTunnelLock held as READER

Arguments


Return Value
    
    TRUE    if an adapter with a matching name was found
    FALSE   otherwise

--*/

{
    BOOLEAN     bFound;
    PTUNNEL     pTunnel;
    PLIST_ENTRY pleNode;

    bFound = FALSE;

    for(pleNode  = g_leTunnelList.Flink;
        pleNode != &g_leTunnelList;
        pleNode  = pleNode->Flink)
    {
        pTunnel = CONTAINING_RECORD(pleNode, TUNNEL, leTunnelLink);

        if(CompareUnicodeStrings(&(pTunnel->usBindName),
                                 pusBindName))
        {
            bFound = TRUE;

            break;
        }
    }

    return bFound;
}



#if DBG

NTSTATUS
CreateTunnel(
    IN  PNDIS_STRING            pnsBindName,
    OUT TUNNEL                  **ppNewTunnel,
    IN  PANSI_STRING            pasAnsiName
    )

#else

NTSTATUS
CreateTunnel(
    IN  PNDIS_STRING            pnsBindName,
    OUT TUNNEL                  **ppNewTunnel
    )

#endif

/*++

Routine Description
  
    Creates and initializes an TUNNEL when we get a bind notification
    The tunnel is added to the tunnel list
  
Locks
  
    Must be called with the g_rwlTunnelLock held as WRITER

Arguments
      
    pnsBindName     Name of binding
    ppNewTunnel     Pointer to location to return a pointer to created
                    tunnel
    pasAnsiBindName Only in DBG versions. Binding name, as ANSI string

Return Value

    STATUS_SUCCESS
    STATUS_NO_MEMORY
    
--*/

{
    DWORD   dwSize;
    PBYTE   pbyBuffer;
    PTUNNEL pTunnel;
   
    PTDI_ADDRESS_IP pTdiIp; 
    
    TraceEnter(TUNN, "CreateTunnel");

    *ppNewTunnel = NULL;
    
    //
    // The size that one needs is the size of the adapter + the length of the
    // name.  Add 4 to help with alignment
    //
    
    dwSize = ALIGN_UP(sizeof(TUNNEL),ULONG) + 
             ALIGN_UP(pnsBindName->Length + sizeof(WCHAR), ULONG);

#if DBG

    //
    // For debug code we also store the adapter name in ANSI
    //

    dwSize += ALIGN_UP((pnsBindName->Length/sizeof(WCHAR)) + sizeof(CHAR),
                       ULONG);

#endif

    pTunnel = RtAllocate(NonPagedPool,
                         dwSize,
                         TUNNEL_TAG);
    
    if(pTunnel is NULL)
    {
        Trace(TUNN, ERROR,
              ("CreateTunnel: Failed to allocate memory\n"));

        TraceLeave(TUNN, "CreateTunnel");
        
        return STATUS_NO_MEMORY;
    }

    //
    // Clear all the fields out
    //
    
    RtlZeroMemory(pTunnel, 
                  dwSize);

    //
    // The Unicode name buffer starts at the end of the adapter structure.
    //
    
    pbyBuffer   = (PBYTE)pTunnel + sizeof(TUNNEL);

    //
    // We DWORD align it for better compare/copy
    //

    pbyBuffer   = ALIGN_UP_POINTER(pbyBuffer, ULONG);
    
    pTunnel->usBindName.Length        = pnsBindName->Length;
    pTunnel->usBindName.MaximumLength = pnsBindName->Length;
    pTunnel->usBindName.Buffer        = (PWCHAR)(pbyBuffer);

    RtlCopyMemory(pTunnel->usBindName.Buffer,
                  pnsBindName->Buffer,
                  pnsBindName->Length);

#if DBG

    //
    // The debug string comes after the UNICODE adapter name buffer
    //
    
    pbyBuffer = pbyBuffer + pnsBindName->Length + sizeof(WCHAR);
    pbyBuffer = ALIGN_UP_POINTER(pbyBuffer, ULONG);
    
    pTunnel->asDebugBindName.Buffer        = pbyBuffer;
    pTunnel->asDebugBindName.MaximumLength = pasAnsiName->MaximumLength;
    pTunnel->asDebugBindName.Length        = pasAnsiName->Length;
    

    RtlCopyMemory(pTunnel->asDebugBindName.Buffer,
                  pasAnsiName->Buffer,
                  pasAnsiName->Length);
    
#endif    
   
    //
    // Must be set to INVALID so that GetEntityList can work
    //

    pTunnel->dwATInstance = INVALID_ENTITY_INSTANCE;
    pTunnel->dwIfInstance = INVALID_ENTITY_INSTANCE;

    //
    // Set the admin state to UP, but mark the interface unmapped
    //

    pTunnel->dwAdminState = IF_ADMIN_STATUS_UP;
    pTunnel->dwOperState  = IF_OPER_STATUS_NON_OPERATIONAL;

    //
    // This hardware index is needed to generate the Unique ID that
    // DHCP uses.
    // NOTE - we dont have an index so all hardware addrs will be the same
    //

    BuildHardwareAddrFromIndex(pTunnel->rgbyHardwareAddr,
                               pTunnel->dwIfIndex);

    //
    // Initialize the lock for the tunnel
    //

    RtInitializeSpinLock(&(pTunnel->rlLock));

    InitRefCount(pTunnel);

    pTunnel->ulMtu    = DEFAULT_MTU;

    //
    // Initialize the TDI related stuff
    //
    
    pTunnel->tiaIpAddr.TAAddressCount = 1;
    
    pTunnel->tiaIpAddr.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pTunnel->tiaIpAddr.Address[0].AddressType   = TDI_ADDRESS_TYPE_IP;


    pTunnel->tciConnInfo.UserDataLength = 0;
    pTunnel->tciConnInfo.UserData       = NULL;
    pTunnel->tciConnInfo.OptionsLength  = 0;
    pTunnel->tciConnInfo.Options        = NULL;
    pTunnel->tciConnInfo.RemoteAddress  = &(pTunnel->tiaIpAddr);
    
    pTunnel->tciConnInfo.RemoteAddressLength = sizeof(pTunnel->tiaIpAddr);
    
    InitBufferPool(&(pTunnel->HdrBufferPool),
                   HEADER_BUFFER_SIZE,
                   0,
                   5,
                   0,
                   TRUE,
                   HEADER_TAG);

    InitPacketPool(&(pTunnel->PacketPool),
                   PACKET_RSVD_LENGTH,
                   0,
                   20,
                   0,
                   PACKET_TAG);
    
    //
    // Initialize the packet queue
    //

    InitializeListHead(&(pTunnel->lePacketQueueHead));
 
    InsertHeadList(&g_leTunnelList,
                   &(pTunnel->leTunnelLink));

    *ppNewTunnel = pTunnel;
    
    TraceLeave(TUNN, "CreateTunnel");
        
    return STATUS_SUCCESS;
}


VOID
DeleteTunnel(
    IN  PTUNNEL pTunnel
    )

/*++

Routine Description


Locks


Arguments


Return Value
    NO_ERROR

--*/

{
    TraceEnter(TUNN, "DeleteTunnel");

    Trace(TUNN, INFO,
          ("DeleteTunnel: Deleting tunnel 0x%x. Index %d\n",
           pTunnel, pTunnel->dwIfIndex));

    if(FreeBufferPool(&(pTunnel->HdrBufferPool)) is FALSE)
    {
        Trace(TUNN, ERROR,
              ("DeleteTunnel: Couldnt free buffer pool %x for tunnel %x\n",
               pTunnel,
               pTunnel->HdrBufferPool));

        RtAssert(FALSE);
    }

    RtFree(pTunnel);

    TraceLeave(TUNN, "DeleteTunnel");
}


PTUNNEL
FindTunnel(
    IN  PULARGE_INTEGER puliTunnelId
    )

/*++

Routine Description

    Routine to lookup tunnels given a TunnelId (which is a 64 bit integer
    created by concatenating the RemoteEnpoint Address and LocalEndpoint
    Address)

    The tunnel returned is refcounted and locked
    
Locks

    The g_rwlTunnelLock must be taken as READER
    
Arguments

    uliTunnelId  a 64 bit integer created by concatenating the RemoteEndpoint
                 Address and LocalEndpoint Address
                
Return Value

    Address of the TUNNEL if found
    NULL otherwise

--*/

{
    PLIST_ENTRY pleNode;
    PTUNNEL     pTunnel;

    for(pleNode = g_leTunnelList.Flink;
        pleNode isnot &g_leTunnelList;
        pleNode = pleNode->Flink)
    {
        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leTunnelLink);

        if(pTunnel->uliTunnelId.QuadPart is puliTunnelId->QuadPart)
        {
            RtAcquireSpinLockAtDpcLevel(&(pTunnel->rlLock));

            ReferenceTunnel(pTunnel);

            return pTunnel;
        }
    }

    return NULL;
}

PTUNNEL
FindTunnelGivenIndex(
    IN  DWORD   dwIfIndex
    )

/*++

Routine Description

    Routine to lookup tunnels given an IfIndex. This is a slow routine

    The tunnel returned is refcounted - BUT NOT LOCKED
    
Locks

    The g_rwlTunnelLock must be taken as READER
    
Arguments

    dwIfIndex   Interface Index of the tunnel

Return Value

    Address of the TUNNEL if found
    NULL otherwise

--*/

{
    PLIST_ENTRY pleNode;
    PTUNNEL     pTunnel;

    for(pleNode = g_leTunnelList.Flink;
        pleNode isnot &g_leTunnelList;
        pleNode = pleNode->Flink)
    {
        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leTunnelLink);

        if(pTunnel->dwIfIndex is dwIfIndex)
        {
            RtAcquireSpinLockAtDpcLevel(&(pTunnel->rlLock));

            ReferenceTunnel(pTunnel);

            return pTunnel;
        }
    }

    return NULL;
}

VOID
RemoveAllTunnels(
    VOID
    )

/*++

Routine Description

    Removes all the tunnels in the system.
    We remove the tunnel from the list and delete the corresponding 
    interface from IP, dereferencing the tunnel twice.

    If the tunnels is not being used any more, this should delete the tunnel

Locks

    This is called from the Unload handler so does not need any locks

Arguments

    None

Return Value

    None

--*/

{
    PLIST_ENTRY pleNode;
    PTUNNEL     pTunnel;

    while(!IsListEmpty(&g_leTunnelList))
    {
        pleNode = RemoveHeadList(&g_leTunnelList);

        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leTunnelLink);

        //
        // Deref the tunnel once for deleting it from the list
        //

        DereferenceTunnel(pTunnel);

        //
        // Delete the interface from IP
        //

        g_pfnIpDeleteInterface(pTunnel->pvIpContext,
                               TRUE);

        //
        // Dereference the tunnel for deleting it from IP
        //

        DereferenceTunnel(pTunnel);
    }

    g_ulNumTunnels = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\inc\ddipinip.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    private\inc\ddipinip.h

Abstract:

    Public IOCTLS and related structures for the IP in IP encapsulation
    driver
    See documentation for more details

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


#ifndef __DDIPINIP_H__
#define __DDIPINIP_H__

#ifndef ANY_SIZE
#define ANY_SIZE    1
#endif

#define IPINIP_SERVICE_NAME     "IPINIP"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Device Name - this string is the name of the device.  It is the name     //
// that should be passed to NtCreateFile when accessing the device.         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define DD_IPINIP_DEVICE_NAME  L"\\Device\\IPINIP"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Win32 Name - This is the (Unicode and NonUnicode) name exposed by Win32  //
// subsystem for the device. It is the name that should be passed to        //
// CreateFile(Ex) when opening the device.                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IPINIP_NAME        L"\\\\.\\IPINIP"
#define IPINIP_NAME_NUC     "\\\\.\\IPINIP"

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IOCTL code definitions and related structures                            //
// All the IOCTLs are synchronous                                           //
// All need administrator privilege                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define FSCTL_IPINIP_BASE     FILE_DEVICE_NETWORK

#define _IPINIP_CTL_CODE(function, method, access) \
    CTL_CODE(FSCTL_IPINIP_BASE, function, method, access)

#define MIN_IPINIP_CODE             0

#define CREATE_TUNNEL_CODE          (MIN_IPINIP_CODE)
#define DELETE_TUNNEL_CODE          (CREATE_TUNNEL_CODE     + 1)
#define SET_TUNNEL_INFO_CODE        (DELETE_TUNNEL_CODE     + 1)
#define GET_TUNNEL_TABLE_CODE       (SET_TUNNEL_INFO_CODE   + 1)
#define IPINIP_NOTIFICATION_CODE    (GET_TUNNEL_TABLE_CODE  + 1)

#define MAX_IPINIP_CODE             (IPINIP_NOTIFICATION_CODE)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to create a tunnel                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IOCTL_IPINIP_CREATE_TUNNEL \
    _IPINIP_CTL_CODE(CREATE_TUNNEL_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _IPINIP_CREATE_TUNNEL
{
    //
    // The index of the created tunnel
    //

    OUT DWORD   dwIfIndex;
    
    //
    // Name of the interface (must be a guid)
    //

    IN  GUID    Guid;
}IPINIP_CREATE_TUNNEL, *PIPINIP_CREATE_TUNNEL;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to delete a tunnel                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IOCTL_IPINIP_DELETE_TUNNEL \
    _IPINIP_CTL_CODE(DELETE_TUNNEL_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _IPINIP_DELETE_TUNNEL
{
    //
    // The index of the tunnel to remove
    //

    IN  DWORD   dwIfIndex;

}IPINIP_DELETE_TUNNEL, *PIPINIP_DELETE_TUNNEL;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The IOCTL used to set up a tunnel                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IOCTL_IPINIP_SET_TUNNEL_INFO \
    _IPINIP_CTL_CODE(SET_TUNNEL_INFO_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef struct _IPINIP_SET_TUNNEL_INFO
{
    //
    // Index as returned by the create call
    //

    IN  DWORD   dwIfIndex;

    //
    // The state the tunnel goes to after the set
    //

    OUT DWORD   dwOperationalState;

    //
    // Configuration
    //

    IN  DWORD   dwRemoteAddress;
    IN  DWORD   dwLocalAddress;
    IN  BYTE    byTtl;
}IPINIP_SET_TUNNEL_INFO, *PIPINIP_SET_TUNNEL_INFO;


#define IOCTL_IPINIP_GET_TUNNEL_TABLE \
    _IPINIP_CTL_CODE(GET_TUNNEL_TABLE_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)


typedef struct _TUNNEL_INFO
{
    OUT DWORD   dwIfIndex;
    OUT DWORD   dwRemoteAddress;
    OUT DWORD   dwLocalAddress;
    OUT DWORD   fMapped;
    OUT BYTE    byTtl;
}TUNNEL_INFO, *PTUNNEL_INFO;

typedef struct _IPINIP_TUNNEL_TABLE
{
    OUT ULONG         ulNumTunnels;
    OUT TUNNEL_INFO   rgTable[ANY_SIZE];
}IPINIP_TUNNEL_TABLE, *PIPINIP_TUNNEL_TABLE;

#define SIZEOF_BASIC_TUNNEL_TABLE   \
    (ULONG)(FIELD_OFFSET(IPINIP_TUNNEL_TABLE, rgTable[0]))

#define SIZEOF_TUNNEL_TABLE(X)      \
    SIZEOF_BASIC_TUNNEL_TABLE + ((X) * sizeof(TUNNEL_INFO))

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The asynchronous IOCTL used to receive state change notifications        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IOCTL_IPINIP_NOTIFICATION  \
    _IPINIP_CTL_CODE(IPINIP_NOTIFICATION_CODE,METHOD_BUFFERED,FILE_WRITE_ACCESS)

typedef enum _IPINIP_EVENT
{
    IE_INTERFACE_UP     = 0,
    IE_INTERFACE_DOWN   = 1,

}IPINIP_EVENT, *PIPINIP_EVENT;

typedef enum _IPINIP_SUB_EVENT
{
    ISE_ICMP_TTL_TOO_LOW = 0,
    ISE_DEST_UNREACHABLE = 1,

}IPINIP_SUB_EVENT, *PIPINIP_SUB_EVENT;

typedef struct _IPINIP_NOTIFICATION
{
    IPINIP_EVENT        ieEvent;

    IPINIP_SUB_EVENT    iseSubEvent;

    DWORD               dwIfIndex;

}IPINIP_NOTIFICATION, *PIPINIP_NOTIFICATION;

#endif // __DDIPINIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\bpdummy.c ===
#include "..\..\inc\bpool.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\dbgdummy.c ===
#include "..\..\inc\debug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\driver.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\driver.h

Abstract:

    Headers for driver.c

Revision History:


--*/


KTIMER   g_ktTimer;
KDPC     g_kdTimerDpc;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
IpIpDispatch(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

VOID
IpIpUnload(
    PDRIVER_OBJECT DriverObject
    );

BOOLEAN
SetupExternalName(
    PUNICODE_STRING  pusNtName,
    PWCHAR           pwcDosName,
    BOOLEAN          bCreate
    );

NTSTATUS
StartDriver(
    VOID
    );

VOID
StopDriver(
    VOID
    );

BOOLEAN
InitializeDriver(
    VOID
    );

NTSTATUS
RegisterWithIp(
    VOID
    );

VOID
DeregisterWithIp(
    VOID
    );

NTSTATUS
OpenRegKey(
    PHANDLE  HandlePtr,
    PWCHAR   KeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    );

BOOLEAN
EnterDriverCode(
    VOID
    );

VOID
ExitDriverCode(
    VOID
    );

VOID
ClearPendingIrps(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for the ARP module

Revision History:


Notes:

--*/

#ifndef __RT_DEBUG_H__
#define __RT_DEBUG_H__

VOID
RtInitializeDebug();

//
// Tags for Pools
//

#define FREE_TAG                'rfII'
#define DATA_TAG                'tdII'
#define TUNNEL_TAG              'nTII'
#define HEADER_TAG              'dhII'
#define PACKET_TAG              'kpII'
#define SEND_CONTEXT_TAG        'csII'
#define TRANSFER_CONTEXT_TAG    'ctII'
#define QUEUE_NODE_TAG          'qwII'
#define MESSAGE_TAG             'gmII'
#define STRING_TAG              'rsII'


//
// File signatures for everyone
//

#define DEBUG_SIG       'gbed'
#define DRIVER_SIG      'rvrd'
#define BPOOL_SIG       'lopb'
#define PPOOL_SIG       'lopp'
#define ADAPTER_SIG     'tpdA'
#define SEND_SIG        'dnes'
#define TDIX_SIG        'xidt'
#define IOCT_SIG        'tcoi'
#define ICMP_SIG        'pmci'

//
// We use the RT_XXX_DEBUG flags so that we can force to
// different debug modes on free builds by changing sources.
// On a checked build, all debugging is on
//

#if DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  1
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   1
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    1
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    1
#endif

#else // DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  0
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   0
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    0
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    0
#endif

#endif // DBG


#if RT_ASSERT_ON

#define RtAssert(X)                                             \
{                                                               \
    if(!(X))                                                    \
    {                                                           \
        DbgPrint("[IPINIP] Assertion failed in %s at line %d\n",\
                 __FILE__,__LINE__);                            \
        DbgPrint("IPINIP: Assertion " #X "\n");                 \
        DbgBreakPoint();                                        \
    }                                                           \
}

#else   // RT_ASSERT_ON

#define RtAssert(X)

#endif


#if RT_TRACE_DEBUG

BYTE    g_byDebugLevel;
DWORD   g_fDebugComp;


#define IPINIP_STREAM_GLOBAL        0x00000001
#define IPINIP_STREAM_SEND          0x00000002
#define IPINIP_STREAM_RCV           0x00000004
#define IPINIP_STREAM_UTIL          0x00000008
#define IPINIP_STREAM_MEMORY        0x00000010
#define IPINIP_STREAM_TUNN          0x00000020
#define IPINIP_STREAM_TDI           0x00000040

#define RT_DBG_LEVEL_NONE           0xFF
#define RT_DBG_LEVEL_FATAL          0xF0
#define RT_DBG_LEVEL_ERROR          0xE0
#define RT_DBG_LEVEL_WARN           0xD0
#define RT_DBG_LEVEL_INFO           0xC0
#define RT_DBG_LEVEL_TRACE          0xB0

#define Trace(Stream, Level, Str)                   \
{                                                   \
    if ((RT_DBG_LEVEL_##Level >= RT_DBG_LEVEL_ERROR) ||             \
        ((RT_DBG_LEVEL_##Level >= g_byDebugLevel) &&                    \
         ((g_fDebugComp & IPINIP_STREAM_##Stream) == IPINIP_STREAM_##Stream)))\
    {                                               \
        DbgPrint("[IPINIP] ");                      \
        DbgPrint Str;                               \
    }                                               \
}

#define TraceEnter(Stream, Str) Trace(Stream, TRACE, ("Entering "Str"\n"))
#define TraceLeave(Stream, Str) Trace(Stream, TRACE, ("Leaving "Str"\n"))

#else   // RT_TRACE_DEBUG

#define Trace(Stream, Level, Str)

#define TraceEnter(Stream, Str)
#define TraceLeave(Stream, Str)

#endif // RT_TRACE_DEBUG



#if RT_LOCK_DEBUG

extern KSPIN_LOCK  g_ksLockLock;

#ifndef __FILE_SIG__
#error File signature not defined
#endif

typedef struct _RT_LOCK
{
	ULONG		ulLockSig;
	BOOLEAN     bAcquired;
	PKTHREAD    pktLastThread;
	ULONG       ulFileSig;
	ULONG		ulLineNumber;
	KSPIN_LOCK  kslLock;
}RT_LOCK, *PRT_LOCK;


VOID
RtpInitializeSpinLock(
    IN  PRT_LOCK    pLock,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber
    );

VOID
RtpAcquireSpinLock(
    IN  PRT_LOCK    pLock,
    OUT PKIRQL      pkiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bAtDpc
    );

VOID
RtpReleaseSpinLock(
    IN  PRT_LOCK    pLock,
    IN  KIRQL       kiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bFromDpc
    );

#define RT_LOCK_SIG	'KCOL'


#define RtInitializeSpinLock(X)        RtpInitializeSpinLock((X), __FILE_SIG__, __LINE__)

#define RtAcquireSpinLock(X, Y)        RtpAcquireSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtAcquireSpinLockAtDpcLevel(X) RtpAcquireSpinLock((X), NULL, __FILE_SIG__, __LINE__, TRUE)

#define RtReleaseSpinLock(X, Y)        RtpReleaseSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtReleaseSpinLockFromDpcLevel(X) RtpReleaseSpinLock((X), 0, __FILE_SIG__, __LINE__, TRUE)


#else   // RT_LOCK_DEBUG


typedef KSPIN_LOCK  RT_LOCK, *PRT_LOCK;

#define RtInitializeSpinLock          KeInitializeSpinLock
#define RtAcquireSpinLock             KeAcquireSpinLock
#define RtAcquireSpinLockAtDpcLevel   KeAcquireSpinLockAtDpcLevel
#define RtReleaseSpinLock             KeReleaseSpinLock
#define RtReleaseSpinLockFromDpcLevel KeReleaseSpinLockFromDpcLevel


#endif	// RT_LOCK_DEBUG





#if RT_MEM_DEBUG


#ifndef __FILE_SIG__
#error File signature not defined
#endif

//
// Memory Allocation/Freeing Audit:
//

//
// The RT_ALLOCATION structure stores all info about one allocation
//

typedef struct _RT_ALLOCATION
{
    LIST_ENTRY  leLink;
    ULONG       ulMemSig;
    ULONG       ulFileSig;
    ULONG       ulLineNumber;
    ULONG       ulSize;
    UCHAR		pucData[1];
}RT_ALLOCATION, *PRT_ALLOCATION;

//
// The RT_FREE structure stores info about an allocation
// that was freed. Later if the memory is touched, the
// free list can be scanned to see where the allocation was
// freed
//

typedef struct _RT_FREE
{
    LIST_ENTRY  leLink;
    UINT_PTR    pStartAddr;
    ULONG       ulSize;
    ULONG       ulMemSig;
    ULONG       ulAllocFileSig;
    ULONG       ulAllocLineNumber;
    ULONG       ulFreeFileSig;
    ULONG       ulFreeLineNumber;
}RT_FREE, *PRT_FREE;


#define RT_MEMORY_SIG     'YRMM'
#define RT_FREE_SIG       'EERF'

PVOID
RtpAllocate(
    IN POOL_TYPE    ptPool,
	IN ULONG	    ulSize,
    IN ULONG        ulTag,
	IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtpFree(
	PVOID	pvPointer,
    IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtAuditMemory();

#define RtAllocate(X, Y, Z)   RtpAllocate((X), (Y), (Z), __FILE_SIG__, __LINE__)
#define RtFree(X)             RtpFree((X), __FILE_SIG__, __LINE__)



#else // RT_MEM_DEBUG



#define RtAllocate    ExAllocatePoolWithTag
#define RtFree        ExFreePool

#define RtAuditMemory()



#endif // RT_MEM_DEBUG




#endif // __RT_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\ipinip\driver.c

Abstract:

    IP in IP driver shell

Revision History:

    Gurdeep Singh Pall          8/2/95  Created

--*/

#define __FILE_SIG__    DRIVER_SIG

#include "inc.h"

#pragma alloc_text(INIT, DriverEntry)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system and must be named
    "Driver Entry"
    The function is discardable since it is only called once
    On checked builds we read some values from registry and initialize the
    debugging
    We create a DEVICE_OBJECT for ourselves to field the IOCTLs, create 
    a DOS name for the device and initialize some events and spinlocks

Locks 

    None

Arguments

    DriverObject    Pointer to I/O subsystem created driver object
    RegistryPath    Points to driver key in HKLM\CCS\Services...

Return Value

    STATUS_SUCCESS  if everything went as planned or some status code from
                    ntstatus.h

--*/

{
    NTSTATUS        nStatus;
    PDEVICE_OBJECT  pDeviceObject;
    UNICODE_STRING  usDeviceName;
    DWORD           dwVal, i;
    HANDLE          hRegKey;

    WCHAR           ParametersRegistryPath[] =
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\IpInIp\\Parameters";

    RtInitializeDebug();

    //
    // Read the registry for parameters
    //

    nStatus = OpenRegKey(&hRegKey,
                         ParametersRegistryPath);

    if(nStatus is STATUS_SUCCESS)
    {

#if RT_TRACE_DEBUG

        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugLevel",
                                   &dwVal);

        if(nStatus is STATUS_SUCCESS)
        {
            g_byDebugLevel  = (BYTE)dwVal;
        }

        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugComp",
                                   &dwVal);

        if(nStatus is STATUS_SUCCESS)
        {
            g_fDebugComp  = dwVal;
        }
#endif

#if DBG
        nStatus = GetRegDWORDValue(hRegKey,
                                   L"DebugBreak",
                                   &dwVal);

        if((nStatus is STATUS_SUCCESS) and
           (dwVal is 1))
        {
            DbgBreakPoint();
        }
#endif

        ZwClose(hRegKey);
    }

    TraceEnter(GLOBAL, "DriverEntry");

    //
    // Initialize some globals
    //
    
    g_dwDriverState = DRIVER_STOPPED;
    g_ulNumThreads  = 0;
    g_ulNumOpens    = 0;

    g_hIpRegistration = NULL;

    //
    // Create the device
    //

    RtlInitUnicodeString(&usDeviceName,
                         DD_IPINIP_DEVICE_NAME);

    nStatus = IoCreateDevice(DriverObject,
                             0,
                             &usDeviceName,
                             FILE_DEVICE_NETWORK,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &pDeviceObject);

    if (!NT_SUCCESS(nStatus))
    {
        Trace(GLOBAL, ERROR,
              ("DriverEntry: Cant create device object %ws, status %lx.\n",
               DD_IPINIP_DEVICE_NAME,
               nStatus));

        TraceLeave(GLOBAL, "DriverEntry");

        return nStatus;
    }

    //
    // Initialize the driver object
    //

    DriverObject->DriverUnload   = IpIpUnload;
    DriverObject->FastIoDispatch = NULL;

    for(i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = IpIpDispatch;
    }


    if(!SetupExternalName(&usDeviceName, 
                          WIN32_IPINIP_SYMBOLIC_LINK,
                          TRUE))
    {
        Trace(GLOBAL,ERROR,
              ("DriverEntry: Win32 device name could not be created\n"));

        IoDeleteDevice(pDeviceObject);

        TraceLeave(GLOBAL, "DriverEntry");

        return  STATUS_UNSUCCESSFUL;
    }

    //
    // Lock and event needed to keep track of threads in the driver
    //

    RtInitializeSpinLock(&g_rlStateLock);

    KeInitializeEvent(&(g_keStateEvent),
                      SynchronizationEvent,
                      FALSE);

    //
    // Many threads may be waiting for us to start so this needs to be a
    // NotificationEvent
    //

    KeInitializeEvent(&(g_keStartEvent),
                      NotificationEvent,
                      FALSE);

    InitRwLock(&g_rwlTunnelLock);

    InitializeListHead(&g_leTunnelList);

    InitializeListHead(&g_lePendingMessageList);
    InitializeListHead(&g_lePendingIrpList);

    //
    // Register with IP
    //

    nStatus = RegisterWithIp();

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("DriverEntry: RegisterWithIP failed\n"));

        IoDeleteDevice(pDeviceObject);

        TraceLeave(GLOBAL, "InitializeDriver");

        return FALSE;
    }

    g_pIpIpDevice = pDeviceObject;

    TraceLeave(GLOBAL, "DriverEntry");

    return nStatus;
}



#pragma alloc_text(PAGE, IpIpDispatch)

NTSTATUS
IpIpDispatch(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )

/*++

Routine Description

    The functions which handles the IRPs sent to the driver

Locks

    This code is PAGEABLE so can not acquire locks
 
Arguments
      

Return Value

    STATUS_SUCCESS 

--*/

{
    PIO_STACK_LOCATION	irpStack;
    ULONG		        ulInputBuffLen;
    ULONG		        ulOutputBuffLen;
    ULONG		        ioControlCode;
    NTSTATUS	        nStatus;
    KIRQL               kiIrql;
    LARGE_INTEGER       liTimeOut;
    BOOLEAN             bEnter;
    
    
    PAGED_CODE();
 
    TraceEnter(GLOBAL, "IpIpDispatch");

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //
    
    ulInputBuffLen  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    ulOutputBuffLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
        {
            
            Trace(GLOBAL, TRACE,
                  ("IpIpDispatch: IRP_MJ_CREATE\n"));

            //
            // We start the driver when the first CreateFile is done
            // But we need to serialize the Creates
            //

            nStatus = StartDriver();
        
            if(nStatus is STATUS_PENDING)
            {
                //
                // Means someone is trying to start the driver
                // We wait for some time (since we are at PASSIVE)
                //

                liTimeOut.QuadPart = START_TIMEOUT;
                
                nStatus = KeWaitForSingleObject(&g_keStartEvent,
                                                UserRequest,
                                                KernelMode,
                                                FALSE,
                                                &liTimeOut);
                
                if(nStatus isnot STATUS_SUCCESS)
                {
                    //
                    // We timed out - bad things are happening here
                    //
                    
                    Trace(GLOBAL, ERROR,
                          ("IpIpDispatch: Timeout trying to start driver\n"));

                    nStatus = STATUS_UNSUCCESSFUL;
                }
                else
                { 
                    //
                    // Make sure the driver actually started
                    //

                    bEnter = EnterDriverCode();

                    ExitDriverCode();

                    if(!bEnter)
                    {
                        Trace(GLOBAL, ERROR,
                              ("IpIpDispatch: Wait successful, but unable to start driver\n"));

                        nStatus = STATUS_UNSUCCESSFUL;
                    }
                }

            }                    

            break;
        }

        case IRP_MJ_CLOSE:
        {
            Trace(GLOBAL, TRACE,
                  ("IpIpDispatch: IRP_MJ_CLOSE\n"));

            //
            // We handle cleanup and not close
            //
            
            nStatus = STATUS_SUCCESS;

            break;
        }
        
        case IRP_MJ_CLEANUP:
        {
            Trace(GLOBAL, TRACE,
                  ("IpIpDispatch: IRP_MJ_CLEANUP\n"));

            StopDriver();

            nStatus = STATUS_SUCCESS;
            
            break;
        }

        case IRP_MJ_DEVICE_CONTROL:
        {
            DWORD   dwState;
            ULONG   ulControl;

            //
            // Get the control code and our code
            //
            
            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
            
            //
            // If the driver is stopping, dont process anything else
            //
            
            bEnter =  EnterDriverCode();
            
            if(!bEnter)
            {
                Trace(GLOBAL, ERROR,
                      ("IpIpDispatch: Driver is not started\n"));
                
                nStatus = STATUS_NO_SUCH_DEVICE;
                
                break;
            }
            
            switch(ioControlCode)
            {
                case IOCTL_IPINIP_CREATE_TUNNEL:
                {
                    nStatus = AddTunnelInterface(Irp,
                                                 ulInputBuffLen,
                                                 ulOutputBuffLen);
                    
                    break;
                }

                case IOCTL_IPINIP_DELETE_TUNNEL:
                {
                    nStatus = DeleteTunnelInterface(Irp,
                                                    ulInputBuffLen,
                                                    ulOutputBuffLen);
                    
                    break;
                }

                case IOCTL_IPINIP_SET_TUNNEL_INFO:
                {
                    nStatus = SetTunnelInfo(Irp,
                                            ulInputBuffLen,
                                            ulOutputBuffLen);
                    
                    break;
                }
                
                case IOCTL_IPINIP_GET_TUNNEL_TABLE:
                {
                    nStatus = GetTunnelTable(Irp,
                                             ulInputBuffLen,
                                             ulOutputBuffLen);
                    
                    break;
                }
               
                case IOCTL_IPINIP_NOTIFICATION:
                {
                    nStatus = ProcessNotification(Irp,
                                                  ulInputBuffLen,
                                                  ulOutputBuffLen);

                    break;
                }
 
                default:
                {
                    Trace(GLOBAL, ERROR,
                          ("IpIpDispatch: Unknown IRP_MJ_DEVICE_CONTROL %x\n",
                           ioControlCode));
                
                    nStatus = STATUS_INVALID_PARAMETER;
                }
            }        

            ExitDriverCode();
            
            break;
        }

        default:
        {
            Trace(GLOBAL, ERROR,
                  ("IpIpDispatch: Unknown IRP_MJ_XX - %x\n",
                   irpStack->MajorFunction));

            nStatus = STATUS_INVALID_PARAMETER;

            break;
        }
    }

    if(nStatus isnot STATUS_PENDING)
    {
        Irp->IoStatus.Status = nStatus;

        IoCompleteRequest(Irp,
                          IO_NETWORK_INCREMENT);
    }

    TraceLeave(GLOBAL, "IpIpDispatch");

    return nStatus;
}


VOID
IpIpUnload(
    PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description

    Called by the I/O subsystem, when our driver is being unloaded
    
Locks


Arguments


Return Value

    None

--*/

{
    UNICODE_STRING  usDeviceName;
    BOOLEAN         bWait;
    KIRQL           kiIrql;
    NDIS_STATUS     nsStatus;
    NTSTATUS        nStatus;

    TraceEnter(GLOBAL,"IpIpUnload");

    //
    // The driver must have stopped before it came here
    //

    RtAssert(g_dwDriverState is DRIVER_STOPPED);

    RemoveAllTunnels();

    //
    // Clear out IP's state
    //
    
    DeregisterWithIp();

    //
    // Remove ourself from NT and DOS namespace
    //
    
    RtlInitUnicodeString(&usDeviceName,
                         DD_IPINIP_DEVICE_NAME);

    SetupExternalName(&usDeviceName, 
                      WIN32_IPINIP_SYMBOLIC_LINK,
                      FALSE);


    //
    // Clean out address blocks, if any
    //

    while(!IsListEmpty(&g_leAddressList))
    {
        PADDRESS_BLOCK  pAddrBlock;
        PLIST_ENTRY     pleNode;

        pleNode = RemoveHeadList(&g_leAddressList);

        pAddrBlock = CONTAINING_RECORD(pleNode,
                                       ADDRESS_BLOCK,
                                       leAddressLink);

        RtFree(pAddrBlock);
    }

    //
    // See if we have any free memory
    //

    RtAuditMemory();
    
    //
    // Delete the device object
    //
    
    IoDeleteDevice(DriverObject->DeviceObject);

    TraceLeave(GLOBAL,"IpIpUnload");
}

#pragma alloc_text(PAGE, SetupExternalName)

BOOLEAN
SetupExternalName(
    PUNICODE_STRING  pusNtName,
    PWCHAR           pwcDosName,
    BOOLEAN          bCreate
    )

/*++

Routine Description

    Setup or delete a symbolic link to DOS namespace
    
Locks

Arguments

    pusNtName   Name in NT space
    pwcDosName  Name in DOS space
    bCreate     Set to TRUE to create, FALSE to delete
    
Return Value

    TRUE    if successful
    FALSE   otherwise

--*/

{
    UNICODE_STRING  usSymbolicLinkName;
    WCHAR           rgwcBuffer[100];

    PAGED_CODE();

    //
    // Form the full symbolic link name we wish to create.
    //

    usSymbolicLinkName.Buffer = rgwcBuffer;

    RtlInitUnicodeString(&usSymbolicLinkName,
                         pwcDosName);

    if(bCreate)
    {
        if(!NT_SUCCESS(IoCreateSymbolicLink(&usSymbolicLinkName,
                                            pusNtName)))
        {
            return FALSE;
        }
    }
    else
    {
        IoDeleteSymbolicLink(&usSymbolicLinkName);
    }

    return TRUE;
}

NTSTATUS
StartDriver(
    VOID
    )

/*++

Routine Description
      
    Main routine to start the driver. We call this when we get CREATE irp
    If the driver has started, we return success. If someone is starting the
    driver, we return pending. The caller then needs to wait on g_keStartEvent
    We try and start the driver. If all goes well, we set the event and
    everyone parties on from there
    
Locks 

    The function takes the g_rlStateLock to check the state and increment
    the number of CREATEs it has received (open handles)
    
Arguments

    None

Return Value

    STATUS_SUCCESS  if the driver started
    STATUS_PENDING  if the driver is being started by some other thread's

--*/

{
    KIRQL               kiOldIrql;
    NTSTATUS            nStatus;
    DWORD               dwState;
    OPEN_CONTEXT        TdixContext;
    WORK_QUEUE_ITEM     WorkItem;
    KEVENT              keTempEvent;
 
    TraceEnter(GLOBAL, "StartDriver");

    RtAcquireSpinLock(&g_rlStateLock,
                      &kiOldIrql);

    g_ulNumOpens++;

    if(g_ulNumOpens isnot 1)
    {
        if(g_dwDriverState is DRIVER_STARTING)
        {
            //
            // Someone is trying to start the driver
            //

            Trace(GLOBAL, INFO,
                  ("StartDriver: Driver is being started by someone else\n"));

            nStatus = STATUS_PENDING;
        }
        else
        {
            //
            // If we are not the first CreateFile, and the driver is not 
            // starting then the driver must already be running
            //

            RtAssert(g_dwDriverState is DRIVER_STARTED);

            nStatus = STATUS_SUCCESS;
        }

        RtReleaseSpinLock(&g_rlStateLock,
                          kiOldIrql);
    
        return nStatus;
    }

    //
    // The first CreateFile
    //

    RtAssert(g_dwDriverState is DRIVER_STOPPED);

    //
    // Set the state to starting, release the lock and actually start 
    // the driver
    //

    g_dwDriverState = DRIVER_STARTING;

    RtReleaseSpinLock(&g_rlStateLock,
                      kiOldIrql);

    dwState = DRIVER_STARTED;

    //
    // Initialize the event and work item to start TDI
    //

    KeInitializeEvent(&keTempEvent,
                      SynchronizationEvent,
                      FALSE);

    TdixContext.pkeEvent = &keTempEvent;

    ExInitializeWorkItem(&WorkItem,
                         TdixInitialize,
                         &TdixContext);

    //
    // Start TDI in the system context so that we the handles are not
    // associated with the current process
    //

    ExQueueWorkItem(&WorkItem,
                    DelayedWorkQueue);

    //
    // Wait for TDI to get done
    //

   nStatus = KeWaitForSingleObject(TdixContext.pkeEvent,
                                   UserRequest,
                                   KernelMode,
                                   FALSE,
                                   NULL);

    if((nStatus isnot STATUS_SUCCESS) or
       (TdixContext.nStatus isnot STATUS_SUCCESS))
    {
        Trace(GLOBAL, ERROR,
              ("StartDriver: TdixInitialize failed with %x %x\n",
               nStatus, TdixContext.nStatus));

        dwState = DRIVER_STOPPED;
    }
   
    if(dwState is DRIVER_STARTED)
    {
        LARGE_INTEGER   liDueTime;

        KeInitializeDpc(&g_kdTimerDpc,
                        IpIpTimerRoutine,
                        NULL);

        KeInitializeTimer(&g_ktTimer);

        liDueTime = RtlEnlargedUnsignedMultiply(TIMER_IN_MILLISECS,
                                                SYS_UNITS_IN_ONE_MILLISEC);

        liDueTime = RtlLargeIntegerNegate(liDueTime);

        KeSetTimerEx(&g_ktTimer,
                     liDueTime,
                     0,
                     &g_kdTimerDpc); 
    }

    RtAcquireSpinLock(&g_rlStateLock,
                      &kiOldIrql);

    g_dwDriverState = dwState;
  
    //
    // Someone may have been waiting for us to start
    //
 
    KeSetEvent(&g_keStartEvent,
               0,
               FALSE); 

    RtReleaseSpinLock(&g_rlStateLock,
                      kiOldIrql);

    TraceLeave(GLOBAL, "StartDriver");

    return nStatus;
}

    
VOID
StopDriver(
    VOID
    )

/*++

Routine Description

    Called when we get an IRP_MJ_CLEANUP. It is the inverse of StartDriver
    If this is the last thread, we set the state to STOPPED and wait till
    all threads of execution have exited the driver.
    We then clean out resources
  
Locks 

    The function takes the g_rlStateLock
    
Arguments
      
    None
    
Return Value

    None
    
--*/
{
    KIRQL           kiOldIrql;
    NTSTATUS        nStatus;
    BOOLEAN         bWait;
    ULONG           i;
    OPEN_CONTEXT    TdixContext;
    WORK_QUEUE_ITEM WorkItem;
    KEVENT          keTempEvent;
    PIO_WORKITEM    pIoWorkItem;
 
    TraceEnter(GLOBAL, "StopDriver");

    //
    // Acquire the state and ref count spin lock
    //
    
    RtAcquireSpinLock(&g_rlStateLock,
                      &kiOldIrql);

    g_ulNumOpens--;

    if(g_ulNumOpens isnot 0)
    {
        //
        // Other people still around
        //

        RtReleaseSpinLock(&g_rlStateLock,
                          kiOldIrql);

        TraceLeave(GLOBAL, "StopDriver");

        return;
    }


    //
    // Set the state to stopping. Any reader will
    // return on seeing this. So essentially we are not
    // allowing any new readers in
    //
    
    g_dwDriverState = DRIVER_STOPPED;

    //
    // However there may already be readers. We wait
    // if there are any
    //
    
    bWait = (g_ulNumThreads > 0);

    RtReleaseSpinLock(&g_rlStateLock,
                      kiOldIrql);

    //
    // Now do a wait. We can do this since we are at PASSIVE
    //

    if(bWait)
    {
        Trace(GLOBAL, INFO,
              ("StopDriver: Need to wait for threads to exit\n"));

        do
        {
            nStatus = KeWaitForSingleObject(&g_keStateEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL);

        }while((nStatus is STATUS_USER_APC) or 
               (nStatus is STATUS_ALERTED) or 
               (nStatus is STATUS_TIMEOUT));
    }

    //
    // Undo the timer
    //

    i = 0;

    while(KeCancelTimer(&g_ktTimer) is FALSE)
    {
        LARGE_INTEGER   liTimeOut;

        //
        // Hmm, timer was not in the system queue. 
        // Set the wait to 2, 4, 6... secs
        //

        liTimeOut.QuadPart = (LONGLONG)((i + 1) * 2 * 1000 * 1000 * 10 * -1);

        KeDelayExecutionThread(UserMode,
                               FALSE,
                               &liTimeOut);

        i++;
    }

    //
    // Initialize the event and work item to stop TDI
    //

    KeInitializeEvent(&keTempEvent,
                      SynchronizationEvent,
                      FALSE);

    TdixContext.pkeEvent = &keTempEvent;

    pIoWorkItem = IoAllocateWorkItem(g_pIpIpDevice);

    //
    // Must have a work item - no failure code path
    //

    RtAssert(pIoWorkItem);

    IoQueueWorkItem(pIoWorkItem,
                    TdixDeinitialize,
                    DelayedWorkQueue,
                    &TdixContext);

    //
    // Wait for TDI to get done
    //

    nStatus = KeWaitForSingleObject(TdixContext.pkeEvent,
                                    UserRequest,
                                    KernelMode,
                                    FALSE,
                                    NULL);

    RtAssert(nStatus is STATUS_SUCCESS);

    IoFreeWorkItem(pIoWorkItem);

    //
    // Cleanup all resources
    //
   
    while(!IsListEmpty(&g_lePendingMessageList))
    {
        PLIST_ENTRY         pleNode;
        PPENDING_MESSAGE    pMessage;

        //
        // We have some old info
        // Remove it off the pending list
        //

        pleNode = RemoveHeadList(&g_lePendingMessageList);

        //
        // Get a pointer to the structure
        //

        pMessage = CONTAINING_RECORD(pleNode,
                                     PENDING_MESSAGE,
                                     leMessageLink);

        //
        // Free the allocated message
        //

        FreeMessage(pMessage);
    }

    ClearPendingIrps();
 
    TraceLeave(GLOBAL, "StopDriver");
}



NTSTATUS
RegisterWithIp(
    VOID
    )

/*++

Routine Description

    Registers the ARP module with IP

Locks


Arguments


Return Value


--*/

{
    NDIS_STRING     nsIpIpName;
    WCHAR           pwszName[] = IPINIP_ARP_NAME;
    IP_STATUS       Status;
    IPInfo          Info;

    TraceEnter(GLOBAL, "RegisterWithIP");

    Status = IPGetInfo(&Info,
                       sizeof(Info));

    if(Status isnot IP_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("RegisterWithIp: Couldnt get IPInfo %x\n", Status));

        TraceLeave(GLOBAL,
                   "RegisterWithIP");

        return STATUS_UNSUCCESSFUL;
    }

    g_pfnOpenRce    = Info.ipi_openrce;
    g_pfnCloseRce   = Info.ipi_closerce;

    nsIpIpName.MaximumLength  = sizeof(pwszName);
    nsIpIpName.Length         = sizeof(IPINIP_ARP_NAME) - sizeof(WCHAR);
    nsIpIpName.Buffer         = pwszName;

    Status = IPRegisterARP(&nsIpIpName,
                           IP_ARP_BIND_VERSION,
                           IpIpBindAdapter,
                           &g_pfnIpAddInterface,
                           &g_pfnIpDeleteInterface,
                           &g_pfnIpBindComplete,
                           &g_pfnIpAddLink,
                           &g_pfnIpDeleteLink,
                           &g_pfnIpChangeIndex,
                           &g_pfnIpReserveIndex,
                           &g_pfnIpDereserveIndex,
                           &g_hIpRegistration);
    
    if(Status isnot IP_SUCCESS)
    {
        Trace(GLOBAL, ERROR,
              ("RegisterWithIp: Couldnt register with IP\n"));

        TraceLeave(GLOBAL,
                   "RegisterWithIP");

        return STATUS_UNSUCCESSFUL;
    }

    TraceLeave(GLOBAL,
               "RegisterWithIP");

    return STATUS_SUCCESS;
}

VOID
DeregisterWithIp(
    VOID
    )

/*++

Routine Description

   DeRegisters the ARP module with IP

Locks


Arguments


Return Value

--*/

{
    NTSTATUS    nStatus;

    TraceEnter(GLOBAL, "DeregisterWithIp");

    nStatus = IPDeregisterARP(g_hIpRegistration);

    if(nStatus isnot STATUS_SUCCESS)    
    {
        Trace(GLOBAL, ERROR,
              ("DeregisterWithIp: Couldnt deregister with IP. Error %x\n",
               nStatus));

    }

    g_pfnIpAddInterface     = NULL;
    g_pfnIpDeleteInterface  = NULL;
    g_pfnIpBindComplete     = NULL;
    g_pfnIpRcv              = NULL;
    g_pfnIpRcvComplete      = NULL;
    g_pfnIpSendComplete     = NULL;
    g_pfnIpTDComplete       = NULL;
    g_pfnIpStatus           = NULL;
    g_pfnIpRcvPkt           = NULL;
    g_pfnIpPnp              = NULL;
    g_hIpRegistration       = NULL;

    TraceLeave(GLOBAL, "DeregisterWithIp");
}

#pragma alloc_text(PAGE, OpenRegKey)

NTSTATUS
OpenRegKey(
    PHANDLE  HandlePtr,
    PWCHAR  KeyName
    )
{
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);

    RtlZeroMemory(&ObjectAttributes,
                  sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(&ObjectAttributes,
                               &UKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(HandlePtr,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}


#pragma alloc_text(PAGE, GetRegDWORDValue)

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    )
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR                       keybuf[128];
    UNICODE_STRING              UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));


    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             128,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}

BOOLEAN
EnterDriverCode(
    VOID
    )
{
    KIRQL   irql;
    BOOLEAN bEnter;

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    if(g_dwDriverState is DRIVER_STARTED)
    {
        g_ulNumThreads++;

        bEnter = TRUE;
    }
    else
    {
        bEnter = FALSE;
    }

    RtReleaseSpinLock(&g_rlStateLock,
                         irql);

    return bEnter;
}


VOID
ExitDriverCode(
    VOID
    )
{
    KIRQL   irql;

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    g_ulNumThreads--;

    if((g_dwDriverState is DRIVER_STOPPED) and
       (g_ulNumThreads is 0))
    {
        KeSetEvent(&g_keStateEvent,
                   0,
                   FALSE);
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

}

VOID
ClearPendingIrps(
    VOID
    )
    
/*++

Routine Description:

    Called at cleanup time to return any pending IRPs    

Locks:

    Acquires the IoCancelSpinLock since it controls the pending irp list

Arguments:

    None

Return Value:

    None

--*/

{
    KIRQL   irql;

    TraceEnter(GLOBAL, "ClearPendingIrps");

    IoAcquireCancelSpinLock (&irql);

    while(!IsListEmpty(&g_lePendingIrpList))
    {
        PLIST_ENTRY pleNode;
        PIRP        pIrp;

        pleNode = RemoveHeadList(&g_lePendingIrpList);

        pIrp = CONTAINING_RECORD(pleNode,
                                 IRP,
                                 Tail.Overlay.ListEntry);

        IoSetCancelRoutine(pIrp,
                           NULL);

        pIrp->IoStatus.Status       = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Information  = 0;

        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock(irql);

        IoCompleteRequest(pIrp,
                          IO_NETWORK_INCREMENT);

        //
        // Reaquire the lock
        //

        IoAcquireCancelSpinLock(&irql);
    }

    IoReleaseCancelSpinLock(irql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\ioctl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ipinip\ioctl.h

Abstract:

    header for ioctl.c

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

//
// Notification events
//

typedef struct _PENDING_MESSAGE
{
    LIST_ENTRY          leMessageLink;

    IPINIP_NOTIFICATION inMsg;

}PENDING_MESSAGE, *PPENDING_MESSAGE;

//++
//
//  PPENDING_MESSAGE
//  AllocateMessage(
//      VOID
//      )
//
//  Allocate a Message blob 
//
//--

#define AllocateMessage()              \
            RtAllocate(NonPagedPool, sizeof(PENDING_MESSAGE), MESSAGE_TAG)

//++
//
//  VOID
//  FreeMessage(
//      PPENDING_MESSAGE   pMsg
//      )
//
//  Free a Message blob
//
//--

#define FreeMessage(n)     RtFree((n))

//
// List of pending Messages
//

LIST_ENTRY  g_lePendingMessageList;

//
// List of pending IRPs
//

LIST_ENTRY  g_lePendingIrpList;

NTSTATUS
AddTunnelInterface(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    );

NTSTATUS
DeleteTunnelInterface(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    );

NTSTATUS
SetTunnelInfo(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    );

NTSTATUS
GetTunnelTable(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    );

NTSTATUS
ProcessNotification(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    );

VOID
CancelNotificationIrp(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp
    );

VOID
CompleteNotificationIrp(
    PPENDING_MESSAGE    pMessage
    );

PADDRESS_BLOCK
GetAddressBlock(
    DWORD   dwAddress
    );

VOID
UpdateMtuAndReachability(
    PTUNNEL pTunnel
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\globals.h

Abstract:

    

Revision History:

    

--*/

#ifndef __IPINIP_GLOBALS_H__
#define __IPINIP_GLOBALS_H__

//
// Our IP Registration handle
//

HANDLE g_hIpRegistration;

//
// Callback functions into IP
// No receive packet routine
//

IPRcvRtn	        g_pfnIpRcv;
IPTDCmpltRtn	    g_pfnIpTDComplete;
IPTxCmpltRtn	    g_pfnIpSendComplete;
IPStatusRtn	        g_pfnIpStatus;
IPRcvCmpltRtn	    g_pfnIpRcvComplete;
IP_ADD_INTERFACE    g_pfnIpAddInterface; 
IP_DEL_INTERFACE    g_pfnIpDeleteInterface;
IP_BIND_COMPLETE    g_pfnIpBindComplete;
IP_PNP              g_pfnIpPnp;
IPRcvPktRtn         g_pfnIpRcvPkt;
IP_ADD_LINK         g_pfnIpAddLink;
IP_DELETE_LINK      g_pfnIpDeleteLink;
IP_CHANGE_INDEX     g_pfnIpChangeIndex;
IP_RESERVE_INDEX    g_pfnIpReserveIndex;
IP_DERESERVE_INDEX  g_pfnIpDereserveIndex;

IPAddr      (*g_pfnOpenRce)(IPAddr, IPAddr, RouteCacheEntry **, uchar *,
                    ushort *, IPOptInfo *);
void        (*g_pfnCloseRce)(RouteCacheEntry *);


//
// Stuff to maintain driver state
//

DWORD       g_dwDriverState;
RT_LOCK     g_rlStateLock;
ULONG       g_ulNumThreads;
ULONG       g_ulNumOpens;
KEVENT      g_keStateEvent;
KEVENT      g_keStartEvent;

//
// Pointer to our device
//

PDEVICE_OBJECT  g_pIpIpDevice;

//
// Table of IOCTL handlers
//

extern PFN_IOCTL_HNDLR g_rgpfnProcessIoctl[];

//
// Reader writer lock to protect the list of tunnels
//

RW_LOCK     g_rwlTunnelLock;

//
// List of tunnels (adapters)
//

LIST_ENTRY  g_leTunnelList;

//
// List of all the addresses
//

LIST_ENTRY  g_leAddressList;

//
// Number of tunnels in the system
//

ULONG       g_ulNumTunnels;

#endif // __IPINIP_GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\icmpfn.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ipinip\icmpfn.h

Abstract:

    header for icmpfn.c

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


#ifndef __IPINIP_ICMP_H__
#define __IPINIP_ICMP_H___

#include <packon.h>


typedef struct _ICMP_HEADER
{
    BYTE    byType;             // ICMP type
    BYTE    byCode;             // ICMP Code
    WORD    wXSum;              // Standard 1's complement checksum
}ICMP_HEADER, *PICMP_HEADER;

#pragma warning(disable:4201)

typedef struct _ICMP_DGRAM_TOO_BIG_MSG
{
    ICMP_HEADER;
    WORD    wUnused;
    USHORT  usMtu;

}ICMP_DGRAM_TOO_BIG_MSG, *PICMP_DGRAM_TOO_BIG_MSG;

#pragma warning(default:4201)

#include <packoff.h>

//
// ICMP types and codes that we are interested in
//

#define ICMP_TYPE_DEST_UNREACHABLE      0x03
#define ICMP_TYPE_TIME_EXCEEDED         0x0B
#define ICMP_TYPE_PARAM_PROBLEM         0x0C

#define ICMP_CODE_NET_UNREACHABLE       0x00
#define ICMP_CODE_HOST_UNREACHABLE      0x01
#define ICMP_CODE_PROTO_UNREACHABLE     0x02
#define ICMP_CODE_PORT_UNREACHABLE      0x03
#define ICMP_CODE_DGRAM_TOO_BIG         0x04

#define DEST_UNREACH_LENGTH             8
#define TIME_EXCEED_LENGTH              8

typedef
NTSTATUS
(*PICMP_HANDLER)(
    PTUNNEL         pTunnel,
    PICMP_HEADER    pIcmpHeader,
    PIP_HEADER      pInHeader
    );


NTSTATUS
HandleTimeExceeded(
    PTUNNEL         pTunnel,
    PICMP_HEADER    pIcmpHeader,
    PIP_HEADER      pInHeader
    );

NTSTATUS
HandleDestUnreachable(
    PTUNNEL         pTunnel,
    PICMP_HEADER    pIcmpHeader,
    PIP_HEADER      pInHeader
    );

VOID
IpIpTimerRoutine(
    PKDPC   Dpc,
    PVOID   DeferredContext,
    PVOID   SystemArgument1,
    PVOID   SystemArgument2
    );

#endif // __IPINIP_ICMP_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\inc.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\wanarp\allinc.h

Abstract:
    WAN ARP main header.

Revision History:

    Gurdeep Singh Pall          7/31/95

--*/

#ifndef __IPINIP_INC_H___
#define __IPINIP_INC_H___


typedef unsigned long       DWORD, *PDWORD;
typedef unsigned short      WORD,  *PWORD;
typedef unsigned char       BYTE,  *PBYTE;
typedef void                *PVOID;

#include <ntddk.h>
#include <ndis.h>
#include <cxport.h>
#include <ip.h>
#include <ntddip.h>
#include <ntddtcp.h>
#include <llipif.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <tcpinfo.h>
#include <llinfo.h>
#include <tdistat.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <arpinfo.h>

#include <ipifcons.h>

#include <ddipinip.h>

#define is      ==
#define isnot   !=
#define or      ||
#define and     &&

#include "debug.h"
#include "rwlock.h"
#include "ppool.h"
#include "bpool.h"
#include "ipinip.h"
#include "globals.h"
#include "tdix.h"

#include "driver.h"
#include "adapter.h"
#include "send.h"
#include "ioctl.h"
#include "icmpfn.h"

#endif // __IPINIP_INC_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\ipinip.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\ipinip.h

Abstract:

    Main header file for the IP in IP encapsulation driver


Revision History:


--*/


#ifndef __IPINIP_IPINIP_H__
#define __IPINIP_IPINIP_H___

//
// The protocol ID for IP in IP
//

#define PROTO_IPINIP        4
#define PROTO_ICMP          1

//
// The IP version that we work with
//

#define IP_VERSION_4        0x04

//
// Macro for figuring out the length of an IP header
//

#define LengthOfIPHeader(X)   (ULONG)((((X)->byVerLen) & 0x0F)<<2);

//
// The length of the smallest valid IP Header is 20 bytes
// and the largest is 60
//

#define MIN_IP_HEADER_LENGTH    20
#define MAX_IP_HEADER_LENGTH    60

#define ICMP_HEADER_LENGTH      8

//
// Since we are IPv4 and 20 bytes of header, the version+length field is 45
//

#define IP_VERSION_LEN          0x45

//
// Macro to decide whether the address is unicast
//

#define IsUnicastAddr(X)    ((DWORD)((X) & 0x000000F0) < (DWORD)(0x000000E0))
#define IsClassDAddr(X)     (((X) & 0x000000F0) == 0x000000E0)
#define IsClassEAddr(X)     (((X) & 0x000000F8) == 0x000000F0)

//
// Symbolic link into DOS space
//

#define WIN32_IPINIP_SYMBOLIC_LINK L"\\DosDevices\\IPINIP"


//
// ARP name (for IP). Also goes into LLInterface
//

#define IPINIP_ARP_NAME L"IPINIP"

#define TCPIP_IF_PREFIX L"\\Device\\"

//
// All IOCTLs are handled by functions with the prototype below. This allows
// us to build a table of pointers and call out to them instead of doing
// a switch
//

typedef
NTSTATUS
(*PFN_IOCTL_HNDLR)(
    PIRP   pIrp,
    ULONG  ulInLength,
    ULONG  ulOutLength
    );


//
// We look like an 802.x ARP interface
//

#define ARP_802_ADDR_LENGTH     6

//
// Macro for building a 802.3 hw address given an index. 
// We do this since our adapters do not have a real net card associated with
// them
//

#define HW_NAME_SEED            "\0SExx\0"

#define BuildHardwareAddrFromIndex(addr,index) {                \
                RtlCopyMemory(addr, HW_NAME_SEED, 6);           \
                addr[3] = (uchar) index >> 8;                   \
                addr[4] = (uchar) index;                        \
}

//
// The description string for our interfaces (try and make length + 1 a 
// multiple of 4)
//

#define VENDOR_DESCRIPTION_STRING       "IP in IP (Tunnel) Interface"

//
// The default speed and MTU. We change the MTU when we get a better estimate
// but the speed remains the same
//

#define DEFAULT_MTU         (1500 - 60)
#define DEFAULT_SPEED       (100000000)

//
// The number of seconds after which an attempt is made to change the state
// of an interface
//

#define UP_TO_DOWN_CHANGE_PERIOD    (5 * 60)
#define DOWN_TO_UP_CHANGE_PERIOD    (1 * 60)

//
// Timer period
//

#define TIMER_IN_MILLISECS          (1 * 60 * 1000)

#define SYS_UNITS_IN_ONE_MILLISEC   (1000 * 10)

#define MILLISECS_TO_TICKS(ms)          \
    ((ULONGLONG)(ms) * SYS_UNITS_IN_ONE_MILLISEC / KeQueryTimeIncrement())

#define SECS_TO_TICKS(s)               \
    ((ULONGLONG)MILLISECS_TO_TICKS((s) * 1000))


//
// #defines to make it easier to get to the Remote and Local
// addresses of a tunnel
//

#define REMADDR     uliTunnelId.LowPart
#define LOCALADDR   uliTunnelId.HighPart

//
// A tunnel is considered mapped when both endpoints have been specified
// Instead of keeping a separate field for the tunnel state, we reuse the 
// dwAdminState field
//

#define TS_ADDRESS_PRESENT          (0x01000000)
#define TS_ADDRESS_REACHABLE        (0x02000000)
#define TS_DELETING                 (0x04000000)
#define TS_MAPPED                   (0x08000000)
#define TS_DEST_UNREACH             (0x10000000)
#define TS_TTL_TOO_LOW              (0x20000000)

#define ERROR_BITS                  (TS_DEST_UNREACH|TS_TTL_TOO_LOW)


#define MarkTunnelMapped(p)         (p)->dwAdminState |= TS_MAPPED;
#define MarkTunnelUnmapped(p)       (p)->dwAdminState &= ~TS_MAPPED;

#define IsTunnelMapped(p)           ((p)->dwAdminState & TS_MAPPED)

#define ClearErrorBits(p)           ((p)->dwAdminState &= ~(ERROR_BITS))

#define GetAdminState(p)            ((p)->dwAdminState & 0x0000FFFF)

typedef struct _TUNNEL
{
    //
    // Link in the list of tunnels
    //

    LIST_ENTRY      leTunnelLink;

    //
    // Address of the remote end and the local end are
    // kept in a ULARGE_INTEGER. This makes it easier for comparisons
    // uliTunnelId.LowPart  = RemoteAddress
    // uliTunnelId.HighPart = LocalAddress
    // For comparisons use uliTunnelId.QuadPart
    //

    ULARGE_INTEGER  uliTunnelId;

    //
    // The interface index given to us by IP stack
    //

    DWORD           dwIfIndex;

    //
    // TDI magic stuff. Entity Ids
    //

    DWORD           dwATInstance;
    DWORD           dwIfInstance;

    //
    // IP's context for this interface
    //

    PVOID           pvIpContext;

    //
    // The name of the binding/adapter
    //

    UNICODE_STRING  usBindName;

#if DBG

    //
    // In debug builds we have the name is ANSI so that we can print it
    //

    ANSI_STRING     asDebugBindName;

#endif

    //
    // The lock and reference count used to mantain consistency for the
    // data structure. We keep one refcount for every stored reference to
    // the TUNNEL. Thus, when the TUNNEL is created and an interface is
    // added to IP, the ref count is set to 2. Since IP does not return
    // from IPDeleteInterface() till it is done using the interface, this
    // means we do not need to reference the tunnel when executing code that
    // is called by IP (e.g IpIpSend())
    //

    RT_LOCK         rlLock;
    LONG            lRefCount;

    //
    // The (fake) hardware address
    //

    BYTE            rgbyHardwareAddr[ARP_802_ADDR_LENGTH];

    //
    // The TTL associated with the tunnel. Defaults to DEFAULT_TTL
    //

    BYTE            byTtl;

    //
    // Flags determiniting the state of the tunnel
    //

    BYTE            byTunnelState;

    //
    // The MTU for this tunnel. This is learnt dynamically, though it starts
    // at DEFAULT_MTU
    //

    ULONG           ulMtu;

    //
    // The link on the address list
    //

    LIST_ENTRY      leAddressLink;

    //
    // The admin and operational states.
    //
 
    DWORD           dwAdminState;
    DWORD           dwOperState;

    //
    // The KeQueryTickCount() value the last time the dwOperState was 
    // changed
    //

    ULONGLONG       ullLastChange;
    

    //
    // Last time the state changed. We dont do anything with this right now
    //

    DWORD           dwLastChange;

    //
    // Sundry MIB-II statistics for the interface
    //

    ULONG           ulInOctets;
    ULONG           ulInUniPkts;
    ULONG           ulInNonUniPkts;
    ULONG           ulInDiscards;
    ULONG           ulInErrors;
    ULONG           ulInUnknownProto;
    ULONG           ulOutOctets;
    ULONG           ulOutUniPkts;
    ULONG           ulOutNonUniPkts;
    ULONG           ulOutDiscards;
    ULONG           ulOutErrors;
    ULONG           ulOutQLen;

    //
    // Constant structures needed to do a send. Instead of filling these
    // up every time, we reuse these
    //

    TA_IP_ADDRESS               tiaIpAddr;
    TDI_CONNECTION_INFORMATION  tciConnInfo;

    //
    // Each tunnel has a packet pool, a buffer pool for headers and a
    // buffer pool for data
    //

    PACKET_POOL     PacketPool;
    BUFFER_POOL     HdrBufferPool;

    LIST_ENTRY      lePacketQueueHead;

    BOOLEAN         bWorkItemQueued;

}TUNNEL, *PTUNNEL;

typedef struct _ADDRESS_BLOCK
{
    //
    // Link on the list of address blocks
    //

    LIST_ENTRY  leAddressLink;

    //
    // Listhead for the tunnels that use this as their local address
    // 

    LIST_ENTRY  leTunnelList;

    //
    // The IP Address
    //

    DWORD       dwAddress;

    //
    // Set to true if the address is actually in the system
    //

    BOOLEAN     bAddressPresent;

}ADDRESS_BLOCK, *PADDRESS_BLOCK;

//
// The size of a data buffer in the buffer pool
//

#define DATA_BUFFER_SIZE        (128)

//
// The size of the header buffer in the buffer pool. We dont have any 
// options so we go with the basic IP header
//

#define HEADER_BUFFER_SIZE      MIN_IP_HEADER_LENGTH

//++
//
//  PIP_HEADER
//  GetIpHeader(
//      PTUNNEL pTunnel
//      )
//
//  Gets an IP Header from the HdrBufferPool
//
//--

#define GetIpHeader(X)  (PIP_HEADER)GetBufferFromPool(&((X)->HdrBufferPool))

//++
//
//  VOID
//  FreeHeader(
//      PTUNNEL     pTunnel,
//      PIP_HEADER  pHeader
//      )
//
//  Frees an IP Header buffer to the HdrBufferPool
//
//--

#define FreeIpHeader(T,H)   FreeBufferToPool(&((T)->HdrBufferPool),(H))


//
// The size of our protocol reserved area
//

#define PACKET_RSVD_LENGTH      8

//
// The ref count for a TUNNEL is set to 2, once because a pointer is saved in
// the group list and once because the function that creates the TUNNEL will
// deref it once
//

#if 0
#define InitRefCount(pTunnel)                               \
{                                                           \
    DbgPrint("\n<>Init refcount to 2 for %x (%s, %d)\n\n",  \
             pTunnel, __FILE__, __LINE__);                  \
    (pTunnel)->lRefCount = 2;                               \
}
#else
#define InitRefCount(pTunnel)                               \
    (pTunnel)->lRefCount = 2
#endif

#if 0
#define ReferenceTunnel(pTunnel)                            \
{                                                           \
    DbgPrint("\n++Ref %x to %d (%s, %d)\n\n",               \
             pTunnel,                                       \
             InterlockedIncrement(&((pTunnel)->lRefCount)), \
             __FILE__, __LINE__);                           \
}
#else
#define ReferenceTunnel(pTunnel)                            \
    InterlockedIncrement(&((pTunnel)->lRefCount))
#endif

#if 0
#define DereferenceTunnel(pTunnel)                          \
{                                                           \
    LONG __lTemp;                                           \
    __lTemp = InterlockedDecrement(&((pTunnel)->lRefCount));\
    DbgPrint("\n--Deref %x to %d (%s, %d)\n\n",             \
             pTunnel,__lTemp,__FILE__, __LINE__);           \
    if(__lTemp == 0)                                        \
    {                                                       \
        DeleteTunnel((pTunnel));                            \
    }                                                       \
}
#else
#define DereferenceTunnel(pTunnel)                          \
{                                                           \
    if(InterlockedDecrement(&((pTunnel)->lRefCount)) == 0)  \
    {                                                       \
        DeleteTunnel((pTunnel));                            \
    }                                                       \
}
#endif

//
// The state of the driver.
//

#define DRIVER_STOPPED      0
#define DRIVER_STARTING     1
#define DRIVER_STARTED      2


//
// Timeout value for start is 10 seconds.
// So in 100ns it becomes
//

#define START_TIMEOUT       (LONGLONG)(10 * 1000 * 1000 * 10)

#define CompareUnicodeStrings(S1,S2)                    \
    (((S1)->Length == (S2)->Length) &&                  \
     (RtlCompareMemory((S1)->Buffer,                    \
                       (S2)->Buffer,                    \
                       (S2)->Length) == (S2)->Length))


//
// #defines to keep track of number of threads of execution in our code
// This is needed for us to stop cleanly
//


//
// EnterDriver returns if the driver is stopping
//

#define EnterDriver()                                       \
{                                                           \
    RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);            \
    if(g_dwDriverState is DRIVER_STOPPED)                   \
    {                                                       \
        RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);      \
        return;                                             \
    }                                                       \
    g_ulNumThreads++;                                       \
    RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);          \
}


#define ExitDriver()                                        \
{                                                           \
    RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);            \
    g_ulNumThreads--;                                       \
    if((g_dwDriverState is DRIVER_STOPPED) and              \
       (g_dwNumThreads is 0))                               \
    {                                                       \
        KeSetEvent(&g_keStateEvent,                         \
                   0,                                       \
                   FALSE);                                  \
    }                                                       \
    RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);          \
}

//
// Nifty macro for printing IP Addresses
//

#define PRINT_IPADDR(x) \
    ((x)&0x000000FF),(((x)&0x0000FF00)>>8),(((x)&0x00FF0000)>>16),(((x)&0xFF000000)>>24)

//
// IPv4 header
//

#include <packon.h>

#if !defined(DONT_INCLUDE_IP_HEADER)

#define IP_DF_FLAG          (0x0040)

//
// 0.0.0.0 is an invalid address
//

#define INVALID_IP_ADDRESS  (0x00000000)

typedef struct _IP_HEADER
{
    BYTE      byVerLen;         // Version and length.
    BYTE      byTos;            // Type of service.
    WORD      wLength;          // Total length of datagram.
    WORD      wId;              // Identification.
    WORD      wFlagOff;         // Flags and fragment offset.
    BYTE      byTtl;            // Time to live.
    BYTE      byProtocol;       // Protocol.
    WORD      wXSum;            // Header checksum.
    DWORD     dwSrc;            // Source address.
    DWORD     dwDest;           // Destination address.
}IP_HEADER, *PIP_HEADER;

#endif

#include <packoff.h>

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#endif // __IPINIP_IPINIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\ppool.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\ppool.h

Abstract:

    Structures and #defines for managing NDIS_PACKET pools. This is
    merely a reformatted version of SteveC's l2tp\ppool.h

Revision History:


--*/


#ifndef __IPINIP_PPOOL_H__
#define __IPINIP_PPOOL_H___


//
// Data structures
//

//
// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//

typedef struct _PACKET_POOL
{
    //
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    
    ULONG ulProtocolReservedLength;

    //
    // The optimal number of packets to allocate in each packet block.
    //
    
    ULONG ulPacketsPerBlock;

    //
    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    
    ULONG ulMaxPackets;

    //
    // Current number of individual packets allocated in the entire pool.
    //
    
    ULONG ulCurPackets;

    //
    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    
    ULONG ulFreesPerCollection;

    //
    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    
    ULONG ulFreesSinceCollection;

    //
    // Memory identification tag for allocated blocks.
    //
    
    ULONG ulTag;

    //
    // Head of the double linked list of PACKET_BLOCKs.  Access to the
    // list is protected with 'lock' in this structure.
    //
    
    LIST_ENTRY  leBlockHead;

    //
    // Head of the double linked list of free PACKET_HEADs.  Each
    // PACKET_HEAD in the list is ready to go, i.e. it already has an
    // NDIS_PACKET associated with it.
    // Access to the list is prototected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    
    LIST_ENTRY  leFreePktHead;

    //
    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    
    RT_LOCK     rlLock;
    
}PACKET_POOL, *PPACKET_POOL;

//
// Header of a single block of packets from a packet pool.  The PACKET_HEAD of
// the first buffer immediately follows.
//

typedef struct _PACKET_BLOCK
{
    //
    // Links to the prev/next packet block header in the packet pool's list.
    //
    
    LIST_ENTRY      leBlockLink;

    //
    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    
    NDIS_HANDLE     nhNdisPool;

    //
    // Back pointer to the packet pool.
    //
    
    PPACKET_POOL    pPool;

    //
    // Number of individual packets in this block.
    //
    
    ULONG           ulPackets;

    //
    // Number of individual packets in this block on the free list.
    //
    
    ULONG           ulFreePackets;
    
}PACKET_BLOCK ,*PPACKET_BLOCK;

//
// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//

typedef struct _PACKET_HEAD
{
    //
    // Link to next packet header in the packet pool's free list.
    //
    
    LIST_ENTRY      leFreePktLink;

    //
    // Back link to owning packet block header.
    //
    
    PPACKET_BLOCK   pBlock;

    //
    // NDIS packet descriptor of this buffer.
    //
    
    PNDIS_PACKET    pNdisPacket;
    
}PACKET_HEAD, *PPACKET_HEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PPACKET_POOL pPool,
    IN  ULONG        ulProtocolReservedLength,
    IN  ULONG        ulMaxPackets,
    IN  ULONG        ulPacketsPerBlock,
    IN  ULONG        ulFreesPerCollection,
    IN  ULONG        ulTag
    );

BOOLEAN
FreePacketPool(
    IN PPACKET_POOL  pPool
    );

PNDIS_PACKET
GetPacketFromPool(
    IN  PPACKET_POOL pPool,
    OUT PACKET_HEAD  **ppHead
    );

VOID
FreePacketToPool(
    IN PPACKET_POOL  pPool,
    IN PPACKET_HEAD  pHead,
    IN BOOLEAN       fGarbageCollection
    );

//
// PPACKET_POOL
// PacketPoolFromPacketHead(
//    IN PPACKET_HEAD pHead
//    );
//


#define PacketPoolFromPacketHead(pHead) \
    ((pHead)->pBlock->pPool)


#endif // __IPINIP_PPOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\icmpfn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ipinip\icmpfn.c

Abstract:

    Handlers for ICMP messages relating to the tunnel

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

#define __FILE_SIG__    ICMP_SIG

#include "inc.h"

NTSTATUS
HandleTimeExceeded(
    PTUNNEL         pTunnel,
    PICMP_HEADER    pIcmpHeader,
    PIP_HEADER      pInHeader
    )

/*++

Routine Description


Locks

    The tunnels is locked and refcounted

Arguments

    pTunnel         Tunnel associated with the ICMP message
    pIcmpHeader     The ICMP header
    pInHeader       The original header

Return Value

    STATUS_SUCCESS

--*/

{
    PPENDING_MESSAGE    pMessage;

    //
    // We mark the tunnel as down.
    // Periodically we will sweep the tunnels and mark them as up
    //

#if DBG

    Trace(TUNN, INFO,
          ("HandleTimeExceeded: Time exceeded message for %s\n",
           pTunnel->asDebugBindName.Buffer));

#endif
          
          
    pTunnel->dwOperState    = IF_OPER_STATUS_NON_OPERATIONAL;
    pTunnel->dwAdminState  |= TS_TTL_TOO_LOW;

    pMessage = AllocateMessage();

    if(pMessage isnot NULL)
    {
        pMessage->inMsg.ieEvent     = IE_INTERFACE_DOWN;
        pMessage->inMsg.iseSubEvent = ISE_ICMP_TTL_TOO_LOW;
        pMessage->inMsg.dwIfIndex   = pTunnel->dwIfIndex;

        CompleteNotificationIrp(pMessage);
    }

    KeQueryTickCount((PLARGE_INTEGER)&((pTunnel->ullLastChange)));

    return STATUS_SUCCESS;
}

NTSTATUS
HandleDestUnreachable(
    PTUNNEL         pTunnel,
    PICMP_HEADER    pIcmpHeader,
    PIP_HEADER      pInHeader
    )

/*++

Routine Description


Locks

    The tunnels is locked and refcounted

Arguments

    pTunnel         Tunnel associated with the ICMP message
    pIcmpHeader     The ICMP header
    pInHeader       The original header

Return Value

    STATUS_SUCCESS

--*/

{
    PPENDING_MESSAGE    pMessage;


    if(pIcmpHeader->byCode is ICMP_CODE_DGRAM_TOO_BIG)
    {
        PICMP_DGRAM_TOO_BIG_MSG pMsg;
        ULONG                   ulNewMtu;  

        pMsg = (PICMP_DGRAM_TOO_BIG_MSG)pIcmpHeader;

        //
        // Change the MTU
        //

        ulNewMtu = (ULONG)(RtlUshortByteSwap(pMsg->usMtu) - MAX_IP_HEADER_LENGTH);

        if(ulNewMtu < pTunnel->ulMtu)
        {
            LLIPMTUChange       mtuChangeInfo;

#if DBG

            Trace(TUNN, INFO,
                  ("HandleDestUnreachable: Dgram too big %s. Old %d New %d\n",
                   pTunnel->asDebugBindName.Buffer,
                   pTunnel->ulMtu,
                   ulNewMtu));

#endif

            pTunnel->ulMtu        = ulNewMtu;
            mtuChangeInfo.lmc_mtu = ulNewMtu;

            g_pfnIpStatus(pTunnel->pvIpContext,
                          LLIP_STATUS_MTU_CHANGE,
                          &mtuChangeInfo,
                          sizeof(LLIPMTUChange),
                          NULL);
        }
        else
        {
            RtAssert(FALSE);
        }

        KeQueryTickCount((PLARGE_INTEGER)&((pTunnel->ullLastChange)));

        return STATUS_SUCCESS;
    }
        
    RtAssert(pIcmpHeader->byCode <= ICMP_CODE_DGRAM_TOO_BIG);

    //
    // Other codes are NetUnreachable, HostUnreachable, ProtoUnreachable
    // and PortUnreachable.
    //

    RtAssert(pIcmpHeader->byCode isnot ICMP_CODE_PORT_UNREACHABLE);

#if DBG

    Trace(TUNN, INFO,
          ("HandleDestUnreachable: Code %d\n",
           pIcmpHeader->byCode));

#endif

    //
    // For these codes, we mark the tunnel down.
    // Periodically we will sweep the tunnels and mark them as up
    //

    pTunnel->dwOperState    = IF_OPER_STATUS_NON_OPERATIONAL;
    pTunnel->dwAdminState  |= TS_DEST_UNREACH;

    pMessage = AllocateMessage();

    if(pMessage isnot NULL)
    {
        pMessage->inMsg.ieEvent     = IE_INTERFACE_DOWN;
        pMessage->inMsg.iseSubEvent = ISE_DEST_UNREACHABLE;
        pMessage->inMsg.dwIfIndex   = pTunnel->dwIfIndex;

        CompleteNotificationIrp(pMessage);
    }

    KeQueryTickCount((PLARGE_INTEGER)&((pTunnel->ullLastChange)));

    return STATUS_SUCCESS;
}

VOID
IpIpTimerRoutine(
    PKDPC   Dpc,
    PVOID   DeferredContext,
    PVOID   SystemArgument1,
    PVOID   SystemArgument2
    )

/*++

Routine Description:

    The DPC routine associated with the timer.

Locks:


Arguments:

    Dpc
    DeferredContext
    SystemArgument1
    SystemArgument2

Return Value:

    NONE

--*/

{
    PLIST_ENTRY     pleNode;
    LARGE_INTEGER   liDueTime;

    RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);

    if(g_dwDriverState != DRIVER_STARTED)
    {
        RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);

        return;
    }

    RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);

    EnterReaderAtDpcLevel(&g_rwlTunnelLock);

    for(pleNode = g_leTunnelList.Flink;
        pleNode isnot &g_leTunnelList;
        pleNode = pleNode->Flink)
    {
        PTUNNEL     pTunnel;
        ULONGLONG   ullCurrentTime;
        BOOLEAN     bChange;

        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leTunnelLink);


        //
        // Lock, but dont refcount the tunnel.
        // The ref is not needed since, we have the tunnel list lock and
        // that means the tunnel cant be remove from the list, which keeps
        // a refcount for us
        //

        RtAcquireSpinLockAtDpcLevel(&(pTunnel->rlLock));

        if(GetAdminState(pTunnel) isnot IF_ADMIN_STATUS_UP)
        {
            //
            // TODO: maybe we should move admin state under the tunnel list 
            // lock? Possibly a perf improvement
            //

            RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

            continue;
        }

        KeQueryTickCount((PLARGE_INTEGER)&ullCurrentTime);
       
        //
        // If the tunnel has a local address and either (i) the counter has 
        // rolled over or (ii) more than the change period time has passed 
        // - update its mtu and reachability info
        // The change period is different depending on whether the tunnel is
        // UP or DOWN
        //

        if(pTunnel->dwOperState is IF_OPER_STATUS_OPERATIONAL)
        {
            bChange = ((ullCurrentTime - pTunnel->ullLastChange) >= 
                       SECS_TO_TICKS(UP_TO_DOWN_CHANGE_PERIOD));
        }
        else
        {
            bChange = ((ullCurrentTime - pTunnel->ullLastChange) >= 
                       SECS_TO_TICKS(DOWN_TO_UP_CHANGE_PERIOD));
        }

        if((pTunnel->dwAdminState & TS_ADDRESS_PRESENT) and
           ((pTunnel->ullLastChange > ullCurrentTime) or
            bChange))
        {

#if DBG

            Trace(TUNN, INFO,
                  ("IpIpTimerRoutine: Updating %s\n",
                   pTunnel->asDebugBindName.Buffer));

#endif

            //
            // If everything is good, it will set the OperState to up
            //

            UpdateMtuAndReachability(pTunnel);
        }

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
    }

    ExitReaderFromDpcLevel(&g_rwlTunnelLock);

    liDueTime = RtlEnlargedUnsignedMultiply(TIMER_IN_MILLISECS,
                                            SYS_UNITS_IN_ONE_MILLISEC);

    liDueTime = RtlLargeIntegerNegate(liDueTime);

    KeSetTimerEx(&g_ktTimer,
                 liDueTime,
                 0,
                 &g_kdTimerDpc);
 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\ioctl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ipinip\ioctl.c

Abstract:

    IOCTL handlers for IP in IP encapsulation driver

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/


#define __FILE_SIG__    IOCT_SIG

#include "inc.h"


NTSTATUS
AddTunnelInterface(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description

    This is the handler for IOCTL_IPINIP_CREATE_TUNNEL.  We do the normal
    buffer length checks. 

Locks

    None

Arguments

    pIrp          IRP 
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL      
    STATUS_INFO_LENGTH_MISMATCH
    STATUS_INVALID_PARAMETER

--*/

{
    PVOID       pvIoBuffer;
    NTSTATUS    nStatus;
    PTUNNEL     pTunnel;
    KIRQL       irql; 
    ULONG       i, ulMaxLength;
    BOOLEAN     bTerminated;
    DWORD       dwNewIndex;

    PIPINIP_CREATE_TUNNEL   pCreateInfo;

    TraceEnter(TUNN, "AddTunnelInterface");

    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pCreateInfo = (PIPINIP_CREATE_TUNNEL)pvIoBuffer;

    //
    // Always clean out the information field
    //

    pIrp->IoStatus.Information   = 0;

    if(ulInLength < sizeof(IPINIP_CREATE_TUNNEL))
    {
        Trace(TUNN, ERROR,
              ("AddTunnelInterface: In Length %d too small\n",
               ulInLength));

        TraceLeave(TUNN, "AddTunnelInterface");

        return STATUS_BUFFER_TOO_SMALL;
    }

    if(ulOutLength < sizeof(IPINIP_CREATE_TUNNEL))
    {
        Trace(TUNN, ERROR,
              ("AddTunnelInterface: Out Length %d too small\n",
               ulInLength));

        TraceLeave(TUNN, "AddTunnelInterface");

        return STATUS_BUFFER_TOO_SMALL;
    }

    nStatus = IpIpCreateAdapter(pCreateInfo,
                                0,
                                &dwNewIndex);

   
    if(nStatus is STATUS_SUCCESS)
    {
        pIrp->IoStatus.Information = sizeof(IPINIP_CREATE_TUNNEL);

        pCreateInfo->dwIfIndex = dwNewIndex;
    }

    TraceLeave(TUNN, "AddTunnelInterface");
    
    return nStatus;
}



NTSTATUS
DeleteTunnelInterface(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description

    This is the handler for IOCTL_IPINIP_DELETE_TUNNEL.  

Locks

    Takes the tunnel list lock as writer and the tunnel lock

Arguments

    pIrp          IRP 
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL      
    STATUS_OBJECT_NAME_NOT_FOUND

--*/

{
    PVOID       pvIoBuffer;
    NTSTATUS    nStatus;
    PTUNNEL     pTunnel;
    KIRQL       irql; 
    ULONG       i;
    LIST_ENTRY  leTempList;

    PIPINIP_DELETE_TUNNEL   pDeleteInfo;

    TraceEnter(TUNN, "DeleteTunnelInterface");

    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pDeleteInfo = (PIPINIP_DELETE_TUNNEL)pvIoBuffer;

    //
    // Always clean out the information field
    //

    pIrp->IoStatus.Information   = 0;

    if(ulInLength < sizeof(IPINIP_DELETE_TUNNEL))
    {
        Trace(TUNN, ERROR,
              ("DeleteTunnelInterface: In Length %d too small\n",
               ulInLength));

        TraceLeave(TUNN, "DeleteTunnelInterface");

        return STATUS_BUFFER_TOO_SMALL;
    }

    InitializeListHead(&leTempList);

    EnterReader(&g_rwlTunnelLock,
                &irql);
    
    pTunnel = FindTunnelGivenIndex(pDeleteInfo->dwIfIndex);

    if(pTunnel is NULL)
    {
        ExitReader(&g_rwlTunnelLock,
                   irql);
        
        //
        // Could not find the tunnel for the given index
        //
        
        Trace(TUNN, ERROR,
              ("DeleteTunnelInterface: Couldnt find tunnel for index %d\n",
               pDeleteInfo->dwIfIndex));

        TraceLeave(TUNN, "DeleteTunnelInterface");
    
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if(IsTunnelMapped(pTunnel))
    {
        //
        // Remove it from the address blocks
        //

        RemoveEntryList(&(pTunnel->leAddressLink));
    }

    //
    // Mark the tunnel as unmapped
    //

    MarkTunnelUnmapped(pTunnel);

    //
    // Remove the tunnel from the list
    //

    RemoveEntryList(&(pTunnel->leTunnelLink));

    pTunnel->dwAdminState |= TS_DELETING;

    pTunnel->dwOperState = IF_OPER_STATUS_NON_OPERATIONAL;
  
    //
    // If there are queued packets, copy out the queue
    //

    if(!IsListEmpty(&(pTunnel->lePacketQueueHead)))
    {
        //
        // Copy out Flink and Blink
        //

        leTempList = pTunnel->lePacketQueueHead;

        //
        // Set Flink's Blink
        //

        leTempList.Flink->Blink = &leTempList;

        //
        // Set Blink's Flink
        //

        leTempList.Blink->Flink = &leTempList;
    }

    RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));


    //
    // Deref the tunnel once for deleting it from the list
    //

    DereferenceTunnel(pTunnel);

    //
    // Protected by the tunnel lock
    //

    g_ulNumTunnels--;

    //
    // Let go of the lock
    //

    ExitReader(&g_rwlTunnelLock, irql);

    //
    // Before deleting from IP, free all the packets
    //

    while(!IsListEmpty(&leTempList))
    {
        PLIST_ENTRY pleNode;
        PQUEUE_NODE pQueueNode;

        pleNode = RemoveHeadList(&leTempList);

        pQueueNode = CONTAINING_RECORD(pleNode,
                                       QUEUE_NODE,
                                       leQueueItemLink);

        for(i = 0; i < pQueueNode->uiNumPackets; i++)
        {
            PNDIS_PACKET    pnpPacket;

            pnpPacket = pQueueNode->ppPacketArray[i];

            //
            // ok to access pvIpContext since we have a reference
            // and the tunnel is not going away
            //

            g_pfnIpSendComplete(pTunnel->pvIpContext,
                                pnpPacket,
                                NDIS_STATUS_ADAPTER_NOT_READY);
        }

        FreeQueueNode(pQueueNode);
    }

    //
    // Now delete the interface
    //

    g_pfnIpDeleteInterface(pTunnel->pvIpContext,
                           TRUE);

    //
    // Dereference the tunnel for deleting it from IP
    // and once more because FindTunnel... put a ref on it
    //

    DereferenceTunnel(pTunnel);
    DereferenceTunnel(pTunnel);

    TraceLeave(TUNN, "DeleteTunnelInterface");
    
    return STATUS_SUCCESS;
}


NTSTATUS
SetTunnelInfo(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description

    This is the handler for IOCTL_IPINIP_SET_TUNNEL.  We do the normal
    buffer length checks. 

Locks

    Takes the tunnel list lock as writer and the tunnel lock

Arguments

    pIrp          IRP 
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL      
    STATUS_INSUFFICIENT_RESOURCES
    STATUS_OBJECT_NAME_NOT_FOUND
    STATUS_INVALID_PARAMETER

--*/

{
    PVOID       pvIoBuffer;
    NTSTATUS    nsStatus;
    PTUNNEL     pTunnel;
    KIRQL       irql; 
    LIST_ENTRY  leTempList;
    ULONG       i;

    PIPINIP_SET_TUNNEL_INFO pSet;
    PTDI_ADDRESS_IP         pTdiIp;
    PADDRESS_BLOCK          pAddrBlock;

    TraceEnter(TUNN, "SetTunnelInfo");

    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pSet = (PIPINIP_SET_TUNNEL_INFO)pvIoBuffer;

    //
    // Always clean out the information field
    //

    pIrp->IoStatus.Information   = 0;

    if(ulInLength < sizeof(IPINIP_SET_TUNNEL_INFO))
    {
        Trace(TUNN, ERROR,
              ("SetTunnelInfo: In Length %d too small\n",
               ulInLength));

        TraceLeave(TUNN, "SetTunnelInfo");

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Validate the parameters
    //

    if((pSet->dwLocalAddress is INVALID_IP_ADDRESS) or
       (pSet->dwRemoteAddress is INVALID_IP_ADDRESS) or
       ((DWORD)(pSet->dwLocalAddress & 0x000000E0) >= (DWORD)0x000000E0) or
       ((DWORD)(pSet->dwRemoteAddress & 0x000000E0) >= (DWORD)0x000000E0) or
       (pSet->byTtl is 0))
    {
        Trace(TUNN, ERROR,
              ("SetTunnelInfo: One of %d.%d.%d.%d %d.%d.%d.%d %d is invalid\n",
               PRINT_IPADDR(pSet->dwLocalAddress),
               PRINT_IPADDR(pSet->dwRemoteAddress),
               pSet->byTtl));

        TraceLeave(TUNN, "SetTunnelInfo");

        return STATUS_INVALID_PARAMETER;
    }

    InitializeListHead(&leTempList);

    EnterWriter(&g_rwlTunnelLock,
                &irql);
    
    pTunnel = FindTunnelGivenIndex(pSet->dwIfIndex);

    if(pTunnel is NULL)
    {
        ExitWriter(&g_rwlTunnelLock,
                   irql);
        
        //
        // Could not find the tunnel for the given index
        //
        
        Trace(TUNN, ERROR,
              ("SetTunnelInfo: Couldnt find tunnel for index %d\n",
               pSet->dwIfIndex));

        TraceLeave(TUNN, "SetTunnelInfo");
    
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    if(IsTunnelMapped(pTunnel))
    {
        Trace(TUNN, TRACE,
              ("SetTunnelInfo: Tunnel already mapped\n"));

        //
        // if we are only changing the TTL, alles okay
        //

        if((pSet->dwRemoteAddress is pTunnel->REMADDR) and
           (pSet->dwLocalAddress is pTunnel->LOCALADDR))
        {
            Trace(TUNN, TRACE,
                  ("SetTunnelInfo: Only changing TTL on mapped tunnel\n"));

            pTunnel->byTtl = pSet->byTtl;

            RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
        
            DereferenceTunnel(pTunnel);

            ExitWriter(&g_rwlTunnelLock,
                       irql);

            TraceLeave(TUNN, "SetTunnelInfo");

            return STATUS_SUCCESS;
        }

        //
        // So addresses are changing..
        //

        Trace(TUNN, TRACE,
              ("SetTunnelInfo: Changing address on mapped tunnel\n"));

        //
        // Remove it from the address blocks
        //

        RemoveEntryList(&(pTunnel->leAddressLink));

        //
        // This also marks it unmapped
        //

        pTunnel->dwAdminState = IF_ADMIN_STATUS_DOWN;
        pTunnel->dwOperState  = IF_OPER_STATUS_NON_OPERATIONAL;

        //
        // Copy out the queued packets to delete later
        //

        if(!IsListEmpty(&(pTunnel->lePacketQueueHead)))
        {
            //
            // Copy out Flink and Blink
            //

            leTempList = pTunnel->lePacketQueueHead;
    
            //
            // Set Flink's Blink
            //

            leTempList.Flink->Blink = &leTempList;

            //
            // Set Blink's Flink
            //

            leTempList.Blink->Flink = &leTempList;
        }
    }
    else
    {
        RtAssert(IsListEmpty(&(pTunnel->lePacketQueueHead)));
    }

    //
    // Set the state down
    //

    pTunnel->dwOperState  = IF_OPER_STATUS_NON_OPERATIONAL;
    pTunnel->dwAdminState = IF_ADMIN_STATUS_UP;

    //
    // See if we have the address block for this
    //

    pAddrBlock = GetAddressBlock(pSet->dwLocalAddress);

    if(pAddrBlock)
    {
        RtAssert(pAddrBlock->dwAddress is pSet->dwLocalAddress);

        if(pAddrBlock->bAddressPresent)
        {
            pTunnel->dwAdminState |= TS_ADDRESS_PRESENT;
        }
    }
    else
    {
        //
        // Create one
        //

        pAddrBlock = RtAllocate(NonPagedPool,
                                sizeof(ADDRESS_BLOCK),
                                TUNNEL_TAG);

        if(pAddrBlock is NULL)
        {
            RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

            ExitWriter(&g_rwlTunnelLock,
                       irql);

            DereferenceTunnel(pTunnel);

            Trace(TDI, ERROR,
                  ("TdixAddressArrival: Unable to allocate address block\n"));

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pAddrBlock->dwAddress       = pSet->dwLocalAddress;
        pAddrBlock->bAddressPresent = FALSE;

        InitializeListHead(&(pAddrBlock->leTunnelList));

        InsertHeadList(&g_leAddressList,
                       &(pAddrBlock->leAddressLink));
    }
       
    //
    // Link this onto the address
    //

    InsertHeadList(&(pAddrBlock->leTunnelList),
                   &(pTunnel->leAddressLink));
 
    pTunnel->REMADDR    = pSet->dwRemoteAddress;
    pTunnel->LOCALADDR  = pSet->dwLocalAddress;
    pTunnel->byTtl      = pSet->byTtl;

    MarkTunnelMapped(pTunnel);

    //
    // Initialize the TDI structure for this
    //

    pTdiIp = &(pTunnel->tiaIpAddr.Address[0].Address[0]);

    pTdiIp->sin_port = 0;
    pTdiIp->in_addr  = pTunnel->REMADDR;

    if(pTunnel->dwAdminState & TS_ADDRESS_PRESENT)
    {
        UpdateMtuAndReachability(pTunnel);
    }

    //
    // Return the current operational state to the user
    //

    pSet->dwOperationalState = pTunnel->dwOperState;

    RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

    ExitWriter(&g_rwlTunnelLock,
               irql);


    //
    // Before dereferencing
    //

    while(!IsListEmpty(&leTempList))
    {
        PLIST_ENTRY pleNode;
        PQUEUE_NODE pQueueNode;

        pleNode = RemoveHeadList(&leTempList);

        pQueueNode = CONTAINING_RECORD(pleNode,
                                       QUEUE_NODE,
                                       leQueueItemLink);

        for(i = 0; i < pQueueNode->uiNumPackets; i++)
        {
            PNDIS_PACKET    pnpPacket;

            pnpPacket = pQueueNode->ppPacketArray[i];

            //
            // ok to access pvIpContext since we have a reference
            // and the tunnel is not going away
            //

            g_pfnIpSendComplete(pTunnel->pvIpContext,
                                pnpPacket,
                                NDIS_STATUS_ADAPTER_NOT_READY);
        }

        FreeQueueNode(pQueueNode);
    }
    
    DereferenceTunnel(pTunnel);

    TraceLeave(TUNN, "SetTunnelInfo");
   
    pIrp->IoStatus.Information = sizeof(IPINIP_SET_TUNNEL_INFO);

    return STATUS_SUCCESS;
}


NTSTATUS
GetTunnelTable(
    IN  PIRP   pIrp,
    IN  ULONG  ulInLength,
    IN  ULONG  ulOutLength
    )

/*++

Routine Description

    This is the handler for IOCTL_IPINIP_GET_TUNNEL.  We do the normal
    buffer length checks. 

Locks

   Takes the tunnel list lock as Reader

Arguments

    pIrp          IRP 
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer

Return Value

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL      

--*/

{
    PVOID           pvIoBuffer;
    ULONG           i;
    NTSTATUS        nsStatus;
    KIRQL           irql;
    PLIST_ENTRY     pleNode;
    PTUNNEL         pTunnel;

    PIPINIP_TUNNEL_TABLE    pTunnelTable;

    
    TraceEnter(TUNN, "GetTunnels");
    
    //
    // Get the user buffer
    //

    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;

    pTunnelTable = (PIPINIP_TUNNEL_TABLE)pvIoBuffer;

    //
    // Always clean out the information field
    //

    pIrp->IoStatus.Information   = 0;

    if(ulOutLength < SIZEOF_BASIC_TUNNEL_TABLE)
    {
        Trace(TUNN, ERROR,
              ("GetTunnels: In Length %d too smaller than smallest table %d\n",
               ulInLength,
               SIZEOF_BASIC_TUNNEL_TABLE));

        TraceLeave(TUNN, "GetTunnels");

        return STATUS_BUFFER_TOO_SMALL;
    }

    EnterReader(&g_rwlTunnelLock,
                &irql);

    if(ulOutLength < SIZEOF_TUNNEL_TABLE(g_ulNumTunnels))
    {
        ExitReader(&g_rwlTunnelLock,
                   irql);

        Trace(TUNN, ERROR,
              ("GetTunnels: Len %d is less than required (%d) for %d i/f\n",
               ulOutLength,
               SIZEOF_TUNNEL_TABLE(g_ulNumTunnels),
               g_ulNumTunnels));

        pTunnelTable->ulNumTunnels = g_ulNumTunnels;

        pIrp->IoStatus.Information = SIZEOF_BASIC_TUNNEL_TABLE;

        TraceLeave(TUNN, "GetTunnels");
    
        return STATUS_SUCCESS;
    }

    pTunnelTable->ulNumTunnels = g_ulNumTunnels;
    
    //
    // So we have enough space to fill the tunnel
    //

    for(pleNode = g_leTunnelList.Flink, i = 0;
        pleNode isnot &g_leTunnelList;
        pleNode = pleNode->Flink, i++)
    {
        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leTunnelLink);

        pTunnelTable->rgTable[i].dwIfIndex       = pTunnel->dwIfIndex;
        pTunnelTable->rgTable[i].dwRemoteAddress = pTunnel->REMADDR;
        pTunnelTable->rgTable[i].dwLocalAddress  = pTunnel->LOCALADDR;
        pTunnelTable->rgTable[i].fMapped         = IsTunnelMapped(pTunnel);
        pTunnelTable->rgTable[i].byTtl           = pTunnel->byTtl;
    }

    RtAssert(i is g_ulNumTunnels);

    ExitReader(&g_rwlTunnelLock,
               irql);

    pIrp->IoStatus.Information = SIZEOF_TUNNEL_TABLE(i);

    TraceLeave(TUNN, "GetTunnels");
    
    return STATUS_SUCCESS;
}

NTSTATUS
ProcessNotification(
    PIRP    pIrp,
    ULONG   ulInLength,
    ULONG   ulOutLength
    )

/*++

Routine Description:
      
    The handler for IOCTL_IPINIP_NOTIFICATION. We see if we have some info
    we wish to return to the caller and if we do, we return it. Otherwise,
    we pend the IRP and use it later when we need to report an event to
    the user mode
    
Locks: 

    Acquires the IoCancelSpinLock
    
Arguments:
      
    pIrp          IRP 
    ulInLength    The length of the Input Buffer
    ulOutLength   The length of the Output Buffer
    
Return Value:

    STATUS_PENDING
    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL
    
--*/

{
    KIRQL       kiIrql;
    PLIST_ENTRY pleNode;
    PVOID       pvIoBuffer;
    
    PPENDING_MESSAGE   pMessage;

    TraceEnter(GLOBAL, "ProcessNotification");
 
    pvIoBuffer   = pIrp->AssociatedIrp.SystemBuffer;
    
    pIrp->IoStatus.Information = 0;

    if((ulInLength < sizeof(IPINIP_NOTIFICATION)) or
       (ulOutLength < sizeof(IPINIP_NOTIFICATION)))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
        
    //
    // use cancel spin lock to prevent irp being cancelled during this call.
    //
    
    IoAcquireCancelSpinLock(&kiIrql);
    
    //
    // If we have a pending notification then complete it - else
    // queue the notification IRP
    //
    
    if(!IsListEmpty(&g_lePendingMessageList))
    {
        //
        // We have some old info
        //

        Trace(GLOBAL, TRACE,
              ("ProcNotification: Pending message being completed\n"));

        //
        // Remove it off the pending list
        //
        
        pleNode = RemoveHeadList(&g_lePendingMessageList);

        //
        // Get a pointer to the structure
        //
        
        pMessage = CONTAINING_RECORD(pleNode,
                                     PENDING_MESSAGE,
                                     leMessageLink);

        //
        // Copy out the event to the user mode buffer
        //
        
        RtlCopyMemory(pIrp->AssociatedIrp.SystemBuffer,
                      &pMessage->inMsg,
                      sizeof(IPINIP_NOTIFICATION));

        //
        // Mark the IRP as non pending (and hence non cancelable)
        //
        
        IoSetCancelRoutine(pIrp,
                           NULL);

        //
        // Fill the irp info
        //
        
        pIrp->IoStatus.Information = sizeof(IPINIP_NOTIFICATION);

        IoReleaseCancelSpinLock(kiIrql);
        
        //
        // Free the allocated message
        //
        
        FreeMessage(pMessage);
        
        return STATUS_SUCCESS;
    }


    Trace(GLOBAL, TRACE,
          ("ProcNotification: Notification being queued\n")); 


    //
    // Queue this IRP to use for later
    // First, mark the irp as pending
    //
    
    IoMarkIrpPending(pIrp);

    //
    // Queue up the irp at the end
    //
    
    InsertTailList(&g_lePendingIrpList,
                   &(pIrp->Tail.Overlay.ListEntry));

    //
    // Set the cancel routine
    //
    
    IoSetCancelRoutine(pIrp,
                       CancelNotificationIrp);
        
    IoReleaseCancelSpinLock(kiIrql);
        
    return STATUS_PENDING;
}

VOID
CancelNotificationIrp(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp
    )

/*++

Routine Description:

    Called to cancel a queued irp
  
Locks: 

    Called with the IoCancelSpinLock acquired
    
Arguments:
      
    pDeviceObject
    pIrp
    
Return Value:

    None
    
--*/

{
    TraceEnter(GLOBAL, "CancelNotificationIrp");

    //
    // Mark this Irp as cancelled
    //
    
    pIrp->IoStatus.Status        = STATUS_CANCELLED;
    pIrp->IoStatus.Information   = 0;

    //
    // Take off our own list
    //
    
    RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

    //
    // Release cancel spin lock which the IO system acquired
    //
    
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    IoCompleteRequest(pIrp,
                      IO_NETWORK_INCREMENT);
}


VOID
CompleteNotificationIrp(
    PPENDING_MESSAGE    pMessage
    )

/*++

Routine Description:

    Called to send a message to user mode
  
Locks: 

    Acquires the IoCancelSpinLock
    
Arguments:
      
    pEvent
    
Return Value:

    None
    
--*/

{
    KIRQL   kiIrql;
    
    TraceEnter(GLOBAL, "CompleteNotificationIrp");

    //
    // grab cancel spin lock
    //
    
    IoAcquireCancelSpinLock(&kiIrql);

    if(!IsListEmpty(&g_lePendingIrpList))
    {
        PLIST_ENTRY pleNode;
        PIRP        pIrp;

        //
        // We have a pending IRP. Use it to return info to router manager
        //
        
        pleNode = RemoveHeadList(&g_lePendingIrpList) ;

        pIrp = CONTAINING_RECORD(pleNode,
                                 IRP,
                                 Tail.Overlay.ListEntry);
        
        RtlCopyMemory(pIrp->AssociatedIrp.SystemBuffer,
                      &(pMessage->inMsg),
                      sizeof(IPINIP_NOTIFICATION));
        
        Trace(GLOBAL, TRACE,
              ("CompleteNotificationIrp: Returning Irp with event code of %d\n",
               ((PIPINIP_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer)->ieEvent));
        
        IoSetCancelRoutine(pIrp,
                           NULL);

        pIrp->IoStatus.Status       = STATUS_SUCCESS;
        pIrp->IoStatus.Information  = sizeof(IPINIP_NOTIFICATION);

        //
        // release lock
        //
        
        IoReleaseCancelSpinLock(kiIrql);

        IoCompleteRequest(pIrp,
                          IO_NETWORK_INCREMENT);

        //
        // Free the allocated Message
        //
        
        FreeMessage(pMessage);

    }
    else
    {
        Trace(GLOBAL, TRACE,
              ("CompleteNotificationIrp: Found no pending Irp so queuing message\n"));

        
        InsertTailList(&g_lePendingMessageList,
                       &(pMessage->leMessageLink));

        //
        // release lock
        //
        
        IoReleaseCancelSpinLock(kiIrql);
    }
}

PADDRESS_BLOCK
GetAddressBlock(
    DWORD   dwAddress
    )

/*++

Routine Description

    Looks up the address block for the given address

Locks

    Must be called with the g_rwlTunnelLock held    

Arguments

    dwAddress

Return Value

    Pointer to the address block
    NULL if not found
    
--*/

{
    PLIST_ENTRY pleNode;

    for(pleNode = g_leAddressList.Flink;
        pleNode isnot &g_leAddressList;
        pleNode = pleNode->Flink)
    {
        PADDRESS_BLOCK  pAddrBlock;

        pAddrBlock = CONTAINING_RECORD(pleNode,
                                       ADDRESS_BLOCK,
                                       leAddressLink);

        if(pAddrBlock->dwAddress is dwAddress)
        {
            return pAddrBlock;
        }
    }

    return NULL;
}

VOID
UpdateMtuAndReachability(
    PTUNNEL pTunnel
    )

/*++

Routine Description

    Updates the MTU and reachability info for a tunnel

Locks

    Must be called with the Tunnel locked and referenced

Arguments

    pTunnel

Return Value

    None

--*/

{
    DWORD           dwLocalNet;
    RouteCacheEntry *pDummyRce;
    BYTE            byType;
    USHORT          usMtu;
    IPOptInfo       OptInfo;
    BOOLEAN         bChange;
    ULONG           ulNewMtu;

    PPENDING_MESSAGE    pMessage;

    bChange = FALSE;

    RtAssert(pTunnel->dwAdminState & TS_ADDRESS_PRESENT);
    RtAssert(IsTunnelMapped(pTunnel));

    RtlZeroMemory(&OptInfo,
                  sizeof(OptInfo));

    //
    // See if the remote address is reachable and what the MTU is.
    //

    dwLocalNet = g_pfnOpenRce(pTunnel->REMADDR,
                              pTunnel->LOCALADDR,
                              &pDummyRce,
                              &byType,
                              &usMtu,
                              &OptInfo);

    if(dwLocalNet isnot NULL_IP_ADDR)
    {
        LLIPMTUChange       mtuChangeInfo;

        pTunnel->dwAdminState |= TS_ADDRESS_REACHABLE;

        //
        // Clear out any error bits
        //

        ClearErrorBits(pTunnel);

        //
        // Set the MTU if its changed
        //

        RtAssert(usMtu > MAX_IP_HEADER_LENGTH);

        ulNewMtu = usMtu - MAX_IP_HEADER_LENGTH;

        if(pTunnel->ulMtu isnot ulNewMtu)
        {
            bChange = TRUE;

            pTunnel->ulMtu = ulNewMtu;

            mtuChangeInfo.lmc_mtu = pTunnel->ulMtu;

            g_pfnIpStatus(pTunnel->pvIpContext,
                          LLIP_STATUS_MTU_CHANGE,
                          &mtuChangeInfo,
                          sizeof(LLIPMTUChange),
                          NULL);
        }

        if(pTunnel->dwOperState isnot IF_OPER_STATUS_OPERATIONAL)
        {
            bChange = TRUE;

            pTunnel->dwOperState = IF_OPER_STATUS_OPERATIONAL;
        }

        //
        // Close the RCE
        //

        g_pfnCloseRce(pDummyRce);
    }
    else
    {
        pTunnel->dwAdminState &= ~TS_ADDRESS_REACHABLE;
 
        if(pTunnel->dwOperState isnot IF_OPER_STATUS_NON_OPERATIONAL)
        {
            bChange = TRUE;

            pTunnel->dwOperState = IF_OPER_STATUS_NON_OPERATIONAL;
        }
    }

    if(bChange)
    {
        pMessage = AllocateMessage();

        if(pMessage isnot NULL)
        {
            if(pTunnel->dwOperState is IF_OPER_STATUS_OPERATIONAL)
            {
                pMessage->inMsg.ieEvent = IE_INTERFACE_UP;
            }
            else
            {
                pMessage->inMsg.ieEvent = IE_INTERFACE_DOWN;
            }

            pMessage->inMsg.iseSubEvent = 0xFFFFFFFF;
            pMessage->inMsg.dwIfIndex   = pTunnel->dwIfIndex;

            CompleteNotificationIrp(pMessage);
        }
    }

    KeQueryTickCount((PLARGE_INTEGER)&((pTunnel->ullLastChange)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\ppool.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\ppool.h

Abstract:

    Code for managing NDIS_PACKET pools. This is merely a reformatted version
    of SteveC's l2tp\ppool.c

Revision History:


--*/

#define __FILE_SIG__    PPOOL_SIG

#include "inc.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PPACKET_HEAD
AddPacketBlockToPool(
    IN PPACKET_POOL pPool
    );

VOID
FreeUnusedPacketPoolBlocks(
    IN PPACKET_POOL pPool
    );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PPACKET_POOL pPool,
    IN  ULONG        ulProtocolReservedLength,
    IN  ULONG        ulMaxPackets,
    IN  ULONG        ulPacketsPerBlock,
    IN  ULONG        ulFreesPerCollection,
    IN  ULONG        ulTag
    )
/*++
Routine Description

    Initialize caller's packet pool control block 'pPool'

Locks

    Caller's 'pPool' packet must be protected from multiple access during
    this call.
    
Arguments

    ulProtocolReservedLength    size in bytes of the 'ProtocolReserved'
                                array of each individual packet.
    ulMaxPackets                maximum number of packets allowed in the
                                entire pool, or 0 for unlimited.
    ulPacketsPerBlock           number of packets to include in each block
                                of packets.
    ulFreesPerCollection        number of FreePacketToPool calls until the
                                next garbage collect scan, or 0 for default.
    ulTag                       pool tag to use when allocating blocks
    
Return Value

    None

--*/
{
    pPool->ulProtocolReservedLength     = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock            = ulPacketsPerBlock;
    pPool->ulMaxPackets                 = ulMaxPackets;
    pPool->ulFreesSinceCollection       = 0;
    pPool->ulTag                        = ulTag;

    if(ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        //
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        
        pPool->ulFreesPerCollection = 50 * pPool->ulPacketsPerBlock;
    }

    InitializeListHead(&(pPool->leBlockHead));
    InitializeListHead(&(pPool->leFreePktHead));
    
    RtInitializeSpinLock(&(pPool->rlLock));
}


BOOLEAN
FreePacketPool(
    IN PPACKET_POOL pPool
    )
/*++
Routine Description

    Free up all resources allocated in packet pool 'pPool'.  This is the
    inverse of InitPacketPool.

Locks


Arguments


Return Value

    TRUE    if successful
    FALSE   if any of the pool could not be freed due to outstanding packets

--*/
{
    BOOLEAN fSuccess;
    KIRQL   irql;
    
    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    FreeUnusedPacketPoolBlocks(pPool);

    fSuccess = (pPool->ulCurPackets is 0);

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    return fSuccess;
}


PNDIS_PACKET
GetPacketFromPool(
    IN  PPACKET_POOL pPool,
    OUT PACKET_HEAD  **ppHead
    )
/*++
Routine Description

    Returns the address of the NDIS_PACKET descriptor allocated from the
    pool. The pool is expanded, if necessary, but caller should
    still check for NULL return since the pool may have been at maximum
    size. 

Locks


Arguments

    pPool   Pool to get packet from
    ppHead  Pointer the "cookie" that is used to return the packet to
            the pool (see FreePacketToPool).  Caller would normally stash this
            value in the appropriate 'reserved' areas of the packet for
            retrieval later.
            
Return Value

    Pointer to NDIS_PACKET or NULL

--*/
{
    PLIST_ENTRY  pleNode;
    PPACKET_HEAD pHead;
    PNDIS_PACKET pPacket;
    KIRQL        irql;


    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    if(IsListEmpty(&pPool->leFreePktHead))
    {
        pleNode = NULL;
    }
    else
    {
        pleNode = RemoveHeadList(&(pPool->leFreePktHead));
        
        pHead = CONTAINING_RECORD(pleNode, PACKET_HEAD, leFreePktLink);
        
        pHead->pBlock->ulFreePackets--;
    }

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);

    if(!pleNode)
    {
        //
        // The free list was empty.  Try to expand the pool.
        //
        
        pHead = AddPacketBlockToPool(pPool);
        
        if(!pHead)
        {
            return NULL;
        }
    }

    *ppHead = pHead;
    
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PPACKET_POOL pPool,
    IN PPACKET_HEAD pHead,
    IN BOOLEAN      fGarbageCollection
    )
/*++
Routine Description

    Returns a packet to the pool of unused packet. The packet must have
    been previously allocate with GetaPacketFromPool.
    
Locks


Arguments

    pPool   Pool to which the packet is to be returned
    pHead   The "cookie" that was given when the packet was allocated
    
    fGarbageCollection is set when the free should be considered for
    purposes of garbage collection.  This is used by the AddPacketToPool
    routine to avoid counting the initial "add" frees.  Normal callers
    should set this flag.
    
Return Value
    NO_ERROR

--*/
{
    KIRQL   irql;

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    InsertHeadList(&(pPool->leFreePktHead),
                   &(pHead->leFreePktLink));
    
    pHead->pBlock->ulFreePackets++;
    
    if(fGarbageCollection)
    {
        pPool->ulFreesSinceCollection++;
        
        if(pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
        {
            //
            // Time to collect garbage, i.e. free any blocks in the pool
            // not in use.
            //
            
            FreeUnusedPacketPoolBlocks(pPool);
            
            pPool->ulFreesSinceCollection = 0;
        }   
    }   

    RtReleaseSpinLock(&(pPool->rlLock),
                      irql);
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PPACKET_HEAD
AddPacketBlockToPool(
    IN PPACKET_POOL pPool
    )
/*++
Routine Description

    Allocate a new packet block and add it to the packet pool

Locks


Arguments


Return Value
    NO_ERROR

--*/
{
    NDIS_STATUS     status;
    PPACKET_BLOCK   pNew;
    ULONG           ulSize;
    ULONG           ulCount;
    BOOLEAN         fOk;
    PPACKET_HEAD    pReturn;
    KIRQL           irql;

    
    fOk  = FALSE;
    pNew = NULL;

    RtAcquireSpinLock(&(pPool->rlLock),
                      &irql);

    do
    {
        if((pPool->ulMaxPackets) and
           (pPool->ulCurPackets >= pPool->ulMaxPackets))
        {
            //
            // No can do.  The pool was initialized with a max size and that
            // has been reached.
            //
            
            break;
        }

        //
        // Calculate the contiguous block's size and the number of packets
        // it will hold.
        //

        ulCount = pPool->ulPacketsPerBlock;
            
        if(pPool->ulMaxPackets)
        {
            if(ulCount > (pPool->ulMaxPackets - pPool->ulCurPackets))
            {
                //
                // If a max was specified, respect that
                //
                
                ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
            }
        }

        //
        // We allocate a PACKET_BLOCK to account for this block of packets
        // and one PACKET_HEAD per packet
        //
        
        ulSize = sizeof(PACKET_BLOCK) + (ulCount * sizeof(PACKET_HEAD));

        //
        // Allocate the contiguous memory block for the PACKETBLOCK header
        // and the individual PACKET_HEADs.
        //
        
        pNew = RtAllocate(NonPagedPool,
                          ulSize,
                          pPool->ulTag);

        if(!pNew)
        {
            Trace(UTIL, ERROR,
                  ("AddPacketBlockToPool: Unable to allocate %d bytes\n",
                   ulSize));
            
            break;
        }

        //
        // Zero only the block header portion.
        //
        
        NdisZeroMemory(pNew, sizeof(PACKET_BLOCK));

        //
        // Allocate a pool of NDIS_PACKET descriptors.
        //
        
        NdisAllocatePacketPool(&status,
                               &pNew->nhNdisPool,
                               ulCount,
                               pPool->ulProtocolReservedLength);

        if(status isnot NDIS_STATUS_SUCCESS)
        {
            Trace(UTIL, ERROR,
                  ("AddPacketBlockToPool: Unable to allocate packet pool for %d packets\n",
                   ulCount));
            
            break;
        }

        //
        // Fill in the back pointer to the pool.
        //
        
        pNew->pPool = pPool;

        //
        // Link the new block.  At this point, all the packets are
        // effectively "in use".  They are made available in the loop
        // below.
        //
        
        pNew->ulPackets      = ulCount;
        pPool->ulCurPackets += ulCount;
        
        InsertHeadList(&(pPool->leBlockHead),
                       &(pNew->leBlockLink));
        
        fOk = TRUE;
        
    }while(FALSE);

    RtReleaseSpinLock(&pPool->rlLock,
                      irql);

    if(!fOk)
    {
        //
        // Bailing, undo whatever succeeded.
        //
        
        if(pNew)
        {
            RtFree(pNew);
            
            if(pNew->nhNdisPool)
            {
                NdisFreePacketPool(pNew->nhNdisPool);
            }
        }

        return NULL;
    }

    //
    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    
    {
        ULONG i;
        PPACKET_HEAD pHead;

        pReturn = NULL;

        //
        // For each PACKET_HEAD of the block...
        //
        
        for(i = 0, pHead = (PPACKET_HEAD)(pNew + 1);
            i < ulCount;
            i++, pHead++)
        {
            InitializeListHead(&pHead->leFreePktLink);
            
            pHead->pBlock       = pNew;
            pHead->pNdisPacket  = NULL;

            //
            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            
            NdisAllocatePacket(&status,
                               &pHead->pNdisPacket,
                               pNew->nhNdisPool);

            if(status isnot NDIS_STATUS_SUCCESS)
            {
                continue;
            }

            if(pReturn)
            {
                //
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                
                FreePacketToPool(pPool,
                                 pHead,
                                 FALSE);
            }
            else
            {
                //
                // The first successfully constructed packet is returned by
                // this routine.
                //
                
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PPACKET_POOL pPool
    )
/*++
Routine Description

    Check if any of the blocks in pool are not in use, and if so, free them.
    
Locks

    Caller must hold the pool lock

    NOTE: The MSDN doc says that no locks may be held while calling
    NdisFreePacketXxx, but according to JameelH that is incorrect.
    
Arguments

    pPool   Pointer to pool
    
Return Value

    None

--*/
{
    PLIST_ENTRY pleNode;

    //
    // For each block in the pool...
    //
    
    pleNode = pPool->leBlockHead.Flink;
    
    while(pleNode isnot &(pPool->leBlockHead))
    {
        PLIST_ENTRY     pleNextNode;
        PPACKET_BLOCK   pBlock;

        pleNextNode = pleNode->Flink;

        pBlock = CONTAINING_RECORD(pleNode, PACKET_BLOCK, leBlockLink);
        
        if(pBlock->ulFreePackets >= pBlock->ulPackets)
        {
            ULONG        i;
            PPACKET_HEAD pHead;

            //
            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            
            for(i = 0, pHead = (PPACKET_HEAD)(pBlock + 1);
                i < pBlock->ulPackets;
                i++, pHead++)
            {
                RemoveEntryList(&(pHead->leFreePktLink));

                if(pHead->pNdisPacket)
                {
                    NdisFreePacket(pHead->pNdisPacket);
                }
            }

            //
            // Remove and release the unused block.
            //
            
            RemoveEntryList(pleNode);
            
            pPool->ulCurPackets -= pBlock->ulPackets;

            if(pBlock->nhNdisPool)
            {
                NdisFreePacketPool(pBlock->nhNdisPool);
            }

            RtFree(pBlock);
        }

        pleNode = pleNextNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\send.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\send.c

Abstract:

    The file contains the part of interface of the IP in IP tunnel driver
    to the TCP/IP stack that deals with sending data

    The code is a cleaned up version of wanarp\ipif.c which in turn
    was derived from HenrySa's ip\arp.c

Revision History:

    AmritanR

--*/

#define __FILE_SIG__    SEND_SIG

#include "inc.h"

IP_STATUS
SendICMPErr(IPAddr Src, IPHeader UNALIGNED *Header, uchar Type, uchar Code,
            ulong Pointer);

VOID
SendIcmpError(
    DWORD           dwLocalAddress,
    PNDIS_BUFFER    pnbFirstBuff,
    PVOID           pvFirstData,
    ULONG           ulFirstLen,
    BYTE            byType,
    BYTE            byCode
    );

NDIS_STATUS
IpIpSend(
    PVOID           pvContext,
    NDIS_PACKET     **ppPacketArray,
    UINT            uiNumPackets,
    DWORD           dwDestAddr,
    RouteCacheEntry *pRce,
    PVOID           pvLinkContext
    )

/*++

Routine Description

    Function called by IP to send a packet

Locks

    The TUNNEL is refcounted (by virtue of being in IP)

Arguments

    pvContext       Our context to IP for the interface - the PTUNNEL
    ppPacketArray   The array of NDIS_PACKETs to send
    uiNumPackets    The number of packets in the array
    dwDestAddr      The destination (next hop) address
    pRce            Pointer to RCE.
    pvLinkContext   Only for P2MP interfaces
 
Return Value

    NDIS_STATUS_SUCCESS    

--*/

{
    PTUNNEL          pTunnel;
    PWORK_QUEUE_ITEM pWorkItem;
    PQUEUE_NODE      pQueueNode;
    KIRQL            kiIrql;
    DWORD            dwLastAddr;

#if PROFILE

    LONGLONG         llTime, llNow;

    KeQueryTickCount((PLARGE_INTEGER)&llTime);

#endif
    
    TraceEnter(SEND, "IpIpSend");

    pTunnel = (PTUNNEL)pvContext;

    //
    // TODO: No one has a clue as to how to deal with multi-packet
    // sends. Right now we assume we get one packet. Later we can fix this
    //
    
    RtAssert(uiNumPackets is 1);

    //
    // All our packets are queued onto the TUNNEL before the transmit
    // routine is called. Allocate a link in the queue
    //

    pQueueNode  = AllocateQueueNode();

    if(pQueueNode is NULL)
    {
        //
        // Running out of memory
        //

        Trace(SEND, INFO,
              ("IpIpSend: Couldnt allocate queue node\n"));

        TraceLeave(SEND, "IpIpSend");

        return NDIS_STATUS_RESOURCES;
    }

    pWorkItem  = &(pQueueNode->WorkItem);

    pQueueNode->ppPacketArray = &(pQueueNode->pnpPacket);
    pQueueNode->pnpPacket     = ppPacketArray[0];
    pQueueNode->uiNumPackets  = uiNumPackets;
    pQueueNode->dwDestAddr    = dwDestAddr;

    //
    // If we are not at PASSIVE, just schedule a worker to come back and
    // handle this
    //

    if(KeGetCurrentIrql() > PASSIVE_LEVEL)
    {
        Trace(SEND, INFO,
              ("IpIpSend: Irql too high, queueing packet\n"));

        //
        // We dont need to reference the TUNNEL because IP has a reference
        // to the INTERFACE
        //  

        RtAcquireSpinLockAtDpcLevel(&(pTunnel->rlLock));

        //
        // Hack for quenching ICMP errors to the same destination
        //

        dwLastAddr = 0;

        if(pTunnel->dwOperState isnot IF_OPER_STATUS_OPERATIONAL)
        {
            ULONG           i, ulFirstLen, ulTotalLen;
            PNDIS_PACKET    pnpPacket;
            PNDIS_BUFFER    pnbFirstBuff, pnbNewBuffer;
            PVOID           pvFirstData;
            PIP_HEADER      pHeader;
            
            //
            // Cant transmit on this, either because we are deleting this
            // interface, or because the admin has shut us down
            //

            for(i = 0; i < uiNumPackets; i++)
            {
                pnpPacket = ppPacketArray[i];

                //
                // Get the information about the packet and buffer
                //
    
                NdisGetFirstBufferFromPacket(pnpPacket,
                                             &pnbFirstBuff,
                                             &pvFirstData,
                                             &ulFirstLen,
                                             &ulTotalLen);
    
                RtAssert(pvFirstData isnot NULL);

                RtAssert(ulFirstLen >= sizeof(IP_HEADER));
    
                pHeader = (PIP_HEADER)pvFirstData;
    
                if(IsUnicastAddr(pHeader->dwDest))
                {
                    pTunnel->ulOutUniPkts++;
                }
                else
                {
                    pTunnel->ulOutNonUniPkts++;
                }

                pTunnel->ulOutDiscards++;

                //
                // Send an ICMP error
                //

                if(dwLastAddr isnot pHeader->dwSrc)
                {
                    SendIcmpError(pTunnel->LOCALADDR,
                                  pnbFirstBuff,
                                  pvFirstData,
                                  ulFirstLen,
                                  ICMP_TYPE_DEST_UNREACHABLE,
                                  ICMP_CODE_HOST_UNREACHABLE);
                    
                    dwLastAddr = pHeader->dwSrc;
                }
            
            }
            
            RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

            FreeQueueNode(pQueueNode);

            Trace(SEND, INFO,
                  ("IpIpSend: Tunnel %x has admin state %d so not sending\n",
                   pTunnel,
                   pTunnel->dwAdminState));


            TraceLeave(SEND, "IpIpSend");

            return NDIS_STATUS_SUCCESS;
        }

        //
        // Insert at the end of the queue
        //

        InsertTailList(&(pTunnel->lePacketQueueHead),
                       &(pQueueNode->leQueueItemLink));

#if PROFILE

        //
        // The time at which IP called us for these packets
        //

        pQueueNode->llSendTime = llTime;

#endif
        if(pTunnel->bWorkItemQueued is FALSE)
        {
            //
            // Need to schedule a work item since one is not already scheduled
            //

            ExInitializeWorkItem(pWorkItem,
                                 IpIpDelayedSend,
                                 pTunnel);


            //
            // TODO: For delayed sends we ref the tunnel. Do we need to?
            //

            ReferenceTunnel(pTunnel);
        
            //
            // Reference the driver since the worker has to be scheduled
            //

            RtAcquireSpinLockAtDpcLevel(&g_rlStateLock);

            g_ulNumThreads++;

            RtReleaseSpinLockFromDpcLevel(&g_rlStateLock);

            pTunnel->bWorkItemQueued = TRUE;


            ExQueueWorkItem(pWorkItem,
                            CriticalWorkQueue);

        }
    
#if PROFILE

        //
        // We update this field after queing the work item, but it is
        // still safe since the field is protected by the tunnel lock
        // This is the time at which the work item was queued
        //

        KeQueryTickCount((PLARGE_INTEGER)&(pQueueNode->llCallTime));

#endif

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

        
        TraceLeave(SEND, "IpIpSend");
        
        return NDIS_STATUS_PENDING;
    }
    
    //
    // We dont need to reference the TUNNEL because IP has a reference to
    // the INTERFACE
    //

    //
    // If we are here, it is because we are at passive
    //
    
    
    //
    // Just hook the queue item to the end of the list and call the 
    // transmit routine
    //
  
    RtAcquireSpinLock(&(pTunnel->rlLock),
                      &kiIrql);

    InsertTailList(&(pTunnel->lePacketQueueHead),
                   &(pQueueNode->leQueueItemLink));
 
    RtReleaseSpinLock(&(pTunnel->rlLock),
                      kiIrql);

#if PROFILE

    pQueueNode->llSendTime  = llTime;

    KeQueryTickCount((PLARGE_INTEGER)&llNow);

    pQueueNode->llCallTime  = llNow;

#endif
 
    IpIpTransmit(pTunnel,
                 FALSE);

    return NDIS_STATUS_PENDING;
}


VOID
IpIpDelayedSend(
    PVOID   pvContext
    )

/*++

Routine Description

    The worker function called when we find that the send from IP was
    not at PASSIVE

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    PTUNNEL         pTunnel;
    ULONG           i;
    KIRQL           irql;
    NDIS_STATUS     nsStatus;

    
    TraceEnter(SEND, "IpIpDelayedSend");
    
    pTunnel = (PTUNNEL)pvContext;

    RtAssert(pTunnel);

    IpIpTransmit(pTunnel,
                 TRUE);

    //
    // Either IpIpTransmit or TdixSendComplete will do the SendComplete
    //
    
    
    //
    // We referenced the tunnel if we put it on the work queue
    // Deref it now
    //

    DereferenceTunnel(pTunnel);

    RtAcquireSpinLock(&g_rlStateLock,
                      &irql);

    g_ulNumThreads--;

    if((g_dwDriverState is DRIVER_STOPPED) and
       (g_ulNumThreads is 0))
    {
        KeSetEvent(&g_keStateEvent,
                   0,
                   FALSE);
    }

    RtReleaseSpinLock(&g_rlStateLock,
                      irql);

    TraceLeave(SEND, "IpIpDelayedSend");
}

VOID
IpIpTransmit(
    PTUNNEL     pTunnel,
    BOOLEAN     bFromWorker
    )

/*++

Routine Description

    Called to transmit any queued packets on the tunnel

Locks

    This MUST be called at passive

Arguments

    pTunnel     The tunnel whose queue needs to be transmitted
    bFromWorker TRUE if called off a worker

Return Value

    None
    This is an implicit asynchronous call

--*/

{
    PIP_HEADER      pHeader, pNewHeader;
    USHORT          usLength;
    KIRQL           irql;
    UINT            i;
    ULONG           ulFirstLen, ulTotalLen;
    PNDIS_PACKET    pnpPacket;
    PNDIS_BUFFER    pnbFirstBuff, pnbNewBuffer;
    PVOID           pvFirstData;
    NTSTATUS        nStatus;
    PLIST_ENTRY     pleNode;
    PQUEUE_NODE     pQueueNode;

#if PROFILE

    LONGLONG        llCurrentTime;

    KeQueryTickCount((PLARGE_INTEGER)&llCurrentTime);

#endif

    TraceEnter(SEND, "IpIpTransmit");

    RtAcquireSpinLock(&(pTunnel->rlLock),
                      &irql);

    if(pTunnel->dwOperState isnot IF_OPER_STATUS_OPERATIONAL)
    {
        //
        // Cant transmit on this, either because we are deleting this
        // interface, or because the admin has shut us down
        // Just walk all the packets, increment the stats and then
        // call SendComplete for the packet
        //

        while(!IsListEmpty(&(pTunnel->lePacketQueueHead)))
        {
            DWORD   dwLastAddr;

            pleNode = RemoveHeadList(&(pTunnel->lePacketQueueHead));

            pQueueNode = CONTAINING_RECORD(pleNode,
                                           QUEUE_NODE,
                                           leQueueItemLink);

            dwLastAddr = 0;

            for(i = 0; i < pQueueNode->uiNumPackets; i++)
            {
        
                pnpPacket = pQueueNode->ppPacketArray[i];

                //
                // Get the information about the packet and buffer
                //
    
                NdisGetFirstBufferFromPacket(pnpPacket,
                                             &pnbFirstBuff,
                                             &pvFirstData,
                                             &ulFirstLen,
                                             &ulTotalLen);
    
                RtAssert(pvFirstData isnot NULL);
    
                RtAssert(ulFirstLen >= sizeof(IP_HEADER));
        
                pHeader = (PIP_HEADER)pvFirstData;
    
                if(IsUnicastAddr(pHeader->dwDest))
                {
                    pTunnel->ulOutUniPkts++;
                }
                else
                {
                    pTunnel->ulOutNonUniPkts++;
                }

                pTunnel->ulOutDiscards++;
    
                RtReleaseSpinLock(&(pTunnel->rlLock),
                                  irql);

                //
                // Send an ICMP error
                //

                if(dwLastAddr isnot pHeader->dwSrc)
                {
                    SendIcmpError(pTunnel->LOCALADDR,
                                  pnbFirstBuff,
                                  pvFirstData,
                                  ulFirstLen,
                                  ICMP_TYPE_DEST_UNREACHABLE,
                                  ICMP_CODE_HOST_UNREACHABLE);
                    
                    dwLastAddr = pHeader->dwSrc;
                }
        
                g_pfnIpSendComplete(pTunnel->pvIpContext,
                                    pnpPacket,
                                    NDIS_STATUS_ADAPTER_NOT_READY);

                RtAcquireSpinLock(&(pTunnel->rlLock),
                                  &irql);
            }

            FreeQueueNode(pQueueNode);

        }

        if(bFromWorker)
        {
            pTunnel->bWorkItemQueued = FALSE;
        }

        RtReleaseSpinLock(&(pTunnel->rlLock),
                          irql);
        
        TraceLeave(SEND, "IpIpTransmit");

        return;
    }

    while(!IsListEmpty(&(pTunnel->lePacketQueueHead)))
    {
        pleNode = RemoveHeadList(&(pTunnel->lePacketQueueHead));

        pQueueNode = CONTAINING_RECORD(pleNode,
                                       QUEUE_NODE,
                                       leQueueItemLink);

        for(i = 0; i < pQueueNode->uiNumPackets; i++)
        {

            pnpPacket = pQueueNode->ppPacketArray[i];

            //
            // Get the information about the packet and buffer
            //
    
            NdisGetFirstBufferFromPacket(pnpPacket,
                                         &pnbFirstBuff,
                                         &pvFirstData,
                                         &ulFirstLen,
                                         &ulTotalLen);
    
            RtAssert(pvFirstData isnot NULL);

            //
            // Remove this till NK fixes the bug in IPTransmit
            // NB:
            //RtAssert(ulFirstLen >= sizeof(IP_HEADER));
    
            pHeader = (PIP_HEADER)pvFirstData;
    
            if(IsUnicastAddr(pHeader->dwDest))
            {
                pTunnel->ulOutUniPkts++;
            }
            else
            {
                pTunnel->ulOutNonUniPkts++;
            
                if(IsClassEAddr(pHeader->dwDest))
                {
                    //
                    // Bad address - throw it away
                    //
                
                    pTunnel->ulOutErrors++;

                    //
                    // Release the spinlock, call IP's SendComplete,
                    // reacquire the spinlock and continue processing the
                    // array
                    //
                
                    RtReleaseSpinLock(&(pTunnel->rlLock),
                                      irql);

                    g_pfnIpSendComplete(pTunnel->pvIpContext,
                                        pnpPacket,
                                        NDIS_STATUS_INVALID_PACKET);
                
                    RtAcquireSpinLock(&(pTunnel->rlLock),
                                      &irql);

                    continue;
                }
            }
        

            //
            // We dont need to muck with the TTL, since the IP stack would have
            // decremented it
            //
    
            //
            // RFC 2003 pg 6:
            // If the IP Source Address of the datagram matches router's own
            // IP Address, on any of its network interfaces, the router MUST NOT
            // tunnel the datagram; instead the datagram SHOULD be discarded
            //
    
            // TODO: This means comparing it against all the addresses that we 
            // have
    
    
            //
            // RFC 2003 pg 6:
            // If the IP Source Address of the datagram matches the IP Address 
            // of the Tunnel Destination, the router MUST NOT tunnel the 
            // datagram; instead the datagram SHOULD be discarded
            //
    
            if(pHeader->dwDest is pTunnel->REMADDR)
            {
                Trace(SEND, ERROR,
                      ("IpIpTransmit: Packet # %d had dest of %d.%d.%d.%d which matches the remote endpoint\n",
                       i, PRINT_IPADDR(pHeader->dwDest)));
        
                pTunnel->ulOutErrors++;
        
                RtReleaseSpinLock(&(pTunnel->rlLock),
                                  irql);

                g_pfnIpSendComplete(pTunnel->pvIpContext,
                                    pnpPacket,
                                    NDIS_STATUS_INVALID_PACKET);
                
                RtAcquireSpinLock(&(pTunnel->rlLock),
                                  &irql);

                continue;
            }

            //
            // Slap on an IP header
            //
    
            pNewHeader = GetIpHeader(pTunnel);
    
            if(pNewHeader is NULL)
            {
                pTunnel->ulOutDiscards++;
        
                //
                // Not enough resources
                //
        
                Trace(SEND, ERROR,
                      ("IpIpTransmit: Could not get buffer for header\n"));
        
                RtReleaseSpinLock(&(pTunnel->rlLock),
                                  irql);

                g_pfnIpSendComplete(pTunnel->pvIpContext,
                                    pnpPacket,
                                    NDIS_STATUS_RESOURCES);
                
                RtAcquireSpinLock(&(pTunnel->rlLock),
                                  &irql);

                continue;
            }

            pNewHeader->byVerLen    = IP_VERSION_LEN;
            pNewHeader->byTos       = pHeader->byTos;
    
            //
            // Currently we dont have any options, so all we do
            // is add 20 bytes to the length
            //
    
            usLength = RtlUshortByteSwap(pHeader->wLength) + MIN_IP_HEADER_LENGTH;
    
            pNewHeader->wLength = RtlUshortByteSwap(usLength);
        
            //
            // Id is set up by IP stack
            // If the DF flag is set, copy that out
            //
  
            pNewHeader->wFlagOff    = (pHeader->wFlagOff & IP_DF_FLAG);
            pNewHeader->byTtl       = pTunnel->byTtl;
            pNewHeader->byProtocol  = PROTO_IPINIP;
    
            //
            // XSum is done by IP, but we need to zero it out
            //

            pNewHeader->wXSum       = 0x0000;
            pNewHeader->dwSrc       = pTunnel->LOCALADDR;
            pNewHeader->dwDest      = pTunnel->REMADDR;
    
            //
            // Slap on the buffer in front of the current packet
            // and we are done
            //
    
            pnbNewBuffer = GetNdisBufferFromBuffer((PBYTE)pNewHeader);
    
            RtAssert(pnbNewBuffer);
        
#if DBG

            //
            // Query the buffer to see that everything is setup OK
            //
    
#endif

            NdisChainBufferAtFront(pnpPacket,
                                   pnbNewBuffer);
    
            //
            // Reference the tunnel, once for every send
            // ulOutDiscards, ulOutOctets are incremented in
            // SendComplete handler. 
            //
    
            pTunnel->ulOutQLen++;
    
            ReferenceTunnel(pTunnel);
    
            RtReleaseSpinLock(&(pTunnel->rlLock),
                              irql);
    
            //
            // Dont really care about the return code from here.
            // Even if it is an error, TdixSendDatagram will call our send
            // complete handler
            //

#if PROFILE
        
            TdixSendDatagram(pTunnel,
                             pnpPacket,
                             pnbNewBuffer,
                             usLength,
                             pQueueNode->llSendTime,
                             pQueueNode->llCallTime,
                             llCurrentTime);

#else

            TdixSendDatagram(pTunnel,
                             pnpPacket,
                             pnbNewBuffer,
                             usLength);

#endif

            //
            // If we come till here, we will always have our SendComplete called
            // The DereferenceTunnel() will be done there
            //  

            RtAcquireSpinLock(&(pTunnel->rlLock),
                          &irql);
        }

        FreeQueueNode(pQueueNode);
    }

    //
    // Dont have a work item queued
    //

    if(bFromWorker)
    { 
        pTunnel->bWorkItemQueued = FALSE;
    }
 
    RtReleaseSpinLock(&(pTunnel->rlLock),
                      irql);
    
    
    TraceLeave(SEND, "IpIpTransmit");
}
    
VOID
IpIpInvalidateRce(
    PVOID           pvContext,
    RouteCacheEntry *pRce
    )

/*++

Routine Description

    Called by IP when an RCE is closed or otherwise invalidated.
    
Locks


Arguments


Return Value
    NO_ERROR

--*/
{
    
}


UINT
IpIpReturnPacket(
    PVOID           pARPInterfaceContext,
    PNDIS_PACKET    pPacket
    )
{
    return STATUS_SUCCESS;
}

VOID
IpIpSendComplete(
    NTSTATUS        nSendStatus,
    PTUNNEL         pTunnel,
    PNDIS_PACKET    pnpPacket,
    ULONG           ulPktLength
    )

/*++

Routine Description


Locks

    We acquire the TUNNEL lock
    
Arguments


Return Value

    

--*/

{
    KIRQL        irql;
    PNDIS_BUFFER pnbFirstBuffer;
    UINT         uiFirstLength;
    PVOID        pvFirstData;

    TraceEnter(SEND, "IpIpSendComplete");
 
    //
    // The tunnel was refcounted, so could not have gone away
    // Lock it
    //
    
    RtAcquireSpinLock(&(pTunnel->rlLock),
                      &irql);
    
    //
    // If the status was success, increment the bytes sent
    // otherwise increment the bytes
    //

    if(nSendStatus isnot STATUS_SUCCESS)
    {
        Trace(SEND, ERROR,
              ("IpIpSendComplete: Status %x sending data\n",
               nSendStatus));

        pTunnel->ulOutDiscards++;
    }
    else
    {
        pTunnel->ulOutOctets    += ulPktLength;
    }

    //
    // Decrement the Qlen
    //

    pTunnel->ulOutQLen--;

    RtReleaseSpinLock(&(pTunnel->rlLock),
                      irql);

    //
    // Free the IP header we slapped on
    //

    NdisUnchainBufferAtFront(pnpPacket,
                             &pnbFirstBuffer);

    NdisQueryBuffer(pnbFirstBuffer,
                    &pvFirstData,
                    &uiFirstLength);

    RtAssert(uiFirstLength is MIN_IP_HEADER_LENGTH);

    FreeIpHeader(pTunnel,
                 pvFirstData);

    //
    // We are done. Just indicate everything back up to IP
    //

    g_pfnIpSendComplete(pTunnel->pvIpContext,
                        pnpPacket,
                        nSendStatus);

    //
    // Done with the tunnel, deref it
    //

    DereferenceTunnel(pTunnel);
    
    TraceEnter(SEND, "IpIpSendComplete");
}

#if 0
NDIS_STATUS
IpIpTransferData(
    PVOID        pvContext,
    NDIS_HANDLE  nhMacContext,
    UINT         uiProtoOffset,
    UINT         uiTransferOffset,
    UINT         uiTransferLength,
    PNDIS_PACKET pnpPacket,
    PUINT        puiTransferred
    )

/*++

Routine Description


Locks


Arguments


Return Value
    NO_ERROR

--*/

{
    NTSTATUS        nStatus;
    PNDIS_PACKET    pnpOriginalPacket;
    ULONG           ulTotalSrcLen, ulTotalDestLen;
    ULONG           ulDestOffset, ulSrcOffset;
    ULONG           ulCopyLength, ulBytesCopied;
    PNDIS_BUFFER    pnbSrcBuffer, pnbDestBuffer;
    PVOID           pvDataToCopy;

    //
    // The TD context we gave IP was just a pointer to the NDIS_PACKET
    //
    
    pnpOriginalPacket = (PNDIS_PACKET)nhMacContext;

    //
    // Get info about the first buffer in the src packet
    //
    
    NdisQueryPacket(pnpOriginalPacket,
                    NULL,
                    NULL,
                    &pnbSrcBuffer,
                    &ulTotalSrcLen);


    //
    // Query the given packet to get the Destination buffer
    // and the Total length
    //
    
    NdisQueryPacket(pnpPacket,
                    NULL,
                    NULL,
                    &pnbDestBuffer,
                    &ulTotalDestLen);


    ulSrcOffset = uiTransferOffset + uiProtoOffset;
    
    //
    // Make sure that we have enough data to fulfil the request
    //

    
    RtAssert((ulTotalSrcLen - ulSrcOffset) >= uiTransferLength);

    RtAssert(pnbDestBuffer);
    

    //
    // ulDestOffset is also a count of the bytes copied till now
    //
    
    ulDestOffset    = 0;
    
    while(pnbSrcBuffer)
    {

        NdisQueryBuffer(pnbSrcBuffer,
                        &pvDataToCopy,
                        &ulCopyLength);

        //
        // See if we need to copy the whole buffer or only part
        // of it. ulDestOffset is also a count of he bytes copied
        // up till this point
        //
        
        if(uiTransferLength - ulDestOffset < ulCopyLength)
        {
            //
            // Need to copy less than this buffer
            //
            
            ulCopyLength = uiTransferLength - ulDestOffset;
        }
        
#if NDISBUFFERISMDL
        
        nStatus = TdiCopyBufferToMdl(pvDataToCopy,
                                     ulSrcOffset,
                                     ulCopyLength,
                                     pnbDestBuffer,
                                     ulDestOffset,
                                     &ulBytesCopied);

#else
#error "Fix this"
#endif

        if((nStatus isnot STATUS_SUCCESS) and
           (ulBytesCopied isnot ulCopyLength))
        {
            //
            // something bad happened in the copy
            //

        }

        ulSrcOffset     = 0;
        ulDestOffset   += ulBytesCopied;
        
        NdisGetNextBuffer(pnbSrcBuffer, &pnbSrcBuffer);
    }

    *puiTransferred = ulDestOffset;
}
#endif                   

NDIS_STATUS
IpIpTransferData(
    PVOID        pvContext,
    NDIS_HANDLE  nhMacContext,
    UINT         uiProtoOffset,
    UINT         uiTransferOffset,
    UINT         uiTransferLength,
    PNDIS_PACKET pnpPacket,
    PUINT        puiTransferred
    )

/*++

Routine Description


Locks


Arguments


Return Value

    NO_ERROR

--*/

{
    PTRANSFER_CONTEXT    pXferCtxt;

    TraceEnter(SEND, "IpIpTransferData");

    pXferCtxt = (PTRANSFER_CONTEXT)nhMacContext;

    pXferCtxt->pvContext         = pvContext;
    pXferCtxt->uiProtoOffset     = uiProtoOffset;
    pXferCtxt->uiTransferOffset  = uiTransferOffset;
    pXferCtxt->uiTransferLength  = uiTransferLength;
    pXferCtxt->pnpTransferPacket = pnpPacket;

    *puiTransferred = 0;

    pXferCtxt->bRequestTransfer  = TRUE;
    
    TraceLeave(SEND, "IpIpTransferData");

    return NDIS_STATUS_PENDING;
}

VOID
SendIcmpError(
    DWORD           dwLocalAddress,
    PNDIS_BUFFER    pnbFirstBuff,
    PVOID           pvFirstData,
    ULONG           ulFirstLen,
    BYTE            byType,
    BYTE            byCode
    )
    
/*++

Routine Description:

    Internal routine called to send an icmp error message

Locks:

    None needed, the buffers shouldnt be modified while the function is
    in progress
    
Arguments:

    dwLocalAddress  NTE on which this packet was received
    pnbFirstBuffer  The buffer that has the IP Header
    pvFirstData     Pointer to the data in the buffer
    ulFirstLen      Size of the buffer
    byType          ICMP type to return
    byCode          ICMP code to return

Return Value:

    None

--*/

{
    struct IPHeader *pErrorHeader;
    BYTE            FlatHeader[MAX_IP_HEADER_LENGTH + ICMP_HEADER_LENGTH];
    ULONG           ulSecondLen, ulLeft;
    PVOID           pvSecondBuff;

    //
    // If the error is being sent in response to an ICMP
    // packet, tcpip will touch the icmp header also
    // So we copy it into a flat buffer
    //
    
    pErrorHeader = NULL;

    if((ulFirstLen < MAX_IP_HEADER_LENGTH + ICMP_HEADER_LENGTH) and
       (ulFirstLen < (ULONG)RtlUshortByteSwap(((PIP_HEADER)pvFirstData)->wLength)))
    {
        NdisQueryBufferSafe(NDIS_BUFFER_LINKAGE(pnbFirstBuff),
                            &pvSecondBuff,
                            &ulSecondLen,
                            LowPagePriority);
        
        if(pvSecondBuff isnot NULL)
        {
            //
            // First copy out what's in the first buffer
            //
            
            RtlCopyMemory(FlatHeader,
                          pvFirstData,
                          ulFirstLen);
            
            //
            // How much is left in the flat buffer?
            //
            
            ulLeft = (MAX_IP_HEADER_LENGTH + ICMP_HEADER_LENGTH) - ulFirstLen;
            
            //
            // Copy out MIN(SecondBuffer, What's Left)
            //
            
            ulLeft = (ulSecondLen < ulLeft) ? ulSecondLen: ulLeft;
            
            RtlCopyMemory(FlatHeader + ulFirstLen,
                          pvSecondBuff,
                          ulLeft);
            
            pErrorHeader = (struct IPHeader *)&FlatHeader;
        }
    }
    else
    {
        pErrorHeader = (struct IPHeader *)pvFirstData;
    }
    
    if(pErrorHeader isnot NULL)
    {
        SendICMPErr(dwLocalAddress,
                    pErrorHeader,
                    ICMP_TYPE_DEST_UNREACHABLE,
                    ICMP_CODE_HOST_UNREACHABLE,
                    0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\tdix.c ===
/*++

Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\ipinip\tdix.c

Abstract:

    Interface to TDI

Revision History:

    Derived from Steve Cobb's ndis\l2tp code
   
   
    About ALLOCATEIRPS:
   
    This driver is lower level code than typical TDI drivers.  It has locked
    MDL-mapped input buffers readily available and does not need to provide any
    mapping to user mode client requests on completion.  This allows a
    performance gain from allocating and deallocating IRPs directly, thus
    avoiding unnecessary setup in TdiBuildInternalDeviceControlIrp and
    unnecessary APC queuing in IoCompleteRequest.  Define ALLOCATEIRPs=1 to
    make this optimization, or define it 0 to use the strictly TDI-compliant
    TdiBuildInternalDeviceControlIrp method.
   
   
    About NDISBUFFERISMDL:
   
    Calls to TdiBuildSendDatagram assume the NDIS_BUFFER can be passed in place
    of an MDL which avoids a pointless copy.  If this is not the case, an
    explicit MDL buffer would need to be allocated and caller's buffer copied
    to the MDL buffer before sending.  Same issue for TdiBuildReceiveDatagram,
    except of course that the copy would be from the MDL buffer to caller's
    buffer after receiving.
    
--*/


#define __FILE_SIG__    TDIX_SIG

#include "inc.h"

#if NDISBUFFERISMDL
#else
#error Additional code to copy NDIS_BUFFER to/from MDL NYI.
#endif


//
// The Handle for the IP in IP (proto 4) transport address
//

HANDLE          g_hIpIpHandle;

//
// The pointer to the file object for the above handle
//

PFILE_OBJECT    g_pIpIpFileObj;


//
// The Handle for the ICMP (proto 1) transport address
//

HANDLE          g_hIcmpHandle;

//
// The pointer to the file object for the above handle
//

PFILE_OBJECT    g_pIcmpFileObj;


//
// Handle for address changes
//

HANDLE          g_hAddressChange;


NPAGED_LOOKASIDE_LIST    g_llSendCtxtBlocks;
NPAGED_LOOKASIDE_LIST    g_llTransferCtxtBlocks;
NPAGED_LOOKASIDE_LIST    g_llQueueNodeBlocks;

#pragma alloc_text(PAGE, TdixInitialize)

VOID
TdixInitialize(
    PVOID   pvContext
    )

/*++

Routine Description

    Initialize the TDI related globals.
    Open the TDI transport address for Raw IP, protocol number 4.
    Sets the address object for HEADER_INCLUDE
    Also opens Raw IP for ICMP (used to manager TUNNEL MTU)
    Register to receive datagrams at the selected handler

Locks

    This call must be made at PASSIVE IRQL.

Arguments

    None

Return Value

    STATUS_SUCCESS      if successful
    STATUS_UNSUCCESSFUL otherwise

--*/

{
    PIRP    pIrp;
    
    IO_STATUS_BLOCK     iosb;
    NTSTATUS            nStatus;
    TDIObjectID         *pTdiObjId;
    KEVENT              keWait;
    POPEN_CONTEXT       pOpenCtxt;
   
    PIO_STACK_LOCATION              pIrpSp;
    TCP_REQUEST_SET_INFORMATION_EX  tcpSetInfo;
    TDI_CLIENT_INTERFACE_INFO       tdiInterface;

    TraceEnter(TDI, "TdixInitialize");
    
    PAGED_CODE();

    pOpenCtxt = (POPEN_CONTEXT)pvContext;

    //
    // Init the Handle and pointer to file object for RAW IP
    //

    g_hIpIpHandle   = NULL;
    g_pIpIpFileObj  = NULL;
    
    g_hIcmpHandle   = NULL;
    g_pIcmpFileObj  = NULL;
    

    //
    // Initialize lookaside lists for our send and receive contexts
    //

    ExInitializeNPagedLookasideList(&g_llSendCtxtBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(SEND_CONTEXT),
                                    SEND_CONTEXT_TAG,
                                    SEND_CONTEXT_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&g_llTransferCtxtBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(TRANSFER_CONTEXT),
                                    TRANSFER_CONTEXT_TAG,
                                    TRANSFER_CONTEXT_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList(&g_llQueueNodeBlocks,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(QUEUE_NODE),
                                    QUEUE_NODE_TAG,
                                    QUEUE_NODE_LOOKASIDE_DEPTH);

    InitializeListHead(&g_leAddressList);

    //
    // Open file and handle objects for both IP in IP and ICMP
    //

    nStatus = TdixOpenRawIp(PROTO_IPINIP,
                            &g_hIpIpHandle,
                            &g_pIpIpFileObj);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixInitialize: Couldnt open raw IP for IP in IP\n"));

        TdixDeinitialize(g_pIpIpDevice,
                         NULL);

        TraceLeave(TDI, "TdixInitialize");
      
        pOpenCtxt->nStatus = nStatus;
 
        KeSetEvent(pOpenCtxt->pkeEvent,
                   0,
                   FALSE);

        return; 
    }

    nStatus = TdixOpenRawIp(PROTO_ICMP,
                            &g_hIcmpHandle,
                            &g_pIcmpFileObj);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixInitialize: Couldnt open raw IP for ICMP\n"));

        TdixDeinitialize(g_pIpIpDevice,
                         NULL);

        TraceLeave(TDI, "TdixInitialize");

        pOpenCtxt->nStatus = nStatus;

        KeSetEvent(pOpenCtxt->pkeEvent,
                   0,
                   FALSE);

        return;    
    }

    //
    // Set HeaderInclude option on this AddressObject
    //

    tcpSetInfo.BufferSize   = 1;
    tcpSetInfo.Buffer[0]    = TRUE;
    
    pTdiObjId = &tcpSetInfo.ID;

    pTdiObjId->toi_entity.tei_entity   = CL_TL_ENTITY;
    pTdiObjId->toi_entity.tei_instance = 0;
    
    pTdiObjId->toi_class = INFO_CLASS_PROTOCOL;
    pTdiObjId->toi_type  = INFO_TYPE_ADDRESS_OBJECT;
    pTdiObjId->toi_id    = AO_OPTION_IP_HDRINCL;
    
    //
    // Init the event needed to wait on the IRP
    //

    KeInitializeEvent(&keWait,
                      SynchronizationEvent,
                      FALSE);
    
    pIrp = IoBuildDeviceIoControlRequest(IOCTL_TCP_SET_INFORMATION_EX,
                                         g_pIpIpFileObj->DeviceObject,
                                         (PVOID)&tcpSetInfo,
                                         sizeof(TCP_REQUEST_SET_INFORMATION_EX),
                                         NULL,
                                         0,
                                         FALSE,
                                         &keWait,
                                         &iosb);

    if (pIrp is NULL)
    {
        Trace(TDI, ERROR,
              ("TdixInitialize: Couldnt build Irp for IP\n"));

        nStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        //
        // Io subsystem doesnt do anything for us in kernel mode
        // so we need to set up the IRP ourselves
        //

        pIrpSp = IoGetNextIrpStackLocation(pIrp);

        pIrpSp->FileObject = g_pIpIpFileObj;

        //
        // Submit the request to the forwarder
        //
        
        nStatus = IoCallDriver(g_pIpIpFileObj->DeviceObject,
                               pIrp);

        if(nStatus isnot STATUS_SUCCESS)
        {
            if(nStatus is STATUS_PENDING)
            {
                Trace(TDI, INFO,
                      ("TdixInitialize: IP returned pending when setting HDRINCL option\n"));

                KeWaitForSingleObject(&keWait,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      0);

                nStatus = STATUS_SUCCESS;
            }
        }
    }

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixInitialize: IOCTL to IP Forwarder for HDRINCL failed %x\n",
               nStatus));
        
        TdixDeinitialize(g_pIpIpDevice,
                         NULL);

        TraceLeave(TDI, "TdixInitialize");

        pOpenCtxt->nStatus = nStatus;

        KeSetEvent(pOpenCtxt->pkeEvent,
                   0,
                   FALSE);

        return;        
    }
    
    //
    // Install our receive datagram handler.  Caller's 'pReceiveHandler' will
    // be called by our handler when a datagram arrives and TDI business is
    // out of the way.
    //
    
    nStatus = TdixInstallEventHandler(g_pIpIpFileObj,
                                      TDI_EVENT_RECEIVE_DATAGRAM,
                                      TdixReceiveIpIpDatagram,
                                      NULL);


    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixOpen: Status %x installing IpIpReceiveDatagram Event\n",
               nStatus));
        
        TdixDeinitialize(g_pIpIpDevice,
                         NULL);

        TraceLeave(TDI, "TdixInitialize");

        pOpenCtxt->nStatus = nStatus;

        KeSetEvent(pOpenCtxt->pkeEvent,
                   0,
                   FALSE);

        return;
    }

    nStatus = TdixInstallEventHandler(g_pIcmpFileObj,
                                      TDI_EVENT_RECEIVE_DATAGRAM,
                                      TdixReceiveIcmpDatagram,
                                      NULL);


    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixOpen: Status %x installing IcmpReceiveDatagram Event\n",
               nStatus));
        
        TdixDeinitialize(g_pIpIpDevice,
                         NULL);

        TraceLeave(TDI, "TdixInitialize");
       
        pOpenCtxt->nStatus = nStatus;

        KeSetEvent(pOpenCtxt->pkeEvent,
                   0,
                   FALSE);

        return; 
    }

   
    RtlZeroMemory(&tdiInterface, 
                  sizeof(TDI_CLIENT_INTERFACE_INFO));

    tdiInterface.MajorTdiVersion =   TDI_CURRENT_MAJOR_VERSION;
    tdiInterface.MinorTdiVersion =   TDI_CURRENT_MINOR_VERSION;

    tdiInterface.AddAddressHandlerV2 =   TdixAddressArrival;
    tdiInterface.DelAddressHandlerV2 =   TdixAddressDeletion;
 
    TdiRegisterPnPHandlers(&tdiInterface,
                           sizeof(TDI_CLIENT_INTERFACE_INFO),
                           &g_hAddressChange);
   
    pOpenCtxt->nStatus = STATUS_SUCCESS;

    KeSetEvent(pOpenCtxt->pkeEvent,
               0,
               FALSE);

    TraceLeave(TDI, "TdixInitialize");
    
    return; 
}

#pragma alloc_text(PAGE, TdixOpenRawIp)

NTSTATUS
TdixOpenRawIp(
    IN  DWORD       dwProtoId,
    OUT HANDLE      *phAddrHandle,
    OUT FILE_OBJECT **ppAddrFileObj
    )

/*++

Routine Description

    This routine opens a Raw IP transport address for a given protocol

Locks

    None
    
Arguments

    dwProtoId        Protocol to be opened
    phAddrHandle     Pointer to transport Address Handle opened
    ppAddrFileObject Pointer to pointer to file object for transport address
                     handle
     

Return Value

    STATUS_SUCCESS

--*/

{
    ULONG   ulEaLength;
    BYTE    rgbyEa[100];
    WCHAR   rgwcRawIpDevice[sizeof(DD_RAW_IP_DEVICE_NAME) + 10];
    WCHAR   rgwcProtocolNumber[10];

    NTSTATUS            nStatus;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iosb;
    PTA_IP_ADDRESS      pTaIp;
    PTDI_ADDRESS_IP     pTdiIp;
    UNICODE_STRING      usDevice;
    UNICODE_STRING      usProtocolNumber;
    HANDLE              hTransportAddrHandle;
    PFILE_OBJECT        pTransportAddrFileObj;

    PFILE_FULL_EA_INFORMATION       pEa;


    PAGED_CODE();

    TraceEnter(TDI, "TdixOpenRawIp");

    *phAddrHandle  = NULL;
    *ppAddrFileObj = NULL;

    //
    // FILE_FULL_EA_INFORMATION wants null terminated buffers now
    //

    RtlZeroMemory(rgbyEa,
                  sizeof(rgbyEa));

    RtlZeroMemory(rgwcRawIpDevice,
                  sizeof(rgwcRawIpDevice));

    RtlZeroMemory(rgwcProtocolNumber,
                  sizeof(rgwcProtocolNumber));

    
    //
    // Set up parameters needed to open the transport address.  First, the
    // object attributes.
    //
    
    //
    // Build the raw IP device name as a counted string.  The device name
    // is followed by a path separator then the protocol number of
    // interest.
    //
    
    usDevice.Buffer        = rgwcRawIpDevice;
    usDevice.Length        = 0;
    usDevice.MaximumLength = sizeof(rgwcRawIpDevice);

    RtlAppendUnicodeToString(&usDevice,
                             DD_RAW_IP_DEVICE_NAME);

    usDevice.Buffer[usDevice.Length/sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
    
    usDevice.Length += sizeof(WCHAR);
    
    usProtocolNumber.Buffer        = rgwcProtocolNumber;
    usProtocolNumber.MaximumLength = sizeof(rgwcProtocolNumber);
    
    RtlIntegerToUnicodeString((ULONG)dwProtoId,
                              10,
                              &usProtocolNumber);
    
    RtlAppendUnicodeStringToString(&usDevice,
                                   &usProtocolNumber);
    
    RtAssert(usDevice.Length < sizeof(rgwcRawIpDevice));

    InitializeObjectAttributes(&oa,
                               &usDevice,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Set up the extended attribute that tells the IP stack the IP
    // address/port on which we want to receive.  
    // We "bind" to INADDR_ANY
    //
    
    RtAssert((sizeof(FILE_FULL_EA_INFORMATION) +
              TDI_TRANSPORT_ADDRESS_LENGTH +
              sizeof(TA_IP_ADDRESS))
             <= 100);

    pEa = (PFILE_FULL_EA_INFORMATION)rgbyEa;
    
    pEa->NextEntryOffset = 0;
    pEa->Flags           = 0;
    pEa->EaNameLength    = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEa->EaValueLength   = sizeof(TA_IP_ADDRESS);
    
    NdisMoveMemory(pEa->EaName,
                   TdiTransportAddress,
                   TDI_TRANSPORT_ADDRESS_LENGTH);
    
    //
    // Note: The unused byte represented by the "+ 1" below is to match up
    //       with what the IP stack expects, though it doesn't appear in the
    //       current docs.
    //
    
    pTaIp = (PTA_IP_ADDRESS)(pEa->EaName + TDI_TRANSPORT_ADDRESS_LENGTH + 1);
    
    pTaIp->TAAddressCount = 1;
    
    pTaIp->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pTaIp->Address[0].AddressType   = TDI_ADDRESS_TYPE_IP;

    pTdiIp = &(pTaIp->Address[0].Address[0]);
    
    pTdiIp->sin_port = 0;
    pTdiIp->in_addr  = 0;
    
    NdisZeroMemory(pTdiIp->sin_zero,
                   sizeof(pTdiIp->sin_zero));

    ulEaLength = (ULONG) ((UINT_PTR)(pTaIp + 1) - (UINT_PTR)pEa);

    //
    // Open the transport address.
    // Settin FILE_SHARE_READ|FILE_SHARE_WRITE is equivalent to the
    // SO_REUSEADDR option
    //
    
    
    nStatus = ZwCreateFile(&hTransportAddrHandle,
                           FILE_READ_DATA | FILE_WRITE_DATA,
                           &oa,
                           &iosb,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN,
                           0,
                           pEa,
                           ulEaLength);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixOpenRawIp: Unable to open %S. Status %x\n",
               usDevice.Buffer,
               nStatus));
       
        TraceLeave(TDI, "TdixOpenRawIp");
 
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get the object address from the handle.  This also checks our
    // permissions on the object.
    //
    
    nStatus =  ObReferenceObjectByHandle(hTransportAddrHandle,
                                         0,
                                         NULL,
                                         KernelMode,
                                         &pTransportAddrFileObj,
                                         NULL);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixOpenRawIp: Unable to open object for handle %x. Status %x\n",
               hTransportAddrHandle,
               nStatus));
        
        TraceLeave(TDI, "TdixOpenRawIp");

        return STATUS_UNSUCCESSFUL;
    }

    *phAddrHandle   = hTransportAddrHandle;
    *ppAddrFileObj  = pTransportAddrFileObj;

    TraceLeave(TDI, "TdixOpenRawIp");

    return STATUS_SUCCESS;
}

#pragma alloc_text(PAGE, TdixDeinitialize)

VOID
TdixDeinitialize(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PVOID            pvContext
    )

/*++

Routine Description

    Undo TdixInitialize actions

Locks

    This call must be made at PASSIVE IRQL in the context of the system process
    
Arguments

    pvContext
    
Return Value
   
    None 

--*/

{
    POPEN_CONTEXT   pOpenCtxt;

    PAGED_CODE();

    TraceEnter(TDI, "TdixDeinitialize");

    UNREFERENCED_PARAMETER(pDeviceObject);

    pOpenCtxt = (POPEN_CONTEXT)pvContext;

    if(g_hAddressChange isnot NULL)
    {
        TdiDeregisterPnPHandlers(g_hAddressChange);
    }

    ExDeleteNPagedLookasideList(&g_llSendCtxtBlocks);

    ExDeleteNPagedLookasideList(&g_llTransferCtxtBlocks);
    
    ExDeleteNPagedLookasideList(&g_llQueueNodeBlocks);

    if(g_pIpIpFileObj)
    {
        //
        // Install a NULL handler, effectively uninstalling.
        //
        
        TdixInstallEventHandler(g_pIpIpFileObj,
                                TDI_EVENT_RECEIVE_DATAGRAM,
                                NULL,
                                NULL);

        ObDereferenceObject(g_pIpIpFileObj);
        
        g_pIpIpFileObj = NULL;
    }

    if(g_hIpIpHandle)
    {
        ZwClose(g_hIpIpHandle);
        
        g_hIpIpHandle = NULL;
    }

    if(g_pIcmpFileObj)
    {
        TdixInstallEventHandler(g_pIcmpFileObj,
                                TDI_EVENT_RECEIVE_DATAGRAM,
                                NULL,
                                NULL);

        ObDereferenceObject(g_pIcmpFileObj);
        
        g_pIcmpFileObj = NULL;
    }

    if(g_hIcmpHandle)
    {
        ZwClose(g_hIcmpHandle);
        
        g_hIcmpHandle = NULL;
    }

    if(pOpenCtxt)
    {
        KeSetEvent(pOpenCtxt->pkeEvent,
                   0,
                   FALSE);
    }

    TraceLeave(TDI, "TdixDeinitialize");
}


#pragma alloc_text(PAGE, TdixInstallEventHandler)

NTSTATUS
TdixInstallEventHandler(
    IN PFILE_OBJECT pAddrFileObj,
    IN INT          iEventType,
    IN PVOID        pfnEventHandler,
    IN PVOID        pvEventContext
    )

/*++

Routine Description

    Install a TDI event handler routine
    
Locks

    The call must be made at PASSIVE
    
Arguments

    iEventType              The event for which the handler is to be set
    pfnEventHandler         The event handler
    pvEventContext          The context passed to the event handler
    
Return Value

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_SUCCESS

--*/

{
    NTSTATUS    nStatus;
    PIRP        pIrp;

    PAGED_CODE();

    TraceEnter(TDI, "TdixInstallEventHandler");
    
    //
    // Allocate a "set event" IRP with base initialization.
    //
    
    pIrp = TdiBuildInternalDeviceControlIrp(
               TDI_SET_EVENT_HANDLER,
               pAddrFileObj->DeviceObject,
               pAddrFileObj,
               NULL,
               NULL);

    if(pIrp is NULL)
    {
        Trace(TDI, ERROR,
              ("TdixInstallEventHandler: Could not allocate IRP\n"));
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Complete the "set event" IRP initialization.
    //
    
    TdiBuildSetEventHandler(pIrp,
                            pAddrFileObj->DeviceObject,
                            pAddrFileObj,
                            NULL,
                            NULL,
                            iEventType,
                            pfnEventHandler,
                            pvEventContext);

/*
    Trace(GLOBAL, ERROR,
          ("**FileObj 0x%x Irp 0x%x fscontext to callee 0x%x\n",
           pAddrFileObj,
           pIrp,
           IoGetNextIrpStackLocation(pIrp)->FileObject));
*/
    //
    // Tell the I/O manager to pass our IRP to the transport for processing.
    //
    
    nStatus = IoCallDriver(pAddrFileObj->DeviceObject,
                           pIrp);
    
    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(TDI, ERROR,
              ("TdixInstallEventHandler: Error %X sending IRP\n",
               nStatus));
    }

    TraceLeave(TDI, "TdixInstallEventHandler");
    
    return nStatus;
}

VOID
TdixAddressArrival(
    PTA_ADDRESS         pAddr, 
    PUNICODE_STRING     pusDeviceName,
    PTDI_PNP_CONTEXT    pContext
    )

/*++

Routine Description

    Our handler called by TDI whenever a new address is added to the
    system
    We see if this is an IP Address and if we have any tunnels that
    use this address as an endpoint. If any do, then we mark all those
    tunnels as up

Locks

    Acquires the g_rwlTunnelLock as WRITER.
    Also locks each of the tunnels

Arguments

    pAddr
    pusDeviceName
    pContext

Return Value


--*/

{
    KIRQL           kiIrql;
    PADDRESS_BLOCK  pAddrBlock;
    PTDI_ADDRESS_IP pTdiIpAddr;
    PLIST_ENTRY     pleNode;

    TraceEnter(TDI, "TdixAddressArrival");

    if(pAddr->AddressType isnot TDI_ADDRESS_TYPE_IP)
    {
        TraceLeave(TDI, "TdixAddressArrival");

        return;
    }

    RtAssert(pAddr->AddressLength >= sizeof(TDI_ADDRESS_IP));

    pTdiIpAddr = (PTDI_ADDRESS_IP)pAddr->Address;

    Trace(TDI, TRACE,
          ("TdixAddressArrival: New address %d.%d.%d.%d\n",
           PRINT_IPADDR(pTdiIpAddr->in_addr)));

    EnterWriter(&g_rwlTunnelLock,
                &kiIrql);

    pAddrBlock = GetAddressBlock(pTdiIpAddr->in_addr);

    if(pAddrBlock isnot NULL)
    {
        RtAssert(pAddrBlock->dwAddress is pTdiIpAddr->in_addr);

        if(pAddrBlock->bAddressPresent is TRUE)
        {
            Trace(TDI, ERROR,
                  ("TdixAddressArrival: Multiple notification on %d.%d.%d.%d\n",
                   PRINT_IPADDR(pTdiIpAddr->in_addr)));

            ExitWriter(&g_rwlTunnelLock,
                       kiIrql);

            TraceLeave(TDI, "TdixAddressArrival");

            return;
        }

        pAddrBlock->bAddressPresent = TRUE;
    }
    else
    {
        pAddrBlock = RtAllocate(NonPagedPool,
                                sizeof(ADDRESS_BLOCK),
                                TUNNEL_TAG);

        if(pAddrBlock is NULL)
        {
            Trace(TDI, ERROR,
                  ("TdixAddressArrival: Unable to allocate address block\n"));

            ExitWriter(&g_rwlTunnelLock,
                       kiIrql);

            TraceLeave(TDI, "TdixAddressArrival");

            return;
        }

        pAddrBlock->dwAddress = pTdiIpAddr->in_addr;
        pAddrBlock->bAddressPresent = TRUE;

        InitializeListHead(&(pAddrBlock->leTunnelList));

        InsertHeadList(&g_leAddressList,
                       &(pAddrBlock->leAddressLink));
    }

    //
    // Walk the list of tunnels on this address and
    // set them up
    //

    for(pleNode = pAddrBlock->leTunnelList.Flink;
        pleNode isnot &(pAddrBlock->leTunnelList);
        pleNode = pleNode->Flink)
    {
        PTUNNEL         pTunnel;
        DWORD           dwLocalNet;
        RouteCacheEntry *pDummyRce;
        BYTE            byType;
        USHORT          usMtu;
        IPOptInfo       OptInfo;

        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leAddressLink);

        RtAcquireSpinLockAtDpcLevel(&(pTunnel->rlLock));

        RtAssert(pTunnel->LOCALADDR is pTdiIpAddr->in_addr);
        RtAssert(pTunnel->dwOperState is IF_OPER_STATUS_NON_OPERATIONAL);

        pTunnel->dwAdminState  |= TS_ADDRESS_PRESENT;

        if(GetAdminState(pTunnel) is IF_ADMIN_STATUS_UP)
        {
            pTunnel->dwOperState = IF_OPER_STATUS_OPERATIONAL;

            //
            // See if the remote address is reachable and what the MTU is.
            //

            UpdateMtuAndReachability(pTunnel);
        }

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
    }
    
    ExitWriter(&g_rwlTunnelLock,
               kiIrql);

    TraceLeave(TDI, "TdixAddressArrival");

    return;
}


VOID
TdixAddressDeletion(
    PTA_ADDRESS         pAddr, 
    PUNICODE_STRING     pusDeviceName,
    PTDI_PNP_CONTEXT    pContext
    )

/*++

Routine Description

    Our handler called by TDI whenever an address is removed from to the
    system
    We see if this is an IP Address and if we have any tunnels that
    use this address as an endpoint. If any do, then we mark all those
    tunnels as down

Locks

    Acquires the g_rwlTunnelLock as WRITER.
    Also locks each of the tunnels

Arguments

    pAddr
    pusDeviceName
    pContext

Return Value


--*/

{
    KIRQL           kiIrql;
    PADDRESS_BLOCK  pAddrBlock;
    PTDI_ADDRESS_IP pTdiIpAddr;
    PLIST_ENTRY     pleNode;

    TraceEnter(TDI, "TdixAddressDeletion");

    if(pAddr->AddressType isnot TDI_ADDRESS_TYPE_IP)
    {
        TraceLeave(TDI, "TdixAddressDeletion");

        return;
    }

    RtAssert(pAddr->AddressLength >= sizeof(TDI_ADDRESS_IP));

    pTdiIpAddr = (PTDI_ADDRESS_IP)pAddr->Address;

    Trace(TDI, TRACE,
          ("TdixAddressDeletion: Address %d.%d.%d.%d\n",
           PRINT_IPADDR(pTdiIpAddr->in_addr)));

    EnterWriter(&g_rwlTunnelLock,
                &kiIrql);

    pAddrBlock = GetAddressBlock(pTdiIpAddr->in_addr);

    if(pAddrBlock is NULL)
    {
        ExitWriter(&g_rwlTunnelLock,
                   kiIrql);

        TraceLeave(TDI, "TdixAddressDeletion");

        return;
    }
    
    RtAssert(pAddrBlock->dwAddress is pTdiIpAddr->in_addr);
    RtAssert(pAddrBlock->bAddressPresent);
    
    //
    // Walk the list of tunnels on this address and
    // set them down
    //

    for(pleNode = pAddrBlock->leTunnelList.Flink;
        pleNode isnot &(pAddrBlock->leTunnelList);
        pleNode = pleNode->Flink)
    {
        PTUNNEL pTunnel;

        pTunnel = CONTAINING_RECORD(pleNode,
                                    TUNNEL,
                                    leAddressLink);

        RtAcquireSpinLockAtDpcLevel(&(pTunnel->rlLock));

        RtAssert(pTunnel->LOCALADDR is pTdiIpAddr->in_addr);
        RtAssert(pTunnel->dwAdminState & TS_ADDRESS_PRESENT);
        RtAssert(IsTunnelMapped(pTunnel));

        pTunnel->dwOperState = IF_OPER_STATUS_NON_OPERATIONAL;

        //
        // Reset the admin state to UP/DOWN|MAPPED (It has to be mapped)
        //

        pTunnel->dwAdminState = GetAdminState(pTunnel);
        MarkTunnelMapped(pTunnel);

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
    }
    
    ExitWriter(&g_rwlTunnelLock,
               kiIrql);

    TraceLeave(TDI, "TdixAddressDeletion");

    return;
}
 
NTSTATUS
TdixReceiveIpIpDatagram(
    IN  PVOID   pvTdiEventContext,
    IN  LONG    lSourceAddressLen,
    IN  PVOID   pvSourceAddress,
    IN  LONG    plOptionsLen,
    IN  PVOID   pvOptions,
    IN  ULONG   ulReceiveDatagramFlags,
    IN  ULONG   ulBytesIndicated,
    IN  ULONG   ulBytesAvailable,
    OUT PULONG  pulBytesTaken,
    IN  PVOID   pvTsdu,
    OUT IRP     **ppIoRequestPacket
    )

/*++

Routine Description

    ClientEventReceiveDatagram indication handler. We figure out the 
    tunnel with which to associate the lookahead data.  We increment some
    stats and then indicate the data to IP (taking care to skip over the
    outer IP header) along with a receive context.
    If all the data is there, IP copies the data out and returns.
    Otherwise IP requests a TransferData.
    In our TransferData function, we set a flag in the receive context (the
    same one is being passed around) to indicate the IP requested a
    TransferData, and return PENDING. 
    The control then returns back to this function. We look at the pXferCtxt
    to see if IP requested a transfer, and if so, we call
    TdiBuildReceiveDatagram() to create the IRP to pass back to complete
    the receive.

    There is some funky stuff that needs to be done with offsets into the
    lookahead as well as destination buffers and care should be taken to
    understand those before change is made to the code.

Locks

    Runs at DISPATCH IRQL.
    
Arguments


Return Value
    NO_ERROR

--*/

{
    PTRANSFER_CONTEXT   pXferCtxt;
    PNDIS_BUFFER        pnbFirstBuffer;
    PVOID               pvData;
    PIRP                pIrp;
    PIP_HEADER          pOutHeader, pInHeader;
    ULARGE_INTEGER      uliTunnelId;
    PTA_IP_ADDRESS      ptiaAddress;
    PTUNNEL             pTunnel;
    ULONG               ulOutHdrLen, ulDataLen;
    BOOLEAN             bNonUnicast;
        
    TraceEnter(RCV, "TdixReceiveIpIp");

    //
    // The TSDU is the data and NOT the MDL
    //

    pvData = (PVOID)pvTsdu;
    
    //
    // Figure out the tunnel for this receive
    // Since the transport indicates atleast 128 bytes, we can safely read out
    // the IP Header
    //

    RtAssert(ulBytesIndicated > sizeof(IP_HEADER));

    pOutHeader = (PIP_HEADER)pvData;

    RtAssert(pOutHeader->byProtocol is PROTO_IPINIP);
    RtAssert((pOutHeader->byVerLen >> 4) is IP_VERSION_4);

    //
    // These defines depend upon a variable being named "uliTunnelId"
    //
    
    REMADDR     = pOutHeader->dwSrc;
    LOCALADDR   = pOutHeader->dwDest;

    //
    // Make sure that the source address given and the IP Header are in
    // synch
    //

    ptiaAddress = (PTA_IP_ADDRESS)pvSourceAddress;

    //
    // Bunch of checks to make sure the packet and the handler
    // are telling us the same thing
    //
    
    RtAssert(lSourceAddressLen is sizeof(TA_IP_ADDRESS));
    
    RtAssert(ptiaAddress->TAAddressCount is 1);
    
    RtAssert(ptiaAddress->Address[0].AddressType is TDI_ADDRESS_TYPE_IP);
    
    RtAssert(ptiaAddress->Address[0].AddressLength is TDI_ADDRESS_LENGTH_IP);

    RtAssert(ptiaAddress->Address[0].Address[0].in_addr is pOutHeader->dwSrc);

    //
    // Get a pointer to the inside header. By TDI spec we should get
    // enough data to get at the inner header
    //
   
    ulDataLen   = RtlUshortByteSwap(pOutHeader->wLength);
    ulOutHdrLen = LengthOfIPHeader(pOutHeader);

    if(ulDataLen < ulOutHdrLen + MIN_IP_HEADER_LENGTH)
    {
        //
        // Malformed packet. Doesnt have a inner header
        //

        Trace(RCV, ERROR,
              ("TdixReceiveIpIp: Packet %d.%d.%d.%d -> %d.%d.%d.%d had size %d\n",
              PRINT_IPADDR(pOutHeader->dwSrc),
              PRINT_IPADDR(pOutHeader->dwDest),
              ulDataLen));

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // This cant be more than 128 (60 + 20)
    //

    RtAssert(ulBytesIndicated > ulOutHdrLen + MIN_IP_HEADER_LENGTH);
    
    pInHeader   = (PIP_HEADER)((PBYTE)pOutHeader + ulOutHdrLen);

    //
    // If the inside header is also IP in IP and is for one of our tunnels,
    // drop the packet. If we dont, someone could build a series of
    // encapsulated headers which would cause this function to be called
    // recursively making us overflow our stack. Ofcourse, a better fix
    // would be to switch processing to another thread at this point
    // for multiply encapsulated packets, but that is too much work; so 
    // currently we just dont allow an IP in IP tunnel within an IP in IP
    // tunnel
    //

    if(pInHeader->byProtocol is PROTO_IPINIP)
    {
        ULARGE_INTEGER  uliInsideId;
        PTUNNEL         pInTunnel;

        //
        // See if this is for us
        //

        uliInsideId.LowPart  = pInHeader->dwSrc;
        uliInsideId.HighPart = pInHeader->dwDest;

        //
        // Find the TUNNEL. We need to acquire the tunnel lock
        //

        EnterReaderAtDpcLevel(&g_rwlTunnelLock);

        pInTunnel = FindTunnel(&uliInsideId);

        ExitReaderFromDpcLevel(&g_rwlTunnelLock);

        if(pInTunnel isnot NULL)
        {
            RtReleaseSpinLockFromDpcLevel(&(pInTunnel->rlLock));

            DereferenceTunnel(pInTunnel);

            Trace(RCV, WARN,
                  ("TdixReceiveIpIp: Packet on tunnel for %d.%d.%d.%d/%d.%d.%d.%d contained another IPinIP packet for tunnel %d.%d.%d.%d/%d.%d.%d.%d\n",
                  PRINT_IPADDR(REMADDR),
                  PRINT_IPADDR(LOCALADDR),
                  PRINT_IPADDR(uliInsideId.LowPart),
                  PRINT_IPADDR(uliInsideId.HighPart)));

            TraceLeave(RCV, "TdixReceiveIpIp");

            return STATUS_DATA_NOT_ACCEPTED;
        }
    }

#if DBG

    //
    // The size of the inner data must be total bytes - outer header
    //
    
    ulDataLen   = RtlUshortByteSwap(pInHeader->wLength);

    RtAssert((ulDataLen + ulOutHdrLen) is ulBytesAvailable);

    //
    // The outer header should also give a good length
    //

    ulDataLen   = RtlUshortByteSwap(pOutHeader->wLength);

    //
    // Data length and bytes available must match
    //
    
    RtAssert(ulDataLen is ulBytesAvailable);
    
#endif
    
    //
    // Find the TUNNEL. We need to acquire the tunnel lock
    //
    
    EnterReaderAtDpcLevel(&g_rwlTunnelLock);
    
    pTunnel = FindTunnel(&uliTunnelId);

    ExitReaderFromDpcLevel(&g_rwlTunnelLock);
    
    if(pTunnel is NULL)
    {
        Trace(RCV, WARN, 
              ("TdixReceiveIpIp: Couldnt find tunnel for %d.%d.%d.%d/%d.%d.%d.%d\n",
              PRINT_IPADDR(REMADDR),
              PRINT_IPADDR(LOCALADDR)));

        //
        // Could not find a matching tunnel
        //

        TraceLeave(RCV, "TdixReceiveIpIp");
        
        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // Ok, so we have the tunnel and it is ref counted and locked
    //
    
    //
    // The number of octets received
    //
    
    pTunnel->ulInOctets += ulBytesAvailable;

    //
    // Check the actual (inside) destination
    //
    
    if(IsUnicastAddr(pInHeader->dwDest))
    {
        //
        // TODO: should we check to see that the address is not 0.0.0.0?
        //
        
        pTunnel->ulInUniPkts++;

        bNonUnicast = FALSE;
    }
    else
    {
        pTunnel->ulInNonUniPkts++;
        
        if(IsClassEAddr(pInHeader->dwDest))
        {
            //
            // Bad address - throw it away
            //
            
            pTunnel->ulInErrors++;

            //
            // Releaselock, free buffer chain
            //
            
        }
        
        bNonUnicast = TRUE;
    }

    if(pTunnel->dwOperState isnot IF_OPER_STATUS_OPERATIONAL)
    {
        Trace(RCV, WARN,
              ("TdixReceiveIpIp: Tunnel %x is not up\n",
               pTunnel));

        pTunnel->ulInDiscards++;

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

        DereferenceTunnel(pTunnel);

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // Allocate a receive context 
    //

    pXferCtxt = AllocateTransferContext();
    
    if(pXferCtxt is NULL)
    {
        Trace(RCV, ERROR,
              ("TdixReceiveIpIp: Couldnt allocate transfer context\n"));

        //
        // Could not allocate context, free the data, unlock and deref
        // the tunnel
        //

        pTunnel->ulInDiscards++;

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
        
        DereferenceTunnel(pTunnel);

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_DATA_NOT_ACCEPTED;
    }
    

    //
    // Fill in the read-datagram context with the information that won't
    // otherwise be available in the completion routine.
    //
    
    pXferCtxt->pTunnel   = pTunnel;

    //
    // Ok, all statistics are done.
    // Release the lock on the tunnel and indicate the data (or part
    // thereof) to IP
    //

    RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

    //
    // The data starts at pInHeader
    // We indicate (ulBytesIndicated - outer header length) up to IP
    // The total data is the (ulBytesAvailable - outer header)
    // We associate a TRANSFER_CONTEXT with this indication,
    // The Protocol Offset is just our outer header
    // 

    pXferCtxt->bRequestTransfer = FALSE;

#if PROFILE
   
    KeQueryTickCount((PLARGE_INTEGER)&(pXferCtxt->llRcvTime));

#endif
 
    g_pfnIpRcv(pTunnel->pvIpContext,
               pInHeader,
               ulBytesIndicated - ulOutHdrLen,
               ulBytesAvailable - ulOutHdrLen,
               pXferCtxt,
               ulOutHdrLen,
               bNonUnicast,
               NULL);
    
    //
    // IP calls our TransferData synchronously, and since we also handle
    // that call synchronously. If IP requests a data transfer, we set
    // bRequestTransfer to true in the pXferCtxt
    //

    if(pXferCtxt->bRequestTransfer is FALSE)
    {

#if PROFILE

        LONGLONG llTime;

        KeQueryTickCount((PLARGE_INTEGER)&llTime);

        llTime -= pXferCtxt->llRcvTime;

        llTime *= KeQueryTimeIncrement();

        Trace(RCV, ERROR,
              ("Profile: Rcv took %d.%d units\n",
               ((PLARGE_INTEGER)&llTime)->HighPart,
               ((PLARGE_INTEGER)&llTime)->LowPart));

#endif

        Trace(RCV, TRACE,
              ("TdixReceiveIpIp: IP did not request transfer\n"));

        //
        // For some reason or another IP did not want this packet
        // We are done with it
        //

        FreeTransferContext(pXferCtxt);
        
        DereferenceTunnel(pTunnel);

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_SUCCESS;
    }

    //
    // Make sure that the things looks the same before and after the call
    //

    RtAssert(pXferCtxt->pvContext is pTunnel);
    RtAssert(pXferCtxt->uiProtoOffset is ulOutHdrLen);

    //
    // Should not be asking to transfer more than was indicated
    //
    
    RtAssert(pXferCtxt->uiTransferLength <= ulBytesAvailable);
    
    //
    // So IP did want it transferred
    //
    
#if ALLOCATEIRPS

    //
    // Allocate the IRP directly.
    //
    
    pIrp = IoAllocateIrp(g_pIpIpFileObj->DeviceObject->StackSize,
                         FALSE);
    
#else

    //
    // Allocate a "receive datagram" IRP with base initialization.
    //
    
    pIrp =  TdiBuildInternalDeviceControlIrp(TDI_RECEIVE_DATAGRAM,
                                             g_pIpIpFileObj->DeviceObject,
                                             g_pIpIpFileObj,
                                             NULL,
                                             NULL);
    
#endif

    if(!pIrp)
    {
        Trace(RCV, ERROR,
              ("TdixReceiveIpIp: Unable to build IRP for receive\n"));

        pTunnel->ulInDiscards++;

        FreeTransferContext(pXferCtxt);

        //
        // Call IP's TDComplete to signal the failure of this
        // transfer
        //
        
        
        DereferenceTunnel(pTunnel);

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_DATA_NOT_ACCEPTED;
    }

   
    //
    // IP gives us an NDIS_PACKET to which to transfer data
    // TDI wants just an MDL chain
    //

#if NDISBUFFERISMDL
 
    NdisQueryPacket(pXferCtxt->pnpTransferPacket,
                    NULL,
                    NULL,
                    &pnbFirstBuffer,
                    NULL);

#else
#error "Fix This"
#endif    

    //
    // Complete the "receive datagram" IRP initialization.
    //
    
    TdiBuildReceiveDatagram(pIrp,
                            g_pIpIpFileObj->DeviceObject,
                            g_pIpIpFileObj,
                            TdixReceiveIpIpDatagramComplete,
                            pXferCtxt,
                            pnbFirstBuffer,
                            pXferCtxt->uiTransferLength,
                            NULL,
                            NULL,
                            0);
    

    //
    // Adjust the IRP's stack location to make the transport's stack current.
    // Normally IoCallDriver handles this, but this IRP doesn't go thru
    // IoCallDriver.  Seems like it would be the transport's job to make this
    // adjustment, but IP for one doesn't seem to do it.  There is a similar
    // adjustment in both the redirector and PPTP.
    //
    
    IoSetNextIrpStackLocation(pIrp);

    *ppIoRequestPacket = pIrp;
    *pulBytesTaken     = pXferCtxt->uiTransferOffset + ulOutHdrLen;

    //
    // we DONT dereference the TUNNEL here
    // That is done in the completion routine
    //
    
    TraceLeave(RCV, "TdixReceiveIpIp");

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
TdixReceiveIpIpDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description

    Standard I/O completion routine.
    Called to signal the completion of a receive. The context is the
    TRANSFER_CONTEXT setup with TdiBuildReceiveDatagram. 
    
Locks

    Takes the TUNNEL's lock.
    
Arguments

   
Return Value

    STATUS_SUCCESS

--*/

{
    PTRANSFER_CONTEXT   pXferCtxt;
    PTUNNEL             pTunnel;
    LONGLONG            llTime;

    TraceEnter(RCV, "TdixReceiveIpIpDatagramComplete");
    
    pXferCtxt = (PTRANSFER_CONTEXT) Context;

    //
    // The tunnel has been referenced but not locked
    //
    
    pTunnel = pXferCtxt->pTunnel;

    RtAssert(pXferCtxt->uiTransferLength is Irp->IoStatus.Information);
    
    g_pfnIpTDComplete(pTunnel->pvIpContext,
                      pXferCtxt->pnpTransferPacket,
                      Irp->IoStatus.Status,
                      (ULONG)(Irp->IoStatus.Information));

#if PROFILE

    KeQueryTickCount((PLARGE_INTEGER)&llTime);

    Trace(RCV, ERROR,
          ("Profile: %d.%d %d.%d\n",
            ((PLARGE_INTEGER)&llTime)->HighPart,
            ((PLARGE_INTEGER)&llTime)->LowPart,
            ((PLARGE_INTEGER)&pXferCtxt->llRcvTime)->HighPart,
            ((PLARGE_INTEGER)&pXferCtxt->llRcvTime)->LowPart));

    llTime -= pXferCtxt->llRcvTime;

    llTime *= KeQueryTimeIncrement();

    Trace(RCV, ERROR,
          ("Profile: Rcv took %d.%d units\n",
           ((PLARGE_INTEGER)&llTime)->HighPart,
           ((PLARGE_INTEGER)&llTime)->LowPart));

#endif

    FreeTransferContext(pXferCtxt);

    //
    // Deref the tunnel (finally)
    //

    DereferenceTunnel(pTunnel);
    
#if ALLOCATEIRPS
    
    //
    // Releae the IRP resources and tell the I/O manager to forget it existed
    // in the standard way.
    //
    
    IoFreeIrp(Irp);
    
    TraceLeave(RCV, "TdixReceiveIpIpDatagramComplete");

    return STATUS_MORE_PROCESSING_REQUIRED;
    
#else

    //
    // Let the I/O manager release the IRP resources.
    //
    
    TraceLeave(RCV, "TdixReceiveIpIpDatagramComplete");

    return STATUS_SUCCESS;

#endif
}


#pragma alloc_text(PAGE, TdixSendDatagram)

#if PROFILE

NTSTATUS
TdixSendDatagram(
    IN PTUNNEL      pTunnel,
    IN PNDIS_PACKET pnpPacket,
    IN PNDIS_BUFFER pnbFirstBuffer,
    IN ULONG        ulBufferLength,
    IN LONGLONG     llSendTime,
    IN LONGLONG     llCallTime,
    IN LONGLONG     llTransmitTime
    )

#else

NTSTATUS
TdixSendDatagram(
    IN PTUNNEL      pTunnel,
    IN PNDIS_PACKET pnpPacket,
    IN PNDIS_BUFFER pnbFirstBuffer,
    IN ULONG        ulBufferLength
    )

#endif

/*++

Routine Description

    Sends a datagram over a tunnel. The remote endpoint is that of the tunnel
    and the send complete handler is TdixSendCompleteHandler
    A SendContext is associated with the send
    
Locks

    This call needs to be at PASSIVE level
    The TUNNEL needs to be ref counted but not locked
 
Arguments

    pTunnel         TUNNEL over which the datagram is to be sent
    pnpPacket       Packet descriptor allocate from PACKET_POOL of the tunnel
    pnbFirstBuffer  The first buffer in the chain (the outer IP header)
    ulBufferLength  The lenght of the complete packet (including outer header)

Return Value


--*/

{
    NTSTATUS        nStatus;
    PSEND_CONTEXT   pSendCtxt;
    PIRP            pIrp;
   
    TraceEnter(SEND, "TdixSendDatagram");
 
    do
    {
        //
        // Allocate a context for this send-datagram from our lookaside list.
        //
        
        pSendCtxt = AllocateSendContext();

        if(pSendCtxt is NULL)
        {
            Trace(SEND, ERROR,
                  ("TdixSendDatagram: Unable to allocate send context\n"));

            nStatus = STATUS_INSUFFICIENT_RESOURCES;

            break;
        }

            
#if ALLOCATEIRPS

        //
        // Allocate the IRP directly.
        //
        
        pIrp = IoAllocateIrp(g_pIpIpFileObj->DeviceObject->StackSize,
                             FALSE);
       
        // Trace(GLOBAL, ERROR,
        //      ("TdixSendDatagram: irp = 0x%x\n",pIrp));
 
#else
        
        //
        // Allocate a "send datagram" IRP with base initialization.
        //
        
        pIrp = TdiBuildInternalDeviceControlIrp(TDI_SEND_DATAGRAM,
                                                g_pIpIpFileObj->DeviceObject,
                                                g_pIpIpFileObj,
                                                NULL,
                                                NULL);
        
#endif

        if(!pIrp)
        {
            Trace(SEND, ERROR,
                  ("TdixSendDatagram: Unable to build IRP\n"));
            
            nStatus = STATUS_INSUFFICIENT_RESOURCES;
            
            break;
        }

        //
        // Fill in the send-datagram context.
        //
            
        pSendCtxt->pTunnel      = pTunnel;
        pSendCtxt->pnpPacket    = pnpPacket;
        pSendCtxt->ulOutOctets  = ulBufferLength;

#if PROFILE

        pSendCtxt->llSendTime       = llSendTime;
        pSendCtxt->llCallTime       = llCallTime;
        pSendCtxt->llTransmitTime   = llTransmitTime;

#endif
        
        //
        // Complete the "send datagram" IRP initialization.
        //
        
        TdiBuildSendDatagram(pIrp,
                             g_pIpIpFileObj->DeviceObject,
                             g_pIpIpFileObj,
                             TdixSendDatagramComplete,
                             pSendCtxt,
                             pnbFirstBuffer,
                             ulBufferLength,
                             &(pTunnel->tciConnInfo));
        
        //
        // Tell the I/O manager to pass our IRP to the transport for
        // processing.
        //

#if PROFILE

        KeQueryTickCount((PLARGE_INTEGER)&pSendCtxt->llCall2Time);

#endif

        nStatus = IoCallDriver(g_pIpIpFileObj->DeviceObject,
                               pIrp);
        
        RtAssert(nStatus is STATUS_PENDING);
        
        nStatus = STATUS_SUCCESS;
        
    }while (FALSE);

    if(nStatus isnot STATUS_SUCCESS)
    {
        Trace(SEND, ERROR,
              ("TdixSendDatagram: Status %X sending\n",
               nStatus));

        //
        // Pull a half Jameel, i.e. convert a synchronous failure to an
        // asynchronous failure from client's perspective.  However, clean up
        // context here.
        //
        
        if(pSendCtxt)
        {
            FreeSendContext(pSendCtxt);
        }

        IpIpSendComplete(nStatus,
                         pTunnel,
                         pnpPacket,
                         ulBufferLength);

    }

    TraceLeave(SEND, "TdixSendDatagram");

    return STATUS_PENDING;
}


NTSTATUS
TdixSendDatagramComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PSEND_CONTEXT   pSendCtxt;
    PTUNNEL         pTunnel;
    PNDIS_PACKET    pnpPacket;
    PNDIS_BUFFER    pnbFirstBuffer;
    ULONG           ulBufferLength;
    KIRQL           irql;
    LONGLONG        llTime, llSendTime, llQTime, llTxTime, llCallTime;
    ULONG           ulInc;
 
    TraceEnter(SEND, "TdixSendDatagramComplete");

    pSendCtxt       = (PSEND_CONTEXT) Context;

#if PROFILE

    KeQueryTickCount((PLARGE_INTEGER)&llTime);
    
    ulInc   = KeQueryTimeIncrement();

    llSendTime  = pSendCtxt->llCallTime - pSendCtxt->llSendTime;
    llSendTime *= ulInc;
   
    llQTime     = pSendCtxt->llTransmitTime - pSendCtxt->llCallTime;
    llQTime    *= ulInc;

    llTxTime    = pSendCtxt->llCall2Time - pSendCtxt->llTransmitTime;
    llTxTime   *= ulInc;

    llCallTime  = llTime - pSendCtxt->llCall2Time;
    llCallTime *= ulInc;

    llTime      = llTime - pSendCtxt->llSendTime;
    llTime     *= ulInc;

    DbgPrint("SendProfile: Send %d.%d Q %d.%d Tx %d.%d Call %d.%d \nTotal %d.%d\n",
            ((PLARGE_INTEGER)&llSendTime)->HighPart,
            ((PLARGE_INTEGER)&llSendTime)->LowPart,
            ((PLARGE_INTEGER)&llQTime)->HighPart,
            ((PLARGE_INTEGER)&llQTime)->LowPart,
            ((PLARGE_INTEGER)&llTxTime)->HighPart,
            ((PLARGE_INTEGER)&llTxTime)->LowPart,
            ((PLARGE_INTEGER)&llCallTime)->HighPart,
            ((PLARGE_INTEGER)&llCallTime)->LowPart,
            ((PLARGE_INTEGER)&llTime)->HighPart,
            ((PLARGE_INTEGER)&llTime)->LowPart);

#endif

    //
    // Just call our SendComplete function with the right args
    //

    pTunnel         = pSendCtxt->pTunnel;
    pnpPacket       = pSendCtxt->pnpPacket;
    ulBufferLength  = pSendCtxt->ulOutOctets;

    //
    // Free the send-complete context.
    // 

    FreeSendContext(pSendCtxt);
    
    IpIpSendComplete(Irp->IoStatus.Status,
                     pTunnel,
                     pnpPacket,
                     ulBufferLength);
    
#if ALLOCATEIRPS

    //
    // Release the IRP resources and tell the I/O manager to forget it existed
    // in the standard way.
    //
    
    IoFreeIrp(Irp);
    
    TraceLeave(SEND, "TdixSendDatagramComplete");

    return STATUS_MORE_PROCESSING_REQUIRED;
    
#else

    //
    // Let the I/O manager release the IRP resources.
    //
    
    TraceLeave(SEND, "TdixSendDatagramComplete");

    return STATUS_SUCCESS;
    
#endif
}


NTSTATUS
TdixReceiveIcmpDatagram(
    IN  PVOID   pvTdiEventContext,
    IN  LONG    lSourceAddressLen,
    IN  PVOID   pvSourceAddress,
    IN  LONG    plOptionsLeng,
    IN  PVOID   pvOptions,
    IN  ULONG   ulReceiveDatagramFlags,
    IN  ULONG   ulBytesIndicated,
    IN  ULONG   ulBytesAvailable,
    OUT PULONG  pulBytesTaken,
    IN  PVOID   pvTsdu,
    OUT IRP     **ppIoRequestPacket
    )

/*++

Routine Description

    ClientEventReceiveDatagram indication handler for ICMP messages.
    ICMP messages are used to monitor the state of the tunnel

    We currently only look for Type 3 Code 4 messages (fragmentation
    needed, but don't fragment bit is set). This is done to support
    PATH MTU over tunnels.

    We look at the IP header inside the ICMP packet. We see if it was an
    IP in IP packet that caused this ICMP message, and if so we try and match
    it to one of our TUNNELS.

Locks

    Runs at DISPATCH IRQL.
    
Arguments


Return Value
    NO_ERROR

--*/

{
    PVOID               pvData;
    PIRP                pIrp;
    PIP_HEADER          pOutHeader, pInHeader;
    PICMP_HEADER        pIcmpHdr;
    ULARGE_INTEGER      uliTunnelId;
    PTA_IP_ADDRESS      ptiaAddress;
    PTUNNEL             pTunnel;
    ULONG               ulOutHdrLen, ulDataLen, ulIcmpLen;
    BOOLEAN             bNonUnicast;
    PICMP_HANDLER       pfnHandler;
    NTSTATUS            nStatus;

    pfnHandler = NULL;
    
    //
    // The TSDU is the data and NOT the MDL
    //

    pvData = (PVOID)pvTsdu;
    
    //
    // Figure out the tunnel for this receive
    // Since the transport indicates atleast 128 bytes, we can safely read out
    // the IP Header
    //

    RtAssert(ulBytesIndicated > sizeof(IP_HEADER));

    pOutHeader = (PIP_HEADER)pvData;

    RtAssert(pOutHeader->byProtocol is PROTO_ICMP);
    
    RtAssert(pOutHeader->byVerLen >> 4 is IP_VERSION_4);

    //
    // Since the ICMP packet is small, we expect all the data to be 
    // give to us, instead of having to do a transfer data
    //

    ulDataLen   = RtlUshortByteSwap(pOutHeader->wLength);
    ulOutHdrLen = LengthOfIPHeader(pOutHeader);

    if(ulDataLen < ulOutHdrLen + sizeof(ICMP_HEADER))
    {
        //
        // Malformed packet. Doesnt have a inner header
        //

        Trace(RCV, ERROR,
              ("TdixReceiveIcmp: Packet %d.%d.%d.%d -> %d.%d.%d.%d had size %d\n",
              PRINT_IPADDR(pOutHeader->dwSrc),
              PRINT_IPADDR(pOutHeader->dwDest),
              ulDataLen));

        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // This cant be more than 128 (60 + 4)
    //

    RtAssert(ulBytesIndicated > ulOutHdrLen + sizeof(ICMP_HEADER));

    pIcmpHdr = (PICMP_HEADER)((PBYTE)pOutHeader + ulOutHdrLen);

    ulIcmpLen = ulDataLen - ulOutHdrLen;

    //
    // See if this is one of the types we are interested in
    //

    switch(pIcmpHdr->byType)
    {
        case ICMP_TYPE_DEST_UNREACHABLE:
        {
            //
            // Only interested in codes 0 - 4
            //

            if(pIcmpHdr->byCode > ICMP_CODE_DGRAM_TOO_BIG)
            {
                return STATUS_DATA_NOT_ACCEPTED;
            }

            if(ulIcmpLen < (DEST_UNREACH_LENGTH + MIN_IP_HEADER_LENGTH))
            {
                //
                // Not enough data to get at the tunnel 
                //

                return STATUS_DATA_NOT_ACCEPTED;
            }

            pInHeader = (PIP_HEADER)((ULONG_PTR)pIcmpHdr + DEST_UNREACH_LENGTH);

            pfnHandler = HandleDestUnreachable;

            break;
        }

        case ICMP_TYPE_TIME_EXCEEDED:
        {
            if(ulIcmpLen < (TIME_EXCEED_LENGTH + MIN_IP_HEADER_LENGTH))
            {
                //
                // Not enough data to get at the tunnel
                //

                return STATUS_DATA_NOT_ACCEPTED;
            }

            pInHeader = (PIP_HEADER)((PBYTE)pIcmpHdr + TIME_EXCEED_LENGTH);

            pfnHandler = HandleTimeExceeded;
            
            break;
        }

        case ICMP_TYPE_PARAM_PROBLEM:
        default:
        {
            //
            // Not interested in this
            //

            
            return STATUS_DATA_NOT_ACCEPTED;
        }
    }

    //
    // See if the packet that caused the ICMP was an IP in IP packet
    //

    if(pInHeader->byProtocol isnot PROTO_IPINIP)
    {
        //
        // Someother packet caused this
        //

        return STATUS_DATA_NOT_ACCEPTED;
    }
    
    //
    // See if we can find a tunnel associated with the original packet
    // These defines depend upon a variable being named "uliTunnelId"
    //
    
    REMADDR     = pInHeader->dwDest;
    LOCALADDR   = pInHeader->dwSrc;

    //
    // Make sure that the source address given and the IP Header are in
    // synch
    //

    ptiaAddress = (PTA_IP_ADDRESS)pvSourceAddress;

    //
    // Bunch of checks to make sure the packet and the handler
    // are telling us the same thing
    //
    
    RtAssert(lSourceAddressLen is sizeof(TA_IP_ADDRESS));
    
    RtAssert(ptiaAddress->TAAddressCount is 1);
    
    RtAssert(ptiaAddress->Address[0].AddressType is TDI_ADDRESS_TYPE_IP);
    
    RtAssert(ptiaAddress->Address[0].AddressLength is TDI_ADDRESS_LENGTH_IP);

    RtAssert(ptiaAddress->Address[0].Address[0].in_addr is pOutHeader->dwSrc);

    //
    // Find the TUNNEL. We need to acquire the tunnel lock
    //
    
    EnterReaderAtDpcLevel(&g_rwlTunnelLock);
    
    pTunnel = FindTunnel(&uliTunnelId);

    ExitReaderFromDpcLevel(&g_rwlTunnelLock);
    
    if(pTunnel is NULL)
    {
        //
        // Could not find a matching tunnel
        //

        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // Ok, so we have the tunnel and it is ref counted and locked
    //
    
    nStatus = pfnHandler(pTunnel,
                         pIcmpHdr,
                         pInHeader);
 
    RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
        
    DereferenceTunnel(pTunnel);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\tdix.h ===
/*++

Copyright (c) 1997  Microsoft Corporation


Module Name:

    net\routing\ip\ipinip\tdix.h

Abstract:

    Interface to TDI

Revision History:

    Copied from Steve Cobb's ntos\ndis\l2tp code
    Most of the comments are the original ones from SteveC.
    There are style and some name changes
    
--*/


#ifndef __IPINIP_TDIX_H__
#define __IPINIP_TDIX_H__


//
// Read datagram information context used to pass context information from the
// ReadDatagram event handler to the RECEIVE_DATAGRAM completion routine.
//

typedef struct _SEND_CONTEXT
{
    //
    // The tunnel over which the send is being done
    //

    PTUNNEL         pTunnel;

    //
    // Pointer to the packet being sent
    // This packet is not sent, rather the first buffer is sent
    //

    PNDIS_PACKET    pnpPacket;

    //
    // The size of the packet
    //

    ULONG           ulOutOctets;

#if PROFILE

    LONGLONG        llSendTime;
    LONGLONG        llCallTime;
    LONGLONG        llTransmitTime;
    LONGLONG        llCall2Time;

#endif

}SEND_CONTEXT, *PSEND_CONTEXT;

typedef struct _TRANSFER_CONTEXT
{
    //
    // Tunnel associated with the receive
    //

    PTUNNEL         pTunnel;

    //
    // The packet to transfer data into
    //

    PNDIS_PACKET    pnpTransferPacket;

    //
    // The context returned by IP
    //

    PVOID           pvContext;

    //
    // The offset indicated by us to IP (outer IP Header)
    //

    UINT            uiProtoOffset;

    //
    // The offset into the received packet at which to begin copying data
    //

    UINT            uiTransferOffset;

    //
    // The the number of bytes to transfer
    //

    UINT            uiTransferLength;

    //
    // Flag to see if IP requested a transfer
    //

    BOOLEAN         bRequestTransfer;

#if PROFILE

    LONGLONG        llRcvTime;

#endif

}TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

typedef struct _QUEUE_NODE
{
    LIST_ENTRY      leQueueItemLink;

    //
    // We make the work queue item part of the struct so that
    // we dont need to allocate (and free) two structs
    //

    WORK_QUEUE_ITEM WorkItem;

    //
    // The ppPacketArray points to an vector of uiNumPackets NDIS_PACKETs
    // The common case however is uiNumPackets = 1. To optimiize for this
    // we make ppPacketArray point to pnpPacket and make pnpPacket point to
    // the packet to transmit. This way we dont need to allocate a 
    // uiNumPackets * sizeof(PNDIS_PACKET) sized block of memory.
    //

    NDIS_PACKET     **ppPacketArray;

    PNDIS_PACKET    pnpPacket;

    //
    // The number of packets
    //

    UINT            uiNumPackets;

    //
    // The next hop address. Not really important, maybe move this to 
    // a debug only build?
    //

    DWORD           dwDestAddr;

#if PROFILE

    LONGLONG        llSendTime;
    LONGLONG        llCallTime;

#endif

}QUEUE_NODE, *PQUEUE_NODE;

typedef struct _OPEN_CONTEXT
{

    PKEVENT     pkeEvent;
    NTSTATUS    nStatus;

}OPEN_CONTEXT, *POPEN_CONTEXT;

//
// The depths of the lookaside lists used to allocate send and receive
// contexts
//

#define SEND_CONTEXT_LOOKASIDE_DEPTH        20
#define TRANSFER_CONTEXT_LOOKASIDE_DEPTH    20
#define QUEUE_NODE_LOOKASIDE_DEPTH          20

//
// The lookaside lists themselves
//

extern NPAGED_LOOKASIDE_LIST    g_llSendCtxtBlocks;
extern NPAGED_LOOKASIDE_LIST    g_llTransferCtxtBlocks;
extern NPAGED_LOOKASIDE_LIST    g_llQueueNodeBlocks;


//++
//  PSEND_CONTEXT
//  AllocateSendContext(
//      VOID
//      )
//
//  Allocate a send context from g_llSendCtxtBlocks
//
//--

#define AllocateSendContext()               \
            ExAllocateFromNPagedLookasideList(&g_llSendCtxtBlocks)

//++
//  VOID
//  FreeSendContext(
//      PSEND_CONTEXT   pSndCtxt
//      )
//
//  Free a send context to g_llSendCtxtBlocks
//
//--

#define FreeSendContext(p)                  \
            ExFreeToNPagedLookasideList(&g_llSendCtxtBlocks, (p))


//++
//  PTRANSFER_CONTEXT
//  AllocateTransferContext(
//      VOID
//      )
//
//  Allocate a transfer context from g_llTransferCtxtBlocks
//
//--

#define AllocateTransferContext()           \
            ExAllocateFromNPagedLookasideList(&g_llTransferCtxtBlocks)


//++
//  VOID
//  FreeTransferContext(
//      PTRANSFER_CONTEXT   pTransferCtxt
//      )
//
//  Free a transfer context to g_llTransferCtxtBlocks
//
//--

#define FreeTransferContext(p)                  \
            ExFreeToNPagedLookasideList(&g_llTransferCtxtBlocks, (p))


//++
//  PQUEUE_NODE
//  AllocateQueueNode(
//      VOID
//      )
//
//  Allocate a queue node from g_llQueueNodeBlocks
//
//--

#define AllocateQueueNode()                     \
            ExAllocateFromNPagedLookasideList(&g_llQueueNodeBlocks)

//++
//  VOID
//  FreeQueueNode(
//      PQUEUE_NODE pQueueNode
//      )
//
//  Free a work context to g_llQueueNodeBlocks
//
//--

#define FreeQueueNode(p)                        \
            ExFreeToNPagedLookasideList(&g_llQueueNodeBlocks, (p))


//
// Interface prototypes
//

VOID
TdixInitialize(
    PVOID   pvContext
    );

NTSTATUS
TdixOpenRawIp(
    IN  DWORD       dwProtoId,
    OUT HANDLE      *phAddrHandle,
    OUT FILE_OBJECT **ppAddrFileObj
    );

VOID
TdixDeinitialize(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PVOID            pvContext
    );

NTSTATUS
TdixInstallEventHandler(
    IN PFILE_OBJECT pAddrFileObj,
    IN INT          iEventType,
    IN PVOID        pfnEventHandler,
    IN PVOID        pvEventContext
    );

VOID
TdixAddressArrival(
    PTA_ADDRESS         pAddr,
    PUNICODE_STRING     pusDeviceName,
    PTDI_PNP_CONTEXT    pContext
    );

VOID
TdixAddressDeletion(
    PTA_ADDRESS         pAddr,
    PUNICODE_STRING     pusDeviceName,
    PTDI_PNP_CONTEXT    pContext
    );

NTSTATUS
TdixReceiveIpIpDatagram(
    IN  PVOID   pvTdiEventContext,
    IN  LONG    lSourceAddressLen,
    IN  PVOID   pvSourceAddress,
    IN  LONG    plOptionsLeng,
    IN  PVOID   pvOptions,
    IN  ULONG   ulReceiveDatagramFlags,
    IN  ULONG   ulBytesIndicated,
    IN  ULONG   ulBytesAvailable,
    OUT PULONG  pulBytesTaken,
    IN  PVOID   pvTsdu,
    OUT IRP     **ppIoRequestPacket
    );

NTSTATUS
TdixReceiveIpIpDatagramComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#if PROFILE

NTSTATUS
TdixSendDatagram(
    IN PTUNNEL      pTunnel,
    IN PNDIS_PACKET pnpPacket,
    IN PNDIS_BUFFER pnbFirstBuffer,
    IN ULONG        ulBufferLength,
    IN LONGLONG     llSendTime,
    IN LONGLONG     llCallTime,
    IN LONGLONG     llTransmitTime
    );

#else

NTSTATUS
TdixSendDatagram(
    IN PTUNNEL      pTunnel,
    IN PNDIS_PACKET pnpPacket,
    IN PNDIS_BUFFER pnbFirstBuffer,
    IN ULONG        ulBufferLength
    );

#endif

NTSTATUS
TdixSendDatagramComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
TdixReceiveIcmpDatagram(
    IN  PVOID   pvTdiEventContext,
    IN  LONG    lSourceAddressLen,
    IN  PVOID   pvSourceAddress,
    IN  LONG    plOptionsLeng,
    IN  PVOID   pvOptions,
    IN  ULONG   ulReceiveDatagramFlags,
    IN  ULONG   ulBytesIndicated,
    IN  ULONG   ulBytesAvailable,
    OUT PULONG  pulBytesTaken,
    IN  PVOID   pvTsdu,
    OUT IRP     **ppIoRequestPacket
    );

#endif // __IPINIP_TDIX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\mcastmib\defs.h

Abstract:

    IP Multicast MIB defines

Revision history:

    Dave Thaler         4/17/98  Created

--*/

#ifndef __DEFS_H__
#define __DEFS_H__

// 
// Define this when snmpsfx.dll supports 3-phase sets
//
#undef THREE_PHASE

//
// Define this if the router keeps track of the number of hops to the
// closest member (e.g. MOSPF can calculate this) to set a TTL per oif entry.
//
#undef CLOSEST_MEMBER_HOPS


#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000)>>24)

#define     IP_ADDRESS_LEN  4

//------------------------------------------------------------------------------
// Memory allocation/deallocation macros
//------------------------------------------------------------------------------

#define     MULTICAST_MIB_ALLOC( x )          HeapAlloc( GetProcessHeap(), 0, (x) )
#define     MULTICAST_MIB_FREE( x )           HeapFree( GetProcessHeap(), 0, (x) )

//------------------------------------------------------------------------------
// Macro to simplify use of DIM MIB functions
//------------------------------------------------------------------------------
#define     CONNECT_TO_ROUTER(res)                                          \
    (res) = ( g_hMIBServer ) ? NO_ERROR : ConnectToRouter()

#define     MIB_GET(type, w, x, y, z, res)                                  \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntry ## type(                                   \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    IPRTRMGR_PID,                                           \
                    (LPVOID) (w),                                           \
                    (x),                                                    \
                    (LPVOID *) (y),                                         \
                    (z)                                                     \
                );                                                          \
    }                                                                       \
}

#define     MIB_SET(type, x, y, res)                                        \
{                                                                           \
    CONNECT_TO_ROUTER(res);                                                 \
                                                                            \
    if ( (res) == NO_ERROR )                                                \
    {                                                                       \
        (res) = MprAdminMIBEntry ## type(                                   \
                    g_hMIBServer,                                           \
                    PID_IP,                                                 \
                    IPRTRMGR_PID,                                           \
                    (LPVOID) (x),                                           \
                    (y)                                                     \
                );                                                          \
    }                                                                       \
}

#define     MULTICAST_MIB_GET(w, x, y, z, res)                              \
    MIB_GET(Get, w, x, y, z, res)
    
#define     MULTICAST_MIB_GETFIRST(w, x, y, z, res)                         \
    MIB_GET(GetFirst, w, x, y, z, res)
    
#define     MULTICAST_MIB_GETNEXT(w, x, y, z, res)                          \
    MIB_GET(GetNext, w, x, y, z, res)

#define     MULTICAST_MIB_VALIDATE(x, y, res)                               \
    MIB_SET(Validate, x, y, res)

#define     MULTICAST_MIB_COMMIT(x, y, res)                                 \
    MIB_SET(Set, x, y, res)

#define     MULTICAST_MIB_CLEANUP(x, y, res)                                \
    MIB_SET(Cleanup, x, y, res)

//------------------------------------------------------------------------------
// Macros to convert between Asn and Win32 data types
//------------------------------------------------------------------------------

#define SetAsnInteger(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_INTEGER);             \
	    (dstBuf)->asnValue.number = (AsnInteger)(val);      \
    }                                                       \
}

#define ForceSetAsnInteger(dstBuf,val){                     \
    (dstBuf)->asnType = ASN_INTEGER;                        \
    (dstBuf)->asnValue.number = (AsnInteger)(val);          \
}

#define SetAsnCounter(dstBuf,val){                          \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_COUNTER);     \
        (dstBuf)->asnValue.counter = (AsnCounter)(val);     \
    }                                                       \
}

#define SetAsnTimeTicks(dstBuf,val){                        \
    if ((dstBuf)->asnType)			                        \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_TIMETICKS);   \
        (dstBuf)->asnValue.ticks = (AsnTimeticks)(val);     \
    }                                                       \
}

#define SetAsnOctetString(dstBuf,buffer,src,len){           \
    if ((dstBuf)->asnType)                                  \
    {                                                       \
        ASSERT((dstBuf)->asnType==ASN_OCTETSTRING);         \
        (dstBuf)->asnValue.string.length = len;             \
        (dstBuf)->asnValue.string.stream = (BYTE*)memcpy(buffer,src,len);\
        (dstBuf)->asnValue.string.dynamic = FALSE;          \
    }                                                       \
}

#define SetAsnIPAddress(dstBuf,buffer,val){                     \
    if ((dstBuf)->asnType)			                            \
    {                                                           \
        ASSERT((dstBuf)->asnType==ASN_RFC1155_IPADDRESS);       \
        (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;     \
        if(!(dstBuf)->asnValue.address.stream)                  \
        {                                                       \
           (dstBuf)->asnValue.address.stream = (PBYTE)buffer;   \
           (dstBuf)->asnValue.address.dynamic = FALSE;          \
        }                                                       \
        (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;   \
    }                                                           \
}

#define ForceSetAsnIPAddress(dstBuf,buffer,val){                \
    (dstBuf)->asnType = ASN_RFC1155_IPADDRESS;                  \
    (dstBuf)->asnValue.address.length = IP_ADDRESS_LEN;         \
    if(!((dstBuf)->asnValue.address.stream))                    \
    {                                                           \
       (dstBuf)->asnValue.address.stream = (PBYTE)buffer;       \
       (dstBuf)->asnValue.address.dynamic = FALSE;              \
    }                                                           \
    (*(DWORD*)((dstBuf)->asnValue.address.stream)) = val;       \
}

#define GetAsnInteger(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.number):(defVal))

#define GetAsnCounter(srcBuf,defVal)                        \
    (((srcBuf)->asnType)? ((srcBuf)->asnValue.counter):(defVal))

#define GetAsnTimeTicks(srcBuf, defval) \
    ( ( (srcBuf)-> asnType ) ? (srcBuf)-> asnValue.ticks : (defval) )

#define GetAsnIPAddress(srcBuf,defVal)                                  \
    (DWORD)(((srcBuf)->asnType && (srcBuf)->asnValue.string.length)?    \
            (*(DWORD*)((srcBuf)->asnValue.address.stream)) : (defVal))	

#define GetAsnOctetString(dst,srcBuf) \
    (((srcBuf)->asnType) \
     ? (memcpy(dst,(srcBuf)->asnValue.string.stream,\
                 (srcBuf)->asnValue.string.length)) \
     : NULL)


#define IsAsnTypeNull(asnObj) (!((asnObj)->asnType))
#define IsAsnIPAddressTypeNull(asnObj) (!((asnObj)->asnType && (asnObj)->asnValue.address.length))

//
// Timeouts for the caches in millisecs
//
#define IPMULTI_IF_CACHE_TIMEOUT  (1 * 1000)

//------------------------------------------------------------------------------
// Debug tracing macros
//------------------------------------------------------------------------------

#ifdef MIB_DEBUG
#define TRACE0(Z)             TracePrintf(g_dwTraceId,Z)
#define TRACE1(Y,Z)           TracePrintf(g_dwTraceId,Y,Z)
#define TRACE2(X,Y,Z)         TracePrintf(g_dwTraceId,X,Y,Z)
#define TRACE3(W,X,Y,Z)       TracePrintf(g_dwTraceId,W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)     TracePrintf(g_dwTraceId,V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)   TracePrintf(g_dwTraceId,U,W,X,Y,Z)

#define TRACEW0(Z)            TracePrintfW(g_dwTraceId,Z)

#define TraceEnter(X)         TracePrintf(g_dwTraceId,"Entering " X)
#define TraceLeave(X)         TracePrintf(g_dwTraceId,"Leaving " X "\n")

#define TraceError(X) \
    TracePrintf( g_dwTraceId, "MprAdminMIB API returned : %d", (X) ); 

#define TraceError1(x)                              \
{                                                   \
    LPWSTR  __lpwszErr = NULL;                      \
                                                    \
    TRACE1( "MprAdminMIB API returned : %d", (x) ); \
    MprAdminGetErrorString( (x), &__lpwszErr );     \
                                                    \
    if ( __lpwszErr )                               \
    {                                               \
        TRACEW0( __lpwszErr );                      \
        LocalFree( __lpwszErr );                    \
    }                                               \
}                                               

#else
#define TRACE0(Z)
#define TRACE1(Y,Z)  
#define TRACE2(X,Y,Z)
#define TRACE3(W,X,Y,Z)
#define TRACE4(V,W,X,Y,Z)
#define TRACE5(U,V,W,X,Y,Z)
#define TRACEW0(Z)            
#define TraceEnter(X) 
#define TraceLeave(X)
#define TraceError(x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\rwlock.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\ipmlock.h

Abstract:

    Reader Writer lock primitives for the IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

//
// Need to include "debug.h" before this file is included because
// RT_LOCK is defined there
//

//
// A reader writer lock for kernel mode.
//

typedef struct _RW_LOCK
{
    RT_LOCK rlReadLock;
    RT_LOCK rlWriteLock;
    LONG    lReaderCount;
}RW_LOCK, *PRW_LOCK;

//
// VOID
// InitRwLock(
//  PRW_LOCK    pLock
//  )
//
//  Initializes the spin locks and the reader count
//


#define InitRwLock(l)                                           \
    RtInitializeSpinLock(&((l)->rlReadLock));                   \
    RtInitializeSpinLock(&((l)->rlWriteLock));                  \
    (l)->lReaderCount = 0
        
//
// VOID
// EnterReader(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql 
//  )
//
// Acquires the Reader Spinlock (now thread is at DPC). 
// InterlockedIncrements the reader count (interlocked because the reader 
// lock is not taken when the count is decremented in ExitReader())
// If the thread is the first reader, also acquires the Writer Spinlock (at
// DPC to be more efficient) to block writers
// Releases the Reader Spinlock from DPC, so that it remains at DPC
// for the duration of the lock being held 
//
// If a writer is in the code, the first reader will wait on the Writer
// Spinlock and all subsequent readers will wait on the Reader Spinlock
// If a reader is in the code and is executing the EnterReader, then a new
// reader will wait for sometime on the Reader Spinlock, and then proceed
// on to the code (at DPC)
//



#define EnterReader(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

#define EnterReaderAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

//
// VOID
// ExitReader(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// InterlockedDec the reader count.
// If this is the last reader, then release the Writer Spinlock to let
// other writers in
// Otherwise, just lower the irql to what was before the lock was
// acquired.  Either way, the irql is down to original irql
//

#define ExitReader(l, q)                                        \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLock(&((l)->rlWriteLock), q);              \
    else                                                        \
        KeLowerIrql(q)

#define ExitReaderFromDpcLevel(l)                               \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock))

//
// EnterWriter(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql
//  )
//
// Acquire the reader and then the writer spin lock
// If there  are readers in the code, the first writer will wait
// on the Writer Spinlock.  All other writers will wait (with readers)
// on the Reader Spinlock
// If there is a writer in the code then a new writer will wait on 
// the Reader Spinlock

#define EnterWriter(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))

#define EnterWriterAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))


//
// ExitWriter(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// Release both the locks
//

#define ExitWriter(l, q)                                        \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLock(&((l)->rlReadLock), q)


#define ExitWriterFromDpcLevel(l)                               \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\send.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ipinip\send.h

Abstract:

    Function prototypes for send.c

Revision History:

    AmritanR

--*/


NDIS_STATUS
IpIpSend(
    VOID            *pvContext,
    NDIS_PACKET     **ppPacketArray,
    UINT            uiNumPackets,
    DWORD           dwDest,
    RouteCacheEntry *pRce,
    PVOID           pvLinkContext
    );

VOID
IpIpDelayedSend(
    PVOID   pvContext
    );


VOID
IpIpTransmit(
    PTUNNEL     pTunnel,
    BOOLEAN     bFromWorker
    );

VOID
IpIpInvalidateRce(
    PVOID           pvContext,
    RouteCacheEntry *pRce
    );


UINT
IpIpReturnPacket(
    PVOID           pARPInterfaceContext,
    PNDIS_PACKET    pPacket
    );

NDIS_STATUS
IpIpTransferData(
    PVOID        pvContext,
    NDIS_HANDLE  nhMacContext,
    UINT         uiProtoOffset,
    UINT         uiTransferOffset,
    UINT         uiTransferLength,
    PNDIS_PACKET pnpPacket,
    PUINT        puiTransferred
    );

VOID
IpIpSendComplete(
    NTSTATUS        nSendStatus,
    PTUNNEL         pTunnel,
    PNDIS_PACKET    pnpPacket,
    ULONG           ulPktLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\rcv.c ===
/*++

Copyright (c) 1995  Microsoft Corporation


Module Name:

    net\routing\ip\ipinip\rcv.c

Abstract:

    

Revision History:

    
--*/


#define __FILE_SIG__    RCV_SIG

#include "inc.h"


IP_STATUS
IpIpRcvDatagram(
    IN  PVOID       pvIpContext,
    IN  DWORD       dwDestAddr,
    IN  DWORD       dwSrcAddr,
    IN  DWORD       dwAcceptAddr,
    IN  DWORD       dwRcvAddr,
    IN  IPHeader UNALIGNED pHeader,
    IN  UINT        uiHdrLen,
    IN  IPRcvBuf    *pRcvBuf,
    IN  UINT        uiTotalLen,
    IN  BOOLEAN     bIsBCast,
    IN  BYTE        byProtocol,
    IN  IPOptInfo   *pOptInfo
    )

/*++

Routine Description

    This

Locks

    

Arguments

    pvIpContext     IP's context for the receive indication. Currently this
                    is a pointer to the source NTE
    dwDestAddr      The Destination address in the header
    dwSrcAddr       The Source Address in the header
    dwAcceptAddr    The address of the NTE which "accepted" this packet
    dwRcvAddr       The address of the NTE on which the packet was received
    pHeader         Pointer to the IP Header
    uiHdrLen        The header length
    pRcvBuf         The COMPLETE packet in an IPRcvBuf structure
    uiRcvdDataLen   The size of the received datagram
    bIsBCast        Whether the packet was a link layer broadcast
    byProtocol      The Protocol ID in the header
    pOptInfo        Pointer to Option info

Return Value

    IP_SUCCESS

--*/

{
    PTRANSFER_CONTEXT   pXferCtxt;
    PNDIS_BUFFER        pnbFirstBuffer;
    PVOID               pvData;
    PIRP                pIrp;
    IP_HEADER UNALIGNED *pInHeader, *pOutHeader;
    ULARGE_INTEGER      uliTunnelId;
    PTUNNEL             pTunnel;
    ULONG               ulOutHdrLen, ulDataLen;
    BOOLEAN             bNonUnicast;
        
    TraceEnter(RCV, "TdixReceiveIpIp");

    //
    // Get a pointer to the first buffer
    //
    
    pvData = (PVOID)(pRcvBuf->ipr_buffer);

    RtAssert(pvData);
    
    //
    // Figure out the tunnel for this receive
    // Since the transport indicates atleast 128 bytes, we can safely read out
    // the IP Header
    //

    RtAssert(uiTotalLen > sizeof(IP_HEADER));


    pOutHeader = pHeader;
    
    RtAssert(pOutHeader->byProtocol is PROTO_IPINIP);
    RtAssert(pOutHeader->byVerLen >> 4 is IP_VERSION_4);

    //
    // These defines depend upon a variable being named "uliTunnelId"
    //
    
    REMADDR     = dwSrcAddr;
    LOCALADDR   = dwDestAddr;

    //
    // Bunch of checks to make sure the packet and the handler
    // are telling us the same thing
    //
    
    RtAssert(pOutHeader->dwSrc is dwSrcAddr);
    RtAssert(pOutHeader->dwDest is dwDestAddr);

    //
    // Get a pointer to the inside header
    //
    
    ulOutHdrLen = LengthOfIPHeader(pOutHeader);
    
    pInHeader   = (IP_HEADER UNALIGNED *)((PBYTE)pOutHeader + ulOutHdrLen);

#if DBG

    //
    // The size of the inner data must be total bytes - outer header
    //
    
    ulDataLen   = ntohs(pInHeader->wLength);

    RtAssert((ulDataLen + ulOutHdrLen) is uiTotalLen);

    //
    // The outer header should also give a good length
    //

    ulDataLen   = ntohs(pOutHeader->wLength);

    //
    // Data length and bytes available must match
    //
    
    RtAssert(ulDataLen is uiTotalLen);
    
#endif
    
    //
    // Find the TUNNEL. We need to acquire the tunnel list lock
    //
    
    EnterReaderAtDpcLevel(&g_rwlTunnelLock);
    
    pTunnel = FindTunnel(&uliTunnelId);

    ExitReaderFromDpcLevel(&g_rwlTunnelLock);
    
    if(pTunnel is NULL)
    {
        Trace(RCV, WARN, 
              ("TdixReceiveIpIp: Couldnt find tunnel for %d.%d.%d.%d/%d.%d.%d.%d\n",
              PRINT_IPADDR(REMADDR),
              PRINT_IPADDR(LOCALADDR)));

        //
        // Could not find a matching tunnel
        //

        TraceLeave(RCV, "TdixReceiveIpIp");

        //
        // Return a code that will cause IP to send the right ICMP message
        //
        
        return IP_DEST_PROT_UNREACHABLE;;
    }

    //
    // Ok, so we have the tunnel and it is ref counted and locked
    //
    
    //
    // The number of octets received
    //
    
    pTunnel->ulInOctets += ulBytesAvailable;

    //
    // Check the actual (inside) destination
    //
    
    if(IsUnicastAddr(pInHeader->dwDest))
    {
        //
        // TODO: should we check to see that the address is not 0.0.0.0?
        //
        
        pTunnel->ulInUniPkts++;

        bNonUnicast = FALSE;
    }
    else
    {
        pTunnel->ulInNonUniPkts++;
        
        if(IsClassEAddr(pInHeader->dwDest))
        {
            //
            // Bad address - throw it away
            //
            
            pTunnel->ulInErrors++;

            //
            // Releaselock, free buffer chain
            //
            
        }
        
        bNonUnicast = TRUE;
    }

    //
    // If the tunnel is non operational yet we are getting packets, means
    // it probably should be made operational
    //

    RtAssert(pTunnel->dwOperState is MIB_IF_OPER_STATUS_OPERATIONAL);

    if((pTunnel->dwAdminState isnot MIB_IF_ADMIN_STATUS_UP) or
       (pTunnel->dwOperState isnot MIB_IF_OPER_STATUS_OPERATIONAL))
    {
        Trace(RCV, WARN,
              ("TdixReceiveIpIp: Tunnel %x is not up\n",
               pTunnel));

        pTunnel->ulInDiscards++;

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

        DereferenceTunnel(pTunnel);

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // Allocate a transfer context 
    //

    pXferCtxt = AllocateTransferContext();

    if(pXferCtxt is NULL)
    {
        Trace(RCV, ERROR,
              ("TdixReceiveIpIp: Couldnt allocate transfer context\n"));

        //
        // Could not allocate context, free the data, unlock and deref
        // the tunnel
        //

        pTunnel->ulInDiscards++;

        RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));
        
        DereferenceTunnel(pTunnel);

        TraceLeave(RCV, "TdixReceiveIpIp");

        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // Ok, all statistics are done.
    // Release the lock on the tunnel
    //

    RtReleaseSpinLockFromDpcLevel(&(pTunnel->rlLock));

    
    //
    // Fill in the read-datagram context with the information that won't
    // otherwise be available in the completion routine.
    //
    
    pXferCtxt->pTunnel       = pTunnel;
    pXferCtxt->pRcvBuf       = pRcvBuf;
    pXferCtxt->uiTotalLen    = uiTotalLen;
    pXferCtxt->ulProtoOffset = ulOutHdrLen;
    
    
    //
    // The data starts at pInHeader
    // We indicate the only the first buffer to IP which means
    // (ulFirstBufLen - outer header length) bytes
    // The total data is the (ulTotalLen - outer header)
    // We associate a TRANSFER_CONTEXT with this indication,
    // The Protocol Offset is just our outer header
    // 

    g_pfnIPRcv(pTunnel->pvIpContext,
               pInHeader,
               ulFirstBufLen - ulOutHdrLen,
               ulTotalLen - ulOutHdrLen,
               pXferCtxt,
               ulOutHdrLen,
               bNonUnicast);

    //
    // Deref the tunnel (finally)
    //

    DereferenceTunnel(pTunnel);
    
    TraceLeave(RCV, "TdixReceiveIpIp");

    return STATUS_SUCCESS;
}


NDIS_STATUS
IpIpTransferData(
    PVOID        pvContext,
    NDIS_HANDLE  nhMacContext,
    UINT         uiProtoOffset,
    UINT         uiTransferOffset,
    UINT         uiTransferLength,
    PNDIS_PACKET pnpPacket,
    PUINT        puiTransferred
    )

/*++

Routine Description


Locks


Arguments


Return Value

    NO_ERROR

--*/

{
    PTRANSFER_CONTEXT    pXferCtxt;

    TraceEnter(SEND, "IpIpTransferData");

    pXferCtxt = (PTRANSFER_CONTEXT)nhMacContext;
    
    RtAssert(pXferCtxt->pTunnel is pvContext);
    RtAssert(pXferCtxt->ulProtoOffset is uiProtoOffset);
    
    //
    // Should not be asking to transfer more than was indicated
    // Since the transfer will start at and offset of
    // uiProtoOffset + uiTransferOffset, the following should hold
    //
    
    RtAssert((pXferContext->uiTotalLen - uiProtoOffset - uiTransferOffset) >=
             uiTransferLength);

    //
    // Copy the data from the RCV buffer to the given NDIS_BUFFER
    //
   
    *puiTransferred = CopyRcvBufferToNdisBuffer(pXferCtxt->pRcvBuf,
                                                pnbFirstBuffer,
                                                uiTransferLength,
                                                uiProtoOffset + uiTransferOffset,
                                                uiTransferOffset);

    
    TraceLeave(SEND, "IpIpTransferData");

    return NDIS_STATUS_PENDING;
}


uint
CopyRcvBufferToNdisBuffer(
    IN      IPRcvBuf     *pRcvBuffer,
    IN OUT  PNDIS_BUFFER pnbNdisBuffer,
    IN      uint         Size,
    IN      uint         RcvBufferOffset,
    IN      uint         NdisBufferOffset
    )
{
    uint    TotalBytesCopied = 0;   // Bytes we've copied so far.
    uint    BytesCopied = 0;        // Bytes copied out of each buffer.
    uint    DestSize, RcvSize;      // Size left in current destination and
                                    // recv. buffers, respectively.
    uint    BytesToCopy;            // How many bytes to copy this time.
    NTSTATUS Status;


    RtAssert(RcvBuf != NULL);

    RtAssert(RcvOffset <= RcvBuf->ipr_size);

    //
    // The destination buffer can be NULL - this is valid, if odd.
    //
    
    if(pnbDestBuf != NULL)
    {
    }
    
    RcvSize  = RcvBuf->ipr_size - RcvOffset;
    DestSize = NdisBufferLength(DestBuf);
    
    if (Size < DestSize)
    {
        DestSize = Size;
    }
    
    do
    {
        //
        // Compute the amount to copy, and then copy from the
        // appropriate offsets.
        
        BytesToCopy = MIN(DestSize, RcvSize);
        
        Status = TdiCopyBufferToMdl(RcvBuf->ipr_buffer,
                                    RcvOffset,
                                    BytesToCopy,
                                    DestBuf,
                                    DestOffset,
                                    &BytesCopied);

        if (!NT_SUCCESS(Status))
        {
            break;
        }

        RtAssert(BytesCopied == BytesToCopy);

        TotalBytesCopied += BytesCopied;
        DestSize -= BytesCopied;
        DestOffset += BytesCopied;
        RcvSize -= BytesToCopy;

        if (!RcvSize)
        {
            //
            // Exhausted this buffer.

            RcvBuf = RcvBuf->ipr_next;

            //
            // If we have another one, use it.
            //
            
            if (RcvBuf != NULL)
            {
                RcvOffset = 0;
                RcvSize = RcvBuf->ipr_size;
            }
            else
            {
                break;
            }
        }
        else
        {
            //
            // Buffer not exhausted, update offset.
            //

            RcvOffset += BytesToCopy;
        }

    }while (DestSize);

    return TotalBytesCopied;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\mibfuncs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\mcastmib\defs.h

Abstract:

    IP Multicast MIB instrumentation callbacks

Revision history:

    Dave Thaler         4/17/98  Created

--*/

#ifndef _MIBFUNCS_H_
#define _MIBFUNCS_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// global group                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_global(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_global {
    AsnAny ipMRouteEnable;        
} buf_global;

#define gf_ipMRouteEnable                 get_global
#define gb_ipMRouteEnable                 buf_global

UINT
get_ipMRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ipMRouteEntry {
    AsnAny ipMRouteGroup;
    AsnAny ipMRouteSource;
    AsnAny ipMRouteSourceMask;
    AsnAny ipMRouteUpstreamNeighbor;                         
    AsnAny ipMRouteInIfIndex;                         
    AsnAny ipMRouteUpTime;                  
    AsnAny ipMRouteExpiryTime;
    AsnAny ipMRoutePkts;
    AsnAny ipMRouteDifferentInIfPackets;
    AsnAny ipMRouteOctets;
    AsnAny ipMRouteProtocol;
    AsnAny ipMRouteRtProto;
    AsnAny ipMRouteRtAddress;
    AsnAny ipMRouteRtMask;

    // Buffers for IP address objects above
    DWORD  dwIpMRouteGroupInfo;
    DWORD  dwIpMRouteSourceInfo;
    DWORD  dwIpMRouteSourceMaskInfo;
    DWORD  dwIpMRouteUpstreamNeighborInfo;
    DWORD  dwIpMRouteRtAddressInfo;
    DWORD  dwIpMRouteRtMaskInfo;
} buf_ipMRouteEntry;

#define gf_ipMRouteUpstreamNeighbor                 get_ipMRouteEntry
#define gf_ipMRouteInIfIndex                        get_ipMRouteEntry
#define gf_ipMRouteUpTime                           get_ipMRouteEntry
#define gf_ipMRouteExpiryTime                       get_ipMRouteEntry
#define gf_ipMRoutePkts                             get_ipMRouteEntry
#define gf_ipMRouteDifferentInIfPackets             get_ipMRouteEntry
#define gf_ipMRouteOctets                           get_ipMRouteEntry
#define gf_ipMRouteProtocol                         get_ipMRouteEntry
#define gf_ipMRouteRtProto                          get_ipMRouteEntry
#define gf_ipMRouteRtAddress                        get_ipMRouteEntry
#define gf_ipMRouteRtMask                           get_ipMRouteEntry

#define gb_ipMRouteGroup                            buf_ipMRouteEntry
#define gb_ipMRouteSource                           buf_ipMRouteEntry
#define gb_ipMRouteSourceMask                       buf_ipMRouteEntry
#define gb_ipMRouteUpstreamNeighbor                 buf_ipMRouteEntry
#define gb_ipMRouteInIfIndex                        buf_ipMRouteEntry
#define gb_ipMRouteUpTime                           buf_ipMRouteEntry
#define gb_ipMRouteExpiryTime                       buf_ipMRouteEntry
#define gb_ipMRoutePkts                             buf_ipMRouteEntry
#define gb_ipMRouteDifferentInIfPackets             buf_ipMRouteEntry
#define gb_ipMRouteOctets                           buf_ipMRouteEntry
#define gb_ipMRouteProtocol                         buf_ipMRouteEntry
#define gb_ipMRouteRtProto                          buf_ipMRouteEntry
#define gb_ipMRouteRtAddress                        buf_ipMRouteEntry
#define gb_ipMRouteRtMask                           buf_ipMRouteEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ipMRouteNextHopEntry table                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ipMRouteNextHopEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ipMRouteNextHopEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ipMRouteNextHopEntry {
    AsnAny ipMRouteNextHopGroup;
    AsnAny ipMRouteNextHopSource;
    AsnAny ipMRouteNextHopSourceMask;
    AsnAny ipMRouteNextHopIfIndex;
    AsnAny ipMRouteNextHopAddress;

    AsnAny ipMRouteNextHopState;                  
    AsnAny ipMRouteNextHopUpTime;                 
    AsnAny ipMRouteNextHopExpiryTime;             
#ifdef CLOSEST_MEMBER_HOPS
    AsnAny ipMRouteNextHopClosestMemberHops;             
#endif
    AsnAny ipMRouteNextHopProtocol;             
    AsnAny ipMRouteNextHopPkts;             

    // Buffers for IP Address objects above
    DWORD  dwIpMRouteNextHopGroupInfo;
    DWORD  dwIpMRouteNextHopSourceInfo;
    DWORD  dwIpMRouteNextHopSourceMaskInfo;
    DWORD  dwIpMRouteNextHopAddressInfo;
} buf_ipMRouteNextHopEntry;

typedef struct _sav_ipMRouteNextHopEntry {
    AsnAny ipMRouteNextHopState;                  
    AsnAny ipMRouteNextHopUpTime;                 
    AsnAny ipMRouteNextHopExpiryTime;             
#ifdef CLOSEST_MEMBER_HOPS
    AsnAny ipMRouteNextHopClosestMemberHops;             
#endif
    AsnAny ipMRouteNextHopProtocol;             
    AsnAny ipMRouteNextHopPkts;             
} sav_ipMRouteNextHopEntry;

#define gf_ipMRouteNextHopState                 get_ipMRouteNextHopEntry
#define gf_ipMRouteNextHopUpTime                get_ipMRouteNextHopEntry
#define gf_ipMRouteNextHopExpiryTime            get_ipMRouteNextHopEntry
#ifdef CLOSEST_MEMBER_HOPS
#define gf_ipMRouteNextHopClosestMemberHops     get_ipMRouteNextHopEntry
#endif
#define gf_ipMRouteNextHopProtocol              get_ipMRouteNextHopEntry
#define gf_ipMRouteNextHopPkts                  get_ipMRouteNextHopEntry

#define gb_ipMRouteNextHopGroup                 buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopSource                buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopSourceMask            buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopIfIndex               buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopAddress               buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopState                 buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopUpTime                buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopExpiryTime            buf_ipMRouteNextHopEntry
#ifdef CLOSEST_MEMBER_HOPS
#define gb_ipMRouteNextHopClosestMemberHops     buf_ipMRouteNextHopEntry
#endif
#define gb_ipMRouteNextHopProtocol              buf_ipMRouteNextHopEntry
#define gb_ipMRouteNextHopPkts                  buf_ipMRouteNextHopEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ipMRouteInterfaceEntry table                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ipMRouteInterfaceEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ipMRouteInterfaceEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ipMRouteInterfaceEntry {
    AsnAny ipMRouteInterfaceIfIndex;
    AsnAny ipMRouteInterfaceTtl;
    AsnAny ipMRouteInterfaceProtocol;
    AsnAny ipMRouteInterfaceRateLimit;
    AsnAny ipMRouteInterfaceInMcastOctets;
    AsnAny ipMRouteInterfaceOutMcastOctets;
} buf_ipMRouteInterfaceEntry;

typedef struct _sav_ipMRouteInterfaceEntry {
    AsnAny ipMRouteInterfaceIfIndex;
    AsnAny ipMRouteInterfaceTtl;
    AsnAny ipMRouteInterfaceProtocol;
    AsnAny ipMRouteInterfaceRateLimit;
} sav_ipMRouteInterfaceEntry;
                        
#define gf_ipMRouteInterfaceIfIndex         get_ipMRouteInterfaceEntry
#define gf_ipMRouteInterfaceTtl             get_ipMRouteInterfaceEntry
#define gf_ipMRouteInterfaceProtocol        get_ipMRouteInterfaceEntry
#define gf_ipMRouteInterfaceRateLimit       get_ipMRouteInterfaceEntry
#define gf_ipMRouteInterfaceInMcastOctets   get_ipMRouteInterfaceEntry
#define gf_ipMRouteInterfaceOutMcastOctets  get_ipMRouteInterfaceEntry

#define gb_ipMRouteInterfaceIfIndex         buf_ipMRouteInterfaceEntry
#define gb_ipMRouteInterfaceTtl             buf_ipMRouteInterfaceEntry
#define gb_ipMRouteInterfaceProtocol        buf_ipMRouteInterfaceEntry
#define gb_ipMRouteInterfaceRateLimit       buf_ipMRouteInterfaceEntry
#define gb_ipMRouteInterfaceInMcastOctets   buf_ipMRouteInterfaceEntry
#define gb_ipMRouteInterfaceOutMcastOctets  buf_ipMRouteInterfaceEntry

#define sf_ipMRouteInterfaceIfIndex         set_ipMRouteInterfaceEntry
#define sf_ipMRouteInterfaceTtl             set_ipMRouteInterfaceEntry
#define sf_ipMRouteInterfaceProtocol        set_ipMRouteInterfaceEntry
#define sf_ipMRouteInterfaceRateLimit       set_ipMRouteInterfaceEntry

#define sb_ipMRouteInterfaceIfIndex         sav_ipMRouteInterfaceEntry
#define sb_ipMRouteInterfaceTtl             sav_ipMRouteInterfaceEntry
#define sb_ipMRouteInterfaceProtocol        sav_ipMRouteInterfaceEntry
#define sb_ipMRouteInterfaceRateLimit       sav_ipMRouteInterfaceEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ipMRouteBoundaryEntry table                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ipMRouteBoundaryEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ipMRouteBoundaryEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ipMRouteBoundaryEntry {
    AsnAny ipMRouteBoundaryIfIndex;
    AsnAny ipMRouteBoundaryAddress;
    AsnAny ipMRouteBoundaryAddressMask;
    AsnAny ipMRouteBoundaryStatus;

    // Buffers for IP address objects above
    DWORD  dwIpMRouteBoundaryAddressInfo;
    DWORD  dwIpMRouteBoundaryAddressMaskInfo;
} buf_ipMRouteBoundaryEntry;

typedef struct _sav_ipMRouteBoundaryEntry {
    // Index terms
    AsnAny ipMRouteBoundaryIfIndex;
    AsnAny ipMRouteBoundaryAddress;
    AsnAny ipMRouteBoundaryAddressMask;

    // Writable objects
    AsnAny ipMRouteBoundaryStatus;
} sav_ipMRouteBoundaryEntry;

#define gf_ipMRouteBoundaryStatus               get_ipMRouteBoundaryEntry

#define gb_ipMRouteBoundaryIfIndex              buf_ipMRouteBoundaryEntry
#define gb_ipMRouteBoundaryAddress              buf_ipMRouteBoundaryEntry
#define gb_ipMRouteBoundaryAddressMask          buf_ipMRouteBoundaryEntry
#define gb_ipMRouteBoundaryStatus               buf_ipMRouteBoundaryEntry

#define sf_ipMRouteBoundaryStatus               set_ipMRouteBoundaryEntry

#define sb_ipMRouteBoundaryIfIndex              sav_ipMRouteBoundaryEntry
#define sb_ipMRouteBoundaryAddress              sav_ipMRouteBoundaryEntry
#define sb_ipMRouteBoundaryAddressMask          sav_ipMRouteBoundaryEntry
#define sb_ipMRouteBoundaryStatus               sav_ipMRouteBoundaryEntry

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ipMRouteScopeEntry table                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
get_ipMRouteScopeEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

UINT
set_ipMRouteScopeEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    );

typedef struct _buf_ipMRouteScopeEntry {
    AsnAny ipMRouteScopeAddress;
    AsnAny ipMRouteScopeAddressMask;
    AsnAny ipMRouteScopeName;
    AsnAny ipMRouteScopeStatus;

    // Buffers for IP address and string objects above
    DWORD  dwIpMRouteScopeAddressInfo;
    DWORD  dwIpMRouteScopeAddressMaskInfo;
    BYTE   rgbyScopeNameInfo[MAX_SCOPE_NAME_LEN+1];
} buf_ipMRouteScopeEntry;

typedef struct _sav_ipMRouteScopeEntry {
    // Index terms
    AsnAny ipMRouteScopeAddress;
    AsnAny ipMRouteScopeAddressMask;

    // Writable objects
    AsnAny ipMRouteScopeName;
    AsnAny ipMRouteScopeStatus;

    // Buffers
    BYTE   rgbyScopeNameInfo[MAX_SCOPE_NAME_LEN+1];
} sav_ipMRouteScopeEntry;

#define gf_ipMRouteScopeName                 get_ipMRouteScopeEntry
#define gf_ipMRouteScopeStatus               get_ipMRouteScopeEntry

#define gb_ipMRouteScopeAddress              buf_ipMRouteScopeEntry
#define gb_ipMRouteScopeAddressMask          buf_ipMRouteScopeEntry
#define gb_ipMRouteScopeName                 buf_ipMRouteScopeEntry
#define gb_ipMRouteScopeStatus               buf_ipMRouteScopeEntry

#define sf_ipMRouteScopeName                 set_ipMRouteScopeEntry
#define sf_ipMRouteScopeStatus               set_ipMRouteScopeEntry

#define sb_ipMRouteScopeAddress              sav_ipMRouteScopeEntry
#define sb_ipMRouteScopeAddressMask          sav_ipMRouteScopeEntry
#define sb_ipMRouteScopeName                 sav_ipMRouteScopeEntry
#define sb_ipMRouteScopeStatus               sav_ipMRouteScopeEntry

#endif // _MIBFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\mibentry.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\mcastmib\mibentry.c

Abstract:

    IP Multicast MIB structures

Revision history:

    Dave Thaler         4/17/98  Created

--*/

#include "precomp.h"

static UINT ids_multicast[] = {1,3,6,1,3,60,1,1};

static UINT ids_ipMRouteEnable[]                      = {1,0};

static UINT ids_ipMRouteTable[]                       = {2};
static UINT ids_ipMRouteEntry[]                       = {2,1};
static UINT ids_ipMRouteGroup[]                       = {2,1,1};
static UINT ids_ipMRouteSource[]                      = {2,1,2};
static UINT ids_ipMRouteSourceMask[]                  = {2,1,3};
static UINT ids_ipMRouteUpstreamNeighbor[]            = {2,1,4};
static UINT ids_ipMRouteInIfIndex[]                   = {2,1,5};
static UINT ids_ipMRouteUpTime[]                      = {2,1,6};
static UINT ids_ipMRouteExpiryTime[]                  = {2,1,7};
static UINT ids_ipMRoutePkts[]                        = {2,1,8};
static UINT ids_ipMRouteDifferentInIfPackets[]        = {2,1,9};
static UINT ids_ipMRouteOctets[]                      = {2,1,10};
static UINT ids_ipMRouteProtocol[]                    = {2,1,11};
static UINT ids_ipMRouteRtProto[]                     = {2,1,12};
static UINT ids_ipMRouteRtAddress[]                   = {2,1,13};
static UINT ids_ipMRouteRtMask[]                      = {2,1,14};

static UINT ids_ipMRouteNextHopTable[]                = {3};
static UINT ids_ipMRouteNextHopEntry[]                = {3,1};
static UINT ids_ipMRouteNextHopGroup[]                = {3,1,1};
static UINT ids_ipMRouteNextHopSource[]               = {3,1,2};
static UINT ids_ipMRouteNextHopSourceMask[]           = {3,1,3};
static UINT ids_ipMRouteNextHopIfIndex[]              = {3,1,4};
static UINT ids_ipMRouteNextHopAddress[]              = {3,1,5};
static UINT ids_ipMRouteNextHopState[]                = {3,1,6};
static UINT ids_ipMRouteNextHopUpTime[]               = {3,1,7};
static UINT ids_ipMRouteNextHopExpiryTime[]           = {3,1,8};
#ifdef CLOSEST_MEMBER_HOPS
static UINT ids_ipMRouteNextHopClosestMemberHops[]    = {3,1,9};
#endif
static UINT ids_ipMRouteNextHopProtocol[]             = {3,1,10};
static UINT ids_ipMRouteNextHopPkts[]                 = {3,1,11};

static UINT ids_ipMRouteInterfaceTable[]              = {4};
static UINT ids_ipMRouteInterfaceEntry[]              = {4,1};
static UINT ids_ipMRouteInterfaceIfIndex[]            = {4,1,1};
static UINT ids_ipMRouteInterfaceTtl[]                = {4,1,2};
static UINT ids_ipMRouteInterfaceProtocol[]           = {4,1,3};
static UINT ids_ipMRouteInterfaceRateLimit[]          = {4,1,4};
static UINT ids_ipMRouteInterfaceInMcastOctets[]      = {4,1,5};
static UINT ids_ipMRouteInterfaceOutMcastOctets[]     = {4,1,6};

static UINT ids_ipMRouteBoundaryTable[]               = {5};
static UINT ids_ipMRouteBoundaryEntry[]               = {5,1};
static UINT ids_ipMRouteBoundaryIfIndex[]             = {5,1,1};
static UINT ids_ipMRouteBoundaryAddress[]             = {5,1,2};
static UINT ids_ipMRouteBoundaryAddressMask[]         = {5,1,3};
static UINT ids_ipMRouteBoundaryStatus[]              = {5,1,4};

static UINT ids_ipMRouteScopeTable[]                  = {6};
static UINT ids_ipMRouteScopeEntry[]                  = {6,1};
static UINT ids_ipMRouteScopeAddress[]                = {6,1,1};
static UINT ids_ipMRouteScopeAddressMask[]            = {6,1,2};
static UINT ids_ipMRouteScopeName[]                   = {6,1,3};
static UINT ids_ipMRouteScopeStatus[]                 = {6,1,4};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibEntry mib_multicast[] = {
        MIB_INTEGER(ipMRouteEnable),
        MIB_TABLE_ROOT(ipMRouteTable), 
            MIB_TABLE_ENTRY(ipMRouteEntry),
                MIB_IPADDRESS_NA(ipMRouteGroup),
                MIB_IPADDRESS_NA(ipMRouteSource),
                MIB_IPADDRESS_NA(ipMRouteSourceMask),
                MIB_IPADDRESS(ipMRouteUpstreamNeighbor),
                MIB_INTEGER(ipMRouteInIfIndex), 
                MIB_TIMETICKS(ipMRouteUpTime),
                MIB_TIMETICKS(ipMRouteExpiryTime),
                MIB_COUNTER(ipMRoutePkts),
                MIB_COUNTER(ipMRouteDifferentInIfPackets),
                MIB_COUNTER(ipMRouteOctets),
                MIB_INTEGER(ipMRouteProtocol), 
                MIB_INTEGER(ipMRouteRtProto), 
                MIB_IPADDRESS(ipMRouteRtAddress), 
                MIB_IPADDRESS(ipMRouteRtMask), 
        MIB_TABLE_ROOT(ipMRouteNextHopTable), 
            MIB_TABLE_ENTRY(ipMRouteNextHopEntry),
                MIB_IPADDRESS_NA(ipMRouteNextHopGroup),
                MIB_IPADDRESS_NA(ipMRouteNextHopSource),
                MIB_IPADDRESS_NA(ipMRouteNextHopSourceMask),
                MIB_INTEGER_NA(ipMRouteNextHopIfIndex), 
                MIB_IPADDRESS_NA(ipMRouteNextHopAddress),
                MIB_INTEGER(ipMRouteNextHopState), 
                MIB_TIMETICKS(ipMRouteNextHopUpTime),
                MIB_TIMETICKS(ipMRouteNextHopExpiryTime),
#ifdef CLOSEST_MEMBER_HOPS
                MIB_INTEGER(ipMRouteNextHopClosestMemberHops), 
#endif
                MIB_INTEGER(ipMRouteNextHopProtocol), 
                MIB_COUNTER(ipMRouteNextHopPkts), 
        MIB_TABLE_ROOT(ipMRouteInterfaceTable), 
            MIB_TABLE_ENTRY(ipMRouteInterfaceEntry),
                MIB_INTEGER_NA(ipMRouteInterfaceIfIndex), 
                MIB_INTEGER(ipMRouteInterfaceTtl), 
                MIB_INTEGER(ipMRouteInterfaceProtocol), 
                MIB_INTEGER(ipMRouteInterfaceRateLimit), 
                MIB_COUNTER(ipMRouteInterfaceInMcastOctets), 
                MIB_COUNTER(ipMRouteInterfaceOutMcastOctets), 
        MIB_TABLE_ROOT(ipMRouteBoundaryTable),
            MIB_TABLE_ENTRY(ipMRouteBoundaryEntry),
                MIB_INTEGER_AC(ipMRouteBoundaryIfIndex), 
                MIB_IPADDRESS_AC(ipMRouteBoundaryAddress),
                MIB_IPADDRESS_AC(ipMRouteBoundaryAddressMask),
                MIB_INTEGER_RW(ipMRouteBoundaryStatus),
        MIB_TABLE_ROOT(ipMRouteScopeTable),
            MIB_TABLE_ENTRY(ipMRouteScopeEntry),
                MIB_IPADDRESS_AC(ipMRouteScopeAddress),
                MIB_IPADDRESS_AC(ipMRouteScopeAddressMask),
                MIB_DISPSTRING_RW_L(ipMRouteScopeName,0,255),
                MIB_INTEGER_RW(ipMRouteScopeStatus),

    MIB_END()
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry list                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibTable tbl_multicast[] = {
    MIB_TABLE(multicast,ipMRouteEntry,         NULL),
    MIB_TABLE(multicast,ipMRouteNextHopEntry,  NULL),
    MIB_TABLE(multicast,ipMRouteInterfaceEntry,NULL),
    MIB_TABLE(multicast,ipMRouteBoundaryEntry, NULL),
    MIB_TABLE(multicast,ipMRouteScopeEntry,    NULL)
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib view                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpMibView v_multicast = MIB_VIEW(multicast);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\cache.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    cache.h

Abstract:

    This module contains declarations for a simple cache system.
    Cache entries are stored as void pointers with 32-bit keys.

Author:

    Abolade Gbadegesin (aboladeg)   19-Feb-1998

Revision History:

--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#define CACHE_SHIFT     4
#define CACHE_SIZE      (1 << (8 - CACHE_SHIFT))
#define CACHE_INDEX(k)  ((unsigned char)(k) & (0xFF >> CACHE_SHIFT))

typedef struct _CACHE_ENTRY {
    unsigned long Key;
    void* Value;
    long Hits;
    long Misses;
} CACHE_ENTRY, *PCACHE_ENTRY;


__inline
void
InitializeCache(
    CACHE_ENTRY Cache[]
    )
{
    memset(Cache, 0, CACHE_SIZE * sizeof(CACHE_ENTRY));
}

__inline
void
ClearCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    Cache[Index].Key = 0;
    Cache[Index].Value = 0;
    Cache[Index].Hits = 0;
    Cache[Index].Misses = 0;
}


__inline
void*
ProbeCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key) {
        Cache[Index].Hits++;
        return Cache[Index].Value;
    }
    Cache[Index].Misses++;
    return NULL;
}

__inline
int
UpdateCache(
    CACHE_ENTRY Cache[],
    unsigned long Key,
    void* Value
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key ||
        Cache[Index].Hits >=
            (Cache[Index].Misses - (Cache[Index].Misses >> 2))) { return 0; }
    Cache[Index].Key = Key;
    Cache[Index].Value = Value;
    Cache[Index].Hits = 0;
    Cache[Index].Misses = 0;
    return 1;
}


__inline
void
InterlockedClearCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    InterlockedExchange(&Cache[Index].Key, 0);
    InterlockedExchangePointer(&Cache[Index].Value, 0);
    InterlockedExchange(&Cache[Index].Hits, 0);
    InterlockedExchange(&Cache[Index].Misses, 0);
}


__inline
void*
InterlockedProbeCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key) {
        InterlockedIncrement(&Cache[Index].Hits);
        return Cache[Index].Value;
    }
    InterlockedIncrement(&Cache[Index].Misses);
    return NULL;
}

__inline
int
InterlockedUpdateCache(
    CACHE_ENTRY Cache[],
    unsigned long Key,
    void* Value
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key ||
        Cache[Index].Hits >=
            (Cache[Index].Misses - (Cache[Index].Misses >> 2))) { return 0; }
    InterlockedExchange(&Cache[Index].Key, Key);
    InterlockedExchangePointer(&Cache[Index].Value, Value);
    InterlockedExchange(&Cache[Index].Hits, 0);
    InterlockedExchange(&Cache[Index].Misses, 0);
    return 1;
}

#endif // _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\precomp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\mcastmib\precomp.h

Abstract:

    Precompiled header for the IP Multicast MIB subagent

Revision history:

    Dave Thaler         4/17/98  Created

--*/

#ifndef __PRECOMP_H__
#define __PRECOMP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <crt\stddef.h>
#include <TCHAR.H>
#include <winsock2.h>
#include <snmp.h>
#include <snmpexts.h>
#include <mprapi.h>
#include <routprot.h>
#include <iprtrmib.h>
#include <rtm.h>
#include <ddipmcst.h> // reqd by mgm.h
#include <mgm.h>

#if defined( MIB_DEBUG )

#include <rtutils.h>
extern DWORD   g_dwTraceId;

#endif

#include "mibentry.h"
#include "mibfuncs.h"
#include "defs.h"

extern      MIB_SERVER_HANDLE       g_hMIBServer;
extern      CRITICAL_SECTION        g_CS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\mibfuncs.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\mcastmib\mibfuncs.c

Abstract:

    IP Multicast MIB instrumentation callbacks

Revision history:

    Dave Thaler         4/17/98  Created

--*/

#include    "precomp.h"
#pragma     hdrstop

//
// Define this to report a dummy MFE
//
#undef SAMPLE_MFE

#define ROWSTATUS_ACTIVE 1

DWORD
ConnectToRouter();

DWORD
SetGlobalInfo(
    IN  AsnAny *                        objectArray
);

DWORD
GetMibInfo( 
    IN  UINT                            actionId,
    IN  PMIB_OPAQUE_QUERY               pQuery,
    IN  DWORD     dwQuerySize,
    OUT PMIB_OPAQUE_INFO          *     ppimgod,
    OUT PDWORD                          pdwOutSize
);

//
// IP Multicast MIB scalar objects
//

UINT
get_global(
    UINT     actionId,
    AsnAny  *objectArray,
    UINT    *errorIndex
    )
{
    DWORD               dwErr = ERROR_NOT_FOUND;
    DWORD               dwNumEntries = 1;
    PMIB_IPMCAST_GLOBAL pEntry;
    buf_global         *pOutput;
    PMIB_OPAQUE_INFO    pRpcInfo = NULL;
    DWORD               dwOutBufferSize = 0;
    MIB_OPAQUE_QUERY    pQueryBuff, *pQuery = &pQueryBuff;
    DWORD               dwQuerySize;

    TraceEnter("get_global");
    pOutput = (buf_global*)objectArray;

    pQuery->dwVarId       = MCAST_GLOBAL;
    dwQuerySize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);

    dwErr = GetMibInfo(actionId, pQuery, dwQuerySize,
                       &pRpcInfo, &dwOutBufferSize);
    if (dwErr != NO_ERROR) {
        TraceError(dwErr);
        return dwErr;
    }

    pEntry = (PMIB_IPMCAST_GLOBAL) pRpcInfo->rgbyData;

    SetAsnInteger(&(pOutput->ipMRouteEnable), pEntry->dwEnable); 

    if (pRpcInfo)
        MprAdminMIBBufferFree(pRpcInfo);

    TraceLeave("get_global");
    return MIB_S_SUCCESS;
}

//
// IP Multicast Interface Table support
//
// We cache the fields which are static config info (such as protocol)
// so that queries that access only these rows can consult the cache
// rather than forcing a call to the router manager, kernel diving, etc.
//

typedef struct {
    DWORD dwIfIndex;   // interface to which this info applies
    DWORD dwProtocol;  // multicast protocol owning that interface
    DWORD dwTimestamp; // time at which above info was obtained
} MCAST_IF_CONFIG;

#define CACHE_SIZE 100 // number of interfaces to cache
MCAST_IF_CONFIG *cacheArray[CACHE_SIZE];

static int
GetCacheIdx(dwIfIndex)
    DWORD dwIfIndex;
{
    register int i;

    for (i=0; i<CACHE_SIZE; i++)
       if (cacheArray[i] && cacheArray[i]->dwIfIndex==dwIfIndex)
          return i;
    return -1;
}

static void
UpdateCacheInterfaceConfig(dwCacheIdx, newIfConfig)
    DWORD            dwCacheIdx;
    MCAST_IF_CONFIG *newIfConfig;
{
    // Free the old one
    if (cacheArray[dwCacheIdx])
        MULTICAST_MIB_FREE( cacheArray[dwCacheIdx] );

    // Store the new one
    cacheArray[dwCacheIdx] = newIfConfig;
}


static void
AddCacheInterfaceConfig(pIfConfig)
    MCAST_IF_CONFIG *pIfConfig;
{
    register int i, best = -1;

    // Find empty or oldest spot
    for (i=0; i<CACHE_SIZE; i++) {
       if (!cacheArray[i]) {
          best=i;
          break;
       }
       if (best<0 || cacheArray[i]->dwTimestamp < cacheArray[best]->dwTimestamp)
          best=i;
    }
    
    UpdateCacheInterfaceConfig(best, pIfConfig);
}

static MCAST_IF_CONFIG *
SaveInterfaceConfig(pEntry)
    PMIB_IPMCAST_IF_ENTRY pEntry;
{
    MCAST_IF_CONFIG *pIfConfig;
    int iCacheIdx;

    TRACE1("SaveInterfaceConfig %d\n", pEntry->dwIfIndex);

    pIfConfig= MULTICAST_MIB_ALLOC(sizeof(MCAST_IF_CONFIG));
    if (!pIfConfig) {
        return NULL;
    }
    pIfConfig->dwIfIndex = pEntry->dwIfIndex;
    pIfConfig->dwProtocol = pEntry->dwProtocol;
    pIfConfig->dwTimestamp = GetCurrentTime();

    iCacheIdx = GetCacheIdx(pEntry->dwIfIndex);
    if (iCacheIdx >= 0)
       UpdateCacheInterfaceConfig((DWORD)iCacheIdx, pIfConfig);
    else
       AddCacheInterfaceConfig(pIfConfig);

    return pIfConfig;
}

MCAST_IF_CONFIG *
GetInterfaceConfig(dwIfIndex)
    DWORD dwIfIndex;
{
    MCAST_IF_CONFIG            *outIfConfig = NULL;
    MCAST_IF_CONFIG            *pIfConfig;
    DWORD                       dwQuerySize;
    MIB_OPAQUE_QUERY            pQueryBuff, *pQuery = &pQueryBuff;
    DWORD                       dwErr = ERROR_NOT_FOUND;
    DWORD                       dwNumEntries = 1;
    PMIB_IPMCAST_IF_ENTRY       pEntry;
    buf_ipMRouteInterfaceEntry *pOutput;
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;
    DWORD                       dwOutBufferSize = 0;

    TRACE1("GetInterfaceConfig %d\n", dwIfIndex);

    // Do a MIB lookup 
    pQuery->dwVarId       = MCAST_IF_ENTRY;
    pQuery->rgdwVarIndex[0] = dwIfIndex;
    dwQuerySize = sizeof(MIB_OPAQUE_QUERY);

    dwErr = GetMibInfo(MIB_ACTION_GET, pQuery, dwQuerySize,
                       &pRpcInfo, &dwOutBufferSize);
   
    // Save each entry returned
    if (dwErr == NO_ERROR) {
       pEntry = (PMIB_IPMCAST_IF_ENTRY) pRpcInfo->rgbyData;
       pIfConfig = SaveInterfaceConfig(pEntry);

       if (pEntry->dwIfIndex == dwIfIndex)
          outIfConfig = pIfConfig;
    }

    // Return the saved entry which was asked for
    if (pRpcInfo)
        MprAdminMIBBufferFree(pRpcInfo);
    return outIfConfig;
}

MCAST_IF_CONFIG *
ForceGetCacheInterfaceConfig(dwIfIndex)
    DWORD dwIfIndex;
{
    MCAST_IF_CONFIG *tmpIfConfig;
    int iCacheIdx = GetCacheIdx(dwIfIndex);

    TRACE2("ForceGetCacheInterfaceConfig ifIndex=%d ci=%d\n", dwIfIndex,
        iCacheIdx);

    if (iCacheIdx >= 0 
     && GetCurrentTime() - cacheArray[iCacheIdx]->dwTimestamp 
          < IPMULTI_IF_CACHE_TIMEOUT)
       return cacheArray[iCacheIdx];

    // Service a cache miss
    tmpIfConfig = GetInterfaceConfig(dwIfIndex);
    return tmpIfConfig;
}

static DWORD
GetInterfaceProtocol(dwIfIndex)
    DWORD dwIfIndex;
{
    // Look up interface config in interface config cache
    MCAST_IF_CONFIG *pIfConfig = ForceGetCacheInterfaceConfig(dwIfIndex);

    return (pIfConfig)? pIfConfig->dwProtocol : 0;
}


UINT
get_ipMRouteInterfaceEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
/*++
Routine Description:
    Get the InterfaceEntry for IP Multicast. Have to get the InterfaceConfig 
    and InterfaceStats for the interface from the router.
--*/
{
    DWORD                       dwErr = ERROR_NOT_FOUND;
    DWORD                       dwNumEntries = 1;
    PMIB_IPMCAST_IF_ENTRY       pEntry;
    buf_ipMRouteInterfaceEntry *pOutput;
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;
    DWORD                       dwOutBufferSize = 0;
    MIB_OPAQUE_QUERY            pQueryBuff, 
                               *pQuery = &pQueryBuff;
    DWORD                       dwQuerySize;

    TraceEnter("get_ipMRouteInterfaceEntry");
    pOutput = (buf_ipMRouteInterfaceEntry*)objectArray;

    pQuery->dwVarId       = MCAST_IF_ENTRY;
    pQuery->rgdwVarIndex[0] = GetAsnInteger( &( pOutput->ipMRouteInterfaceIfIndex ), 0 );
    dwQuerySize = sizeof(MIB_OPAQUE_QUERY);

    dwErr = GetMibInfo(actionId, pQuery, dwQuerySize,
                       &pRpcInfo, &dwOutBufferSize);
    if (dwErr != NO_ERROR) {
        TraceError(dwErr);
        return ERROR_NO_MORE_ITEMS;
    }

    pEntry = (PMIB_IPMCAST_IF_ENTRY) pRpcInfo->rgbyData;

    SaveInterfaceConfig(pEntry);

    // Set index values
    ForceSetAsnInteger(&(pOutput->ipMRouteInterfaceIfIndex), pEntry->dwIfIndex);

    // Set other values
    SetAsnInteger(&(pOutput->ipMRouteInterfaceTtl), pEntry->dwTtl); 
    SetAsnInteger(&(pOutput->ipMRouteInterfaceProtocol), pEntry->dwProtocol);
    SetAsnInteger(&(pOutput->ipMRouteInterfaceRateLimit), pEntry->dwRateLimit);

    SetAsnCounter(&(pOutput->ipMRouteInterfaceInMcastOctets), 
     pEntry->ulInMcastOctets);
    SetAsnCounter(&(pOutput->ipMRouteInterfaceOutMcastOctets), 
     pEntry->ulOutMcastOctets);

    if (pRpcInfo)
        MprAdminMIBBufferFree(pRpcInfo);

    TraceLeave("get_ipMRouteInterfaceEntry");
    return MIB_S_SUCCESS;
}


//
// Multicast Forwarding Table (ipMRouteTable) support
//

UINT
get_ipMRouteEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
/*++
Routine Description:
    Get the MFE information based on the input criteria.
--*/
{
    DWORD              dwResult = ERROR_NOT_FOUND;
    DWORD              dwNumEntries = 1;
    IPMCAST_MFE        mfe;
    IPMCAST_MFE_STATS  mfeStats;
#ifdef SAMPLE_MFE
    MIB_IPMCAST_MFE_STATS sampledata;
#endif
    PMIB_IPMCAST_MFE_STATS pEntry;
    PMIB_MFE_STATS_TABLE pTable = NULL;
    PMIB_OPAQUE_INFO   pRpcInfo = NULL;
    DWORD              dwOutBufferSize = 0;
    buf_ipMRouteEntry *pOutput;
    MIB_OPAQUE_QUERY   pQueryBuff[2]; // big enough to hold 1 + extra index 
                                      // fields, so we don't have to malloc
    MIB_OPAQUE_QUERY  *pQuery = &pQueryBuff[0];
    DWORD        dwQuerySize;
    BOOL               bPart;

    TraceEnter("get_ipMRouteEntry");
    pOutput = (buf_ipMRouteEntry*)objectArray;

    pQuery->dwVarId       = MCAST_MFE_STATS;

    // Extract the instance info
    pQuery->rgdwVarIndex[0] = GetAsnIPAddress( &pOutput->ipMRouteGroup, 0 );
    pQuery->rgdwVarIndex[1] = GetAsnIPAddress( &pOutput->ipMRouteSource, 
     0xFFFFFFFF );
    pQuery->rgdwVarIndex[2] = GetAsnIPAddress( &pOutput->ipMRouteSourceMask,
     0xFFFFFFFF);

    // 
    // Fix up query if instance was partially-specified.
    // This section can go away if the SNMP API does this for us.
    //
    if (!pOutput->ipMRouteGroup.asnType
     || !pOutput->ipMRouteGroup.asnValue.string.length) {
        actionId = MIB_ACTION_GETFIRST;
    } else {
        if (!pOutput->ipMRouteSource.asnType
         || !pOutput->ipMRouteSource.asnValue.string.length) {
           if (pQuery->rgdwVarIndex[0]) {
              pQuery->rgdwVarIndex[0]--;
           } else {
              actionId = MIB_ACTION_GETFIRST;
           }
        } else {
           if (!pOutput->ipMRouteSourceMask.asnType
            || !pOutput->ipMRouteSourceMask.asnValue.string.length) {
              if (pQuery->rgdwVarIndex[1]) {
                 pQuery->rgdwVarIndex[1]--;
              } else {
                 if (pQuery->rgdwVarIndex[0]) {
                    pQuery->rgdwVarIndex[0]--;
                    pQuery->rgdwVarIndex[1] = 0xFFFFFFFF;
                 } else {
                    actionId = MIB_ACTION_GETFIRST;
                 }
              }
           }
        }
    }

    dwQuerySize = sizeof(MIB_OPAQUE_QUERY) + 2*sizeof(DWORD);

#ifndef SAMPLE_MFE
    dwResult = GetMibInfo(actionId, pQuery, dwQuerySize, 
                       &pRpcInfo, &dwOutBufferSize);
    if (dwResult != NO_ERROR) {
        TraceError(dwResult);
        return dwResult;
    }

    pTable = (PMIB_MFE_STATS_TABLE)( pRpcInfo->rgbyData);
    if (pTable->dwNumEntries == 0)
    {
       MprAdminMIBBufferFree( pRpcInfo );
       return MIB_S_NO_MORE_ENTRIES;
    }
    pEntry = pTable->table; // use first entry returned
#else
    pEntry = &sampledata;
    if (pQuery->rgdwVarIndex[0] >= 0x01010101)
       return MIB_S_NO_MORE_ENTRIES;
    sampledata.dwGroup   = 0x01010101; /* (*,G) Entry */
    sampledata.dwSource  = 0x00000000;
    sampledata.dwSrcMask = 0x00000000;
    // don't care what the other values are for this test
#endif

    // Save index terms
    ForceSetAsnIPAddress(&(pOutput->ipMRouteGroup),      
                         &(pOutput->dwIpMRouteGroupInfo),
                         pEntry->dwGroup);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteSource),    
                         &(pOutput->dwIpMRouteSourceInfo),
                         pEntry->dwSource);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteSourceMask), 
                         &(pOutput->dwIpMRouteSourceMaskInfo),
                         pEntry->dwSrcMask);

    // Save other terms
    SetAsnIPAddress(&pOutput->ipMRouteUpstreamNeighbor, 
                    &pOutput->dwIpMRouteUpstreamNeighborInfo,
                    pEntry->dwUpStrmNgbr);
    SetAsnInteger(&(pOutput->ipMRouteInIfIndex), pEntry->dwInIfIndex);
    SetAsnTimeTicks(&(pOutput->ipMRouteUpTime), pEntry->ulUpTime);
    SetAsnTimeTicks(&(pOutput->ipMRouteExpiryTime), pEntry->ulExpiryTime);
    SetAsnCounter(&(pOutput->ipMRoutePkts), pEntry->ulInPkts);
    SetAsnCounter(&(pOutput->ipMRouteDifferentInIfPackets), 
     pEntry->ulPktsDifferentIf);
    SetAsnCounter(&(pOutput->ipMRouteOctets), pEntry->ulInOctets);

    // For protocol, we'll just report the protocol owning the iif
    SetAsnInteger(&(pOutput->ipMRouteProtocol),        
       GetInterfaceProtocol(pEntry->dwInIfIndex));

    SetAsnInteger(&pOutput->ipMRouteRtProto, pEntry->dwRouteProtocol);
    SetAsnIPAddress(&pOutput->ipMRouteRtAddress, 
                    &pOutput->dwIpMRouteRtAddressInfo,
                    pEntry->dwRouteNetwork);
    SetAsnIPAddress(&pOutput->ipMRouteRtMask, 
                    &pOutput->dwIpMRouteRtMaskInfo,
                    pEntry->dwRouteMask);

    if ( pRpcInfo ) { MprAdminMIBBufferFree( pRpcInfo ); }

    TraceLeave("get_ipMRouteEntry");
    return MIB_S_SUCCESS;
}

//
// Multicast Forwarding Next Hop table (ipMRouteNextHopTable) support
//

static DWORD
LocateMfeOif(actionId, pQuery, oifIndex, oifAddress, ppEntry, ppOif,
    ppRpcInfo)
    UINT                    actionId;
    MIB_OPAQUE_QUERY       *pQuery;
    DWORD                   oifIndex;
    DWORD                   oifAddress;
    PMIB_IPMCAST_MFE_STATS *ppEntry;
    PMIB_IPMCAST_OIF_STATS *ppOif;
    PMIB_OPAQUE_INFO       *ppRpcInfo;
/*++
Routine Description:
    Get the exact/next/first oif entry based on the input criteria.
--*/
{
    DWORD                  dwResult = MIB_S_SUCCESS;
    DWORD dwQuerySize = sizeof(MIB_OPAQUE_QUERY) + 2*sizeof(DWORD);
    DWORD                  dwOutBufferSize = 0;
    PMIB_MFE_STATS_TABLE   pTable = NULL;
    PMIB_IPMCAST_MFE_STATS pEntry = NULL;
    PMIB_IPMCAST_OIF_STATS pOif = NULL;
    PMIB_OPAQUE_INFO       pRpcInfo = NULL;
    BOOL                   oifIndexAny   = FALSE;
    BOOL                   oifAddressAny = FALSE;
    DWORD                  idx;
    BOOL                   bFound;

    do {

        // Get the first MFE which applies (if any)
        dwResult = GetMibInfo(actionId, pQuery, dwQuerySize, 
                       &pRpcInfo, &dwOutBufferSize);
        if (dwResult != NO_ERROR) {
            TraceError(dwResult);
            return dwResult;
        }
        pTable = (PMIB_MFE_STATS_TABLE)( pRpcInfo->rgbyData);
        if (pTable->dwNumEntries == 0) {
           MprAdminMIBBufferFree( pRpcInfo );
           return MIB_S_NO_MORE_ENTRIES; 
        }
        pEntry = pTable->table; // use first entry returned

        // Get the first OIF which applies (if any)
        bFound=FALSE;
        for (idx=0; !bFound && idx < pEntry->ulNumOutIf; idx++) {
           pOif = &pEntry->rgmiosOutStats[idx];

           // Do processing for GET
           if (actionId==MIB_ACTION_GET) {
              if (oifIndex   == pOif->dwOutIfIndex 
               && oifAddress == pOif->dwNextHopAddr) {
                 bFound=TRUE;
                 break;
              } else
                 continue;
           }

           // Do processing for GET-NEXT 
           if ( oifIndexAny == TRUE
            ||  oifIndex  < pOif->dwOutIfIndex
            || (oifIndex == pOif->dwOutIfIndex 
                && (oifAddressAny == TRUE
                 || oifAddress < pOif->dwNextHopAddr))) {
              bFound=TRUE;
              break;
           }
        }
        if (bFound)
           break;

        // else continue and get a new entry
        pQuery->rgdwVarIndex[0] = pEntry->dwGroup;
        pQuery->rgdwVarIndex[1] = pEntry->dwSource;
        pQuery->rgdwVarIndex[2] = pEntry->dwSrcMask;
        oifAddressAny = oifIndexAny = TRUE;

    } while (actionId != MIB_ACTION_GET); // once for GET, "forever" for others

    *ppEntry   = pEntry;
    *ppOif     = pOif;
    *ppRpcInfo = pRpcInfo;
    return dwResult;
}

UINT
get_ipMRouteNextHopEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD              dwResult = ERROR_NOT_FOUND;
    DWORD              dwNumEntries = 1;
    IPMCAST_MFE        mfe;
    IPMCAST_MFE_STATS  mfeStats;
#ifdef SAMPLE_MFE
    MIB_IPMCAST_MFE_STATS sampledata;
#endif
    PMIB_IPMCAST_MFE_STATS pEntry;
    PMIB_IPMCAST_OIF_STATS pOif;
    PMIB_MFE_STATS_TABLE pTable = NULL;
    DWORD              dwOutBufferSize = 0;
    buf_ipMRouteNextHopEntry *pOutput;
    MIB_OPAQUE_QUERY   pQueryBuff[2]; // big enough to hold 1 + extra index 
                                      // fields, so we don't have to malloc
    MIB_OPAQUE_QUERY  *pQuery = &pQueryBuff[0];
    DWORD        dwQuerySize;
    DWORD        oifIndex, oifAddress;
    PMIB_OPAQUE_INFO   pRpcInfo = NULL;

    TraceEnter("get_ipMRouteNextHopEntry");
    pOutput = (buf_ipMRouteNextHopEntry*)objectArray;

    pQuery->dwVarId       = MCAST_MFE_STATS;

    // 
    // XXX Note that the 3 lines below aren't quite right, since 
    // 0-value instances will be missed.  That is (*,G) entries 
    // will be skipped!!
    //
    // Should call for a GET-FIRST if an incomplete length is given.
    // Maybe the Sfx API does this already.
    //
    // XXX hold off on changing this until Florin changes the SNMP
    // api to cover the out-of-range index case.
    // 
    pQuery->rgdwVarIndex[0] = GetAsnIPAddress( &( pOutput->ipMRouteNextHopGroup ), 0 );
    pQuery->rgdwVarIndex[1] = GetAsnIPAddress( &( pOutput->ipMRouteNextHopSource), 0 );
    pQuery->rgdwVarIndex[2] = GetAsnIPAddress( &( pOutput->ipMRouteNextHopSourceMask ), 0 );
    oifIndex   = GetAsnInteger( &(pOutput->ipMRouteNextHopIfIndex), 0);
    oifAddress = GetAsnIPAddress( &(pOutput->ipMRouteNextHopAddress), 0);

#ifndef SAMPLE_MFE
{
    dwResult = LocateMfeOif(actionId, pQuery, oifIndex, oifAddress, 
     &pEntry, &pOif, &pRpcInfo);
    if (dwResult != NO_ERROR) {
        TraceError(dwResult);
        return dwResult;
    }
}
#else
{
    pEntry = &sampledata;
    pOif   = &pEntry->rgmiosOutStats[0];
    if (pQuery->rgdwVarIndex[0] >= 0x01010101)
       return MIB_S_NO_MORE_ENTRIES;
    pEntry->dwGroup   = 0x01010101;
    pEntry->dwSource  = 0x02020202;
    pEntry->dwSrcMask = 0x03030303;
    pEntry->ulNumOutIf = 1;
    pOif->dwOutIfIndex = 11;
    pOif->dwNextHopAddr = 0x04040404;
    pOif->ulOutPackets = 22;
    // don't care what the other values are for this test
}
#endif

    // Save index terms
    ForceSetAsnIPAddress(&(pOutput->ipMRouteNextHopGroup),      
                         &(pOutput->dwIpMRouteNextHopGroupInfo),
                         pEntry->dwGroup);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteNextHopSource),    
                         &(pOutput->dwIpMRouteNextHopSourceInfo),
                         pEntry->dwSource);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteNextHopSourceMask), 
                         &(pOutput->dwIpMRouteNextHopSourceMaskInfo),
                         pEntry->dwSrcMask);
    ForceSetAsnInteger  (&(pOutput->ipMRouteNextHopIfIndex), 
                         pOif->dwOutIfIndex);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteNextHopAddress), 
                         &(pOutput->dwIpMRouteNextHopAddressInfo),
                         pOif->dwNextHopAddr);

    // Save other terms
    SetAsnInteger(&(pOutput->ipMRouteNextHopState), 2); // "forwarding"
    SetAsnTimeTicks(&(pOutput->ipMRouteNextHopUpTime), pEntry->ulUpTime); // XXX 
    SetAsnTimeTicks(&(pOutput->ipMRouteNextHopExpiryTime), pEntry->ulExpiryTime); // XXX 
#ifdef CLOSEST_MEMBER_HOPS
    SetAsnInteger(&(pOutput->ipMRouteNextHopClosestMemberHops), 1); 
#endif
    SetAsnCounter(&(pOutput->ipMRouteNextHopPkts), pOif->ulOutPackets);
    // For protocol, we'll just report the protocol owning the interface
    SetAsnInteger(&(pOutput->ipMRouteNextHopProtocol), 
        GetInterfaceProtocol(pOif->dwOutIfIndex));

    if ( pRpcInfo ) { MprAdminMIBBufferFree( pRpcInfo ); }

    TraceLeave("get_ipMRouteNextHopEntry");
    return MIB_S_SUCCESS;
}

DWORD
SetMibInfo(
    IN  UINT                              actionId,    // SET, CLEANUP
    IN  PMIB_OPAQUE_INFO                  pInfo,       // value info
    IN  DWORD                             dwInfoSize   // size of above
)
{
    DWORD dwRes = NO_ERROR;
    
    switch ( actionId )
    {

#ifdef THREE_PHASE
    case MIB_ACTION_VALIDATE :

        MULTICAST_MIB_VALIDATE(
            pInfo,
            dwInfoSize,
            dwRes
        );
                 
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
        }

        break;
#endif

    case MIB_ACTION_SET :

#if 1
        dwRes = ( g_hMIBServer ) ? NO_ERROR 
                                 : ConnectToRouter();

        if ( dwRes == NO_ERROR )
        {
            dwRes = MprAdminMIBEntrySet( g_hMIBServer,
                                         PID_IP,
                                         IPRTRMGR_PID,
                                         (LPVOID) (pInfo),
                                         (dwInfoSize)
                                       );
        }
#else
        MULTICAST_MIB_COMMIT(
            pInfo,
            dwInfoSize,
            dwRes
        );
#endif
                 
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER
         ||  dwRes == ERROR_INVALID_INDEX )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
        }
    
        break;

#ifdef THREE_PHASE
    case MIB_ACTION_CLEANUP :

        MULTICAST_MIB_CLEANUP(
            pInfo,
            dwInfoSize,
            dwRes
        );
                 
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER )
        {
            dwRes = MIB_S_INVALID_PARAMETER;
        }

        break;
#endif

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    
    }

    return dwRes;
}

DWORD
GetMibInfo( 
    IN  UINT                              actionId,    // GET, GET-NEXT, SET
    IN  PMIB_OPAQUE_QUERY                 pQuery,      // instance info
    IN  DWORD                             dwQuerySize, // size of above
    OUT PMIB_OPAQUE_INFO                 *ppimgod,     // value info
    OUT PDWORD                            pdwOutSize   // size of above
)
{
    DWORD                   dwRes           = (DWORD) -1;
    PMIB_OPAQUE_INFO        pimgodOutData   = NULL;
    
    *ppimgod = NULL;

    switch ( actionId )
    {
    case MIB_ACTION_GET :

        MULTICAST_MIB_GET(
            pQuery,
            dwQuerySize,
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        // RPC_S_SERVER_UNAVAILABLE is returned when the router
        // isn't running.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER
         ||  dwRes == RPC_S_SERVER_UNAVAILABLE
         ||  dwRes == RPC_S_UNKNOWN_IF )
        {
            dwRes = MIB_S_ENTRY_NOT_FOUND;
        }

        break;

    case MIB_ACTION_GETFIRST :

        MULTICAST_MIB_GETFIRST(
            pQuery,
            dwQuerySize,
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        // RPC_S_SERVER_UNAVAILABLE is returned when the router
        // isn't running.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER
         ||  dwRes == RPC_S_SERVER_UNAVAILABLE
         ||  dwRes == RPC_S_UNKNOWN_IF )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    case MIB_ACTION_GETNEXT :
    
        MULTICAST_MIB_GETNEXT(
            pQuery,
            dwQuerySize,
            &pimgodOutData,
            pdwOutSize,
            dwRes
        );
        
                 
        //
        // ERROR_INVALID_PARAMETER is returned when there is 
        // no interface for the specified index.
        // RPC_S_SERVER_UNAVAILABLE is returned when the router
        // isn't running.
        //
        
        if ( dwRes == ERROR_INVALID_PARAMETER 
          || dwRes == ERROR_NO_MORE_ITEMS
          || dwRes == RPC_S_SERVER_UNAVAILABLE
          || dwRes == RPC_S_UNKNOWN_IF )
        {
            dwRes = MIB_S_NO_MORE_ENTRIES;

            break;
        }

        //
        // Get Next wraps to the next table at the end of the
        // entries in the current table.  To flag the end of a table,
        // check the end of the table.
        //
    
        if ( pQuery->dwVarId != pQuery->dwVarId )
        {
            MprAdminMIBBufferFree( pimgodOutData );
        
            dwRes = MIB_S_NO_MORE_ENTRIES;
        }

        break;

    default :

        dwRes = MIB_S_INVALID_PARAMETER;
        
        break;
    
    }

    if ( dwRes == NO_ERROR )
    {
        *ppimgod = pimgodOutData;
    }

    return dwRes;
}

UINT
set_ipMRouteScopeEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                       dwRes = MIB_S_SUCCESS;
    DWORD                       dwNumEntries = 1;
    PMIB_IPMCAST_SCOPE          pEntry;
    sav_ipMRouteScopeEntry     *pOutput;
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;
    DWORD                       dwOutBufferSize = 0;
    MIB_OPAQUE_QUERY   pQueryBuff[2]; // big enough to hold 1 + extra index 
                                      // fields, so we don't have to malloc
    MIB_OPAQUE_QUERY  *pQuery = &pQueryBuff[0];
    DWORD                       dwQuerySize;
    DWORD                       dwIfIndex;
    DWORD                       dwAddr;
    DWORD                       dwMask;

    TraceEnter("set_ipMRouteScopeEntry");
    pOutput = (sav_ipMRouteScopeEntry*)objectArray;

    dwAddr    = GetAsnIPAddress(  &pOutput->ipMRouteScopeAddress,     0 );
    dwMask    = GetAsnIPAddress(  &pOutput->ipMRouteScopeAddressMask, 0 );

    switch(actionId) {
    case MIB_ACTION_VALIDATE:
       //
       // Verify that the specified ifIndex, address, and mask are valid.
       //
       if ((dwAddr & dwMask) != dwAddr) {
          TRACE0( "set_ipMRouteScopeEntry: address/mask mismatch" );
          dwRes = MIB_S_INVALID_PARAMETER; 
       } else if (!IN_MULTICAST(ntohl(dwAddr))) {
          TRACE0( "set_ipMRouteScopeEntry: non-multicast address" );
          dwRes = MIB_S_INVALID_PARAMETER; 
       }
       break;
      
    case MIB_ACTION_SET: {
       BYTE              pScopeName[MAX_SCOPE_NAME_LEN+1];
       DWORD             dwInfoSize;
       MIB_IPMCAST_SCOPE pScopeBuff[2]; // big enough to hold 1 + mib hdr
                                        // so we don't have to malloc
       MIB_OPAQUE_INFO  *pInfo = (PMIB_OPAQUE_INFO)&pScopeBuff[0];
       PMIB_IPMCAST_SCOPE pScope = (MIB_IPMCAST_SCOPE *)(pInfo->rgbyData);

       pInfo->dwId                = MCAST_SCOPE;
       pScope->dwGroupAddress     = dwAddr;
       pScope->dwGroupMask        = dwMask;

       //
       // Copy the scope name.  
       //

       pScopeName[0] = '\0';
       GetAsnOctetString( pScopeName, &pOutput->ipMRouteScopeName );

       MultiByteToWideChar( CP_UTF8,
                            0,
                            pScopeName,
                            strlen(pScopeName),
                            pScope->snNameBuffer,
                            MAX_SCOPE_NAME_LEN+1 );

       pScope->dwStatus           = GetAsnInteger( 
         &pOutput->ipMRouteScopeStatus, 0 );
       dwInfoSize = MIB_INFO_SIZE(MIB_IPMCAST_SCOPE);
   
       //
       // Passing a name of "" or a status of 0 tells the router
       // not to change the existing value.
       //

       dwRes = SetMibInfo(actionId, pInfo, dwInfoSize);
   
       break;
       }

    case MIB_ACTION_CLEANUP:
       dwRes = MIB_S_SUCCESS;
       break;

    default:
       dwRes = MIB_S_INVALID_PARAMETER;
       TRACE0(" set_ipMRouteScopeEntry - Wrong Action ");
       break;
    }

    TraceLeave("set_ipMRouteScopeEntry");

    return dwRes;
}

UINT
set_ipMRouteBoundaryEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                       dwRes = MIB_S_SUCCESS;
    DWORD                       dwNumEntries = 1;
    PMIB_IPMCAST_BOUNDARY       pEntry;
    sav_ipMRouteBoundaryEntry *pOutput;
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;
    DWORD                       dwOutBufferSize = 0;
    MIB_OPAQUE_QUERY   pQueryBuff[2]; // big enough to hold 1 + extra index 
                                      // fields, so we don't have to malloc
    MIB_OPAQUE_QUERY  *pQuery = &pQueryBuff[0];
    DWORD                       dwQuerySize;
    DWORD                       dwIfIndex;
    DWORD                       dwAddr;
    DWORD                       dwMask;

    TraceEnter("set_ipMRouteBoundaryEntry");
    pOutput = (sav_ipMRouteBoundaryEntry*)objectArray;

    dwIfIndex = GetAsnInteger( &( pOutput->ipMRouteBoundaryIfIndex ), 0 );
    dwAddr    = GetAsnIPAddress( &pOutput->ipMRouteBoundaryAddress, 0 );
    dwMask    = GetAsnIPAddress( &pOutput->ipMRouteBoundaryAddressMask, 0 );

    switch(actionId) {
    case MIB_ACTION_VALIDATE:
       //
       // Verify that the specified ifIndex, address, and mask are valid.
       //
       if ((dwAddr & dwMask) != dwAddr) {
          TRACE0( "set_ipMRouteBoundaryEntry: address/mask mismatch" );
          dwRes = MIB_S_INVALID_PARAMETER; 
       } else if (!IN_MULTICAST(ntohl(dwAddr))) {
          TRACE0( "set_ipMRouteBoundaryEntry: non-multicast address" );
          dwRes = MIB_S_INVALID_PARAMETER; 
       }
       break;
      
    case MIB_ACTION_SET: {
       DWORD             dwInfoSize;
       MIB_OPAQUE_INFO   pInfoBuff[2]; // big enough to hold 1 + extra index 
                                       // fields, so we don't have to malloc
       MIB_OPAQUE_INFO  *pInfo = &pInfoBuff[0];
       PMIB_IPMCAST_BOUNDARY pBound = (MIB_IPMCAST_BOUNDARY *)(pInfo->rgbyData);

       pInfo->dwId                = MCAST_BOUNDARY;
       pBound->dwIfIndex          = dwIfIndex;
       pBound->dwGroupAddress     = dwAddr;
       pBound->dwGroupMask        = dwMask;
       pBound->dwStatus           = GetAsnInteger( 
         &pOutput->ipMRouteBoundaryStatus, 0 );
       dwInfoSize = sizeof(MIB_OPAQUE_INFO) + 3*sizeof(DWORD);
   
       dwRes = SetMibInfo(actionId, pInfo, dwInfoSize);
   
       break;
       }

    case MIB_ACTION_CLEANUP:
       dwRes = MIB_S_SUCCESS;
       break;

    default:
       dwRes = MIB_S_INVALID_PARAMETER;
       TRACE0(" set_ipMRouteBoundaryEntry - Wrong Action ");
       break;
    }

    TraceLeave("set_ipMRouteBoundaryEntry");

    return dwRes;
}

UINT
get_ipMRouteScopeEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                       dwErr = ERROR_NOT_FOUND;
    DWORD                       dwNumEntries = 1;
    PMIB_IPMCAST_SCOPE          pEntry;
    buf_ipMRouteScopeEntry     *pOutput;
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;
    DWORD                       dwOutBufferSize = 0;
    MIB_OPAQUE_QUERY   pQueryBuff[2]; // big enough to hold 1 + extra index 
                                      // fields, so we don't have to malloc
    MIB_OPAQUE_QUERY  *pQuery = &pQueryBuff[0];
    DWORD                       dwQuerySize;
    BYTE                        pScopeName[MAX_SCOPE_NAME_LEN+1];

    TraceEnter("get_ipMRouteScopeEntry");
    pOutput = (buf_ipMRouteScopeEntry*)objectArray;

    pQuery->dwVarId       = MCAST_SCOPE;
    pQuery->rgdwVarIndex[0] = GetAsnIPAddress( &pOutput->ipMRouteScopeAddress, 0 );
    pQuery->rgdwVarIndex[1] = GetAsnIPAddress( &pOutput->ipMRouteScopeAddressMask, 0 );
    dwQuerySize = sizeof(MIB_OPAQUE_QUERY) + sizeof(DWORD);

    dwErr = GetMibInfo(actionId, pQuery, dwQuerySize,
                       &pRpcInfo, &dwOutBufferSize);
    if (dwErr != NO_ERROR) {
        TraceError(dwErr);
TraceLeave("get_ipMRouteScopeEntry");

        if (dwErr == ERROR_NOT_FOUND)
            return MIB_S_ENTRY_NOT_FOUND;

        return dwErr;
    }

    pEntry = (PMIB_IPMCAST_SCOPE) pRpcInfo->rgbyData;

    // Set index values

    ForceSetAsnIPAddress(&(pOutput->ipMRouteScopeAddress),      
                         &(pOutput->dwIpMRouteScopeAddressInfo),
                         pEntry->dwGroupAddress);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteScopeAddressMask),      
                         &(pOutput->dwIpMRouteScopeAddressMaskInfo),
                         pEntry->dwGroupMask);

    // Set other values.

    WideCharToMultiByte( CP_UTF8,
                         0,
                         pEntry->snNameBuffer, 
                         wcslen(pEntry->snNameBuffer)+1,
                         pScopeName,
                         MAX_SCOPE_NAME_LEN+1,
                         NULL,
                         NULL ); 

    SetAsnOctetString(&( pOutput->ipMRouteScopeName), 
                        pOutput->rgbyScopeNameInfo,
                        pScopeName,
                        min(strlen(pScopeName),MAX_SCOPE_NAME_LEN));

    SetAsnInteger(&(pOutput->ipMRouteScopeStatus), ROWSTATUS_ACTIVE);

    if (pRpcInfo)
        MprAdminMIBBufferFree(pRpcInfo);

    TraceLeave("get_ipMRouteScopeEntry");
    return MIB_S_SUCCESS;
}

UINT
get_ipMRouteBoundaryEntry(
    UINT     actionId,
    AsnAny * objectArray,
    UINT *   errorIndex
    )
{
    DWORD                       dwErr = ERROR_NOT_FOUND;
    DWORD                       dwNumEntries = 1;
    PMIB_IPMCAST_BOUNDARY       pEntry;
    buf_ipMRouteBoundaryEntry *pOutput;
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;
    DWORD                       dwOutBufferSize = 0;
    MIB_OPAQUE_QUERY   pQueryBuff[2]; // big enough to hold 1 + extra index 
                                      // fields, so we don't have to malloc
    MIB_OPAQUE_QUERY  *pQuery = &pQueryBuff[0];
    DWORD                       dwQuerySize;

    TraceEnter("get_ipMRouteBoundaryEntry");
    pOutput = (buf_ipMRouteBoundaryEntry*)objectArray;

    pQuery->dwVarId       = MCAST_BOUNDARY;
    pQuery->rgdwVarIndex[0] = GetAsnInteger( &( pOutput->ipMRouteBoundaryIfIndex ), 0 );
    pQuery->rgdwVarIndex[1] = GetAsnIPAddress( &pOutput->ipMRouteBoundaryAddress, 0 );
    pQuery->rgdwVarIndex[2] = GetAsnIPAddress( &pOutput->ipMRouteBoundaryAddressMask, 0 );
    dwQuerySize = sizeof(MIB_OPAQUE_QUERY) + 2*sizeof(DWORD);

    dwErr = GetMibInfo(actionId, pQuery, dwQuerySize,
                       &pRpcInfo, &dwOutBufferSize);
    if (dwErr != NO_ERROR) {
        TraceError(dwErr);
TraceLeave("get_ipMRouteBoundaryEntry");

        if (dwErr == ERROR_NOT_FOUND)
            return MIB_S_ENTRY_NOT_FOUND;

        return dwErr;
    }

    pEntry = (PMIB_IPMCAST_BOUNDARY) pRpcInfo->rgbyData;

    // Set index values
    ForceSetAsnInteger(&(pOutput->ipMRouteBoundaryIfIndex), pEntry->dwIfIndex);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteBoundaryAddress),      
                         &(pOutput->dwIpMRouteBoundaryAddressInfo),
                         pEntry->dwGroupAddress);
    ForceSetAsnIPAddress(&(pOutput->ipMRouteBoundaryAddressMask),      
                         &(pOutput->dwIpMRouteBoundaryAddressMaskInfo),
                         pEntry->dwGroupMask);

    // Set other values
    SetAsnInteger(&(pOutput->ipMRouteBoundaryStatus), ROWSTATUS_ACTIVE);

    if (pRpcInfo)
        MprAdminMIBBufferFree(pRpcInfo);

    TraceLeave("get_ipMRouteBoundaryEntry");
    return MIB_S_SUCCESS;
}

DWORD
ConnectToRouter()
{
    DWORD       dwRes = (DWORD) -1;

    TraceEnter("ConnectToRouter");

    EnterCriticalSection( &g_CS );

    do
    {
        MPR_SERVER_HANDLE hTmp;

        if ( g_hMIBServer )
        {
            dwRes = NO_ERROR;
            break;
        }

        dwRes = MprAdminMIBServerConnect( NULL, &hTmp );

        if ( dwRes == NO_ERROR )
        {
            InterlockedExchangePointer(&g_hMIBServer, hTmp );
        }
        else
        {
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", 
                dwRes
            );
        }
        
    } while ( FALSE );

    LeaveCriticalSection( &g_CS );

    TraceLeave("ConnectToRouter");

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\load.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\ip\mcastmib\load.c

Abstract:

    IP Multicast MIB subagent

Revision history:

    Dave Thaler         4/17/98  Created

--*/

#include "precomp.h"
#pragma hdrstop


#if defined( MIB_DEBUG )

DWORD               g_dwTraceId     = INVALID_TRACEID;

#endif

MIB_SERVER_HANDLE   g_hMIBServer    = ( MIB_SERVER_HANDLE) NULL;

//
// Critical section to protect MIB server handle
//

CRITICAL_SECTION    g_CS;

//
// Extension Agent DLLs need access to elapsed time agent has been active.
// This is implemented by initializing the Extension Agent with a time zero
// reference, and allowing the agent to compute elapsed time by subtracting
// the time zero reference from the current system time.  
//

DWORD g_uptimeReference = 0;

//
// Handle to Subagent Framework 
//

SnmpTfxHandle g_tfxHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Subagent entry points                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL 
SnmpExtensionInit(
    IN     DWORD                 uptimeReference,
       OUT HANDLE *              lpPollForTrapEvent,
       OUT AsnObjectIdentifier * lpFirstSupportedView
    )
{

    DWORD       dwRes   = (DWORD) -1;


#if defined( MIB_DEBUG )

    //
    // tracing for DEBUG
    //

    g_dwTraceId = TraceRegister( "IPMULTICASTMIB" );
    
#endif


    TraceEnter("SnmpExtensionInit");


    //
    // Verify router service is running
    //

    if ( !MprAdminIsServiceRunning( NULL ) )
    {
        TRACE0( "Router Service not running" );
        
    }
    else {
    
        //
        // Connect to router.  In case of error, set
        // connection handle to NULL.  Connection can
        // be established later.
        //
        
        dwRes = MprAdminMIBServerConnect(
                    NULL,
                    &g_hMIBServer
                );

        if ( dwRes != NO_ERROR )
        {
            g_hMIBServer = (MIB_SERVER_HANDLE) NULL;
            
            TRACE1( 
                "Error %d setting up DIM connection to MIB Server\n", dwRes
            );

            return FALSE;
        }
    }

    
    // save uptime reference
    g_uptimeReference = uptimeReference;

    // obtain handle to subagent framework
    g_tfxHandle = SnmpTfxOpen(1,&v_multicast);

    // validate handle
    if (g_tfxHandle == NULL) {
        return FALSE;
    }

    // pass back first view identifier to master
    *lpFirstSupportedView = v_multicast.viewOid;

    // traps not supported yet
    *lpPollForTrapEvent = NULL;

    TraceLeave("SnmpExtensionInit");
    return TRUE;    
}

#ifdef THREE_PHASE
BOOL SnmpExtensionQueryEx(
  DWORD dwRequestType,           // extension agent request type
  DWORD dwTransactionId,         // identifier of the incoming PDU
  SnmpVarBindList *pVarBindList, // pointer to variable binding list
  AsnOctetString *pContextInfo,  // pointer to context information
  AsnInteger32 *pErrorStatus,    // pointer to SNMPv2 error status
  AsnInteger32 *pErrorIndex      // pointer to the error index);
{
    // forward to framework
    return SnmpTfxQueryEx(
                g_tfxHandle,
                dwRequestType,
                pVarBindlist,
                pErrorStatus,
                pErrorIndex
                );
}
#endif

BOOL 
SnmpExtensionQuery(
    IN     BYTE                 requestType,
    IN OUT RFC1157VarBindList * variableBindings,
       OUT AsnInteger *         errorStatus,
       OUT AsnInteger *         errorIndex
    )
{
    // forward to framework
    return SnmpTfxQuery(
                g_tfxHandle,
                requestType,
                variableBindings,
                errorStatus,
                errorIndex
                );
}

BOOL 
SnmpExtensionTrap(
    OUT AsnObjectIdentifier *enterprise,
    OUT AsnInteger *genericTrap,
    OUT AsnInteger *specificTrap,
    OUT AsnTimeticks *timeStamp,
    OUT RFC1157VarBindList *variableBindings
    )
{
    // no traps
    return FALSE;
}


BOOL WINAPI
DllMain(
    HINSTANCE       hInstDLL,
    DWORD           fdwReason,
    LPVOID          pReserved
)
{
    
    switch ( fdwReason )
    {
        case DLL_PROCESS_ATTACH :
        {
            DisableThreadLibraryCalls( hInstDLL );

            InitializeCriticalSection( &g_CS );
            
            g_hMIBServer = (MIB_SERVER_HANDLE) NULL;
            
            break;
        }
        
        case DLL_PROCESS_DETACH :
        {
            //
            // Disconnect from router
            //

            if ( g_hMIBServer )
            {
                MprAdminMIBServerDisconnect( g_hMIBServer );
            }

            DeleteCriticalSection( &g_CS );
            
#if defined( MIB_DEBUG )

            if ( g_dwTraceId != INVALID_TRACEID )
            {
                TraceDeregister( g_dwTraceId );
            }
#endif              
            break;
         }
         
         default :
         {
            break;
         }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\mcastmib\mibentry.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mibentry.h

Abstract:

    IP Multicast MIB structures.

Revision History:

    Dave Thaler       4/17/98  Created

--*/

#ifndef _MIBENTRY_H_
#define _MIBENTRY_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Mib entry indices                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define mi_ipMRouteEnable                       0
#define mi_ipMRouteTable                        mi_ipMRouteEnable+1
#define mi_ipMRouteEntry                        mi_ipMRouteTable+1 
#define mi_ipMRouteGroup                        mi_ipMRouteEntry+1
#define mi_ipMRouteSource                       mi_ipMRouteGroup+1
#define mi_ipMRouteSourceMask                   mi_ipMRouteSource+1
#define mi_ipMRouteUpstreamNeighbor             mi_ipMRouteSourceMask+1
#define mi_ipMRouteInIfIndex                    mi_ipMRouteUpstreamNeighbor+1
#define mi_ipMRouteUpTime                       mi_ipMRouteInIfIndex+1
#define mi_ipMRouteExpiryTime                   mi_ipMRouteUpTime+1
#define mi_ipMRoutePkts                         mi_ipMRouteExpiryTime+1
#define mi_ipMRouteDifferentInIfPackets         mi_ipMRoutePkts+1
#define mi_ipMRouteOctets                       mi_ipMRouteDifferentInIfPackets+1
#define mi_ipMRouteProtocol                     mi_ipMRouteOctets+1
#define mi_ipMRouteRtProto                      mi_ipMRouteProtocol+1
#define mi_ipMRouteRtAddress                    mi_ipMRouteRtProto+1
#define mi_ipMRouteRtMask                       mi_ipMRouteRtAddress+1

#define mi_ipMRouteNextHopTable                 mi_ipMRouteRtMask+1
#define mi_ipMRouteNextHopEntry                 mi_ipMRouteNextHopTable+1
#define mi_ipMRouteNextHopGroup                 mi_ipMRouteNextHopEntry+1
#define mi_ipMRouteNextHopSource                mi_ipMRouteNextHopGroup+1
#define mi_ipMRouteNextHopSourceMask            mi_ipMRouteNextHopSource+1
#define mi_ipMRouteNextHopIfIndex               mi_ipMRouteNextHopSourceMask+1
#define mi_ipMRouteNextHopAddress               mi_ipMRouteNextHopIfIndex+1
#define mi_ipMRouteNextHopState                 mi_ipMRouteNextHopAddress+1
#define mi_ipMRouteNextHopUpTime                mi_ipMRouteNextHopState+1
#define mi_ipMRouteNextHopExpiryTime            mi_ipMRouteNextHopUpTime+1
#ifdef CLOSEST_MEMBER_HOPS
#define mi_ipMRouteNextHopClosestMemberHops     mi_ipMRouteNextHopExpiryTime+1
#define mi_ipMRouteNextHopProtocol              mi_ipMRouteNextHopClosestMemberHops+1
#else
#define mi_ipMRouteNextHopProtocol              mi_ipMRouteNextHopExpiryTime+1
#endif
#define mi_ipMRouteNextHopPkts                  mi_ipMRouteNextHopProtocol+1

#define mi_ipMRouteInterfaceTable               mi_ipMRouteNextHopPkts+1
//#define mi_ipMRouteInterfaceTable               mi_ipMRouteProtocol+1
#define mi_ipMRouteInterfaceEntry               mi_ipMRouteInterfaceTable+1
#define mi_ipMRouteInterfaceIfIndex             mi_ipMRouteInterfaceEntry+1
#define mi_ipMRouteInterfaceTtl                 mi_ipMRouteInterfaceIfIndex+1
#define mi_ipMRouteInterfaceProtocol            mi_ipMRouteInterfaceTtl+1
#define mi_ipMRouteInterfaceRateLimit           mi_ipMRouteInterfaceProtocol+1
#define mi_ipMRouteInterfaceInMcastOctets       mi_ipMRouteInterfaceRateLimit+1
#define mi_ipMRouteInterfaceOutMcastOctets      mi_ipMRouteInterfaceInMcastOctets+1

#define mi_ipMRouteBoundaryTable                mi_ipMRouteInterfaceOutMcastOctets+1
#define mi_ipMRouteBoundaryEntry                mi_ipMRouteBoundaryTable+1
#define mi_ipMRouteBoundaryIfIndex              mi_ipMRouteBoundaryEntry+1
#define mi_ipMRouteBoundaryAddress              mi_ipMRouteBoundaryIfIndex+1
#define mi_ipMRouteBoundaryAddressMask          mi_ipMRouteBoundaryAddress+1
#define mi_ipMRouteBoundaryStatus               mi_ipMRouteBoundaryAddressMask+1

#define mi_ipMRouteScopeTable                   mi_ipMRouteBoundaryStatus+1
#define mi_ipMRouteScopeEntry                   mi_ipMRouteScopeTable+1
#define mi_ipMRouteScopeAddress                 mi_ipMRouteScopeEntry+1
#define mi_ipMRouteScopeAddressMask             mi_ipMRouteScopeAddress+1
#define mi_ipMRouteScopeName                    mi_ipMRouteScopeAddressMask+1
#define mi_ipMRouteScopeStatus                  mi_ipMRouteScopeName+1

//
// Now we have to set up defines to tell the Master agent the number of
// cols in each table and the number of cols that are indices for these table.
// The Agent expects the indices to be contiguous and in the beginning
//

//
// ipMRouteTable
//                                            

#define ne_ipMRouteEntry                       14
#define ni_ipMRouteEntry                        3

//                                             
// ipMRouteNextHopTable
//                                              

#ifdef CLOSEST_MEMBER_HOPS
#define ne_ipMRouteNextHopEntry                11
#else
#define ne_ipMRouteNextHopEntry                10
#endif
#define ni_ipMRouteNextHopEntry                 5

//
// ipMRouteInterfaceTable
//

#define ne_ipMRouteInterfaceEntry               6
#define ni_ipMRouteInterfaceEntry               1

//
// ipMRouteBoundaryTable
//

#define ne_ipMRouteBoundaryEntry                4
#define ni_ipMRouteBoundaryEntry                3

//
// ipMRouteScopeTable
//

#define ne_ipMRouteScopeEntry                   4
#define ni_ipMRouteScopeEntry                   2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Declaration of supported view                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern SnmpMibView v_multicast;

#endif // _MIBENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\compref.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    compref.h

Abstract:

    This module contains declarations for maintaining reference-count
    on a component. It provides an asynchronous thread-safe means of
    handling cleanup in a module.

    The mechanism defined uses a locked reference count and cleanup-routine
    to manage the lifetime of the component. When the reference-count
    is dropped to zero, the associated cleanup-routine is invoked.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_COMPREF_H_
#define _NATHLP_COMPREF_H_

typedef
VOID
(*PCOMPONENT_CLEANUP_ROUTINE)(
    VOID
    );

//
// Structure:   COMPONENT_REFERENCE
//
// This structure must reside in memory for the lifetime of the component
// to which it refers. It is used to synchronize the components execution.
//

typedef struct _COMPONENT_REFERENCE {
    KSPIN_LOCK Lock;
    ULONG ReferenceCount;
    BOOLEAN Deleted;
    KEVENT Event;
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine;
} COMPONENT_REFERENCE, *PCOMPONENT_REFERENCE;



//
// FUNCTION DECLARATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    );

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    BOOLEAN Wait
    );

__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

//
// MACRO DECLARATIONS
//

#define RETURN_VOID

#define REFERENCE_COMPONENT(c) \
    AcquireComponentReference(c)

#define DEREFERENCE_COMPONENT(c) \
    ReleaseComponentReference(c)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!AcquireComponentReference(c)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    ReleaseComponentReference(c); return retcode


//
// INLINE ROUTINE IMPLEMENTATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/

{
    KIRQL Irql;
    KeAcquireSpinLock(&ComponentReference->Lock, &Irql);
    if (ComponentReference->Deleted) {
        KeReleaseSpinLock(&ComponentReference->Lock, Irql);
        return FALSE;
    }
    ++ComponentReference->ReferenceCount;
    KeReleaseSpinLock(&ComponentReference->Lock, Irql);
    return TRUE;

} // AcquireComponentReference


VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the last reference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/

{

} // DeleteComponentReference


ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    )

/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/

{
    KeInitializeSpinLock(&ComponentReference->Lock);
    KeInitializeEvent(&ComponentReference->Event, NotificationEvent, FALSE);
    ComponentReference->Deleted = FALSE;
    ComponentReference->ReferenceCount = 1;
    ComponentReference->CleanupRoutine = CleanupRoutine;
    return STATUS_SUCCESS;

} // InitializeComponentReference



__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    KIRQL Irql;
    KeAcquireSpinLock(&ComponentReference->Lock, &Irql);
    if (--ComponentReference->ReferenceCount) {
        KeReleaseSpinLock(&ComponentReference->Lock, Irql);
        return FALSE;
    }
    KeReleaseSpinLock(&ComponentReference->Lock, Irql);
    KeSetEvent(&ComponentReference->Event, 0, FALSE);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseComponentReference


__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    BOOLEAN Wait
    )

/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

    Wait - if TRUE, the routine waits till the last reference is released.

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    KIRQL Irql;
    KeAcquireSpinLock(&ComponentReference->Lock, &Irql);
    if (ComponentReference->Deleted) {
        KeReleaseSpinLock(&ComponentReference->Lock, Irql);
        return TRUE;
    }
    ComponentReference->Deleted = TRUE;
    if (--ComponentReference->ReferenceCount) {
        if (!Wait) {
            KeReleaseSpinLock(&ComponentReference->Lock, Irql);
            return FALSE;
        }
        else {
            PKEVENT Event = &ComponentReference->Event;
            KeReleaseSpinLock(&ComponentReference->Lock, Irql);
            KeWaitForSingleObject(
                Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            return TRUE;
        }
    }
    KeReleaseSpinLock(&ComponentReference->Lock, Irql);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseInitialComponentReference


__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/

{
    KIRQL Irql;
    KeAcquireSpinLock(&ComponentReference->Lock, &Irql);
    ComponentReference->ReferenceCount = 1;
    ComponentReference->Deleted = FALSE;
    KeReleaseSpinLock(&ComponentReference->Lock, Irql);
} // ReleaseComponentReference



#endif // _NATHLP_COMPREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\debug.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains declarations related to the NAT's debug-code.

Author:

    Abolade Gbadegesin (t-abolag)   16-July-1997

Revision History:

--*/


#ifndef _NAT_DEBUG_H_
#define _NAT_DEBUG_H_

//
// Kernel-debugger output definitions
//

#if DBG
#define TRACE(Class,Args) \
    if ((TRACE_CLASS_ ## Class) & (TraceClassesEnabled)) { DbgPrint Args; }
#define ERROR(Args)             DbgPrint Args
#define CALLTRACE(Args)         TRACE(CALLS, Args)
#else
#define TRACE(Class,Args)
#define ERROR(Args)
#define CALLTRACE(Args)
#endif


#define TRACE_CLASS_CALLS       0x00000001
#define TRACE_CLASS_MAPPING     0x00000002
#define TRACE_CLASS_POOL        0x00000004
#define TRACE_CLASS_XLATE       0x00000008
#define TRACE_CLASS_EDIT        0x00000010
#define TRACE_CLASS_ICMP        0x00000020
#define TRACE_CLASS_PER_PACKET  0x00000040
#define TRACE_CLASS_PPTP        0x00000080
#define TRACE_CLASS_TICKET      0x00000100
#define TRACE_CLASS_NBT         0x00000200
#define TRACE_CLASS_XSUM        0x00000400
#define TRACE_CLASS_IP          0x00000800
#define TRACE_CLASS_REDIRECT    0x00001000
#define TRACE_CLASS_WMI         0x00002000
#define TRACE_CLASS_RHIZOME     0x00004000


//
// Pool-tag value definitions, sorted by tag value
//

#define NAT_TAG_RANGE_ARRAY         'ARaN'
#define NAT_TAG_ADDRESS             'AtaN'
#define NAT_TAG_BINDING             'BtaN'
#define NAT_TAG_ICMP                'CIaN'
#define NAT_TAG_IF_CONFIG           'CtaN'
#define NAT_TAG_SD                  'DSaN'
#define NAT_TAG_DIRECTOR            'DtaN'
#define NAT_TAG_EDITOR              'EtaN'
#define NAT_TAG_HOOK                'HtaN'
#define NAT_TAG_INTERFACE           'ItaN'
#define NAT_TAG_BITMAP              'MBaN'
#define NAT_TAG_FREE_MAP            'MFaN'
#define NAT_TAG_MAPPING             'MtaN'
#define NAT_TAG_NBT                 'NtaN'
#define NAT_TAG_IOCTL               'OIaN'
#define NAT_TAG_IP                  'PIaN'
#define NAT_TAG_PPTP                'PtaN'
#define NAT_TAG_REDIRECT            'RtaN'
#define NAT_TAG_SORT                'StaN'
#define NAT_TAG_DYNAMIC_TICKET      'TDaN'
#define NAT_TAG_TICKET              'TtaN'
#define NAT_TAG_USED_ADDRESS        'AUaN'
#define NAT_TAG_WORK_ITEM           'WtaN'
#define NAT_TAG_WMI                 'mWaN'
#define NAT_TAG_RHIZOME             'zRaN'

#endif // _NAT_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\dispatch.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

    This files contains declarations for the NAT IRP dispatch code.

Author:

    Abolade Gbadegesin (t-abolag)   11-July-1997

Revision History:

--*/

#ifndef _NAT_DISPATCH_H_
#define _NAT_DISPATCH_H_

extern KSPIN_LOCK NatFileObjectLock;
extern HANDLE NatOwnerProcessId;
extern ULONG NatFileObjectCount;

NTSTATUS
NatDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
NatFastIoDeviceControl(
    PFILE_OBJECT FileObject,
    BOOLEAN Wait,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    ULONG IoControlCode,
    PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    );

extern FAST_IO_DISPATCH NatFastIoDispatch;

#endif // _NAT_DISPATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\edithlp.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    edithlp.h

Abstract:

    This module contains helper-declarations for the NAT's built-in editors.

Author:

    Abolade Gbadegesin (t-abolag)   25-Aug-1997

Revision History:

--*/

#ifndef _NAT_EDITHLP_H_
#define _NAT_EDITHLP_H_


//
// Macro:   COPY_FROM_BUFFER
//
// This macro copies from a buffer-chain to a flat buffer.
//

#define \
COPY_FROM_BUFFER( \
    Destination, \
    Source, \
    Length, \
    Offset \
    ) \
{ \
    PUCHAR _Destination = Destination; \
    ULONG _Length = Length; \
    LONG _Offset = Offset; \
    IPRcvBuf* _Source = Source; \
    while ((LONG)_Source->ipr_size < _Offset) { \
        _Offset -= _Source->ipr_size; \
        _Source = _Source->ipr_next; \
    } \
    while (_Length) { \
        ULONG Bytes = min(_Length, _Source->ipr_size-_Offset); \
        RtlCopyMemory(_Destination, _Source->ipr_buffer+_Offset, Bytes);\
        _Length -= Bytes; \
        _Destination += Bytes; \
        _Source = _Source->ipr_next; \
        _Offset = 0; \
    } \
}


//
// Macro:   FIND_HEADER_FIELD
// 
// This macro initializes a pseudo header's 'Field' member with the address
// in a buffer chain of the corresponding application-header field.
// It is assumed that each field of the application-header is aligned
// on the natural boundary for its width (e.g. 32-bit fields aligned
// on 32-bit boundaries).
//
// 'RecvBuffer' gives the first buffer in the chain containing the field,
// and 'DataOffsetp' points to the (negative) offset into 'RecvBuffer'
// of the header. This offset would be negative if the header is spread
// over multiple buffers and 'RecvBuffer' is one of the later buffers.
//
// The macro advances through the buffer chain until it finds the buffer
// containing the field (using FIELD_OFFSET). It then initializes the 
// pseudo-header's field pointer with the position of the field
// (i.e. 'Header->Field = &(field in buffer-chain)).
//
// Given that it walks the buffer chain, the macro thus requires that
// the pseudo-header's field pointers be initialized in-order,
// since an earlier field cannot be found in the chain after we have
// passed the buffer containing the latter while searching for a later field.
//

#define \
FIND_HEADER_FIELD( \
    RecvBuffer, \
    DataOffsetp, \
    Header, \
    Field, \
    HeaderType, \
    FieldType \
    ) \
    while ((LONG)(RecvBuffer)->ipr_size < \
            *(DataOffsetp) + FIELD_OFFSET(HeaderType, Field) \
            ) { \
        *(DataOffsetp) -= (RecvBuffer)->ipr_size; \
        (RecvBuffer) = (RecvBuffer)->ipr_next; \
        if (!(RecvBuffer)) { break; } \
    } \
    if (RecvBuffer) { \
        (Header)->Field = \
            (FieldType)((RecvBuffer)->ipr_buffer + *(DataOffsetp) + \
                FIELD_OFFSET(HeaderType, Field)); \
    }


#endif // _NAT_EDITHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\dispatch.c ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This file contains the code for handling I/O request packets.

Author:

    Abolade Gbadegesin (t-abolag)   11-July-1997

Revision History:

    Abolade Gbadegesin (aboladeg)   19-July-1998

    Cleaned up fast-path processing, and corrected input/output buffer logic
    while making the mapping-tree global rather than per-interface.

--*/

#include "precomp.h"
#pragma hdrstop


//
// Fast-io-dispatch structure; we only support fast-IO for IOCTLs
//

FAST_IO_DISPATCH NatFastIoDispatch =
{
    FIELD_OFFSET(FAST_IO_DISPATCH, FastIoDeviceControl),
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NatFastIoDeviceControl
};

//
// Spinlock to guard file object create / close 
//

KSPIN_LOCK NatFileObjectLock;

//
// The process that owns the outstanding file objects
//

HANDLE NatOwnerProcessId;

//
// The count of outstanding user-mode file objects.
//

ULONG NatFileObjectCount;

//
// FORWARD DECLARATIONS
//

NTSTATUS
NatpExecuteIoDeviceControl(
    PIRP Irp,
    PFILE_OBJECT FileObject,
    MODE RequestorMode,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    ULONG IoControlCode,
    PULONG Size
    );

NTSTATUS
NatpSetGlobalInfo(
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG Size
    );

BOOLEAN FASTCALL
NatpValidateHeader(
    PRTR_INFO_BLOCK_HEADER Header,
    ULONG Size
    );


NTSTATUS
NatDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to handle interrupt-request packets
    queued to the NAT's device object. A single routine serves
    to handle all the varios requests in which we are interested.

Arguments:

    DeviceObject - the NAT's device-object

    Irp - the interrupt request packet

Return Value:

    NTSTATUS - status code.

--*/

{
    PVOID Buffer;
    PRTR_TOC_ENTRY Entry;
    PRTR_INFO_BLOCK_HEADER Header;
    ULONG i;
    PIO_STACK_LOCATION IrpSp;
    KIRQL Irql;
    HANDLE ProcessId;
    ULONG Size = 0;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN ShouldComplete = TRUE;
    CALLTRACE(("NatDispatch\n"));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    Buffer = Irp->AssociatedIrp.SystemBuffer;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_CREATE: {

            //
            // If this is a user-mode request check process
            // ownership.
            //

            if (UserMode == Irp->RequestorMode) {

                ProcessId = PsGetCurrentProcessId();
                KeAcquireSpinLock(&NatFileObjectLock, &Irql);

                if (0 == NatFileObjectCount) {

                    //
                    // No process currently owns the NAT -- record
                    // the new owning process id, and update the
                    // outstanding file object count.
                    //

                    ASSERT(NULL == NatOwnerProcessId);

                    NatOwnerProcessId = ProcessId;
                    NatFileObjectCount = 1;

                } else if (ProcessId == NatOwnerProcessId) {

                    //
                    // The owning process is creating another
                    // file object.
                    //

                    NatFileObjectCount += 1;

                } else {

                    //
                    // A process that is not our owner is trying
                    // to create a file object -- fail the request.
                    //

                    status = STATUS_ACCESS_DENIED;
                }

                KeReleaseSpinLock(&NatFileObjectLock, Irql);
            }
            
            break;
        }

        case IRP_MJ_CLEANUP: {
            NatDeleteAnyAssociatedInterface(IrpSp->FileObject);
            NatCleanupAnyAssociatedRedirect(IrpSp->FileObject);
            NatCleanupAnyAssociatedNotification(IrpSp->FileObject);
            NatDeleteAnyAssociatedDynamicTicket(IrpSp->FileObject);
            break;
        }

        case IRP_MJ_CLOSE: {

            //
            // If this is a user-mode request update the outstanding
            // file object count and process ownership.
            //

            if (UserMode == Irp->RequestorMode) {

                KeAcquireSpinLock(&NatFileObjectLock, &Irql);

                ASSERT(NatFileObjectCount > 0);
                ASSERT(PsGetCurrentProcessId() == NatOwnerProcessId);

                NatFileObjectCount -= 1;

                if (0 == NatFileObjectCount) {

                    //
                    // The process has closed its last outstanding
                    // file object, and thus is no longer our
                    // owner.
                    //

                    NatOwnerProcessId = NULL;
                }

                KeReleaseSpinLock(&NatFileObjectLock, Irql);
            }
            break;
        }

        case IRP_MJ_DEVICE_CONTROL: {

            status =
                NatpExecuteIoDeviceControl(
                    Irp,
                    IrpSp->FileObject,
                    Irp->RequestorMode,
                    Buffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Buffer,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    IrpSp->Parameters.DeviceIoControl.IoControlCode,
                    &Size
                    );

            break;
        }

#if NAT_WMI
        case IRP_MJ_SYSTEM_CONTROL: {
        
            status =
                NatExecuteSystemControl(
                    DeviceObject,
                    Irp,
                    &ShouldComplete
                    );

            if (ShouldComplete) {
                ShouldComplete = FALSE;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
                    
			break;
		}
#endif

    }

    if (status != STATUS_PENDING && ShouldComplete) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = Size;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;

} // NatDispatch


BOOLEAN
NatFastIoDeviceControl(
    PFILE_OBJECT FileObject,
    BOOLEAN Wait,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    ULONG IoControlCode,
    PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked by the I/O system in an attempt to complete
    an I/O control request without constructing an IRP.

Arguments:

    FileObject - the file associated with the I/O request

    Wait - indicates whether a wait is allowed in this context

    InputBuffer - input information for the I/O request

    InputBufferLength - length of 'InputBuffer'

    OutputBuffer - output information for the I/O request

    OutputBufferLength - length of 'OutputBuffer'

    IoControlCode - I/O request code

    IoStatus - receives the status of the I/O request

    DeviceObject - device object of the NAT

Return Value:

    BOOLEAN - TRUE if completed synchronously, FALSE otherwise

--*/

{
    ULONG Size = 0;
    NTSTATUS Status;
    PVOID LocalInputBuffer;
    MODE PreviousMode;
    //
    // We are in the context of the requesting thread,
    // so exceptions may occur, and must be handled.
    // To deal with modifications to the user-provided information
    // capture the contents of the input buffer in non-paged pool.
    //
    if (!InputBufferLength) {
        LocalInputBuffer = NULL;
    } else {
        LocalInputBuffer =
            ExAllocatePoolWithTag(
                NonPagedPool,
                InputBufferLength,
                NAT_TAG_IOCTL
                );
        if (!LocalInputBuffer) {
            return FALSE;
        }
    }
    PreviousMode = ExGetPreviousMode();
    __try {
        if (InputBufferLength) {
            if (PreviousMode != KernelMode) {
                ProbeForRead(InputBuffer, InputBufferLength, sizeof(UCHAR));
            }
            RtlCopyMemory(LocalInputBuffer, InputBuffer, InputBufferLength);
        }
        Status =
            NatpExecuteIoDeviceControl(
                NULL,
                FileObject,
                PreviousMode,
                LocalInputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength,
                IoControlCode,
                &Size
                );
        if (Status != STATUS_PENDING && NT_SUCCESS(Status)) {
            IoStatus->Information = Size;
            IoStatus->Status = Status;
        } else {
            Status = STATUS_PENDING;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        if (LocalInputBuffer) { ExFreePool(LocalInputBuffer); }
        return FALSE;
    }
    if (LocalInputBuffer) { ExFreePool(LocalInputBuffer); }
    return ((Status == STATUS_PENDING) ? FALSE : TRUE);
} // NatFastIoDeviceControl


NTSTATUS
NatpExecuteIoDeviceControl(
    PIRP Irp,
    PFILE_OBJECT FileObject,
    MODE RequestorMode,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    ULONG IoControlCode,
    PULONG Size
    )

/*++

Routine Description:

    This routine is invoked to handle I/O controls, either in the context
    of the requesting thread (via FastIoDispatch) or in the context of a
    system thread (with a corresponding IRP).

    For certain requests, particularly those requiring output information,
    we return 'STATUS_PENDING' when invoked in the fast path since we cannot
    write into the output buffer at raised IRQL. Instead, we wait to be
    reinvoked via the slow path with a non-paged system buffer.

Arguments:

    Irp - in the slow-path, the IRP associated with the control;
        in the fast-path, NULL

    FileObject - the file-object associated with the control

    RequestorMode - indicates whether the requestor is in kernel-mode
        or user-mode

    InputBuffer/InputBufferLength - describe data passed in with the control;
        may be user-mode or kernel-mode buffer

    OutputBuffer/OutputBufferLength - describe space in which to return
        information; may be user-mode or kernel-mode buffer

    IoControlCode - indicates control requested

    Size - on output, number of bytes stored in 'OutputBuffer'.

Return Value:

    NTSTATUS - status code.

--*/

{
    PIP_ADAPTER_BINDING_INFO BindingInfo;
    PRTR_TOC_ENTRY Entry;
    PRTR_INFO_BLOCK_HEADER Header;
    ULONG i;
    NTSTATUS status = STATUS_SUCCESS;

    *Size = 0;

    switch (IoControlCode) {

        case IOCTL_IP_NAT_REQUEST_NOTIFICATION: {

            if (!Irp) { return STATUS_PENDING; }
            if (InputBufferLength < sizeof(IP_NAT_REQUEST_NOTIFICATION)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatRequestNotification(
                    (PIP_NAT_REQUEST_NOTIFICATION)InputBuffer,
                    Irp,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_SET_GLOBAL_INFO: {
            status =
                NatpSetGlobalInfo(
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength,
                    Size
                    );
            break;
        }

        case IOCTL_IP_NAT_CREATE_INTERFACE: {

            if (InputBufferLength <
                sizeof(IP_NAT_CREATE_INTERFACE) +
                sizeof(IP_ADAPTER_BINDING_INFO)
                ) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            } 

            BindingInfo =
                (PIP_ADAPTER_BINDING_INFO)
                    ((PIP_NAT_CREATE_INTERFACE)InputBuffer)->BindingInfo;
            if (BindingInfo->AddressCount >= MAXLONG / sizeof(NAT_ADDRESS) ||
                SIZEOF_IP_BINDING(BindingInfo->AddressCount) +
                sizeof(IP_NAT_CREATE_INTERFACE) > InputBufferLength) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            status =
                NatCreateInterface(
                    (PIP_NAT_CREATE_INTERFACE)InputBuffer,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_DELETE_INTERFACE: {

            if (InputBufferLength != sizeof(ULONG)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatDeleteInterface(
                    *(PULONG)InputBuffer,
                    FileObject
                    );
            if (status == STATUS_PENDING) {
                //
                // A return of STATUS_PENDING indicates that the interface
                // is now marked for deletion but an active thread holds
                // a reference to it; convert this to a STATUS_SUCCESS code
                // to avoid bypassing our IRP-completion code in 'NatDispatch'.
                //
                status = STATUS_SUCCESS;
            }
            break;
        }

        case IOCTL_IP_NAT_SET_INTERFACE_INFO: {

            if (InputBufferLength <
                FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
                FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry)
                ) {   
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            Header = &((PIP_NAT_INTERFACE_INFO)InputBuffer)->Header;

            if (!NatpValidateHeader(
                    Header,
                    InputBufferLength -
                    FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header)
                    )) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }
                
            status =
                NatConfigureInterface(
                    (PIP_NAT_INTERFACE_INFO)InputBuffer,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_GET_INTERFACE_INFO: {

            *Size = OutputBufferLength;

            if (InputBufferLength != sizeof(ULONG)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryInformationInterface(
                    *(PULONG)InputBuffer,
                    (PIP_NAT_INTERFACE_INFO)OutputBuffer,
                    Size
                    );
            break;
        }

        case IOCTL_IP_NAT_GET_INTERFACE_STATISTICS: {

            if (InputBufferLength != sizeof(ULONG)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength < sizeof(IP_NAT_INTERFACE_STATISTICS)) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *Size = sizeof(IP_NAT_INTERFACE_STATISTICS);

            status =
                NatQueryStatisticsInterface(
                    *(PULONG)InputBuffer,
                    (PIP_NAT_INTERFACE_STATISTICS)OutputBuffer
                    );
            break;
        }

        case IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE: {

            if (!Irp) { return STATUS_PENDING; }

            *Size = OutputBufferLength;

            if (InputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                    EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                    EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryInterfaceMappingTable(
                    (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)InputBuffer,
                    (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)OutputBuffer,
                    Size
                    );
            break;
        }

        case IOCTL_IP_NAT_GET_MAPPING_TABLE: {

            if (!Irp) { return STATUS_PENDING; }

            *Size = OutputBufferLength;

            if (InputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                    EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                    EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryMappingTable(
                    (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)InputBuffer,
                    (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)OutputBuffer,
                    Size
                    );
            break;
        }

        case IOCTL_IP_NAT_REGISTER_DIRECTOR: {

            *Size = sizeof(IP_NAT_REGISTER_DIRECTOR);

            //
            // Only kernel-mode drivers can register as directors
            //

            if (RequestorMode != KernelMode ||
                SharedUserData->NtProductType == NtProductWinNt) {
                status = STATUS_ACCESS_DENIED;
                break;
            }

            if (InputBufferLength != sizeof(IP_NAT_REGISTER_DIRECTOR)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength < sizeof(IP_NAT_REGISTER_DIRECTOR)) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Perform the director-registration
            //

            status =
                NatCreateDirector(
                    (PIP_NAT_REGISTER_DIRECTOR)InputBuffer
                    );
            break;
        }

        case IOCTL_IP_NAT_GET_DIRECTOR_TABLE: {

            if (!Irp) { return STATUS_PENDING; }

            *Size = OutputBufferLength;

            if (InputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_DIRECTORS, EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_DIRECTORS, EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryDirectorTable(
                    (PIP_NAT_ENUMERATE_DIRECTORS)InputBuffer,
                    (PIP_NAT_ENUMERATE_DIRECTORS)OutputBuffer,
                    Size
                    );
            break;
        }

        case IOCTL_IP_NAT_REGISTER_EDITOR: {

            *Size = sizeof(IP_NAT_REGISTER_EDITOR);

            //
            // Only kernel-mode drivers can register as editors
            //

            if (RequestorMode != KernelMode) {
                status = STATUS_ACCESS_DENIED;
                break;
            }

            if (InputBufferLength != sizeof(IP_NAT_REGISTER_EDITOR)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength < sizeof(IP_NAT_REGISTER_EDITOR)) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Perform the editor-registration
            //

            status = NatCreateEditor((PIP_NAT_REGISTER_EDITOR)InputBuffer);
            break;
        }

        case IOCTL_IP_NAT_GET_EDITOR_TABLE: {

            if (!Irp) { return STATUS_PENDING; }

            *Size = OutputBufferLength;

            if (InputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_EDITORS, EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength <
                FIELD_OFFSET(IP_NAT_ENUMERATE_EDITORS, EnumerateTable)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryEditorTable(
                    (PIP_NAT_ENUMERATE_EDITORS)InputBuffer,
                    (PIP_NAT_ENUMERATE_EDITORS)OutputBuffer,
                    Size
                    );
            break;
        }

        case IOCTL_IP_NAT_CREATE_REDIRECT: {

            if (!Irp) { return STATUS_PENDING; }
#if 0
            if (SharedUserData->NtProductType == NtProductWinNt) {
                status = STATUS_ACCESS_DENIED;
                break;
            }
#endif

            if (InputBufferLength != sizeof(IP_NAT_CREATE_REDIRECT) ||
                OutputBufferLength != sizeof(IP_NAT_REDIRECT_STATISTICS)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatCreateRedirect(
                    (PIP_NAT_CREATE_REDIRECT)InputBuffer,
                    Irp,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_CREATE_REDIRECT_EX: {

            if (!Irp) { return STATUS_PENDING; }
#if 0
            if (SharedUserData->NtProductType == NtProductWinNt) {
                status = STATUS_ACCESS_DENIED;
                break;
            }
#endif

            if (InputBufferLength != sizeof(IP_NAT_CREATE_REDIRECT_EX) ||
                OutputBufferLength != sizeof(IP_NAT_REDIRECT_STATISTICS)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatCreateRedirectEx(
                    (PIP_NAT_CREATE_REDIRECT_EX)InputBuffer,
                    Irp,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_CANCEL_REDIRECT: {

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_REDIRECT)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatCancelRedirect(
                    (PIP_NAT_LOOKUP_REDIRECT)InputBuffer,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_GET_REDIRECT_STATISTICS: {

            if (!Irp) { return STATUS_PENDING; }

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_REDIRECT) ||
                OutputBufferLength != sizeof(IP_NAT_REDIRECT_STATISTICS)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryInformationRedirect(
                    (PIP_NAT_LOOKUP_REDIRECT)InputBuffer,
                    OutputBuffer,
                    OutputBufferLength,
                    NatStatisticsRedirectInformation
                    );
            if (NT_SUCCESS(status)) { *Size = OutputBufferLength; }
            break;
        }

        case IOCTL_IP_NAT_GET_REDIRECT_DESTINATION_MAPPING: {

            if (!Irp) { return STATUS_PENDING; }

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_REDIRECT) ||
                OutputBufferLength !=
                sizeof(IP_NAT_REDIRECT_DESTINATION_MAPPING)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryInformationRedirect(
                    (PIP_NAT_LOOKUP_REDIRECT)InputBuffer,
                    OutputBuffer,
                    OutputBufferLength,
                    NatDestinationMappingRedirectInformation
                    );
            if (NT_SUCCESS(status)) { *Size = OutputBufferLength; }
            break;
        }

        case IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING: {

            if (!Irp) { return STATUS_PENDING; }

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_REDIRECT) ||
                OutputBufferLength != sizeof(IP_NAT_REDIRECT_SOURCE_MAPPING)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatQueryInformationRedirect(
                    (PIP_NAT_LOOKUP_REDIRECT)InputBuffer,
                    OutputBuffer,
                    OutputBufferLength,
                    NatSourceMappingRedirectInformation
                    );
            if (NT_SUCCESS(status)) { *Size = OutputBufferLength; }
            break;
        }

        case IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY: {
            PIP_NAT_LOOKUP_SESSION_MAPPING LookupMapping;

            if (!Irp) { return STATUS_PENDING; }

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_SESSION_MAPPING) ||
                OutputBufferLength != sizeof(IP_NAT_SESSION_MAPPING_KEY)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            LookupMapping = (PIP_NAT_LOOKUP_SESSION_MAPPING)InputBuffer;
            status =
                NatLookupAndQueryInformationMapping(
                    LookupMapping->Protocol,
                    LookupMapping->DestinationAddress,
                    LookupMapping->DestinationPort,
                    LookupMapping->SourceAddress,
                    LookupMapping->SourcePort,
                    OutputBuffer,
                    OutputBufferLength,
                    NatKeySessionMappingInformation
                    );
            if (NT_SUCCESS(status)) { *Size = OutputBufferLength; }
            break;
        }

        case IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY_EX: {
            PIP_NAT_LOOKUP_SESSION_MAPPING LookupMapping;

            if (!Irp) { return STATUS_PENDING; }

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_SESSION_MAPPING) ||
                OutputBufferLength != sizeof(IP_NAT_SESSION_MAPPING_KEY_EX)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            LookupMapping = (PIP_NAT_LOOKUP_SESSION_MAPPING)InputBuffer;
            status =
                NatLookupAndQueryInformationMapping(
                    LookupMapping->Protocol,
                    LookupMapping->DestinationAddress,
                    LookupMapping->DestinationPort,
                    LookupMapping->SourceAddress,
                    LookupMapping->SourcePort,
                    OutputBuffer,
                    OutputBufferLength,
                    NatKeySessionMappingExInformation
                    );
            if (NT_SUCCESS(status)) { *Size = OutputBufferLength; }
            break;
        }

        case IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_STATISTICS: {
            PIP_NAT_LOOKUP_SESSION_MAPPING LookupMapping;

            if (!Irp) { return STATUS_PENDING; }

            if (InputBufferLength != sizeof(IP_NAT_LOOKUP_SESSION_MAPPING) ||
                OutputBufferLength != sizeof(IP_NAT_SESSION_MAPPING_STATISTICS)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            LookupMapping = (PIP_NAT_LOOKUP_SESSION_MAPPING)InputBuffer;
            status =
                NatLookupAndQueryInformationMapping(
                    LookupMapping->Protocol,
                    LookupMapping->DestinationAddress,
                    LookupMapping->DestinationPort,
                    LookupMapping->SourceAddress,
                    LookupMapping->SourcePort,
                    OutputBuffer,
                    OutputBufferLength,
                    NatStatisticsSessionMappingInformation
                    );
            if (NT_SUCCESS(status)) { *Size = OutputBufferLength; }
            break;
        }

        case IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET: {

            if (InputBufferLength < sizeof(IP_NAT_CREATE_DYNAMIC_TICKET)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatCreateDynamicTicket(
                    (PIP_NAT_CREATE_DYNAMIC_TICKET)InputBuffer,
                    InputBufferLength,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET: {

            if (InputBufferLength != sizeof(IP_NAT_DELETE_DYNAMIC_TICKET)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatDeleteDynamicTicket(
                    (PIP_NAT_DELETE_DYNAMIC_TICKET)InputBuffer,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_CREATE_TICKET: {

            if (InputBufferLength != sizeof(IP_NAT_CREATE_TICKET)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatProcessCreateTicket(
                    (PIP_NAT_CREATE_TICKET)InputBuffer,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_DELETE_TICKET: {

            if (InputBufferLength != sizeof(IP_NAT_CREATE_TICKET)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatProcessDeleteTicket(
                    (PIP_NAT_CREATE_TICKET)InputBuffer,
                    FileObject
                    );
            break;
        }

        case IOCTL_IP_NAT_LOOKUP_TICKET: {

            if (InputBufferLength != sizeof(IP_NAT_CREATE_TICKET)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            if (OutputBufferLength != sizeof(IP_NAT_PORT_MAPPING)) {
                status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            status =
                NatProcessLookupTicket(
                    (PIP_NAT_CREATE_TICKET)InputBuffer,
                    (PIP_NAT_PORT_MAPPING)OutputBuffer,
                    FileObject
                    );
            break;

        }

        default: {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    return status;

} // NatpExecuteIoDeviceControl


NTSTATUS
NatpSetGlobalInfo(
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG Size
    )

/*++

Routine Description:

    This routine is invoked upon receipt of the NAT's configuration.

Arguments:

    InputBuffer/InputBufferLength - describe configuration information

    OutputBuffer/OutputBufferLength - unused.

    Size - unused

Return Value:

    NTSTATUS - status code.

--*/

{
    PRTR_TOC_ENTRY Entry;
    PRTR_INFO_BLOCK_HEADER Header;
    ULONG i;
    ULONG Protocol;

    if (InputBufferLength <
        FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
        FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry)
        ) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    Header = &((PIP_NAT_GLOBAL_INFO)InputBuffer)->Header;

    if (!NatpValidateHeader(
            Header,
            InputBufferLength - FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header)
            )) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    for (i = 0; i < Header->TocEntriesCount; i++) {

        Entry = &Header->TocEntry[i];
        switch (Entry->InfoType) {

            case IP_NAT_TIMEOUT_TYPE: {
                PIP_NAT_TIMEOUT Timeout = GetInfoFromTocEntry(Header,Entry);
                InterlockedExchange(
                    &TcpTimeoutSeconds,
                    Timeout->TCPTimeoutSeconds
                    );
                InterlockedExchange(
                    &UdpTimeoutSeconds,
                    Timeout->UDPTimeoutSeconds
                    );
                break;
            }

            case IP_NAT_PROTOCOLS_ALLOWED_TYPE: {
                PIP_NAT_PROTOCOLS_ALLOWED ProtocolsAllowed =
                    GetInfoFromTocEntry(Header,Entry);
                //
                // The protocols allowed are specified using a 256-bit bitmap;
                // an allowed protocol has the bit for its protocol number set.
                // For each protocol enabled in the bitmap, we now install the
                // default IP-header translation routine, with the exception
                // of protocols which are always enabled.
                //
                #define IS_BIT_SET(b,i) ((b)[(i) / 32] & (1 << ((i) & 31)))
                for (Protocol = 0; Protocol < 256; Protocol++) {
                    if (Protocol == NAT_PROTOCOL_ICMP ||
                        Protocol == NAT_PROTOCOL_PPTP ||
                        Protocol == NAT_PROTOCOL_TCP ||
                        Protocol == NAT_PROTOCOL_UDP
                        ) {
                        continue;
                    }
                    if (IS_BIT_SET(ProtocolsAllowed->Bitmap, Protocol)) {
                        InterlockedExchangePointer(
                            (PVOID)TranslateRoutineTable[Protocol],
                            (PVOID)NatTranslateIp
                            );
                    }
                    else {
                        InterlockedExchangePointer(
                            (PVOID)TranslateRoutineTable[Protocol],
                            NULL
                            );
                    }
                }
                break;
            }
        }
    }

    return STATUS_SUCCESS;
}


BOOLEAN FASTCALL
NatpValidateHeader(
    PRTR_INFO_BLOCK_HEADER Header,
    ULONG Size
    )

/*++

Routine Description:

    This routine is invoked to ensure that the given header is consistent.
    This is the case if
    * the header's size is less than or equal to 'Size'
    * each entry in the header is contained in 'Header->Size'.
    * the data for each entry is contained in 'Header->Size'.

Arguments:

    Header - the header to be validated

    Size - the size of the buffer in which 'Header' appears

Return Value:

    BOOLEAN - TRUE if valid, FALSE otherwise.

--*/

{
    ULONG i;
    ULONG64 Length;

    //
    // Check that the base structure is present
    //

    if (Size < FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry) ||
        Size < Header->Size) {
        return FALSE;
    }

    //
    // Check that the table of contents is present
    //

    Length = (ULONG64)Header->TocEntriesCount * sizeof(RTR_TOC_ENTRY);
    if (Length > MAXLONG) {
        return FALSE;
    }

    Length += FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);
    if (Length > Header->Size) {
        return FALSE;
    }

    //
    // Check that all the data is present
    //

    for (i = 0; i < Header->TocEntriesCount; i++) {
        Length =
            (ULONG64)Header->TocEntry[i].Count * Header->TocEntry[i].InfoSize;
        if (Length > MAXLONG) {
            return FALSE;
        }
        if ((Length + Header->TocEntry[i].Offset) > Header->Size) {
            return FALSE;
        }
    }

    return TRUE;

} // NatpValidateHeader
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\director.h ===
/*++

Module Name:

    director.h

Abstract:

    This module contains declarations for the NAT's director-handling.
    Directors are consulted about the routing of incoming sessions.

Author:

    Abolade Gbadegesin  (aboladeg)  16-Feb-1998

Revision History:

    Abolade Gbadegesin  (aboladeg)  19-Apr-1998

    Added support for wildcards in protocol/port of a director registration.

--*/

#ifndef _NAT_DIRECTOR_H_
#define _NAT_DIRECTOR_H_

//
// Structure:   NAT_DIRECTOR
//
// Holds information about a director
//
// Each director is on a global list ('DirectorList') which is protected
// by a spin lock ('DirectorLock'). The list is sorted on a key composed of
// the protocol of the sessions to be edited and the protocol port number.
//
// N.B. The list is sorted in **descending** order. We allow wildcard
// registrations (e.g. port 0 means any port) so when searching for a director,
// using descending order allows us to find more specific matches before
// less-specific matches. The composition of the keys is critical in making
// this work; the protocol is in the most-significant part of the key,
// and the port is in the less-significant part.
//
// Access to directors is synchronized using the same reference-counting logic
// used to synchronize access to interfaces. See 'IF.H' for more information.
//
// Each session being directed by a director is linked into the director's list
// of mappings ('MappingList'). Access to this list of mappings must also 
// be synchronized. This is achieved using 'DirectorMappingLock', which
// must be acquired before modifying any director's list of mappings.
// See 'MAPPING.H' for further details.
//
// N.B. On the rare occasions when 'MappingLock' must be held at the same time
// as one of 'InterfaceLock', 'EditorLock', and 'DirectorLock', 'MappingLock'
// must always be acquired first. Again, see 'MAPPING.H' for further details.
//

typedef struct _NAT_DIRECTOR {
    LIST_ENTRY Link;
    ULONG Key;
    ULONG ReferenceCount;
    KSPIN_LOCK Lock;
    LIST_ENTRY MappingList;
    ULONG Flags;
    PVOID Context;                                  // read-only
    PNAT_DIRECTOR_QUERY_SESSION QueryHandler;       // read-only
    PNAT_DIRECTOR_CREATE_SESSION CreateHandler;     // read-only
    PNAT_DIRECTOR_DELETE_SESSION DeleteHandler;     // read-only
    PNAT_DIRECTOR_UNLOAD UnloadHandler;             // read-only
} NAT_DIRECTOR, *PNAT_DIRECTOR;

//
// Definitions of flags for the field NAT_DIRECTOR.Flags
//

#define NAT_DIRECTOR_FLAG_DELETED       0x80000000
#define NAT_DIRECTOR_DELETED(Director) \
    ((Director)->Flags & NAT_DIRECTOR_FLAG_DELETED)

//
// Director key-manipulation macros
//

#define MAKE_DIRECTOR_KEY(Protocol,Port) \
    (((ULONG)((Protocol) & 0xFF) << 16) | \
     (ULONG)((Port) & 0xFFFF))

#define DIRECTOR_KEY_PORT(Key)        ((USHORT)((Key) & 0x0000FFFF))
#define DIRECTOR_KEY_PROTOCOL(Key)    ((UCHAR)((Key) >> 16))


//
// GLOBAL DATA DECLARATIONS
//

extern ULONG DirectorCount;
extern LIST_ENTRY DirectorList;
extern KSPIN_LOCK DirectorLock;
extern KSPIN_LOCK DirectorMappingLock;


//
// DIRECTOR MANAGEMENT ROUTINES
//

VOID
NatCleanupDirector(
    PNAT_DIRECTOR Director
    );

NTSTATUS
NatCreateDirector(
    PIP_NAT_REGISTER_DIRECTOR     RegisterContext
    );

NTSTATUS
NatDeleteDirector(
    PNAT_DIRECTOR Director
    );

//
// BOOLEAN
// NatDereferenceDirector(
//     PNAT_DIRECTOR Director
//     );
//

#define \
NatDereferenceDirector( \
    _Director \
    ) \
    (InterlockedDecrement(&(_Director)->ReferenceCount) \
        ? TRUE \
        : NatCleanupDirector(_Director), FALSE)

VOID
NatInitializeDirectorManagement(
    VOID
    );

PNAT_DIRECTOR
NatLookupAndReferenceDirector(
    UCHAR Protocol,
    USHORT Port
    );

PNAT_DIRECTOR
NatLookupDirector(
    ULONG Key,
    PLIST_ENTRY* InsertionPoint
    );

struct _NAT_DYNAMIC_MAPPING;

VOID
NatMappingAttachDirector(
    PNAT_DIRECTOR Director,
    PVOID DirectorSessionContext,
    struct _NAT_DYNAMIC_MAPPING* Mapping
    );

VOID
NatMappingDetachDirector(
    PNAT_DIRECTOR Director,
    PVOID DirectorSessionContext,
    struct _NAT_DYNAMIC_MAPPING* Mapping,
    IP_NAT_DELETE_REASON DeleteReason
    );

NTSTATUS
NatQueryDirectorTable(
    IN PIP_NAT_ENUMERATE_DIRECTORS InputBuffer,
    IN PIP_NAT_ENUMERATE_DIRECTORS OutputBuffer,
    IN PULONG OutputBufferLength
    );

//
// BOOLEAN
// NatReferenceDirector(
//     PNAT_DIRECTOR Director
//     );
//

#define \
NatReferenceDirector( \
    _Director \
    ) \
    (NAT_DIRECTOR_DELETED(_Director) \
        ? FALSE \
        : InterlockedIncrement(&(_Director)->ReferenceCount), TRUE)

VOID
NatShutdownDirectorManagement(
    VOID
    );

//
// HELPER ROUTINES
//

NTSTATUS
NatDirectorDeregister(
    IN PVOID DirectorHandle
    );

NTSTATUS
NatDirectorDissociateSession(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

VOID
NatDirectorQueryInfoSession(
    IN PVOID SessionHandle,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

#endif // _NAT_DIRECTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\director.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    director.c

Abstract:

    This module contains the code for director management.

Author:

    Abolade Gbadegesin (t-abolag)   16-Feb-1998

Revision History:

    Abolade Gbadegesin  (aboladeg)  19-Apr-1998

    Added support for wildcards in protocol/port of a director registration.

--*/

#include "precomp.h"
#pragma hdrstop

//
// GLOBAL DATA DEFINITIONS
//

//
// Count of NAT directors
//

ULONG DirectorCount;

//
// List of NAT directors
//

LIST_ENTRY DirectorList;

//
// Spin-lock controlling access to 'DirectorList'
//

KSPIN_LOCK DirectorLock;

//
// Spin-lock controlling access to the 'MappingList' field of all directors
//

KSPIN_LOCK DirectorMappingLock;


VOID
NatCleanupDirector(
    PNAT_DIRECTOR Director
    )

/*++

Routine Description:

    Called to perform final cleanup for an director.

Arguments:

    Director - the director to be cleaned up.

Return Value:

    none.

--*/

{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;

    CALLTRACE(("NatCleanupDirector\n"));

    //
    // Detach the director from all of its mappings
    //

    KeAcquireSpinLock(&DirectorLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&DirectorMappingLock);
    for (Link = Director->MappingList.Flink; Link != &Director->MappingList;
         Link = Link->Flink) {
        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, DirectorLink);
        Link = Link->Blink;
        NatMappingDetachDirector(
            Director,
            Mapping->DirectorContext,
            Mapping,
            NatCleanupDirectorDeleteReason
            );
    }
    KeReleaseSpinLockFromDpcLevel(&DirectorMappingLock);
    KeReleaseSpinLock(&DirectorLock, Irql);

    if (Director->UnloadHandler) {
        Director->UnloadHandler(Director->Context);
    }

    ExFreePool(Director);

} // NatCleanupDirector



NTSTATUS
NatCreateDirector(
    PIP_NAT_REGISTER_DIRECTOR RegisterContext
    )

/*++

Routine Description:

    This routine is invoked when an director attempts to register.
    It handles creation of a context-block for the director.

Arguments:

    RegisterContext - information about the registering director

Return Value:

    NTSTATUS - status code.

--*/

{
    PNAT_DIRECTOR Director;
    PLIST_ENTRY InsertionPoint;
    KIRQL Irql;
    ULONG Key;

    CALLTRACE(("NatCreateDirector\n"));

    RegisterContext->DirectorHandle = NULL;

    //
    // Validate the registration information
    //

    if (!RegisterContext->QueryHandler &&
        !RegisterContext->CreateHandler &&
        !RegisterContext->DeleteHandler &&
        !RegisterContext->UnloadHandler) {
        ERROR(("NatCreateDirector: bad argument\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a new director-struct
    //

    Director =
        ExAllocatePoolWithTag(
            NonPagedPool, sizeof(NAT_DIRECTOR), NAT_TAG_DIRECTOR
            );

    if (!Director) {
        ERROR(("NatCreateDirector: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    KeInitializeSpinLock(&Director->Lock);
    Director->ReferenceCount = 1;
    Director->Flags = RegisterContext->Flags;
    Director->Key =
        MAKE_DIRECTOR_KEY(RegisterContext->Protocol, RegisterContext->Port);
    InitializeListHead(&Director->MappingList);
    Director->Context = RegisterContext->DirectorContext;
    Director->CreateHandler = RegisterContext->CreateHandler;
    Director->DeleteHandler = RegisterContext->DeleteHandler;
    Director->QueryHandler = RegisterContext->QueryHandler;
    Director->UnloadHandler = RegisterContext->UnloadHandler;

    KeAcquireSpinLock(&DirectorLock, &Irql);
    if (NatLookupDirector(Director->Key, &InsertionPoint)) {
        KeReleaseSpinLock(&DirectorLock, Irql);
        ERROR(
            ("NatCreateDirector: duplicate director %d/%d\n",
            RegisterContext->Protocol, RegisterContext->Port)
            );
        ExFreePool(Director);
        return STATUS_UNSUCCESSFUL;
    }
    InsertTailList(InsertionPoint, &Director->Link);
    KeReleaseSpinLock(&DirectorLock, Irql);

    InterlockedIncrement(&DirectorCount);

    //
    // Supply the caller with 'out' information
    //

    RegisterContext->DirectorHandle = (PVOID)Director;
    RegisterContext->QueryInfoSession = NatDirectorQueryInfoSession;
    RegisterContext->Deregister = NatDirectorDeregister;
    RegisterContext->DissociateSession = NatDirectorDissociateSession;

    return STATUS_SUCCESS;

} // NatCreateDirector



NTSTATUS
NatDeleteDirector(
    PNAT_DIRECTOR Director
    )

/*++

Routine Description:

    Handles director deletion.

Arguments:

    Director - specifies the director to be deleted.

Return Value

    NTSTATUS - status code.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatDeleteDirector\n"));
    if (!Director) { return STATUS_INVALID_PARAMETER; }
    InterlockedDecrement(&DirectorCount);

    //
    // Remove the director from the list
    //

    KeAcquireSpinLock(&DirectorLock, &Irql);
    RemoveEntryList(&Director->Link);
    Director->Flags |= NAT_DIRECTOR_FLAG_DELETED;
    KeReleaseSpinLock(&DirectorLock, Irql);

    //
    // Drop its reference count and cleanup if necessary
    //

    if (InterlockedDecrement(&Director->ReferenceCount) > 0) {
        return STATUS_PENDING;
    }
    NatCleanupDirector(Director);
    return STATUS_SUCCESS;

} // NatDeleteDirector


VOID
NatInitializeDirectorManagement(
    VOID
    )

/*++

Routine Description:

    This routine prepares the director-management module for operation.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeDirectorManagement\n"));

    DirectorCount = 0;
    KeInitializeSpinLock(&DirectorLock);
    InitializeListHead(&DirectorList);
    KeInitializeSpinLock(&DirectorMappingLock);

} // NatInitializeDirectorManagement


PNAT_DIRECTOR
NatLookupAndReferenceDirector(
    UCHAR Protocol,
    USHORT Port
    )

/*++

Routine Description:

    This routine is called to search for a director for the given
    incoming protocol and port, and to obtain a referenced pointer
    to such a director.

    This routine must be invoked at DISPATCH_LEVEL.

Arguments:

    Protocol - the protocol of the director to be looked up

    Port - the port-number of the director to be looked up

Return Value:

    PNAT_DIRECTOR - the references director if found; NULL otherwise.

--*/

{
    PNAT_DIRECTOR Director;
    ULONG Key;
    PLIST_ENTRY Link;

    KeAcquireSpinLockAtDpcLevel(&DirectorLock);

    if (IsListEmpty(&DirectorList)) {
        KeReleaseSpinLockFromDpcLevel(&DirectorLock); return NULL;
    }
    Key = MAKE_DIRECTOR_KEY(Protocol, Port);

    //
    // Our support for wildcards takes advantage of the fact that
    // all wildcards are designated by zero; hence, since our list
    // is in descending order we only need to look for wildcards
    // at the point where we would break off a normal search.
    //

    for (Link = DirectorList.Flink; Link != &DirectorList; Link = Link->Flink) {
        Director = CONTAINING_RECORD(Link, NAT_DIRECTOR, Link);
        if (Key < Director->Key) {
            continue;
        } else if (Key > Director->Key) {
            //
            // End of normal search. Now look for wildcards
            //
            do {
                if ((!DIRECTOR_KEY_PROTOCOL(Director->Key) ||
                     Protocol == DIRECTOR_KEY_PROTOCOL(Director->Key)) &&
                    (!DIRECTOR_KEY_PORT(Director->Key) ||
                     Port == DIRECTOR_KEY_PORT(Director->Key))) {
                    //
                    // We have a matching wildcard.
                    //
                    break;
                }
                Link = Link->Flink;
            } while (Link != &DirectorList);
            if (Link == &DirectorList) { break; }
        }

        //
        // We've found it. Reference it and return.
        //

        if (!NatReferenceDirector(Director)) { Director = NULL; }
        KeReleaseSpinLockFromDpcLevel(&DirectorLock);
        return Director;
    }

    KeReleaseSpinLockFromDpcLevel(&DirectorLock);

    return NULL;

} // NatLookupAndReferenceDirector


PNAT_DIRECTOR
NatLookupDirector(
    ULONG Key,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to retrieve the director corresponding to the given
    key.

Arguments:

    Key - the key for which an director is to be found

    InsertionPoint - receives the point at which the director should be
        inserted if not found

Return Value:

    PNAT_DIRECTOR - the required director, if found

--*/

{
    PNAT_DIRECTOR Director;
    PLIST_ENTRY Link;
    for (Link = DirectorList.Flink; Link != &DirectorList; Link = Link->Flink) {
        Director = CONTAINING_RECORD(Link, NAT_DIRECTOR, Link);
        if (Key < Director->Key) {
            continue;
        } else if (Key > Director->Key) {
            break;
        }
        return Director;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // NatLookupDirector


VOID
NatMappingAttachDirector(
    PNAT_DIRECTOR Director,
    PVOID DirectorSessionContext,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine is invoked to attach a mapping to a director.
    It serves as a notification that there is one more mapping 
    associated with the director.

Arguments:

    Director - the director for the mapping

    DirectorSessionContext - context associated with the mapping by the director

    Mapping - the mapping to be attached.

Return Value:

    none.

Environment:

    Always invoked at dispatch level with 'DirectorLock' and
    'DirectorMappingLock' held by the caller.

--*/

{
    Mapping->Director = Director;
    Mapping->DirectorContext = DirectorSessionContext;
    InsertTailList(&Director->MappingList, &Mapping->DirectorLink);
    if (Director->CreateHandler) {
        Director->CreateHandler(
            Mapping,
            Director->Context,
            DirectorSessionContext
            );
    }
} // NatMappingAttachDirector


VOID
NatMappingDetachDirector(
    PNAT_DIRECTOR Director,
    PVOID DirectorSessionContext,
    PNAT_DYNAMIC_MAPPING Mapping,
    IP_NAT_DELETE_REASON DeleteReason
    )

/*++

Routine Description:

    This routine is invoked to detach a mapping from a director.
    It serves as a notification that there is one less mapping 
    associated with the director.

Arguments:

    Director - director to be detached

    DirectorSessionContext - context associated with the director

    Mapping - the mapping to be detached, or NULL if a mapping could not be
        created.

Return Value:

    none.

Environment:

    Always invoked at dispatch level with 'DirectorLock' and
    'DirectorMappingLock' held, in that order.

--*/

{
    KIRQL Irql;
    if (!Mapping) {
        if (Director->DeleteHandler) {
            Director->DeleteHandler(
                NULL,
                Director->Context,
                DirectorSessionContext,
                DeleteReason
                );
        }
    } else {
        if (Director->DeleteHandler) {
            Director->DeleteHandler(
                Mapping,
                Director->Context,
                Mapping->DirectorContext,
                DeleteReason
                );
        }
        RemoveEntryList(&Mapping->DirectorLink);
        Mapping->Director = NULL;
        Mapping->DirectorContext = NULL;
    }
} // NatMappingDetachDirector


NTSTATUS
NatQueryDirectorTable(
    IN PIP_NAT_ENUMERATE_DIRECTORS InputBuffer,
    IN PIP_NAT_ENUMERATE_DIRECTORS OutputBuffer,
    IN PULONG OutputBufferLength
    )

/*++

Routine Description:

    This routine is used for enumerating the registered directors.

Arguments:

    InputBuffer - supplies context information for the information

    OutputBuffer - receives the result of the enumeration

    OutputBufferLength - size of the i/o buffer

Return Value:

    STATUS_SUCCESS if successful, error code otherwise.

--*/

{
    ULONG Count;
    ULONG i;
    KIRQL Irql;
    ULONG Key;
    PLIST_ENTRY Link;
    PNAT_DIRECTOR Director;
    NTSTATUS status;
    PIP_NAT_DIRECTOR Table;

    CALLTRACE(("NatQueryDirectorTable\n"));

    Key = InputBuffer->EnumerateContext;
    KeAcquireSpinLock(&DirectorLock, &Irql);

    //
    // See if this is a new enumeration or a continuation of an old one.
    //

    if (!Key) {

        //
        // This is a new enumeration. We start with the first item
        // in the list of entries
        //

        Director =
            IsListEmpty(&DirectorList)
                ? NULL
                : CONTAINING_RECORD(DirectorList.Flink, NAT_DIRECTOR, Link);
    } else {

        //
        // This is a continuation. The context therefore contains
        // the key for the next entry.
        //

        Director = NatLookupDirector(Key, NULL);
    }

    if (!Director) {
        OutputBuffer->EnumerateCount = 0;
        OutputBuffer->EnumerateContext = 0;
        OutputBuffer->EnumerateTotalHint = DirectorCount;
        *OutputBufferLength =
            FIELD_OFFSET(IP_NAT_ENUMERATE_DIRECTORS, EnumerateTable);
        KeReleaseSpinLock(&DirectorLock, Irql);
        return STATUS_SUCCESS;
    }

    //
    // Compute the maximum number of entries we can store
    //

    Count =
        *OutputBufferLength -
        FIELD_OFFSET(IP_NAT_ENUMERATE_DIRECTORS, EnumerateTable);
    Count /= sizeof(IP_NAT_DIRECTOR);

    //
    // Walk the list storing entries in the caller's buffer
    //

    Table = OutputBuffer->EnumerateTable;

    for (i = 0, Link = &Director->Link; i < Count && Link != &DirectorList;
         i++, Link = Link->Flink) {
        Director = CONTAINING_RECORD(Link, NAT_DIRECTOR, Link);
        Table[i].Protocol = DIRECTOR_KEY_PROTOCOL(Director->Key);
        Table[i].Port = DIRECTOR_KEY_PORT(Director->Key);
    }

    //
    // The enumeration is over; update the output structure
    //

    *OutputBufferLength =
        i * sizeof(IP_NAT_DIRECTOR) +
        FIELD_OFFSET(IP_NAT_ENUMERATE_DIRECTORS, EnumerateTable);
    OutputBuffer->EnumerateCount = i;
    OutputBuffer->EnumerateTotalHint = DirectorCount;
    if (Link == &DirectorList) {
        //
        // We reached the end of the list
        //
        OutputBuffer->EnumerateContext = 0;
    } else {
        //
        // Save the continuation context
        //
        OutputBuffer->EnumerateContext =
            CONTAINING_RECORD(Link, NAT_DIRECTOR, Link)->Key;
    }

    KeReleaseSpinLock(&DirectorLock, Irql);
    return STATUS_SUCCESS;

} // NatQueryDirectorTable


VOID
NatShutdownDirectorManagement(
    VOID
    )

/*++

Routine Description:

    This routine shuts down the director-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PNAT_DIRECTOR Director;
    KIRQL Irql;

    CALLTRACE(("NatShutdownDirectorManagement\n"));

    //
    // Delete all directors
    //

    KeAcquireSpinLock(&DirectorLock, &Irql);
    while (!IsListEmpty(&DirectorList)) {
        Director = CONTAINING_RECORD(DirectorList.Flink, NAT_DIRECTOR, Link);
        RemoveEntryList(&Director->Link);
        KeReleaseSpinLockFromDpcLevel(&DirectorLock);
        NatCleanupDirector(Director);
        KeAcquireSpinLockAtDpcLevel(&DirectorLock);
    }
    KeReleaseSpinLock(&DirectorLock, Irql);

} // NatShutdownDirectorManagement



//
// DIRECTOR HELPER ROUTINES
//
// The caller is assumed to be running at DISPATCH_LEVEL.
//

NTSTATUS
NatDirectorDeregister(
    IN PVOID DirectorHandle
    )

/*++

Routine Description:

    This routine is called by a director to remove itself
    from the director list.

Arguments:

    DirectorHandle - handle of the director to be removed.

Return Value:

    NTSTATUS - status code.

--*/

{
    CALLTRACE(("NatDirectorDeregister\n"));
    return NatDeleteDirector((PNAT_DIRECTOR)DirectorHandle);

} // NatDirectorDeregister


NTSTATUS
NatDirectorDissociateSession(
    IN PVOID DirectorHandle,
    IN PVOID SessionHandle
    )

/*++

Routine Description:

    This routine is called by a director to dissociate itself from a specific
    session.

Arguments:

    DirectorHandle - the director which wishes to dissociate itself.

    SessionHandle - the session from which the director is disssociating itself.

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    Invoked at dispatch level with neither 'DirectorLock' nor
    'DirectorMappingLock' held by the caller.

--*/

{

    PNAT_DIRECTOR Director = (PNAT_DIRECTOR)DirectorHandle;
    KIRQL Irql;
    PNAT_DYNAMIC_MAPPING Mapping = (PNAT_DYNAMIC_MAPPING)SessionHandle;
    CALLTRACE(("NatDirectorDissociateSession\n"));
    KeAcquireSpinLock(&DirectorLock, &Irql);
    if (Mapping->Director != Director) {
        KeReleaseSpinLock(&DirectorLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }
    KeAcquireSpinLockAtDpcLevel(&DirectorMappingLock);
    NatMappingDetachDirector(
        Director,
        Mapping->DirectorContext,
        Mapping,
        NatDissociateDirectorDeleteReason
        );
    KeReleaseSpinLockFromDpcLevel(&DirectorMappingLock);
    if (!NAT_MAPPING_DELETE_ON_DISSOCIATE_DIRECTOR(Mapping)) {
        KeReleaseSpinLock(&DirectorLock, Irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&DirectorLock);
        KeAcquireSpinLockAtDpcLevel(&MappingLock);
        NatDeleteMapping(Mapping);
        KeReleaseSpinLock(&MappingLock, Irql);
    }
    return STATUS_SUCCESS;

} // NatDirectorDissociateSession


VOID
NatDirectorQueryInfoSession(
    IN PVOID SessionHandle,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked by a director to obtain information
    about a session.

Arguments:

    SessionHandle - the session for which information is required

    Statistics - receives statistics for the session

Return Value:

    none.

Environment:

    Invoked 
--*/

{
    KIRQL Irql;
    KeAcquireSpinLock(&MappingLock, &Irql);
    NatQueryInformationMapping(
        (PNAT_DYNAMIC_MAPPING)SessionHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        Statistics
        );
    KeReleaseSpinLock(&MappingLock, Irql);
} // NatDirectorQueryInfoSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\editor.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    editor.c

Abstract:

    This module contains the code for editor management.

Author:

    Abolade Gbadegesin (t-abolag)   14-July-1997

Return Value:

--*/

#include "precomp.h"
#pragma hdrstop

//
// GLOBAL DATA DEFINITIONS
//

//
// Count of NAT editors
//

ULONG EditorCount;

//
// List of NAT editors
//

LIST_ENTRY EditorList;

//
// Spin-lock controlling access to 'EditorList'.
//

KSPIN_LOCK EditorLock;

//
// Spin-lock controlling access to the 'MappingList' field of all editors.
//

KSPIN_LOCK EditorMappingLock;


VOID
NatCleanupEditor(
    PNAT_EDITOR Editor
    )

/*++

Routine Description:

    Called to perform final cleanup for an editor.

Arguments:

    Editor - the editor to be cleaned up.

Return Value:

    none.

Environment:

    Invoked with 'EditorLock' NOT held by the caller.

--*/

{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;

    KeAcquireSpinLock(&EditorLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&EditorMappingLock);

    for (Link = Editor->MappingList.Flink; Link != &Editor->MappingList;
         Link = Link->Flink) {
        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, EditorLink);
        Link = Link->Blink;
        NatMappingDetachEditor(Editor, Mapping);
    }

    KeReleaseSpinLockFromDpcLevel(&EditorMappingLock);
    KeReleaseSpinLock(&EditorLock, Irql);

    ExFreePool(Editor);

} // NatCleanupEditor



NTSTATUS
NatCreateEditor(
    PIP_NAT_REGISTER_EDITOR RegisterContext
    )

/*++

Routine Description:

    This routine is invoked when an editor attempts to register.
    It handles creation of a context-block for the editor.

Arguments:

    RegisterContext - information about the registering editor

Return Value:

    NTSTATUS - status code.

--*/

{
    PNAT_EDITOR Editor;
    PLIST_ENTRY InsertionPoint;
    KIRQL Irql;

    CALLTRACE(("NatCreateEditor\n"));

    //
    // Validate the registration information
    //

    if ((RegisterContext->Protocol != NAT_PROTOCOL_TCP &&
         RegisterContext->Protocol != NAT_PROTOCOL_UDP) ||
        (!RegisterContext->Port) ||
        (RegisterContext->Direction != NatInboundDirection &&
         RegisterContext->Direction != NatOutboundDirection) ||
        (!RegisterContext->ForwardDataHandler &&
         !RegisterContext->ReverseDataHandler)) {
        ERROR(("NatCreateEditor: bad argument\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a new editor-struct
    //

    Editor =
        ExAllocatePoolWithTag(NonPagedPool, sizeof(NAT_EDITOR), NAT_TAG_EDITOR);

    if (!Editor) {
        ERROR(("NatCreateEditor: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    KeInitializeSpinLock(&Editor->Lock);
    Editor->ReferenceCount = 1;
    Editor->Flags = RegisterContext->Flags;
    Editor->Key =
        MAKE_EDITOR_KEY(
            RegisterContext->Protocol,
            RegisterContext->Port,
            RegisterContext->Direction
            );
    InitializeListHead(&Editor->MappingList);

    Editor->Context = RegisterContext->EditorContext;
    Editor->CreateHandler = RegisterContext->CreateHandler;
    Editor->DeleteHandler = RegisterContext->DeleteHandler;
    Editor->ForwardDataHandler = RegisterContext->ForwardDataHandler;
    Editor->ReverseDataHandler = RegisterContext->ReverseDataHandler;

    KeAcquireSpinLock(&EditorLock, &Irql);
    if (NatLookupEditor(Editor->Key, &InsertionPoint)) {
        KeReleaseSpinLock(&EditorLock, Irql);
        ERROR(
            ("NatCreateEditor: duplicate editor %d/%d\n",
            RegisterContext->Protocol, RegisterContext->Port)
            );
        ExFreePool(Editor);
        return STATUS_UNSUCCESSFUL;
    }
    InsertTailList(InsertionPoint, &Editor->Link);
    KeReleaseSpinLock(&EditorLock, Irql);

    InterlockedIncrement(&EditorCount);

    //
    // Supply the caller with 'out' information
    //

    RegisterContext->EditorHandle = (PVOID)Editor;
    RegisterContext->CreateTicket = NatEditorCreateTicket;
    RegisterContext->DeleteTicket = NatEditorDeleteTicket;
    RegisterContext->Deregister = NatEditorDeregister;
    RegisterContext->DissociateSession = NatEditorDissociateSession;
    RegisterContext->EditSession = NatEditorEditSession;
    RegisterContext->QueryInfoSession = NatEditorQueryInfoSession;
    RegisterContext->TimeoutSession = NatEditorTimeoutSession;

    return STATUS_SUCCESS;

} // NatCreateEditor



NTSTATUS
NatDeleteEditor(
    PNAT_EDITOR Editor
    )

/*++

Routine Description:

    Handles editor deletion.

    This routine assumes that EditorLock is NOT held by the caller.

Arguments:

    Editor - specifies the editor to be deleted.

Return Value

    NTSTATUS - status code.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatDeleteEditor\n"));

    InterlockedDecrement(&EditorCount);

    //
    // Remove the editor for the list
    //

    KeAcquireSpinLock(&EditorLock, &Irql);
    Editor->Flags |= NAT_EDITOR_FLAG_DELETED;
    RemoveEntryList(&Editor->Link);
    KeReleaseSpinLock(&EditorLock, Irql);

    //
    // Drop its reference count and clean up if necessary
    //

    if (InterlockedDecrement(&Editor->ReferenceCount) > 0) {
        return STATUS_PENDING;
    }
    NatCleanupEditor(Editor);
    return STATUS_SUCCESS;

} // NatDeleteEditor


VOID
NatInitializeEditorManagement(
    VOID
    )

/*++

Routine Description:

    This routine prepares the editor-management module for operation.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeEditorManagement\n"));
    EditorCount = 0;
    KeInitializeSpinLock(&EditorLock);
    InitializeListHead(&EditorList);
    KeInitializeSpinLock(&EditorMappingLock);
} // NatInitializeEditorManagement


PNAT_EDITOR
NatLookupEditor(
    ULONG Key,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to retrieve the editor corresponding to the given
    key.

Arguments:

    Key - the key for which an editor is to be found

    InsertionPoint - receives the point at which the editor should be inserted
        if not found

Return Value:

    PNAT_EDITOR - the required editor, if found

--*/

{
    PNAT_EDITOR Editor;
    PLIST_ENTRY Link;
    for (Link = EditorList.Flink; Link != &EditorList; Link = Link->Flink) {
        Editor = CONTAINING_RECORD(Link, NAT_EDITOR, Link);
        if (Key > Editor->Key) {
            continue;
        } else if (Key < Editor->Key) {
            break;
        }
        return Editor;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // NatLookupEditor


VOID
NatMappingAttachEditor(
    PNAT_EDITOR Editor,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine is invoked to attach a mapping to an editor.
    It serves as a notification that there is one more mapping 
    associated with the editor.

Arguments:

    Editor - the editor for the mapping

    Mapping - the mapping to be attached.

Return Value:

    none.

Environment:

    Always invoked at dispatch level with 'EditorLock' and 'EditorMappingLock'
    held by the caller.

--*/

{
    ULONG PrivateAddress;
    USHORT PrivatePort;
    ULONG PublicAddress;
    USHORT PublicPort;
    ULONG RemoteAddress;
    USHORT RemotePort;

    CALLTRACE(("NatMappingAttachEditor\n"));
    if (Editor->CreateHandler) {
        NatQueryInformationMapping(
            Mapping,
            NULL,
            &PrivateAddress,
            &PrivatePort,
            &RemoteAddress,
            &RemotePort,
            &PublicAddress,
            &PublicPort,
            NULL
            );
        Editor->CreateHandler(
            Editor->Context,
            PrivateAddress,
            PrivatePort,
            RemoteAddress,
            RemotePort,
            PublicAddress,
            PublicPort,
            &Mapping->EditorContext
            );
    }
    Mapping->Editor = Editor;
    InsertTailList(&Editor->MappingList, &Mapping->EditorLink);
} // NatMappingAttachEditor


VOID
NatMappingDetachEditor(
    PNAT_EDITOR Editor,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine is invoked to detach a mapping from a editor.
    It serves as a notification that there is one less mapping 
    associated with the editor.

Arguments:

    Editor - editor to be detached

    Mapping - the mapping to be detached

Return Value:

    none.

Environment:

    Always invoked at dispatch level with 'EditorLock' and 'EditorMappingLock'
    held by the caller.

--*/

{
    KIRQL Irql;
    if (Editor->DeleteHandler && Mapping->Interfacep) {
        Editor->DeleteHandler(
            Mapping->Interfacep,
            Mapping,
            Editor->Context,
            Mapping->EditorContext
            );
    }
    RemoveEntryList(&Mapping->EditorLink);
    Mapping->Editor = NULL;
    Mapping->EditorContext = NULL;
} // NatMappingDetachEditor


NTSTATUS
NatQueryEditorTable(
    IN PIP_NAT_ENUMERATE_EDITORS InputBuffer,
    IN PIP_NAT_ENUMERATE_EDITORS OutputBuffer,
    IN PULONG OutputBufferLength
    )

/*++

Routine Description:

    This routine is used for enumerating the registered editors.

Arguments:

    InputBuffer - supplies context information for the information

    OutputBuffer - receives the result of the enumeration

    OutputBufferLength - size of the i/o buffer

Return Value:

    STATUS_SUCCESS if successful, error code otherwise.

--*/

{
    ULONG Count;
    ULONG i;
    KIRQL Irql;
    ULONG Key;
    PLIST_ENTRY Link;
    PNAT_EDITOR Editor;
    NTSTATUS status;
    PIP_NAT_EDITOR Table;

    CALLTRACE(("NatQueryEditorTable\n"));

    Key = InputBuffer->EnumerateContext;
    KeAcquireSpinLock(&EditorLock, &Irql);

    //
    // See if this is a new enumeration or a continuation of an old one.
    //

    if (!Key) {

        //
        // This is a new enumeration. We start with the first item
        // in the list of editors
        //

        Editor =
            IsListEmpty(&EditorList)
                ? NULL
                : CONTAINING_RECORD(EditorList.Flink, NAT_EDITOR, Link);
    } else {

        //
        // This is a continuation. The context therefore contains
        // the key for the next editor.
        //

        Editor = NatLookupEditor(Key, NULL);
    }

    if (!Editor) {
        OutputBuffer->EnumerateCount = 0;
        OutputBuffer->EnumerateContext = 0;
        OutputBuffer->EnumerateTotalHint = EditorCount;
        *OutputBufferLength =
            FIELD_OFFSET(IP_NAT_ENUMERATE_EDITORS, EnumerateTable);
        KeReleaseSpinLock(&EditorLock, Irql);
        return STATUS_SUCCESS;
    }

    //
    // Compute the maximum number of entries we can store
    //

    Count =
        *OutputBufferLength -
        FIELD_OFFSET(IP_NAT_ENUMERATE_EDITORS, EnumerateTable);
    Count /= sizeof(IP_NAT_EDITOR);

    //
    // Walk the list storing mappings in the caller's buffer
    //

    Table = OutputBuffer->EnumerateTable;

    for (i = 0, Link = &Editor->Link; i < Count && Link != &EditorList;
         i++, Link = Link->Flink) {
        Editor = CONTAINING_RECORD(Link, NAT_EDITOR, Link);
        Table[i].Direction = EDITOR_KEY_DIRECTION(Editor->Key);
        Table[i].Protocol = EDITOR_KEY_PROTOCOL(Editor->Key);
        Table[i].Port = EDITOR_KEY_PORT(Editor->Key);
    }

    //
    // The enumeration is over; update the output structure
    //

    *OutputBufferLength =
        i * sizeof(IP_NAT_EDITOR) +
        FIELD_OFFSET(IP_NAT_ENUMERATE_EDITORS, EnumerateTable);
    OutputBuffer->EnumerateCount = i;
    OutputBuffer->EnumerateTotalHint = EditorCount;
    if (Link == &EditorList) {
        //
        // We reached the end of the editor list
        //
        OutputBuffer->EnumerateContext = 0;
    } else {
        //
        // Save the continuation context
        //
        OutputBuffer->EnumerateContext =
            CONTAINING_RECORD(Link, NAT_EDITOR, Link)->Key;
    }

    KeReleaseSpinLock(&EditorLock, Irql);
    return STATUS_SUCCESS;

} // NatQueryEditorTable



VOID
NatShutdownEditorManagement(
    VOID
    )

/*++

Routine Description:

    This routine shuts down the editor-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PNAT_EDITOR Editor;
    KIRQL Irql;
    CALLTRACE(("NatShutdownEditorManagement\n"));

    KeAcquireSpinLock(&EditorLock, &Irql);

    //
    // Delete all editors
    //

    while (!IsListEmpty(&EditorList)) {
        Editor = CONTAINING_RECORD(EditorList.Flink, NAT_EDITOR, Link);
        RemoveEntryList(&Editor->Link);
        KeReleaseSpinLockFromDpcLevel(&EditorLock);
        NatCleanupEditor(Editor);
        KeAcquireSpinLockAtDpcLevel(&EditorLock);
    }

    KeReleaseSpinLock(&EditorLock, Irql);

} // NatShutdownEditorManagement


//
// EDITOR HELPER ROUTINES
//
// These routines assume that references are held on the calling 'Interface',
// 'Editor' and 'Mapping' but that none are locked. The caller is assumed
// to be running at dispatch level, with the exception of the routine
// 'NatEditorDeregister' which may be invoked at lower IRQL.
//

NTSTATUS
NatEditorCreateTicket(
    IN PVOID InterfaceHandle,
    IN UCHAR Protocol,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG RemoteAddress OPTIONAL,
    IN USHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress,
    OUT PUSHORT PublicPort
    )

/*++

Routine Description:

    This routine is called by editors to dynamically establish mappings for
    sessions.

Arguments:

    InterfaceHandle - handle of interface over which the mapping is to be
        established; would have been passed in a 'DataHandler' call.

    Protocol - NAT_PROTOCOL_TCP or NAT_PROTOCOL_UDP

    PrivateAddress - IP address of the session's private endpoint

    PrivatePort - protocol port of the session's private endpoint

    PublicAddress - receives the public address of the ticket created

    PublicPort - receives the public port of the ticket created

Return Value:

    NTSTATUS - success/failure code.

--*/

{
    NTSTATUS status;

    CALLTRACE(("NatEditorCreateTicket\n"));

    //
    // Lock the interface as expected by 'NatCreateTicket',
    // and make the new ticket
    //

    KeAcquireSpinLockAtDpcLevel(&((PNAT_INTERFACE)InterfaceHandle)->Lock);

    status =
        NatCreateTicket(
            (PNAT_INTERFACE)InterfaceHandle,
            Protocol,
            PrivateAddress,
            PrivatePort,
            RemoteAddress,
            RemotePort,
            0,
            NULL,
            0,
            PublicAddress,
            PublicPort
            );

    KeReleaseSpinLockFromDpcLevel(&((PNAT_INTERFACE)InterfaceHandle)->Lock);

    return status;

} // NatEditorCreateTicket



NTSTATUS
NatEditorDeleteTicket(
    IN PVOID InterfaceHandle,
    IN ULONG PublicAddress,
    IN UCHAR Protocol,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress OPTIONAL,
    IN USHORT RemotePort OPTIONAL
    )

/*++

Routine Description:

    This routine deletes a ticket created by 'NatEditorDeleteTicket'.

Arguments:

    InterfaceHandle - handle of interface on which the ticket was issued

    Protocol - NAT_PROTOCOL_TCP or NAT_PROTOCOL_UDP

    PublicAddress - address of the ticket's public endpoint

    PublicPort - port of the ticket's public endpoint

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    ULONG64 Key;
    ULONG64 RemoteKey;
    NTSTATUS status;

    CALLTRACE(("NatEditorDeleteTicket\n"));

    //
    // Lock the interface as expected by 'NatLookupAndDeleteTicket',
    // and delete the ticket
    //

    Key = MAKE_TICKET_KEY(Protocol, PublicAddress, PublicPort);
    RemoteKey = MAKE_TICKET_KEY(Protocol, RemoteAddress, RemotePort);
    KeAcquireSpinLockAtDpcLevel(&((PNAT_INTERFACE)InterfaceHandle)->Lock);
    status = NatLookupAndDeleteTicket(
                (PNAT_INTERFACE)InterfaceHandle,
                Key,
                RemoteKey
                );
    KeReleaseSpinLockFromDpcLevel(&((PNAT_INTERFACE)InterfaceHandle)->Lock);

    return status;

} // NatEditorDeleteTicket



NTSTATUS
NatEditorDeregister(
    IN PVOID EditorHandle
    )

/*++

Routine Description:

    This routine removes an editor from the editor list,
    and dissociates it from all sessions it is currently editing.

Arguments:

    EditorHandle - handle of the editor to be removed.

Return Value:

    NTSTATUS - status code.

--*/

{
    PNAT_EDITOR Editor = (PNAT_EDITOR)EditorHandle;
    KIRQL Irql;
    CALLTRACE(("NatEditorDeregister\n"));
    KeAcquireSpinLock(&EditorLock, &Irql);
    Editor->Flags |= NAT_EDITOR_FLAG_DELETED;
    RemoveEntryList(&Editor->Link);
    KeReleaseSpinLock(&EditorLock, Irql);
    if (InterlockedDecrement(&Editor->ReferenceCount) > 0) {
        return STATUS_PENDING;
    }
    NatCleanupEditor(Editor);
    return STATUS_SUCCESS;

} // NatEditorDeregister


NTSTATUS
NatEditorDissociateSession(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    )

/*++

Routine Description:

    This routine is called by an editor to dissociate itself from a specific
    session.

Arguments:

    EditorHandle - the editor which wishes to dissociate itself.

    SessionHandle - the session from which the editor is disssociating itself.

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    Invoked at dispatch level with neither 'EditorLock' nor 'EditorMappingLock'
    held by the caller.

--*/

{

    PNAT_EDITOR Editor = (PNAT_EDITOR)EditorHandle;
    PNAT_DYNAMIC_MAPPING Mapping = (PNAT_DYNAMIC_MAPPING)SessionHandle;
    CALLTRACE(("NatEditorDissociateSession\n"));
    KeAcquireSpinLockAtDpcLevel(&EditorLock);
    if (Mapping->Editor != Editor) {
        KeReleaseSpinLockFromDpcLevel(&EditorLock);
        return STATUS_INVALID_PARAMETER;
    }
    KeAcquireSpinLockAtDpcLevel(&EditorMappingLock);
    NatMappingDetachEditor(Editor, Mapping);
    KeReleaseSpinLockFromDpcLevel(&EditorMappingLock);
    KeReleaseSpinLockFromDpcLevel(&EditorLock);
    return STATUS_SUCCESS;

} // NatEditorDissociateSession


NTSTATUS
NatEditorEditSession(
    IN PVOID DataHandle,
    IN PVOID RecvBuffer,
    IN ULONG OldDataOffset,
    IN ULONG OldDataLength,
    IN PUCHAR NewData,
    IN ULONG NewDataLength
    )

/*++

Routine Description:

    This routine is invoked by an editor to replace one range of bytes
    in a packet with another range of bytes.

    The routine makes the necessary adjustments to TCP sequence numbers
    if the edition alters the size of a TCP segment.

Arguments:

    EditorHandle - handle of the editor invoking this function.

    SessionHandle - the session whose data is to be edited.

    DataHandle - per-packet context passed to 'DataHandler'.

    RecvBuffer - the 'RecvBuffer' argument to 'DataHandler'.

    OldDataOffset - offset into 'RecvBuffer' of the range to be replaced

    OldDataLength - length of range to be replaced

    NewData - pointer to the bytes to serve as a replacement for 'OldData'

    NewDataLength - number of bytes in the replacement range.

Return Value:

    NTSTATUS - indicates success/failure

--*/

{

#define XLATECONTEXT        ((PNAT_XLATE_CONTEXT)DataHandle)
#define RECVBUFFER          ((IPRcvBuf*)RecvBuffer)

    LONG Diff;
    IPRcvBuf* End;
    ULONG EndOffset;
    IPRcvBuf* NewEnd;
    ULONG NewEndOffset;
    BOOLEAN ResetIpHeader;
    ULONG Size;
    IPRcvBuf* Start;
    ULONG StartOffset;
    IPRcvBuf* Temp;
    PUCHAR TempBuffer;

    CALLTRACE(("NatEditorEditSession\n"));

    ResetIpHeader =
        ((PUCHAR)XLATECONTEXT->Header == XLATECONTEXT->RecvBuffer->ipr_buffer);

    //
    // Find the buffer which contains the start of the range to be edited
    //

    for (Start = (IPRcvBuf*)RecvBuffer, StartOffset = 0;
         Start && (StartOffset + Start->ipr_size) < OldDataOffset;
         StartOffset += Start->ipr_size, Start = Start->ipr_next) { }

    if (!Start) { return STATUS_INVALID_PARAMETER; }

    StartOffset = OldDataOffset - StartOffset;

    //
    // Find the buffer which contains the end of the range to be edited
    //

    for (End = Start, EndOffset = OldDataLength + StartOffset;
         End && EndOffset > End->ipr_size;
         EndOffset -= End->ipr_size, End = End->ipr_next) { }

    if (!End) { return STATUS_INVALID_PARAMETER; }

    //
    // Compute the change in length
    //

    Diff = NewDataLength - OldDataLength;

    //
    // If the length is decreasing, we MAY free some of the buffers.
    // If the length is increasing, we WILL grow the last buffer.
    //

    if (Diff < 0) {

        //
        // See how many buffers we will need for the new length
        //

        for (NewEnd = Start, NewEndOffset = NewDataLength + StartOffset;
             NewEnd && NewEndOffset > NewEnd->ipr_size;
             NewEndOffset -= NewEnd->ipr_size, NewEnd = NewEnd->ipr_next) { }

        //
        // Free all the buffers we can
        //

        if (NewEnd != End) {
            for (Temp = NewEnd->ipr_next; Temp != End; Temp = NewEnd->ipr_next) {
                NewEnd->ipr_next = Temp->ipr_next;
                Temp->ipr_next = NULL;
                IPFreeBuff(Temp);
            }
        }

        //
        // Copy over the remaining buffers
        //

        Size = min(NewDataLength, Start->ipr_size - StartOffset);

        RtlCopyMemory(Start->ipr_buffer + StartOffset, NewData, Size);

        NewData += Size;
        NewDataLength -= Size;

        for (Temp = Start->ipr_next; Temp != NewEnd->ipr_next;
             Temp = Temp->ipr_next) {
            Size = min(NewDataLength, Size);
            RtlCopyMemory(Temp->ipr_buffer, NewData, Size);
            NewData += Size;
            NewDataLength -= Size;
        }

        //
        // Now move up any data in the 'End' buffer 
        //

        if (NewEnd == End) {
            RtlMoveMemory(
                End->ipr_buffer + NewEndOffset,
                End->ipr_buffer + EndOffset,
                End->ipr_size - EndOffset
                );
            End->ipr_size -= EndOffset - NewEndOffset;
        } else {
            NewEnd->ipr_size = NewEndOffset;
            End->ipr_size -= EndOffset;
            RtlMoveMemory(
                End->ipr_buffer,
                End->ipr_buffer + EndOffset,
                End->ipr_size
                );
        }
    }
    else
    if (Diff > 0) {

        IPRcvBuf SavedRcvBuf;

        //
        // We will have to reallocate the last buffer;
        // first save the old rcvbuf so we can free it
        // once we've copied out the old data
        //

        SavedRcvBuf = *End;
        SavedRcvBuf.ipr_next = NULL;

        Size = End->ipr_size;
        TempBuffer = End->ipr_buffer;

        End->ipr_size += Diff;

        if (!IPAllocBuff(End, End->ipr_size)) {
            TRACE(EDIT, ("NatEditorEditSession: allocation failed\n"));
            return STATUS_NO_MEMORY;
        }

        //
        // If there's only one buffer, we have to copy any non-edited data
        // at the start of the old buffer
        //

        if (Start == End && StartOffset) {
            RtlCopyMemory(
                Start->ipr_buffer,
                TempBuffer,
                StartOffset
                );
        }

        //
        // Copy any non-edited data that is at the end of the old buffer
        //

        if (Size != (EndOffset+1)) {
            RtlCopyMemory(
                End->ipr_buffer + EndOffset + Diff,
                TempBuffer + EndOffset,
                Size - EndOffset
                );
        }

        FreeIprBuff(&SavedRcvBuf);

        //
        // Now copy over the buffers
        //

        Size = min(NewDataLength, Size);

        RtlCopyMemory(Start->ipr_buffer + StartOffset, NewData, Size);

        NewData += Size;
        NewDataLength -= Size;

        for (Temp = Start->ipr_next; Temp != End->ipr_next;
             Temp = Temp->ipr_next) {
            Size = min(NewDataLength, Size);
            RtlCopyMemory(Temp->ipr_buffer, NewData, Size);
            NewData += Size;
            NewDataLength -= Size;
        }

        //
        // Set up for checksum computation below
        //

        NewEnd = End;
        NewEndOffset = EndOffset + Diff;
    }
    else {

        //
        // Equal length. We just walk through copying over existing data
        //

        Size = min(NewDataLength, Start->ipr_size - StartOffset);

        RtlCopyMemory(Start->ipr_buffer + StartOffset, NewData, Size);

        NewData += Size;
        NewDataLength -= Size;

        for (Temp = Start->ipr_next; Temp != End->ipr_next;
             Temp = Temp->ipr_next) {
            Size = min(NewDataLength, Size);
            RtlCopyMemory(Temp->ipr_buffer, NewData, Size);
            NewData += Size;
            NewDataLength -= Size;
        }

        NewEnd = End;
        NewEndOffset = EndOffset;
    }

    //
    // Reset the 'Protocol' fields of the context which may be pointing
    // to memory that was freed above.
    // 

    if (ResetIpHeader) {
        XLATECONTEXT->Header = (PIP_HEADER)XLATECONTEXT->RecvBuffer->ipr_buffer;
    }
    NAT_BUILD_XLATE_CONTEXT(
        XLATECONTEXT,
        XLATECONTEXT->Header,
        XLATECONTEXT->DestinationType,
        XLATECONTEXT->RecvBuffer,
        XLATECONTEXT->SourceAddress,
        XLATECONTEXT->DestinationAddress
        );

    //
    // If this is a UDP packet, update the length field in the protocol header
    //

    if (Diff && XLATECONTEXT->Header->Protocol == NAT_PROTOCOL_UDP) {
        PUDP_HEADER UdpHeader = (PUDP_HEADER)XLATECONTEXT->ProtocolHeader;
        UdpHeader->Length = NTOHS(UdpHeader->Length);
        UdpHeader->Length += (SHORT)Diff;
        UdpHeader->Length = NTOHS(UdpHeader->Length);
    }

    //
    // Update the packet's context to reflect the changes made
    //

    XLATECONTEXT->Flags |= NAT_XLATE_FLAG_EDITED;
    XLATECONTEXT->Header->TotalLength =
        NTOHS(XLATECONTEXT->Header->TotalLength) + (SHORT)Diff;
    XLATECONTEXT->Header->TotalLength =
        NTOHS(XLATECONTEXT->Header->TotalLength);
    XLATECONTEXT->TcpSeqNumDelta += Diff;

    return STATUS_SUCCESS;

#undef XLATECONTEXT
#undef RECVBUFFER

} // NatEditorEditSession



VOID
NatEditorQueryInfoSession(
    IN PVOID SessionHandle,
    OUT PULONG PrivateAddress OPTIONAL,
    OUT PUSHORT PrivatePort OPTIONAL,
    OUT PULONG RemoteAddress OPTIONAL,
    OUT PUSHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress OPTIONAL,
    OUT PUSHORT PublicPort OPTIONAL,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    )

/*++

Routine Description:

    This routine is called by editors to retrieve information about a session.

Arguments:

    SessionHandle - handle of the session about which to retrieve information

    PrivateAddress - receives the IP address of the session's private endpoint

    PrivatePort - receives the protocol port of the session's private endpoint

    RemoteAddress - receives the IP address of the session's remote endpoint

    RemotePort - receives the protocol port of the session's remote endpoint

    PublicAddress - receives the IP address of the session's public endpoint

    PublicPort - receives the protocol port of the session's public endpoint

    Statistics - receives any statistics for the mapping

Return Value:

    none.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatEditorQueryInfoSession\n"));
    KeAcquireSpinLock(&MappingLock, &Irql);
    NatQueryInformationMapping(
        (PNAT_DYNAMIC_MAPPING)SessionHandle,
        NULL,
        PrivateAddress,
        PrivatePort,
        RemoteAddress,
        RemotePort,
        PublicAddress,
        PublicPort,
        Statistics
        );
    KeReleaseSpinLock(&MappingLock, Irql);
} // NatEditorQueryInfoSession



VOID
NatEditorTimeoutSession(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    )

/*++

Routine Description:

    This routine is invoked by an editor to indicate that a given session
    should be timed out at the earliest opportunity.

Arguments:

    EditorHandle - the editor requesting the timeout

    SessionHandle - the session to be timed-out

Return Value:

    none.

--*/

{
    KeAcquireSpinLockAtDpcLevel(&((PNAT_DYNAMIC_MAPPING)SessionHandle)->Lock);
    NatExpireMapping((PNAT_DYNAMIC_MAPPING)SessionHandle);
    KeReleaseSpinLockFromDpcLevel(&((PNAT_DYNAMIC_MAPPING)SessionHandle)->Lock);

} // NatEditorTimeoutSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\editor.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    editor.h

Abstract:

    This module contains declarations related to management of session-editors.

Author:

    Abolade Gbadegesin (t-abolag)   14-July-1997

Revision History:

--*/

#ifndef _NAT_EDITOR_H_
#define _NAT_EDITOR_H_

//
// Structure:   NAT_EDITOR
//
// Holds information about an editor
//
// Each editor is on a global list of editors ('EditorList') which is protected
// by a spin lock ('EditorLock'). The list is sorted on a key composed of
// the protocol of the sessions to be edited, the protocol port number, and
// the flag indicating whether the defining port is the destination or source.
//
// Access to editors is synchronized using the same reference-counting logic
// as access to interfaces. See 'IF.H' for more information.
//
// Each session being edited by an editor is linked into the editor's list
// of mappings ('MappingList'). Access to this list of mappings must also 
// be synchronized. This is achieved using 'EditorMappingLock', which
// must be acquired before modifying any editor's list of mappings.
// See 'MAPPING.H' for further details.
//
// N.B. On the rare occasions when 'MappingLock' must be held at the same time
// as one of 'InterfaceLock', 'EditorLock', and 'DirectorLock', 'MappingLock'
// must always be acquired first.
//

typedef struct _NAT_EDITOR {
    LIST_ENTRY Link;
    ULONG Key;
    ULONG ReferenceCount;
    KSPIN_LOCK Lock;
    LIST_ENTRY MappingList;
    ULONG Flags;
    PVOID Context;
    PNAT_EDITOR_CREATE_HANDLER CreateHandler;
    PNAT_EDITOR_DELETE_HANDLER DeleteHandler;
    PNAT_EDITOR_DATA_HANDLER ForwardDataHandler;
    PNAT_EDITOR_DATA_HANDLER ReverseDataHandler;
} NAT_EDITOR, *PNAT_EDITOR;

//
// Definitions of flags for the field NAT_EDITOR.Flags
//

#define NAT_EDITOR_FLAG_DELETED     0x80000000

//
// Macros used to test various flags
//

#define NAT_EDITOR_DELETED(Editor) \
    ((Editor)->Flags & NAT_EDITOR_FLAG_DELETED)

#define NAT_EDITOR_RESIZE(Editor) \
    ((Editor)->Flags & IP_NAT_EDITOR_FLAGS_RESIZE)

//
// Editor key-manipulation macros
//

#define MAKE_EDITOR_KEY(Protocol,Port,Direction) \
    (((ULONG)((Protocol) & 0xFF) << 24) | \
    (ULONG)(((Direction) & 0xFF) << 16) | \
    (ULONG)((Port) & 0xFFFF))

#define EDITOR_KEY_DIRECTION(Key)   ((UCHAR)(((Key) & 0x00FF0000) >> 16))
#define EDITOR_KEY_PORT(Key)        ((USHORT)((Key) & 0x0000FFFF))
#define EDITOR_KEY_PROTOCOL(Key)    ((UCHAR)(((Key) & 0xFF000000) >> 24))


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY EditorList;
extern KSPIN_LOCK EditorLock;
extern KSPIN_LOCK EditorMappingLock;

//
// EDITOR MANAGEMENT ROUTINES
//

VOID
NatCleanupEditor(
    PNAT_EDITOR Editor
    );

NTSTATUS
NatCreateEditor(
    PIP_NAT_REGISTER_EDITOR RegisterContext
    );

NTSTATUS
NatDeleteEditor(
    PNAT_EDITOR Editor
    );

//
// BOOLEAN
// NatDereferenceEditor(
//     PNAT_EDITOR Editor
//     );
//

#define \
NatDereferenceEditor( \
    _Editor \
    ) \
    (InterlockedDecrement(&(_Editor)->ReferenceCount) \
        ? TRUE \
        : NatCleanupEditor(_Editor), FALSE)

VOID
NatInitializeEditorManagement(
    VOID
    );

PNAT_EDITOR
NatLookupEditor(
    ULONG Key,
    PLIST_ENTRY* InsertionPoint
    );

struct _NAT_DYNAMIC_MAPPING;
VOID
NatMappingAttachEditor(
    PNAT_EDITOR Editor,
    struct _NAT_DYNAMIC_MAPPING* Mapping
    );

VOID
NatMappingDetachEditor(
    PNAT_EDITOR Editor,
    struct _NAT_DYNAMIC_MAPPING* Mapping
    );

NTSTATUS
NatQueryEditorTable(
    IN PIP_NAT_ENUMERATE_EDITORS InputBuffer,
    IN PIP_NAT_ENUMERATE_EDITORS OutputBuffer,
    IN PULONG OutputBufferLength
    );

//
// BOOLEAN
// NatReferenceEditor(
//     PNAT_DIRECTOR Editor
//     );
//

#define \
NatReferenceEditor( \
    _Editor \
    ) \
    (NAT_EDITOR_DELETED(_Editor) \
        ? FALSE \
        : InterlockedIncrement(&(_Editor)->ReferenceCount), TRUE)

VOID
NatShutdownEditorManagement(
    VOID
    );

//
// HELPER ROUTINES
//

NTSTATUS
NatEditorCreateTicket(
    IN PVOID InterfaceHandle,
    IN UCHAR Protocol,
    IN ULONG PrivateAddress,
    IN USHORT PrivatePort,
    IN ULONG RemoteAddress OPTIONAL,
    IN USHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress,
    OUT PUSHORT PublicPort
    );

NTSTATUS
NatEditorDeleteTicket(
    IN PVOID InterfaceHandle,
    IN ULONG PublicAddress,
    IN UCHAR Protocol,
    IN USHORT PublicPort,
    IN ULONG RemoteAddress OPTIONAL,
    IN USHORT RemotePort OPTIONAL
    );

NTSTATUS
NatEditorDeleteSession(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

NTSTATUS
NatEditorDeregister(
    IN PVOID EditorHandle
    );

NTSTATUS
NatEditorDissociateSession(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );

NTSTATUS
NatEditorEditSession(
    IN PVOID DataHandle,
    IN PVOID RecvBuffer,
    IN ULONG OldDataOffset,
    IN ULONG OldDataLength,
    IN PUCHAR NewData,
    IN ULONG NewDataLength
    );

VOID
NatEditorQueryInfoSession(
    IN PVOID SessionHandle,
    OUT PULONG PrivateAddress OPTIONAL,
    OUT PUSHORT PrivatePort OPTIONAL,
    OUT PULONG RemoteAddress OPTIONAL,
    OUT PUSHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress OPTIONAL,
    OUT PUSHORT PublicPort OPTIONAL,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

VOID
NatEditorTimeoutSession(
    IN PVOID EditorHandle,
    IN PVOID SessionHandle
    );


__inline VOID
NatEditorEditShortSession(
    IN PVOID DataHandle,
    IN PUSHORT Shortp,
    IN USHORT Value
    )
{
    if (((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta) {
        *((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta += (USHORT)~(*Shortp);
        *((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta += (USHORT)Value;
    }

    *Shortp = Value;
}

__inline VOID
NatEditorEditLongSession(
    IN PVOID DataHandle,
    IN PULONG Longp,
    IN ULONG Value
    )
{
    if (((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta) {
        *((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta+=(USHORT)~(*Longp);
        *((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta+=(USHORT)~(*Longp>>16);
        *((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta+=(USHORT)Value;
        *((PNAT_XLATE_CONTEXT)DataHandle)->ChecksumDelta+=(USHORT)(Value>>16);
    }

    *Longp = Value;
}


#endif // _NAT_EDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\entry.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    entry.h

Abstract:

    This module contains declarations for the NAT's driver-entry.
    Also included are declarations for data defined in 'entry.c'.

Author:

    Abolade Gbadegesin (t-abolag)   13-July-1997

Revision History:

--*/

#ifndef _NAT_ENTRY_H_
#define _NAT_ENTRY_H_

//
// CONSTANT DECLARATIONS
//

#define DEFAULT_TCP_TIMEOUT         (24 * 60 * 60)

#define DEFAULT_UDP_TIMEOUT         60

#define DEFAULT_START_PORT          NTOHS(1025)

#define DEFAULT_END_PORT            NTOHS(3000)


//
// GLOBAL DATA DECLARATIONS
//

extern BOOLEAN AllowInboundNonUnicastTraffic;
extern COMPONENT_REFERENCE ComponentReference;
extern WCHAR ExternalName[];
extern PDEVICE_OBJECT IpDeviceObject;
extern PFILE_OBJECT IpFileObject;
extern PDEVICE_OBJECT NatDeviceObject;
#if NAT_WMI
extern UNICODE_STRING NatRegistryPath;
#endif
extern USHORT ReservedPortsLowerRange;
extern USHORT ReservedPortsUpperRange;
extern PDEVICE_OBJECT TcpDeviceObject;
extern PFILE_OBJECT TcpFileObject;
extern HANDLE TcpDeviceHandle;
extern ULONG TcpTimeoutSeconds;
extern ULONG TraceClassesEnabled;
extern ULONG UdpTimeoutSeconds;


//
// MACRO DEFINITIONS
//

//
// Component-reference macros
//

#define REFERENCE_NAT() \
    REFERENCE_COMPONENT(&ComponentReference)

#define REFERENCE_NAT_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&ComponentReference,retcode)

#define DEREFERENCE_NAT() \
    DEREFERENCE_COMPONENT(&ComponentReference)

#define DEREFERENCE_NAT_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&ComponentReference, retcode)

//
// Macro for composing a LONG64 from two LONGs.
//

#define MAKE_LONG64(lo,hi)    ((lo) | ((LONG64)(hi) << 32))

//
// Macros for handling network-order shorts and longs
//

#define ADDRESS_BYTES(a) \
    ((a) & 0x000000FF), (((a) & 0x0000FF00) >> 8), \
    (((a) & 0x00FF0000) >> 16), (((a) & 0xFF000000) >> 24)

//
// Define a macro version of ntohs which can be applied to constants,
// and which can thus be computed at compile time.
//

#define NTOHS(p)    ((((p) & 0xFF00) >> 8) | (((UCHAR)(p) << 8)))


//
// FUNCTION PROTOTYPES
//

NTSTATUS
NatInitiateTranslation(
    VOID
    );

VOID
NatTerminateTranslation(
    VOID
    );

extern
ULONG
tcpxsum (
   IN ULONG Checksum,
   IN PUCHAR Source,
   IN ULONG Length
   );


#endif // _NAT_ENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\entry.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    This module contains the entry-code for the IP Network Address Translator.

Author:

    Abolade Gbadegesin (t-abolag)   11-July-1997

Revision History:

	William Ingle (billi)           12-May-2001		NULL security descriptor check

--*/

#include "precomp.h"
#pragma hdrstop


//
// GLOBAL DATA DEFINITIONS
//

COMPONENT_REFERENCE ComponentReference;

//
// Win32 device-name
//

WCHAR ExternalName[] = L"\\DosDevices\\IPNAT";

//
// Device- and file-object for the IP driver
//

extern PDEVICE_OBJECT IpDeviceObject = NULL;
extern PFILE_OBJECT IpFileObject = NULL;
extern HANDLE TcpDeviceHandle = NULL;

//
// Device-object for the NAT driver
//

extern PDEVICE_OBJECT NatDeviceObject = NULL;

//
// Registry parameters key name
//

WCHAR ParametersName[] = L"Parameters";

//
// Name of value holding reserved ports
//

WCHAR ReservedPortsName[] = L"ReservedPorts";

//
// Start and end of reserved-port range
//

USHORT ReservedPortsLowerRange = DEFAULT_START_PORT;
USHORT ReservedPortsUpperRange = DEFAULT_END_PORT;

//
// Device- and file-object for the TCP driver
//

extern PDEVICE_OBJECT TcpDeviceObject = NULL;
extern PFILE_OBJECT TcpFileObject = NULL;

//
// Registry path for the driver's parameters
//

const WCHAR IpNatParametersPath[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\IpNat\\Parameters";

//
// Timeout interval for TCP session mappings
//

ULONG TcpTimeoutSeconds = DEFAULT_TCP_TIMEOUT;

//
// Bitmap of enabled tracing message classes
//

ULONG TraceClassesEnabled = 0;

//
// Registry trace-class value name
//

WCHAR TraceClassesEnabledName[] = L"TraceClassesEnabled";

//
// Timeout interval for UDP and other message-oriented session mappings
//

ULONG UdpTimeoutSeconds = DEFAULT_UDP_TIMEOUT;

#if NAT_WMI
//
// Copy of our registry path for WMI use.
//

UNICODE_STRING NatRegistryPath;
#endif

//
// Name of value for allowing inbound non-unicast
//

WCHAR AllowInboundNonUnicastTrafficName[] = L"AllowInboundNonUnicastTraffic";


//
// If true, non-unicast traffic will not be dropped
// when recevied on a firewalled interface.
//

BOOLEAN AllowInboundNonUnicastTraffic = FALSE;


//
// FUNCTION PROTOTYPES (alphabetically)
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
NatAdjustSecurityDescriptor(
    VOID
    );

VOID
NatCleanupDriver(
    VOID
    );

VOID
NatCreateExternalNaming(
    IN PUNICODE_STRING DeviceString
    );

VOID
NatDeleteExternalNaming(
    VOID
    );

NTSTATUS
NatInitializeDriver(
    VOID
    );

NTSTATUS
NatSetFirewallHook(
    BOOLEAN Install
    );

VOID
NatUnloadDriver(
    IN PDRIVER_OBJECT  DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, NatAdjustSecurityDescriptor)
#pragma alloc_text(PAGE, NatCreateExternalNaming)
#pragma alloc_text(PAGE, NatDeleteExternalNaming)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Performs driver-initialization for NAT.

Arguments:

Return Value:

    STATUS_SUCCESS if initialization succeeded, error code otherwise.

--*/

{
    WCHAR DeviceName[] = DD_IP_NAT_DEVICE_NAME;
    UNICODE_STRING DeviceString;
    LONG i;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ParametersKey;
    HANDLE ServiceKey;
    NTSTATUS status;
    UNICODE_STRING String;

    PAGED_CODE();

    CALLTRACE(("DriverEntry\n"));

#if DBG
    //
    // Open the registry key
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status = ZwOpenKey(&ServiceKey, KEY_READ, &ObjectAttributes);
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&String, ParametersName);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &String,
            OBJ_CASE_INSENSITIVE,
            ServiceKey,
            NULL
            );
        status = ZwOpenKey(&ParametersKey, KEY_READ, &ObjectAttributes);
        ZwClose(ServiceKey);
        if (NT_SUCCESS(status)) {
            UCHAR Buffer[32];
            ULONG BytesRead;
            PKEY_VALUE_PARTIAL_INFORMATION Value;
            RtlInitUnicodeString(&String, TraceClassesEnabledName);
            status =
                ZwQueryValueKey(
                    ParametersKey,
                    &String,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                    sizeof(Buffer),
                    &BytesRead
                    );
            ZwClose(ParametersKey);
            if (NT_SUCCESS(status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Type == REG_DWORD) {
                TraceClassesEnabled =
                    *(PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data;
            }
        }
    }
#endif

#if NAT_WMI

    //
    // Record our registry path for WMI use
    //

    NatRegistryPath.Length = 0;
    NatRegistryPath.MaximumLength
        = RegistryPath->MaximumLength + sizeof( UNICODE_NULL );
    NatRegistryPath.Buffer = ExAllocatePoolWithTag(
                                PagedPool,
                                NatRegistryPath.MaximumLength,
                                NAT_TAG_WMI
                                );

    if( NatRegistryPath.Buffer )
    {
        RtlCopyUnicodeString( &NatRegistryPath, RegistryPath );
    }
    else
    {
        ERROR(("NAT: Unable to allocate string for RegistryPath\n"));
        return STATUS_NO_MEMORY;
    }
#endif

    //
    // Create the device's object.
    //

    RtlInitUnicodeString(&DeviceString, DeviceName);

    status =
        IoCreateDevice(
            DriverObject,
            0,
            &DeviceString,
            FILE_DEVICE_NETWORK,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &NatDeviceObject
            );

    if (!NT_SUCCESS(status)) {
        ERROR(("IoCreateDevice failed (0x%08X)\n", status));
        return status;
    }

    //
    // Adjust the security descriptor on the device object.
    //

    status = NatAdjustSecurityDescriptor();

    if (!NT_SUCCESS(status)) {
        ERROR(("NatAdjustSecurityDescriptor failed (0x%08x)\n", status));
        return status;
    }

    //
    // Initialize file-object tracking items
    //

    KeInitializeSpinLock(&NatFileObjectLock);
    NatOwnerProcessId = NULL;
    NatFileObjectCount = 0;

    //
    // Setup the driver object
    //

    DriverObject->DriverUnload = NatUnloadDriver;
    DriverObject->FastIoDispatch = &NatFastIoDispatch;
    DriverObject->DriverStartIo = NULL;

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = NatDispatch;
    }

    //
    // Create a Win32-accessible device object
    //

    NatCreateExternalNaming(&DeviceString);

    //
    // Initialize the driver's structures
    //

    status = NatInitializeDriver();

    return status;

} // DriverEntry


NTSTATUS
NatAdjustSecurityDescriptor(
    VOID
    )

/*++

Routine Description:

    Modifies the security descriptor on the NAT's device object so
    that only SYSTEM has any permissions.

Arguments:

    none.

Return Value:

    NTSTATUS - success/error code.

--*/

{
    
    PACE_HEADER AceHeader;
    PSID AceSid;
    PACL Dacl;
    BOOLEAN DaclDefaulted;
    BOOLEAN DaclPresent;
    DWORD i;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR NatSD = NULL;
    PACL NewDacl = NULL;
    SECURITY_DESCRIPTOR NewSD;
    SECURITY_INFORMATION SecurityInformation;
    ULONG Size;
    NTSTATUS status;

    do
    {
        //
        // Get our original security descriptor
        //

        status =
            ObGetObjectSecurity(
                NatDeviceObject,
                &NatSD,
                &MemoryAllocated
                );

		// ObGetObjectSecurity can return a NULL security descriptor
		// even with NT_SUCCESS status code
        if (!NT_SUCCESS(status) || (NULL==NatSD)) {
            break;
        }

        //
        // Obtain the Dacl from the security descriptor
        //

        status =
            RtlGetDaclSecurityDescriptor(
                NatSD,
                &DaclPresent,
                &Dacl,
                &DaclDefaulted
                );
        
        if (!NT_SUCCESS(status)) {
            break;
        }

        ASSERT(FALSE != DaclPresent);

        //
        // Make a copy of the Dacl so that we can modify it.
        //

        NewDacl =
            ExAllocatePoolWithTag(
                PagedPool,
                Dacl->AclSize,
                NAT_TAG_SD
                );

        if (NULL == NewDacl) {
            status = STATUS_NO_MEMORY;
            break;
        }

        RtlCopyMemory(NewDacl, Dacl, Dacl->AclSize);

        //
        // Loop through the DACL, removing any access allowed
        // entries that aren't for SYSTEM
        //

        for (i = 0; i < NewDacl->AceCount; i++) {

            status = RtlGetAce(NewDacl, i, &AceHeader);

            if (NT_SUCCESS(status)) {
            
                if (ACCESS_ALLOWED_ACE_TYPE == AceHeader->AceType) {

                    AceSid = (PSID) &((ACCESS_ALLOWED_ACE*)AceHeader)->SidStart;

                    if (!RtlEqualSid(AceSid, SeExports->SeLocalSystemSid)) {
                    
                        status = RtlDeleteAce(NewDacl, i);
                        if (NT_SUCCESS(status)) {
                            i -= 1;
                        }
                    }
                }
            }
        }

        ASSERT(NewDacl->AceCount > 0);

        //
        // Create a new security descriptor to hold the new Dacl.
        //

        status =
            RtlCreateSecurityDescriptor(
                &NewSD,
                SECURITY_DESCRIPTOR_REVISION
                );

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Place the new Dacl into the new SD
        //

        status =
            RtlSetDaclSecurityDescriptor(
                &NewSD,
                TRUE,
                NewDacl,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Set the new SD into our device object. Only the Dacl from the
        // SD will be set.
        //

        SecurityInformation = DACL_SECURITY_INFORMATION;
        status =
            ObSetSecurityObjectByPointer(
                NatDeviceObject,
                SecurityInformation,
                &NewSD
                );

    } while (FALSE);

    if (NULL != NatSD) {
        ObReleaseObjectSecurity(NatSD, MemoryAllocated);
    }

    if (NULL != NewDacl) {
        ExFreePool(NewDacl);
    }

    return status;
    
} // NatAdjustSecurityDescriptor


VOID
NatCleanupDriver(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the last reference to the NAT driver
    is released.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatCleanupDriver\n"));

} // NatCleanupDriver


VOID
NatCreateExternalNaming(
    IN  PUNICODE_STRING DeviceString
    )

/*++

Routine Description:

    Creates a symbolic-link to the NAT's device-object so
    the NAT can be opened by a user-mode process.

Arguments:

    DeviceString - Unicode name of the NAT's device-object.

Return Value:

    none.

--*/

{
    UNICODE_STRING symLinkString;
    PAGED_CODE();
    RtlInitUnicodeString(&symLinkString, ExternalName);
    IoCreateSymbolicLink(&symLinkString, DeviceString);

} // NatCreateExternalNaming


VOID
NatDeleteExternalNaming(
    VOID
    )

/*++

Routine Description:

    Deletes the Win32 symbolic-link to the NAT's device-object

Arguments:

Return Value:

    none.

--*/

{
    UNICODE_STRING symLinkString;
    PAGED_CODE();
    RtlInitUnicodeString(&symLinkString, ExternalName);
    IoDeleteSymbolicLink(&symLinkString);

} // NatDeleteExternalNaming



NTSTATUS
NatInitializeDriver(
    VOID
    )

/*++

Routine Description:

    Performs initialization of the driver's structures.

Arguments:

    none.

Return Value:

    NTSTATUS - success/error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ParametersKey;
    NTSTATUS status;
    NTSTATUS status2;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatus;

    CALLTRACE(("NatInitializeDriver\n"));

    //
    // Set up global synchronization objects
    //

    InitializeComponentReference(&ComponentReference, NatCleanupDriver);

    //
    // Obtain the IP and TCP driver device-objects
    //

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);
    status =
        IoGetDeviceObjectPointer(
            &UnicodeString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &IpFileObject,
            &IpDeviceObject
            );
    if (!NT_SUCCESS(status)) {
        ERROR(("NatInitializeDriver: error %X getting IP object\n", status));
        return status;
    }

    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);
    status =
        IoGetDeviceObjectPointer(
            &UnicodeString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &TcpFileObject,
            &TcpDeviceObject
            );
    if (!NT_SUCCESS(status)) {
        ERROR(("NatInitializeDriver: error %X getting TCP object\n", status));
        return status;
    }

    //
    // Open Tcp Kernel Device
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    status =
        ZwCreateFile(
            &TcpDeviceHandle,
            GENERIC_READ,
            &ObjectAttributes,
            &IoStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

    if ( !NT_SUCCESS(status) )
    {
        ERROR(("ZwCreateFile failed (0x%08X)\n", status));
    } 

    ObReferenceObject(IpDeviceObject);
    ObReferenceObject(TcpDeviceObject);

    //
    // Initialize all object-modules
    //

    NatInitializeTimerManagement();
    NatInitializeMappingManagement();
    NatInitializeDirectorManagement();
    NatInitializeEditorManagement();
    NatInitializeRedirectManagement();
    NatInitializeDynamicTicketManagement();
    NatInitializeIcmpManagement();
    NatInitializeRawIpManagement();
    NatInitializeInterfaceManagement();
#if 0
    status = NatInitializeAddressManagement();
    if (!NT_SUCCESS(status)) { return status; }
#endif
    NatInitializePacketManagement();
    NatInitializeNotificationManagement();

#if NAT_WMI
    NatInitializeWMI();
#endif

    //
    // Initialize NAT-provided editors.
    //

    status = NatInitializePptpManagement();
    if (!NT_SUCCESS(status)) { return status; }

    //
    // Commence translation of packets, and start the periodic timer.
    //

    status = NatInitiateTranslation();

    //
    // Read optional registry settings.
    // The user may customize the range of ports used by modifying
    // the reserved-ports setting in the registry.
    // We now check to see if there is such a value,
    // and if so, we use it as our reserved-port range.
    //
    // The user may also specify that inbound non-unicast traffic
    // is allowed on a firewalled interface.
    //
    //
    // N.B. Failures here are not returned to the caller.
    //

    RtlInitUnicodeString(&UnicodeString, IpNatParametersPath);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status2 = ZwOpenKey(&ParametersKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(status2)) {

        UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
        ULONG EndPort;
        PWCHAR p;
        ULONG StartPort;
        PKEY_VALUE_PARTIAL_INFORMATION Value = NULL;
        ULONG ValueLength;

        //
        // First check for allowed non-unicast traffic.
        //

        RtlInitUnicodeString(
            &UnicodeString,
            AllowInboundNonUnicastTrafficName
            );

        status2 =
            ZwQueryValueKey(
                ParametersKey,
                &UnicodeString,
                KeyValuePartialInformation,
                (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                sizeof(Buffer),
                &ValueLength
                );
        
        if (NT_SUCCESS(status2)
            && REG_DWORD == ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Type) {
            
            AllowInboundNonUnicastTraffic =
                1 == *((PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data);
        }

        //
        // Check for reserved ports
        //


        do {

            RtlInitUnicodeString(&UnicodeString, ReservedPortsName);

            status2 =
                ZwQueryValueKey(
                    ParametersKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                    sizeof(Buffer),
                    &ValueLength
                    );
            if (status2 != STATUS_BUFFER_OVERFLOW) { break; }

            Value =
                (PKEY_VALUE_PARTIAL_INFORMATION)
                    ExAllocatePoolWithTag(
                        PagedPool, ValueLength, NAT_TAG_RANGE_ARRAY
                        );
            if (!Value) { break; }

            status2 =
                ZwQueryValueKey(
                    ParametersKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Value,
                    ValueLength,
                    &ValueLength
                    );
            if (!NT_SUCCESS(status2)) { break; }

            //
            // The value should be in the format "xxx-yyy\0\0";
            // read the first number
            //

            p = (PWCHAR)Value->Data;
            RtlInitUnicodeString(&UnicodeString, p);
            status2 = RtlUnicodeStringToInteger(&UnicodeString, 10, &StartPort);
            if (!NT_SUCCESS(status2)) { break; }

            //
            // Advance past '-'
            //

            while (*p && *p != L'-') { ++p; }
            if (*p != L'-') { break; } else { ++p; }

            //
            // Read second number
            //

            RtlInitUnicodeString(&UnicodeString, p);
            status2 = RtlUnicodeStringToInteger(&UnicodeString, 10, &EndPort);
            if (!NT_SUCCESS(status2)) { break; }

            //
            // Validate the resulting range
            //

            if (StartPort > 0 &&
                StartPort < 65535 &&
                EndPort > 0 &&
                EndPort < 65535 &&
                StartPort <= EndPort
                ) {
                ReservedPortsLowerRange = NTOHS((USHORT)StartPort);
                ReservedPortsUpperRange = NTOHS((USHORT)EndPort);
            }

        } while(FALSE);

        if (Value) { ExFreePool(Value); }
        ZwClose(ParametersKey);
    }

    return status;
    
} // NatInitializeDriver



NTSTATUS
NatInitiateTranslation(
    VOID
    )

/*++

Routine Description:

    This routine is invoked on creation of the first interface,
    to launch the periodic timer and install the firewall hook.

Arguments:

    none.

Return Value:

    STATUS_SUCCESS if successful, error code otherwise.

--*/

{
    CALLTRACE(("NatInitiateTranslation\n"));

    //
    // Launch the timer
    //

    NatStartTimer();

    //
    // Install 'NatTranslate' as the firewall hook
    //

    return NatSetFirewallHook(TRUE);

} // NatInitiateTranslation


NTSTATUS
NatSetFirewallHook(
    BOOLEAN Install
    )

/*++

Routine Description:

    This routine is called to set (Install==TRUE) or clear (Install==FALSE) the
    value of the firewall-callout function pointer in the IP driver.

Arguments:

    Install - indicates whether to install or remove the hook.

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    The routine assumes the caller is executing at PASSIVE_LEVEL.

--*/

{
    IP_SET_FIREWALL_HOOK_INFO HookInfo;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    TCP_RESERVE_PORT_RANGE PortRange;
    KEVENT LocalEvent;
    NTSTATUS status;

    CALLTRACE(("NatSetFirewallHook\n"));

    //
    // Register (or deregister) as a firewall
    //

    HookInfo.FirewallPtr = (IPPacketFirewallPtr)NatTranslatePacket;
    HookInfo.Priority = 1;
    HookInfo.Add = Install;

    KeInitializeEvent(&LocalEvent, SynchronizationEvent, FALSE);
    Irp =
        IoBuildDeviceIoControlRequest(
            IOCTL_IP_SET_FIREWALL_HOOK,
            IpDeviceObject,
            (PVOID)&HookInfo,
            sizeof(HookInfo),
            NULL,
            0,
            FALSE,
            &LocalEvent,
            &IoStatus
            );

    if (!Irp) {
        ERROR(("NatSetFirewallHook: IoBuildDeviceIoControlRequest=0\n"));
        return STATUS_UNSUCCESSFUL;
    }

    status = IoCallDriver(IpDeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&LocalEvent, Executive, KernelMode, FALSE, NULL);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ERROR(("NatSetFirewallHook: IpSetFirewallHook=0x%08X\n", status));
        return status;
    }

    if (ReservedPortsLowerRange != DEFAULT_START_PORT ||
        ReservedPortsUpperRange != DEFAULT_END_PORT
        ) {
        return STATUS_SUCCESS;
    }

    //
    // Reserve (or unreserve) our port-range
    //
    // N.B. The IOCTL expects host-order numbers and we store the range
    // in network order, so do a swap before reserving the ports.
    //

    PortRange.LowerRange = NTOHS(DEFAULT_START_PORT);
    PortRange.UpperRange = NTOHS(DEFAULT_END_PORT);
    Irp =
        IoBuildDeviceIoControlRequest(
            Install
                ? IOCTL_TCP_RESERVE_PORT_RANGE
                : IOCTL_TCP_UNRESERVE_PORT_RANGE,
            TcpDeviceObject,
            (PVOID)&PortRange,
            sizeof(PortRange),
            NULL,
            0,
            FALSE,
            &LocalEvent,
            &IoStatus
            );
    if (!Irp) {
        ERROR(("NatSetFirewallHook: IoBuildDeviceIoControlRequest(2)=0\n"));
        return STATUS_UNSUCCESSFUL;
    }

    status = IoCallDriver(TcpDeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&LocalEvent, Executive, KernelMode, FALSE, NULL);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ERROR(("NatSetFirewallHook: Tcp(Un)ReservePortRange=0x%08X\n", status));
    }

    return status;

} // NatSetFirewallHook


VOID
NatTerminateTranslation(
    VOID
    )

/*++

Routine Description:

    On cleanup of the last interface, this routine is invoked
    to stop the periodic timer and de-install the firewall hook.


Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatTerminateTranslation\n"));
    NatSetFirewallHook(FALSE);

} // NatTerminateTranslation


VOID
NatUnloadDriver(
    IN PDRIVER_OBJECT   DriverObject
    )

/*++

Routine Description:

    Performs cleanup for the NAT.

Arguments:

    DriverObject - reference to the NAT's driver-object

Return Value:

--*/

{
    PNAT_EDITOR Editor;
    PLIST_ENTRY List;

    CALLTRACE(("NatUnloadDriver\n"));

    //
    // Stop translation and clear the periodic timer
    //

    NatTerminateTranslation();

    //
    // Stop the route-change-notification in our packet-management and
    // address-management modules.
    // This forces completion of the route-change and address-change IRPs,
    // which in turn releases component-references which would otherwise not
    // drop until a route-change and address-change occurred.
    //

    NatShutdownNotificationManagement();
    NatShutdownPacketManagement();
#if 0
    NatShutdownAddressManagement();
#endif

    //
    // Drop our self-reference and wait for all activity to cease.
    //

    ReleaseInitialComponentReference(&ComponentReference, TRUE);

    //
    // Tear down our Win32-namespace symbolic link
    //

    NatDeleteExternalNaming();

    //
    // Delete the NAT's device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    //
    // Shutdown object modules
    //

#if NAT_WMI
    NatShutdownWMI();

    if( NatRegistryPath.Buffer )
    {
        ExFreePool( NatRegistryPath.Buffer );
        RtlInitUnicodeString( &NatRegistryPath, NULL );
    }
#endif

    NatShutdownPptpManagement();
    NatShutdownTimerManagement();
    NatShutdownMappingManagement();
    NatShutdownEditorManagement();
    NatShutdownDirectorManagement();
    NatShutdownDynamicTicketManagement();
    NatShutdownRawIpManagement();
    NatShutdownIcmpManagement();
    NatShutdownInterfaceManagement();

    //
    // Release references to the IP and TCP driver objects
    //

    ObDereferenceObject((PVOID)IpFileObject);
    ObDereferenceObject(IpDeviceObject);
    ObDereferenceObject((PVOID)TcpFileObject);
    ObDereferenceObject(TcpDeviceObject);

    if (TcpDeviceHandle) {

        ZwClose(TcpDeviceHandle);
        TcpDeviceHandle = NULL;
    }

    DeleteComponentReference(&ComponentReference);

} // NatUnloadDriver
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\icmp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    icmp.c

Abstract:

    This module contains the code for manipulating ICMP request/reply mappings.
    When the NAT decides to translate an ICMP request, it creates a mapping
    and places it on the interface's ICMP-mapping list, so that when the reply
    to the request arrives, it can be directed to the appropriate client.

Author:

    Abolade Gbadegesin (t-abolag)   31-July-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// GLOBAL DATA DECLARATIONS
//

NPAGED_LOOKASIDE_LIST IcmpLookasideList;
LIST_ENTRY IcmpMappingList[NatMaximumDirection];
KSPIN_LOCK IcmpMappingLock;

//
// FORWARD DECLARATIONS
//

FORWARD_ACTION
NatpFirewallIcmp(
    PNAT_INTERFACE Interfacep,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp
    );

BOOLEAN
NatTranslateIcmpEncapsulatedRequest(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PIP_HEADER IpHeader,
    PICMP_HEADER IcmpHeader,
    PIP_HEADER EncapsulatedIpHeader,
    struct _ENCAPSULATED_ICMP_HEADER* EncapsulatedIcmpHeader,
    BOOLEAN ChecksumOffloaded
    );

BOOLEAN
NatTranslateIcmpRequest(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    BOOLEAN ReplyCode,
    BOOLEAN ChecksumOffloaded
    );

BOOLEAN
NatTranslateEncapsulatedRequest(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PIP_HEADER IpHeader,
    PICMP_HEADER IcmpHeader,
    PIP_HEADER EncapsulatedIpHeader,
    struct _ENCAPSULATED_UDP_HEADER* EncapsulatedHeader,
    BOOLEAN ChecksumOffloaded
    );


NTSTATUS
NatCreateIcmpMapping(
    PNAT_INTERFACE Interfacep,
    ULONG RemoteAddress,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    PUSHORT PrivateId,
    PUSHORT PublicId,
    PLIST_ENTRY InboundInsertionPoint,
    PLIST_ENTRY OutboundInsertionPoint,
    PNAT_ICMP_MAPPING* MappingCreated
    )

/*++

Routine Description:

    Called to create, initialize, and insert an ICMP mapping in an interface's
    list of ICMP mappings.

    For outbound ICMP requests, we allocate a unique 'PublicId' for the mapping,
    and for inbound requests, we allocate a unique 'PrivateId' for the mapping.

Arguments:

    Interfacep - the interface for the new mapping

    RemoteAddress - the address of the remote endpoint

    PrivateAddress - the address of the machine on the private network

    PublicAddress - the publicly-visible address to replace 'PrivateAddress';
        in case this is 0, an address is chosen in this routine.

    PrivateId - the private-endpoint's identifier for the ICMP message,
        or NULL if an identifier should be chosen by this routine.

    PublicId - the public-endpoint's identifier for the ICMP message,
        or NULL if an identifier should be chosen by this routine.

    InboundInsertionPoint - the entry preceding the new mapping in the list
        sorted for inbound searching

    OutboundInsertionPoint - the entry preceding the new mapping in the list
        sorted for outbound searching

    MappingCreated - receives the mapping created

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    Invoked with 'IcmpMappingLock' held by the caller.

--*/

{
    USHORT Id;
    PLIST_ENTRY Link;
    PNAT_ICMP_MAPPING Mapping;
    PNAT_ICMP_MAPPING DuplicateMapping;
    NTSTATUS status;
    PNAT_ICMP_MAPPING Temp;
    PNAT_USED_ADDRESS UsedAddress;
    CALLTRACE(("NatCreateIcmpMapping\n"));

    //
    // Allocate a new mapping
    //

    Mapping = ALLOCATE_ICMP_BLOCK();
    if (!Mapping) {
        ERROR(("NatCreateIcmpMapping: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the mapping
    //

    Mapping->PrivateKey = MAKE_ICMP_KEY(RemoteAddress, PrivateAddress);

    //
    // See if the public address is specified, and if not, acquire an address
    //

    if (PublicAddress) {
        Mapping->PublicKey = MAKE_ICMP_KEY(RemoteAddress, PublicAddress);
    } else {

        //
        // Acquire an address mapping for the ICMP mapping
        //

        KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
        status =
            NatAcquireFromAddressPool(
                Interfacep,
                PrivateAddress,
                0,
                &UsedAddress
                );

        if (!NT_SUCCESS(status)) {
            KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
            TRACE(ICMP, ("NatCreateIcmpMapping: no address available\n"));
            FREE_ICMP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }
        PublicAddress = UsedAddress->PublicAddress;
        NatDereferenceAddressPoolEntry(Interfacep, UsedAddress);
        KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
        Mapping->PublicKey = MAKE_ICMP_KEY(RemoteAddress, PublicAddress);
    }

    //
    // If no 'PrivateId' is specified, select one.
    //

    if (PrivateId) {
        Mapping->PrivateId = *PrivateId;
    } else {

        //
        // Find the next available identifier
        // by searching the list of inbound mappings
        //

        Id = 1;

        for (Link = IcmpMappingList[NatOutboundDirection].Flink;
             Link != &IcmpMappingList[NatOutboundDirection];
             Link = Link->Flink) {

            Temp =
                CONTAINING_RECORD(
                    Link, NAT_ICMP_MAPPING, Link[NatOutboundDirection]
                    );

            if (Mapping->PrivateKey > Temp->PrivateKey) {
                continue;
            } else if (Mapping->PrivateKey < Temp->PrivateKey) {
                break;
            }

            //
            // Primary key equal; see if the identifier we've chosen
            // collides with this one
            //

            if (Id > Temp->PrivateId) {
                continue;
            } else if (Id < Temp->PrivateId) {
                break;
            }

            //
            // The identifier's collide; choose another and go on
            //

            ++Id;
        }

        if (Link == &IcmpMappingList[NatOutboundDirection] && !Id) {

            //
            // We are at the end of the list, and all 64K-1 IDs are taken
            //

            FREE_ICMP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }

        Mapping->PrivateId = Id;

        //
        // And by the way, we now have the outbound insertion point
        //

        if (!OutboundInsertionPoint) { OutboundInsertionPoint = Link; }
    }

    //
    // If no 'PublicId' is specified, select one.
    //

    if (PublicId) {
        Mapping->PublicId = *PublicId;
    } else {

        //
        // Find the next available identifier
        // by searching the list of inbound mappings
        //

        Id = 1;

        for (Link = IcmpMappingList[NatInboundDirection].Flink;
             Link != &IcmpMappingList[NatInboundDirection];
             Link = Link->Flink) {

            Temp =
                CONTAINING_RECORD(
                    Link, NAT_ICMP_MAPPING, Link[NatInboundDirection]
                    );

            if (Mapping->PublicKey > Temp->PublicKey) {
                continue;
            } else if (Mapping->PublicKey < Temp->PublicKey) {
                break;
            }

            //
            // Primary key equal; see if the identifier we've chosen
            // collides with this one
            //

            if (Id > Temp->PublicId) {
                continue;
            } else if (Id < Temp->PublicId) {
                break;
            }

            //
            // The identifier's collide; choose another and go on
            //

            ++Id;
        }

        if (Link == &IcmpMappingList[NatInboundDirection] && !Id) {

            //
            // We are at the end of the list, and all 64K-1 IDs are taken
            //

            FREE_ICMP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }

        Mapping->PublicId = Id;

        //
        // And by the way, we now have the inbound insertion point
        //

        if (!InboundInsertionPoint) { InboundInsertionPoint = Link; }
    }

    TRACE(
        MAPPING,
        ("NatCreateIcmpMapping: Icmp=%016I64X:%04X::%016I64X:%04X\n",
        Mapping->PrivateKey, Mapping->PrivateId,
        Mapping->PublicKey, Mapping->PublicId
        ));

    //
    // Insert the mapping in the inbound list
    //

    if (!InboundInsertionPoint) {
        DuplicateMapping =
            NatLookupInboundIcmpMapping(
                Mapping->PrivateKey,
                Mapping->PrivateId,
                &InboundInsertionPoint
                );

        if (NULL != DuplicateMapping) {

            //
            // This mapping already exists on the inbound path
            //
            
            FREE_ICMP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }   
    }

    InsertTailList(InboundInsertionPoint, &Mapping->Link[NatInboundDirection]);

    //
    // Insert the mapping in the outbound list
    //

    if (!OutboundInsertionPoint) {
        DuplicateMapping =
            NatLookupOutboundIcmpMapping(
                Mapping->PublicKey,
                Mapping->PublicId,
                &OutboundInsertionPoint
                );

        if (NULL != DuplicateMapping) {

            //
            // This mapping already exists on the outbound path
            //

            RemoveEntryList(&Mapping->Link[NatInboundDirection]);
            FREE_ICMP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }   
    }

    InsertTailList(
        OutboundInsertionPoint, &Mapping->Link[NatOutboundDirection]
        );

    *MappingCreated = Mapping;

    return STATUS_SUCCESS;

} // NatCreateIcmpMapping


VOID
NatInitializeIcmpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the ICMP translation module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeIcmpManagement\n"));
    KeInitializeSpinLock(&IcmpMappingLock);
    InitializeListHead(&IcmpMappingList[NatInboundDirection]);
    InitializeListHead(&IcmpMappingList[NatOutboundDirection]);
    ExInitializeNPagedLookasideList(
        &IcmpLookasideList,
        NatAllocateFunction,
        NULL,
        0,
        sizeof(NAT_ICMP_MAPPING),
        NAT_TAG_ICMP,
        ICMP_LOOKASIDE_DEPTH
        );
} // NatInitializeIcmpManagement


PNAT_ICMP_MAPPING
NatLookupInboundIcmpMapping(
    ULONG64 PublicKey,
    USHORT PublicId,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to find an ICMP mapping using the remote-address
    and the publicly-visible address, which correspond to the 'PublicKey',
    and the 'PublicId' field.

Arguments:

    PublicKey - the remote-address/public-address combination

    PublicId - the mapping's public identifier

    InsertionPoint - receives the insertion-point if the mapping is not found.

Return Value:

    PNAT_ICMP_MAPPING - the mapping found, or NULL if not found.

--*/

{
    PLIST_ENTRY Link;
    PNAT_ICMP_MAPPING Mapping;
    CALLTRACE(("NatLookupInboundIcmpMapping\n"));

    if (InsertionPoint) { *InsertionPoint = NULL; }

    for (Link = IcmpMappingList[NatInboundDirection].Flink;
         Link != &IcmpMappingList[NatInboundDirection]; Link = Link->Flink) {

        Mapping =
            CONTAINING_RECORD(
                Link, NAT_ICMP_MAPPING, Link[NatInboundDirection]
                );

        if (PublicKey > Mapping->PublicKey) {
            continue;
        } else if (PublicKey < Mapping->PublicKey) {
            break;
        }

        //
        // Primary keys equal; check secondary keys.
        //

        if (PublicId > Mapping->PublicId) {
            continue;
        } else if (PublicId < Mapping->PublicId) {
            break;
        }

        //
        // Secondary keys equal, too. This is the requested item.
        //

        return Mapping;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupInboundIcmpMapping



PNAT_ICMP_MAPPING
NatLookupOutboundIcmpMapping(
    ULONG64 PrivateKey,
    USHORT PrivateId,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to find an ICMP mapping using the remote-address
    and the private address, which correspond to the 'PrivateKey'.

Arguments:

    PrivateKey - the remote-address/private-address combination

    PrivateId - the mapping's private identifier

    InsertionPoint - receives insertion-point if mapping not found.

Return Value:

    PNAT_ICMP_MAPPING - the mapping found, or NULL if not found.

--*/

{
    PLIST_ENTRY Link;
    PNAT_ICMP_MAPPING Mapping;
    CALLTRACE(("NatLookupOutboundIcmpMapping\n"));

    if (InsertionPoint) { *InsertionPoint = NULL; }

    for (Link = IcmpMappingList[NatOutboundDirection].Flink;
         Link != &IcmpMappingList[NatOutboundDirection]; Link = Link->Flink) {

        Mapping =
            CONTAINING_RECORD(
                Link, NAT_ICMP_MAPPING, Link[NatOutboundDirection]
                );

        if (PrivateKey > Mapping->PrivateKey) {
            continue;
        } else if (PrivateKey < Mapping->PrivateKey) {
            break;
        }

        //
        // Primary keys equal; check secondary keys.
        //

        if (PrivateId > Mapping->PrivateId) {
            continue;
        } else if (PrivateId < Mapping->PrivateId) {
            break;
        }

        //
        // Keys are equal, so we've found it.
        //

        return Mapping;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // NatLookupOutboundIcmpMapping


FORWARD_ACTION
NatpFirewallIcmp(
    PNAT_INTERFACE Interfacep,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp
    )

/*++

Routine Description:

    This routine encapsulates the ICMP firewall logic. It is
    only used (as of now) for non-boundary FW interfaces

Arguments:

    Interfacep - the boundary interface over which to translate.

    Direction - the direction in which the packet is traveling

    Contextp - initialized with context-information for the packet

Return Value:

    FORWARD_ACTION - indicates action to take on packet.

Environment:

    Invoked with a reference made to 'Interfacep'.

--*/

{
    FORWARD_ACTION act;
    ULONG i;
    PICMP_HEADER IcmpHeader;
    PIP_HEADER IpHeader;
    PNAT_ICMP_MAPPING IcmpMapping;
    ULONG64 PublicKey;
    ULONG64 RemoteKey;
    PLIST_ENTRY InsertionPoint;
    NTSTATUS ntStatus;

    TRACE(XLATE, ("NatpFirewallIcmp\n"));

    if (NatOutboundDirection == Direction) {

        //
        // Make sure this packet has a valid source address
        // for this interface.
        //
        
        act = DROP;
        for (i = 0; i < Interfacep->AddressCount; i++) {
            if (Contextp->SourceAddress ==
                    Interfacep->AddressArray[i].Address
               ) {
                act = FORWARD;
                break;
            }
        }

        if (DROP == act) {
            
            //
            // Invalid source addess -- packet should be
            // dropped w/o any further processing.
            //

            return act;
        }
    }

    IpHeader = Contextp->Header;
    IcmpHeader = (PICMP_HEADER)Contextp->ProtocolHeader;

    switch (IcmpHeader->Type) {

        //
        // Message forewarded only if a corresponding mapping
        // exists. A mapping for an outbound packet can exist only
        // if the use chooses to allow the corresponding request
        // type.
        //
        
        case ICMP_ECHO_REPLY:
        case ICMP_TIMESTAMP_REPLY:
        case ICMP_ROUTER_REPLY:
        case ICMP_MASK_REPLY: {
        
            if (NatInboundDirection == Direction) {
                PublicKey =
                    MAKE_ICMP_KEY(
                        Contextp->SourceAddress,
                        Contextp->DestinationAddress
                        );

                KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
                IcmpMapping =
                    NatLookupInboundIcmpMapping(
                        PublicKey,
                        IcmpHeader->Identifier,
                        &InsertionPoint
                        );

                if (NULL != IcmpMapping) {
                    KeQueryTickCount(
                        (PLARGE_INTEGER)&IcmpMapping->LastAccessTime
                        );
                }
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                        
                act = IcmpMapping != NULL ? FORWARD : DROP;
            } else {
                PublicKey =
                    MAKE_ICMP_KEY(
                        Contextp->DestinationAddress,
                        Contextp->SourceAddress
                        );

                KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
                IcmpMapping =
                    NatLookupOutboundIcmpMapping(
                        PublicKey,
                        IcmpHeader->Identifier,
                        &InsertionPoint
                        );

                if (NULL != IcmpMapping) {
                    KeQueryTickCount(
                        (PLARGE_INTEGER)&IcmpMapping->LastAccessTime
                        );
                }
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                        
                act = IcmpMapping != NULL ? FORWARD : DROP;
            }

            break;
        }
        
        //
        // Outbound messages create a mapping and are forwarded.
        // Inbound messages are dropped, unless configured to
        // allow inbound; if this is the case, create a mapping
        // and forward. The mapping will allow the response
        // to go through the firewall
        //

        case ICMP_ECHO_REQUEST:
        case ICMP_TIMESTAMP_REQUEST:
        case ICMP_ROUTER_REQUEST:
        case ICMP_MASK_REQUEST: {
        
            if (NatOutboundDirection == Direction) {
                act = FORWARD;
                
                //
                // Check to see if a mapping already exists
                //

                PublicKey =
                    MAKE_ICMP_KEY(
                        Contextp->DestinationAddress,
                        Contextp->SourceAddress
                        );

                KeAcquireSpinLockAtDpcLevel (&IcmpMappingLock);
                
                IcmpMapping =
                    NatLookupOutboundIcmpMapping(
                        PublicKey,
                        IcmpHeader->Identifier,
                        &InsertionPoint
                        );

                if (NULL == IcmpMapping) {

                    //
                    // One didn't -- create a new mappping.
                    //

                    ntStatus =
                        NatCreateIcmpMapping(
                            Interfacep,
                            Contextp->DestinationAddress,
                            Contextp->SourceAddress,
                            Contextp->SourceAddress,
                            &IcmpHeader->Identifier,
                            &IcmpHeader->Identifier,
                            NULL,
                            NULL,
                            &IcmpMapping
                            );
                            
                    if (!NT_SUCCESS(ntStatus)) {
                        TRACE(
                            XLATE, (
                            "NatIcmpFirewall: error 0x%x creating mapping\n",
                            ntStatus
                            ));
                        act = DROP;
                    }
                } else {
                    KeQueryTickCount(
                        (PLARGE_INTEGER)&IcmpMapping->LastAccessTime
                        );
                }

                KeReleaseSpinLockFromDpcLevel( &IcmpMappingLock );
            } else {

                //
                // Check to see if inbound for this type is permitted. If
                // so, create a mapping and forward.
                //

                if (NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)) {
                    act = FORWARD;
                
                    //
                    // Check to see if a mapping already exists
                    //

                    PublicKey =
                        MAKE_ICMP_KEY(
                            Contextp->SourceAddress,
                            Contextp->DestinationAddress
                            );

                    KeAcquireSpinLockAtDpcLevel (&IcmpMappingLock);
                    
                    IcmpMapping =
                        NatLookupInboundIcmpMapping(
                            PublicKey,
                            IcmpHeader->Identifier,
                            &InsertionPoint
                            );

                    if (NULL == IcmpMapping) {

                        //
                        // One didn't -- create a new mappping.
                        //

                        ntStatus =
                            NatCreateIcmpMapping(
                                Interfacep,
                                Contextp->SourceAddress,
                                Contextp->DestinationAddress,
                                Contextp->DestinationAddress,
                                &IcmpHeader->Identifier,
                                &IcmpHeader->Identifier,
                                NULL,
                                NULL,
                                &IcmpMapping
                                );
                                
                        if (!NT_SUCCESS(ntStatus)) {
                            TRACE(
                                XLATE, (
                                "NatIcmpFirewall: error 0x%x creating mapping\n",
                                ntStatus
                                ));
                            act = DROP;
                        }
                    } else {
                        KeQueryTickCount(
                            (PLARGE_INTEGER)&IcmpMapping->LastAccessTime
                            );
                    }

                    KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                } else {

                    //
                    // Not permitted.
                    //
                    
                    act = DROP;
                }
            }

            break;
        }
        
        //
        // These messages are allowed inbound, but are dropped outbound
        // (unless the user chooses to allow them). Allowing outbound creates
        // more avenues of attack for port-scanning tools.
        //

        case ICMP_TIME_EXCEED:
        case ICMP_PARAM_PROBLEM:
        case ICMP_DEST_UNREACH:
        case ICMP_SOURCE_QUENCH: {

            if (NatInboundDirection == Direction) {
                act = FORWARD;
            } else {
                act =
                    (NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)
                        ? FORWARD
                        : DROP);
            }
            
            break;
        }

        //
        // These messages are always dropped, no matter the direction
        // (unless the user chooses to allow them).
        //

        case ICMP_REDIRECT: {
            act =
                (NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)
                    ? FORWARD
                    : DROP);
            break;
        }

        //
        // Anything else is dropped by default.
        //
        
        default: {
            act = DROP;
            break;
        }
    }

    return act;
    
} // NatpFirewallIcmp




VOID
NatShutdownIcmpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to clean up the ICMP management module
    when the NAT driver is unloaded.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ExDeleteNPagedLookasideList(&IcmpLookasideList);
} // NatShutdownIcmpManagement


FORWARD_ACTION
NatTranslateIcmp(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InRecvBuffer,
    IPRcvBuf** OutRecvBuffer
    )

/*++

Routine Description:

    This routine is invoked to perform translation on an ICMP message.

Arguments:

    Interfacep - the boundary interface over which to translate, or NULL
        if the packet is inbound and the receiving interface has not been
        added to the NAT.

    Direction - the direction in which the packet is traveling

    Contextp - initialized with context-information for the packet

    InRecvBuffer - input buffer-chain

    OutRecvBuffer - receives modified buffer-chain.

Return Value:

    FORWARD_ACTION - indicates action to take on packet.

Environment:

    Invoked with a reference made to 'Interfacep' by the caller.

--*/

{
    FORWARD_ACTION act;
    BOOLEAN ChecksumOffloaded;
    ULONG i;
    PICMP_HEADER IcmpHeader;
    PIP_HEADER IpHeader;
    TRACE(XLATE, ("NatTranslateIcmp\n"));

    //
    // If the interface is in FW mode and is not a
    // boundary interface, go directly to the firewall
    // logic
    //

    if (Interfacep
        && NAT_INTERFACE_FW(Interfacep)
        && !NAT_INTERFACE_BOUNDARY(Interfacep)) {

        return NatpFirewallIcmp(
            Interfacep,
            Direction,
            Contextp
            );
    }

    IpHeader = Contextp->Header;
    IcmpHeader = (PICMP_HEADER)Contextp->ProtocolHeader;
    ChecksumOffloaded = Contextp->ChecksumOffloaded;

    //
    // The default action is chosen as follows:
    // i. if the packet is incoming on a boundary interface
    //  a. drop if not locally destined
    //  b. drop if the interface is firewalled
    //  c. forward otherwise
    // ii. the packet is outgoing on a boundary interface, drop
    //  if source-address is private.
    //

    if (Direction == NatInboundDirection) {
        if ((*Contextp->DestinationType >= DEST_REMOTE)
            || (Interfacep
                && NAT_INTERFACE_FW(Interfacep)
                && !NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type))) {

            act = DROP;
        } else {
            act = FORWARD;
        }            
    } else {
        //
        // See if the packet's source-address is private
        //
        // N.B. 'Interfacep' is always valid for outbound packets.
        //
        act = DROP;
        for (i = 0; i < Interfacep->AddressCount; i++) {
            if (Contextp->SourceAddress ==
                    Interfacep->AddressArray[i].Address
               ) {
                //
                // The packet's source-address is public,
                // so we'll allow it onto the public network.
                //
                act = FORWARD;
                break;
            }
        }
    }

    //
    // See what kind of ICMP message this is,
    // and translate it if possible.
    //

    switch (IcmpHeader->Type) {
    
        case ICMP_ROUTER_REPLY:
        case ICMP_MASK_REPLY:    
        case ICMP_ECHO_REPLY:
        case ICMP_TIMESTAMP_REPLY: {
        
            if (IpHeader->TimeToLive <= 1) {
                TRACE(XLATE, ("NatTranslateIcmp: ttl<=1, no translation\n"));
                return FORWARD;
            }
            if (Contextp->ProtocolRecvBuffer->ipr_size <
                    FIELD_OFFSET(ICMP_HEADER, EncapsulatedIpHeader) ||
                !NatTranslateIcmpRequest(
                    Interfacep,
                    Direction,
                    Contextp,
                    TRUE,
                    ChecksumOffloaded
                    )) {
                
                return act;
            }
            *OutRecvBuffer = *InRecvBuffer; *InRecvBuffer = NULL;
            *Contextp->DestinationType = DEST_INVALID;
            return FORWARD;
        }

        case ICMP_ROUTER_REQUEST:
        case ICMP_MASK_REQUEST:
        case ICMP_ECHO_REQUEST:
        case ICMP_TIMESTAMP_REQUEST: {
            if (IpHeader->TimeToLive <= 1) {
                TRACE(XLATE, ("NatTranslateIcmp: ttl<=1, no translation\n"));
                return FORWARD;
            }
            if (Contextp->ProtocolRecvBuffer->ipr_size <
                    FIELD_OFFSET(ICMP_HEADER, EncapsulatedIpHeader) ||
                !NatTranslateIcmpRequest(
                    Interfacep,
                    Direction,
                    Contextp,
                    FALSE,
                    ChecksumOffloaded
                    )) {

                //
                // If the interface is in FW mode, we don't want to let
                // a non-translated packet through, unless the user has
                // configured the interface otherwise.
                //

                if (Interfacep
                    && NAT_INTERFACE_FW(Interfacep)
                    && !NAT_INTERFACE_ALLOW_ICMP(
                            Interfacep,
                            IcmpHeader->Type
                            )) {

                    act = DROP;
                }
                
                return act;
            }
            *OutRecvBuffer = *InRecvBuffer; *InRecvBuffer = NULL;
            *Contextp->DestinationType = DEST_INVALID;
            return FORWARD;
        }

        case ICMP_TIME_EXCEED: {

            //
            // Outgoing on a firewalled interface are dropped, unless
            // the user has specified otherwise
            //

            if (Direction == NatOutboundDirection
                && Interfacep
                && NAT_INTERFACE_FW(Interfacep)
                && !NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)) {

                return DROP;
            }

            //
            // Time-exceeded messages will be triggered at each hop
            // to the final destination of a traceroute sequence.
            // Such messages must be translated like ICMP replies.
            // Time-exceeded messages may also be generated
            // in response to TCP/UDP packets, so we translate them
            // in the latter case as well.
            //

            if (Contextp->ProtocolRecvBuffer->ipr_size <
                    sizeof(ICMP_HEADER) ||
                (IcmpHeader->EncapsulatedIpHeader.VersionAndHeaderLength
                    & 0x0f) != 5) {
                return act;
            } else if (IcmpHeader->EncapsulatedIpHeader.Protocol ==
                        NAT_PROTOCOL_ICMP) {
                if ((IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_ECHO_REQUEST
                      && IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_MASK_REQUEST
                      && IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_ROUTER_REQUEST
                      && IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_TIMESTAMP_REQUEST) ||
                     !NatTranslateIcmpEncapsulatedRequest(
                        Interfacep,
                        Direction,
                        IpHeader,
                        IcmpHeader,
                        &IcmpHeader->EncapsulatedIpHeader,
                        &IcmpHeader->EncapsulatedIcmpHeader,
                        ChecksumOffloaded
                        )) {
                    return act;
                }
            } else if (IcmpHeader->EncapsulatedIpHeader.Protocol
                        == NAT_PROTOCOL_TCP ||
                       IcmpHeader->EncapsulatedIpHeader.Protocol
                        == NAT_PROTOCOL_UDP) {
                if (!NatTranslateEncapsulatedRequest(
                        Interfacep,
                        Direction,
                        IpHeader,
                        IcmpHeader,
                        &IcmpHeader->EncapsulatedIpHeader,
                        &IcmpHeader->EncapsulatedUdpHeader,
                        ChecksumOffloaded
                        )) {
                    return act;
                }
            } else {
                return act;
            }
            *OutRecvBuffer = *InRecvBuffer; *InRecvBuffer = NULL;
            *Contextp->DestinationType = DEST_INVALID;
            return FORWARD;
        }

        case ICMP_PARAM_PROBLEM:
        case ICMP_DEST_UNREACH: {

            //
            // Outgoing on a firewalled interface are dropped, unless
            // the user has specified otherwise
            //

            if (Direction == NatOutboundDirection
                && Interfacep
                && NAT_INTERFACE_FW(Interfacep)
                && !NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)) {

                return DROP;
            }

            //
            // Destination unreachable messages will be generated for a variety
            // of reasons. We are interested in the following cases:
            //  * Packet-too-big: When a packet received on a boundary
            //      interface has the 'DF' bit set, the local forwarder may
            //      generate an ICMP error message to the remote endpoint
            //      indicating that the remote system should reduce its MSS.
            //      This error, however, will contain the IP address of the
            //      private network in the encapsulated packet, since the ICMP
            //      error was generated after translation.
            //  * Port-unreachable: Indicates that no application is listening
            //      at the UDP port to which a packet was sent.
            //

            if (Contextp->ProtocolRecvBuffer->ipr_size <
                    sizeof(ICMP_HEADER) ||
                (IcmpHeader->EncapsulatedIpHeader.VersionAndHeaderLength
                    & 0x0f) != 5) {
                return act;
            } else if (IcmpHeader->EncapsulatedIpHeader.Protocol ==
                        NAT_PROTOCOL_ICMP) {
                if ((IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_ECHO_REQUEST
                      && IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_MASK_REQUEST
                      && IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_ROUTER_REQUEST
                      && IcmpHeader->EncapsulatedIcmpHeader.Type !=
                        ICMP_TIMESTAMP_REQUEST) ||
                     !NatTranslateIcmpEncapsulatedRequest(
                        Interfacep,
                        Direction,
                        IpHeader,
                        IcmpHeader,
                        &IcmpHeader->EncapsulatedIpHeader,
                        &IcmpHeader->EncapsulatedIcmpHeader,
                        ChecksumOffloaded
                        )) {
                    return act;
                }
            } else if (IcmpHeader->EncapsulatedIpHeader.Protocol
                        == NAT_PROTOCOL_TCP ||
                       IcmpHeader->EncapsulatedIpHeader.Protocol
                        == NAT_PROTOCOL_UDP) {
                if (!NatTranslateEncapsulatedRequest(
                    Interfacep,
                    Direction,
                    IpHeader,
                    IcmpHeader,
                    &IcmpHeader->EncapsulatedIpHeader,
                    &IcmpHeader->EncapsulatedUdpHeader,
                    ChecksumOffloaded
                    )) {
                    return act;
                }
            } else {
                return act;
            }
            
            *OutRecvBuffer = *InRecvBuffer; *InRecvBuffer = NULL;
            *Contextp->DestinationType = DEST_INVALID;
            return FORWARD;
        }

        case ICMP_SOURCE_QUENCH: {

            //
            // Outgoing on a firewalled interface are dropped, unless
            // the user has specified otherwise
            //

            if (Direction == NatOutboundDirection
                && Interfacep
                && NAT_INTERFACE_FW(Interfacep)
                && !NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)) {

                return DROP;
            }
            
            return act;
        }

        case ICMP_REDIRECT: {
            //
            // We do not translate ICMP redirect errors, since we want
            // the NAT's IP forwarder to see the redirects and adjust
            // its routing table accordingly.
            //
            // However, we do not allow inbound or outbound redirects
            // across a firwall interface, unless the user has
            // specified otherwise
            //

            if (Interfacep
                && NAT_INTERFACE_FW(Interfacep)
                && NAT_INTERFACE_ALLOW_ICMP(Interfacep, IcmpHeader->Type)) {

                act = FORWARD;
            }

            return act;
        }
        
        default: {
            break;
        }
    }

    return act;

} // NatTranslateIcmp


BOOLEAN
NatTranslateIcmpEncapsulatedRequest(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PIP_HEADER IpHeader,
    PICMP_HEADER IcmpHeader,
    PIP_HEADER EncapsulatedIpHeader,
    struct _ENCAPSULATED_ICMP_HEADER* EncapsulatedIcmpHeader,
    BOOLEAN ChecksumOffloaded
    )

/*++

Routine Description:

    This routine is invoked to translate an ICMP error message in which
    we have another ICMP message encapsulated. This is necessary, for instance,
    in the case of ICMP time-exceeded errors, upon which 'traceroute' relies.

Arguments:

    Interfacep - the interface across which the ICMP message will be forwarded,
        or NULL if the packet was received on a non-boundary interface 
        unknown to the NAT.

    Direction - the direction in which the ICMP message is traveling

    IpHeader - points to the IP header of the ICMP message

    IcmpHeader - points to the ICMP header within the IP packet

    EncapsulatedIpHeader - points to the IP header of the ICMP message
        encapsulated in the data portion of the message

    EncapsulatedIcmpHeader - points to the ICMP header of the ICMP message
        encapsulated in the data portion of the message

Return Value:

    BOOLEAN - TRUE if the packet was translated, FALSE otherwise

Environment:

    Invoked at dispatch IRQL with a reference made to 'Interfacep'.

--*/

{
    ULONG Checksum;
    ULONG ChecksumDelta;
    ULONG ChecksumDelta2;
    PNAT_ICMP_MAPPING IcmpMapping;
    ULONG64 Key;
    CALLTRACE(("NatTranslateIcmpEncapsulatedRequest\n"));

    //
    // The checksum processing for encapsulated messages
    // is extremely complicated since we must update
    // (1) the ICMP checksum of the encapsulated ICMP message,
    //     using the change to the encapsulated ICMP identifier
    // (2) the IP header-checksum of the encapsulated ICMP message
    //     using the change to the encapsulated IP addresses
    // (3) the ICMP checksum of the containing ICMP error message
    //     using both the above changes as well as the changes
    //     to both the above checksums
    // (4) the IP header-checksum of the containing ICMP error message
    //     using the change to the containing IP addresses
    // Any changes to the logic below must be made with extreme care.
    //

    if (Direction == NatInboundDirection) {
        Key =
            MAKE_ICMP_KEY(
                EncapsulatedIpHeader->DestinationAddress,
                EncapsulatedIpHeader->SourceAddress
                );
        KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
        IcmpMapping =
            NatLookupInboundIcmpMapping(
                Key,
                EncapsulatedIcmpHeader->Identifier,
                NULL
                );
        if (!IcmpMapping) {
            KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
            TRACE(
                XLATE, (
                "NatTranslateIcmpEncapsulatedRequest: "
                "no mapping for error message\n"
                ));
            return FALSE;
        }

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedIcmpHeader->Identifier);
        EncapsulatedIcmpHeader->Identifier = IcmpMapping->PrivateId;
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedIcmpHeader->Identifier);

        ChecksumDelta2 = ChecksumDelta;
        CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedIcmpHeader->Checksum);
        CHECKSUM_UPDATE(EncapsulatedIcmpHeader->Checksum);
        CHECKSUM_LONG(ChecksumDelta2, EncapsulatedIcmpHeader->Checksum);
        ChecksumDelta = ChecksumDelta2; CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedIpHeader->SourceAddress);
        EncapsulatedIpHeader->SourceAddress =
            ICMP_KEY_PRIVATE(IcmpMapping->PrivateKey);
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedIpHeader->SourceAddress);

        ChecksumDelta2 = ChecksumDelta;
        CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedIpHeader->Checksum);
        CHECKSUM_UPDATE(EncapsulatedIpHeader->Checksum);
        CHECKSUM_LONG(ChecksumDelta2, EncapsulatedIpHeader->Checksum);
        ChecksumDelta = ChecksumDelta2; CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->DestinationAddress);
        IpHeader->DestinationAddress =
            ICMP_KEY_PRIVATE(IcmpMapping->PrivateKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->DestinationAddress);
        CHECKSUM_UPDATE(IpHeader->Checksum);
        KeQueryTickCount((PLARGE_INTEGER)&IcmpMapping->LastAccessTime);
    } else {
        Key =
            MAKE_ICMP_KEY(
                EncapsulatedIpHeader->SourceAddress,
                EncapsulatedIpHeader->DestinationAddress
                );
        KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
        IcmpMapping =
            NatLookupOutboundIcmpMapping(
                Key,
                EncapsulatedIcmpHeader->Identifier,
                NULL
                );
        if (!IcmpMapping) {
            KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
            TRACE(
                XLATE, (
                "NatTranslateIcmpEncapsulatedRequest: "
                "no mapping for error message\n"
                ));
            return FALSE;
        }

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedIcmpHeader->Identifier);
        EncapsulatedIcmpHeader->Identifier = IcmpMapping->PublicId;
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedIcmpHeader->Identifier);

        ChecksumDelta2 = ChecksumDelta;
        CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedIcmpHeader->Checksum);
        CHECKSUM_UPDATE(EncapsulatedIcmpHeader->Checksum);
        CHECKSUM_LONG(ChecksumDelta2, EncapsulatedIcmpHeader->Checksum);
        ChecksumDelta = ChecksumDelta2; CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedIpHeader->DestinationAddress);
        EncapsulatedIpHeader->DestinationAddress =
            ICMP_KEY_PUBLIC(IcmpMapping->PublicKey);
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedIpHeader->DestinationAddress);

        ChecksumDelta2 = ChecksumDelta;
        CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedIpHeader->Checksum);
        CHECKSUM_UPDATE(EncapsulatedIpHeader->Checksum);
        CHECKSUM_LONG(ChecksumDelta2, EncapsulatedIpHeader->Checksum);
        ChecksumDelta = ChecksumDelta2; CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->SourceAddress);
        IpHeader->SourceAddress =
            ICMP_KEY_PUBLIC(IcmpMapping->PublicKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->SourceAddress);
        CHECKSUM_UPDATE(IpHeader->Checksum);
        KeQueryTickCount((PLARGE_INTEGER)&IcmpMapping->LastAccessTime);
    }
    KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);

    //
    // If checksum offloading is enabled on this packet, recompute the
    // IP checksum. (There is no ICMP checksum-offload, so we will never
    // need to fully recompute that.)
    //

    if (ChecksumOffloaded) {
        NatComputeIpChecksum(IpHeader);
    }
    
    return TRUE;
} // NatTranslateIcmpEncapsulatedRequest


BOOLEAN
NatTranslateIcmpRequest(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    BOOLEAN ReplyCode,
    BOOLEAN ChecksumOffloaded
    )

/*++

Routine Description:

    This routine is invoked to translate an ICMP request or reply message.

Arguments:

    Interfacep - the interface across which the ICMP message is to be forwarded,
        or NULL if the packet was received on a non-boundary interface unknown
        to the NAT.

    Direction - the direction in which the ICMP message is traveling

    Contextp - contains information about the packet

    ReplyCode - if TRUE, the message is a reply; otherwise, it is a request.

Return Value:

    BOOLEAN - TRUE if the message was translated, FALSE otherwise.

Environment:

    Invoked at dispatch IRQL with a reference made to 'Interfacep'.

--*/

{
    ULONG Checksum;
    ULONG ChecksumDelta;
    ULONG i;
    PICMP_HEADER IcmpHeader;
    PNAT_ICMP_MAPPING IcmpMapping;
    PIP_HEADER IpHeader;
    PLIST_ENTRY InsertionPoint;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG64 PrivateKey;
    UCHAR Protocol;
    ULONG64 PublicKey;
    ULONG64 RemoteKey;
    NTSTATUS status;
    CALLTRACE(("NatTranslateIcmpRequest\n"));

    IpHeader = Contextp->Header;
    IcmpHeader = (PICMP_HEADER)Contextp->ProtocolHeader;

    //
    // For ICMP requests/replies we must maintain mappings, so begin by seeing
    // if there is already a mapping for this particular message
    //

    InsertionPoint = NULL;

    if (Direction == NatOutboundDirection) {
        PrivateKey =
            MAKE_ICMP_KEY(
                Contextp->DestinationAddress,
                Contextp->SourceAddress
                );
        KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
        IcmpMapping =
            NatLookupOutboundIcmpMapping(
                PrivateKey,
                IcmpHeader->Identifier,
                &InsertionPoint
                );
        if (!IcmpMapping) {

            //
            // No mapping was found, so try to create one.
            //
            // If the packet is an outbound reply-message,
            // there really ought to be a corresponding inbound-mapping.
            // Hence don't try to create one here, as it will just
            // confuse the remote endpoint, which may find itself
            // looking at a reply whose origin seems to be different
            // from the machine to which it sent a request.
            //

            if (ReplyCode) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                TRACE(
                    XLATE, (
                    "NatTranslateIcmpRequest: ignoring outbound reply\n"
                    ));
                return FALSE;
            }

            //
            // First look for a static mapping from this private address
            // to a public address. If one is found, it will be used
            // in the call to 'NatCreateIcmpMapping' below. Otherwise,
            // a public address will be chosen from the address-pool.
            //
            // N.B. When a packet is outbound, 'Interfacep' is always valid.
            //

            PublicKey = 0;
            if (!Interfacep->NoStaticMappingExists) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
                for (i = 0; i < Interfacep->AddressMappingCount; i++) {
                    if (Contextp->SourceAddress >
                        Interfacep->AddressMappingArray[i].PrivateAddress) {
                        continue;
                    } else if (Contextp->SourceAddress <
                           Interfacep->AddressMappingArray[i].PrivateAddress) {
                        break;
                    }
                    PublicKey =
                        Interfacep->AddressMappingArray[i].PublicAddress;
                    break;
                }
                KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
            }

            status =
                NatCreateIcmpMapping(
                    Interfacep,
                    Contextp->DestinationAddress,
                    Contextp->SourceAddress,
                    (ULONG)PublicKey,
                    &IcmpHeader->Identifier,
                    NULL,
                    NULL,
                    InsertionPoint,
                    &IcmpMapping
                    );
            if (!NT_SUCCESS(status)) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                TRACE(
                    XLATE, (
                    "NatTranslateIcmpRequest: error creating mapping\n"
                    ));
                return FALSE;
            }
        }

        //
        // Replace the Identifier in the packet,
        // and replace the destination in the packet,
        // updating the checksum as we go.
        //

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IcmpHeader->Identifier);
        IcmpHeader->Identifier = IcmpMapping->PublicId;
        CHECKSUM_LONG(ChecksumDelta, IcmpHeader->Identifier);
        CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->SourceAddress);
        IpHeader->SourceAddress = ICMP_KEY_PUBLIC(IcmpMapping->PublicKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->SourceAddress);
        CHECKSUM_UPDATE(IpHeader->Checksum);
        KeQueryTickCount((PLARGE_INTEGER)&IcmpMapping->LastAccessTime);
    } else {

        //
        // The packet is inbound.
        //

        PublicKey =
            MAKE_ICMP_KEY(
                Contextp->SourceAddress,
                Contextp->DestinationAddress
                );
        KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
        IcmpMapping =
            NatLookupInboundIcmpMapping(
                PublicKey,
                IcmpHeader->Identifier,
                &InsertionPoint
                );
        if (!IcmpMapping) {

            //
            // No mapping was found, so try to create one,
            // if there is a static mapping which allows inbound sessions.
            // We make an exception for inbound reply-messages;
            // if the packet is a reply-message, it might be locally destined,
            // in which case we pass it untouched to the stack.
            //
            // Don't create a mapping for an inbound reply;
            // it's probably a reply to a locally-initiated request.
            //

            if (ReplyCode) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                return FALSE;
            }

            //
            // First look for a static mapping from this public address
            // to a private address. If one is found, it will be used
            // in the call to 'NatCreateIcmpMapping' below. Otherwise,
            // a public address will be chosen from the address-pool.
            //
            // This involves an exhaustive search since the address-mappings
            // are sorted on private address rather than public address.
            //

            if (!Interfacep) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                return FALSE;
            } else if (Interfacep->NoStaticMappingExists) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                TRACE(
                    XLATE, (
                    "NatTranslateIcmpRequest: ignoring inbound message\n"
                    ));
                return FALSE;
            } else {
                PrivateKey = 0;
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
                for (i = 0; i < Interfacep->AddressMappingCount; i++) {
                    if (Interfacep->AddressMappingArray[i].PublicAddress !=
                        Contextp->DestinationAddress ||
                        !Interfacep->AddressMappingArray[i].AllowInboundSessions) {
                        continue;
                    }
                    PrivateKey =
                        Interfacep->AddressMappingArray[i].PrivateAddress;
                    break;
                }
                KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                if (!PrivateKey) {
                    TRACE(
                        XLATE, (
                        "NatTranslateIcmpRequest: ignoring inbound message\n"
                        ));
                    return FALSE;
                }
                KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
            }

            status =
                NatCreateIcmpMapping(
                    Interfacep,
                    Contextp->SourceAddress,
                    (ULONG)PrivateKey,
                    Contextp->DestinationAddress,
                    NULL,
                    &IcmpHeader->Identifier,
                    InsertionPoint,
                    NULL,
                    &IcmpMapping
                    );
            if (!NT_SUCCESS(status)) {
                KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);
                TRACE(
                    XLATE, (
                    "NatTranslateIcmpRequest: error creating mapping\n"
                    ));
                return FALSE;
            }
        }

        //
        // Replace the Identifier in the packet
        // and replace the destination in the packet,
        // updating the checksum as we go.
        //

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IcmpHeader->Identifier);
        IcmpHeader->Identifier = IcmpMapping->PrivateId;
        CHECKSUM_LONG(ChecksumDelta, IcmpHeader->Identifier);
        CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->DestinationAddress);
        IpHeader->DestinationAddress =
            ICMP_KEY_PRIVATE(IcmpMapping->PrivateKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->DestinationAddress);
        CHECKSUM_UPDATE(IpHeader->Checksum);
        KeQueryTickCount((PLARGE_INTEGER)&IcmpMapping->LastAccessTime);
    }
    KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);

    //
    // If checksum offloading is enabled on this packet, recompute the
    // IP checksum. (There is no ICMP checksum-offload, so we will never
    // need to fully recompute that.)
    //

    if (ChecksumOffloaded) {
        NatComputeIpChecksum(IpHeader);
    }
    return TRUE;
} // NatTranslateIcmpRequest


BOOLEAN
NatTranslateEncapsulatedRequest(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PIP_HEADER IpHeader,
    PICMP_HEADER IcmpHeader,
    PIP_HEADER EncapsulatedIpHeader,
    struct _ENCAPSULATED_UDP_HEADER* EncapsulatedHeader,
    BOOLEAN ChecksumOffloaded
    )

/*++

Routine Description:

    This routine is invoked to translate an ICMP error message in which
    we have TCP segment or UDP datagram encapsulated. This is necessary,
    for instance, in the case of ICMP destination-unreachable errors,
    particularly where the target will take some action (such as reducing MTU)
    upon receipt of the message.

Arguments:

    Interfacep - the interface across which the ICMP message will be forwarded,
        or NULL if the packet was received on a non-boundary interface.

    Direction - the direction in which the ICMP message is traveling

    IpHeader - points to the IP header of the ICMP message

    IcmpHeader - points to the ICMP header within the IP packet

    EncapsulatedIpHeader - points to the IP header of the TCP segment
        encapsulated in the data portion of the ICMP message

    EncapsulatedHeader - points to the TCP/UDP header of the TCP segment
        encapsulated in the data portion of the ICMP message

Return Value:

    BOOLEAN - TRUE if the packet was translated, FALSE otherwise

Environment:

    Invoked at dispatch IRQL with a reference made to 'Interfacep'.

    N.B.!!! This routine will acquire the mapping lock in order to search
    the mapping-tree for the entry corresponding to the session for which
    this ICMP error message was generated. All callers must take note,
    and must ensure that the mapping lock is not already held on entry.

--*/

{
    ULONG Checksum;
    ULONG ChecksumDelta;
    ULONG ChecksumDelta2;
    ULONG64 DestinationKey;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG64 ReplacementKey;
    ULONG64 SourceKey;
    CALLTRACE(("NatTranslateEncapsulatedRequest\n"));

    //
    // We begin by retrieving the mapping for the TCP session
    // to which the contained segment belongs.
    //
    // We need to save the key with which we will replace the
    // encapsulted message's contents. When an error is inbound,
    // it must have been generated in response to an outbound message,
    // and the outbound message contained in the error will have in it
    // the public IP address and port to which we originally translated
    // the outbound message. We therefore need to put back
    // the private IP address and port so that the private machine
    // will be able to identify the error.
    // Similarly, when the error is outbound, we need to put in
    // the public IP address and port so that the remote machine
    // will be able to identify the error.
    //
    // Onward, then. Construct the key to be used for the lookup,
    // take the mapping lock, and look up forward or reverse mappings.
    //

    MAKE_MAPPING_KEY(
        DestinationKey,
        EncapsulatedIpHeader->Protocol,
        EncapsulatedIpHeader->SourceAddress,
        EncapsulatedHeader->SourcePort
        );
    MAKE_MAPPING_KEY(
        SourceKey,
        EncapsulatedIpHeader->Protocol,
        EncapsulatedIpHeader->DestinationAddress,
        EncapsulatedHeader->DestinationPort
        );
    KeAcquireSpinLockAtDpcLevel(&MappingLock);
    if (Direction == NatInboundDirection) {
        Mapping = NatLookupReverseMapping(DestinationKey, SourceKey, NULL);
        if (Mapping) {
            ReplacementKey = Mapping->SourceKey[NatForwardPath];
        } else {
            Mapping = NatLookupForwardMapping(DestinationKey, SourceKey, NULL);
            if (Mapping) {
                ReplacementKey = Mapping->SourceKey[NatReversePath];
            }
        }
    } else {
        Mapping = NatLookupForwardMapping(DestinationKey, SourceKey, NULL);
        if (Mapping) {
            ReplacementKey = Mapping->DestinationKey[NatReversePath];
        } else {
            Mapping = NatLookupReverseMapping(DestinationKey, SourceKey, NULL);
            if (Mapping) {
                ReplacementKey = Mapping->DestinationKey[NatForwardPath];
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&MappingLock);
    if (!Mapping) {
        TRACE(
            XLATE, (
            "NatTranslateEncapsulatedRequest: no mapping for message\n"
            ));
        return FALSE;
    }

    //
    // The checksum processing for encapsulated messages
    // remains extremely complicated since we must update
    // [0] for UDP messages, the UDP message checksum, using the change
    //     to the encapsulated UDP source port. No corresponding change
    //     is required for TCP segments, whose checksum appears beyond
    //     the eight bytes included in ICMP error messages.
    // (1) the IP header-checksum of the encapsulated TCP segment
    //     using the change to the encapsulated IP addresses
    // (2) the ICMP checksum of the containing ICMP error message
    //     using both the above change as well as the change
    //     to the above checksum
    // (3) the IP header-checksum of the containing ICMP error message
    //     using the change to the containing IP addresses
    // Any changes to the logic below must be made with extreme care.
    //

    if (Direction == NatInboundDirection) {
        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedHeader->SourcePort);
        EncapsulatedHeader->SourcePort = MAPPING_PORT(ReplacementKey);
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedHeader->SourcePort);

        if (EncapsulatedIpHeader->Protocol == NAT_PROTOCOL_UDP) {
            ChecksumDelta2 = ChecksumDelta;
            CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedHeader->Checksum);
            CHECKSUM_UPDATE(EncapsulatedHeader->Checksum);
            CHECKSUM_LONG(ChecksumDelta2, EncapsulatedHeader->Checksum);
            ChecksumDelta = ChecksumDelta2;
        }
        CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedIpHeader->SourceAddress);
        EncapsulatedIpHeader->SourceAddress = MAPPING_ADDRESS(ReplacementKey);
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedIpHeader->SourceAddress);

        ChecksumDelta2 = ChecksumDelta;
        CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedIpHeader->Checksum);
        CHECKSUM_UPDATE(EncapsulatedIpHeader->Checksum);
        CHECKSUM_LONG(ChecksumDelta2, EncapsulatedIpHeader->Checksum);
        ChecksumDelta = ChecksumDelta2; CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->DestinationAddress);
        IpHeader->DestinationAddress = MAPPING_ADDRESS(ReplacementKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->DestinationAddress);
        CHECKSUM_UPDATE(IpHeader->Checksum);
    } else {
        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedHeader->DestinationPort);
        EncapsulatedHeader->DestinationPort = MAPPING_PORT(ReplacementKey);
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedHeader->DestinationPort);

        if (EncapsulatedIpHeader->Protocol == NAT_PROTOCOL_UDP) {
            ChecksumDelta2 = ChecksumDelta;
            CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedHeader->Checksum);
            CHECKSUM_UPDATE(EncapsulatedHeader->Checksum);
            CHECKSUM_LONG(ChecksumDelta2, EncapsulatedHeader->Checksum);
            ChecksumDelta = ChecksumDelta2;
        }
        CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~EncapsulatedIpHeader->DestinationAddress);
        EncapsulatedIpHeader->DestinationAddress =
            MAPPING_ADDRESS(ReplacementKey);
        CHECKSUM_LONG(ChecksumDelta, EncapsulatedIpHeader->DestinationAddress);

        ChecksumDelta2 = ChecksumDelta;
        CHECKSUM_LONG(ChecksumDelta2, ~EncapsulatedIpHeader->Checksum);
        CHECKSUM_UPDATE(EncapsulatedIpHeader->Checksum);
        CHECKSUM_LONG(ChecksumDelta2, EncapsulatedIpHeader->Checksum);
        ChecksumDelta = ChecksumDelta2; CHECKSUM_UPDATE(IcmpHeader->Checksum);

        ChecksumDelta = 0;
        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->SourceAddress);
        IpHeader->SourceAddress = MAPPING_ADDRESS(ReplacementKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->SourceAddress);
        CHECKSUM_UPDATE(IpHeader->Checksum);
    }

    //
    // If checksum offloading is enabled on this packet, recompute the
    // IP checksum. (There is no ICMP checksum-offload, so we will never
    // need to fully recompute that.)
    //

    if (ChecksumOffloaded) {
        NatComputeIpChecksum(IpHeader);
    }
    
    return TRUE;
} // NatTranslateEncapsulatedRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\icmp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    icmp.h

Abstract:

    Contains declarations for the NAT's ICMP-message manipulation.

Author:

    Abolade Gbadegesin (t-abolag)   30-July-1997

Revision History:

--*/

#ifndef _NAT_ICMP_H_
#define _NAT_ICMP_H_


//
// Structure:   NAT_ICMP_MAPPING
//
// This structure stores a mapping created for an ICMP-request message.
//
// In order to allow ICMP requests to be associated with replies,
// we translate the 'Identification' field, which operates in a manner
// similar to the TCP/UDP port field; the 'Identification' field is the same
// for a 'session' (e.g. a series of echo-request messages).
//
// This means that when an internal machine 'pings' an external machine,
// we choose a unique 'PublicId' for the 'session' from the point of view
// of the external machine. Likewise, when an external machine 'pings'
// an internal machine, we choose a unique 'PrivateId' for the session.
//
// Hence, on the outbound path we identify ICMP messages using the tuple
//
//  <RemoteAddress # PrivateAddress, PrivateId>
//
// and on the inbound path we identify using the tuple
//
//  <RemoteAddress # PublicAddress, PublicId>
//
// and these tuples are the composite search keys for the outbound and inbound
// list of mappings, respectively, for each interface.
//

typedef struct _NAT_ICMP_MAPPING {

    LIST_ENTRY Link[NatMaximumDirection];
    ULONG64 PrivateKey;
    ULONG64 PublicKey;
    USHORT PrivateId;
    USHORT PublicId;
    LONG64 LastAccessTime;

} NAT_ICMP_MAPPING, *PNAT_ICMP_MAPPING;


//
// ICMP mapping-key manipulation macros
//

#define MAKE_ICMP_KEY(RemoteAddress,OtherAddress) \
    ((ULONG)(RemoteAddress) | ((ULONG64)((ULONG)(OtherAddress)) << 32))

#define ICMP_KEY_REMOTE(Key)        ((ULONG)(Key))
#define ICMP_KEY_PRIVATE(Key)       ((ULONG)((Key) >> 32))
#define ICMP_KEY_PUBLIC(Key)        ((ULONG)((Key) >> 32))


//
// ICMP mapping allocation macros
//

#define ALLOCATE_ICMP_BLOCK() \
    ExAllocateFromNPagedLookasideList(&IcmpLookasideList)

#define FREE_ICMP_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&IcmpLookasideList,(Block))

extern NPAGED_LOOKASIDE_LIST IcmpLookasideList;
extern LIST_ENTRY IcmpMappingList[NatMaximumDirection];
extern KSPIN_LOCK IcmpMappingLock;


//
// ICMP MAPPING MANAGEMENT ROUTINES
//

NTSTATUS
NatCreateIcmpMapping(
    PNAT_INTERFACE Interfacep,
    ULONG RemoteAddress,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    PUSHORT PrivateId,
    PUSHORT PublicId,
    PLIST_ENTRY InboundInsertionPoint,
    PLIST_ENTRY OutboundInsertionPoint,
    PNAT_ICMP_MAPPING* MappingCreated
    );

VOID
NatInitializeIcmpManagement(
    VOID
    );

PNAT_ICMP_MAPPING
NatLookupInboundIcmpMapping(
    ULONG64 PublicKey,
    USHORT PublicId,
    PLIST_ENTRY* InsertionPoint
    );

PNAT_ICMP_MAPPING
NatLookupOutboundIcmpMapping(
    ULONG64 PrivateKey,
    USHORT PrivateId,
    PLIST_ENTRY* InsertionPoint
    );

VOID
NatShutdownIcmpManagement(
    VOID
    );

XLATE_IP_ROUTINE(NatTranslateIcmp)

#endif // _NAT_ICMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\makefile.inc ===
#
# generate binary mof file (bmf) and auxiliarly files
#

clean:
    del natschma.h natschma.bmf 

$(O)\natschma.mof: natschma.mof

$(O)\natschma.bmf: $(O)\natschma.mof

natschma.h: $(O)\natschma.bmf
    wmimofck -h$(O)\natschma.h $(O)\natschma.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\if.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    if.h

Abstract:

    This file contains declarations for interface management.

Author:

    Abolade Gbadegesin (t-abolag)   12-July-1997

Revision History:

--*/

#ifndef _NAT_IF_H_
#define _NAT_IF_H_


//
// Structure:   NAT_ADDRESS
//
// This structure holds an address in an interface's list of binding-addresses.
//

typedef struct _NAT_ADDRESS {
    ULONG Address;
    ULONG Mask;
    ULONG NegatedClassMask;
} NAT_ADDRESS, *PNAT_ADDRESS;

struct _NAT_INTERFACE;

//
// Structure:   NAT_INTERFACE
//
// Holds configuration/operational information for a NAT interface.
//
// Synchronization on an interface makes use of an interface-list lock
// ('InterfaceLock'), a per-interface reference count, and a per-interface
// spin-lock:
//
//  Acquiring a reference to an interface guarantees the interface's existence;
//  acquiring the interface's spin-lock guarantees the interface's consistency.
//
//  To acquire a reference, first acquire the interface-list lock;
//  to traverse the interface-list, first acquire the interface-list lock.
//
//  An interface's spin-lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
//  Note that holding the list lock alone does not guarantee consistency.
//
// Each session being associated with an interface is linked into its
// of mappings ('MappingList'). Access to this list of mappings must also 
// be synchronized. This is achieved using 'InterfaceMappingLock', which
// must be acquired before modifying any interface's list of mappings.
// See 'MAPPING.H' for further details.
//
// N.B. On the rare occasions when 'MappingLock' must be held at the same time
// as one of 'InterfaceLock', 'EditorLock', and 'DirectorLock', 'MappingLock'
// must always be acquired first.
//

typedef struct _NAT_INTERFACE {
    LIST_ENTRY Link;
    ULONG ReferenceCount;
    KSPIN_LOCK Lock;
    ULONG Index;                    // read-only
    PFILE_OBJECT FileObject;        // read-only
    //
    // Configuration information
    //
    PIP_NAT_INTERFACE_INFO Info;
    ULONG Flags;
    ULONG AddressRangeCount;
    PIP_NAT_ADDRESS_RANGE AddressRangeArray;
    ULONG PortMappingCount;
    PIP_NAT_PORT_MAPPING PortMappingArray;
    ULONG AddressMappingCount;
    PIP_NAT_ADDRESS_MAPPING AddressMappingArray;
    ULONG IcmpFlags;
    USHORT MTU;
    //
    // Binding information
    //
    ULONG AddressCount;             // read-only
    PNAT_ADDRESS AddressArray;      // read-only
    //
    // Operational information
    //
    ULONG NoStaticMappingExists;    // interlocked-access only
    ULONG FreeMapCount;
    PNAT_FREE_ADDRESS FreeMapArray;
    PNAT_USED_ADDRESS UsedAddressTree;
    LIST_ENTRY UsedAddressList;
    LIST_ENTRY TicketList;
    LIST_ENTRY MappingList;
    //
    // Statistical information
    //
    IP_NAT_INTERFACE_STATISTICS Statistics;
} NAT_INTERFACE, *PNAT_INTERFACE;

//
// Flags
//

#define NAT_INTERFACE_BOUNDARY(Interface) \
    ((Interface)->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY)

#define NAT_INTERFACE_NAPT(Interface) \
    ((Interface)->Flags & IP_NAT_INTERFACE_FLAGS_NAPT)

#define NAT_INTERFACE_FW(Interface) \
    ((Interface)->Flags & IP_NAT_INTERFACE_FLAGS_FW)

#define NAT_INTERFACE_FLAGS_DELETED         0x80000000
#define NAT_INTERFACE_DELETED(Interface) \
    ((Interface)->Flags & NAT_INTERFACE_FLAGS_DELETED)

#define NAT_INTERFACE_ALLOW_ICMP(Interface, MessageCode) \
    ((Interface)->IcmpFlags & (1 << MessageCode))

//
// Defines the depth of the lookaside list for allocating ICMP mappings
//

#define ICMP_LOOKASIDE_DEPTH        10

//
// Defines the depth of the lookaside list for allocating IP mappings
//

#define IP_LOOKASIDE_DEPTH          10

//
// Minimum interface MTU
//
#define MIN_VALID_MTU               68

//
// GLOBAL DATA DECLARATIONS
//

extern ULONG FirewalledInterfaceCount;
extern CACHE_ENTRY InterfaceCache[CACHE_SIZE];
extern ULONG InterfaceCount;
extern LIST_ENTRY InterfaceList;
extern KSPIN_LOCK InterfaceLock;
extern KSPIN_LOCK InterfaceMappingLock;

//
// INTERFACE MANAGEMENT ROUTINES
//

VOID
NatCleanupInterface(
    IN PNAT_INTERFACE Interfacep
    );

NTSTATUS
NatConfigureInterface(
    IN PIP_NAT_INTERFACE_INFO InterfaceInfo,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
NatCreateInterface(
    IN PIP_NAT_CREATE_INTERFACE CreateInterface,
    IN PFILE_OBJECT FileObject
    );

VOID
NatDeleteAnyAssociatedInterface(
    PFILE_OBJECT FileObject
    );

NTSTATUS
NatDeleteInterface(
    IN ULONG Index,
    IN PFILE_OBJECT FileObject
    );

//
// BOOLEAN
// NatDereferenceInterface(
//     PNAT_INTERFACE Interfacep
//     );
//

#define \
NatDereferenceInterface( \
    _Interfacep \
    ) \
    (InterlockedDecrement(&(_Interfacep)->ReferenceCount) \
        ? TRUE \
        : (NatCleanupInterface(_Interfacep), FALSE))

VOID
NatInitializeInterfaceManagement(
    VOID
    );

PIP_NAT_ADDRESS_MAPPING
NatLookupAddressMappingOnInterface(
    IN PNAT_INTERFACE Interfacep,
    IN ULONG PublicAddress
    );

//
// PNAT_INTERFACE
// NatLookupCachedInterface(
//     IN ULONG Index,
//     IN OUT PNAT_INTERFACE Interfacep
//     );
//

#define \
NatLookupCachedInterface( \
    _Index, \
    _Interfacep \
    ) \
    ((((_Interfacep) = InterlockedProbeCache(InterfaceCache, (_Index))) && \
       (_Interfacep)->Index == (_Index) && \
       !NAT_INTERFACE_DELETED((_Interfacep))) \
        ? (_Interfacep) \
        : (((_Interfacep) = NatLookupInterface((_Index), NULL)) \
            ? (InterlockedUpdateCache(InterfaceCache,(_Index),(_Interfacep)), \
                (_Interfacep)) \
            : NULL))

PNAT_INTERFACE
NatLookupInterface(
    IN ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

PIP_NAT_PORT_MAPPING
NatLookupPortMappingOnInterface(
    IN PNAT_INTERFACE Interfacep,
    IN UCHAR Protocol,
    IN USHORT PublicPort
    );

VOID
NatMappingAttachInterface(
    PNAT_INTERFACE Interfacep,
    PVOID InterfaceContext,
    PNAT_DYNAMIC_MAPPING Mapping
    );

VOID
NatMappingDetachInterface(
    PNAT_INTERFACE Interfacep,
    PVOID InterfaceContext,
    PNAT_DYNAMIC_MAPPING Mapping
    );

NTSTATUS
NatQueryInformationInterface(
    IN ULONG Index,
    IN PIP_NAT_INTERFACE_INFO InterfaceInfo,
    IN PULONG Size
    );

NTSTATUS
NatQueryStatisticsInterface(
    IN ULONG Index,
    IN PIP_NAT_INTERFACE_STATISTICS InterfaceStatistics
    );

//
// BOOLEAN
// NatReferenceInterface(
//     PNAT_INTERFACE Interfacep
//     );
//

#define \
NatReferenceInterface( \
    _Interfacep \
    )  \
    (NAT_INTERFACE_DELETED(_Interfacep) \
        ? FALSE \
        : (InterlockedIncrement(&(_Interfacep)->ReferenceCount), TRUE))

VOID
NatResetInterface(
    IN PNAT_INTERFACE Interfacep
    );

VOID
NatShutdownInterfaceManagement(
    VOID
    );

#endif // _NAT_IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\if.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    if.c

Abstract:

    This file contains code for interface management.

Author:

    Abolade Gbadegesin (t-abolag)   12-July-1997

Revision History:

    Abolade Gbadegesin (aboladeg)   19-July-1998

    Substantially rewritten as part of change to a global mapping-tree.

--*/

#include "precomp.h"
#pragma hdrstop


//
// GLOBAL DATA DEFINITIONS
//

ULONG FirewalledInterfaceCount;
CACHE_ENTRY InterfaceCache[CACHE_SIZE];
ULONG InterfaceCount;
LIST_ENTRY InterfaceList;
KSPIN_LOCK InterfaceLock;
KSPIN_LOCK InterfaceMappingLock;


VOID
NatCleanupInterface(
    PNAT_INTERFACE Interfacep
    )

/*++

Routine Description:

    Called to perform cleanup for an interface.

    On completion, the memory for the interface is freed and its context
    becomes invalid.

Arguments:

    Interfacep - the interface to be cleaned up.

Return Value:

    none.

Environment:

    Invoked with no references to 'Interfacep', and with 'Interfacep' already
    removed from the interface list.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatCleanupInterface\n"));

    InterlockedClearCache(InterfaceCache, Interfacep->Index);

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    NatResetInterface(Interfacep);
    KeReleaseSpinLock(&InterfaceLock, Irql);
    if (Interfacep->AddressArray) { ExFreePool(Interfacep->AddressArray); }
    if (Interfacep->Info) { ExFreePool(Interfacep->Info); }
    ExFreePool(Interfacep);

    InterlockedDecrement(&InterfaceCount);

} // NatCleanupInterface


LONG
FASTCALL
NatCompareAddressMappingCallback(
    VOID* a,
    VOID* b
    )

/*++

Routine Description:

    This routine is the callback invoked by our sorting routine
    when we ask it to sort the array of configured address-mappings.
    The sorting treats the 'PublicAddress' field as an integer.

Arguments:

    a - first mapping

    b - second mapping

Return Value:

    LONG - the result of the comparison (<0, ==0, >0).

--*/

{
    return
        ((PIP_NAT_ADDRESS_MAPPING)a)->PrivateAddress -
        ((PIP_NAT_ADDRESS_MAPPING)b)->PrivateAddress;
}


LONG
FASTCALL
NatComparePortMappingCallback(
    VOID* a,
    VOID* b
    )

/*++

Routine Description:

    This routine is the callback invoked by our sorting routine
    when we ask it to sort the array of configured port-mappings.
    The sorting catenates the 'Protocol' and 'PublicPort' fields
    and treats the result as a 24 bit integer.

Arguments:

    a - first mapping

    b - second mapping

Return Value:

    LONG - the result of the comparison (<0, ==0, >0).

--*/

{
    return
        (((PIP_NAT_PORT_MAPPING)a)->Protocol -
            ((PIP_NAT_PORT_MAPPING)b)->Protocol) ||
        (((PIP_NAT_PORT_MAPPING)a)->PublicPort -
            ((PIP_NAT_PORT_MAPPING)b)->PublicPort);
}


NTSTATUS
NatConfigureInterface(
    IN PIP_NAT_INTERFACE_INFO InterfaceInfo,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine handles the (re)configuration of an interface on receipt
    of IOCTL_IP_NAT_SET_INTERFACE_INFO from a user-mode client.

Arguments:

    InterfaceInfo - contains the new configuration

    FileObject - file-object of the requestor

Return Value:

    NTSTATUS - status code.

--*/

{
    PRTR_TOC_ENTRY Entry;
    PRTR_INFO_BLOCK_HEADER Header;
    ULONG i;
    PIP_NAT_INTERFACE_INFO Info;
    PNAT_INTERFACE Interfacep;
    ULONG Index;
    KIRQL Irql;
    ULONG j;
    ULONG Size;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN WaitRequired;

    CALLTRACE(("NatConfigureInterface\n"));

    //
    // Create a copy of the new configuration;
    // we must do this before raising IRQL since 'InterfaceInfo' may be
    // a pageable user-mode buffer.
    //

    Header = &InterfaceInfo->Header;
    Size = FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) + Header->Size;

    Info = ExAllocatePoolWithTag(NonPagedPool, Size, NAT_TAG_IF_CONFIG);
    if (!Info) {
        ERROR(("NatConfigureInterface: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    RtlCopyMemory(Info, InterfaceInfo, Size);

    //
    // Lookup the interface to be configured
    //

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    Interfacep = NatLookupInterface(InterfaceInfo->Index, NULL);
    if (!Interfacep || Interfacep->FileObject != FileObject) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        ExFreePool(Info);
        return STATUS_INVALID_PARAMETER;
    }
    NatReferenceInterface(Interfacep);

    KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
    NatResetInterface(Interfacep);
    if (NAT_INTERFACE_FW(Interfacep)) {
        ASSERT(FirewalledInterfaceCount > 0);
        InterlockedDecrement(&FirewalledInterfaceCount);
    }
    Interfacep->Flags &= ~IP_NAT_INTERFACE_FLAGS_ALL;
    Interfacep->Flags |=
        (Info->Flags & IP_NAT_INTERFACE_FLAGS_ALL);

    if (NAT_INTERFACE_FW(Interfacep)) {
        InterlockedIncrement(&FirewalledInterfaceCount);
    }

    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

    //
    // Destroy the original configuration, if any.
    //

    if (Interfacep->Info) { ExFreePool(Interfacep->Info); }
    Interfacep->Info = Info;
    Interfacep->AddressRangeCount = 0;
    Interfacep->AddressRangeArray = NULL;
    Interfacep->AddressMappingCount = 0;
    Interfacep->AddressMappingArray = NULL;
    Interfacep->PortMappingCount = 0;
    Interfacep->PortMappingArray = NULL;

    Header = &Interfacep->Info->Header;

    //
    // Parse the new configuration
    //

    for (i = 0; i < Header->TocEntriesCount && NT_SUCCESS(status); i++) {

        Entry = &Header->TocEntry[i];

        switch (Entry->InfoType) {

            case IP_NAT_ADDRESS_RANGE_TYPE: {
                Interfacep->AddressRangeCount = Entry->Count;
                Interfacep->AddressRangeArray =
                    (PIP_NAT_ADDRESS_RANGE)GetInfoFromTocEntry(Header,Entry);
                break;
            }

            case IP_NAT_PORT_MAPPING_TYPE: {
                Interfacep->PortMappingCount = Entry->Count;
                Interfacep->PortMappingArray =
                    (PIP_NAT_PORT_MAPPING)GetInfoFromTocEntry(Header,Entry);

                //
                // Sort the mappings so that we can do fast lookups
                // using binary search later on in the translate-path.
                //

                status =
                    ShellSort(
                        Interfacep->PortMappingArray,
                        Entry->InfoSize,
                        Entry->Count,
                        NatComparePortMappingCallback,
                        NULL
                        );
                if (!NT_SUCCESS(status)) {
                    ERROR(("NatConfigureInterface: ShellSort failed\n"));
                    break;
                }

                break;
            }

            case IP_NAT_ADDRESS_MAPPING_TYPE: {
                Interfacep->AddressMappingCount = Entry->Count;
                Interfacep->AddressMappingArray =
                    (PIP_NAT_ADDRESS_MAPPING)GetInfoFromTocEntry(Header,Entry);

                //
                // Sort the mappings so that we can do fast lookups
                // using binary search later on in the translate-path.
                //

                status =
                    ShellSort(
                        Interfacep->AddressMappingArray,
                        Entry->InfoSize,
                        Entry->Count,
                        NatCompareAddressMappingCallback,
                        NULL
                        );
                if (!NT_SUCCESS(status)) {
                    ERROR(("NatConfigureInterface: ShellSort failed\n"));
                    break;
                }

                break;
            }

            case IP_NAT_ICMP_CONFIG_TYPE: {
                Interfacep->IcmpFlags =
                    *(PULONG) GetInfoFromTocEntry(Header,Entry);

                break;
            }
        }
    }

    InterlockedExchange(
        &Interfacep->NoStaticMappingExists,
        !(Interfacep->AddressMappingCount || Interfacep->PortMappingCount)
        );

    if (NT_SUCCESS(status)) {
        status = NatCreateAddressPool(Interfacep);
    }

    if (!NT_SUCCESS(status)) {
        KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
        KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
        KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
        NatResetInterface(Interfacep);
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
    }

    KeReleaseSpinLock(&Interfacep->Lock, Irql);

    NatDereferenceInterface(Interfacep);

    return status;

} // NatConfigureInterface


USHORT
NatpGetInterfaceMTU(
    ULONG index
)

/*++

Routine Description:
 
    This routine returns the MTU of a interface.  
    The code here is a copy-paste version of those in http.sys.
   
Arguments:

    index - the inteface index

Return Value:

    ULONG - the MTU of the specified interface

--*/
{
    IFEntry *IFEntryPtr = NULL;
    TDIEntityID *EntityTable = NULL, *EntityPtr = NULL;
    BYTE IFBuf[sizeof(IFEntry) + MAX_IFDESCR_LEN];
    TCP_REQUEST_QUERY_INFORMATION_EX ReqInBuf;
    IO_STATUS_BLOCK IoStatus;
    KEVENT LocalEvent;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG InBufLen = 0, OutBufLen = 0;
    TDIObjectID *ID = NULL;
    USHORT InterfaceMTU = 0;
    ULONG i, NumEntities = 0;
    HANDLE EventHandle;

    CALLTRACE(("NatpGetInterfaceMTU (0x%08X)\n", index));
    
    if (NULL == TcpDeviceHandle) {
        return 0;
    }

    //
    // Find the interface instance corresponding to the interface index 
    //
    InBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    OutBufLen = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;

    EntityTable = 
        (TDIEntityID *) ExAllocatePoolWithTag(
            PagedPool, OutBufLen, NAT_TAG_IF_CONFIG);

    if (!EntityTable)
    {
        ERROR(("NatpGetInterfaceMTU: TDIEntityID Buffer Allocation Failed\n"));
        return 0;
    }

    RtlZeroMemory(EntityTable, OutBufLen);
    RtlZeroMemory(&ReqInBuf, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));

    ID = &(ReqInBuf.ID);

    ID->toi_entity.tei_entity   = GENERIC_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_GENERIC;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = ENTITY_LIST_ID;

    status = ZwCreateEvent (&EventHandle, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (!NT_SUCCESS(status)) {
        ERROR(("NatpGetInterfaceMTU: ZwCreateEvent = 0x%08X\n", status));
        if (EntityTable)
            ExFreePool(EntityTable);
         return 0;
    }

    status = 
        ZwDeviceIoControlFile(
           TcpDeviceHandle,                // FileHandle
           EventHandle,                    // Event
           NULL,                           // ApcRoutine
           NULL,                           // ApcContext
           &IoStatus,                      // IoStatusBlock
           IOCTL_TCP_QUERY_INFORMATION_EX, // IoControlCode
           (PVOID)&ReqInBuf,               // InputBuffer
           InBufLen,                       // InputBufferLength
           (PVOID)EntityTable,             // OutputBuffer
           OutBufLen                       // OutputBufferLength
           );

     if ( STATUS_PENDING == status ) {
         ZwWaitForSingleObject(
             EventHandle, 
             FALSE,
             NULL
             );
         status = IoStatus.Status;
     }

     ZwResetEvent(EventHandle, NULL);

     if (!NT_SUCCESS(status)) {
         ERROR(("NatpGetInterfaceMTU: TcpQueryInformationEx = 0x%08X\n", status));

         if (EntityTable)
            ExFreePool(EntityTable);
         return 0;
     } 

    //
    // Now we have all the TDI entities.  
    //
    NumEntities = ((ULONG)(IoStatus.Information)) / sizeof(TDIEntityID);

    TRACE(XLATE, ("NatpGetInterfaceMTU: Find %d TDI entities\n", NumEntities));

    // Search through the interface entries
    for (i = 0, EntityPtr = EntityTable; i < NumEntities; i++, EntityPtr++)
    {
        if (EntityPtr->tei_entity == IF_ENTITY)
        {
            //
            // Get the full IFEntry. It's a pitty that we only look at the
            // Mtu size after getting such a big structure.
            //
            OutBufLen = sizeof(IFEntry) + MAX_IFDESCR_LEN;
            IFEntryPtr = (IFEntry *)IFBuf;

            RtlZeroMemory(IFEntryPtr, OutBufLen);

            InBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
            RtlZeroMemory(&ReqInBuf,sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
            
            ID = &(ReqInBuf.ID);

            ID->toi_entity.tei_entity   = IF_ENTITY;
            ID->toi_entity.tei_instance = EntityPtr->tei_instance;
            ID->toi_class               = INFO_CLASS_PROTOCOL;
            ID->toi_type                = INFO_TYPE_PROVIDER;
            ID->toi_id                  = IF_MIB_STATS_ID;
 
            status = 
                ZwDeviceIoControlFile(
                    TcpDeviceHandle,                // FileHandle
                    EventHandle,                    // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &IoStatus,                      // IoStatusBlock
                    IOCTL_TCP_QUERY_INFORMATION_EX, // IoControlCode
                    (PVOID)&ReqInBuf,               // InputBuffer
                    InBufLen,                       // InputBufferLength
                    (PVOID)IFEntryPtr,              // OutputBuffer
                    OutBufLen                       // OutputBufferLength
                    );

            if ( STATUS_PENDING == status ) {
                ZwWaitForSingleObject(
                    EventHandle, 
                    FALSE,
                    NULL
                    );
                status = IoStatus.Status;
            }
            
            ZwResetEvent(EventHandle, NULL);

            if (!NT_SUCCESS(status)) {
                ERROR(("NatpGetInterfaceMTU: TcpQueryInformationEx (2) = 0x%08X\n", status));
                break;
            }

            if (IFEntryPtr) { 
                   
                if (IFEntryPtr->if_index == index) {                    
                   // 
                   // find the specific interface so return its MTU.
                   //
                   if (IFEntryPtr->if_mtu <= MAXUSHORT)
                      InterfaceMTU = (USHORT)(IFEntryPtr->if_mtu);

                   TRACE(
                       XLATE, 
                       ("NatpGetInterfaceMTU: Interface (0x%08X)'s MTU = %d\n", 
                           index, InterfaceMTU));
                   break;
                 }
            }
        }
    }

    if (EventHandle) {
        ZwClose(EventHandle);
    }

    if (EntityTable) {
        ExFreePool(EntityTable);
    }

    if (MIN_VALID_MTU > InterfaceMTU) {
        return 0;
    } else {
        return InterfaceMTU;
    }
}

NTSTATUS
NatCreateInterface(
    IN PIP_NAT_CREATE_INTERFACE CreateInterface,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine handles the creation of a NAT interface-object.
    The interface is initialized and placed on the interface-list;
    the configuration information is later supplied to 'NatConfigureInterface'.

Arguments:

    CreateInterface - describes the interface to be created

    FileObject - identifies the user-mode process associated with the interface

Return Value:

    NTSTATUS - status code.

--*/

{
    PNAT_ADDRESS AddressArray;
    ULONG AddressCount;
    PIP_ADAPTER_BINDING_INFO BindingInfo;
    ULONG i;
    ULONG Index;
    PLIST_ENTRY InsertionPoint;
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    USHORT mtu = 0;

    CALLTRACE(("NatCreateInterface\n"));

    //
    // Allocate space for the interface's address.
    // We do this before raising IRQL since 'CreateInterface' may be
    // a pageable user-mode buffer.
    //
    // N.B. We allocate one more address than needed,
    // to ensure that 'AddressArray[0]' can be always read
    // even if there are no addresses. This allows us to optimize
    // checks for locally-destined packets in 'NatpReceivePacket'
    // and for locally-originated packets in 'NatpSendPacket'.
    //

    BindingInfo = (PIP_ADAPTER_BINDING_INFO)CreateInterface->BindingInfo;
    AddressArray =
        (PNAT_ADDRESS)
            ExAllocatePoolWithTag(
                NonPagedPool,
                (BindingInfo->AddressCount + 1) * sizeof(NAT_ADDRESS),
                NAT_TAG_ADDRESS
                );
    if (!AddressArray) {
        ERROR(("NatCreateInterface: address-array allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    //
    // Copy the binding information to the allocated space.
    //

    AddressCount = BindingInfo->AddressCount;
    for (i = 0; i < BindingInfo->AddressCount; i++) {
        AddressArray[i].Address = BindingInfo->Address[i].Address;
        AddressArray[i].Mask = BindingInfo->Address[i].Mask;
        AddressArray[i].NegatedClassMask = 
            ~(GET_CLASS_MASK(BindingInfo->Address[i].Address));
    }

    //
    // Obtain the MTU of this interface.  If failed, set to the mininum value.
    //
    mtu = NatpGetInterfaceMTU(CreateInterface->Index);
 
    //
    // See if an interface with the given index exists already
    //

    Index = CreateInterface->Index;
    KeAcquireSpinLock(&InterfaceLock, &Irql);
    if (NatLookupInterface(Index, &InsertionPoint)) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        ERROR(("NatCreateInterface: interface %d already exists\n", Index));
        ExFreePool(AddressArray);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate space for the new interface
    //

    Interfacep =
        (PNAT_INTERFACE)
            ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(NAT_INTERFACE),
                NAT_TAG_INTERFACE
                );
    if (!Interfacep) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        ERROR(("NatCreateInterface: interface allocation failed\n"));
        ExFreePool(AddressArray);
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(Interfacep, sizeof(NAT_INTERFACE));

    //
    // Initialize the interface
    //

    KeInitializeSpinLock(&Interfacep->Lock);
    Interfacep->ReferenceCount = 1;
    Interfacep->Index = Index;
    Interfacep->FileObject = FileObject;
    Interfacep->AddressArray = AddressArray;
    Interfacep->AddressCount = AddressCount;
    Interfacep->MTU = mtu;
    InitializeListHead(&Interfacep->Link);
    InitializeListHead(&Interfacep->UsedAddressList);
    InitializeListHead(&Interfacep->MappingList);
    InitializeListHead(&Interfacep->TicketList);

    InsertTailList(InsertionPoint, &Interfacep->Link);
    KeReleaseSpinLock(&InterfaceLock, Irql);

    InterlockedIncrement(&InterfaceCount);

    return STATUS_SUCCESS;

} // NatCreateInterface


NTSTATUS
NatDeleteInterface(
    IN ULONG Index,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    Handles interface deletion. The interface is removed from the interface
    list, and if there are no references to it, it is immediately cleaned up.

Arguments:

    Index - specifies the interface to be deleted.

    FileObject - indicates the file-object of the requestor

Return Value

    NTSTATUS - status code.

--*/

{
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    CALLTRACE(("NatDeleteInterface\n"));

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    Interfacep = NatLookupInterface(Index, NULL);
    if (!Interfacep || Interfacep->FileObject != FileObject) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }
    RemoveEntryList(&Interfacep->Link);
    InterlockedClearCache(InterfaceCache, Interfacep->Index);
    Interfacep->Flags |= NAT_INTERFACE_FLAGS_DELETED;
    if (NAT_INTERFACE_FW(Interfacep)) {
        ASSERT(FirewalledInterfaceCount > 0);
        InterlockedDecrement(&FirewalledInterfaceCount);
    }
   KeReleaseSpinLock(&InterfaceLock, Irql);

    if (InterlockedDecrement(&Interfacep->ReferenceCount) > 0) {
        return STATUS_PENDING;
    }

    NatCleanupInterface(Interfacep);
    return STATUS_SUCCESS;

} // NatDeleteInterface


VOID
NatDeleteAnyAssociatedInterface(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to delete any interface associated with
    the given file-object.

Arguments:

    FileObject - the file-object to be cleaned up

Return Value:

    none.

--*/

{
    PNAT_INTERFACE Interfacep;
    ULONG Index;
    KIRQL Irql;
    PLIST_ENTRY Link;
    CALLTRACE(("NatDeleteAnyAssociatedInterface\n"));
    KeAcquireSpinLock(&InterfaceLock, &Irql);
    for (Link = InterfaceList.Flink; Link != &InterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, NAT_INTERFACE, Link);
        if (Interfacep->FileObject != FileObject) { continue; }
        Index = Interfacep->Index;
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
        NatDeleteInterface(Index, FileObject);
        KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
        Link = &InterfaceList;
    }
    KeReleaseSpinLock(&InterfaceLock, Irql);
} // NatDeleteAnyAssociatedInterface


VOID
NatInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine prepares the interface-management module for operation.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeInterfaceManagement\n"));
    FirewalledInterfaceCount = 0;
    InterfaceCount = 0;
    TicketCount = 0;
    KeInitializeSpinLock(&InterfaceLock);
    KeInitializeSpinLock(&InterfaceMappingLock);
    InitializeListHead(&InterfaceList);
    InitializeCache(InterfaceCache);

} // NatInitializeInterfaceManagement


PIP_NAT_ADDRESS_MAPPING
NatLookupAddressMappingOnInterface(
    IN PNAT_INTERFACE Interfacep,
    IN ULONG PublicAddress
    )

/*++

Routine Description:

    This routine is invoked to look up an address-mapping on an interface.
    The interface's address-mappings are stored in sorted-order, allowing
    us to use binary-search to quickly locate an address-mapping.
    (See 'NatConfigureInterface' for the code which does the sorting).

    This routine is only of benefit in cases where there are many mappings
    configured, since there is overhead involved in setting up the search.

Arguments:

    Interfacep - the interface on which to perform the search

    PublicAddress - the public address of the mapping to be looked up

Return Value:

    PIP_NAT_ADDRESS_MAPPING - the mapping if found, NULL otherwise.

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    LONG Left = 0;
    LONG Right = (LONG)Interfacep->AddressMappingCount;
    LONG i;

    for ( ; Left <= Right; ) {

        i = Left + (Right - Left) / 2;

        if (PublicAddress < Interfacep->AddressMappingArray[i].PublicAddress) {
            Right = i - 1; continue;
        } else if (PublicAddress >
                    Interfacep->AddressMappingArray[i].PublicAddress) {
            Left = i + 1; continue;
        }

        return &Interfacep->AddressMappingArray[i];
    }

    return NULL;

} // NatLookupAddressMappingOnInterface


PNAT_INTERFACE
NatLookupInterface(
    IN ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to search for an interface with the given index
    in our list of interfaces.

Arguments:

    Index - identifies the interface to be found

    InsertionPoint - optionally receives the link in the list before which
        the interface would be inserted

Return Value:

    PNAT_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked with 'InterfaceLock' held by the caller.

--*/

{
    PNAT_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    TRACE(PER_PACKET, ("NatLookupInterface\n"));

    for (Link = InterfaceList.Flink; Link != &InterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, NAT_INTERFACE, Link);
        if (Interfacep->Index > Index) {
            continue;
        } else if (Interfacep->Index < Index) {
            break;
        }
        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupInterface


PIP_NAT_PORT_MAPPING
NatLookupPortMappingOnInterface(
    IN PNAT_INTERFACE Interfacep,
    IN UCHAR Protocol,
    IN USHORT PublicPort
    )

/*++

Routine Description:

    This routine is invoked to look up a port-mapping on an interface.
    The interface's port-mappings are stored in sorted-order, allowing
    us to use binary-search to quickly locate a port-mapping.
    (See 'NatConfigureInterface' for the code which does the sorting).

    This routine is only of benefit in cases where there are many mappings
    configured, since there is overhead involved in setting up the search.

Arguments:

    Interfacep - the interface on which to perform the search

    Protocol - the protocol of the mapping to be looked up

    PublicPort - the public port of the mapping to be looked up

Return Value:

    PIP_NAT_PORT_MAPPING - the mapping if found, NULL otherwise.

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    LONG Left = 0;
    LONG Right = (LONG)Interfacep->PortMappingCount;
    LONG i;
    ULONG SearchKey, ElementKey;

    SearchKey = (Protocol << 16) | PublicPort;

    for ( ; Left <= Right; ) {

        i = Left + (Right - Left) / 2;

        ElementKey =
            (Interfacep->PortMappingArray[i].Protocol << 16) |
            Interfacep->PortMappingArray[i].PublicPort;

        if (SearchKey < ElementKey) {
            Right = i - 1; continue;
        } else if (SearchKey > ElementKey) {
            Left = i + 1; continue;
        }

        return &Interfacep->PortMappingArray[i];
    }

    return NULL;

} // NatLookupPortMappingOnInterface


VOID
NatMappingAttachInterface(
    PNAT_INTERFACE Interfacep,
    PVOID InterfaceContext,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine is invoked to attach a mapping to an interface.
    It serves as a notification that there is one more mapping 
    associated with the interface.

Arguments:

    Interfacep - the interface for the mapping

    InterfaceContext - context associated with the interface;
        in our case, holds the address-pool entry in use by the mapping

    Mapping - the mapping to be attached.

Return Value:

    none.

Environment:

    Always invoked at dispatch level, with 'InterfaceLock' and
    'InterfaceMappingLock' held.

--*/

{
    Mapping->Interfacep = Interfacep;
    Mapping->InterfaceContext = InterfaceContext;
    InsertTailList(&Interfacep->MappingList, &Mapping->InterfaceLink);
    InterlockedIncrement(&Interfacep->Statistics.TotalMappings);
    if (NAT_MAPPING_INBOUND(Mapping)) {
        InterlockedIncrement(&Interfacep->Statistics.InboundMappings);
    }
} // NatMappingAttachInterface


VOID
NatMappingDetachInterface(
    PNAT_INTERFACE Interfacep,
    PVOID InterfaceContext,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine is invoked to detach a mapping from an interface.
    It serves as a notification that there is one less mapping 
    associated with the interface.

Arguments:

    Interfacep - the interface for the mapping

    InterfaceContext - context associated with the interface;
        in our case, holds the address-pool entry in use by the mapping

    Mapping - the mapping to be attached, or NULL if a mapping could not be
        created.

Return Value:

    none.

Environment:

    Always invoked at dispatch level, with 'InterfaceLock' and
    'InterfaceMappingLock' held.

--*/

{
    //
    // N.B. The mapping may be NULL, e.g. if its creation failed.
    // In that case we just release the address acquired for the mapping.
    //
    if (Mapping) {
        RemoveEntryList(&Mapping->InterfaceLink);
        Mapping->Interfacep = NULL;
        Mapping->InterfaceContext = NULL;
        if (NAT_MAPPING_INBOUND(Mapping)) {
            InterlockedDecrement(&Interfacep->Statistics.InboundMappings);
        }
        InterlockedDecrement(&Interfacep->Statistics.TotalMappings);
    }
    NatDereferenceAddressPoolEntry(
        Interfacep,
        (PNAT_USED_ADDRESS)InterfaceContext
        );
} // NatMappingDetachInterface


NTSTATUS
NatQueryInformationInterface(
    IN ULONG Index,
    IN PIP_NAT_INTERFACE_INFO InterfaceInfo,
    IN PULONG Size
    )

/*++

Routine Description:

    Called to construct the optional information in use on the interface.

Arguments:

    Index - identifies the interface

    InterfaceInfo - receives the retrieved configuration

    Size - the size of the given buffer

Return Value:

    STATUS_SUCCESS if retrieved, STATUS_BUFFER_TOO_SMALL if '*Size' is too
        small, error otherwise.

--*/

{
    PRTR_INFO_BLOCK_HEADER Header;
    ULONG InfoSize;
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    NTSTATUS status = STATUS_SUCCESS;
    PVOID Temp;

    CALLTRACE(("NatQueryInformationInterface\n"));

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    Interfacep = NatLookupInterface(Index, NULL);
    if (!Interfacep) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }
    NatReferenceInterface(Interfacep);
    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

    KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
    Header = &Interfacep->Info->Header;
    InfoSize = FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) + Header->Size;
    if (*Size < InfoSize) {
        KeReleaseSpinLock(&Interfacep->Lock, Irql);
    } else {
        //
        // In transferring the requested information, we must be careful
        // because the output-buffer may be a pageable user-mode address.
        // We cannot take a page-fault while holding the interface's lock
        // at dispatch level, so we make a non-paged copy of the information,
        // release the interface's lock to return to passive level,
        // and then copy the information to the caller's buffer.
        //
        Temp = ExAllocatePoolWithTag(NonPagedPool, InfoSize, NAT_TAG_IF_CONFIG);
        if (!Temp) {
            KeReleaseSpinLock(&Interfacep->Lock, Irql);
            status = STATUS_NO_MEMORY;
            InfoSize = 0;
        } else {
            RtlCopyMemory(Temp, Interfacep->Info, InfoSize);
            KeReleaseSpinLock(&Interfacep->Lock, Irql);
            __try {
                RtlCopyMemory(InterfaceInfo, Temp, InfoSize);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
            ExFreePool(Temp);
        }
    }
    *Size = InfoSize;

    NatDereferenceInterface(Interfacep);

    return status;

} // NatQueryInformationInterface


NTSTATUS
NatQueryStatisticsInterface(
    ULONG Index,
    IN PIP_NAT_INTERFACE_STATISTICS InterfaceStatistics
    )

/*++

Routine Description:

    This routine is invoked to copy the statistics for an interface.
    Note that we do not need to lock the interface to access the statistics,
    since they are all updated using interlocked operations.

Arguments:

    Index - identifies the interface

    InterfaceStatistics - i/o buffer used for transfer of information

Return Value:

    STATUS_SUCCESS if successful, error code otherwise.

--*/

{
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    NTSTATUS Status;

    CALLTRACE(("NatQueryStatisticsInterface\n"));

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    Interfacep = NatLookupInterface(Index, NULL);
    if (!Interfacep) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }
    NatReferenceInterface(Interfacep);
    KeReleaseSpinLock(&InterfaceLock, Irql);

    //
    // Copy the statistics to the caller's buffer
    //

    Status = STATUS_SUCCESS;
    __try {
        *InterfaceStatistics = Interfacep->Statistics;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    NatDereferenceInterface(Interfacep);
    return Status;

} // NatQueryStatisticsInterface


VOID
NatResetInterface(
    IN PNAT_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to destroy all structures hanging off an interface.
    It is used when reconfiguring or cleaning up an interface.

Arguments:

    Interfacep - the interface to be reset.

Return Value:

    none.

Environment:

    Invoked with 'InterfaceLock' held by the caller, and
        (a) 'Interfacep->Lock' also held by the caller, or
        (b) the last reference to the interface released.

--*/

{
    PLIST_ENTRY List;
    PLIST_ENTRY Link;
    PNAT_IP_MAPPING IpMapping;
    KIRQL Irql;
    PNAT_DYNAMIC_MAPPING Mapping;
    PNAT_TICKET Ticket;

    CALLTRACE(("NatResetInterface\n"));

    //
    // Clean out the interface's dynamic mappings
    //

    KeAcquireSpinLockAtDpcLevel(&InterfaceMappingLock);
    List = &Interfacep->MappingList;
    while (!IsListEmpty(List)) {
        Mapping =
            CONTAINING_RECORD(List->Flink, NAT_DYNAMIC_MAPPING, InterfaceLink);
        NatExpireMapping(Mapping);
        NatMappingDetachInterface(
            Interfacep, Mapping->InterfaceContext, Mapping
            );
    }
    KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);

    //
    // Clean out the interface's tickets
    //

    List = &Interfacep->TicketList;
    while (!IsListEmpty(List)) {
        Ticket = CONTAINING_RECORD(List->Flink, NAT_TICKET, Link);
        NatDeleteTicket(Interfacep, Ticket);
    }

    //
    // Clean out the interface's address-pool and port-pool
    //

    NatDeleteAddressPool(Interfacep);

} // NatResetInterface


VOID
NatShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine shuts down the interface-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    CALLTRACE(("NatShutdownInterfaceManagement\n"));

    //
    // Delete all interfaces
    //

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    while (!IsListEmpty(&InterfaceList)) {
        Interfacep =
            CONTAINING_RECORD(InterfaceList.Flink, NAT_INTERFACE, Link);
        RemoveEntryList(&Interfacep->Link);
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
        NatCleanupInterface(Interfacep);
        KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
    }
    KeReleaseSpinLock(&InterfaceLock, Irql);
    InterfaceCount = 0;
    TicketCount = 0;

} // NatShutdownInterfaceManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\natc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    natc.c

Abstract:

    This module contains code for testing the functionality of the NAT.

Author:

    Abolade Gbadegesin (t-abolag)   15-July-1997

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntddip.h>
#include <mprapi.h>
#include <ipfltinf.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <routprot.h>
#undef ERROR
#include "debug.h"
#include "prot.h"
}


#define INET_NTOA(a)    inet_ntoa(*(struct in_addr*)&(a))

#define MAPPING_FORMAT  "%3s %4s %15s/%-5d %15s/%-5d %15s/%-5d %-5d\n"


#define IF_COUNT    3

#define MAKE_ADDRESS(a,b,c,d) \
    ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))

#define NETORDER_PORT(a) \
    ((((a) & 0xFF00) >> 8) | (((a) & 0x00FF) << 8))


ULONG InterfaceIndex;

HANDLE IpHandle = NULL;
HANDLE NatHandle = NULL;

//
// FORWARD DECLARATIONS
//

NTSTATUS
CreateLocalInterface(
    ULONG Address,
    ULONG Mask
    );

VOID
DisplayMapping(
    PIP_NAT_SESSION_MAPPING Mapping
    );

VOID
DumpBuffer(
    PUCHAR Buffer,
    ULONG Size
    );

LONG __cdecl
main(
    LONG    argc,
    CHAR*   argv[]
    )

/*++
--*/

{

    UCHAR               Buffer[256];
    UNICODE_STRING      DeviceString;
    PRTR_INFO_BLOCK_HEADER  Header;
    LONG                i;
    LONG                j;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    ULONG               Offset;
    NTSTATUS            status;
    ULONG               TocCount;
    ULONG               TocEntry;


    //
    // Open the IP driver
    //

    RtlInitUnicodeString(&DeviceString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(
        &ObjectAttributes, &DeviceString, OBJ_CASE_INSENSITIVE, NULL, NULL
        );

    status = NtCreateFile(
                &IpHandle,
                SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_OPEN_IF,
                0,
                NULL,
                0
                );

    if (!NT_SUCCESS(status)) {
        printf("Error 0x%08X opening IP driver.\n", status);
        return status;
    }

    if (argc != 3) {

        //
        // Open the NAT driver
        //
    
        RtlInitUnicodeString(&DeviceString, DD_IP_NAT_DEVICE_NAME);
    
        InitializeObjectAttributes(
            &ObjectAttributes, &DeviceString, OBJ_CASE_INSENSITIVE, NULL, NULL
            );
    
        status = NtCreateFile(
                    &NatHandle,
                    SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0
                    );
    
        if (!NT_SUCCESS(status)) {
            printf("Error 0x%08X opening NAT driver.\n", status);
            NtClose(IpHandle);
            return status;
        }
    }

    if (argc >= 2 && lstrcmpi(argv[1], "-x") == 0) {

        CreateLocalInterface(
            argc == 4 ? inet_addr(argv[2]) : 0,
            argc == 4 ? inet_addr(argv[3]) : 0
            );
    }

#if DBG
    for (;;) {

        ULONG   Option = 0;

        printf("0. Quit\n");
        printf("1. Get Interface Info\n");
        printf("2. Get Interface Statistics\n");
        printf("3. Enumerate Session Mappings\n");
    
        scanf("%d", &Option);

        if (!Option) { break; }

        if (!InterfaceIndex) {
            printf("Enter interface index: ");
            scanf("%d", &InterfaceIndex);
        }

        switch(Option) {

            case 1: {

                PUCHAR Buffer;
                IP_NAT_INTERFACE_INFO InterfaceInfo;
                ULONG Size;

                InterfaceInfo.Index = InterfaceIndex;

                status = NtDeviceIoControlFile(
                            NatHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_IP_NAT_GET_INTERFACE_INFO,
                            (PVOID)&InterfaceInfo,
                            sizeof(InterfaceInfo),
                            NULL,
                            0
                            );

                if (!NT_SUCCESS(status)) {
                    printf("status: 0x%08X\n", status);
                    break;
                }

                printf(
                	"Allocating %d bytes\n", 
                	Size = (ULONG)IoStatusBlock.Information
                	);

                Buffer = (PUCHAR)malloc(Size);

                status = NtDeviceIoControlFile(
                            NatHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_IP_NAT_GET_INTERFACE_INFO,
                            (PVOID)&InterfaceInfo,
                            sizeof(InterfaceInfo),
                            Buffer,
                            Size
                            );

                if (!NT_SUCCESS(status)) {
                    printf("status: 0x%08X\n", status);
                    free(Buffer);
                    break;
                }

                printf(
                	"Retrieved %d bytes\n", 
                	Size = (ULONG)IoStatusBlock.Information
                	);

                DumpBuffer(Buffer, Size);

                free(Buffer);

                break;
            }

            case 2: {

                IP_NAT_INTERFACE_STATISTICS InterfaceStats;

                status = NtDeviceIoControlFile(
                            NatHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_IP_NAT_GET_INTERFACE_STATISTICS,
                            (PVOID)&InterfaceIndex,
                            sizeof(InterfaceIndex),
                            (PVOID)&InterfaceStats,
                            sizeof(InterfaceStats)
                            );

                if (!NT_SUCCESS(status)) {
                    printf("status: 0x%08X\n", status);
                    break;
                }

                printf(
                    "Total Mappings:    %d\n", InterfaceStats.TotalMappings);
                printf(
                    "Inbound Mappings:  %d\n", InterfaceStats.InboundMappings);
                printf(
                    "Packets Forward:   %d\n",
                    InterfaceStats.PacketsForward);
                printf(
                    "Packets Reverse:  %d\n",
                    InterfaceStats.PacketsReverse);
                printf(
                    "Rejects Forward:   %d\n",
                    InterfaceStats.RejectsForward);
                printf(
                    "Rejects Reverse:  %d\n",
                    InterfaceStats.RejectsReverse);

                break;
            }

            case 3: {

                UCHAR Buffer[128];
                PIP_NAT_ENUMERATE_SESSION_MAPPINGS Enum =
                    (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)Buffer;
                ULONG i;

                Enum->Index = InterfaceIndex;
                Enum->EnumerateContext[0] = 0;

#if 0
                printf(
                    "%3s %4s %15s/%-5s %15s/%-5s %15s/%-5s %-5s\n"
                    "DIR", "PROT",
                    "PrivateAddr", "Port", 
                    "PublicAddr", "Port", 
                    "RemoteAddr", "Port", 
                    "Idle"
                    );
#endif

                do {

                    status = NtDeviceIoControlFile(
                                NatHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                IOCTL_IP_NAT_GET_MAPPING_TABLE,
                                (PVOID)Enum,
                                FIELD_OFFSET(
                                    IP_NAT_ENUMERATE_SESSION_MAPPINGS,
                                    EnumerateTable),
                                (PVOID)Enum,
                                sizeof(Buffer)
                                );
    
                    if (!NT_SUCCESS(status)) {
                        printf("status: 0x%08X\n", status);
                        break;
                    }

                    for (i = 0; i < Enum->EnumerateCount; i++) {

                        DisplayMapping(&Enum->EnumerateTable[i]);
                    }

                } while(Enum->EnumerateContext[0]);

                break;
            }
        }
    }
#endif

    if (NatHandle) { NtClose(NatHandle); }
    NtClose(IpHandle);


    return STATUS_SUCCESS;

} // main



VOID
DisplayMapping(
    PIP_NAT_SESSION_MAPPING Mapping
    )
{
    CHAR PrivateAddress[16];
    CHAR PublicAddress[16];
    CHAR RemoteAddress[16];

    strcpy(PrivateAddress, INET_NTOA(Mapping->PrivateAddress));
    strcpy(PublicAddress, INET_NTOA(Mapping->PublicAddress));
    strcpy(RemoteAddress, INET_NTOA(Mapping->RemoteAddress));

    printf(
        MAPPING_FORMAT,
        Mapping->Direction == NatInboundDirection ? "IN" : "OUT",
        Mapping->Protocol == NAT_PROTOCOL_TCP ? "TCP" : "UDP",
        PrivateAddress, ntohs(Mapping->PrivatePort),
        PublicAddress, ntohs(Mapping->PublicPort),
        RemoteAddress, ntohs(Mapping->RemotePort),
        Mapping->IdleTime
        );
}


VOID
DumpBuffer(
    PUCHAR Buffer,
    ULONG Size
    )
{
    int i;
    PULONG Next;

    for (i = 0, Next = (PULONG)Buffer; Next < (PULONG)(Buffer + Size); Next++, i++) {
        printf("0x%08X ", *Next);
        if ((i % 4) == 3) { printf("\n"); }
    }
    if ((i % 4) != 0) { printf("\n"); }
}

typedef HANDLE 
(WINAPI *PCREATE_CAPTURE)(
    PVOID       A1,
    PVOID       A2,
    PVOID       A3
    );

typedef UINT 
(WINAPI *PDESTROY_CAPTURE)(
    HANDLE      CaptureHandle
    );

typedef ULONG 
(WINAPI *PLOAD_CAPTURE)(
    HANDLE      CaptureHandle,
    PCHAR       FileName
    );

typedef ULONG
(WINAPI *PGET_CAPTURE_TOTAL_FRAMES)(
    HANDLE      CaptureHandle
    );

typedef HANDLE 
(WINAPI *PGET_FRAME)(
    HANDLE      CaptureHandle,
    ULONG       FrameNumber
    );

typedef PUCHAR 
(WINAPI *PLOCK_FRAME)(
    HANDLE      FrameHandle
    );

typedef ULONG 
(WINAPI *PUNLOCK_FRAME)(
    HANDLE      FrameHandle
    );

typedef ULONG 
(WINAPI *PGET_FRAME_MAC_TYPE)(
    HANDLE      FrameHandle
    );

typedef ULONG 
(WINAPI *PGET_FRAME_MAC_HEADER_LENGTH)(
    HANDLE      FrameHandle
    );


NTSTATUS
CreateLocalInterface(
    ULONG Address,
    ULONG Mask
    )
{
    UCHAR               Buffer[1024];
    ULONG               i;
    ULONG               IfIndex;
    PMIB_IFTABLE        IfTable = NULL;
    ULONG               IfSize;
    IO_STATUS_BLOCK     IoStatusBlock;
    PMIB_IPADDRTABLE    IpAddrTable = NULL;
    ULONG               IpAddrSize;
    ULONG               j;
    NTSTATUS            status;


    //
    // Retrieve a table of the local interfaces
    //

    IfSize = 0;

    status = GetIfTable(
                NULL,
                &IfSize,
                FALSE
                );

    if (status != ERROR_INSUFFICIENT_BUFFER) { return STATUS_UNSUCCESSFUL; }

    IfTable = (PMIB_IFTABLE)malloc(IfSize);

    if (!IfTable) { return STATUS_NO_MEMORY; }

    memset(IfTable, 0, IfSize);

    
    if (!Address) {

        //
        // Retrieve a table of the local addresses
        //
    
        IpAddrSize = 0;
    
        status = GetIpAddrTable(
                    NULL,
                    &IpAddrSize,
                    FALSE
                    );
    
        if (status != ERROR_INSUFFICIENT_BUFFER) {
            free(IfTable); return STATUS_UNSUCCESSFUL;
        }
    
        IpAddrTable = (PMIB_IPADDRTABLE)malloc(IpAddrSize);
    
        if (!IpAddrTable) {
            free(IfTable); return STATUS_NO_MEMORY;
        }
    }


    do {

    
        status = GetIfTable(
                    IfTable,
                    &IfSize,
                    FALSE
                    );

        if (status != NO_ERROR) { status = STATUS_UNSUCCESSFUL; break; }
    
        if (Address) {

            for (i = 0; i < IfTable->dwNumEntries; i++) {
                printf(
                    "%d. %s [%d]\n", i, IfTable->table[i].bDescr,
                    IfTable->table[i].dwIndex
                    );
            }

            printf("\nEnter interface index: ");
    
            scanf("%d", &IfIndex);
        }
        else {

            status = GetIpAddrTable(
                        IpAddrTable,
                        &IpAddrSize,
                        FALSE
                        );
    
            if (status != NO_ERROR) { status = STATUS_UNSUCCESSFUL; break; }
    
    
            //
            // Display the interfaces
            //
    
            for (i = 0; i < IfTable->dwNumEntries; i++) {
    
                printf("%d. %s ", i, IfTable->table[i].bDescr);
    
                IfTable->table[i].dwSpeed = (ULONG)-1;
    
                for (j = 0; j < IpAddrTable->dwNumEntries; j++) {
    
                    if (IpAddrTable->table[j].dwIndex ==
                            IfTable->table[i].dwIndex){
    
                        printf("[%s]", INET_NTOA(IpAddrTable->table[j].dwAddr));
    
                        IfTable->table[i].dwSpeed = j;
    
                        break;
                    }
                }
    
                printf("\n");
            }

            do { 
    
                printf("\nEnter boundary interface (0-%d): ", i-1);
        
                scanf("%d", &i);
        
            } while (
                i >= IfTable->dwNumEntries ||
                IfTable->table[i].dwSpeed == (ULONG)-1
                );

            Address =  IpAddrTable->table[IfTable->table[i].dwSpeed].dwAddr;
            Mask =  IpAddrTable->table[IfTable->table[i].dwSpeed].dwMask;
            IfIndex = IfTable->table[i].dwIndex;
        }

        //
        // Set the selected interface up as a boundary interface
        //

        IP_NAT_INTERFACE_INFO IfInfo;
        ZeroMemory(&IfInfo, sizeof(IfInfo));
        IfInfo.Index = IfIndex;
        IfInfo.Header.Version = IP_NAT_VERSION;
        IfInfo.Header.Size = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);
        IfInfo.Header.TocEntriesCount = 0;
        IfInfo.Flags =
            IP_NAT_INTERFACE_FLAGS_BOUNDARY|IP_NAT_INTERFACE_FLAGS_NAPT;

        status =
            NtDeviceIoControlFile(
                NatHandle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                IOCTL_IP_NAT_SET_INTERFACE_INFO,
                (PVOID)&IfInfo,
                sizeof(IfInfo),
                NULL,
                0
                );

        if (!NT_SUCCESS(status)) {
            printf("Error 0x%08X configuring interface.\n", status); break;
        }

        InterfaceIndex = IfIndex;

    } while(FALSE);

    if (IpAddrTable) { free(IpAddrTable); }
    if (IfTable) { free(IfTable); }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\nbt.c ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    nbt.c

Abstract:

    This module contains code for the NAT's NetBT support.
    The support consists of an outbound-data handler for NetBT's datagram
    service, which runs over UDP port 138.

Author:

    Abolade Gbadegesin (t-abolag)   25-Aug-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Registration structure for NBT datagram-service editing
//

IP_NAT_REGISTER_EDITOR NbtRegisterEditor;


typedef struct _NBT_PSEUDO_HEADER {

    PUCHAR MessageType;
    PUCHAR Flags;
    // PUSHORT DatagramId;
    PULONG SourceAddress;
    PUSHORT SourcePort;
    // PUSHORT DatagramLength;
    // PUSHORT PacketOffset;
    PUCHAR SourceName;
    PUCHAR DestinationName;

} NBT_PSEUDO_HEADER, *PNBT_PSEUDO_HEADER;

#define NBT_HEADER_FIELD(RecvBuffer, DataOffsetp, Header, Field, Type) \
    FIND_HEADER_FIELD(RecvBuffer, DataOffsetp, Header, Field, NBT_HEADER, Type)


//
// NBT MAPPING MANAGEMENT ROUTINES (alphabetically)
//

NTSTATUS
NatCreateNbtMapping(
    PNAT_INTERFACE Interfacep,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    UCHAR SourceName[],
    PLIST_ENTRY InboundInsertionPoint,
    PNAT_NBT_MAPPING* MappingCreated
    )

/*++

Routine Description:

    This routine is called to allocate and initialize an NBT mapping.
    It assumes that the interface is locked.

Arguments:

    PrivateAddress - the private address for the mapping

    PublicAddress - the public address for the mapping

    SourceName - the NetBIOS name for the mapping's private machine

    InboundInsertionPoint - optionally supplies the point of insertion
        in the list of NBT mappings

    MappingCreated - receives the mapping created

Return Value:

    NTSTATUS - success/failure code.

--*/

{
    PNAT_NBT_MAPPING Mapping;

    CALLTRACE(("NatCreateNbtMapping\n"));

    *MappingCreated = NULL;

    //
    // Allocate space for the new mapping
    //

    Mapping = ALLOCATE_NBT_BLOCK();

    if (!Mapping) {

        TRACE(NBT, ("NatCreateNbtMapping: allocation failed\n"));

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(Mapping, sizeof(*Mapping));

    Mapping->PrivateAddress = PrivateAddress;
    Mapping->PublicAddress = PublicAddress;
    RtlCopyMemory(Mapping->SourceName, SourceName, NBT_NAME_LENGTH);
    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);

    //
    // Find the insertion point if necessary
    //

    if (!InboundInsertionPoint &&
        NatLookupInboundNbtMapping(
            Interfacep,
            PublicAddress,
            SourceName,
            &InboundInsertionPoint
            )) {

        TRACE(
            NBT, ("NatCreateNbtMapping: duplicate %d.%d.%d.%d/%d.%d.%d.%d\n",
            ADDRESS_BYTES(PublicAddress), ADDRESS_BYTES(PrivateAddress)
            ));

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Insert the new mapping
    //

    InsertTailList(InboundInsertionPoint, &Mapping->Link);

    *MappingCreated = Mapping;

    return STATUS_SUCCESS;

} // NatCreateNbtMapping


PNAT_NBT_MAPPING
NatLookupInboundNbtMapping(
    PNAT_INTERFACE Interfacep,
    ULONG PublicAddress,
    UCHAR SourceName[],
    PLIST_ENTRY* InboundInsertionPoint
    )

/*++

Routine Description:

    This routine is invoked to search the list of mappings for a given entry.

Arguments:

    Interfacep - the interface whose mapping-list is to be searched

    PublicAddress - the public address of the mapping

    SourceName - the private NBT endpoint's source-name

    InboundInsertionPoint - optionally receives the insertion point
        if the mapping is not found.

Return Value:

    PNAT_NBT_MAPPING - the mapping if found, otherwise NULL

--*/

{
    LONG cmp;
    PLIST_ENTRY Link;
    PNAT_NBT_MAPPING Mapping;

    TRACE(PER_PACKET, ("NatLookupInboundNbtMapping\n"));

    for (Link = Interfacep->NbtMappingList.Flink;
         Link != &Interfacep->NbtMappingList;
         Link = Link->Flink
         ) {

        Mapping = CONTAINING_RECORD(Link, NAT_NBT_MAPPING, Link);

        if (PublicAddress > Mapping->PublicAddress) { continue; }
        else
        if (PublicAddress < Mapping->PublicAddress) { break; }

        cmp = memcmp(SourceName, Mapping->SourceName, NBT_NAME_LENGTH);

        if (cmp > 0) { continue; }
        else
        if (cmp < 0) { break; }

        //
        // We've found the item.
        //

        return Mapping;
    }

    //
    // The item wasn't found; store the insertion point if possible.
    //

    if (InboundInsertionPoint) { *InboundInsertionPoint = Link; }

    return NULL;

} // NatLookupInboundNbtMapping


//
// NBT EDITOR HANDLER ROUTINES (alphabetically)
//

NTSTATUS
NatInitializeEditorNbt(
    VOID
    )

/*++

Routine Description:

    This routine registers the NBT datagram-service editor with the NAT.

Arguments:

    none.

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    CALLTRACE(("NatInitializeEditorNbt\n"));

    NbtRegisterEditor.Version = IP_NAT_VERSION;
    NbtRegisterEditor.Flags = 0;
    NbtRegisterEditor.Protocol = NAT_PROTOCOL_UDP;
    NbtRegisterEditor.Port = NTOHS(NBT_DATAGRAM_PORT);
    NbtRegisterEditor.Direction = NatOutboundDirection;
    NbtRegisterEditor.EditorContext = NULL;
    NbtRegisterEditor.CreateHandler = NULL;
    NbtRegisterEditor.DeleteHandler = NULL;
    NbtRegisterEditor.ForwardDataHandler = NatOutboundDataHandlerNbt;
    NbtRegisterEditor.ReverseDataHandler = NULL;

    return NatCreateEditor(&NbtRegisterEditor);

} // NatInitializeEditorNbt



NTSTATUS
NatOutboundDataHandlerNbt(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    )

/*++

Routine Description:

    This routine is invoked for each datagram sent using NetBT's datagram
    service. It replaces the address/port pair in the NetBT header with
    the publicly visible address/port pair.

Arguments:

    InterfaceHandle - handle to the outgoing NAT_INTERFACE

    SessionHandle - the session's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    RecvBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'RecvBuffer

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
#define RECVBUFFER      ((IPRcvBuf*)RecvBuffer)

    NBT_PSEUDO_HEADER Header;
    PNAT_NBT_MAPPING Mapping;
    LONG Offset = (LONG)DataOffset;
    ULONG PrivateAddress;
    ULONG PublicAddress;
    USHORT PublicPort;
    UCHAR SourceName[NBT_NAME_LENGTH];
    NTSTATUS status;

    CALLTRACE(("NatOutboundDataHandlerNbt\n"));

    //
    // Retrieve the message type
    //

    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, MessageType, PUCHAR);
    if (!RecvBuffer) { return STATUS_UNSUCCESSFUL; }

    //
    // Only allow DIRECT_{UNIQUE|GROUP} messages, since they're the only ones
    // that can be translated.
    // 

    if (*Header.MessageType != NBT_MESSAGE_DIRECT_UNIQUE &&
        *Header.MessageType != NBT_MESSAGE_DIRECT_GROUP
        ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now retrieve the flags
    //

    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, Flags, PUCHAR);
    if (!RecvBuffer) { return STATUS_UNSUCCESSFUL; }

    //
    // There's nothing to translate in datagram fragments,
    // since they don't include the header.
    //

    if (!(*Header.Flags & NBT_FLAG_FIRST_FRAGMENT)) {
        return STATUS_SUCCESS;
    }

    //
    // Consult the NAT to get the public address/port info
    //

    NbtRegisterEditor.QueryInfoSession(
        SessionHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        &PublicAddress,
        &PublicPort,
        NULL
        );

    //
    // Retrieve the source-address and source-port fields
    //

    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, SourceAddress, PULONG);
    if (!RecvBuffer) { return STATUS_UNSUCCESSFUL; }
    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, SourcePort, PUSHORT);
    if (!RecvBuffer) { return STATUS_UNSUCCESSFUL; }
    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, SourceName, PUCHAR);
    if (!RecvBuffer) { return STATUS_UNSUCCESSFUL; }

    PrivateAddress = *Header.SourceAddress;

    //
    // Copy the SourceName to a local buffer
    //
    
    COPY_FROM_BUFFER(
        SourceName,
        RECVBUFFER,
        NBT_NAME_LENGTH,
        (ULONG)(Header.SourceName-RECVBUFFER->ipr_buffer)
        );

    //
    // Attempt to create a mapping for the NBT datagram
    //

    status =
        NatCreateNbtMapping(
            InterfaceHandle,
            PrivateAddress,
            PublicAddress,
            SourceName,
            NULL,
            &Mapping
            );

    if (!NT_SUCCESS(status)) {
        //
        // The mapping may already exist; be quiet if we can't create it.
        //
        return STATUS_SUCCESS;
    }

    //
    // Translate the datagram-header source information
    //

    NatEditorEditLongSession(
        DataHandle, Header.SourceAddress, PublicAddress
        );
    NatEditorEditShortSession(
        DataHandle, Header.SourcePort, PublicPort
        );
    
    return STATUS_SUCCESS;

#undef RECVBUFFER

} // NatOutboundDataHandlerNbt



FORWARD_ACTION
NatTranslateNbt(
    PNAT_INTERFACE Interfacep,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InRecvBuffer,
    IPRcvBuf** OutRecvBuffer
    )

/*++

Routine Description:

    This routine is called to translate an incoming NetBT datagram message,
    by looking up the destination name in the interface's list of NBT mappings.

Arguments:

    Interfacep - the boundary interface over which to translate.

    Direction - the direction in which the packet is traveling

    Contextp - initialized with context-information for the packet

    InRecvBuffer - input buffer-chain

    OutRecvBuffer - receives modified buffer-chain.

Return Value:

    FORWARD_ACTION - indicates action to take on the packet.

--*/

{
#define RECVBUFFER      ((IPRcvBuf*)RecvBuffer)
#define UDPHEADER       ((PUDP_HEADER)Contextp->ProtocolHeader)

    ULONG Checksum;
    ULONG ChecksumDelta = 0;
    UCHAR DestinationName[NBT_NAME_LENGTH];
    NBT_PSEUDO_HEADER Header;
    PNAT_NBT_MAPPING Mapping;
    LONG Offset;
    ULONG PublicAddress;
    IPRcvBuf* RecvBuffer = Contextp->ProtocolRecvBuffer;

    TRACE(PER_PACKET, ("NatTranslateNbt\n"));

    //
    // Initialize the context for accessing UDP data fields
    //

    Contextp->ProtocolDataOffset = 
        (ULONG)( (PUCHAR)UDPHEADER - Contextp->ProtocolRecvBuffer->ipr_buffer)
        + sizeof(UDP_HEADER);
    Offset = (LONG)Contextp->ProtocolDataOffset;

    //
    // Retrieve the message type
    //

    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, MessageType, PUCHAR);
    if (!RecvBuffer) { return FORWARD; }

    //
    // Only allow DIRECT_{UNIQUE|GROUP} messages, since they're the only ones
    // that can be translated.
    // 

    if (*Header.MessageType != NBT_MESSAGE_DIRECT_UNIQUE &&
        *Header.MessageType != NBT_MESSAGE_DIRECT_GROUP
        ) {
        return FORWARD;
    }

    //
    // Now retrieve the flags
    //

    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, Flags, PUCHAR);
    if (!RecvBuffer) { return FORWARD; }

    //
    // There's nothing to translate in datagram fragments,
    // since they don't include the header.
    //

    if (!(*Header.Flags & NBT_FLAG_FIRST_FRAGMENT)) {
        TRACE(NBT, ("NatTranslateNbt: NBT fragment ignored\n"));
        return FORWARD;
    }

    //
    // Retrieve the public address from the IP header
    //

    PublicAddress = Contextp->DestinationAddress;

    //
    // Get the destination name from within the NetBIOS header
    //

    NBT_HEADER_FIELD(RECVBUFFER, &Offset, &Header, DestinationName, PUCHAR);
    if (!RecvBuffer) { return FORWARD; }

    RtlCopyMemory(DestinationName, Header.DestinationName, NBT_NAME_LENGTH);

    //
    // Lookup an NBT mapping for the datagram,
    // using the public address and the destination name.
    //

    Mapping =
        NatLookupInboundNbtMapping(
            Interfacep,
            PublicAddress,
            DestinationName,
            NULL
            );

    if (!Mapping) { return FORWARD; }

    //
    // Translate the IP header
    //

    CHECKSUM_LONG(ChecksumDelta, ~PublicAddress);
    Contextp->Header->DestinationAddress = Mapping->PrivateAddress;
    CHECKSUM_LONG(ChecksumDelta, Contextp->Header->DestinationAddress);

    CHECKSUM_UPDATE(Contextp->Header->Checksum);

    if (UDPHEADER->Checksum) {
        CHECKSUM_UPDATE(UDPHEADER->Checksum);
    }

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);

    *OutRecvBuffer = *InRecvBuffer; *InRecvBuffer = NULL;

    return FORWARD;

#undef RECVBUFFER
#undef UDPHEADER

} // NatTranslateNbt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\mapping.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mapping.h

Abstract:

    This file contains declarations for the management of dynamic mappings.
    This includes the relevant data structures as well as the routines for
    manipulating the structures.

Author:

    Abolade Gbadegesin (t-abolag) 11-July-1997

Revision History:

--*/

#ifndef _NAT_MAPPING_H_
#define _NAT_MAPPING_H_

//
// Forward declaration of structure defined elsewhere
//

struct _NAT_INTERFACE;
#define PNAT_INTERFACE          struct _NAT_INTERFACE*

typedef enum _NAT_SESSION_MAPPING_INFORMATION_CLASS {
    NatKeySessionMappingInformation,
    NatStatisticsSessionMappingInformation,
#if _WIN32_WINNT > 0x0500
    NatKeySessionMappingExInformation,
#endif
    NatMaximumSessionMappingInformation
} NAT_SESSION_MAPPING_INFORMATION_CLASS,
    *PNAT_SESSION_MAPPING_INFORMATION_CLASS;


//
// Structure:   NAT_DYNAMIC_MAPPING
//
// This structure holds information about a specific active session.
// Each instance is held on the global mapping-list as well as
// on the global mapping-trees for forward and reverse access.
//
// Each mapping stores four keys which are address/protocol/port combinations:
// forward source and destination keys (the original session-endpoints),
// and reverse source and destination keys (the translated endpoints).
//
// Each time a packet is translated using a mapping, the 'LastAccessTime'
// is set to the number of ticks since system-start (KeQueryTickCount).
// This value is used by our timer routine to eliminate expired mappings.
//
// Synchronization of access to mappings is similar to that of interfaces,
// editors, and directors:
//
//  We use a reference count to ensure the existence of a mapping,
//  and a spin-lock to ensure its consistency.
//
//  The fields of a mapping are only consistent while the spinlock is held
//  (with the exception of fields such as 'PrivateKey' which are read-only)
//
//  The spinlock can only be acquired if
//      (a) the reference-count has been incremented, or
//      (b) the mapping-list lock is already held.
//
//  If the mapping is for an edited, directed, or interface's session,
//  it also lives on its editor's, director's or interface's list of mappings.
//  The following holds true of all three lists (i.e. for 'Editor' write
//  'Director' or 'Interface' as appropriate):
//
//  As described in 'EDITOR.H', the cached fields 'Editor*' are protected
//  by the global 'EditorMappingLock'. Hence,
//
//      (a) to read the 'Editor' or 'EditorContext' for a mapping,
//          or to traverse the 'EditorLink' field, 'EditorLock' must be held
//          and the editor referenced. Note that the attempt to reference
//          the editor will fail if the editor has been marked for deletion.
//
//      (b) to modify the 'Editor' or 'EditorContext' or to add or
//          remove a mapping from its editor's list of mappings by changing
//          the 'EditorLink' field, both 'EditorLock' and 'EditorMappingLock'
//          must be acquired, in that order.
//
//  Acquisition of 'EditorLock' ensures that the cached editor will not be
//  deleted while being referenced, and acquisition of 'EditorMappingLock'
//  ensures that no changes are being made to the list.
//
// N.B. On the rare occasions when 'MappingLock' must be held at the same time
// as one of 'InterfaceLock', 'EditorLock', and 'DirectorLock', 'MappingLock'
// must always be acquired first.
//

typedef struct _NAT_DYNAMIC_MAPPING {

    LIST_ENTRY Link;
    RTL_SPLAY_LINKS SLink[NatMaximumPath];
    ULONG64 DestinationKey[NatMaximumPath]; // read-only
    ULONG64 SourceKey[NatMaximumPath];      // read-only
    LONG64 LastAccessTime;

    KSPIN_LOCK Lock;
    ULONG ReferenceCount;

    ULONG AccessCount[NatMaximumPath];      // interlocked-access only
    PNAT_TRANSLATE_ROUTINE TranslateRoutine[NatMaximumPath]; // read-only

    PNAT_INTERFACE Interfacep;
    PVOID InterfaceContext;
    LIST_ENTRY InterfaceLink;

    PNAT_EDITOR Editor;
    PVOID EditorContext;
    LIST_ENTRY EditorLink;

    PNAT_DIRECTOR Director;
    PVOID DirectorContext;
    LIST_ENTRY DirectorLink;

    ULONG Flags;
    ULONG IpChecksumDelta[NatMaximumPath];
    ULONG ProtocolChecksumDelta[NatMaximumPath];
    ULONG TcpSeqNumExpected[NatMaximumPath];
    ULONG TcpSeqNumBase[NatMaximumPath];
    LONG TcpSeqNumDelta[NatMaximumPath];

    // Maxmimum MSS value. Set to 0 if MSS adjustment is unnecessary.
    USHORT MaxMSS;                      
    
    IP_NAT_SESSION_MAPPING_STATISTICS Statistics;
    ULONG BytesForward;                     // interlocked-access only
    ULONG BytesReverse;                     // interlocked-access only
    ULONG PacketsForward;                   // interlocked-access only
    ULONG PacketsReverse;                   // interlocked-access only
    ULONG RejectsForward;                   // interlocked-access only
    ULONG RejectsReverse;                   // interlocked-access only

} NAT_DYNAMIC_MAPPING, *PNAT_DYNAMIC_MAPPING;


//
// Definition of flags for NAT_DYNAMIC_MAPPING.Flags
//
// Set after a mapping has been deleted; when the last reference is released,
// the mapping will be freed.
//
#define NAT_MAPPING_FLAG_DELETED        0x80000000
#define NAT_MAPPING_DELETED(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_DELETED)
//
// Set when an editor expires a mapping using 'NatEditorTimeoutSession'.
//
#define NAT_MAPPING_FLAG_EXPIRED        0x00000001
#define NAT_MAPPING_EXPIRED(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_EXPIRED)
//
// Set when the forward/reverse SYN for a TCP session is seen, respectively
//
#define NAT_MAPPING_FLAG_FWD_SYN        0x00000002
#define NAT_MAPPING_FLAG_REV_SYN        0x00000004
//
// Set when the forward/reverse FIN for a TCP session is seen, respectively
//
#define NAT_MAPPING_FLAG_FWD_FIN        0x00000008
#define NAT_MAPPING_FLAG_REV_FIN        0x00000010
#define NAT_MAPPING_FIN(m) \
    (((m)->Flags & NAT_MAPPING_FLAG_FWD_FIN) && \
     ((m)->Flags & NAT_MAPPING_FLAG_REV_FIN))
//
// Set when an inbound mapping is created using a static address or port,
// or because of a director or ticket.
//
#define NAT_MAPPING_FLAG_INBOUND        0x00000020
#define NAT_MAPPING_INBOUND(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_INBOUND)
//
// Set when a mapping is created by a director and is not subject to expiration.
//
#define NAT_MAPPING_FLAG_NO_TIMEOUT     0x00000040
#define NAT_MAPPING_NO_TIMEOUT(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_NO_TIMEOUT)
//
// Set when only forward packets are to be translated
//
#define NAT_MAPPING_FLAG_UNIDIRECTIONAL 0x00000080
#define NAT_MAPPING_UNIDIRECTIONAL(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_UNIDIRECTIONAL)

//
// Set when director-initiated dissociation should trigger deletion
//
#define NAT_MAPPING_FLAG_DELETE_ON_DISSOCIATE_DIRECTOR 0x00000100
#define NAT_MAPPING_DELETE_ON_DISSOCIATE_DIRECTOR(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_DELETE_ON_DISSOCIATE_DIRECTOR)

//
// Set on TCP mappings when the three-way handshake is complete
//
#define NAT_MAPPING_FLAG_TCP_OPEN 0x00000200
#define NAT_MAPPING_TCP_OPEN(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_TCP_OPEN)
//
// Set if the creation or deletion of this mapping should not
// be logged
//
#define NAT_MAPPING_FLAG_DO_NOT_LOG 0x00000400
#define NAT_MAPPING_DO_NOT_LOG(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_DO_NOT_LOG)
//
// Set if the DF bit must be cleared for all packets that belong
// to this mapping.
//
#define NAT_MAPPING_FLAG_CLEAR_DF_BIT 0x00000800
#define NAT_MAPPING_CLEAR_DF_BIT(m) \
    ((m)->Flags & NAT_MAPPING_FLAG_CLEAR_DF_BIT)

//
// Mapping-key manipulation macros
//

#define MAKE_MAPPING_KEY(Key,Protocol,Address,Port) \
    ((Key) = \
        (Address) | \
        ((ULONG64)((Port) & 0xFFFF) << 32) | \
        ((ULONG64)((Protocol) & 0xFF) << 48))

#define MAPPING_PROTOCOL(Key)       ((UCHAR)(((Key) >> 48) & 0xFF))
#define MAPPING_PORT(Key)           ((USHORT)(((Key) >> 32) & 0xFFFF))
#define MAPPING_ADDRESS(Key)        ((ULONG)(Key))

//
// Resplay threshold; the mapping is resplayed every time its access-count
// passes this value.
//

#define NAT_MAPPING_RESPLAY_THRESHOLD   5

//
// Defines the depth of the lookaside list for allocating dynamic mappings
//

#define MAPPING_LOOKASIDE_DEPTH     20

//
// Defines the threshold at which ad-hoc cleanup of expired mappings begins.
//

#define MAPPING_CLEANUP_THRESHOLD   1000

//
// Mapping allocation macros
//

#define ALLOCATE_MAPPING_BLOCK() \
    ExAllocateFromNPagedLookasideList(&MappingLookasideList)

#define FREE_MAPPING_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&MappingLookasideList,(Block))

//
// GLOBAL VARIABLE DECLARATIONS
//

extern ULONG ExpiredMappingCount;
extern CACHE_ENTRY MappingCache[NatMaximumPath][CACHE_SIZE];
extern ULONG MappingCount;
extern LIST_ENTRY MappingList;
extern KSPIN_LOCK MappingLock;
extern NPAGED_LOOKASIDE_LIST MappingLookasideList;
extern PNAT_DYNAMIC_MAPPING MappingTree[NatMaximumPath];


//
// MAPPING MANAGEMENT ROUTINES
//

PVOID
NatAllocateFunction(
    POOL_TYPE PoolType,
    SIZE_T NumberOfBytes,
    ULONG Tag
    );

VOID
NatCleanupMapping(
    PNAT_DYNAMIC_MAPPING Mapping
    );

NTSTATUS
NatCreateMapping(
    ULONG Flags,
    ULONG64 DestinationKey[],
    ULONG64 SourceKey[],
    PNAT_INTERFACE Interfacep,
    PVOID InterfaceContext,
    USHORT MaxMSS,
    PNAT_DIRECTOR Director,
    PVOID DirectorContext,
    PNAT_DYNAMIC_MAPPING* InboundInsertionPoint,
    PNAT_DYNAMIC_MAPPING* OutboundInsertionPoint,
    PNAT_DYNAMIC_MAPPING* MappingCreated
    );

NTSTATUS
NatDeleteMapping(
    PNAT_DYNAMIC_MAPPING Mapping
    );

//
//  BOOLEAN
//  NatDereferenceMapping(
//      PNAT_DYNAMIC_MAPPING Mapping
//      );
//

#define \
NatDereferenceMapping( \
    _Mapping \
    ) \
    (InterlockedDecrement(&(_Mapping)->ReferenceCount) \
        ? TRUE \
        : (NatCleanupMapping(_Mapping), FALSE))

//
//  VOID
//  NatExpireMapping(
//      PNAT_DYNAMIC_MAPPING Mapping
//      );
//

PNAT_DYNAMIC_MAPPING
NatDestinationLookupForwardMapping(
    ULONG64 DestinationKey
    );

PNAT_DYNAMIC_MAPPING
NatDestinationLookupReverseMapping(
    ULONG64 DestinationKey
    );

#define \
NatExpireMapping( \
    _Mapping \
    ) \
    if (!NAT_MAPPING_EXPIRED(_Mapping)) { \
        (_Mapping)->Flags |= NAT_MAPPING_FLAG_EXPIRED; \
        InterlockedIncrement(&ExpiredMappingCount); \
        if (MappingCount > MAPPING_CLEANUP_THRESHOLD && \
            ExpiredMappingCount >= (MappingCount >> 2)) { \
            NatTriggerTimer(); \
        } \
    }


VOID
NatInitializeMappingManagement(
    VOID
    );

PNAT_DYNAMIC_MAPPING
NatInsertForwardMapping(
    PNAT_DYNAMIC_MAPPING Parent,
    PNAT_DYNAMIC_MAPPING Mapping
    );

PNAT_DYNAMIC_MAPPING
NatInsertReverseMapping(
    PNAT_DYNAMIC_MAPPING Parent,
    PNAT_DYNAMIC_MAPPING Mapping
    );

NTSTATUS
NatLookupAndQueryInformationMapping(
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    OUT PVOID Information,
    ULONG InformationLength,
    NAT_SESSION_MAPPING_INFORMATION_CLASS InformationClass
    );

PNAT_DYNAMIC_MAPPING
NatLookupForwardMapping(
    ULONG64 DestinationKey,
    ULONG64 SourceKey,
    PNAT_DYNAMIC_MAPPING* InsertionPoint
    );

PNAT_DYNAMIC_MAPPING
NatLookupReverseMapping(
    ULONG64 DestinationKey,
    ULONG64 SourceKey,
    PNAT_DYNAMIC_MAPPING* InsertionPoint
    );

VOID
NatQueryInformationMapping(
    IN PNAT_DYNAMIC_MAPPING Mapping,
    OUT PUCHAR Protocol OPTIONAL,
    OUT PULONG PrivateAddress OPTIONAL,
    OUT PUSHORT PrivatePort OPTIONAL,
    OUT PULONG RemoteAddress OPTIONAL,
    OUT PUSHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress OPTIONAL,
    OUT PUSHORT PublicPort OPTIONAL,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    );

NTSTATUS
NatQueryInterfaceMappingTable(
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS InputBuffer,
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS OutputBuffer,
    IN PULONG OutputBufferLength
    );

NTSTATUS
NatQueryMappingTable(
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS InputBuffer,
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS OutputBuffer,
    IN PULONG OutputBufferLength
    );

//
//  BOOLEAN
//  NatReferenceMapping(
//      PNAT_DYNAMIC_MAPPING Mapping
//      );
//

#define \
NatReferenceMapping( \
    _Mapping \
    ) \
    (NAT_MAPPING_DELETED(_Mapping) \
        ? FALSE \
        : (InterlockedIncrement(&(_Mapping)->ReferenceCount), TRUE))

//
//  VOID
//  NatResplayMapping(
//      PNAT_DYNAMIC_MAPPING Mapping,
//      IP_NAT_PATH Path
//      );
//

#define \
NatResplayMapping( \
    _Mapping, \
    _Path \
    ) \
{ \
    PRTL_SPLAY_LINKS _SLink; \
    KeAcquireSpinLockAtDpcLevel(&MappingLock); \
    if (!NAT_MAPPING_DELETED(_Mapping)) { \
        _SLink = RtlSplay(&(_Mapping)->SLink[_Path]); \
        MappingTree[_Path] = \
            CONTAINING_RECORD(_SLink, NAT_DYNAMIC_MAPPING, SLink[_Path]); \
    } \
    KeReleaseSpinLockFromDpcLevel(&MappingLock); \
}

VOID
NatShutdownMappingManagement(
    VOID
    );

PNAT_DYNAMIC_MAPPING
NatSourceLookupForwardMapping(
    ULONG64 SourceKey
    );

PNAT_DYNAMIC_MAPPING
NatSourceLookupReverseMapping(
    ULONG64 SourceKey
    );

//
//  VOID
//  NatTryToResplayMapping(
//      PNAT_DYNAMIC_MAPPING Mapping,
//      IP_NAT_PATH Path
//      );
//

#define \
NatTryToResplayMapping( \
    _Mapping, \
    _Path \
    ) \
    if (InterlockedDecrement(&(_Mapping)->AccessCount[(_Path)]) == 0) { \
        NatResplayMapping((_Mapping), (_Path)); \
        InterlockedExchangeAdd( \
            &(_Mapping)->AccessCount[(_Path)], \
            NAT_MAPPING_RESPLAY_THRESHOLD \
            ); \
    }

VOID
NatUpdateStatisticsMapping(
    PNAT_DYNAMIC_MAPPING Mapping
    );

#undef PNAT_INTERFACE

#endif // _NAT_MAPPING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\nbt.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    nbt.h

Abstract:

    This module contains declarations for the NAT's NetBT support.
    NetBT's datagram service embeds source IP address/port in the datagrams
    that it sends out, hence the need for additional translation.

Author:

    Abolade Gbadegesin (t-abolag)   25-Aug-1997

Revision History:

--*/

#ifndef _NAT_NBT_H_
#define _NAT_NBT_H_


//
// Structure:   NAT_NBT_MAPPING
//
// This structure describes a mapping defined to allow translation of
// NetBT datagram-service sessions across the NAT.
//
// The NetBT datagram-service operates over UDP using port 138 for sending
// and receiving messages. This means that regardless of what value the NAT
// places in the NetBT datagram header, replies will be directed to port 138.
// Therefore, in order to translate NetBT datagrams, the NAT must incorporate
// additional information.
//
// The NAT registers a handler for outbound traffic destined for the NetBT
// datagram-service port, as well as implementing an IP-layer translator
// for inbound traffic destined for the NetBT datagram-service port.
// Each outgoing message is then examined, and a mapping is created using
//  (a) the source (private) IP address in the datagram header
//  (b) the public IP address chosen by the NAT
//  (c) the source name in the datagram header
// The source IP address is then replaced with the public IP address,
// and the source port is replaced with the NetBT datagram-service port.
//
// Each incoming message is in turn examined by the IP-layer translator,
// and a lookup is done using
//  (a) the receiving (public) IP address
//  (b) the destination name in the datagram header.
// after which the packet's destination IP address is translated.
//
// A list of mappings is maintained on each interface, ordered by
// by public IP address and source name for outbound searching.
//


typedef struct _NAT_NBT_MAPPING {
    LIST_ENTRY Link;
    ULONG PrivateAddress;
    ULONG PublicAddress;
    UCHAR SourceName[NBT_NAME_LENGTH];
    LONG64 LastAccessTime;
} NAT_NBT_MAPPING, *PNAT_NBT_MAPPING;


//
// NBT mapping allocation macros
//

#define ALLOCATE_NBT_BLOCK() \
    ExAllocateFromNPagedLookasideList(&NbtLookasideList)

#define FREE_NBT_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&NbtLookasideList,(Block))



//
// FUNCTION DECLARATIONS
//

NTSTATUS
NatCreateNbtMapping(
    PNAT_INTERFACE Interfacep,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    UCHAR SourceName[],
    PLIST_ENTRY InboundInsertionPoint,
    PNAT_NBT_MAPPING* MappingCreated
    );

PNAT_NBT_MAPPING
NatLookupInboundNbtMapping(
    PNAT_INTERFACE Interfacep,
    ULONG PublicAddress,
    UCHAR SourceName[],
    PLIST_ENTRY* InboundInsertionPoint
    );

NTSTATUS
NatInitializeEditorNbt(
    VOID
    );

NTSTATUS
NatOutboundDataHandlerNbt(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

XLATE_IP_ROUTINE(NatTranslateNbt)

extern IP_NAT_REGISTER_EDITOR NbtRegisterEditor;


#endif // _NAT_NBT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\mapping.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mapping.c

Abstract:

    This file contains the code for mapping management.

Author:

    Abolade Gbadegesin (t-abolag)   11-July-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// GLOBAL VARIABLE DEFINITIONS
//

ULONG ExpiredMappingCount;
CACHE_ENTRY MappingCache[NatMaximumPath][CACHE_SIZE];
ULONG MappingCount;
LIST_ENTRY MappingList;
KSPIN_LOCK MappingLock;
NPAGED_LOOKASIDE_LIST MappingLookasideList;
PNAT_DYNAMIC_MAPPING MappingTree[NatMaximumPath];


PVOID
NatAllocateFunction(
    POOL_TYPE PoolType,
    SIZE_T NumberOfBytes,
    ULONG Tag
    )

/*++

Routine Description:

    Called by lookaside lists to allocate memory from the low-priority
    pool.

Arguments:

    PoolType - the pool to allocate from (e.g., non-paged)

    NumberOfBytes - the number of bytes to allocate

    Tag - the tag for the allocation

Return Value:

    PVOID - pointer to the allocated memory, or NULL for failure.

--*/

{
    return
        ExAllocatePoolWithTagPriority(
            PoolType,
            NumberOfBytes,
            Tag,
            LowPoolPriority
            );
} // NatAllocateFunction


VOID
NatCleanupMapping(
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    Called to perform final cleanup for a mapping.

Arguments:

    Mapping - the mapping to be deleted.

Return Value:

    none.

Environment:

    Invoked with the last reference to the mapping released.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatCleanupMapping\n"));

    //
    // The last reference to the mapping has been released;
    //
    // Let the mapping's director know that it's expired
    //

    KeAcquireSpinLock(&DirectorLock, &Irql);
    if (Mapping->Director) {
        KeAcquireSpinLockAtDpcLevel(&DirectorMappingLock);
        NatMappingDetachDirector(
            Mapping->Director,
            Mapping->DirectorContext,
            Mapping,
            NatCleanupSessionDeleteReason
            );
        KeReleaseSpinLockFromDpcLevel(&DirectorMappingLock);
    }
    KeReleaseSpinLockFromDpcLevel(&DirectorLock);

    //
    // Let the mapping's editor know that it's expired
    //

    KeAcquireSpinLockAtDpcLevel(&EditorLock);
    if (Mapping->Editor) {
        KeAcquireSpinLockAtDpcLevel(&EditorMappingLock);
        NatMappingDetachEditor(Mapping->Editor, Mapping);
        KeReleaseSpinLockFromDpcLevel(&EditorMappingLock);
    }
    KeReleaseSpinLockFromDpcLevel(&EditorLock);

    //
    // If the mapping is associated with an address-pool, release the address,
    // and update the statistics for the mapping's interface
    //

    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
    if (Mapping->Interfacep) {
        KeAcquireSpinLockAtDpcLevel(&InterfaceMappingLock);
        NatMappingDetachInterface(
            Mapping->Interfacep, Mapping->InterfaceContext, Mapping
            );
        KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);
    }
    KeReleaseSpinLock(&InterfaceLock, Irql);

    //
    // Clear the location the mapping would occupy in the cache,
    // in case it is cached.
    //

    ClearCache(
        MappingCache[NatForwardPath],
        (ULONG)Mapping->DestinationKey[NatForwardPath]
        );
    ClearCache(
        MappingCache[NatReversePath],
        (ULONG)Mapping->DestinationKey[NatReversePath]
        );

    FREE_MAPPING_BLOCK(Mapping);

} // NatCleanupMapping


NTSTATUS
NatCreateMapping(
    ULONG Flags,
    ULONG64 DestinationKey[],
    ULONG64 SourceKey[],
    PNAT_INTERFACE Interfacep,
    PVOID InterfaceContext,
    USHORT MaxMSS,
    PNAT_DIRECTOR Director,
    PVOID DirectorSessionContext,
    PNAT_DYNAMIC_MAPPING* ForwardInsertionPoint,
    PNAT_DYNAMIC_MAPPING* ReverseInsertionPoint,
    PNAT_DYNAMIC_MAPPING* MappingCreated
    )

/*++

Routine Description:

    This function initializes the fields of a mapping.

    On returning, the routine will have made an initial reference
    to the mapping. The caller must call 'NatDereferenceMapping'
    to release this reference.

Arguments:

    Flags - controls creation of the mapping

    DestinationKey[] - the forward and reverse destination-endpoint keys

    SourceKey[] - the forward and reverse source-endpoint keys

    Interface* - the interface, if any, with which the mapping is associated,
        and the associated context

    MaxMSS - the maximum MSS value allowed on the outgoing interface. 

    Director* - the director, if any, with which the mapping is associated,
        and the associated context

    ForwardInsertionPoint - optionally supplies the point of insertion
        in the forward-lookup mapping-tree

    ReverseInsertionPoint - optionally supplies the point of insertion
        in the reverse-lookup mapping-tree

    MappingCreated - receives the mapping created.

Return Value:

    none.

Environment:

    Invoked with 'MappingLock' held by the caller, and with both 'Interfacep'
    and 'Director' referenced, if specified.

--*/

{
    PNAT_EDITOR Editor;
    ULONG InboundKey;
    PNAT_DYNAMIC_MAPPING InsertionPoint1;
    PNAT_DYNAMIC_MAPPING InsertionPoint2;
    ULONG InterfaceFlags;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG OutboundKey;
    UCHAR Protocol;
    PRTL_SPLAY_LINKS SLink;
    NTSTATUS status;
    BOOLEAN FirewallMode = FALSE;

    CALLTRACE(("NatCreateMapping\n"));

    //
    // Allocate the memory for the new block
    //

    Mapping = ALLOCATE_MAPPING_BLOCK();

    if (!Mapping) {
        ERROR(("NatCreateMapping: allocation failed\n"));
        if (Interfacep) {
            NatMappingDetachInterface(Interfacep, InterfaceContext, NULL);
        }
        if (Director) {
            NatMappingDetachDirector(
                Director,
                DirectorSessionContext,
                NULL,
                NatCreateFailureDeleteReason
                );
        }
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(Mapping, sizeof(*Mapping));
    KeInitializeSpinLock(&Mapping->Lock);
    Mapping->ReferenceCount = 1;
    Mapping->Flags = Flags;
    Mapping->MaxMSS = MaxMSS;
    Mapping->DestinationKey[NatForwardPath] = DestinationKey[NatForwardPath];
    Mapping->DestinationKey[NatReversePath] = DestinationKey[NatReversePath];
    Mapping->SourceKey[NatForwardPath] = SourceKey[NatForwardPath];
    Mapping->SourceKey[NatReversePath] = SourceKey[NatReversePath];
    Mapping->AccessCount[NatForwardPath] = NAT_MAPPING_RESPLAY_THRESHOLD;
    Mapping->AccessCount[NatReversePath] = NAT_MAPPING_RESPLAY_THRESHOLD;
    InitializeListHead(&Mapping->Link);
    InitializeListHead(&Mapping->DirectorLink);
    InitializeListHead(&Mapping->EditorLink);
    InitializeListHead(&Mapping->InterfaceLink);
    RtlInitializeSplayLinks(&Mapping->SLink[NatForwardPath]);
    RtlInitializeSplayLinks(&Mapping->SLink[NatReversePath]);
    Protocol = MAPPING_PROTOCOL(DestinationKey[0]);

    if (SourceKey[NatForwardPath] == DestinationKey[NatReversePath]
        && DestinationKey[NatForwardPath] == SourceKey[NatReversePath]) {

        //
        // This mapping is being created for firewall puposes -- no actual
        // translation needs to be performed. Knowing this, we can use
        // different translation routines and save us some time...
        //

        TRACE(MAPPING,("NAT: Creating FW null mapping\n"));

        FirewallMode = TRUE;

        if (Protocol == NAT_PROTOCOL_TCP) {
            Mapping->TranslateRoutine[NatForwardPath] = NatTranslateForwardTcpNull;
            Mapping->TranslateRoutine[NatReversePath] = NatTranslateReverseTcpNull;
        } else {
            Mapping->TranslateRoutine[NatForwardPath] = NatTranslateForwardUdpNull;
            Mapping->TranslateRoutine[NatReversePath] = NatTranslateReverseUdpNull;
        }
    } else if (Protocol == NAT_PROTOCOL_TCP) {
        Mapping->TranslateRoutine[NatForwardPath] = NatTranslateForwardTcp;
        Mapping->TranslateRoutine[NatReversePath] = NatTranslateReverseTcp;
    } else {
        Mapping->TranslateRoutine[NatForwardPath] = NatTranslateForwardUdp;
        Mapping->TranslateRoutine[NatReversePath] = NatTranslateReverseUdp;
    }

    //
    // Increment the reference count on the mapping;
    // the caller should then do a 'Dereference'.
    //

    ++Mapping->ReferenceCount;

    //
    // Attach the mapping to its interface, if any
    //

    if (Interfacep) {
        KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
        KeAcquireSpinLockAtDpcLevel(&InterfaceMappingLock);
        NatMappingAttachInterface(Interfacep, InterfaceContext, Mapping);
        KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);
        InterfaceFlags = Interfacep->Flags;
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
    }

    //
    // Attach the mapping to its director, if any
    //

    if (Director) {
        KeAcquireSpinLockAtDpcLevel(&DirectorLock);
        KeAcquireSpinLockAtDpcLevel(&DirectorMappingLock);
        NatMappingAttachDirector(Director, DirectorSessionContext, Mapping);
        KeReleaseSpinLockFromDpcLevel(&DirectorMappingLock);
        KeReleaseSpinLockFromDpcLevel(&DirectorLock);
    }

    //
    // We now set up any editors interested in this session,
    // if the mapping is associated with a boundary interface.
    //

    if (Interfacep) {

        InboundKey =
            MAKE_EDITOR_KEY(
                Protocol,
                MAPPING_PORT(DestinationKey[NatForwardPath]),
                NatInboundDirection
                );
        OutboundKey =
            MAKE_EDITOR_KEY(
                Protocol,
                MAPPING_PORT(DestinationKey[NatForwardPath]),
                NatOutboundDirection
                );

        KeAcquireSpinLockAtDpcLevel(&EditorLock);
        for (Link = EditorList.Flink; Link != &EditorList; Link = Link->Flink) {

            Editor = CONTAINING_RECORD(Link, NAT_EDITOR, Link);

            //
            // Skip any built-in editors that are administratively disabled.
            //

            if (((InterfaceFlags & IP_NAT_INTERFACE_FLAGS_DISABLE_PPTP) &&
                (PVOID)Editor == PptpRegisterEditorClient.EditorHandle) ||
                ((InterfaceFlags & IP_NAT_INTERFACE_FLAGS_DISABLE_PPTP) &&
                (PVOID)Editor == PptpRegisterEditorServer.EditorHandle)) {
                continue;
            }

            if (Editor->Key == InboundKey && NAT_MAPPING_INBOUND(Mapping)) {

                KeAcquireSpinLockAtDpcLevel(&EditorMappingLock);
                NatMappingAttachEditor(Editor, Mapping);
                KeReleaseSpinLockFromDpcLevel(&EditorMappingLock);

                //
                // Update the mapping's translation-routine table
                //

                if (Protocol == NAT_PROTOCOL_UDP) {
                    Mapping->TranslateRoutine[NatForwardPath] =
                        NatTranslateForwardUdpEdit;
                    Mapping->TranslateRoutine[NatReversePath] =
                        NatTranslateReverseUdpEdit;
                } else if (!NAT_EDITOR_RESIZE(Editor)) {
                    Mapping->TranslateRoutine[NatForwardPath] =
                        NatTranslateForwardTcpEdit;
                    Mapping->TranslateRoutine[NatReversePath] =
                        NatTranslateReverseTcpEdit;
                } else {
                    Mapping->TranslateRoutine[NatForwardPath] =
                        NatTranslateForwardTcpResize;
                    Mapping->TranslateRoutine[NatReversePath] =
                        NatTranslateReverseTcpResize;
                }

                break;
            } else if (Editor->Key == OutboundKey &&
                        !NAT_MAPPING_INBOUND(Mapping)) {

                KeAcquireSpinLockAtDpcLevel(&EditorMappingLock);
                NatMappingAttachEditor(Editor, Mapping);
                KeReleaseSpinLockFromDpcLevel(&EditorMappingLock);

                //
                // Update the mapping's translation-routine table
                //

                if (Protocol == NAT_PROTOCOL_UDP) {
                    Mapping->TranslateRoutine[NatForwardPath] =
                        NatTranslateForwardUdpEdit;
                    Mapping->TranslateRoutine[NatReversePath] =
                        NatTranslateReverseUdpEdit;
                } else if (!NAT_EDITOR_RESIZE(Editor)) {
                    Mapping->TranslateRoutine[NatForwardPath] =
                        NatTranslateForwardTcpEdit;
                    Mapping->TranslateRoutine[NatReversePath] =
                        NatTranslateReverseTcpEdit;
                } else {
                    Mapping->TranslateRoutine[NatForwardPath] =
                        NatTranslateForwardTcpResize;
                    Mapping->TranslateRoutine[NatReversePath] =
                        NatTranslateReverseTcpResize;
                }
                
                break;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&EditorLock);
    } // Interfacep


    if (!FirewallMode) {
        //
        // Initialize the checksum deltas;
        // See RFC1624 for details on the incremental update of the checksum;
        //

        Mapping->IpChecksumDelta[NatForwardPath] =
            (USHORT)~MAPPING_ADDRESS(SourceKey[NatForwardPath]) +
            (USHORT)~(MAPPING_ADDRESS(SourceKey[NatForwardPath]) >> 16) +
            (USHORT)~MAPPING_ADDRESS(DestinationKey[NatForwardPath]) +
            (USHORT)~(MAPPING_ADDRESS(DestinationKey[NatForwardPath]) >> 16) +
            (USHORT)MAPPING_ADDRESS(SourceKey[NatReversePath]) +
            (USHORT)(MAPPING_ADDRESS(SourceKey[NatReversePath]) >> 16) +
            (USHORT)MAPPING_ADDRESS(DestinationKey[NatReversePath]) +
            (USHORT)(MAPPING_ADDRESS(DestinationKey[NatReversePath]) >> 16);
        Mapping->IpChecksumDelta[NatReversePath] =
            (USHORT)MAPPING_ADDRESS(SourceKey[NatForwardPath]) +
            (USHORT)(MAPPING_ADDRESS(SourceKey[NatForwardPath]) >> 16) +
            (USHORT)MAPPING_ADDRESS(DestinationKey[NatForwardPath]) +
            (USHORT)(MAPPING_ADDRESS(DestinationKey[NatForwardPath]) >> 16) +
            (USHORT)~MAPPING_ADDRESS(SourceKey[NatReversePath]) +
            (USHORT)~(MAPPING_ADDRESS(SourceKey[NatReversePath]) >> 16) +
            (USHORT)~MAPPING_ADDRESS(DestinationKey[NatReversePath]) +
            (USHORT)~(MAPPING_ADDRESS(DestinationKey[NatReversePath]) >> 16);
        Mapping->ProtocolChecksumDelta[NatForwardPath] =
            Mapping->IpChecksumDelta[NatForwardPath] +
            (USHORT)~MAPPING_PORT(SourceKey[NatForwardPath]) +
            (USHORT)~MAPPING_PORT(DestinationKey[NatForwardPath]) +
            (USHORT)MAPPING_PORT(SourceKey[NatReversePath]) +
            (USHORT)MAPPING_PORT(DestinationKey[NatReversePath]);
        Mapping->ProtocolChecksumDelta[NatReversePath] =
            Mapping->IpChecksumDelta[NatReversePath] +
            (USHORT)MAPPING_PORT(SourceKey[NatForwardPath]) +
            (USHORT)MAPPING_PORT(DestinationKey[NatForwardPath]) +
            (USHORT)~MAPPING_PORT(SourceKey[NatReversePath]) +
            (USHORT)~MAPPING_PORT(DestinationKey[NatReversePath]);

        //
        // If the mapping has the loopback address as the source on either
        // path set NAT_MAPPING_FLAG_CLEAR_DF_BIT. When we change the source
        // address of a packet from the loopback address to some other address
        // there is the possibility that we'll create an MTU mismatch that
        // would result in the packet getting dropped by the stack if the
        // DF bit was sent. (Note that since this would occur on the local-send
        // path no ICMP error message would be generated.)
        //
        // Clearing the DF bit for these packets ensures that the stack will
        // succeed in sending the packet, though some performance may be
        // lost due to the fragmentation.
        //

        if (MAPPING_ADDRESS(SourceKey[NatForwardPath]) == 0x0100007f ||
            MAPPING_ADDRESS(SourceKey[NatReversePath]) == 0x0100007f) {
            
            Mapping->Flags |= NAT_MAPPING_FLAG_CLEAR_DF_BIT;
        }
    }

    //
    // Find the insertion points, in the process checking for collisions
    //

    if (!ForwardInsertionPoint) {
        ForwardInsertionPoint = &InsertionPoint1;
        if (NatLookupForwardMapping(
                DestinationKey[NatForwardPath],
                SourceKey[NatForwardPath],
                ForwardInsertionPoint
                )) {
            //
            // A collision has been detected.
            //
            NatCleanupMapping(Mapping);
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (!ReverseInsertionPoint) {
        ReverseInsertionPoint = &InsertionPoint2;
        if (NatLookupReverseMapping(
                DestinationKey[NatReversePath],
                SourceKey[NatReversePath],
                ReverseInsertionPoint
                )) {
            //
            // A collision has been detected.
            //
            NatCleanupMapping(Mapping);
            return STATUS_UNSUCCESSFUL;
        }
    }

    MappingTree[NatForwardPath] =
        NatInsertForwardMapping(*ForwardInsertionPoint, Mapping);

    MappingTree[NatReversePath] =
        NatInsertReverseMapping(*ReverseInsertionPoint, Mapping);

    InsertTailList(&MappingList, &Mapping->Link);
    InterlockedIncrement(&MappingCount);

    *MappingCreated = Mapping;

#if NAT_WMI

    //
    // Log the creation. Logging always uses public addresses,
    // not private.
    //

    if (!NAT_MAPPING_DO_NOT_LOG(Mapping)) {
        if (NAT_MAPPING_INBOUND(Mapping)) {
            NatLogConnectionCreation(
                MAPPING_ADDRESS(DestinationKey[NatForwardPath]),
                MAPPING_ADDRESS(SourceKey[NatForwardPath]),
                MAPPING_PORT(DestinationKey[NatForwardPath]),
                MAPPING_PORT(SourceKey[NatForwardPath]),
                Protocol,
                TRUE
                );
        } else {
            NatLogConnectionCreation(
                MAPPING_ADDRESS(DestinationKey[NatReversePath]),
                MAPPING_ADDRESS(SourceKey[NatReversePath]),
                MAPPING_PORT(DestinationKey[NatReversePath]),
                MAPPING_PORT(SourceKey[NatReversePath]),
                Protocol,
                FALSE
                );
        }
    }
#endif



    return STATUS_SUCCESS;

} // NatCreateMapping


NTSTATUS
NatDeleteMapping(
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    Called to delete a mapping from an interface. The initial reference
    to the mapping is released, so that cleanup occurs whenever the last
    reference is released.

Arguments:

    Mapping - the mapping to be deleted.

Return Value:

    NTSTATUS - indicates success/failure.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    KIRQL Irql;
    PRTL_SPLAY_LINKS SLink;
    CALLTRACE(("NatDeleteMapping\n"));

    if (NAT_MAPPING_DELETED(Mapping)) { return STATUS_PENDING; }

    //
    // Mark the mapping as deleted so attempts to reference it
    // will fail from now on.
    //

    Mapping->Flags |= NAT_MAPPING_FLAG_DELETED;

    //
    // Take the mapping off the list and splay-trees
    //

    InterlockedDecrement(&MappingCount);
    RemoveEntryList(&Mapping->Link);

    if (NAT_MAPPING_EXPIRED(Mapping)) {
        InterlockedDecrement(&ExpiredMappingCount);
    }

    SLink = RtlDelete(&Mapping->SLink[NatForwardPath]);
    MappingTree[NatForwardPath] =
        (SLink
            ? CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatForwardPath])
            : NULL);

    SLink = RtlDelete(&Mapping->SLink[NatReversePath]);
    MappingTree[NatReversePath] =
        (SLink
            ? CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatReversePath])
            : NULL);

#if NAT_WMI

    //
    // Log the deletion. Logging always uses public addresses,
    // not private.
    //

    if (!NAT_MAPPING_DO_NOT_LOG(Mapping)) {
        if (NAT_MAPPING_INBOUND(Mapping)) {
            NatLogConnectionDeletion(
                MAPPING_ADDRESS(Mapping->DestinationKey[NatForwardPath]),
                MAPPING_ADDRESS(Mapping->SourceKey[NatForwardPath]),
                MAPPING_PORT(Mapping->DestinationKey[NatForwardPath]),
                MAPPING_PORT(Mapping->SourceKey[NatForwardPath]),
                MAPPING_PROTOCOL(Mapping->SourceKey[NatForwardPath]),
                TRUE
                );
        } else {
            NatLogConnectionDeletion(
                MAPPING_ADDRESS(Mapping->DestinationKey[NatReversePath]),
                MAPPING_ADDRESS(Mapping->SourceKey[NatReversePath]),
                MAPPING_PORT(Mapping->DestinationKey[NatReversePath]),
                MAPPING_PORT(Mapping->SourceKey[NatReversePath]),
                MAPPING_PROTOCOL(Mapping->SourceKey[NatForwardPath]),
                FALSE
                );
        }
    }
#endif

    if (InterlockedDecrement(&Mapping->ReferenceCount) > 0) {

        //
        // The mapping is in use, defer final cleanup
        //

        return STATUS_PENDING;
    }

    //
    // Go ahead with final cleanup
    //

    NatCleanupMapping(Mapping);

    return STATUS_SUCCESS;

} // NatDeleteMapping


PNAT_DYNAMIC_MAPPING
NatDestinationLookupForwardMapping(
    ULONG64 DestinationKey
    )

/*++

Routine Description:

    This routine retrieves the mapping which matches the given destination
    key. The source key of the mapping is not examined.

Arguments:

    DestinationKey - the primary key used to search for a mapping.

Return Value:

    PNAT_DYNAMIC_MAPPING - the item found, or NULL if no match is found

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PNAT_DYNAMIC_MAPPING Root;
    PNAT_DYNAMIC_MAPPING Mapping;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatDestinationLookupForwardMapping\n"));

    //
    // First look in the mapping-cache
    //

    if ((Mapping =
            (PNAT_DYNAMIC_MAPPING)ProbeCache(
                MappingCache[NatForwardPath],
                (ULONG)DestinationKey
                )) &&
        Mapping->DestinationKey[NatForwardPath] == DestinationKey
        ) {
        
        TRACE(PER_PACKET, ("NatDestinationLookupForwardMapping: cache hit\n"));

        return Mapping;
    }

    //
    // Search the full tree
    //

    Root = MappingTree[NatForwardPath];

    for (SLink = !Root ? NULL : &Root->SLink[NatForwardPath]; SLink;  ) {

        Mapping =
            CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatForwardPath]);

        if (DestinationKey < Mapping->DestinationKey[NatForwardPath]) {
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (DestinationKey > Mapping->DestinationKey[NatForwardPath]) {
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // We found the mapping. We don't update the cache for partial
        // lookups.
        //
        
        return Mapping;
    }

    //
    // No partial match was found
    //

    return NULL;

} // NatDestinationLookupForwardMapping


PNAT_DYNAMIC_MAPPING
NatDestinationLookupReverseMapping(
    ULONG64 DestinationKey
    )

/*++

Routine Description:

    This routine retrieves the mapping which matches the given destination
    key. The source key of the mapping is not examined.

Arguments:

    DestinationKey - the primary key used to search for a mapping.

Return Value:

    PNAT_DYNAMIC_MAPPING - the item found, or NULL if no match is found

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PNAT_DYNAMIC_MAPPING Root;
    PNAT_DYNAMIC_MAPPING Mapping;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatDestinationLookupReverseMapping\n"));

    //
    // First look in the mapping-cache
    //

    if ((Mapping =
            (PNAT_DYNAMIC_MAPPING)ProbeCache(
                MappingCache[NatReversePath],
                (ULONG)DestinationKey
                )) &&
        Mapping->DestinationKey[NatReversePath] == DestinationKey
        ) {
        
        TRACE(PER_PACKET, ("NatDestinationLookupReverseMapping: cache hit\n"));

        return Mapping;
    }

    //
    // Search the full tree
    //

    Root = MappingTree[NatReversePath];

    for (SLink = !Root ? NULL : &Root->SLink[NatReversePath]; SLink;  ) {

        Mapping =
            CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatReversePath]);

        if (DestinationKey < Mapping->DestinationKey[NatReversePath]) {
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (DestinationKey > Mapping->DestinationKey[NatReversePath]) {
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // We found the mapping. We don't update the cache for partial
        // lookups.
        //
        
        return Mapping;
    }

    //
    // No partial match was found
    //

    return NULL;

} // NatDestinationLookupReverseMapping


VOID
NatInitializeMappingManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the NAT's mapping-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeMappingManagement\n"));
    MappingCount = 0;
    ExpiredMappingCount = 0;
    InitializeListHead(&MappingList);
    KeInitializeSpinLock(&MappingLock);
    MappingTree[NatForwardPath] = NULL;
    MappingTree[NatReversePath] = NULL;
    InitializeCache(MappingCache[NatForwardPath]);
    InitializeCache(MappingCache[NatReversePath]);
    ExInitializeNPagedLookasideList(
        &MappingLookasideList,
        NatAllocateFunction,
        NULL,
        0,
        sizeof(NAT_DYNAMIC_MAPPING),
        NAT_TAG_MAPPING,
        MAPPING_LOOKASIDE_DEPTH
        );

} // NatInitializeMappingManagement


PNAT_DYNAMIC_MAPPING
NatInsertForwardMapping(
    PNAT_DYNAMIC_MAPPING Parent,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine inserts a mapping into the tree.

Arguments:

    Parent - the node to be the parent for the new mapping.
        If NULL, the new mapping becomes the root.

    Mapping - the new mapping to be inserted.

Return Value:

    PNAT_DYNAMIC_MAPPING - The new root of the tree.
        If insertion fails, returns NULL.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PRTL_SPLAY_LINKS Root;

    CALLTRACE(("NatInsertForwardMapping\n"));

    if (!Parent) {
        TRACE(MAPPING, ("NatInsertForwardMapping: inserting as root\n"));
        return Mapping;
    }

    //
    // Insert as left or right child
    //

    if (Mapping->DestinationKey[NatForwardPath] <
        Parent->DestinationKey[NatForwardPath]) {
        RtlInsertAsLeftChild(
            &Parent->SLink[NatForwardPath], &Mapping->SLink[NatForwardPath]
            );
    } else if (Mapping->DestinationKey[NatForwardPath] >
                Parent->DestinationKey[NatForwardPath]) {
        RtlInsertAsRightChild(
            &Parent->SLink[NatForwardPath], &Mapping->SLink[NatForwardPath]
            );
    } else {

        //
        // Primary keys are equal; check secondary keys
        //

        if (Mapping->SourceKey[NatForwardPath] <
            Parent->SourceKey[NatForwardPath]) {
            RtlInsertAsLeftChild(
                &Parent->SLink[NatForwardPath], &Mapping->SLink[NatForwardPath]
                );
        } else if (Mapping->SourceKey[NatForwardPath] >
                    Parent->SourceKey[NatForwardPath]) {
            RtlInsertAsRightChild(
                &Parent->SLink[NatForwardPath], &Mapping->SLink[NatForwardPath]
                );
        } else {

            //
            // Secondary keys equal too; fail.
            //

            ERROR((
               "NatInsertForwardMapping: collision 0x%016I64X,0x%016I64X\n",
               Mapping->DestinationKey[NatForwardPath],
               Mapping->SourceKey[NatForwardPath]
               ));

            return NULL;
        }
    }

    //
    // Splay the new node and return the resulting root.
    //

    Root = RtlSplay(&Mapping->SLink[NatForwardPath]);
    return CONTAINING_RECORD(Root, NAT_DYNAMIC_MAPPING, SLink[NatForwardPath]);

} // NatInsertForwardMapping



PNAT_DYNAMIC_MAPPING
NatInsertReverseMapping(
    PNAT_DYNAMIC_MAPPING Parent,
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine inserts a mapping into the tree.

Arguments:

    Parent - the node to be the parent for the new mapping.
        If NULL, the new mapping becomes the root.

    Mapping - the new mapping to be inserted.

Return Value:

    PNAT_DYNAMIC_MAPPING - The new root of the tree.
        If insertion fails, returns NULL.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PRTL_SPLAY_LINKS Root;

    CALLTRACE(("NatInsertReverseMapping\n"));

    if (!Parent) {
        TRACE(MAPPING, ("NatInsertReverseMapping: inserting as root\n"));
        return Mapping;
    }

    //
    // Insert as left or right child
    //

    if (Mapping->DestinationKey[NatReversePath] <
        Parent->DestinationKey[NatReversePath]) {
        RtlInsertAsLeftChild(
            &Parent->SLink[NatReversePath], &Mapping->SLink[NatReversePath]
            );
    } else if (Mapping->DestinationKey[NatReversePath] >
                Parent->DestinationKey[NatReversePath]) {
        RtlInsertAsRightChild(
            &Parent->SLink[NatReversePath], &Mapping->SLink[NatReversePath]
            );
    } else {

        //
        // Primary keys are equal; check secondary keys
        //

        if (Mapping->SourceKey[NatReversePath] <
            Parent->SourceKey[NatReversePath]) {
            RtlInsertAsLeftChild(
                &Parent->SLink[NatReversePath], &Mapping->SLink[NatReversePath]
                );
        } else if (Mapping->SourceKey[NatReversePath] >
                    Parent->SourceKey[NatReversePath]) {
            RtlInsertAsRightChild(
                &Parent->SLink[NatReversePath], &Mapping->SLink[NatReversePath]
                );
        } else {

            //
            // Secondary keys equal too; fail.
            //

            ERROR((
               "NatInsertReverseMapping: collision 0x%016I64X,0x%016I64X\n",
               Mapping->DestinationKey[NatReversePath],
               Mapping->SourceKey[NatReversePath]
               ));

            return NULL;
        }
    }

    //
    // Splay the new node and return the resulting root.
    //

    Root = RtlSplay(&Mapping->SLink[NatReversePath]);
    return CONTAINING_RECORD(Root, NAT_DYNAMIC_MAPPING, SLink[NatReversePath]);

} // NatInsertReverseMapping


NTSTATUS
NatLookupAndQueryInformationMapping(
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    OUT PVOID Information,
    ULONG InformationLength,
    NAT_SESSION_MAPPING_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine attempts to locate a particular session mapping using either
    its forward key or reverse key, and to query information for the mapping,
    if found.

Arguments:

    Protocol - the IP protocol for the mapping to be located

    Destination* - the destination endpoint for the mapping

    Source* - the source endpoint for the mapping

    Information - on output, receives the requested information

    InformationLength - contains the length of the buffer at 'Information'

    InformationClass - specifies

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    ULONG64 DestinationKey;
    KIRQL Irql;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG64 SourceKey;
    NTSTATUS status;
    CALLTRACE(("NatLookupAndQueryInformationMapping\n"));

    //
    // Construct the destination and source key for the mapping,
    // and attempt to retrieve it. We try all four possible combinations
    // of these keys since the caller can't be guaranteed to know which
    // direction the session was headed when it was initiated.
    //

    MAKE_MAPPING_KEY(
        DestinationKey,
        Protocol,
        DestinationAddress,
        DestinationPort
        );
    MAKE_MAPPING_KEY(
        SourceKey,
        Protocol,
        SourceAddress,
        SourcePort
        );
    KeAcquireSpinLock(&MappingLock, &Irql);
    if (!(Mapping = NatLookupForwardMapping(DestinationKey, SourceKey, NULL)) &&
        !(Mapping = NatLookupReverseMapping(DestinationKey, SourceKey, NULL)) &&
        !(Mapping = NatLookupForwardMapping(SourceKey, DestinationKey, NULL)) &&
        !(Mapping = NatLookupReverseMapping(SourceKey, DestinationKey, NULL))) {
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_UNSUCCESSFUL;
    }
    NatReferenceMapping(Mapping);
    KeReleaseSpinLock(&MappingLock, Irql);

    //
    // Attempt to supply the information requested about the mapping.
    //

    switch(InformationClass) {
        case NatKeySessionMappingInformation: {
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->DestinationAddress =
                MAPPING_ADDRESS(Mapping->DestinationKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->DestinationPort =
                MAPPING_PORT(Mapping->DestinationKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->SourceAddress =
                MAPPING_ADDRESS(Mapping->SourceKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->SourcePort =
                MAPPING_PORT(Mapping->SourceKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->NewDestinationAddress =
                MAPPING_ADDRESS(Mapping->SourceKey[NatReversePath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->NewDestinationPort =
                MAPPING_PORT(Mapping->SourceKey[NatReversePath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->NewSourceAddress =
                MAPPING_ADDRESS(Mapping->DestinationKey[NatReversePath]);
            ((PIP_NAT_SESSION_MAPPING_KEY)Information)->NewSourcePort =
                MAPPING_PORT(Mapping->DestinationKey[NatReversePath]);

            status = STATUS_SUCCESS;
            break;
        }

#if _WIN32_WINNT > 0x0500

        case NatKeySessionMappingExInformation: {
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->DestinationAddress =
                MAPPING_ADDRESS(Mapping->DestinationKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->DestinationPort =
                MAPPING_PORT(Mapping->DestinationKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->SourceAddress =
                MAPPING_ADDRESS(Mapping->SourceKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->SourcePort =
                MAPPING_PORT(Mapping->SourceKey[NatForwardPath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->NewDestinationAddress =
                MAPPING_ADDRESS(Mapping->SourceKey[NatReversePath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->NewDestinationPort =
                MAPPING_PORT(Mapping->SourceKey[NatReversePath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->NewSourceAddress =
                MAPPING_ADDRESS(Mapping->DestinationKey[NatReversePath]);
            ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->NewSourcePort =
                MAPPING_PORT(Mapping->DestinationKey[NatReversePath]);

            //
            // If this mapping was created by the Redirect director, attempt
            // to supply to interface that the redirect was triggered on
            //

            if (Mapping->Director ==
                    (PNAT_DIRECTOR)RedirectRegisterDirector.DirectorHandle
                && Mapping->DirectorContext != NULL) {

                ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->AdapterIndex =
                    ((PNAT_REDIRECT)Mapping->DirectorContext)->RestrictAdapterIndex;

            } else {

                ((PIP_NAT_SESSION_MAPPING_KEY_EX)Information)->AdapterIndex =
                    INVALID_IF_INDEX;
            }
            status = STATUS_SUCCESS;
            break;
        }

#endif

        case NatStatisticsSessionMappingInformation: {
            NatQueryInformationMapping(
                Mapping,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                (PIP_NAT_SESSION_MAPPING_STATISTICS)Information
                );
            status = STATUS_SUCCESS;
            break;
        }
        default: {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    NatDereferenceMapping(Mapping);
    return status;
} // NatLookupAndQueryInformationMapping


PNAT_DYNAMIC_MAPPING
NatLookupForwardMapping(
    ULONG64 DestinationKey,
    ULONG64 SourceKey,
    PNAT_DYNAMIC_MAPPING* InsertionPoint
    )

/*++

Routine Description:

    This routine retrieves the mapping which matches the given key.
    If the item is not found, the caller is supplied with the point
    at which a new item should be inserted for the given key.

Arguments:

    DestinationKey - the primary key used to search for a mapping.

    SourceKey - the secondary search key.

    InsertionPoint - receives point of insertion in case no match is found.

Return Value:

    PNAT_DYNAMIC_MAPPING - The item found, or NULL if no exact match is found.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PNAT_DYNAMIC_MAPPING Root;
    PNAT_DYNAMIC_MAPPING Mapping;
    PNAT_DYNAMIC_MAPPING Parent = NULL;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatLookupForwardMapping\n"));

    //
    // First look in the mapping-cache
    //

    if ((Mapping =
            (PNAT_DYNAMIC_MAPPING)ProbeCache(
                MappingCache[NatForwardPath],
                (ULONG)DestinationKey
                )) &&
        Mapping->DestinationKey[NatForwardPath] == DestinationKey &&
        Mapping->SourceKey[NatForwardPath] == SourceKey
        ) {
        TRACE(PER_PACKET, ("NatLookupForwardMapping: cache hit\n"));
        return Mapping;
    }

    //
    // Search the full tree
    //

    Root = MappingTree[NatForwardPath];

    for (SLink = !Root ? NULL : &Root->SLink[NatForwardPath]; SLink;  ) {

        Mapping =
            CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatForwardPath]);

        if (DestinationKey < Mapping->DestinationKey[NatForwardPath]) {
            Parent = Mapping;
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (DestinationKey > Mapping->DestinationKey[NatForwardPath]) {
            Parent = Mapping;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // Primary keys match; check the secondary keys.
        //

        if (SourceKey < Mapping->SourceKey[NatForwardPath]) {
            Parent = Mapping;
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (SourceKey > Mapping->SourceKey[NatForwardPath]) {
            Parent = Mapping;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // Secondary keys match; we got it.
        //

        UpdateCache(
            MappingCache[NatForwardPath],
            (ULONG)DestinationKey,
            (PVOID)Mapping
            );

        return Mapping;
    }

    //
    // We didn't get it; tell the caller where to insert it.
    //

    if (InsertionPoint) { *InsertionPoint = Parent; }

    return NULL;

} // NatLookupForwardMapping


PNAT_DYNAMIC_MAPPING
NatLookupReverseMapping(
    ULONG64 DestinationKey,
    ULONG64 SourceKey,
    PNAT_DYNAMIC_MAPPING* InsertionPoint
    )

/*++

Routine Description:

    This routine retrieves the mapping which matches the given key.
    If the item is not found, the caller is supplied with the point
    at which a new item should be inserted for the given key.

Arguments:

    DestinationKey - the primary key used to search for a mapping.

    SourceKey - the secondary search key.

    InsertionPoint - receives point of insertion in case no match is found.

Return Value:

    PNAT_DYNAMIC_MAPPING - The item found, or NULL if no exact match is found.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PNAT_DYNAMIC_MAPPING Root;
    PNAT_DYNAMIC_MAPPING Mapping;
    PNAT_DYNAMIC_MAPPING Parent = NULL;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatLookupReverseMapping\n"));

    //
    // First look in the mapping-cache
    //

    if ((Mapping =
            (PNAT_DYNAMIC_MAPPING)ProbeCache(
                MappingCache[NatReversePath],
                (ULONG)DestinationKey
                )) &&
        Mapping->DestinationKey[NatReversePath] == DestinationKey &&
        Mapping->SourceKey[NatReversePath] == SourceKey
        ) {
        TRACE(PER_PACKET, ("NatLookupReverseMapping: cache hit\n"));
        return Mapping;
    }

    //
    // Search the full tree
    //

    Root = MappingTree[NatReversePath];

    for (SLink = !Root ? NULL : &Root->SLink[NatReversePath]; SLink;  ) {

        Mapping =
            CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatReversePath]);

        if (DestinationKey < Mapping->DestinationKey[NatReversePath]) {
            Parent = Mapping;
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (DestinationKey > Mapping->DestinationKey[NatReversePath]) {
            Parent = Mapping;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // Primary keys match; check the secondary keys.
        //

        if (SourceKey < Mapping->SourceKey[NatReversePath]) {
            Parent = Mapping;
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (SourceKey > Mapping->SourceKey[NatReversePath]) {
            Parent = Mapping;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // Secondary keys match; we got it.
        //

        UpdateCache(
            MappingCache[NatReversePath],
            (ULONG)DestinationKey,
            (PVOID)Mapping
            );

        return Mapping;
    }

    //
    // We didn't get it; tell the caller where to insert it.
    //

    if (InsertionPoint) { *InsertionPoint = Parent; }

    return NULL;

} // NatLookupReverseMapping


VOID
NatQueryInformationMapping(
    IN PNAT_DYNAMIC_MAPPING Mapping,
    OUT PUCHAR Protocol OPTIONAL,
    OUT PULONG PrivateAddress OPTIONAL,
    OUT PUSHORT PrivatePort OPTIONAL,
    OUT PULONG RemoteAddress OPTIONAL,
    OUT PUSHORT RemotePort OPTIONAL,
    OUT PULONG PublicAddress OPTIONAL,
    OUT PUSHORT PublicPort OPTIONAL,
    OUT PIP_NAT_SESSION_MAPPING_STATISTICS Statistics OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve information about a mapping.
    This is used, for instance, to extract public/private/remote information
    from the mapping-keys of mappings associated with boundary interfaces.

Arguments:

    Mapping - the mapping for which information is required

    Protocol - receives the mapping's protocol

    Private* - receive information about the private endpoint

    Remote* - receive information about the remote endpoint

    Public* - receive information about the public endpoint

    Statistics - receives the mapping's statistics

Return Value:

    none.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    IP_NAT_PATH ForwardPath =
        NAT_MAPPING_INBOUND(Mapping) ? NatReversePath : NatForwardPath;
    IP_NAT_PATH ReversePath =
        NAT_MAPPING_INBOUND(Mapping) ? NatForwardPath : NatReversePath;
    CALLTRACE(("NatQueryInformationMapping\n"));
    if (Protocol) {
        *Protocol = MAPPING_PROTOCOL(Mapping->SourceKey[ForwardPath]);
    }
    if (PrivateAddress) {
        *PrivateAddress = MAPPING_ADDRESS(Mapping->SourceKey[ForwardPath]);
    }
    if (PrivatePort) {
        *PrivatePort = MAPPING_PORT(Mapping->SourceKey[ForwardPath]);
    }
    if (PublicAddress) {
        *PublicAddress = MAPPING_ADDRESS(Mapping->DestinationKey[ReversePath]);
    }
    if (PublicPort) {
        *PublicPort = MAPPING_PORT(Mapping->DestinationKey[ReversePath]);
    }
    if (RemoteAddress) {
        *RemoteAddress = MAPPING_ADDRESS(Mapping->DestinationKey[ForwardPath]);
    }
    if (RemotePort) {
        *RemotePort = MAPPING_PORT(Mapping->DestinationKey[ForwardPath]);
    }
    if (Statistics) {
        NatUpdateStatisticsMapping(Mapping); *Statistics = Mapping->Statistics;
    }
} // NatQueryInformationMapping


NTSTATUS
NatQueryInterfaceMappingTable(
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS InputBuffer,
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS OutputBuffer,
    IN PULONG OutputBufferLength
    )

/*++

Routine Description:

    This routine is used for enumerating the session-mappings.
    Enumeration makes use of a context structure which is passed
    in with each enumeration attempt. The context structure
    is updated each time with the key of the next mapping to be enumerated.

Arguments:

    InputBuffer - supplies context information for the information

    OutputBuffer - receives the result of the enumeration

    OutputBufferLength - size of the i/o buffer

Return Value:

    STATUS_SUCCESS if successful, error code otherwise.

--*/

{
    PULONG Context;
    ULONG Count;
    LONG64 CurrentTime;
    ULONG64 DestinationKey;
    ULONG i;
    LONG64 IdleTime;
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG64 SourceKey;
    NTSTATUS status;
    PIP_NAT_SESSION_MAPPING Table;

    CALLTRACE(("NatQueryInterfaceMappingTable\n"));

    KeAcquireSpinLock(&MappingLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
    Interfacep = NatLookupInterface(InputBuffer->Index, NULL);
    if (!Interfacep) {
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // See if this is a new enumeration or a continuation of an old one.
    //

    Context = InputBuffer->EnumerateContext;
    if (!Context[0]) {

        //
        // This is a new enumeration. We start with the first item
        // in the interface's list of mappings
        //

        Mapping =
            IsListEmpty(&Interfacep->MappingList)
                ? NULL
                : CONTAINING_RECORD(
                    Interfacep->MappingList.Flink,
                    NAT_DYNAMIC_MAPPING,
                    InterfaceLink
                    );
    } else {

        //
        // This is a continuation. The context therefore contains
        // the keys for the next mapping, in the fields
        // Context[0-1] and Context[2-3] respectively
        //

        DestinationKey = MAKE_LONG64(Context[0], Context[1]);
        SourceKey = MAKE_LONG64(Context[2], Context[3]);

        Mapping =
            NatLookupForwardMapping(
                DestinationKey,
                SourceKey,
                NULL
                );
        if (Mapping && !Mapping->Interfacep) { Mapping = NULL; }
    }

    if (!Mapping) {
        OutputBuffer->EnumerateCount = 0;
        OutputBuffer->EnumerateContext[0] = 0;
        OutputBuffer->EnumerateTotalHint = MappingCount;
        *OutputBufferLength =
            FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable);
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_SUCCESS;
    }

    KeReleaseSpinLockFromDpcLevel(&MappingLock);

    //
    // Compute the maximum number of mappings we can store
    //

    Count =
        *OutputBufferLength -
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable);
    Count /= sizeof(IP_NAT_SESSION_MAPPING);

    //
    // Walk the list storing mappings in the caller's buffer
    //

    Table = OutputBuffer->EnumerateTable;
    KeQueryTickCount((PLARGE_INTEGER)&CurrentTime);

    for (i = 0, Link = &Mapping->InterfaceLink;
         i < Count && Link != &Interfacep->MappingList;
         i++, Link = Link->Flink
         ) {
        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, InterfaceLink);
        NatQueryInformationMapping(
            Mapping,
            &Table[i].Protocol,
            &Table[i].PrivateAddress,
            &Table[i].PrivatePort,
            &Table[i].RemoteAddress,
            &Table[i].RemotePort,
            &Table[i].PublicAddress,
            &Table[i].PublicPort,
            NULL
            );
        Table[i].Direction =
            NAT_MAPPING_INBOUND(Mapping)
                ? NatInboundDirection : NatOutboundDirection;
        IdleTime = CurrentTime - Mapping->LastAccessTime;
        Table[i].IdleTime = (ULONG)TICKS_TO_SECONDS(IdleTime);
    }

    //
    // The enumeration is over; update the output structure
    //

    *OutputBufferLength =
        i * sizeof(IP_NAT_SESSION_MAPPING) +
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable);
    OutputBuffer->EnumerateCount = i;
    OutputBuffer->EnumerateTotalHint = MappingCount;
    if (Link == &Interfacep->MappingList) {
        //
        // We reached the end of the mapping list
        //
        OutputBuffer->EnumerateContext[0] = 0;
    } else {
        //
        // Save the continuation context
        //
        Mapping =
            CONTAINING_RECORD(
                Link, NAT_DYNAMIC_MAPPING, InterfaceLink
                );
        OutputBuffer->EnumerateContext[0] =
            (ULONG)Mapping->DestinationKey[NatForwardPath];
        OutputBuffer->EnumerateContext[1] =
            (ULONG)(Mapping->DestinationKey[NatForwardPath] >> 32);
        OutputBuffer->EnumerateContext[2] =
            (ULONG)Mapping->SourceKey[NatForwardPath];
        OutputBuffer->EnumerateContext[3] =
            (ULONG)(Mapping->SourceKey[NatForwardPath] >> 32);
    }

    KeReleaseSpinLock(&InterfaceLock, Irql);
    return STATUS_SUCCESS;

} // NatQueryInterfaceMappingTable


NTSTATUS
NatQueryMappingTable(
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS InputBuffer,
    IN PIP_NAT_ENUMERATE_SESSION_MAPPINGS OutputBuffer,
    IN PULONG OutputBufferLength
    )

/*++

Routine Description:

    This routine is used for enumerating the session-mappings.

Arguments:

    InputBuffer - supplies context information for the information

    OutputBuffer - receives the result of the enumeration

    OutputBufferLength - size of the i/o buffer

Return Value:

    STATUS_SUCCESS if successful, error code otherwise.

--*/

{
    PULONG Context;
    ULONG Count;
    LONG64 CurrentTime;
    ULONG64 DestinationKey;
    ULONG i;
    LONG64 IdleTime;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG64 SourceKey;
    NTSTATUS status;
    PIP_NAT_SESSION_MAPPING Table;

    CALLTRACE(("NatQueryMappingTable\n"));

    Context = InputBuffer->EnumerateContext;
    KeAcquireSpinLock(&MappingLock, &Irql);

    //
    // See if this is a new enumeration or a continuation of an old one.
    //

    if (!Context[0]) {

        //
        // This is a new enumeration. We start with the first item
        // in the interface's list of mappings
        //

        Mapping =
            IsListEmpty(&MappingList)
                ? NULL
                : CONTAINING_RECORD(
                    MappingList.Flink, NAT_DYNAMIC_MAPPING, Link
                    );
    } else {

        //
        // This is a continuation. The context therefore contains
        // the keys for the next mapping, in the fields
        // Context[0-1] and Context[2-3] respectively
        //

        DestinationKey = MAKE_LONG64(Context[0], Context[1]);
        SourceKey = MAKE_LONG64(Context[2], Context[3]);

        Mapping =
            NatLookupForwardMapping(
                DestinationKey,
                SourceKey,
                NULL
                );
    }

    if (!Mapping) {
        OutputBuffer->EnumerateCount = 0;
        OutputBuffer->EnumerateContext[0] = 0;
        OutputBuffer->EnumerateTotalHint = MappingCount;
        *OutputBufferLength =
            FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable);
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_SUCCESS;
    }

    //
    // Compute the maximum number of mappings we can store
    //

    Count =
        *OutputBufferLength -
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable);
    Count /= sizeof(IP_NAT_SESSION_MAPPING);

    //
    // Walk the list storing mappings in the caller's buffer
    //

    Table = OutputBuffer->EnumerateTable;
    KeQueryTickCount((PLARGE_INTEGER)&CurrentTime);

    for (i = 0, Link = &Mapping->Link;
         i < Count && Link != &MappingList;
         i++, Link = Link->Flink
         ) {

        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, Link);

        NatQueryInformationMapping(
            Mapping,
            &Table[i].Protocol,
            &Table[i].PrivateAddress,
            &Table[i].PrivatePort,
            &Table[i].RemoteAddress,
            &Table[i].RemotePort,
            &Table[i].PublicAddress,
            &Table[i].PublicPort,
            NULL
            );
        Table[i].Direction =
            NAT_MAPPING_INBOUND(Mapping)
                ? NatInboundDirection : NatOutboundDirection;
        IdleTime = CurrentTime - Mapping->LastAccessTime;
        Table[i].IdleTime = (ULONG)TICKS_TO_SECONDS(IdleTime);
    }

    //
    // The enumeration is over; update the output structure
    //

    *OutputBufferLength =
        i * sizeof(IP_NAT_SESSION_MAPPING) +
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable);
    OutputBuffer->EnumerateCount = i;
    OutputBuffer->EnumerateTotalHint = MappingCount;
    if (Link == &MappingList) {
        //
        // We reached the end of the mapping list
        //
        OutputBuffer->EnumerateContext[0] = 0;
    } else {
        //
        // Save the continuation context
        //
        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, Link);
        OutputBuffer->EnumerateContext[0] =
            (ULONG)Mapping->DestinationKey[NatForwardPath];
        OutputBuffer->EnumerateContext[1] =
            (ULONG)(Mapping->DestinationKey[NatForwardPath] >> 32);
        OutputBuffer->EnumerateContext[2] =
            (ULONG)Mapping->SourceKey[NatForwardPath];
        OutputBuffer->EnumerateContext[3] =
            (ULONG)(Mapping->SourceKey[NatForwardPath] >> 32);
    }

    KeReleaseSpinLock(&MappingLock, Irql);
    return STATUS_SUCCESS;

} // NatQueryMappingTable


PNAT_DYNAMIC_MAPPING
NatSourceLookupForwardMapping(
    ULONG64 SourceKey
    )

/*++

Routine Description:

    This routine retrieves the mapping which matches the given source key.
    The destination key of the mapping is not examined.

Arguments:

    SourceKey - the primary key used to search for a mapping.

    PublicAddressp - receives the private address of the mapping

    PublicPortp - receives the private port of the mapping

Return Value:

    PNAT_DYNAMIC_MAPPING - the item found, or NULL if no match is found

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PNAT_DYNAMIC_MAPPING Root;
    PNAT_DYNAMIC_MAPPING Mapping;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatSourceLookupForwardMapping\n"));

    //
    // Search the full tree -- the mapping cache can only be used
    // for destination lookups.
    //

    Root = MappingTree[NatForwardPath];

    for (SLink = !Root ? NULL : &Root->SLink[NatForwardPath]; SLink;  ) {

        Mapping =
            CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatForwardPath]);

        if (SourceKey < Mapping->SourceKey[NatForwardPath]) {
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (SourceKey > Mapping->SourceKey[NatForwardPath]) {
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // We found the mapping.
        //
        
        return Mapping;
    }

    //
    // No partial match was found
    //

    return NULL;

} // NatSourceLookupForwardMapping


PNAT_DYNAMIC_MAPPING
NatSourceLookupReverseMapping(
    ULONG64 SourceKey
    )

/*++

Routine Description:

    This routine retrieves the mapping which matches the given source key.
    The destination key of the mapping is not examined.

Arguments:

    SourceKey - the primary key used to search for a mapping.

Return Value:

    PNAT_DYNAMIC_MAPPING - the item found, or NULL if no match is found

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    PNAT_DYNAMIC_MAPPING Root;
    PNAT_DYNAMIC_MAPPING Mapping;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatSourceLookupReverseMapping\n"));

    //
    // Search the full tree -- the mapping cache can only be used
    // for destination lookups.
    //
    
    Root = MappingTree[NatReversePath];

    for (SLink = !Root ? NULL : &Root->SLink[NatReversePath]; SLink;  ) {

        Mapping =
            CONTAINING_RECORD(SLink,NAT_DYNAMIC_MAPPING,SLink[NatReversePath]);

        if (SourceKey < Mapping->SourceKey[NatReversePath]) {
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (SourceKey > Mapping->SourceKey[NatReversePath]) {
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // We found the mapping.
        //
        
        return Mapping;
    }

    //
    // No partial match was found
    //

    return NULL;

} // NatSourceLookupReverseMapping



VOID
NatShutdownMappingManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to shutdown the mapping-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked with no references made to any mappings.

--*/

{
    KIRQL Irql;
    PNAT_DYNAMIC_MAPPING Mapping;
    CALLTRACE(("NatShutdownMappingManagement\n"));
    KeAcquireSpinLock(&MappingLock, &Irql);
    while (!IsListEmpty(&MappingList)) {
        Mapping =
            CONTAINING_RECORD(MappingList.Flink, NAT_DYNAMIC_MAPPING, Link);
        RemoveEntryList(&Mapping->Link);
        NatCleanupMapping(Mapping);
    }
    MappingTree[NatForwardPath] = NULL;
    MappingTree[NatReversePath] = NULL;
    KeReleaseSpinLock(&MappingLock, Irql);
    ExDeleteNPagedLookasideList(&MappingLookasideList);
} // NatShutdownMappingManagement


VOID
NatUpdateStatisticsMapping(
    PNAT_DYNAMIC_MAPPING Mapping
    )

/*++

Routine Description:

    This routine is invoked to immediately update the statistics for a mapping,
    adding the 32-bit incremental counters to the 64-bit cumulative counters.

Arguments:

    Mapping - the mapping whose statistics are to be updated

Return Value:

    none.

Environment:

    Invoked with 'MappingLock' held by the caller.

--*/

{
    ULONG BytesForward;
    ULONG BytesReverse;
    ULONG PacketsForward;
    ULONG PacketsReverse;
    ULONG RejectsForward;
    ULONG RejectsReverse;
    CALLTRACE(("NatUpdateStatisticsMapping\n"));

    //
    // Read the statistics accrued since the last incremental update
    //

    BytesForward = InterlockedExchange(&Mapping->BytesForward, 0);
    BytesReverse = InterlockedExchange(&Mapping->BytesReverse, 0);
    PacketsForward = InterlockedExchange(&Mapping->PacketsForward, 0);
    PacketsReverse = InterlockedExchange(&Mapping->PacketsReverse, 0);
    RejectsForward = InterlockedExchange(&Mapping->RejectsForward, 0);
    RejectsReverse = InterlockedExchange(&Mapping->RejectsReverse, 0);

#   define UPDATE_STATISTIC(x,y) \
    if (y) { \
        ExInterlockedAddLargeStatistic( \
            (PLARGE_INTEGER)&x->Statistics.y, y \
            ); \
    }
    //
    // Update the cumulative statistics for the mapping
    //
    UPDATE_STATISTIC(Mapping, BytesForward);
    UPDATE_STATISTIC(Mapping, BytesReverse);
    UPDATE_STATISTIC(Mapping, PacketsForward);
    UPDATE_STATISTIC(Mapping, PacketsReverse);
    UPDATE_STATISTIC(Mapping, RejectsForward);
    UPDATE_STATISTIC(Mapping, RejectsReverse);
    //
    // Update cumulative statistics for the mapping's interface, if any
    //
    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
    if (Mapping->Interfacep) {
        UPDATE_STATISTIC(Mapping->Interfacep, BytesForward);
        UPDATE_STATISTIC(Mapping->Interfacep, BytesReverse);
        UPDATE_STATISTIC(Mapping->Interfacep, PacketsForward);
        UPDATE_STATISTIC(Mapping->Interfacep, PacketsReverse);
        UPDATE_STATISTIC(Mapping->Interfacep, RejectsForward);
        UPDATE_STATISTIC(Mapping->Interfacep, RejectsReverse);
    }
    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
#   undef UPDATE_STATISTIC

} // NatUpdateStatisticsMapping
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\notify.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This module contains code related to the NAT's notification-management.
    Notification may be requested by a NAT user- or kernel-mode client,
    by making an I/O control request which will complete when
        (a) the requested event occurs, or
        (b) the client's file-object is cleaned up, or
        (c) the NAT is shutting down.
    In the meantime, the I/O request packets are held on a list of pending
    notification-requests.

Author:

    Abolade Gbadegesin  (aboladeg)  July-26-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LIST_ENTRY NotificationList;
KSPIN_LOCK NotificationLock;

//
// FORWARD DECLARATIONS
//

VOID
NatpNotificationCancelRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

PIRP
NatpDequeueNotification(
    IP_NAT_NOTIFICATION Code
    );


VOID
NatCleanupAnyAssociatedNotification(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to cleanup any notifications associated with
    the client whose file-object has just been closed.

Arguments:

    FileObject - the client's file-object

Return Value:

    none.

--*/

{
    PIRP Irp;
    KIRQL Irql;
    PLIST_ENTRY Link;
    CALLTRACE(("NatCleanupAnyAssociatedNotification\n"));

    KeAcquireSpinLock(&NotificationLock, &Irql);
    for (Link = NotificationList.Flink;
         Link != &NotificationList;
         Link = Link->Flink
         ) {
        Irp = CONTAINING_RECORD(Link, IRP, Tail.Overlay.ListEntry);
        if (Irp->Tail.Overlay.DriverContext[0] != FileObject) { continue; }
        if (NULL == IoSetCancelRoutine(Irp, NULL)) {

            //
            // This IRP has been canceled. It will be completed in
            // our cancel routine
            //
            
            continue;
        }

        //
        // The IRP is now uncancellable. Take it off the list.
        //
        
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
        InitializeListHead(&Irp->Tail.Overlay.ListEntry);
        KeReleaseSpinLockFromDpcLevel(&NotificationLock);

        //
        // Complete the IRP
        //
        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        DEREFERENCE_NAT();

        //
        // Continue the search, starting over since we dropped the list lock
        //

        KeAcquireSpinLockAtDpcLevel(&NotificationLock);
        Link = &NotificationList;
    }
    KeReleaseSpinLock(&NotificationLock, Irql);
} // NatCleanupAnyAssociatedNotification


VOID
NatInitializeNotificationManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the notification-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeNotificationManagement\n"));
    InitializeListHead(&NotificationList);
    KeInitializeSpinLock(&NotificationLock);
} // NatInitializeNotificationManagement


PIRP
NatpDequeueNotification(
    IP_NAT_NOTIFICATION Code
    )

/*++

Routine Description:

    This routine is invoked to dequeue a pending notification request IRP
    of the given type. If one is found, it is removed from the list
    and returned to the caller.

Arguments:

    Code - the notification code for which an IRP is required

Return Value:

    PIRP - the notification IRP, if any

Environment:

    Invoked with 'NotificationLock' held by the caller.

--*/

{
    PIRP Irp;
    PLIST_ENTRY Link;
    PIP_NAT_REQUEST_NOTIFICATION RequestNotification;
    CALLTRACE(("NatpDequeueNotification\n"));
    for (Link = NotificationList.Flink;
         Link != &NotificationList;
         Link = Link->Flink
         ) {
        Irp = CONTAINING_RECORD(Link, IRP, Tail.Overlay.ListEntry);
        RequestNotification =
             (PIP_NAT_REQUEST_NOTIFICATION)Irp->AssociatedIrp.SystemBuffer;
        if (RequestNotification->Code != Code) { continue; }
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
        InitializeListHead(&Irp->Tail.Overlay.ListEntry);
        return Irp;
    }
    return NULL;
} // NatpDequeueNotification


VOID
NatpNotificationCancelRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked by the I/O manager upon cancellation of an IRP
    that is associated with a notification.

Arguments:

    DeviceObject - the NAT's device-object

    Irp - the IRP to be cancelled

Return Value:

    none.

Environment:

    Invoked with the cancel spin-lock held by the I/O manager.
    It is this routine's responsibility to release the lock.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatpNotificationCancelRoutine\n"));
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    //
    // Take the IRP off our list
    //
    KeAcquireSpinLock(&NotificationLock, &Irql);
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    InitializeListHead(&Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&NotificationLock, Irql);
    //
    // Complete the IRP
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DEREFERENCE_NAT();
} // NatpNotificationCancelRoutine


NTSTATUS
NatRequestNotification(
    PIP_NAT_REQUEST_NOTIFICATION RequestNotification,
    PIRP Irp,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked upon receipt of a notification-request
    from a client.

Arguments:

    RequeustNotification - describes the notification

    Irp - the associated IRP

    FileObject - the client's file-object

Return Value:

    NTSTATUS - status code.

--*/

{
    KIRQL CancelIrql;
    PIO_STACK_LOCATION IrpSp;
    CALLTRACE(("NatRequestNotification\n"));
    //
    // Check the size of the supplied output-buffer
    //
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (RequestNotification->Code == NatRoutingFailureNotification) {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(IP_NAT_ROUTING_FAILURE_NOTIFICATION)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Attempt to queue the IRP for later completion.
    // If the IRP is already cancelled, though, do nothing
    //
    IoAcquireCancelSpinLock(&CancelIrql);
    KeAcquireSpinLockAtDpcLevel(&NotificationLock);
    if (Irp->Cancel || !REFERENCE_NAT()) {
        KeReleaseSpinLockFromDpcLevel(&NotificationLock);
        IoReleaseCancelSpinLock(CancelIrql);
        return STATUS_CANCELLED;
    }
    //
    // Put the IRP on the list and remember its file-object
    //
    InsertTailList(&NotificationList, &Irp->Tail.Overlay.ListEntry);
    Irp->Tail.Overlay.DriverContext[0] = FileObject;
    KeReleaseSpinLockFromDpcLevel(&NotificationLock);
    //
    // Install our cancel-routine
    //
    IoMarkIrpPending(Irp);
    IoSetCancelRoutine(Irp, NatpNotificationCancelRoutine);
    IoReleaseCancelSpinLock(CancelIrql);
    return STATUS_PENDING;
} // NatRequestNotification


VOID
NatSendRoutingFailureNotification(
    ULONG DestinationAddress,
    ULONG SourceAddress
    )

/*++

Routine Description:

    This routine is invoked to notify any clients that a routing failure has
    occurred.

Arguments:

    DestinationAddress - the destination address of the unroutable packet

    SourceAddress - the source address of the unroutable packet

Return Value:

    none.

--*/

{
    PIRP Irp;
    KIRQL Irql;
    PIP_NAT_ROUTING_FAILURE_NOTIFICATION RoutingFailureNotification;
    CALLTRACE(("NatSendRoutingFailureNotification\n"));
    //
    // See if any client wants routing-failure notification
    //
    KeAcquireSpinLock(&NotificationLock, &Irql);
    if (!(Irp = NatpDequeueNotification(NatRoutingFailureNotification))) {
        KeReleaseSpinLock(&NotificationLock, Irql);
        return;
    }
    KeReleaseSpinLock(&NotificationLock, Irql);
    //
    // Make the IRP uncancellable so we can complete it.
    //
    if (NULL == IoSetCancelRoutine(Irp, NULL)) {

        //
        // The IO manager canceled this IRP. It will be completed
        // in the cancel routine
        //
        
        return;
    }
    
    //
    // Fill in the notification information
    //
    RoutingFailureNotification =
        (PIP_NAT_ROUTING_FAILURE_NOTIFICATION)Irp->AssociatedIrp.SystemBuffer;
    RoutingFailureNotification->DestinationAddress = DestinationAddress;
    RoutingFailureNotification->SourceAddress = SourceAddress;
    //
    // Complete the IRP
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(*RoutingFailureNotification);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DEREFERENCE_NAT();
} // NatSendRoutingFailureNotification


VOID
NatShutdownNotificationManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to shut down the module.
    All outstanding notifications are cancelled.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PLIST_ENTRY Link;
    KIRQL Irql;
    CALLTRACE(("NatShutdownNotificationManagement\n"));

    KeAcquireSpinLock(&NotificationLock, &Irql);
    while (!IsListEmpty(&NotificationList)) {
        //
        // Take the next IRP off the list
        //
        Irp =
            CONTAINING_RECORD(
                NotificationList.Flink, IRP, Tail.Overlay.ListEntry
                );
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
        InitializeListHead(&Irp->Tail.Overlay.ListEntry);
        //
        // Cancel it if necessary
        //
        if (NULL != IoSetCancelRoutine(Irp, NULL)) {
            KeReleaseSpinLockFromDpcLevel(&NotificationLock);
            //
            // Complete the IRP
            //
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            DEREFERENCE_NAT();
            //
            // Resume emptying the list
            //
            KeAcquireSpinLockAtDpcLevel(&NotificationLock);
        }
    }
    KeReleaseSpinLock(&NotificationLock, Irql);
} // NatShutdownNotificationManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\natwmi.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    natwmi.h

Abstract:

    This files contains declarations for the NAT's WMI code, used
    for firewall event logging

Author:

    Jonathan Burstein (jonburs)     24-Jan-2000

Revision History:

--*/

#ifndef _NAT_WMI_H_
#define _NAT_WMI_H_

//
// Exported globals
//

#define NAT_WMI_CONNECTION_CREATION_EVENT   0
#define NAT_WMI_CONNECTION_DELETION_EVENT   1
#define NAT_WMI_PACKET_DROPPED_EVENT        2

extern LONG NatWmiEnabledEvents[];

//
// FUNCTION PROTOTYPES
//

NTSTATUS
NatExecuteSystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN ShouldComplete
    );
    
VOID
NatInitializeWMI(
    VOID
    );

VOID
FASTCALL
NatLogConnectionCreation(
    ULONG LocalAddress,
    ULONG RemoteAddress,
    USHORT LocalPort,
    USHORT RemotePort,
    UCHAR Protocol,
    BOOLEAN InboundConnection
    );

VOID
FASTCALL
NatLogConnectionDeletion(
    ULONG LocalAddress,
    ULONG RemoteAddress,
    USHORT LocalPort,
    USHORT RemotePort,
    UCHAR Protocol,
    BOOLEAN InboundConnection
    );

VOID
FASTCALL
NatLogDroppedPacket(
    NAT_XLATE_CONTEXT *Contextp
    );

VOID
NatShutdownWMI(
    VOID
    );

#endif // _NAT_WMI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\natwmi.c ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This file contains the code for handling WMI requests.

Author:

    Jonathan Burstein (jonburs)     24-Jan-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if NAT_WMI

//
// Data structures for identifying the guids and reporting them to
// WMI. Since the WMILIB callbacks pass an index into the guid list we make
// definitions for the various guids indicies.
//

GUID ConnectionCreationEventGuid = MSIPNAT_ConnectionCreationEventGuid;
GUID ConnectionDeletionEventGuid = MSIPNAT_ConnectionDeletionEventGuid;
GUID PacketDroppedEventGuid = MSIPNAT_PacketDroppedEventGuid;

WMIGUIDREGINFO NatWmiGuidList[] =
{
    {
        &ConnectionCreationEventGuid,
        1,
        WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID
    },

    {
        &ConnectionDeletionEventGuid,
        1,
        WMIREG_FLAG_TRACED_GUID
    },

    {
        &PacketDroppedEventGuid,
        1,
        WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID
    }
};

#define NatWmiGuidCount (sizeof(NatWmiGuidList) / sizeof(WMIGUIDREGINFO))

//
// Enabled events and associated log handles.
//
// NatWmiLogHandles should only be accessed while holding
// NatWmiLock.
//
// NatWmiEnabledEvents should only be modified while holding
// NatWmiLock. It may be read without holding the lock, according
// to these rules:
//
// If NatWmiEnabledEvents[ Event ] is 0, the that event is definately
// _not_ enabled, and there is no need to grab the spin lock.
//
// If NatWmiEnabledEvents[ Event ] is 1, the event _may_ be enabled.
// To determine if the event is truly enabled, grab the spin lock and
// see if NatWmiLogHandles[ Event ] is not 0.
//

LONG NatWmiEnabledEvents[ NatWmiGuidCount ];
UINT64 NatWmiLogHandles[ NatWmiGuidCount ];
KSPIN_LOCK NatWmiLock;

//
// Context block for WMILib routines
//

WMILIB_CONTEXT WmilibContext;

//
// MOF Resource Name
//

WCHAR IPNATMofResource[] = L"IPNATMofResource";

//
// WMI Base instance name
//

WCHAR BaseInstanceName[] = L"IPNat";

//
// Function Prototypes
//

NTSTATUS
NatpWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
NatpExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
NatpSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG InstanceIndex,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
NatpSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
NatpQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
NatpQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );





#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NatpQueryWmiRegInfo)
#pragma alloc_text(PAGE, NatpQueryWmiDataBlock)
#pragma alloc_text(PAGE, NatpSetWmiDataBlock)
#pragma alloc_text(PAGE, NatpSetWmiDataItem)
#pragma alloc_text(PAGE, NatpExecuteWmiMethod)
#pragma alloc_text(PAGE, NatpWmiFunctionControl)
#endif


NTSTATUS
NatExecuteSystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PBOOLEAN ShouldComplete
    )
    
/*++

Routine Description:

    Dispatch routine for System Control IRPs (MajorFunction == 
IRP_MJ_SYSTEM_CONTROL)

Arguments:

    DeviceObject - The device object for the firewall

    Irp - Io Request Packet

    ShouldComplete - [out] true on exit if the IRP needs to be complete

Return Value:

    NT status code

--*/

{
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;

    CALLTRACE(( "NatExecuteSystemControl\n" ));

    *ShouldComplete = FALSE;

    //
    // Call Wmilib helper function to crack the irp. If this is a wmi irp
    // that is targetted for this device then WmiSystemControl will callback
    // at the appropriate callback routine.
    //
    status = WmiSystemControl(
                &WmilibContext,
                DeviceObject,
                Irp,
                &disposition
                );

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            //
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // so we need to complete it
            //
            *ShouldComplete = TRUE;
            break;
        }

        case IrpNotWmi:
        {
            //
            // Not an WMI IRP -- just complete it. We don't handle
            // IRP_MJ_SYSTEM_CONTROL in any other way
            //
            *ShouldComplete = TRUE;
            break;
        }

        case IrpForward:
        default:
        {
            //
            // We really should never get here...
            //
            ASSERT(FALSE);
            break;
        }
    }

    if( !NT_SUCCESS( status ))
    {
        ERROR(( "NAT: Error (%08x) in NatExecuteSystemControl\n", status ));
    }

    return status;
} //NatExecuteSystemControl


VOID
NatInitializeWMI(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize WMI.
    
Arguments:

    none.

Return Value:

    none.

--*/

{
    NTSTATUS status;

    CALLTRACE(( "NatInitializeWMI\n" ));

    //
    // Initialize the spinlock that protects the structure below.
    //

    KeInitializeSpinLock( &NatWmiLock );

    //
    // Zero-out the event tracking structure
    //

    RtlZeroMemory( NatWmiEnabledEvents, sizeof( NatWmiEnabledEvents ));
    RtlZeroMemory( NatWmiLogHandles, sizeof( NatWmiLogHandles )); 
    
    //
    // Fill in the WMILIB_CONTEXT structure with a pointer to the
    // callback routines and a pointer to the list of guids
    // supported by the driver
    //
    
    WmilibContext.GuidCount = NatWmiGuidCount;
    WmilibContext.GuidList = NatWmiGuidList;
    WmilibContext.QueryWmiRegInfo = NatpQueryWmiRegInfo;
    WmilibContext.QueryWmiDataBlock = NatpQueryWmiDataBlock;
    WmilibContext.SetWmiDataBlock = NatpSetWmiDataBlock;
    WmilibContext.SetWmiDataItem = NatpSetWmiDataItem;
    WmilibContext.ExecuteWmiMethod = NatpExecuteWmiMethod;
    WmilibContext.WmiFunctionControl = NatpWmiFunctionControl;

    //
    // Register w/ WMI
    //

    status = IoWMIRegistrationControl(
                NatDeviceObject,
                WMIREG_ACTION_REGISTER
                );

    if( !NT_SUCCESS( status ))
    {
        ERROR(( "Nat: Error initializing WMI (%08x)\n", status ));
    }

    
} // NatInitializeWMI


VOID
FASTCALL
NatLogConnectionCreation(
    ULONG LocalAddress,
    ULONG RemoteAddress,
    USHORT LocalPort,
    USHORT RemotePort,
    UCHAR Protocol,
    BOOLEAN InboundConnection
    )

/*++

Routine Description:

    This routine is called to log the creation of a TCP/UDP connection
    (mapping). If this event is not enabled, no action is taken.
    
Arguments:

    
Return Value:

    none.

--*/

{
    NTSTATUS Status;
    KIRQL Irql;
    UINT64 Logger;
    ULONG Size;
    UCHAR Buffer[ sizeof(EVENT_TRACE_HEADER) + sizeof(MSIPNAT_ConnectionCreationEvent) ];
    PEVENT_TRACE_HEADER EventHeaderp;
    PMSIPNAT_ConnectionCreationEvent EventDatap;

    CALLTRACE(( "NatLogConnectionCreation\n" ));

    if( !NatWmiEnabledEvents[ NAT_WMI_CONNECTION_CREATION_EVENT ] )
    {
        //
        // Event not enabled -- exit quickly.
        //
        
        TRACE(WMI, ("NatLogConnectionCreation: Event not enabled\n"));
        return;
    }

    KeAcquireSpinLock( &NatWmiLock, &Irql );
    Logger = NatWmiLogHandles[ NAT_WMI_CONNECTION_CREATION_EVENT ];
    KeReleaseSpinLock( &NatWmiLock, Irql );
    
    if( Logger )
    {
        //
        // Zero out the buffer
        //

        RtlZeroMemory( Buffer, sizeof( Buffer ));
        
        //
        // Locate structure locations within the buffer
        //

        EventHeaderp = (PEVENT_TRACE_HEADER) Buffer;
        EventDatap =
            (PMSIPNAT_ConnectionCreationEvent) ((PUCHAR)Buffer + sizeof(EVENT_TRACE_HEADER));
        
        //
        // Fill out the event header  
        //

        EventHeaderp->Size = sizeof( Buffer );
        EventHeaderp->Version = 0;
        EventHeaderp->GuidPtr = (ULONGLONG) &ConnectionCreationEventGuid;
        EventHeaderp->Flags = WNODE_FLAG_TRACED_GUID
                                | WNODE_FLAG_USE_GUID_PTR
                                | WNODE_FLAG_USE_TIMESTAMP;
        ((PWNODE_HEADER)EventHeaderp)->HistoricalContext = Logger;
        KeQuerySystemTime( &EventHeaderp->TimeStamp );
        
        //
        // Fill out event data
        //

        EventDatap->LocalAddress = LocalAddress;
        EventDatap->RemoteAddress = RemoteAddress,
        EventDatap->LocalPort = LocalPort;
        EventDatap->RemotePort = RemotePort;
        EventDatap->Protocol = Protocol;
        EventDatap->InboundConnection = InboundConnection;

        //
        // Fire the event. Since this is a trace event and not a standard
        // WMI event, IoWMIWriteEvent will not attempt to free the buffer
        // passed into it.
        //

        Status = IoWMIWriteEvent( Buffer );
        if( !NT_SUCCESS( Status ))
        {
            TRACE(
                WMI,
                ("NatLogConnectionCreation: IoWMIWriteEvent returned %08x\n", Status )
                );
        }
    }
    else
    {
        TRACE(WMI, ("NatLogConnectionCreation: No logging handle\n"));
    }

} // NatLogConnectionCreation


VOID
FASTCALL
NatLogConnectionDeletion(
    ULONG LocalAddress,
    ULONG RemoteAddress,
    USHORT LocalPort,
    USHORT RemotePort,
    UCHAR Protocol,
    BOOLEAN InboundConnection
    )

/*++

Routine Description:

    This routine is called to log the deletion of a TCP/UDP connection
    (mapping). If this event is not enabled, no action is taken.
    
Arguments:

    

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    KIRQL Irql;
    UINT64 Logger;
    ULONG Size;
    UCHAR Buffer[ sizeof(EVENT_TRACE_HEADER) + sizeof(MSIPNAT_ConnectionDeletionEvent) ];
    PEVENT_TRACE_HEADER EventHeaderp;
    PMSIPNAT_ConnectionDeletionEvent EventDatap;

    CALLTRACE(( "NatLogConnectionDeletion\n" ));

    if( !NatWmiEnabledEvents[ NAT_WMI_CONNECTION_DELETION_EVENT ] )
    {
        //
        // Event not enabled -- exit quickly.
        //

        TRACE(WMI, ("NatLogConnectionDeletion: Event not enabled\n"));
        return;
    }

    KeAcquireSpinLock( &NatWmiLock, &Irql );
    Logger = NatWmiLogHandles[ NAT_WMI_CONNECTION_DELETION_EVENT ];
    KeReleaseSpinLock( &NatWmiLock, Irql );
    
    if( Logger )
    {
        //
        // Zero out the buffer
        //

        RtlZeroMemory( Buffer, sizeof( Buffer ));
        
        //
        // Locate structure locations within the buffer
        //

        EventHeaderp = (PEVENT_TRACE_HEADER) Buffer;
        EventDatap =
            (PMSIPNAT_ConnectionDeletionEvent) ((PUCHAR)Buffer + sizeof(EVENT_TRACE_HEADER));
        
        //
        // Fill out the event header  
        //

        EventHeaderp->Size = sizeof( Buffer );
        EventHeaderp->Version = 0;
        EventHeaderp->GuidPtr = (ULONGLONG) &ConnectionDeletionEventGuid;
        EventHeaderp->Flags = WNODE_FLAG_TRACED_GUID
                                | WNODE_FLAG_USE_GUID_PTR
                                | WNODE_FLAG_USE_TIMESTAMP;
        ((PWNODE_HEADER)EventHeaderp)->HistoricalContext = Logger;
        KeQuerySystemTime( &EventHeaderp->TimeStamp );
        
        //
        // Fill out event data
        //

        EventDatap->LocalAddress = LocalAddress;
        EventDatap->RemoteAddress = RemoteAddress,
        EventDatap->LocalPort = LocalPort;
        EventDatap->RemotePort = RemotePort;
        EventDatap->Protocol = Protocol;
        EventDatap->InboundConnection = InboundConnection;

        //
        // Fire the event. Since this is a trace event and not a standard
        // WMI event, IoWMIWriteEvent will not attempt to free the buffer
        // passed into it.
        //

        Status = IoWMIWriteEvent( Buffer );
        if( !NT_SUCCESS( Status ))
        {
            TRACE(
                WMI,
                ("NatLogConnectionDeletion: IoWMIWriteEvent returned %08x\n", Status )
                );
        }
    }
    else
    {
        TRACE(WMI, ("NatLogConnectionDeletion: No logging handle\n"));
    }

} // NatLogConnectionDeletion



VOID
FASTCALL
NatLogDroppedPacket(
    NAT_XLATE_CONTEXT *Contextp
    )

/*++

Routine Description:

    This routine is called to log a dropped packet. If no packet dropped
    logging events are enabled, the routine will take no action.
    
Arguments:

    Contextp - the translation context of the packet

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    KIRQL Irql;
    UINT64 Logger;
    ULONG Size;
    IPRcvBuf *PacketBuffer;
    UCHAR Protocol;
    UCHAR Buffer[ sizeof(EVENT_TRACE_HEADER) + sizeof(MSIPNAT_PacketDroppedEvent) ];
    PEVENT_TRACE_HEADER EventHeaderp;
    PMSIPNAT_PacketDroppedEvent EventDatap;
    

    CALLTRACE(( "NatLogDroppedPacket\n" ));

    if( !NatWmiEnabledEvents[ NAT_WMI_PACKET_DROPPED_EVENT ] )
    {
        //
        // Event not enabled -- exit quickly.
        //

        TRACE(WMI, ("NatLogDroppedPacket: Event not enabled\n"));
        return;
    }

    //
    // Exit if this packet has already been logged
    //

    if( NAT_XLATE_LOGGED( Contextp ))
    {
        TRACE( WMI, ("NatLogDroppedPacket: Duplicate dropped packet log attemp\n" ));
        return;
    }

    KeAcquireSpinLock( &NatWmiLock, &Irql );
    Logger = NatWmiLogHandles[ NAT_WMI_PACKET_DROPPED_EVENT ];
    KeReleaseSpinLock( &NatWmiLock, Irql );
    
    if( Logger )
    {
        //
        // Zero out the buffer
        //

        RtlZeroMemory( Buffer, sizeof( Buffer ));
        
        //
        // Locate structure locations within the buffer
        //

        EventHeaderp = (PEVENT_TRACE_HEADER) Buffer;
        EventDatap = (PMSIPNAT_PacketDroppedEvent) ((PUCHAR)Buffer + sizeof(EVENT_TRACE_HEADER));
        
        //
        // Fill out the event header  
        //

        EventHeaderp->Size = sizeof( Buffer );
        EventHeaderp->Version = 0;
        EventHeaderp->GuidPtr = (ULONGLONG) &PacketDroppedEventGuid;
        EventHeaderp->Flags = WNODE_FLAG_TRACED_GUID
                                | WNODE_FLAG_USE_GUID_PTR
                                | WNODE_FLAG_USE_TIMESTAMP;
        ((PWNODE_HEADER)EventHeaderp)->HistoricalContext = Logger;
        KeQuerySystemTime( &EventHeaderp->TimeStamp );
        
        //
        // Fill out event data
        //

        Protocol = Contextp->Header->Protocol;
        EventDatap->SourceAddress = Contextp->SourceAddress;
        EventDatap->DestinationAddress = Contextp->DestinationAddress;
        EventDatap->Protocol = Protocol;

        //
        // Compute packet size. We need to walk our buffer chain to do
        // this...
        //

        EventDatap->PacketSize = 0;
        PacketBuffer = Contextp->RecvBuffer;

        do
        {
            EventDatap->PacketSize += PacketBuffer->ipr_size;
            PacketBuffer = PacketBuffer->ipr_next;
        } while( NULL != PacketBuffer );

        if( NAT_PROTOCOL_TCP == Protocol || NAT_PROTOCOL_UDP == Protocol )
        {
            EventDatap->SourceIdentifier =
                ((PUSHORT)Contextp->ProtocolHeader)[0];
            EventDatap->DestinationIdentifier =
                ((PUSHORT)Contextp->ProtocolHeader)[1];

            if( NAT_PROTOCOL_TCP == Protocol )
            {
                EventDatap->ProtocolData1 =
                    ((PTCP_HEADER)Contextp->ProtocolHeader)->SequenceNumber;
                EventDatap->ProtocolData2 =
                    ((PTCP_HEADER)Contextp->ProtocolHeader)->AckNumber;
                EventDatap->ProtocolData3 = 
                    ((PTCP_HEADER)Contextp->ProtocolHeader)->WindowSize;
                EventDatap->ProtocolData4 =
                    TCP_ALL_FLAGS( (PTCP_HEADER)Contextp->ProtocolHeader );
            }
        }
        else if( NAT_PROTOCOL_ICMP == Protocol )
        {
            EventDatap->ProtocolData1 =
                ((PICMP_HEADER)Contextp->ProtocolHeader)->Type;
            EventDatap->ProtocolData2 =
                ((PICMP_HEADER)Contextp->ProtocolHeader)->Code;
        }

        //
        // Fire the event. Since this is a trace event and not a standard
        // WMI event, IoWMIWriteEvent will not attempt to free the buffer
        // passed into it.
        //

        Status = IoWMIWriteEvent( Buffer );
        if( !NT_SUCCESS( Status ))
        {
            TRACE(
                WMI,
                ("NatLogDroppedPacket: IoWMIWriteEvent returned %08x\n", Status )
                );
        }

        Contextp->Flags |= NAT_XLATE_FLAG_LOGGED;
    }
    else
    {
        TRACE(WMI, ("NatLogDroppedPacket: No logging handle\n"));
    }
    
} // NatLogDroppedPacket


NTSTATUS
NatpExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
    
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. If
    the driver can complete the method within the callback it should
    call WmiCompleteRequest to complete the irp before returning to the
    caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device whose method is being executed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the input buffer on entry and returns with
         the output data block

Return Value:

    status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    CALLTRACE(( "NatpExecuteWmiMethod\n" ));
    
    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_WMI_GUID_NOT_FOUND,
                0,
                IO_NO_INCREMENT
                );

    return status;
} // NatpExecuteWmiMethod


NTSTATUS
NatpQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
    
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. If the driver can satisfy the query within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the query is satisfied.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    CALLTRACE(( "NatpQueryWmiDataBlock\n" ));
    
    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_WMI_GUID_NOT_FOUND,
                0,
                IO_NO_INCREMENT
                );

    return status;
} // NatpQueryWmiDataBlock



NTSTATUS
NatpQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
    
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose registration info is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. The caller
         does NOT free this buffer.

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL. The caller does NOT free this
        buffer.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/

{    
    PAGED_CODE();

    CALLTRACE(( "NatpQueryWmiRegInfo\n" ));
    
    //
    // Return the registry path for this driver. This is required so WMI
    // can find your driver image and can attribute any eventlog messages to
    // your driver.
    //
    
    *RegistryPath = &NatRegistryPath;

    //
    // Return the name specified in the .rc file of the resource which
    // contains the bianry mof data. By default WMI will look for this
    // resource in the driver image (.sys) file, however if the value
    // MofImagePath is specified in the driver's registry key
    // then WMI will look for the resource in the file specified there.
    //
    
    RtlInitUnicodeString(MofResourceName, IPNATMofResource);

    //
    // Tell WMI to generate instance names off of a static base name
    //
    
    *RegFlags = WMIREG_FLAG_INSTANCE_BASENAME;

    //
    // Set our base instance name. WmiLib will call ExFreePool on the buffer
    // of the string, so we need to allocate it from paged pool.
    //
    
    InstanceName->Length = wcslen( BaseInstanceName ) * sizeof( WCHAR );
    InstanceName->MaximumLength = InstanceName->Length + sizeof( UNICODE_NULL );
    InstanceName->Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            InstanceName->MaximumLength,
                            NAT_TAG_WMI
                            );
    if( NULL != InstanceName->Buffer )
    {
        RtlCopyMemory(
            InstanceName->Buffer,
            BaseInstanceName,
            InstanceName->Length
            );
    }
    else
    {
        ERROR(( "NAT: NatpQueryWmiRegInfo unable to allocate memory\n" ));
        return STATUS_NO_MEMORY;
    }
    
    
    return STATUS_SUCCESS;
} // NatpQueryWmiRegInfo


NTSTATUS
NatpSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
    
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    CALLTRACE(( "NatpSetWmiDataBlock\n" ));

    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_WMI_GUID_NOT_FOUND,
                0,
                IO_NO_INCREMENT
                );

    return status;
} // NatpSetWmiDataBlock



NTSTATUS
NatpSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
    
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being changed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    CALLTRACE(( "NatpSetWmiDataItem\n" ));
    
    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_WMI_GUID_NOT_FOUND,
                0,
                IO_NO_INCREMENT
                );

    return status;
} // NatpSetWmiDataItem


NTSTATUS
NatpWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
    
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it. If the driver can complete enabling/disabling within the callback it
    should call WmiCompleteRequest to complete the irp before returning to
    the caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device object

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PUINT64 Loggerp;
    UINT64 Logger;
    KIRQL Irql;

    PAGED_CODE();

    CALLTRACE(( "NatpWmiFunctionControl\n" ));

    if( WmiEventControl == Function )
    {
        if( GuidIndex < NatWmiGuidCount )
        {
            if( Enable )
            {
                //
                // Get the logger handle from the Irp
                //
                
                IrpSp = IoGetCurrentIrpStackLocation( Irp );

                //
                // The logging handle is in the first UINT64 following the
                // WNODE header.
                //
                
                if( ((PWNODE_HEADER)IrpSp->Parameters.WMI.Buffer)->BufferSize
                     >= sizeof(WNODE_HEADER) + sizeof(UINT64) )
                {
                    Loggerp = (PUINT64) ((PUCHAR)IrpSp->Parameters.WMI.Buffer + sizeof(WNODE_HEADER));
                    Logger = *Loggerp;
                }
                else
                {
                    TRACE(WMI, ("NatpWmiFunctionControl: Wnode too small for logger handle\n"));
                    Logger = 0;
                    Enable = FALSE;
                }
            }
            else
            {
                Logger = 0;
            }

            KeAcquireSpinLock( &NatWmiLock, &Irql );
            
            NatWmiLogHandles[ GuidIndex ] = Logger;
            NatWmiEnabledEvents[ GuidIndex ] = (Enable ? 1 : 0);

            if( NAT_WMI_CONNECTION_CREATION_EVENT == GuidIndex )
            {
                //
                // NAT_WMI_CONNECTION_CREATION_EVENT is the control guid for
                // NAT_WMI_CONNECTION_DELETION_EVENT, so we also need to update
                // that latter's entry
                //

                NatWmiLogHandles[ NAT_WMI_CONNECTION_DELETION_EVENT ] = Logger;
                NatWmiEnabledEvents[ NAT_WMI_CONNECTION_DELETION_EVENT ] =
                    (Enable ? 1 : 0);
            }

            KeReleaseSpinLock( &NatWmiLock, Irql );

            TRACE(
                WMI,
                ("NatpWmiFunctionControl: %s event %i; Logger = 0x%016x\n",
                (Enable ? "Enabled" : "Disabled"), GuidIndex, Logger )); 
        }
        else
        {
            //
            // Invalid guid index.
            //
            
            status = STATUS_WMI_GUID_NOT_FOUND;

            TRACE( WMI, ( "NatpWmiFunctionControl: Invalid WMI guid %i",
                GuidIndex ));
        }
    }
    else
    {
        //
        // We currently don't have any (expensive) data blocks
        //
        
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    status = WmiCompleteRequest(
                DeviceObject,
                Irp,
                status,
                0,
                IO_NO_INCREMENT
                );
                
    return status;
} // NatpWmiFunctionControl



VOID
NatShutdownWMI(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown WMI.
    
Arguments:

    none.

Return Value:

    none.

--*/

{
    NTSTATUS status;

    CALLTRACE(( "NatShutdownWMI\n" ));

    //
    // Deregister w/ WMI
    //

    status = IoWMIRegistrationControl(
                NatDeviceObject,
                WMIREG_ACTION_DEREGISTER
                );

    if( !NT_SUCCESS( status ))
    {
        ERROR(( "Nat: Error shutting down WMI (%08x)\n", status ));
    }

} // NatShutdownWMI

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\pptp.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    pptp.h

Abstract:

    This module contains declarations for the NAT's PPTP-support routines.

Author:

    Abolade Gbadegesin (t-abolag)   18-Aug-1997

Revision History:

--*/


#ifndef _NAT_PPTP_H_
#define _NAT_PPTP_H_

//
// Structure:   NAT_PPTP_MAPPING
//
// This structure stores a mapping created for a PPTP tunnel.
//
// Any PPTP tunnel is uniquely identified by the quadruple
//
//      <PrivateAddress, RemoteAddress, PrivateCallID, RemoteCallID>
//
// We need to ensure that the 'PrivateCallID's are unique for all the machines
// behind the NAT.
//
// Hence, the NAT watches all PPTP control sessions (TCP port 1723), and for
// any PPTP call detected, allocates a call ID to replace the ID chosen by
// the private-network PPTP endpoint.
//
// The allocation is recorded by creating an entry in a list of PPTP mappings,
// which is sorted for outbound-tunnel-message searching on
//
//      <RemoteAddress # PrivateAddress, RemoteCallId>
//
// and sorted for inbound-tunnel-message searching on
//
//      <RemoteAddress # PublicAddress, PublicCallId>.
//
// When a mapping is first created, it is marked half-open and is inserted
// only in the inbound-list, since no remote-call-ID is available to serve
// as the secondary key in the outbound list. Later, when the call-reply
// is received, the mapping is also placed on the outbound list.
//
// Access to the list of PPTP mappings is granted by 'PptpMappingLock'.
//
// N.B. On the rare occasions when 'MappingLock' must be held at the same time
// as one of 'InterfaceLock', 'EditorLock', and 'DirectorLock', 'MappingLock'
// must always be acquired first.
//

typedef struct _NAT_PPTP_MAPPING {
    LIST_ENTRY Link[NatMaximumDirection];
    ULONG64 PrivateKey;
    ULONG64 PublicKey;
    USHORT PrivateCallId;
    USHORT PublicCallId;
    USHORT RemoteCallId;
    ULONG Flags;
    LONG64 LastAccessTime;
} NAT_PPTP_MAPPING, *PNAT_PPTP_MAPPING;

//
// PPTP mapping flags
//

#define NAT_PPTP_FLAG_HALF_OPEN     0x00000001
#define NAT_PPTP_FLAG_DISCONNECTED  0x00000002

#define NAT_PPTP_HALF_OPEN(m) \
    ((m)->Flags & NAT_PPTP_FLAG_HALF_OPEN)

#define NAT_PPTP_DISCONNECTED(m) \
    ((m)->Flags & NAT_PPTP_FLAG_DISCONNECTED)

//
// PPTP key-manipulation macros
//

#define MAKE_PPTP_KEY(RemoteAddress,OtherAddress) \
    ((ULONG)(RemoteAddress) | ((ULONG64)((ULONG)(OtherAddress)) << 32))

#define PPTP_KEY_REMOTE(Key)        ((ULONG)(Key))
#define PPTP_KEY_PRIVATE(Key)       ((ULONG)((Key) >> 32))
#define PPTP_KEY_PUBLIC(Key)        ((ULONG)((Key) >> 32))

//
// PPTP mapping allocation macros
//

#define ALLOCATE_PPTP_BLOCK() \
    ExAllocateFromNPagedLookasideList(&PptpLookasideList)

#define FREE_PPTP_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&PptpLookasideList,(Block))

//
// Define the depth of the lookaside list for allocating PPTP mappings
//

#define PPTP_LOOKASIDE_DEPTH        10


//
// Global data declarations
//

extern NPAGED_LOOKASIDE_LIST PptpLookasideList;
extern LIST_ENTRY PptpMappingList[NatMaximumDirection];
extern KSPIN_LOCK PptpMappingLock;
extern IP_NAT_REGISTER_EDITOR PptpRegisterEditorClient;
extern IP_NAT_REGISTER_EDITOR PptpRegisterEditorServer;


//
// PPTP mapping management routines
//

NTSTATUS
NatAllocatePublicPptpCallId(
    ULONG64 PublicKey,
    PUSHORT CallIdp,
    PLIST_ENTRY *InsertionPoint OPTIONAL
    );

NTSTATUS
NatCreatePptpMapping(
    ULONG RemoteAddress,
    ULONG PrivateAddress,
    USHORT PrivateCallId,
    ULONG PublicAddress,
    PUSHORT CallIdp,
    IP_NAT_DIRECTION Direction,
    PNAT_PPTP_MAPPING* MappingCreated
    );

NTSTATUS
NatInitializePptpManagement(
    VOID
    );

PNAT_PPTP_MAPPING
NatLookupInboundPptpMapping(
    ULONG64 PublicKey,
    USHORT PrivateCallId,
    PLIST_ENTRY* InsertionPoint
    );

PNAT_PPTP_MAPPING
NatLookupOutboundPptpMapping(
    ULONG64 PrivateKey,
    USHORT RemoteCallId,
    PLIST_ENTRY* InsertionPoint
    );

VOID
NatShutdownPptpManagement(
    VOID
    );


//
// PPTP control-connection editor routines
//

NTSTATUS
NatClientToServerDataHandlerPptp(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID ReceiveBuffer,
    IN ULONG DataOffset,
    IN IP_NAT_DIRECTION Direction
    );

NTSTATUS
NatDeleteHandlerPptp(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext
    );

NTSTATUS
NatInboundDataHandlerPptpClient(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

NTSTATUS
NatInboundDataHandlerPptpServer(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

NTSTATUS
NatOutboundDataHandlerPptpClient(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

NTSTATUS
NatOutboundDataHandlerPptpServer(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    );

NTSTATUS
NatServerToClientDataHandlerPptp(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID ReceiveBuffer,
    IN ULONG DataOffset,
    IN IP_NAT_DIRECTION Direction
    );

XLATE_IP_ROUTINE(NatTranslatePptp)

#endif // _NAT_PPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\prot.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

File:

    prot.h

Abstract:

    This module contains Internet protocol-related declarations.

Author:

    Abolade Gbadegesin (t-abolag)   21-July-1997

Revision History:

--*/


#ifndef _NAT_PROT_H_
#define _NAT_PROT_H_


//
// NBT constants
//

#define NBT_DATAGRAM_PORT           138
#define NBT_NAME_LENGTH             34
#define NBT_MESSAGE_DIRECT_UNIQUE   0x10
#define NBT_MESSAGE_DIRECT_GROUP    0x11
#define NBT_FLAG_FIRST_FRAGMENT     0x02


//
// PPTP constants
//

#define PPTP_CONTROL_PORT           1723
#define PPTP_GRE_PROTOCOL           0x880B

//
// IPSec constants
//

#define IPSEC_ISAKMP_PORT           500

//
// DHCP constants
//

#define DHCP_SERVER_PORT            67
#define DHCP_CLIENT_PORT            68

//
// ICMP message-type constants
//

#define ICMP_ECHO_REPLY             0
#define ICMP_DEST_UNREACH           3
#define ICMP_SOURCE_QUENCH          4
#define ICMP_REDIRECT               5
#define ICMP_ECHO_REQUEST           8
#define ICMP_ROUTER_REPLY           9
#define ICMP_ROUTER_REQUEST         10
#define ICMP_TIME_EXCEED            11
#define ICMP_PARAM_PROBLEM          12
#define ICMP_TIMESTAMP_REQUEST      13
#define ICMP_TIMESTAMP_REPLY        14
#define ICMP_MASK_REQUEST           17
#define ICMP_MASK_REPLY             18

//
// ICMP message-code constants
//

#define ICMP_CODE_NET_UNREACH       0
#define ICMP_CODE_HOST_UNREACH      1
#define ICMP_CODE_PROTOCOL_UNREACH  2
#define ICMP_CODE_PORT_UNREACH      3
#define ICMP_CODE_FRAG_NEEDED       4
#define ICMP_SOURCE_ROUTE_FAILED    5

//
// Macro for extracting the data-offset from the field IPHeader.verlen
//

#define IP_DATA_OFFSET(h) \
    ((ULONG)((((PIP_HEADER)(h))->VersionAndHeaderLength & 0x0F) << 2))

//
// Mask for extracting the fragment-offset from the IPHeader structure's
// combined flags/fragment-offset field
//

#define IP_FRAGMENT_OFFSET_MASK     ~0x00E0

//
// Value of the Don't Fragment bit w/in the IPHeader structure's combined
// flags/fragment-offset field.
//

#define IP_DF_FLAG                  0x0040

//
// Macro for extracting the data-offset from the field TCP_HEADER.OffsetAndFlags
// The offset is in 32-bit words, so shifting by 2 gives the value in bytes.
//

#define TCP_DATA_OFFSET(h)          (((h)->OffsetAndFlags & 0x00F0) >> 2)

//
// Masks for extracting flags from the field TCP_HEADER.OffsetAndFlags
//

#define TCP_FLAG_FIN                0x0100
#define TCP_FLAG_SYN                0x0200
#define TCP_FLAG_RST                0x0400
#define TCP_FLAG_PSH                0x0800
#define TCP_FLAG_ACK                0x1000
#define TCP_FLAG_URG                0x2000

#define TCP_FLAG(h,f)               ((h)->OffsetAndFlags & TCP_FLAG_ ## f)
#define TCP_ALL_FLAGS(h)            ((h)->OffsetAndFlags & 0x3f00)
#define TCP_RESERVED_BITS(h)        ((h)->OffsetAndFlags & 0xc00f)

//
// TCP Option Opcodes
//

#define TCP_OPTION_ENDOFOPTIONS     ( 0 )
#define TCP_OPTION_NOP              ( 1 )
#define	TCP_OPTION_MSS   	    ( 2 )
#define	TCP_OPTION_WSCALE	    ( 3 )
#define	TCP_OPTION_SACK_PERMITTED   ( 4 )
#define	TCP_OPTION_SACK	            ( 5 )
#define	TCP_OPTION_TIMESTAMPS	    ( 8 )

//
// Length Definitions for TCP Options
//

#define MSS_OPTION_SIZE             ( 4 )
#define WS_OPTION_SIZE              ( 3 )
#define TS_OPTION_SIZE              ( 10 )
#define SP_OPTION_SIZE              ( 2 )

//
// Maximum MSS value based on the MTU of the sending interface
//
#define MAX_MSSOPTION(m) ((m)>0 ? (m) - sizeof(TCP_HEADER) - sizeof(IP_HEADER):0)

#include <packon.h>

typedef struct _IP_HEADER {
    UCHAR VersionAndHeaderLength;
    UCHAR TypeOfService;
    USHORT TotalLength;
    USHORT Identification;
    USHORT OffsetAndFlags;
    UCHAR TimeToLive;
    UCHAR Protocol;
    USHORT Checksum;
    ULONG SourceAddress;
    ULONG DestinationAddress;
} IP_HEADER, *PIP_HEADER;


typedef struct _TCP_HEADER {
    USHORT SourcePort;
    USHORT DestinationPort;
    ULONG SequenceNumber;
    ULONG AckNumber;
    USHORT OffsetAndFlags;
    USHORT WindowSize;
    USHORT Checksum;
    USHORT UrgentPointer;
} TCP_HEADER, *PTCP_HEADER;

typedef struct _TCP_MSS_OPTION {
    BYTE OptionType;
    BYTE OptionLen;
    USHORT MSSValue;
} MSSOption, *PMSSOption;

typedef struct _UDP_HEADER {
    USHORT SourcePort;
    USHORT DestinationPort;
    USHORT Length;
    USHORT Checksum;
} UDP_HEADER, *PUDP_HEADER;


typedef struct _ICMP_HEADER {
    UCHAR Type;
    UCHAR Code;
    USHORT Checksum;
    USHORT Identifier;                  // valid only for ICMP request/reply
    USHORT SequenceNumber;              // valid only for ICMP request/reply
    IP_HEADER EncapsulatedIpHeader;     // valid only for ICMP errors
    union {
        struct _ENCAPSULATED_TCP_HEADER {
            USHORT SourcePort;
            USHORT DestinationPort;
            ULONG SequenceNumber;
        } EncapsulatedTcpHeader;
        struct _ENCAPSULATED_UDP_HEADER {
            USHORT SourcePort;
            USHORT DestinationPort;
            USHORT Length;
            USHORT Checksum;
        } EncapsulatedUdpHeader;
        struct _ENCAPSULATED_ICMP_HEADER {
            UCHAR Type;
            UCHAR Code;
            USHORT Checksum;
            USHORT Identifier;
            USHORT SequenceNumber;
        } EncapsulatedIcmpHeader;
    };
} ICMP_HEADER, *PICMP_HEADER;


typedef struct _PPTP_HEADER {
    USHORT PacketLength;
    USHORT PacketType;
    ULONG MagicCookie;
    USHORT MessageType;
    USHORT Reserved;
    USHORT CallId;                      // may be sender ID or peer ID
    USHORT PeerCallId;
} PPTP_HEADER, *PPPTP_HEADER;

#define PPTP_MAGIC_COOKIE               0x4D3C2B1A // network byte order

#define PPTP_OUTGOING_CALL_REQUEST      7
#define PPTP_OUTGOING_CALL_REPLY        8
#define PPTP_INCOMING_CALL_REQUEST      9
#define PPTP_INCOMING_CALL_REPLY        10
#define PPTP_INCOMING_CALL_CONNECTED    11
#define PPTP_CALL_CLEAR_REQUEST         12
#define PPTP_CALL_DISCONNECT_NOTIFY     13
#define PPTP_WAN_ERROR_NOTIFY           14
#define PPTP_SET_LINK_INFO              15


typedef struct _GRE_HEADER {
    USHORT FlagsAndVersion;
    USHORT ProtocolType;
    USHORT PayloadLength;
    USHORT CallId;
    ULONG SequenceNumber;
    ULONG AckNumber;
} GRE_HEADER, *PGRE_HEADER;



typedef struct _NBT_HEADER {
    UCHAR MessageType;
    UCHAR Flags;
    USHORT DatagramId;
    ULONG SourceAddress;
    USHORT SourcePort;
    USHORT DatagramLength;
    USHORT PacketOffset;
    UCHAR SourceName[NBT_NAME_LENGTH];
    UCHAR DestinationName[NBT_NAME_LENGTH];
} NBT_HEADER, *PNBT_HEADER;


#include <packoff.h>


//
// IP address class-mask definitions
//

#define CLASS_MASK_A        0x000000ff
#define CLASS_MASK_B        0x0000ffff
#define CLASS_MASK_C        0x00ffffff
#define CLASS_MASK_D        0x000000e0
#define CLASS_MASK_E        0xffffffff

#define ADDRESS_CLASS_A(a)  (((*((PBYTE)&(a))) & 0x80) == 0)
#define ADDRESS_CLASS_B(a)  (((*((PBYTE)&(a))) & 0xc0) == 0x80)
#define ADDRESS_CLASS_C(a)  (((*((PBYTE)&(a))) & 0xe0) == 0xc0)
#define ADDRESS_CLASS_D(a)  (((*((PBYTE)&(a))) & 0xf0) == 0xe0)
#define ADDRESS_CLASS_E(a)  ((((*((PBYTE)&(a)))& 0xf0) == 0xf0) &&  \
                             ((a) != 0xffffffff))

#define GET_CLASS_MASK(a) \
    (ADDRESS_CLASS_A(a) ? CLASS_MASK_A: \
    (ADDRESS_CLASS_B(a) ? CLASS_MASK_B: \
    (ADDRESS_CLASS_C(a) ? CLASS_MASK_C : \
    (ADDRESS_CLASS_D(a) ? CLASS_MASK_D : CLASS_MASK_E))))

#endif // _NAT_PROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\raw.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    raw.c

Abstract:

    This module contains the code for manipulating IP mappings.
    When the NAT decides to translate an IP packet for an unrecognized protocol
    it creates a mapping and places it on the interface's IP-mapping list,
    so that if a reply to the packet arrives, it can be directed to the
    appropriate client.

Author:

    Abolade Gbadegesin (aboladeg)   18-Apr-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   18-Apr-1998

    Based on icmp.c.

--*/

#include "precomp.h"
#pragma hdrstop

//
// GLOBAL DATA DECLARATIONS
//

NPAGED_LOOKASIDE_LIST IpLookasideList;
LIST_ENTRY IpMappingList[NatMaximumDirection];
KSPIN_LOCK IpMappingLock;


NTSTATUS
NatCreateIpMapping(
    PNAT_INTERFACE Interfacep,
    ULONG RemoteAddress,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    UCHAR Protocol,
    PLIST_ENTRY InboundInsertionPoint,
    PLIST_ENTRY OutboundInsertionPoint,
    PNAT_IP_MAPPING* MappingCreated
    )

/*++

Routine Description:

    Called to create, initialize, and insert an IP mapping in an interface's
    list of IP mappings.

Arguments:

    Interfacep - the interface for the new mapping

    RemoteAddress - the address of the remote endpoint

    PrivateAddress - the address of the machine on the private network

    PublicAddress - the publicly-visible address to replace 'PrivateAddress';
        in case this is 0, an address is chosen in this routine.

    Protocol - the protocol field of the IP header

    InboundInsertionPoint - the entry preceding the new mapping in the list
        sorted for inbound searching

    OutboundInsertionPoint - the entry preceding the new mapping in the list
        sorted for outbound searching

    MappingCreated - receives the mapping created

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    Invoked with 'IpMappingLock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    PNAT_IP_MAPPING Mapping;
    NTSTATUS status;
    PNAT_IP_MAPPING Temp;
    PNAT_USED_ADDRESS UsedAddress;


    CALLTRACE(("NatCreateIpMapping\n"));

    //
    // Allocate a new mapping
    //

    Mapping = ALLOCATE_IP_BLOCK();
    if (!Mapping) {
        ERROR(("NatCreateIpMapping: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the mapping
    //

    Mapping->PrivateKey = MAKE_IP_KEY(RemoteAddress, PrivateAddress);
    Mapping->Protocol = Protocol;

    //
    // See if the public address is specified, and if not, acquire an address
    //

    if (!PublicAddress) {

        //
        // Acquire an address mapping for the IP mapping;
        //

        KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
        status =
            NatAcquireFromAddressPool(
                Interfacep,
                PrivateAddress,
                0,
                &UsedAddress
                );

        if (!NT_SUCCESS(status)) {
            KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
            TRACE(IP, ("NatCreateIpMapping: no address available\n"));
            FREE_IP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }

        PublicAddress = UsedAddress->PublicAddress;
        NatDereferenceAddressPoolEntry(Interfacep, UsedAddress);
        KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
    }

    Mapping->PublicKey = MAKE_IP_KEY(RemoteAddress, PublicAddress);

    TRACE(
        MAPPING,
        ("NatCreateIpMapping: Ip=%d:%016I64X:%016I64X\n",
        Mapping->Protocol, Mapping->PrivateKey, Mapping->PublicKey
        ));

    //
    // Insert the mapping in the inbound list
    //

    if (!InboundInsertionPoint) {
        Temp =
            NatLookupInboundIpMapping(
                Mapping->PrivateKey,
                Protocol,
                &InboundInsertionPoint
                );
        if (Temp) {
            TRACE(IP, ("NatCreateIpMapping: duplicated inbound mapping\n"));
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Insert the mapping in the outbound list
    //

    if (!OutboundInsertionPoint) {
        Temp =
            NatLookupOutboundIpMapping(
                Mapping->PublicKey,
                Protocol,
                &OutboundInsertionPoint
                );
        if (Temp) {
            TRACE(IP, ("NatCreateIpMapping: duplicated outbound mapping\n"));
            return STATUS_UNSUCCESSFUL;
        }
    }

    InsertTailList(InboundInsertionPoint, &Mapping->Link[NatInboundDirection]);
    InsertTailList(OutboundInsertionPoint, &Mapping->Link[NatOutboundDirection]);

    *MappingCreated = Mapping;
    return STATUS_SUCCESS;

} // NatCreateIpMapping


VOID
NatInitializeRawIpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the raw IP-layer translation module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    KeInitializeSpinLock(&IpMappingLock);
    InitializeListHead(&IpMappingList[NatInboundDirection]);
    InitializeListHead(&IpMappingList[NatOutboundDirection]);
    ExInitializeNPagedLookasideList(
        &IpLookasideList,
        NatAllocateFunction,
        NULL,
        0,
        sizeof(NAT_IP_MAPPING),
        NAT_TAG_IP,
        IP_LOOKASIDE_DEPTH
        );
} // NatInitializeRawIpManagement


PNAT_IP_MAPPING
NatLookupInboundIpMapping(
    ULONG64 PublicKey,
    UCHAR Protocol,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to find an IP mapping using the remote-address
    and the publicly-visible address, which correspond to the 'PublicKey',
    and the 'Protocol' field.

Arguments:

    PublicKey - the remote-address/public-address combination

    Protocol - the IP protocol of the mapping to be found

    InsertionPoint - receives the insertion-point if the mapping is not found.

Return Value:

    PNAT_IP_MAPPING - the mapping found, or NULL if not found.

--*/

{
    PLIST_ENTRY Link;
    PNAT_IP_MAPPING Mapping;

    CALLTRACE(("NatLookupInboundIpMapping\n"));

    if (InsertionPoint) { *InsertionPoint = NULL; }

    for (Link = IpMappingList[NatInboundDirection].Flink;
         Link != &IpMappingList[NatInboundDirection]; Link = Link->Flink) {

        Mapping =
            CONTAINING_RECORD(
                Link, NAT_IP_MAPPING, Link[NatInboundDirection]
                );

        if (PublicKey > Mapping->PublicKey) {
            continue;
        } else if (PublicKey < Mapping->PublicKey) {
            break;
        }

        //
        // Primary keys equal; check secondary keys.
        //

        if (Protocol > Mapping->Protocol) {
            continue;
        } else if (Protocol < Mapping->Protocol) {
            break;
        }

        //
        // Secondary keys equal, too. This is the requested item.
        //

        return Mapping;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupInboundIpMapping


PNAT_IP_MAPPING
NatLookupOutboundIpMapping(
    ULONG64 PrivateKey,
    UCHAR Protocol,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to find an IP mapping using the remote-address
    and the private address, which correspond to the 'PrivateKey'.

Arguments:

    PrivateKey - the remote-address/private-address combination

    Protocol - the IP protocol of the mapping to be found

    InsertionPoint - receives insertion-point if mapping not found.

Return Value:

    PNAT_IP_MAPPING - the mapping found, or NULL if not found.

--*/

{
    PLIST_ENTRY         Link;
    PNAT_IP_MAPPING   Mapping;

    CALLTRACE(("NatLookupOutboundIpMapping\n"));

    if (InsertionPoint) { *InsertionPoint = NULL; }

    for (Link = IpMappingList[NatOutboundDirection].Flink;
         Link != &IpMappingList[NatOutboundDirection]; Link = Link->Flink) {

        Mapping =
            CONTAINING_RECORD(
                Link, NAT_IP_MAPPING, Link[NatOutboundDirection]
                );

        if (PrivateKey > Mapping->PrivateKey) {
            continue;
        } else if (PrivateKey < Mapping->PrivateKey) {
            break;
        }

        //
        // Primary keys equal; check secondary keys.
        //

        if (Protocol > Mapping->Protocol) {
            continue;
        } else if (Protocol < Mapping->Protocol) {
            break;
        }

        //
        // Keys are equal, so we've found it.
        //

        return Mapping;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupOutboundIpMapping


VOID
NatShutdownRawIpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to clean up the raw IP-layer translation module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ExDeleteNPagedLookasideList(&IpLookasideList);
} // NatShutdownRawIpManagement


FORWARD_ACTION
NatTranslateIp(
    PNAT_INTERFACE Interfacep,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )

/*++

Routine Description:

    This routine is called to translate a IP data packet.

Arguments:

    Interfacep - the boundary interface over which to translate.

    Direction - the direction in which the packet is traveling

    Contextp - initialized with context-information for the packet

    InReceiveBuffer - input buffer-chain

    OutReceiveBuffer - receives modified buffer-chain.

Return Value:

    FORWARD_ACTION - indicates action to take on the packet.

Environment:

    Invoked with a reference made to 'Interfacep' by the caller.

--*/

{
    ULONG Checksum;
    ULONG ChecksumDelta = 0;
    PIP_HEADER IpHeader;
    PNAT_IP_MAPPING Mapping;
    ULONG64 PrivateKey;
    ULONG64 PublicKey;
    BOOLEAN FirewallMode;

    TRACE(XLATE, ("NatTranslateIp\n"));

    FirewallMode = Interfacep && NAT_INTERFACE_FW(Interfacep);

    IpHeader = Contextp->Header;

    if (Direction == NatInboundDirection) {

        //
        // Look for the IP mapping for the data packet
        //

        PublicKey =
            MAKE_IP_KEY(
                Contextp->SourceAddress,
                Contextp->DestinationAddress
                );
        KeAcquireSpinLockAtDpcLevel(&IpMappingLock);
        Mapping =
            NatLookupInboundIpMapping(
                PublicKey,
                IpHeader->Protocol,
                NULL
                );
        if (!Mapping) {
            KeReleaseSpinLockFromDpcLevel(&IpMappingLock);
            return
                ((*Contextp->DestinationType < DEST_REMOTE) && !FirewallMode
                    ? FORWARD : DROP);
        }

        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->DestinationAddress);
        IpHeader->DestinationAddress = IP_KEY_PRIVATE(Mapping->PrivateKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->DestinationAddress);

        CHECKSUM_UPDATE(IpHeader->Checksum);
    } else {

        //
        // Look for the IP mapping for the data packet
        //

        PrivateKey =
            MAKE_IP_KEY(
                Contextp->DestinationAddress,
                Contextp->SourceAddress
                );
        KeAcquireSpinLockAtDpcLevel(&IpMappingLock);
        Mapping =
            NatLookupOutboundIpMapping(
                PrivateKey,
                IpHeader->Protocol,
                NULL
                );
        if (!Mapping) {
            KeReleaseSpinLockFromDpcLevel(&IpMappingLock);
            return DROP;
        }

        CHECKSUM_LONG(ChecksumDelta, ~IpHeader->SourceAddress);
        IpHeader->SourceAddress = IP_KEY_PUBLIC(Mapping->PublicKey);
        CHECKSUM_LONG(ChecksumDelta, IpHeader->SourceAddress);

        CHECKSUM_UPDATE(IpHeader->Checksum);
    }

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&IpMappingLock);
    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NatTranslateIp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\notify.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    notify.h

Abstract:

    This module contains declarations for the NAT's notification handling.
    The user-mode may queue notification buffers to the NAT to be completed
    upon occurrence of a specific event. For instance, a route-failure buffer
    is queued so that when an unroutable packet is seen, its destination is
    written into the first available buffer and the route-failure IRP
    is completed.

Author:

    Abolade Gbadegesin  (aboladeg)  July-26-1998

Revision History:
    
--*/

#ifndef _NAT_NOTIFY_H_
#define _NAT_NOTIFY_H_

VOID
NatCleanupAnyAssociatedNotification(
    PFILE_OBJECT FileObject
    );

VOID
NatInitializeNotificationManagement(
    VOID
    );

NTSTATUS
NatRequestNotification(
    PIP_NAT_REQUEST_NOTIFICATION RequestNotification,
    PIRP Irp,
    PFILE_OBJECT FileObject
    );

VOID
NatSendRoutingFailureNotification(
    ULONG DestinationAddress,
    ULONG SourceAddress
    );

VOID
NatShutdownNotificationManagement(
    VOID
    );

#endif // _NAT_NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\precomp.h ===
#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <cxport.h>
#include <ip.h>         // for IPRcvBuf
#include <ipinfo.h>     // for route-lookup defs
#include <ntddip.h>     // for \Device\Ip I/O control codes
#include <ntddtcp.h>    // for \Device\Tcp I/O control codes
#include <ipfltinf.h>   // for firewall defs
#include <ipfilter.h>   // for firewall defs
#include <tcpinfo.h>    // for TCP_CONN_*
#include <tdiinfo.h>    // for CONTEXT_SIZE, TDIObjectID
#include <tdistat.h>    // for TDI status codes
#include <llinfo.h>  // for interface MTU

#include <iputils.h>
#include <windef.h>
#include <routprot.h>
#include <ipnat.h>

// WMI and event tracing definitions
#if NAT_WMI
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>
#include <evntrace.h>
#endif

#include "prot.h"
#include "resource.h"
#include "sort.h"
#include "cache.h"
#include "compref.h"
#include "entry.h"
#include "pool.h"
#include "xlate.h"
#include "editor.h"
#include "director.h"
#include "notify.h"
#include "mapping.h"
#include "if.h"
#include "dispatch.h"
#include "timer.h"
#include "icmp.h"
#include "raw.h"
#include "pptp.h"
#include "ticket.h"
#include "edithlp.h"
#include "rhizome.h"
#include "redirect.h"

#if NAT_WMI
#include "natschma.h"
#include "natwmi.h"
#endif

#include "debug.h"

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation,
    IN BOOLEAN Quota
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\pool.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    pool.h

Abstract:

    This header contains declarations for the management of the NAT's pools
    of addresses and ports.

Author:

    Abolade Gbadegesin (t-abolag)   12-July-1997

Revision History:

--*/

#ifndef _NAT_POOL_H_
#define _NAT_POOL_H_

//
// forward declaration
//

struct _NAT_INTERFACE;
#define PNAT_INTERFACE      struct _NAT_INTERFACE*

//
// Structure:   NAT_FREE_ADDRESS
//
// Represents a range of free addresses
// Each interface with address-ranges holds an array of this structure,
// which keep track of which addresses are in use and which are free.
//

typedef struct _NAT_FREE_ADDRESS {

    ULONG StartAddress;
    ULONG EndAddress;
    ULONG SubnetMask;
    PRTL_BITMAP Bitmap;

} NAT_FREE_ADDRESS, *PNAT_FREE_ADDRESS;

//
// Structure:   NAT_USED_ADDRESS
//
// Represents an address which is in use.
//
// Each address is an entry on its interface's list of in-use addresses
// from the address pool. In addition to the address pool, entries are made
// for each binding on the interface (i.e. each local address). 
//
// Each address is also included in the interface's splay tree of addresses,
// sorted on 'PrivateAddress'.
//
// Any address which is mapped statically to a private-address will have 
// the flag NAT_POOL_FLAG_STATIC set, and the field 'Mapping' will point
// to the entry in the interface's configuration for the static address-mapping.
//
// When a session cannot be assigned a unique address, an in-use address
// may be used for the session if the interface has port-translation enabled.
// In this event, the field 'ReferenceCount' is incremented.
//
// Each in-use address is initialized with ranges for free UDP and TCP ports
// (stored in network order). NextPortToTry is used to keep track of where
// to start the search for an unconflicting port the next time an allocation
// is requested; this is also in network order.
//

typedef struct _NAT_USED_ADDRESS {

    RTL_SPLAY_LINKS SLink;
    LIST_ENTRY Link;
    ULONG64 Key;
    ULONG PrivateAddress;
    ULONG PublicAddress;
    struct _NAT_USED_ADDRESS* SharedAddress;
    PIP_NAT_ADDRESS_MAPPING AddressMapping;
    ULONG Flags;
    ULONG ReferenceCount;
    USHORT StartPort;
    USHORT EndPort;
    USHORT NextPortToTry;

} NAT_USED_ADDRESS, *PNAT_USED_ADDRESS;

#define MAKE_USED_ADDRESS_KEY(priv,pub) \
    ((ULONG64)(((ULONG64)(priv) << 32) | (ULONG)(pub)))

//
// Used-list entry is deleted
//
#define NAT_POOL_FLAG_DELETED           0x80000000
#define NAT_POOL_DELETED(a) \
    ((a)->Flags & NAT_POOL_FLAG_DELETED)

//
// Used-list entry is for a static mapping
//
#define NAT_POOL_FLAG_STATIC            0x00000001
#define NAT_POOL_STATIC(a) \
    ((a)->Flags & NAT_POOL_FLAG_STATIC)

//
// Used-list entry is for an interface's binding (i.e. local address)
//
#define NAT_POOL_FLAG_BINDING           0x00000008
#define NAT_POOL_BINDING(a) \
    ((a)->Flags & NAT_POOL_FLAG_BINDING)

//
// Used-list entry is a placeholder for a shared address
//
#define NAT_POOL_FLAG_PLACEHOLDER       0x00000010
#define NAT_POOL_PLACEHOLDER(a) \
    ((a)->Flags & NAT_POOL_FLAG_PLACEHOLDER)

//
// Macro for obtaining a placeholder's shared-address
//

#define PLACEHOLDER_TO_ADDRESS(a) \
    ((a) = NAT_POOL_PLACEHOLDER(a) ? (a)->SharedAddress : (a))


//
// POOL MANAGEMENT ROUTINES
//

NTSTATUS
NatAcquireEndpointFromAddressPool(
    PNAT_INTERFACE Interfacep,
    ULONG64 PrivateKey,
    ULONG64 RemoteKey,
    ULONG PublicAddress,
    USHORT PreferredPort,
    BOOLEAN AllowAnyPort,
    PNAT_USED_ADDRESS* AddressAcquired,
    PUSHORT PortAcquired
    );

NTSTATUS
NatAcquireFromAddressPool(
    PNAT_INTERFACE Interfacep,
    ULONG PrivateAddress,
    ULONG PublicAddress OPTIONAL,
    PNAT_USED_ADDRESS* AddressAcquired
    );

NTSTATUS
NatAcquireFromPortPool(
    PNAT_INTERFACE Interfacep,
    PNAT_USED_ADDRESS Addressp,
    UCHAR Protocol,
    USHORT PreferredPort,
    PUSHORT PortAcquired
    );

NTSTATUS
NatCreateAddressPool(
    PNAT_INTERFACE Interfacep
    );

NTSTATUS
NatCreateStaticPortMapping(
    PNAT_INTERFACE Interfacep,
    PIP_NAT_PORT_MAPPING PortMapping
    );

NTSTATUS
NatDeleteAddressPool(
    PNAT_INTERFACE Interfacep
    );

NTSTATUS
NatDereferenceAddressPoolEntry(
    PNAT_INTERFACE Interfacep,
    PNAT_USED_ADDRESS AddressToRelease
    );

PNAT_USED_ADDRESS
NatLookupAddressPoolEntry(
    PNAT_USED_ADDRESS Root,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    PNAT_USED_ADDRESS* InsertionPoint
    );

PNAT_USED_ADDRESS
NatLookupStaticAddressPoolEntry(
    PNAT_INTERFACE Interfacep,
    ULONG PublicAddress,
    BOOLEAN RequireInboundSessions
    );

//
//  VOID
//  NatReferenceAddressPoolEntry(
//      PNAT_USED_ADDRESS Addressp
//      );
//

#define \
NatReferenceAddressPoolEntry( \
    _Addressp \
    ) \
    (NAT_INTERFACE_DELETED(_Addressp) \
        ? FALSE \
        : (InterlockedIncrement(&(_Addressp)->ReferenceCount), TRUE))

#undef PNAT_INTERFACE

#endif // _NAT_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\pool.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    pool.c

Abstract:

    This module contains code for managing the NAT's pool of addresses
    as well as its ranges of ports.

Author:

    Abolade Gbadegesin (t-abolag)   13-July-1997

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


#define IP_NAT_MAX_ADDRESS_RANGE    (1<<16)
#define IP_NAT_MAX_CLIENT_COUNT     (5+2)

//
// Macro used to avoid the fact that RtlInitializeBitMap is pageable
// and hence cannot be called at DPC-level
//

#define INITIALIZE_BITMAP(BMH,B,S) \
    ((BMH)->Buffer = (B), (BMH)->SizeOfBitMap = (S))

//
// FORWARD DECLARATIONS
//

NTSTATUS
NatCreateAddressPoolEntry(
    PNAT_INTERFACE Interfacep,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    DWORD InitialFlags,
    PNAT_USED_ADDRESS* InsertionPoint,
    PNAT_USED_ADDRESS* AddressCreated
    );

PNAT_USED_ADDRESS
NatInsertAddressPoolEntry(
    PNAT_USED_ADDRESS Parent,
    PNAT_USED_ADDRESS Addressp
    );


//
// ADDRESS-POOL ROUTINES (alphabetically)
//

NTSTATUS
NatAcquireFromAddressPool(
    PNAT_INTERFACE Interfacep,
    ULONG PrivateAddress,
    ULONG PublicAddress OPTIONAL,
    PNAT_USED_ADDRESS* AddressAcquired
    )

/*++

Routine Description:

    This routine acquires an address from an address pool.
    It initializes the address's port-pool.

Arguments:

    Interfacep - interface on which to acquire an address.

    PrivateAddress - private address for whom to acquire a public address

    PublicAddress - optionally specifies the public-address to be acquired

    AddressAcquired - receives a pointer to the address acquired.

Return Value:

    NTSTATUS - status code.

--*/

{
    ULONG ClientCount;
    PNAT_USED_ADDRESS InsertionPoint;
    PLIST_ENTRY Link;
    PNAT_USED_ADDRESS Sharedp;
    NTSTATUS status;
    PNAT_USED_ADDRESS Usedp;

    CALLTRACE(("NatAcquireFromAddressPool\n"));

    *AddressAcquired = NULL;

    TRACE(
        POOL, ("NatAcquireFromAddressPool: acquiring for %d.%d.%d.%d\n",
        ADDRESS_BYTES(PrivateAddress)
        ));

    //
    // See if the requesting private address already has a public address
    //

    for (Link = Interfacep->UsedAddressList.Flink, ClientCount = 0;
         Link != &Interfacep->UsedAddressList;
         Link = Link->Flink, ClientCount++) {
        Usedp = CONTAINING_RECORD(Link, NAT_USED_ADDRESS, Link);
        if (Usedp->PrivateAddress == PrivateAddress &&
            (!PublicAddress || Usedp->PublicAddress == PublicAddress)) {
            break;
        }
    }

    if (Link != &Interfacep->UsedAddressList) {
        NatReferenceAddressPoolEntry(Usedp);
        *AddressAcquired = Usedp;
        return STATUS_SUCCESS;
    } else if (ClientCount > IP_NAT_MAX_CLIENT_COUNT &&
               SharedUserData->NtProductType == NtProductWinNt) {
#if 0
        TRACE(
            POOL, ("NatAcquireFromAddressPool: quota exceeded (%d clients)\n",
            ClientCount
            ));
        return STATUS_LICENSE_QUOTA_EXCEEDED;
#endif
    }



    //
    // Create a new entry, inserting it in the list and tree
    //

    status =
        NatCreateAddressPoolEntry(
            Interfacep,
            PrivateAddress,
            PublicAddress,
            0,
            NULL,
            AddressAcquired
            );

    if (NT_SUCCESS(status)) { return STATUS_SUCCESS; }

    TRACE(POOL, ("NatAcquireFromAddressPool: no free addresses\n"));

    //
    // No entry was available;
    // if the caller specified a specific address
    // or if the interface has port-translation disabled,
    // this is a total failure.
    // Otherwise, we can try to find an address which we can share.
    //

    if (PublicAddress || !NAT_INTERFACE_NAPT(Interfacep)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Look for an address which can be shared
    //

    for (Link = Interfacep->UsedAddressList.Flink;
         Link != &Interfacep->UsedAddressList; Link = Link->Flink) {

        Usedp = CONTAINING_RECORD(Link, NAT_USED_ADDRESS, Link);

        //
        // We cannot reuse statically mapped addresses,
        // and we ignore placeholders while searching.
        //

        if (NAT_POOL_STATIC(Usedp) || NAT_POOL_PLACEHOLDER(Usedp)) { continue; }

        //
        // We cannot reuse an entry which would result in our tree
        // containing duplicate keys.
        //

        if (NatLookupAddressPoolEntry(
                Interfacep->UsedAddressTree,
                PrivateAddress,
                Usedp->PublicAddress,
                &InsertionPoint
                )) { continue; }

        break;
    }

    if (Link == &Interfacep->UsedAddressList) { return STATUS_UNSUCCESSFUL; }

    //
    // Reuse the used-address;
    // If it is referenced, we're sharing it.
    //

    TRACE(
        POOL, ("NatAcquireFromAddressPool: reusing %d.%d.%d.%d\n",
        ADDRESS_BYTES(Usedp->PublicAddress)
        ));

    //
    // Allocate and initialize a placeholder which we can find
    // by searching on 'PrivateAddress'
    //

    Sharedp =
        ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(NAT_USED_ADDRESS),
            NAT_TAG_USED_ADDRESS
            );

    if (!Sharedp) {
        ERROR(("NatAcquireFromAddressPool: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(Sharedp, sizeof(*Sharedp));

    Sharedp->Flags = NAT_POOL_FLAG_PLACEHOLDER;
    Sharedp->PrivateAddress = PrivateAddress;
    Sharedp->PublicAddress = Usedp->PublicAddress;
    Sharedp->Key =
        MAKE_USED_ADDRESS_KEY(
            Sharedp->PrivateAddress, Sharedp->PublicAddress
            );
    Sharedp->ReferenceCount = 1;
    InitializeListHead(&Sharedp->Link);
    RtlInitializeSplayLinks(&Sharedp->SLink);
    InsertTailList(&Interfacep->UsedAddressList, &Sharedp->Link);

    Interfacep->UsedAddressTree =
        NatInsertAddressPoolEntry(InsertionPoint, Sharedp);

    //
    // Set the placeholder's 'SharedAddress' field
    // to point to the actual address containing the port-pools
    //

    Sharedp->SharedAddress = Usedp;
    NatReferenceAddressPoolEntry(Usedp);

    *AddressAcquired = Sharedp;

    return STATUS_SUCCESS;

} // NatAcquireFromAddressPool


NTSTATUS
NatAcquireEndpointFromAddressPool(
    PNAT_INTERFACE Interfacep,
    ULONG64 PrivateKey,
    ULONG64 RemoteKey,
    ULONG PublicAddress OPTIONAL,
    USHORT PreferredPort,
    BOOLEAN AllowAnyPort,
    PNAT_USED_ADDRESS* AddressAcquired,
    PUSHORT PortAcquired
    )

/*++

Routine Description:

    This routine is called to acquire an address and port for a session.

Arguments:

    PrivateKey - the private endpoint for the session

    RemoteKey - the remote endpoint for the session

    PublicAddress - optionally specifies the public address to be acquired

    PreferredPort - optionally specifies the port preferred by the caller

    AllowAnyPort - if TRUE, any available port can be used for the mapping
        if 'Portp' is not available.

    AddressAcquired - receives the address acquired

    PortAcquired - receives the port acquired

Return Value:

    NTSTATUS - indicates success/failure.

Environment:

    Invoked with 'MappingLock' and 'Interfacep->Lock' held by the caller.

--*/

{
    PNAT_USED_ADDRESS Addressp;
    USHORT StopPort;
    ULONG i;
    PLIST_ENTRY Link;
    USHORT Port;
    UCHAR Protocol;
    ULONG64 PublicKey;
    PNAT_USED_ADDRESS SharedAddress;
    NTSTATUS status;

    CALLTRACE(("NatAcquireEndpointFromAddressPool\n"));

    //
    // Acquire an address for the session
    //

    status =
        NatAcquireFromAddressPool(
            Interfacep,
            MAPPING_ADDRESS(PrivateKey),
            PublicAddress,
            &Addressp
            );

    if (!NT_SUCCESS(status)) { return status; }

    SharedAddress = Addressp;
    PLACEHOLDER_TO_ADDRESS(SharedAddress);

    //
    // Now look for a port range which contains the preferred port
    //

    Protocol = MAPPING_PROTOCOL(PrivateKey);

    if (PreferredPort) {

        do {

            //
            // The caller prefers that we acquire a particular port;
            // see if we can satisfy the request.
            //

            Port = NTOHS(PreferredPort);
            if (Port < NTOHS(SharedAddress->StartPort) ||
                Port > NTOHS(SharedAddress->EndPort)) {
                break;
            }

            //
            // The preferred port is in the current range.
            // See if it is in use by another mapping
            //

            MAKE_MAPPING_KEY(
                PublicKey,
                Protocol,
                Addressp->PublicAddress,
                PreferredPort
                );

            if (NatLookupReverseMapping(PublicKey, RemoteKey, NULL)) { break; }

            //
            // Now see if it is in use by a ticket
            //

            if (NatIsPortUsedByTicket(Interfacep, Protocol, PreferredPort)) {
                break;
            }

            //
            // The preferred port is available; return
            //

            *AddressAcquired = Addressp;
            *PortAcquired = PreferredPort;

            TRACE(
                POOL,
                ("NatAcquireEndpointFromAddressPool: using preferred port %d\n",
                NTOHS(PreferredPort)
                ));

            return STATUS_SUCCESS;

        } while(FALSE);

        //
        // We couldn't acquire the preferred port;
        // fail if no other port is acceptable.
        //

        if (!AllowAnyPort || !NAT_INTERFACE_NAPT(Interfacep)) {
            NatDereferenceAddressPoolEntry(Interfacep, Addressp);
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // If this is for a UDP session, check to see if there is another
    // session with the same private endpoint. If such a session
    // exists we want to use the same public endpoint for this session.
    //

    if (NAT_PROTOCOL_UDP == MAPPING_PROTOCOL(PrivateKey)) {
        PNAT_DYNAMIC_MAPPING Mapping;
        IP_NAT_PATH Path;

        //
        // Perform a source-only mapping lookup
        //
        
        Mapping = NatSourceLookupForwardMapping(PrivateKey);
        
        if (NULL == Mapping) {
            Mapping = NatSourceLookupReverseMapping(PrivateKey);
        }

        if (NULL != Mapping) {

            //
            // There's another UDP session with this private endpoint;
            // if it has the same public address that we've already
            // acquired then use the same public port.
            //

            Path = NAT_MAPPING_INBOUND(Mapping) 
                    ? NatForwardPath
                    : NatReversePath;

            if (SharedAddress->PublicAddress
                == MAPPING_ADDRESS(Mapping->DestinationKey[Path])) {

                //
                // Same public address -- use the port from
                // this session.
                //

                *AddressAcquired = Addressp;
                *PortAcquired = MAPPING_PORT(Mapping->DestinationKey[Path]);

                TRACE(
                    POOL,
                    ("NatAcquireEndpointFromAddressPool: reusing UDP port %d\n",
                    NTOHS(*PortAcquired)
                    ));

                return STATUS_SUCCESS;
            }
        }  
    }

    //
    // Acquire the first available port for the session
    //

    if (SharedAddress->NextPortToTry != SharedAddress->StartPort) {
        StopPort =
            RtlUshortByteSwap(
                (USHORT)(NTOHS(SharedAddress->NextPortToTry) - 1)
                );
    } else {
        StopPort = SharedAddress->EndPort;
    }
    

    for (Port = SharedAddress->NextPortToTry; Port != StopPort;
         Port = (Port != SharedAddress->EndPort
                    ? RtlUshortByteSwap((USHORT)(NTOHS(Port) + 1))
                    : SharedAddress->StartPort)) {

        //
        // See if this port is in use by a mapping
        //

        MAKE_MAPPING_KEY(PublicKey, Protocol, Addressp->PublicAddress, Port);

        if (NatLookupReverseMapping(PublicKey, RemoteKey, NULL)) { continue; }

        //
        // Now see if it is in use by a ticket
        //

        if (NatIsPortUsedByTicket(Interfacep, Protocol, Port)) { continue; }

        //
        // The port is available; return
        //

        *AddressAcquired = Addressp;
        *PortAcquired = Port;

        //
        // Update the address pool entry with the port with which to
        // start the search on the next allocation attempt. 
        //
        
        if (Port == SharedAddress->EndPort) {
            SharedAddress->NextPortToTry = SharedAddress->StartPort;
        } else {
            SharedAddress->NextPortToTry =
                RtlUshortByteSwap(
                    (USHORT)(NTOHS(Port) + 1)
                    );
        }

        TRACE(
            POOL, ("NatAcquireEndpointFromAddressPool: using port %d\n",
            NTOHS(Port)
            ));

        return STATUS_SUCCESS;
    }

    //
    // We were unable to acquire a port for the session; fail.
    //

    NatDereferenceAddressPoolEntry(Interfacep, Addressp);

    TRACE(POOL, ("NatAcquireEndpointFromAddressPool: no ports available\n"));

    return STATUS_UNSUCCESSFUL;

} // NatAcquireEndpointFromAddressPool


NTSTATUS
NatCreateAddressPool(
    PNAT_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine initializes an interface's address-pool.
    This involves setting up the bitmap of free addresses
    and reserving the statically mapped IP addresses.

Arguments:

    Interfacep - the interface on which to create the address pool.

Return Value:

    NTSTATUS - status code

--*/

{

    ULONG Address;
    BOOLEAN Changed;
    PNAT_FREE_ADDRESS FreeMapArray;
    ULONG FreeMapCount;
    PNAT_FREE_ADDRESS Freep;
    ULONG i;
    PNAT_USED_ADDRESS InsertionPoint;
    ULONG j;
    PRTL_SPLAY_LINKS Parent;
    PIP_NAT_ADDRESS_RANGE* RangeArrayIndirect;
    NTSTATUS status;
    PNAT_USED_ADDRESS Usedp;

    CALLTRACE(("NatCreateAddressPool\n"));

    if (Interfacep->AddressRangeCount <= 1) {
        RangeArrayIndirect = &Interfacep->AddressRangeArray;
    } else {

        //
        // Allocate a temporary block of pointers
        // to be used to do an indirect sort of the range-array.
        //

        RangeArrayIndirect =
            (PIP_NAT_ADDRESS_RANGE*)ExAllocatePoolWithTag(
                NonPagedPool,
                Interfacep->AddressRangeCount * sizeof(PVOID),
                NAT_TAG_RANGE_ARRAY
                );

        if (!RangeArrayIndirect) {
            ERROR(("NatCreateAddressPool: error allocating sort-buffer\n"));
            return STATUS_NO_MEMORY;
        }

        for (i = 0; i < Interfacep->AddressRangeCount; i++) {
            RangeArrayIndirect[i] = &Interfacep->AddressRangeArray[i];
        }

        do {

            //
            // Now do a bubble-sort of the ranges
            //

            Changed = FALSE;

            for (i = 0; i < Interfacep->AddressRangeCount - 1; i++) {

                PIP_NAT_ADDRESS_RANGE CurrentRange = RangeArrayIndirect[i];
                ULONG CurrentRangeStartAddress =
                    RtlUlongByteSwap(CurrentRange->StartAddress);
                PIP_NAT_ADDRESS_RANGE NextRange;

                for (j = i+1, NextRange = RangeArrayIndirect[j];
                     j < Interfacep->AddressRangeCount;
                     j++, NextRange = RangeArrayIndirect[j]) {

                    //
                    // Do a swap if necessary
                    //

                    if (CurrentRangeStartAddress <=
                        RtlUlongByteSwap(NextRange->StartAddress)) { continue; }

                    RangeArrayIndirect[i] = NextRange;
                    RangeArrayIndirect[j] = CurrentRange;
                    CurrentRange = NextRange;
                    CurrentRangeStartAddress =
                        RtlUlongByteSwap(NextRange->StartAddress);
                    Changed = TRUE;
                }
            }

        } while (Changed);
    }

    //
    // Copy the ranges into NAT_FREE_ADDRESS blocks.
    // There will be at most 'RangeCount' of these,
    // and possibly less, since we will merge any ranges
    // which overlap or are adjacent.
    //

    FreeMapCount = 0;
    if (!Interfacep->AddressRangeCount) {
        FreeMapArray = NULL;
    } else {

        FreeMapArray =
            (PNAT_FREE_ADDRESS)ExAllocatePoolWithTag(
                NonPagedPool,
                Interfacep->AddressRangeCount * sizeof(NAT_FREE_ADDRESS),
                NAT_TAG_FREE_MAP
                );

        if (!FreeMapArray) {
            ExFreePool(RangeArrayIndirect);
            return STATUS_NO_MEMORY;
        }
    }

    for (i = 0, j = 0; i < Interfacep->AddressRangeCount; i++) {

        ULONG RangeStartAddress =
            RtlUlongByteSwap(RangeArrayIndirect[i]->StartAddress);

        //
        // See if we should merge with the preceding block;
        //

        if (FreeMapCount) {

            //
            // Incrementing the end-address of the preceding range
            // enables us to catch both overlaps and adjacencies.
            //

            if (RangeStartAddress <=
                RtlUlongByteSwap(FreeMapArray[j].EndAddress) + 1) {

                //
                // We need to merge.
                //

                if (RtlUlongByteSwap(FreeMapArray[j].EndAddress) <
                    RtlUlongByteSwap(RangeArrayIndirect[i]->EndAddress)) {
                    FreeMapArray[j].EndAddress =
                        RangeArrayIndirect[i]->EndAddress;
                }

                if (RtlUlongByteSwap(FreeMapArray[j].SubnetMask) <
                    RtlUlongByteSwap(RangeArrayIndirect[i]->SubnetMask)) {
                    FreeMapArray[j].SubnetMask =
                        RangeArrayIndirect[i]->SubnetMask;
                }

                continue;
            }

            //
            // No merge; move to next slot.
            //

            ++j;
        }

        FreeMapArray[j].StartAddress = RangeArrayIndirect[i]->StartAddress;
        FreeMapArray[j].EndAddress = RangeArrayIndirect[i]->EndAddress;
        FreeMapArray[j].SubnetMask = RangeArrayIndirect[i]->SubnetMask;
        FreeMapCount++;
    }

    if (Interfacep->AddressRangeCount > 1) { ExFreePool(RangeArrayIndirect); }

    //
    // Now we have an array of disjoint, non-adjacent address-ranges;
    // Initialize the bitmap for each address-range.
    //

    for (i = 0; i < FreeMapCount; i++) {

        //
        //  We can't allocate large enough bitmaps to support huge ranges;
        //  for instance, if the address pool is 128.0.0.0-128.255.255.255,
        //  the corresponding bitmap would have 2^24 bits, or 2MB.
        //  For now, shrink all ranges to allow at most 2^16 bits, or 8K.
        //

        j = RtlUlongByteSwap(FreeMapArray[i].EndAddress) -
            RtlUlongByteSwap(FreeMapArray[i].StartAddress) + 1;

        if (j >= IP_NAT_MAX_ADDRESS_RANGE) {

            ERROR(("NatCreateAddressPool: shrinking %d-bit bitmap\n", j));

            //
            // Resize the range
            //

            FreeMapArray[i].EndAddress =
                RtlUlongByteSwap(
                    RtlUlongByteSwap(FreeMapArray[i].StartAddress) +
                    IP_NAT_MAX_ADDRESS_RANGE
                    );
            j = IP_NAT_MAX_ADDRESS_RANGE;
        }

        //
        // Allocate a bitmap for the range
        //

        FreeMapArray[i].Bitmap =
            (PRTL_BITMAP)ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(RTL_BITMAP) +
                (j + sizeof(ULONG) * 8 - 1) / sizeof(ULONG) * 8,
                NAT_TAG_BITMAP
                );

        if (!FreeMapArray[i].Bitmap) {
            ERROR(("NatCreateAddressPool: error allocating bitmap\n"));
            while ((LONG)--i >= 0) { ExFreePool(FreeMapArray[i].Bitmap); }
            ExFreePool(FreeMapArray);
            return STATUS_NO_MEMORY;
        }

        INITIALIZE_BITMAP(
            FreeMapArray[i].Bitmap, (PULONG)(FreeMapArray[i].Bitmap + 1), j
            );
        RtlClearAllBits(FreeMapArray[i].Bitmap);
    }

    status = STATUS_SUCCESS;
    Interfacep->FreeMapArray = FreeMapArray;
    Interfacep->FreeMapCount = FreeMapCount;

    //
    // Create address-pool entries for each local address
    //

    for (i = 0; i < Interfacep->AddressCount; i++) {

        TRACE(
            POOL, ("NatCreateAddressPool: address %d.%d.%d.%d\n",
            ADDRESS_BYTES(Interfacep->AddressArray[i].Address))
            );

        status =
            NatCreateAddressPoolEntry(
                Interfacep,
                Interfacep->AddressArray[i].Address,
                Interfacep->AddressArray[i].Address,
                NAT_POOL_FLAG_BINDING,
                NULL,
                &Usedp
                );
        if (!NT_SUCCESS(status)) { break; }
    }

    //
    // Creating address-pool entries for each statically-mapped address
    //

    for (i = 0; i < Interfacep->AddressMappingCount; i++) {

        TRACE(
            POOL, ("NatCreateAddressPool: mapping %d.%d.%d.%d\n",
            ADDRESS_BYTES(Interfacep->AddressMappingArray[i].PrivateAddress))
            );

        status =
            NatCreateAddressPoolEntry(
                Interfacep,
                Interfacep->AddressMappingArray[i].PrivateAddress,
                Interfacep->AddressMappingArray[i].PublicAddress,
                NAT_POOL_FLAG_STATIC,
                NULL,
                &Usedp
                );
        if (!NT_SUCCESS(status)) { break; }

        Usedp->AddressMapping = &Interfacep->AddressMappingArray[i];
    }

    //
    // Create address-pool entries for statically-mapped port's address
    //

    for (i = Interfacep->PortMappingCount; i > 0; i--) {
        status =
            NatCreateStaticPortMapping(
                Interfacep, 
                &Interfacep->PortMappingArray[i - 1]
                );
        if (!NT_SUCCESS(status)) { break; }
    }

    if (!NT_SUCCESS(status)) {

        //
        // An error occurred. Restore the original state.
        //

        NatDeleteAddressPool(Interfacep);

        return status;
    }

    return STATUS_SUCCESS;

} // NatCreateAddressPool


NTSTATUS
NatCreateAddressPoolEntry(
    PNAT_INTERFACE Interfacep,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    DWORD InitialFlags,
    PNAT_USED_ADDRESS* InsertionPoint,
    PNAT_USED_ADDRESS* AddressCreated
    )

/*++

Routine Description:

    This routine creates, initializes and inserts an address pool entry.

Arguments:

    Interfacep - theinterface on which to create the entry.

    PrivateAddress - the address of the private machine using the address

    PublicAddress - the address for the entry, or 0 to allocate any address.

    InitialFlags - initial flags for the address-entry, as follows:
        NAT_POOL_FLAG_BINDING - if set, the address-entry is treated as
            a binding-entry
        NAT_POOL_FLAG_STATIC - if set, the address-entry corresponds to
            a static mapping

    InsertionPoint - optionally supplies the point where the entry
        should be inserted in the tree.

    AddressCreated - receives the entry created, or the existing entry
        if there is a collision.

Return Value:

    NTSTATUS - success/failure code.

--*/

{
    ULONG ClassMask;
    ULONG Hint;
    ULONG HostOrderPublicAddress;
    ULONG i;
    ULONG Index;
    PNAT_USED_ADDRESS Insert;
    NTSTATUS status = STATUS_SUCCESS;
    PNAT_USED_ADDRESS Usedp;

    CALLTRACE(("NatCreateAddressPoolEntry\n"));

    *AddressCreated = NULL;

    if (PublicAddress) {
        HostOrderPublicAddress = RtlUlongByteSwap(PublicAddress);
    }

    //
    // Find the free-map which contains this binding, if any.
    //

    Index = (ULONG)-1;

    for (i = 0; i < Interfacep->FreeMapCount; i++) {

        //
        // See if we're supposed to be looking for a free address
        //

        if (!PublicAddress) {

            //
            // See if this free-map has any free addresses.
            //

            for (Hint = 0; ; Hint = Index + 1) {

                Index =
                    RtlFindClearBits(
                        Interfacep->FreeMapArray[i].Bitmap, 1, Hint
                        );
                if (Index == (ULONG)-1) { break; }

                //
                // We've got a free address.
                // Make sure it isn't a prohibited address
                // (i.e. having 0 or all-ones in the subnet host portion).
                //

                PublicAddress =
                    RtlUlongByteSwap(
                        Index +
                        RtlUlongByteSwap(
                            Interfacep->FreeMapArray[i].StartAddress
                            ));

                ClassMask = GET_CLASS_MASK(PublicAddress);

                if ((PublicAddress &
                     ~Interfacep->FreeMapArray[i].SubnetMask) == 0 ||
                    (PublicAddress & ~Interfacep->FreeMapArray[i].SubnetMask) ==
                    ~Interfacep->FreeMapArray[i].SubnetMask ||
                    (PublicAddress & ~ClassMask) == 0 ||
                    (PublicAddress & ~ClassMask) == ~ClassMask) {

                    //
                    // The address is prohibited.
                    // Mark it as unavailable so we don't waste time
                    // looking at it ever again.
                    //

                    RtlSetBits(Interfacep->FreeMapArray[i].Bitmap, Index, 1);
                    PublicAddress = 0; continue;
                }

                //
                // The address is not prohibited
                //

                break;
            }

            //
            // Go on to the next free-map if this one was of no use
            //

            if (Index == (ULONG)-1) { continue; }

            //
            // We found an address in the current free-map;
            // go on to initialize a used-address entry
            //

            break;
        }

        //
        // We're not looking for just any free-address;
        // We're looking for the free-map of a particular address.
        // See if the current free-map contains the address in question.
        //

        if (HostOrderPublicAddress >
            RtlUlongByteSwap(Interfacep->FreeMapArray[i].EndAddress)) {
            continue;
        } else {
            Index = RtlUlongByteSwap(Interfacep->FreeMapArray[i].StartAddress);
            if (HostOrderPublicAddress < Index) {
                Index = (ULONG)-1;
                continue;
            }
        }

        //
        // This is the free-map we want.
        // See if the address is prohibited, and if so fail.
        //

        Index = HostOrderPublicAddress - Index;
        if ((PublicAddress & ~Interfacep->FreeMapArray[i].SubnetMask) == 0 ||
            (PublicAddress & ~Interfacep->FreeMapArray[i].SubnetMask) ==
            ~Interfacep->FreeMapArray[i].SubnetMask) {

            //
            // The address is prohibited. Mark it so we don't waste time
            // looking at it ever again.
            //

            RtlSetBits(Interfacep->FreeMapArray[i].Bitmap, Index, 1);

            TRACE(POOL, ("NatCreateAddressPoolEntry: bad address requested\n"));

            return STATUS_UNSUCCESSFUL;
        }

        break;
    }

    if (!PublicAddress) {

        //
        // We couldn't find a free address.
        //

        TRACE(POOL, ("NatCreateAddressPoolEntry: no free addresses\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Find the insertion point in the used-tree.
    //

    if (!InsertionPoint) {

        InsertionPoint = &Insert;

        Usedp =
            NatLookupAddressPoolEntry(
                Interfacep->UsedAddressTree,
                PrivateAddress,
                PublicAddress,
                InsertionPoint
                );

        if (Usedp) {

            //
            // This private-address already has a mapping; fail.
            //

            TRACE(POOL, ("NatCreateAddressPoolEntry: duplicate mapping\n"));
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Allocate a new entry for the new address
    //

    Usedp =
        ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(NAT_USED_ADDRESS),
            NAT_TAG_USED_ADDRESS
            );
    if (!Usedp) {
        ERROR(("NatCreateAddressPoolEntry: allocation failed\n"));
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(Usedp, sizeof(*Usedp));
    Usedp->PrivateAddress = PrivateAddress;
    Usedp->PublicAddress = PublicAddress;
    Usedp->Key = MAKE_USED_ADDRESS_KEY(PrivateAddress, PublicAddress);
    Usedp->Flags = InitialFlags;
    Usedp->ReferenceCount = 1;
    InitializeListHead(&Usedp->Link);
    RtlInitializeSplayLinks(&Usedp->SLink);
    if (NAT_POOL_BINDING(Usedp)) {
        Usedp->StartPort = ReservedPortsLowerRange;
        Usedp->EndPort = ReservedPortsUpperRange;
    } else {
        Usedp->StartPort = NTOHS(1);
        Usedp->EndPort = NTOHS(65534);
    }
    Usedp->NextPortToTry = Usedp->StartPort;

    //
    // Insert the entry in the splay tree and list.
    //

    InsertTailList(&Interfacep->UsedAddressList, &Usedp->Link);

    Interfacep->UsedAddressTree =
        NatInsertAddressPoolEntry(*InsertionPoint, Usedp);

    //
    // Update the free-map
    //

    if (Index != (ULONG)-1) {
        RtlSetBits(Interfacep->FreeMapArray[i].Bitmap, Index, 1);
    }

    *AddressCreated = Usedp;

    return STATUS_SUCCESS;
}


NTSTATUS
NatCreateStaticPortMapping(
    PNAT_INTERFACE Interfacep,
    PIP_NAT_PORT_MAPPING PortMapping
    )

/*++

Routine Description:

    This routine creates a static port mapping (i.e., persistent
    ticket) on an interace

Arguments:

    Interfacep - the interface on which to create the port mapping.

    PortMapping - describes the port mapping to be created.

Return Value:

    NTSTATUS - status code

Environment:

    Invoked with Interfacep->Lock held by the caller.

--*/

{
    PNAT_USED_ADDRESS InsertionPoint;
    ULONG PublicAddress;
    USHORT PublicPort;
    NTSTATUS status;
    PNAT_TICKET Ticketp;
    PNAT_USED_ADDRESS Usedp;

    CALLTRACE(("NatCreateStaticPortMapping\n"));

    //
    // The handling of the static port-mapping depends upon whether
    // its public address is for the interface or from the address-pool.
    // If the 'PublicAddress' is zero, then the port-mapping refers
    // to sessions destined for the interface's actual address.
    // Otherwise, the port-mapping refers to sessions destined for
    // an address in the interface's address pool.
    //

    if (!PortMapping->PublicAddress) {
        status =
            NatAcquireFromAddressPool(
                Interfacep,
                PortMapping->PrivateAddress,
                0,
                &Usedp
                );
    } else {

        Usedp =
            NatLookupAddressPoolEntry(
                Interfacep->UsedAddressTree,
                PortMapping->PrivateAddress,
                PortMapping->PublicAddress,
                &InsertionPoint
                );

        if (Usedp) {
            status = STATUS_SUCCESS;
            NatReferenceAddressPoolEntry(Usedp);
        } else {

            //
            // The mapping was not in use, so we need to create an
            // entry for its address.
            //

            status =
                NatCreateAddressPoolEntry(
                    Interfacep,
                    PortMapping->PrivateAddress,
                    PortMapping->PublicAddress,
                    0,
                    &InsertionPoint,
                    &Usedp
                    );
        }
    }

    //
    // Now create a ticket which will direct all incoming sessions
    // to the private endpoint specified in the static port-mapping.
    //

    if (NT_SUCCESS(status)) {
        status =
            NatCreateTicket(
                Interfacep,
                PortMapping->Protocol,
                PortMapping->PrivateAddress,
                PortMapping->PrivatePort,
                0,
                0,
                NAT_TICKET_FLAG_PORT_MAPPING|NAT_TICKET_FLAG_PERSISTENT,
                Usedp,
                PortMapping->PublicPort,
                &PublicAddress,
                &PublicPort
                );

        NatDereferenceAddressPoolEntry(Interfacep, Usedp);
    }

    return status;
}// NatCreateStaticPortMapping



NTSTATUS
NatDeleteAddressPool(
    PNAT_INTERFACE Interfacep
    )

/*++

Routine Description:

    Destroys an address pool, freeing the memory used by the free-maps
    and optionally, the used-address entries.

Arguments:

    Interfacep - the interface whose address pool is to be deleted.

Return Value:

    NTSTATUS - status code.

--*/

{
    ULONG i;
    PLIST_ENTRY Link;
    PNAT_TICKET Ticketp;
    PNAT_USED_ADDRESS Usedp;

    CALLTRACE(("NatDeleteAddressPool\n"));

    //
    // Dispose of the free-maps
    //

    for (i = 0; i < Interfacep->FreeMapCount; i++) {
        if (Interfacep->FreeMapArray[i].Bitmap) {
            ExFreePool(Interfacep->FreeMapArray[i].Bitmap);
        }
    }

    Interfacep->FreeMapCount = 0;
    if (Interfacep->FreeMapArray) { ExFreePool(Interfacep->FreeMapArray); }
    Interfacep->FreeMapArray = NULL;

    //
    // Clear out port-mappings created as tickets
    //

    for (Link = Interfacep->TicketList.Flink; Link != &Interfacep->TicketList;
         Link = Link->Flink) {
        Ticketp = CONTAINING_RECORD(Link, NAT_TICKET, Link);
        if (!NAT_TICKET_PORT_MAPPING(Ticketp)) { continue; }
        Link = Link->Blink;
        NatDeleteTicket(Interfacep, Ticketp);
    }

    //
    // Deal with the used-list;
    //

    while (!IsListEmpty(&Interfacep->UsedAddressList)) {
        Link = RemoveHeadList(&Interfacep->UsedAddressList);
        Usedp = CONTAINING_RECORD(Link, NAT_USED_ADDRESS, Link);
        Usedp->Flags |= NAT_POOL_FLAG_DELETED;
        NatDereferenceAddressPoolEntry(Interfacep, Usedp);
    }

    Interfacep->UsedAddressTree = NULL;

    return STATUS_SUCCESS;

} // NatDeleteAddressPool


PNAT_USED_ADDRESS
NatInsertAddressPoolEntry(
    PNAT_USED_ADDRESS Parent,
    PNAT_USED_ADDRESS Addressp
    )

/*++

Routine Description:

    This routine is called to insert an address in the interface's
    splay-tree of address-pool entries. The key is the 'PrivateAddress'
    field of the address-pool entry.

Arguments:

    Parent - the parent of the entry to be inserted, which may be obtained
        from NatLookupAddressPoolEntry

    Addressp - the address pool entry to be inserted

Return Value:

    The new root of the splay tree if successful, NULL otherwise.

--*/

{
    ULONG64 Key;
    PRTL_SPLAY_LINKS Root;

    CALLTRACE(("NatInsertAddressPoolEntry\n"));

    if (!Parent) {
        TRACE(POOL, ("NatInsertAddressPoolEntry: inserting as root\n"));
        return Addressp;
    }

    //
    // Insert as left or right child
    //

    Key =
        MAKE_USED_ADDRESS_KEY(Addressp->PrivateAddress,Addressp->PublicAddress);

    if (Addressp->Key < Parent->Key) {
        RtlInsertAsLeftChild(&Parent->SLink, &Addressp->SLink);
    } else if (Addressp->Key > Parent->Key) {
        RtlInsertAsRightChild(&Parent->SLink, &Addressp->SLink);
    } else {

        //
        // Keys are equal; fail.
        //

        ERROR((
           "NatInsertAddressPoolEntry: collision on key 0x%016I64X\n",
           Addressp->Key
           ));

        return NULL;
    }

    //
    // Splay the new node and return the resulting root.
    //

    Root = RtlSplay(&Addressp->SLink);

    return CONTAINING_RECORD(Root, NAT_USED_ADDRESS, SLink);

} // NatInsertAddressPoolEntry


PNAT_USED_ADDRESS
NatLookupAddressPoolEntry(
    PNAT_USED_ADDRESS Root,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    PNAT_USED_ADDRESS* InsertionPoint
    )

/*++

Routine Description:

    This routine searches the interface's splay tree of address-pool entries
    for a particular entry, returning the entry if found, otherwise supplying
    the insertion point for the entry.

Arguments:

    Root - the root of the splay tree ('Interfacep->UsedAddressTree').

    PrivateAddress - the private part of the address-mapping to be looked up

    PublicAddress - the public part of the address-mapping to be looked up

    InsertionPoint - receives the insertion point for the entry

Return Value:

    The entry if found, NULL otherwise.

--*/

{
    PNAT_USED_ADDRESS Addressp;
    ULONG64 Key;
    PNAT_USED_ADDRESS Parent = NULL;
    PRTL_SPLAY_LINKS SLink;

    TRACE(PER_PACKET, ("NatLookupAddressPoolEntry\n"));

    Key = MAKE_USED_ADDRESS_KEY(PrivateAddress, PublicAddress);

    for (SLink = !Root ? NULL : &Root->SLink; SLink;  ) {

        Addressp = CONTAINING_RECORD(SLink, NAT_USED_ADDRESS, SLink);

        if (Key < Addressp->Key) {
            Parent = Addressp;
            SLink = RtlLeftChild(SLink);
            continue;
        } else if (Key > Addressp->Key) {
            Parent = Addressp;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // Private-addresses match; we got it.
        //

        return Addressp;
    }

    //
    // We didn't get it; tell the caller where to insert it.
    //

    if (InsertionPoint) { *InsertionPoint = Parent; }

    return NULL;

} // NatLookupAddressPoolEntry


PNAT_USED_ADDRESS
NatLookupStaticAddressPoolEntry(
    PNAT_INTERFACE Interfacep,
    ULONG PublicAddress,
    BOOLEAN RequireInboundSessions
    )

/*++

Routine Description:

    This routine is invoked to search for an address pool entry
    which is marked static and which corresponds to the given public address.

Arguments:

    Interfacep - the interface whose address pool is to be searched

    PublicAddress - the public address for which to search

    RequireInboundSessions - if TRUE, a match is declared only if
        the entry found allows inbound sessions.

Return Value:

    PNAT_USED_ADDRESS - the address pool entry found, if any.

--*/

{
    ULONG i;
    PNAT_USED_ADDRESS Addressp;
    PIP_NAT_ADDRESS_MAPPING AddressMapping;

    if (!Interfacep->AddressMappingCount) {
        return NULL;
    } else {

        //
        // Perform exhaustive search since static address-mappings
        // are sorted by private address rather than public address.
        //

        AddressMapping = NULL;
        for (i = 0; i < Interfacep->AddressMappingCount; i++) {
            if (PublicAddress !=
                Interfacep->AddressMappingArray[i].PublicAddress) {
                continue;
            }
            AddressMapping = &Interfacep->AddressMappingArray[i];
            break;
        }
    }

    if (!AddressMapping ||
        !(Addressp =
            NatLookupAddressPoolEntry(
                Interfacep->UsedAddressTree,
                AddressMapping->PrivateAddress,
                AddressMapping->PublicAddress,
                NULL
                )) ||
        !NAT_POOL_STATIC(Addressp) ||
        (RequireInboundSessions && !AddressMapping->AllowInboundSessions)) {
        return NULL;
    }

    return Addressp;
} // NatLookupStaticAddressPoolEntry


NTSTATUS
NatDereferenceAddressPoolEntry(
    PNAT_INTERFACE Interfacep,
    PNAT_USED_ADDRESS AddressToRelease
    )

/*++

Routine Description:

    Drops the reference count on an address pool entry.
    This routine invalidates the supplied NAT_USED_ADDRESS pointer.
    Note, though, that it might not be freed, e.g. in the case where
    the address is being shared.

    If the entry is a placeholder and its reference count drops to zero,
    we also drop the reference count of its target ('SharedAddress') entry.

    N.B. If the entry is marked 'deleted', we ignore the 'Interfacep' argument
    since the entry must have been already removed from its interface's
    address pool.

Arguments:

    Interfacep - the interface whose address pool is to be deleted.

    AddressToRelease - contains a pointer to the address to be released.

Return Value:

    NTSTATUS - status code.

--*/

{
    ULONG HostOrderPublicAddress;
    ULONG i;
    ULONG Index;
    PRTL_SPLAY_LINKS SLink;
    PNAT_USED_ADDRESS Usedp = AddressToRelease;

    CALLTRACE(("NatDereferenceAddressPoolEntry\n"));

    if (NAT_POOL_PLACEHOLDER(Usedp)) {

        //
        // Do nothing if there are other references to the placeholder
        //

        if (InterlockedDecrement(&Usedp->ReferenceCount)) {
            return STATUS_SUCCESS;
        }

        //
        // Unlink and free the placeholder
        //

        if (!NAT_POOL_DELETED(Usedp)) {
            RemoveEntryList(&Usedp->Link);
            SLink = RtlDelete(&Usedp->SLink);
            Interfacep->UsedAddressTree =
                !SLink
                    ? NULL
                    : CONTAINING_RECORD(SLink, NAT_USED_ADDRESS, SLink);
        }

        //
        // Move on to the shared-address
        //

        Usedp = Usedp->SharedAddress;
        ExFreePool(AddressToRelease);
    }

    //
    // Do nothing if there are others sharing this address
    //

    if (InterlockedDecrement(&Usedp->ReferenceCount)) { return STATUS_SUCCESS; }

    if (!NAT_POOL_DELETED(Usedp)) {

        //
        // Marking the entry's address as free in the interface's bitmap.
        //

        Index = Usedp->PublicAddress;
        HostOrderPublicAddress = RtlUlongByteSwap(Usedp->PublicAddress);

        for (i = 0; i < Interfacep->FreeMapCount; i++) {

            if (HostOrderPublicAddress <
                RtlUlongByteSwap(Interfacep->FreeMapArray[i].StartAddress) ||
                HostOrderPublicAddress >
                RtlUlongByteSwap(Interfacep->FreeMapArray[i].EndAddress)) {
                continue;
            }

            Index =
                HostOrderPublicAddress -
                RtlUlongByteSwap(Interfacep->FreeMapArray[i].StartAddress);

            RtlClearBits(Interfacep->FreeMapArray[i].Bitmap, Index, 1);

            break;
        }

        //
        // Now we're done; just unlink and free the used-address block
        //

        RemoveEntryList(&Usedp->Link);
        SLink = RtlDelete(&Usedp->SLink);
        Interfacep->UsedAddressTree =
            !SLink ? NULL : CONTAINING_RECORD(SLink, NAT_USED_ADDRESS, SLink);
    }

    ExFreePool(Usedp);
    return STATUS_SUCCESS;

} // NatDereferenceAddressPoolEntry


//
// PORT-POOL ROUTINES (alphabetically)
//

NTSTATUS
NatAcquireFromPortPool(
    PNAT_INTERFACE Interfacep,
    PNAT_USED_ADDRESS Addressp,
    UCHAR Protocol,
    USHORT PreferredPort,
    PUSHORT PortAcquired
    )

/*++

Routine Description:

    This routine is invoked to acquire a unique public port from the pool.
    The port acquired is guaranteed to not be in use by any mapping.
    This is needed, for instance, when we are obtaining a port for a ticket
    to be created by an editor for a dynamically negotiated session.

Arguments:

    Interfacep - the interface on which to acquire the port

    Addressp - the address on which to acquire the port

    Protocol - the protocol for which to acquire the port

    PreferredPort - the port preferred by the caller

    PortAcquired - receives the port acquired

Return Value:

    NTSTATUS - success/failure code.

Environment:

    Invoked with 'MappingLock' and 'Interfacep->Lock' held by the caller.

--*/

{
    #define QUERY_PUBLIC_PORT(m,p) \
        NatQueryInformationMapping((m),NULL,NULL,NULL,NULL,NULL,NULL,p,NULL)
    USHORT EndPort;
    ULONG i;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    USHORT Port;
    USHORT PublicPort;
    PNAT_USED_ADDRESS SharedAddress;

    CALLTRACE(("NatAcquireFromPortPool\n"));

    SharedAddress = Addressp;
    PLACEHOLDER_TO_ADDRESS(SharedAddress);

    //
    // First attempt to satisfy the caller's preference
    //

    if (PreferredPort) {

        //
        // The caller prefers that we acquire a particular port;
        // see if we can satisfy the request.
        //

        do {

            Port = NTOHS(PreferredPort);
            if (Port < NTOHS(SharedAddress->StartPort) ||
                Port > NTOHS(SharedAddress->EndPort)) {
                break;
            }

            //
            // The preferred port is in the current range.
            // See if it is in use by another mapping
            //

            KeAcquireSpinLockAtDpcLevel(&InterfaceMappingLock);
            for (Link = Interfacep->MappingList.Flink;
                 Link != &Interfacep->MappingList; Link = Link->Flink) {
                Mapping =
                    CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, InterfaceLink);
                QUERY_PUBLIC_PORT(Mapping, &PublicPort);
                if (PreferredPort == PublicPort) { break; }
            }
            if (Link != &Interfacep->MappingList) {
                KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);
                break;
            }
            KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);

            //
            // Now see if it is in use by a ticket
            //

            if (NatIsPortUsedByTicket(Interfacep, Protocol, PreferredPort)) {
                break;
            }

            //
            // The preferred port is available; return
            //

            TRACE(
                POOL,
                ("NatAcquireFromPortPool: using preferred port %d\n",
                NTOHS(PreferredPort)
                ));

            *PortAcquired = PreferredPort;

            return STATUS_SUCCESS;

        } while(FALSE);

        //
        // We couldn't acquire the preferred port;
        // fail if no other port is acceptable.
        //

        if (!NAT_INTERFACE_NAPT(Interfacep)) {
            TRACE(
                POOL,
                ("NatAcquireFromPortPool: unable to use preferred port %d\n",
                NTOHS(PreferredPort)
                ));
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Search the port pool, looking for a port which
    // (a) is not already in use by any mapping, and
    // (b) is not already in use by any ticket.
    //

    EndPort = RtlUshortByteSwap((USHORT)(NTOHS(SharedAddress->EndPort) + 1));

    for (Port = SharedAddress->StartPort; Port != EndPort;
         Port = RtlUshortByteSwap((USHORT)(NTOHS(Port) + 1))) {

        //
        // Look through the interface's mappings
        //

        KeAcquireSpinLockAtDpcLevel(&InterfaceMappingLock);
        for (Link = Interfacep->MappingList.Flink;
             Link != &Interfacep->MappingList; Link = Link->Flink) {
            Mapping =
                CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, InterfaceLink);
            QUERY_PUBLIC_PORT(Mapping, &PublicPort);
            if (Port == PublicPort) { break; }
        }
        if (Link != &Interfacep->MappingList) {
            KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);
            continue;
        }
        KeReleaseSpinLockFromDpcLevel(&InterfaceMappingLock);

        //
        // No mapping is using the public-port;
        // Now see if any ticket is using the public port
        //

        if (NatIsPortUsedByTicket(Interfacep, Protocol, Port)) { continue; }

        //
        // The port is not in use by any mapping or ticket; we're done.
        //

        TRACE(
            POOL, ("NatAcquireFromPortPool: acquiring port %d\n",
            NTOHS(Port)
            ));

        *PortAcquired = Port;

        return STATUS_SUCCESS;
    }

    TRACE(POOL, ("NatAcquireFromPortPool: no available ports\n"));

    return STATUS_UNSUCCESSFUL;

} // NatAcquireFromPortPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\pptp.c ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    pptp.c

Abstract:

    Contains routines for managing the NAT's PPTP session-mappings
    and for editing PPTP control-session messages.

Author:

    Abolade Gbadegesin (t-abolag)   19-Aug-1997

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

//
// Structure:   PPTP_PSEUDO_HEADER
//
// This structure serves as a pseudo-header for a PPTP control message.
// Its fields are initialized by 'NatBuildPseudoHeaderPptp' with pointers
// to the positions in a buffer-chain of the given PPTP header fields.
// This allows us to access header-fields through a structure even though
// the actual fields may be spread through the received buffer-chain.
//

typedef struct _PPTP_PSEUDO_HEADER {
    PUSHORT PacketLength;
#if 0
    PUSHORT PacketType; // currently unused
#endif
    ULONG UNALIGNED * MagicCookie;
    PUSHORT MessageType;
    PUSHORT CallId;
    PUSHORT PeerCallId;
} PPTP_PSEUDO_HEADER, *PPPTP_PSEUDO_HEADER;


//
// Structure:   PPTP_DELETE_WORK_ITEM
//

typedef struct _PPTP_DELETE_WORK_ITEM {
    ULONG64 PrivateKey;
    PIO_WORKITEM IoWorkItem;
} PPTP_DELETE_WORK_ITEM, *PPPTP_DELETE_WORK_ITEM;


//
// GLOBAL DATA DEFINITIONS
//

NPAGED_LOOKASIDE_LIST PptpLookasideList;
LIST_ENTRY PptpMappingList[NatMaximumDirection];
KSPIN_LOCK PptpMappingLock;
IP_NAT_REGISTER_EDITOR PptpRegisterEditorClient;
IP_NAT_REGISTER_EDITOR PptpRegisterEditorServer;


//
// FORWARD DECLARATIONS
//

IPRcvBuf*
NatBuildPseudoHeaderPptp(
    IPRcvBuf* ReceiveBuffer,
    PLONG DataOffset,
    PPPTP_PSEUDO_HEADER Header
    );

VOID
NatDeleteHandlerWorkItemPptp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );


//
// PPTP MAPPING MANAGEMENT ROUTINES (alphabetically)
//

NTSTATUS
NatAllocatePublicPptpCallId(
    ULONG64 PublicKey,
    PUSHORT CallIdp,
    PLIST_ENTRY *InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine allocates a public call-ID for a PPTP mapping.

Arguments:

    PublicKey - the public key (public and remote addresses) of the mapping
        the public call ID is for

    CallIdp - receives the allocated public call ID

    InsertionPoint -- receives the correct location to insert the mapping
        on the inbound list

Return Value:

    NTSTATUS - indicates success/failure
    
Environment:

    Invoked with 'PptpMappingLock' held by the caller.

--*/

{
    USHORT CallId;
    PLIST_ENTRY Link;
    PNAT_PPTP_MAPPING Mapping;

    CALLTRACE(("NatAllocatePublicPptpCallId\n"));

    CallId = 1;

    for (Link = PptpMappingList[NatInboundDirection].Flink;
         Link != &PptpMappingList[NatInboundDirection];
         Link = Link->Flink) {

        Mapping =
            CONTAINING_RECORD(
                Link, NAT_PPTP_MAPPING, Link[NatInboundDirection]
                );
        if (PublicKey > Mapping->PublicKey) {
            continue;
        } else if (PublicKey < Mapping->PublicKey) {
            break;
        }

        //
        // Primary key equal; see if the call-ID we've chosen
        // collides with this one
        //

        if (CallId > Mapping->PublicCallId) {
            continue;
        } else if (CallId < Mapping->PublicCallId) {
            break;
        }

        //
        // The call-ID's collide; choose another and go on
        //

        ++CallId;
    }

    if (Link == &PptpMappingList[NatInboundDirection] && !CallId) {

        //
        // We are at the end of the list, and all 64K-1 call-IDs are taken
        //

        return STATUS_UNSUCCESSFUL;
    }

    *CallIdp = CallId;
    if (InsertionPoint) {*InsertionPoint = Link;}
    
    return STATUS_SUCCESS;
} // NatAllocatePublicPptpCallId


NTSTATUS
NatCreatePptpMapping(
    ULONG RemoteAddress,
    ULONG PrivateAddress,
    USHORT CallId,
    ULONG PublicAddress,
    PUSHORT CallIdp,
    IP_NAT_DIRECTION Direction,
    PNAT_PPTP_MAPPING* MappingCreated
    )

/*++

Routine Description:

    This routine creates and initializes a mapping for a PPTP session.
    The mapping is created when a client issues an IncomingCallRequest
    message, at which point only the client's call-ID is available.
    The mapping is therefore initially marked as half-open.
    When the IncomingCallReply is received from the server, the server's
    call-ID is recorded, and when the IncomingCallConnected is issued
    by the client, the 'half-open' flag is cleared.

Arguments:

    RemoteAddress - the address of the remote PPTP endpoint (server)

    PrivateAddress - the address of the private PPTP endpoint (client)

    CallId - the call-ID specified by the PPTP endpoint. For outbound,
        this is the private call ID; for inbound, it is the remote
        call ID

    PublicAddress - the publicly-visible address for the PPTP session

    CallIdp - the call-ID to be used publicly for the PPTP session,
        or NULL if a call-ID should be allocated. Ignored for inbound.

    Direction - the initial list that this mapping should be placed on

    MappingCreated - receives the mapping created

Return Value:

    NTSTATUS - indicates success/failure
    
Environment:

    Invoked with 'PptpMappingLock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    PLIST_ENTRY InsertionPoint;
    PNAT_PPTP_MAPPING Mapping;
    NTSTATUS Status;
    PNAT_PPTP_MAPPING Temp;

    TRACE(PPTP, ("NatCreatePptpMapping\n"));

    //
    // Allocate and initialize a new mapping, marking it half-open
    // since we don't yet know what the remote machine's call-ID will be.
    //

    Mapping = ALLOCATE_PPTP_BLOCK();
    if (!Mapping) {
        ERROR(("NatCreatePptpMapping: allocation failed.\n"));
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(Mapping, sizeof(*Mapping));
    Mapping->Flags = NAT_PPTP_FLAG_HALF_OPEN;
    Mapping->PublicKey = MAKE_PPTP_KEY(RemoteAddress, PublicAddress);
    Mapping->PrivateKey = MAKE_PPTP_KEY(RemoteAddress, PrivateAddress);

    if (NatOutboundDirection == Direction) {

        //
        // CallId refers to the private id -- select an id to use
        // as the public id, and put the mapping on the inbound list
        //
        
        Mapping->PrivateCallId = CallId;

        //
        // Select the public call-ID to be used for the mapping.
        // This may either be specified by the caller, or allocated automatically
        // from the next available call-ID unused in our list of mappings.
        //

        if (CallIdp) {

            //
            // Use the caller-specified call-ID
            //

            Mapping->PublicCallId = *CallIdp;

            if (NatLookupInboundPptpMapping(
                    Mapping->PublicKey,
                    Mapping->PublicCallId,
                    &InsertionPoint
                    )) {

                //
                // Conflicting call-ID
                //

                TRACE(
                    PPTP, (
                    "NatCreatePptpMapping: Conflicting Call-ID %i\n",
                    *CallIdp
                    ));
                    
                FREE_PPTP_BLOCK(Mapping);
                return STATUS_UNSUCCESSFUL;
            }

            
        } else {

            //
            // Find the next available call-ID
            // by searching the list of inbound mappings
            //

            Status = NatAllocatePublicPptpCallId(
                        Mapping->PublicKey,
                        &Mapping->PublicCallId,
                        &InsertionPoint
                        );
                        
            if (!NT_SUCCESS(Status)) {
                TRACE(
                    PPTP, (
                    "NatCreatePptpMapping: Unable to allocate public Call-Id\n"
                    ));
                FREE_PPTP_BLOCK(Mapping);
                return STATUS_UNSUCCESSFUL;
            }
        }
    
        //
        // Insert the mapping in the inbound list
        //

        InsertTailList(InsertionPoint, &Mapping->Link[NatInboundDirection]);

        //
        // We can't insert the mapping in the outbound list
        // until we have the remote call-ID; for now leave it off the list.
        // Note that the mapping was marked 'half-open' above.
        //
        
        InitializeListHead(&Mapping->Link[NatOutboundDirection]);

    } else {

        //
        // The call id refers to the remote call id. All that needed to
        // be done here is to place the mapping on the outbound list
        //

        Mapping->RemoteCallId = CallId;

        if (NatLookupOutboundPptpMapping(
                Mapping->PrivateKey,
                Mapping->RemoteCallId,
                &InsertionPoint
                )) {

            //
            // Duplicate mapping
            //

            TRACE(
                PPTP, (
                "NatCreatePptpMapping: Duplicate mapping 0x%016I64X/%i\n",
                Mapping->PrivateKey,
                Mapping->RemoteCallId
                ));

            FREE_PPTP_BLOCK(Mapping);
            return STATUS_UNSUCCESSFUL;
        }

        InsertTailList(InsertionPoint, &Mapping->Link[NatOutboundDirection]);

        //
        // We can't insert the mapping in the inbound list
        // until we have the public call-ID; for now leave it off the list.
        // Note that the mapping was marked 'half-open' above.
        //
        
        InitializeListHead(&Mapping->Link[NatInboundDirection]);
    }
    
    *MappingCreated = Mapping;
    return STATUS_SUCCESS;

} // NatCreatePptpMapping


PNAT_PPTP_MAPPING
NatLookupInboundPptpMapping(
    ULONG64 PublicKey,
    USHORT PublicCallId,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to lookup a PPTP session mapping in the list
    which is sorted for inbound-access, using <RemoteAddress # PublicAddress>
    as the primary key and 'PublicCallId' as the secondary key.

Arguments:

    PublicKey - the primary search key

    PublicCallId - the publicly visible call-ID, which is the secondary key

    InsertionPoint - receives the point at which the mapping should be inserted
        if the mapping is not found.

Return Value:

    PNAT_PPTP_MAPPING - the mapping found, if any.

Environment:

    Invoked with 'PptpMappingLock' held by the caller.

--*/

{
    PLIST_ENTRY         Link;
    PNAT_PPTP_MAPPING   Mapping;

    TRACE(PER_PACKET, ("NatLookupInboundPptpMapping\n"));

    for (Link = PptpMappingList[NatInboundDirection].Flink;
         Link != &PptpMappingList[NatInboundDirection]; Link = Link->Flink) {
        Mapping =
            CONTAINING_RECORD(
                Link, NAT_PPTP_MAPPING, Link[NatInboundDirection]
                );
        if (PublicKey > Mapping->PublicKey) {
            continue;
        } else if (PublicKey < Mapping->PublicKey) {
            break;
        }

        //
        // Primary keys equal, check secondary keys
        //

        if (PublicCallId > Mapping->PublicCallId) {
            continue;
        } else if (PublicCallId < Mapping->PublicCallId) {
            break;
        }

        //
        // Secondary keys equal, we got it.
        //

        return Mapping;
    }

    //
    // Mapping not found, return insertion point
    //

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupInboundPptpMapping


PNAT_PPTP_MAPPING
NatLookupOutboundPptpMapping(
    ULONG64 PrivateKey,
    USHORT RemoteCallId,
    PLIST_ENTRY* InsertionPoint
    )

/*++

Routine Description:

    This routine is called to lookup a PPTP session mapping in the list
    which is sorted for outbound-access, using <RemoteAddress # PrivateAddress>
    as the primary key and 'RemoteCallId' as the secondary key.

Arguments:

    PrivateKey - the primary search key

    RemoteCallId - the remote endpoint's call-ID, which is the secondary key

    InsertionPoint - receives the point at which the mapping should be inserted
        if the mapping is not found.

Return Value:

    PNAT_PPTP_MAPPING - the mapping found, if any.

Environment:

    Invoked with 'PptpMappingLock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    PNAT_PPTP_MAPPING Mapping;

    TRACE(PER_PACKET, ("NatLookupOutboundPptpMapping\n"));

    for (Link = PptpMappingList[NatOutboundDirection].Flink;
         Link != &PptpMappingList[NatOutboundDirection]; Link = Link->Flink) {
        Mapping =
            CONTAINING_RECORD(
                Link, NAT_PPTP_MAPPING, Link[NatOutboundDirection]
                );
        if (PrivateKey > Mapping->PrivateKey) {
            continue;
        } else if (PrivateKey < Mapping->PrivateKey) {
            break;
        }

        //
        // Primary keys equal, check secondary keys
        //

        if (RemoteCallId > Mapping->RemoteCallId) {
            continue;
        } else if (RemoteCallId < Mapping->RemoteCallId) {
            break;
        }

        //
        // Secondary keys equal, we got it.
        //

        return Mapping;
    }


    //
    // Mapping not found, return insertion point
    //

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupOutboundPptpMapping


//
// PPTP EDITOR ROUTINES (alphabetically)
//

#define RECVBUFFER          ((IPRcvBuf*)ReceiveBuffer)

//
// Macro:   PPTP_HEADER_FIELD
//

#define PPTP_HEADER_FIELD(ReceiveBuffer, DataOffsetp, Header, Field, Type) \
    FIND_HEADER_FIELD( \
        ReceiveBuffer, DataOffsetp, Header, Field, PPTP_HEADER, Type \
        )


IPRcvBuf*
NatBuildPseudoHeaderPptp(
    IPRcvBuf* ReceiveBuffer,
    PLONG DataOffset,
    PPPTP_PSEUDO_HEADER Header
    )

/*++

Routine Description:

    This routine is called to initialize a pseudo-header with pointers
    to the fields of a PPTP header.

Arguments:

    ReceiveBuffer - the buffer-chain containing the PPTP message

    DataOffset - on input, contains the offset to the beginning of the
        PPTP header. On output, contains a (negative) value indicating
        the offset to the beginning of the same PPTP header in the returned
        'IPRcvBuf'. Adding the 'PacketLength' to the value gives the beginning
         of the next PPTP message in the buffer chain.

    Header - receives the header-field pointers.

Return Value:

    IPRcvBuf* - a pointer to the buffer in the chain from which the last
        header-field was read. Returns NULL on failure.

--*/

{

    //
    // Note that the pseudo-header's fields must be initialized in-order,
    // i.e. fields appearing earlier in PPTP header must be set before
    // fields appearing later in the PPTP header.
    // (See comment on 'PPTP_HEADER_FIELD' for more details).
    //

    PPTP_HEADER_FIELD(ReceiveBuffer, DataOffset, Header, PacketLength, PUSHORT);
    if (!ReceiveBuffer) { return NULL; }
    if (!*Header->PacketLength) {return NULL;}
    
    PPTP_HEADER_FIELD(ReceiveBuffer, DataOffset, Header, MagicCookie, PULONG);
    if (!ReceiveBuffer) { return NULL; }
    if (*Header->MagicCookie != PPTP_MAGIC_COOKIE) { return NULL; }

    PPTP_HEADER_FIELD(ReceiveBuffer, DataOffset, Header, MessageType, PUSHORT);
    if (!ReceiveBuffer) { return NULL; }

    PPTP_HEADER_FIELD(ReceiveBuffer, DataOffset, Header, CallId, PUSHORT);
    if (!ReceiveBuffer) { return NULL; }

    PPTP_HEADER_FIELD(ReceiveBuffer, DataOffset, Header, PeerCallId, PUSHORT);
    if (!ReceiveBuffer) { return NULL; }

    //
    // Return the updated 'ReceiveBuffer'.
    // Note that any call to 'PPTP_HEADER_FIELD' above may fail
    // if it hits the end of the buffer chain while looking for a field.
    //

    return ReceiveBuffer;

} // NatBuildPseudoHeaderPptp


NTSTATUS
NatClientToServerDataHandlerPptp(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID ReceiveBuffer,
    IN ULONG DataOffset,
    IN IP_NAT_DIRECTION Direction
    )

/*++

Routine Description:

    This routine is invoked for each TCP segment sent from the client
    to the server of a PPTP control channel.

    The routine is responsible for creating PPTP mappings to allow
    the NAT to translate PPTP data-connections, and for translating
    the 'CallId' field of PPTP control-messages.

    We also use the messages seen to detect when tunnels are to be torn down.

Arguments:

    InterfaceHandle - handle to the outgoing NAT_INTERFACE

    SessionHandle - the connection's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    ReceiveBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'ReceiveBuffer

    Direction - the direction of the packet (inbound or outbound)

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    PPTP_PSEUDO_HEADER Header;
    PLIST_ENTRY Link;
    PNAT_PPTP_MAPPING Mapping;
    ULONG PrivateAddress;
    ULONG PublicAddress;
    ULONG RemoteAddress;
    ULONG64 Key;
    NTSTATUS status;

    CALLTRACE(("NatClientToServerDataHandlerPptp\n"));

    //
    // Perform processing for each PPTP control message in the packet
    //

    for (ReceiveBuffer =
         NatBuildPseudoHeaderPptp(RECVBUFFER, &DataOffset, &Header);
         ReceiveBuffer;
         ReceiveBuffer =
         NatBuildPseudoHeaderPptp(RECVBUFFER, &DataOffset, &Header)
         ) {

        //
        // Process any client-to-server messages which require translation
        //

        switch(NTOHS(*Header.MessageType)) {

            case PPTP_OUTGOING_CALL_REQUEST: {
                TRACE(PPTP, ("OutgoingCallRequest\n"));

                //
                // Create a NAT_PPTP_MAPPING for the PPTP session.
                //

                PptpRegisterEditorClient.QueryInfoSession(
                    SessionHandle,
                    &PrivateAddress,
                    NULL,
                    &RemoteAddress,
                    NULL,
                    &PublicAddress,
                    NULL,
                    NULL
                    );

                KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                status =
                    NatCreatePptpMapping(
                        RemoteAddress,
                        PrivateAddress,
                        *Header.CallId,
                        PublicAddress,
                        NULL,
                        Direction,
                        &Mapping
                        );
                if (NT_SUCCESS(status) && NatOutboundDirection == Direction) {

                    //
                    // For outbound messages, 'CallId' corresponds here to
                    // 'PrivateCallId': replace the private call-ID in the message
                    // with the public call-ID allocated in the new mapping.
                    //
                
                    NatEditorEditShortSession(
                        DataHandle, Header.CallId, Mapping->PublicCallId
                        );
                }
                KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                if (!NT_SUCCESS(status)) { return STATUS_UNSUCCESSFUL; }
                break;
            }

            case PPTP_CALL_CLEAR_REQUEST: {

                BOOLEAN Found = FALSE;
                TRACE(PPTP, ("CallClearRequest\n"));

                //
                // Look up the NAT_PPTP_MAPPING for the PPTP session.

                PptpRegisterEditorClient.QueryInfoSession(
                    SessionHandle,
                    &PrivateAddress,
                    NULL,
                    &RemoteAddress,
                    NULL,
                    &PublicAddress,
                    NULL,
                    NULL
                    );

                if( NatOutboundDirection == Direction) {
                
                    //
                    // 'CallId' corresponds here to 'PrivateCallId',
                    // so we retrieve 'PrivateAddress' and 'RemoteAddress',
                    // which together comprise 'PrivateKey', and use that key
                    // to search the inbound-list.
                    //
                    
                    Key = MAKE_PPTP_KEY(RemoteAddress, PrivateAddress);
                    
                    //
                    // Search exhaustively for PrivateCallId in the inbound list.
                    //

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    for (Link = PptpMappingList[NatInboundDirection].Flink;
                         Link != &PptpMappingList[NatInboundDirection];
                         Link = Link->Flink) {
                        Mapping =
                            CONTAINING_RECORD(
                                Link, NAT_PPTP_MAPPING, Link[NatInboundDirection]
                                );
                        if (Key != Mapping->PrivateKey ||
                            *Header.CallId != Mapping->PrivateCallId) {
                            continue;
                        }
                        Found = TRUE; break;
                    }
                    if (Found) {
                        NatEditorEditShortSession(
                            DataHandle, Header.CallId, Mapping->PublicCallId
                            );
                        Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
                    }
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                    if (!Found) { return STATUS_UNSUCCESSFUL; }

                } else {

                    //
                    // 'CallId' corresponds here to 'RemoteCallId',
                    // so we retrieve 'PublicAddress' and 'RemoteAddress',
                    // which together comprise 'PublicKey', and use that key
                    // to search the outbound-list.
                    //
                    
                    Key = MAKE_PPTP_KEY(RemoteAddress, PublicAddress);
                    
                    //
                    // Search exhaustively for RemoteCallId in the outbound list.
                    //

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    for (Link = PptpMappingList[NatOutboundDirection].Flink;
                         Link != &PptpMappingList[NatOutboundDirection];
                         Link = Link->Flink) {
                        Mapping =
                            CONTAINING_RECORD(
                                Link, NAT_PPTP_MAPPING, Link[NatOutboundDirection]
                                );
                        if (Key != Mapping->PublicKey ||
                            *Header.CallId != Mapping->RemoteCallId) {
                            continue;
                        }
                        Found = TRUE; break;
                    }
                    if (Found) {
                        Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
                    }
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                    if (!Found) { return STATUS_UNSUCCESSFUL; }
                }
                    
                break;
            }
        }

        //
        // Advance to the next message, if any
        //

        DataOffset += NTOHS(*Header.PacketLength);
    }

    return STATUS_SUCCESS;

} // NatClientToServerDataHandlerPptp


NTSTATUS
NatDeleteHandlerPptp(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext
    )

/*++

Routine Description:

    This routine is invoked when a PPTP control connection is deleted.
    At this point we queue an executive work-item to mark all PPTP tunnel
    mappings as disconnected. Note that we cannot mark them during this call,
    because to do so we need to acquire the interface lock, and we cannot
    do so from this context, because we are a 'DeleteHandler' and hence
    we may be called with the interface-lock already held.

Arguments:

    SessionHandle - used to obtain information on the session.

    EditorContext - unused

    EditorSessionContext - unused

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    ULONG PrivateAddress;
    ULONG64 PrivateKey;
    ULONG RemoteAddress;
    PPPTP_DELETE_WORK_ITEM WorkItem;

    TRACE(PPTP, ("NatDeleteHandlerPptp\n"));

    //
    // Get information about the session being deleted
    //

    NatQueryInformationMapping(
        (PNAT_DYNAMIC_MAPPING)SessionHandle,
        NULL,
        &PrivateAddress,
        NULL,
        &RemoteAddress,
        NULL,
        NULL,
        NULL,
        NULL
        );

    PrivateKey = MAKE_PPTP_KEY(RemoteAddress, PrivateAddress);

    //
    // Allocate a work-queue item which will mark as disconnected
    // all the tunnels of the control session being deleted
    //

    WorkItem =
        ExAllocatePoolWithTag(
            NonPagedPool, sizeof(PPTP_DELETE_WORK_ITEM), NAT_TAG_WORK_ITEM
            );
    if (!WorkItem) { return STATUS_UNSUCCESSFUL; }

    WorkItem->PrivateKey = PrivateKey;
    WorkItem->IoWorkItem = IoAllocateWorkItem(NatDeviceObject);
    if (!WorkItem->IoWorkItem) {
        ExFreePool(WorkItem);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Queue the work item, and return
    //

    IoQueueWorkItem(
        WorkItem->IoWorkItem,
        NatDeleteHandlerWorkItemPptp,
        DelayedWorkQueue,
        WorkItem
        );

    return STATUS_SUCCESS;

} // NatDeleteHandlerPptp


VOID
NatDeleteHandlerWorkItemPptp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called to complete the deletion of a PPTP control session.
    It marks all the control-session's tunnels as disconnected.

Arguments:

    DeviceObject - unused.

    Context - contains a PPTP_DELETE_WORK_ITEM from 'NatDeleteHandlerPptp'

Return Value:

    none.

--*/

{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_PPTP_MAPPING Mapping;
    PPPTP_DELETE_WORK_ITEM WorkItem;

    TRACE(PPTP, ("NatDeleteHandlerWorkItemPptp\n"));

    WorkItem = (PPPTP_DELETE_WORK_ITEM)Context;
    IoFreeWorkItem(WorkItem->IoWorkItem);

    //
    // All tunnel mappings over the given control connection
    // must now be marked as disconnected.
    // Walk the inbound and outbound list.
    //

    KeAcquireSpinLock(&PptpMappingLock, &Irql);
    
    for (Link = PptpMappingList[NatInboundDirection].Flink;
         Link != &PptpMappingList[NatInboundDirection]; Link = Link->Flink) {
        Mapping =
            CONTAINING_RECORD(
                Link, NAT_PPTP_MAPPING, Link[NatInboundDirection]
                );
        if (WorkItem->PrivateKey != Mapping->PrivateKey) { continue; }
        Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
    }

    for (Link = PptpMappingList[NatOutboundDirection].Flink;
         Link != &PptpMappingList[NatOutboundDirection]; Link = Link->Flink) {
        Mapping =
            CONTAINING_RECORD(
                Link, NAT_PPTP_MAPPING, Link[NatOutboundDirection]
                );
        if (WorkItem->PrivateKey != Mapping->PrivateKey) { continue; }
        Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
    }
    
    KeReleaseSpinLock(&PptpMappingLock, Irql);

    //
    // Delete the work-item
    //

    ExFreePool(WorkItem);

} // NatDeleteHandlerWorkItemPptp


NTSTATUS
NatInboundDataHandlerPptpClient(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    )

/*++

Routine Description:

    This routine is invoked for each TCP segment received by a private
    PPTP client machine

Arguments:

    InterfaceHandle - the receiving NAT_INTERFACE

    SessionHandle - the connection's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    RecvBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'ReceiveBuffer'

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    CALLTRACE(("NatInboundDataHandlerPptpClient\n"));
    
    return
        NatServerToClientDataHandlerPptp(
            InterfaceHandle,
            SessionHandle,
            DataHandle,
            EditorContext,
            EditorSessionContext,
            RecvBuffer,
            DataOffset,
            NatInboundDirection
            );  
} // NatInboundDataHandlerPptpClient


NTSTATUS
NatInboundDataHandlerPptpServer(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    )

/*++

Routine Description:

    This routine is invoked for each TCP segment received by a private
    PPTP server machine

Arguments:

    InterfaceHandle - the receiving NAT_INTERFACE

    SessionHandle - the connection's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    RecvBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'ReceiveBuffer'

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    CALLTRACE(("NatInboundDataHandlerPptpServer\n"));
    
    return
        NatClientToServerDataHandlerPptp(
            InterfaceHandle,
            SessionHandle,
            DataHandle,
            EditorContext,
            EditorSessionContext,
            RecvBuffer,
            DataOffset,
            NatInboundDirection
            );
} // NatInboundDataHandlerPptpServer


NTSTATUS
NatInitializePptpManagement(
    VOID
    )

/*++

Routine Description:

    This routine initializes the PPTP management module and, in the process,
    registers the PPTP control-session editor with the NAT.

Arguments:

    none.

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    NTSTATUS Status;
    CALLTRACE(("NatInitializePptpManangement\n"));

    KeInitializeSpinLock(&PptpMappingLock);
    InitializeListHead(&PptpMappingList[NatInboundDirection]);
    InitializeListHead(&PptpMappingList[NatOutboundDirection]);

    ExInitializeNPagedLookasideList(
        &PptpLookasideList,
        NatAllocateFunction,
        NULL,
        0,
        sizeof(NAT_PPTP_MAPPING),
        NAT_TAG_PPTP,
        PPTP_LOOKASIDE_DEPTH
        );

    PptpRegisterEditorClient.Version = IP_NAT_VERSION;
    PptpRegisterEditorClient.Flags = 0;
    PptpRegisterEditorClient.Protocol = NAT_PROTOCOL_TCP;
    PptpRegisterEditorClient.Port = NTOHS(PPTP_CONTROL_PORT);
    PptpRegisterEditorClient.Direction = NatOutboundDirection;
    PptpRegisterEditorClient.EditorContext = NULL;
    PptpRegisterEditorClient.CreateHandler = NULL;
    PptpRegisterEditorClient.DeleteHandler = NatDeleteHandlerPptp;
    PptpRegisterEditorClient.ForwardDataHandler = NatOutboundDataHandlerPptpClient;
    PptpRegisterEditorClient.ReverseDataHandler = NatInboundDataHandlerPptpClient;
    Status = NatCreateEditor(&PptpRegisterEditorClient);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    PptpRegisterEditorServer.Version = IP_NAT_VERSION;
    PptpRegisterEditorServer.Flags = 0;
    PptpRegisterEditorServer.Protocol = NAT_PROTOCOL_TCP;
    PptpRegisterEditorServer.Port = NTOHS(PPTP_CONTROL_PORT);
    PptpRegisterEditorServer.Direction = NatInboundDirection;
    PptpRegisterEditorServer.EditorContext = NULL;
    PptpRegisterEditorServer.CreateHandler = NULL;
    PptpRegisterEditorServer.DeleteHandler = NatDeleteHandlerPptp;
    PptpRegisterEditorServer.ForwardDataHandler = NatInboundDataHandlerPptpServer;
    PptpRegisterEditorServer.ReverseDataHandler = NatOutboundDataHandlerPptpServer;
    return NatCreateEditor(&PptpRegisterEditorServer);
} // NatInitializePptpManagement


NTSTATUS
NatOutboundDataHandlerPptpClient(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    )

/*++

Routine Description:

    This routine is invoked for each TCP segment sent from a private
    PPTP client machine

Arguments:

    InterfaceHandle - the receiving NAT_INTERFACE

    SessionHandle - the connection's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    RecvBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'ReceiveBuffer'

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    CALLTRACE(("NatOutboundDataHandlerPptpClient\n"));
    
    return
        NatClientToServerDataHandlerPptp(
            InterfaceHandle,
            SessionHandle,
            DataHandle,
            EditorContext,
            EditorSessionContext,
            RecvBuffer,
            DataOffset,
            NatOutboundDirection
            );
} // NatOutboundDataHandlerPptpClient


NTSTATUS
NatOutboundDataHandlerPptpServer(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID RecvBuffer,
    IN ULONG DataOffset
    )

/*++

Routine Description:

    This routine is invoked for each TCP segment sent from a private
    PPTP server machine

Arguments:

    InterfaceHandle - the receiving NAT_INTERFACE

    SessionHandle - the connection's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    RecvBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'ReceiveBuffer'

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    CALLTRACE(("NatOutboundDataHandlerPptpServer\n"));
    
    return
        NatServerToClientDataHandlerPptp(
            InterfaceHandle,
            SessionHandle,
            DataHandle,
            EditorContext,
            EditorSessionContext,
            RecvBuffer,
            DataOffset,
            NatOutboundDirection
            );
} // NatOutboundDataHandlerPptpServer


NTSTATUS
NatServerToClientDataHandlerPptp(
    IN PVOID InterfaceHandle,
    IN PVOID SessionHandle,
    IN PVOID DataHandle,
    IN PVOID EditorContext,
    IN PVOID EditorSessionContext,
    IN PVOID ReceiveBuffer,
    IN ULONG DataOffset,
    IN IP_NAT_DIRECTION Direction
    )

/*++

Routine Description:

    This routine is invoked for each TCP segment sent from the server
    to the client on a PPTP control channel

    The routine is responsible for translating inbound PPTP control messages.
    It also uses the messages seen to detect when tunnels are to be torn down.


Arguments:

    InterfaceHandle - the receiving NAT_INTERFACE

    SessionHandle - the connection's NAT_DYNAMIC_MAPPING

    DataHandle - the packet's NAT_XLATE_CONTEXT

    EditorContext - unused

    EditorSessionContext - unused

    ReceiveBuffer - contains the received packet

    DataOffset - offset of the protocol data in 'ReceiveBuffer'

    Direction - the direction of the segment (inbound or outbound)

Return Value:

    NTSTATUS - indicates success/failure

--*/

{
    PPTP_PSEUDO_HEADER Header;
    PLIST_ENTRY InsertionPoint;
    PLIST_ENTRY Link;
    BOOLEAN Found = FALSE;
    PNAT_PPTP_MAPPING Mapping;
    ULONG PrivateAddress;
    ULONG64 PrivateKey;
    ULONG PublicAddress;
    ULONG64 PublicKey;
    ULONG RemoteAddress;
    NTSTATUS status;

    CALLTRACE(("NatServerToClientDataHandlerPptp\n"));

    //
    // Perform processing for each PPTP control message in the packet
    //

    for (ReceiveBuffer =
         NatBuildPseudoHeaderPptp(RECVBUFFER, &DataOffset, &Header);
         ReceiveBuffer;
         ReceiveBuffer =
         NatBuildPseudoHeaderPptp(RECVBUFFER, &DataOffset, &Header)) {

        //
        // Process any server-to-client messages which require translation
        //

        switch(NTOHS(*Header.MessageType)) {

            case PPTP_OUTGOING_CALL_REPLY: {
                TRACE(PPTP, ("OutgoingCallReply\n"));

                //
                // Look up the NAT_PPTP_MAPPING for the PPTP session,
                // record the peer's call ID, mark the session as open,
                // and possibly translate the 'PeerCallId'
                //

                PptpRegisterEditorClient.QueryInfoSession(
                    SessionHandle,
                    &PrivateAddress,
                    NULL,
                    &RemoteAddress,
                    NULL,
                    &PublicAddress,
                    NULL,
                    NULL
                    );

                PublicKey = MAKE_PPTP_KEY(RemoteAddress, PublicAddress);

                if (NatInboundDirection == Direction) {

                    //
                    // 'PeerCallId' corresponds here to 'PublicCallId',
                    // so search for a mapping using 'PublicKey'
                    //

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    Mapping =
                        NatLookupInboundPptpMapping(
                            PublicKey,
                            *Header.PeerCallId,
                            NULL
                            );
                            
                    if (Mapping
                        && !NAT_PPTP_DISCONNECTED(Mapping)
                        && NAT_PPTP_HALF_OPEN(Mapping)) {

                        ASSERT(0 == Mapping->RemoteCallId);
                        ASSERT(IsListEmpty(&Mapping->Link[NatOutboundDirection]));

                        Mapping->RemoteCallId = *Header.CallId;
                        if (NatLookupOutboundPptpMapping(
                                Mapping->PrivateKey,
                                Mapping->RemoteCallId,
                                &InsertionPoint
                                )) {

                            //
                            // A duplicate exists; disconnect the mapping.
                            //

                            Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
                            Mapping = NULL;
                        } else {

                            //
                            // Insert the mapping on the outbound list.
                            //

                            InsertTailList(
                                InsertionPoint,
                                &Mapping->Link[NatOutboundDirection]
                                );
                            Mapping->Flags &= ~NAT_PPTP_FLAG_HALF_OPEN;
                        }
                    }

                    if (Mapping && !NAT_PPTP_DISCONNECTED(Mapping)) {

                        //
                        // Replace the public call-ID in the message
                        // with the original private call-ID
                        //

                        NatEditorEditShortSession(
                            DataHandle,
                            Header.PeerCallId,
                            Mapping->PrivateCallId
                            );
                    }
                                
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);

                } else {

                    //
                    // 'PeerCallId' corresponds here to 'RemoteCallId',
                    // so we search for a mapping using 'PrivateKey'
                    //

                    PrivateKey = MAKE_PPTP_KEY(RemoteAddress, PrivateAddress);

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    Mapping =
                        NatLookupOutboundPptpMapping(
                            PrivateKey,
                            *Header.PeerCallId,
                            NULL
                            );
                            
                    if (Mapping
                        && !NAT_PPTP_DISCONNECTED(Mapping)
                        && NAT_PPTP_HALF_OPEN(Mapping)) {

                        ASSERT(0 == Mapping->PrivateCallId);
                        ASSERT(0 == Mapping->PublicCallId);
                        ASSERT(IsListEmpty(&Mapping->Link[NatInboundDirection]));

                        Mapping->PrivateCallId = *Header.CallId;

                        //
                        // Allocate a public call ID for the mapping.
                        //

                        status = NatAllocatePublicPptpCallId(
                                    PublicKey,
                                    &Mapping->PublicCallId,
                                    &InsertionPoint
                                    );

                        if (NT_SUCCESS(status)) {

                            //
                            // Insert the mapping on the inbound list and
                            // mark the mapping as fully open
                            //

                            InsertTailList(
                                InsertionPoint,
                                &Mapping->Link[NatInboundDirection]
                                );
                            Mapping->Flags &= ~NAT_PPTP_FLAG_HALF_OPEN;
                                
                        } else {

                            //
                            // Unable to allocate the public call ID --
                            // disconnect the mapping
                            //

                            Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
                            Mapping = NULL;
                        }
                    }

                    if (Mapping && !NAT_PPTP_DISCONNECTED(Mapping)) {

                        //
                        // Translate the call-ID
                        //

                        NatEditorEditShortSession(
                            DataHandle,
                            Header.CallId,
                            Mapping->PublicCallId
                            );
                    }
                        
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                }
                
                if (!Mapping) { return STATUS_UNSUCCESSFUL; }
                break;
            }

            case PPTP_SET_LINK_INFO:
            case PPTP_INCOMING_CALL_CONNECTED:
            case PPTP_WAN_ERROR_NOTIFY: {
                TRACE(PPTP, ("SetLinkInfo|IncomingCallConnected|WanErrorNotify\n"));

                if (NatInboundDirection == Direction) {

                    //
                    // Look up the NAT_PPTP_MAPPING for the PPTP session
                    // and translate the 'CallId' field with the private call-ID
                    // 'CallId' corresponds here to 'PublicCallId',
                    // so we search for a mapping using 'PublicKey'.
                    //

                    PptpRegisterEditorClient.QueryInfoSession(
                        SessionHandle,
                        NULL,
                        NULL,
                        &RemoteAddress,
                        NULL,
                        &PublicAddress,
                        NULL,
                        NULL
                        );

                    PublicKey = MAKE_PPTP_KEY(RemoteAddress, PublicAddress);

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    Mapping =
                        NatLookupInboundPptpMapping(
                            PublicKey,
                            *Header.CallId,
                            NULL
                            );
                    if (Mapping) {
                        NatEditorEditShortSession(
                            DataHandle, Header.CallId, Mapping->PrivateCallId
                            );
                    }
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                    if (!Mapping) { return STATUS_UNSUCCESSFUL; }
                }

                //
                // For the outbound case, CallId refers to the remote call ID,
                // so no translation is necessary.
                //
                
                break;
            }

            case PPTP_CALL_DISCONNECT_NOTIFY: {
                TRACE(PPTP, ("CallDisconnectNotify\n"));

                //
                // Look up the NAT_PPTP_MAPPING for the PPTP session
                // and mark it for deletion.
                //

                PptpRegisterEditorClient.QueryInfoSession(
                    SessionHandle,
                    &PrivateAddress,
                    NULL,
                    &RemoteAddress,
                    NULL,
                    &PublicAddress,
                    NULL,
                    NULL
                    );

                if (NatOutboundDirection == Direction) {
                
                    //
                    // 'CallId' corresponds here to 'PrivateCallId',
                    // so we retrieve 'PrivateAddress' and 'RemoteAddress',
                    // which together comprise 'PrivateKey', and use that key
                    // to search the inbound-list.
                    //
                    
                    PrivateKey = MAKE_PPTP_KEY(RemoteAddress, PrivateAddress);
                    
                    //
                    // Search exhaustively for PrivateCallId in the inbound list.
                    //

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    for (Link = PptpMappingList[NatInboundDirection].Flink;
                         Link != &PptpMappingList[NatInboundDirection];
                         Link = Link->Flink) {
                        Mapping =
                            CONTAINING_RECORD(
                                Link, NAT_PPTP_MAPPING, Link[NatInboundDirection]
                                );
                        if (PrivateKey != Mapping->PrivateKey ||
                            *Header.CallId != Mapping->PrivateCallId) {
                            continue;
                        }
                        Found = TRUE; break;
                    }
                    if (Found) {
                        NatEditorEditShortSession(
                            DataHandle, Header.CallId, Mapping->PublicCallId
                            );
                        Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
                    }
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                    if (!Found) { return STATUS_UNSUCCESSFUL; }

                } else {

                    //
                    // 'CallId' corresponds here to 'RemoteCallId',
                    // so we retrieve 'PublicAddress' and 'RemoteAddress',
                    // which together comprise 'PublicKey', and use that key
                    // to search the outbound-list.
                    //
                    
                    PublicKey = MAKE_PPTP_KEY(RemoteAddress, PublicAddress);
                    
                    //
                    // Search exhaustively for RemoteCallId in the outbound list.
                    //

                    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
                    for (Link = PptpMappingList[NatOutboundDirection].Flink;
                         Link != &PptpMappingList[NatOutboundDirection];
                         Link = Link->Flink) {
                        Mapping =
                            CONTAINING_RECORD(
                                Link, NAT_PPTP_MAPPING, Link[NatOutboundDirection]
                                );
                        if (PublicKey != Mapping->PublicKey ||
                            *Header.CallId != Mapping->RemoteCallId) {
                            continue;
                        }
                        Found = TRUE; break;
                    }
                    if (Found) {
                        Mapping->Flags |= NAT_PPTP_FLAG_DISCONNECTED;
                    }
                    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
                    if (!Found) { return STATUS_UNSUCCESSFUL; }
                }

                break;
            }
        }

        //
        // Advance to the next message, if any
        //

        DataOffset += NTOHS(*Header.PacketLength);
    }

    return STATUS_SUCCESS;

} // NatInboundDataHandlerPptp



VOID
NatShutdownPptpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown operations for the PPTP editor module.
    It handles cleanup of all existing data structures.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatShutdownPptpManagement"));
    ExDeleteNPagedLookasideList(&PptpLookasideList);
} // NatShutdownPptpManagement


FORWARD_ACTION
NatTranslatePptp(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )

/*++

Routine Description:

    This routine is called to translate a PPTP data packet,
    which is encapsulated inside a GRE header.

Arguments:

    Interfacep - the boundary interface over which to translate, or NULL
        if the packet is received on an interface unknown to the NAT.

    Direction - the direction in which the packet is traveling

    Contextp - initialized with context-information for the packet

    InReceiveBuffer - input buffer-chain

    OutReceiveBuffer - receives modified buffer-chain.

Return Value:

    FORWARD_ACTION - indicates action to take on the packet.

Environment:

    Invoked with reference made to 'Interfacep' by the caller.

--*/

{
    FORWARD_ACTION act;
    ULONG Checksum;
    ULONG ChecksumDelta = 0;
    PGRE_HEADER GreHeader;
    ULONG i;
    PIP_HEADER IpHeader;
    PNAT_PPTP_MAPPING Mapping;
    ULONG64 PrivateKey;
    ULONG64 PublicKey;
    BOOLEAN FirewallMode;
    TRACE(XLATE, ("NatTranslatePptp\n"));

    FirewallMode = Interfacep && NAT_INTERFACE_FW(Interfacep);

    IpHeader = Contextp->Header;
    GreHeader = (PGRE_HEADER)Contextp->ProtocolHeader;

    if (Direction == NatInboundDirection) {

        //
        // Look for the PPTP mapping for the data packet
        //

        PublicKey =
            MAKE_PPTP_KEY(
                Contextp->SourceAddress,
                Contextp->DestinationAddress
                );

        KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
        Mapping =
            NatLookupInboundPptpMapping(
                PublicKey,
                GreHeader->CallId,
                NULL
                );

        if (!Mapping) {
            KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);
            return ((*Contextp->DestinationType < DEST_REMOTE) && !FirewallMode
                ? FORWARD : DROP);
        }

        //
        // Translate the private call-ID
        //

        GreHeader->CallId = Mapping->PrivateCallId;

        if (!Contextp->ChecksumOffloaded) {

            CHECKSUM_LONG(ChecksumDelta, ~IpHeader->DestinationAddress);
            IpHeader->DestinationAddress = PPTP_KEY_PRIVATE(Mapping->PrivateKey);
            CHECKSUM_LONG(ChecksumDelta, IpHeader->DestinationAddress);

            CHECKSUM_UPDATE(IpHeader->Checksum);

        } else {

            IpHeader->DestinationAddress = PPTP_KEY_PRIVATE(Mapping->PrivateKey);
            NatComputeIpChecksum(IpHeader);
        }
        
    } else {

        //
        // Look for the PPTP mapping for the data packet
        //

        PrivateKey =
            MAKE_PPTP_KEY(
                Contextp->DestinationAddress,
                Contextp->SourceAddress
                );

        KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
        Mapping =
            NatLookupOutboundPptpMapping(
                PrivateKey,
                GreHeader->CallId,
                NULL
                );

        if (!Mapping) {
            KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);

            if (NULL != Interfacep) {

                //
                // Make sure this packet has a valid source address
                // for this interface.
                //
                
                act = DROP;
                for (i = 0; i < Interfacep->AddressCount; i++) {
                    if (Contextp->SourceAddress ==
                            Interfacep->AddressArray[i].Address
                       ) {
                        act = FORWARD;
                        break;
                    }
                }
            } else {
                act = FORWARD;
            }
            
            return act;
        }

        //
        // For outbound packets the Call-ID is the remote ID,
        // and hence needs no translation.
        //

        if (!Contextp->ChecksumOffloaded) {
        
            CHECKSUM_LONG(ChecksumDelta, ~IpHeader->SourceAddress);
            IpHeader->SourceAddress = PPTP_KEY_PUBLIC(Mapping->PublicKey);
            CHECKSUM_LONG(ChecksumDelta, IpHeader->SourceAddress);

            CHECKSUM_UPDATE(IpHeader->Checksum);
            
        } else {
        
            IpHeader->SourceAddress = PPTP_KEY_PUBLIC(Mapping->PublicKey);
            NatComputeIpChecksum(IpHeader);    
        }
    }

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);

    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NatTranslatePptp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\raw.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    raw.h

Abstract:

    This module contains declarations for translation of raw IP packets,
    i.e. IP packets whose 'protocol field does not contain a recognized
    value.

Author:

    Abolade Gbadegesin (aboladeg)   18-Apr-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   18-Apr-1998

    Based on icmp.h.

--*/

#ifndef _NAT_RAW_H_
#define _NAT_RAW_H_

//
// Structure:   NAT_IP_MAPPING
//
// This structure holds information about a mapping created
// for a raw IP packet.
// Each such mapping is on its interface's lists of mappings.
// The inbound list is sorted on the 'PublicKey' and 'Protocol',
// and the outbound list is sorted on the 'PrivateKey' and 'Protocol'.
//

typedef struct _NAT_IP_MAPPING {
    LIST_ENTRY Link[NatMaximumDirection];
    ULONG64 PublicKey;
    ULONG64 PrivateKey;
    UCHAR Protocol;
    LONG64 LastAccessTime;
} NAT_IP_MAPPING, *PNAT_IP_MAPPING;

//
// IP mapping key macros
//

#define MAKE_IP_KEY(RemoteAddress,OtherAddress) \
    ((ULONG)(RemoteAddress) | ((ULONG64)((ULONG)(OtherAddress)) << 32))

#define IP_KEY_REMOTE(Key)          ((ULONG)(Key))
#define IP_KEY_PRIVATE(Key)         ((ULONG)((Key) >> 32))
#define IP_KEY_PUBLIC(Key)          ((ULONG)((Key) >> 32))

//
// IP mapping allocation macros
//

#define ALLOCATE_IP_BLOCK() \
    ExAllocateFromNPagedLookasideList(&IpLookasideList)

#define FREE_IP_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&IpLookasideList,(Block))

extern NPAGED_LOOKASIDE_LIST IpLookasideList;
extern LIST_ENTRY IpMappingList[NatMaximumDirection];
extern KSPIN_LOCK IpMappingLock;


//
// IP MAPPING MANAGEMENT ROUTINES
//

NTSTATUS
NatCreateIpMapping(
    PNAT_INTERFACE Interfacep,
    ULONG RemoteAddress,
    ULONG PrivateAddress,
    ULONG PublicAddress,
    UCHAR Protocol,
    PLIST_ENTRY InboundInsertionPoint,
    PLIST_ENTRY OutboundInsertionPoint,
    PNAT_IP_MAPPING* MappingCreated
    );

VOID
NatInitializeRawIpManagement(
    VOID
    );

PNAT_IP_MAPPING
NatLookupInboundIpMapping(
    ULONG64 PublicKey,
    UCHAR Protocol,
    PLIST_ENTRY* InsertionPoint
    );

PNAT_IP_MAPPING
NatLookupOutboundIpMapping(
    ULONG64 PrivateKey,
    UCHAR Protocol,
    PLIST_ENTRY* InsertionPoint
    );

VOID
NatShutdownRawIpManagement(
    VOID
    );

XLATE_IP_ROUTINE(NatTranslateIp);

#endif // _NAT_RAW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\redirect.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    redirect.h

Abstract:

    This module contains declarations for the director which supplies
    user-mode applications with the ability to redirect incoming sessions.

    The director receives I/O controls through the NAT's device object,
    instructing it to direct specific sessions or general session-types
    to given destinations. It maintains a list of the outstanding redirects,
    and consults this list whenever the NAT requires direction of a session.

Author:

    Abolade Gbadegesin (aboladeg)   19-Apr-1998

Revision History:

--*/

#ifndef _NAT_REDIRECT_H_
#define _NAT_REDIRECT_H_

typedef enum _NAT_REDIRECT_INFORMATION_CLASS {
    NatStatisticsRedirectInformation=0,
    NatSourceMappingRedirectInformation,
    NatDestinationMappingRedirectInformation,
    NatMaximumRedirectInformation
} NAT_REDIRECT_INFORMATION_CLASS, *PNAT_REDIRECT_INFORMATION_CLASS;

//
// Structure:   NAT_REDIRECT_ACTIVE_PATTERN
//
// This structure encapsulates the pattern used to match packets to
// active redirects.
//

typedef struct _NAT_REDIRECT_ACTIVE_PATTERN {
    ULONG64 DestinationKey;
    ULONG64 SourceKey;
} NAT_REDIRECT_ACTIVE_PATTERN, *PNAT_REDIRECT_ACTIVE_PATTERN;


//
// Structure:   NAT_REDIRECT_PATTERN
//
// This structure encapsulates the pattern used to locate redirects.
//

typedef struct _NAT_REDIRECT_PATTERN {
    ULONG64 DestinationKey[NatMaximumPath];
    ULONG64 SourceKey[NatMaximumPath];
} NAT_REDIRECT_PATTERN, *PNAT_REDIRECT_PATTERN;

//
// Structure:   NAT_REDIRECT_PATTERN_INFO
//
// This structure stores information associated with the patterns that
// we install into the Rhizome. It contains the a list of the redirects
// that match that pattern.
//

typedef struct _NAT_REDIRECT_PATTERN_INFO {
    LIST_ENTRY Link;
    LIST_ENTRY RedirectList;
    PatternHandle Pattern;
} NAT_REDIRECT_PATTERN_INFO, *PNAT_REDIRECT_PATTERN_INFO;


//
// Structure:   NAT_REDIRECT
//
// This structure stores information about a redirect.
// Each entry is on at most two sorted lists of redirects,
// sorted in descending order with the destination and source endpoints
// as the primary and secondary keys, respectively.
// Each key is composed of a protocol number, port number, and address.
//
// Every redirect is on a master list of redirects indexed by 'NatMaximumPath'
// until the redirect is cancelled or its matching session completes.
//
// We support 'partial' redirects, in which the source address and port
// of the matching session is left unspecified. Such redirects are only
// on the 'NatForwardPath' list of redirects, since they will never be
// instantiated in response to a reverse-direction packet.
//
// We also support 'partial restricted' redirects, in which the source address
// of the matching session is specified, but the source port is not.
// As with 'partial' redirects, these are only on the 'NatForwardPath' list
// of redirects.
//
// A redirect may optionally be associated with an IRP.
// In that case, when the redirect's session is terminated,
// the associated IRP is completed, and the caller's output buffer
// is filled with the statistics for the terminated session.
// The IRP for such a redirect is linked into 'RedirectIrpList',
// and the IRP's 'DriverContext' contains a pointer to the redirect.
//
// Whenever 'RedirectLock' and 'InterfaceLock' must both be held,
// 'RedirectLock' must be acquired first.
//

typedef struct _NAT_REDIRECT {
    LIST_ENTRY ActiveLink[NatMaximumPath];
    LIST_ENTRY Link;
    ULONG64 DestinationKey[NatMaximumPath];
    ULONG64 SourceKey[NatMaximumPath];
    PNAT_REDIRECT_PATTERN_INFO ActiveInfo[NatMaximumPath];
    PNAT_REDIRECT_PATTERN_INFO Info;
    Rhizome *ForwardPathRhizome;
    ULONG Flags;
    ULONG RestrictSourceAddress;
    ULONG RestrictAdapterIndex;
    PIRP Irp;
    PFILE_OBJECT FileObject;
    PKEVENT EventObject;
    PVOID SessionHandle;
    IP_NAT_REDIRECT_STATISTICS Statistics;
    IP_NAT_REDIRECT_SOURCE_MAPPING SourceMapping;
    IP_NAT_REDIRECT_DESTINATION_MAPPING DestinationMapping;
    NTSTATUS CleanupStatus;
} NAT_REDIRECT, *PNAT_REDIRECT;

#define NAT_REDIRECT_FLAG_ZERO_SOURCE               0x80000000
#define NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING     0x40000000
#define NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING    0x20000000
#define NAT_REDIRECT_FLAG_DELETION_REQUIRED         0x10000000
#define NAT_REDIRECT_FLAG_DELETION_PENDING          0x08000000
#define NAT_REDIRECT_FLAG_ACTIVATED                 0x04000000

//
// Structure:   NAT_REDIRECT_DELAYED_CLEANUP_CONTEXT
//
// Context block passed to our delayed cleanup worker
// routine
//

typedef struct _NAT_REDIRECT_DELAYED_CLEANUP_CONTEXT {
    PIO_WORKITEM DeleteWorkItem;
    PNAT_REDIRECT Redirectp; 
} NAT_REDIRECT_DELAYED_CLEANUP_CONTEXT, *PNAT_REDIRECT_DELAYED_CLEANUP_CONTEXT;

//
// Redirect-key manipulation macros
//

#define MAKE_REDIRECT_KEY(Protocol,Address,Port) \
    ((ULONG)(Address) | \
    ((ULONG64)((Port) & 0xFFFF) << 32) | \
    ((ULONG64)((Protocol) & 0xFF) << 48))

#define REDIRECT_PROTOCOL(Key)      ((UCHAR)(((Key) >> 48) & 0xFF))
#define REDIRECT_PORT(Key)          ((USHORT)(((Key) >> 32) & 0xFFFF))
#define REDIRECT_ADDRESS(Key)       ((ULONG)(Key))

//
// GLOBAL VARIABLE DECLARATIONS
//

extern ULONG RedirectCount;
extern IP_NAT_REGISTER_DIRECTOR RedirectRegisterDirector;


//
// FUNCTION PROTOTYPES
//

NTSTATUS
NatCancelRedirect(
    PIP_NAT_LOOKUP_REDIRECT CancelRedirect,
    PFILE_OBJECT FileObject
    );

VOID
NatCleanupAnyAssociatedRedirect(
    PFILE_OBJECT FileObject
    );

NTSTATUS
NatCreateRedirect(
    PIP_NAT_CREATE_REDIRECT CreateRedirect,
    PIRP Irp,
    PFILE_OBJECT FileObject
    );

#if _WIN32_WINNT > 0x0500

NTSTATUS
NatCreateRedirectEx(
    PIP_NAT_CREATE_REDIRECT_EX CreateRedirect,
    PIRP Irp,
    PFILE_OBJECT FileObject
    );

#endif

VOID
NatInitializeRedirectManagement(
    VOID
    );

PNAT_REDIRECT
NatLookupRedirect(
    IP_NAT_PATH Path,
    PNAT_REDIRECT_ACTIVE_PATTERN SearchKey,
    ULONG ReceiveIndex,
    ULONG SendIndex,
    ULONG LookupFlags
    );

#define NAT_LOOKUP_FLAG_MATCH_ZERO_SOURCE           0x00000001
#define NAT_LOOKUP_FLAG_MATCH_ZERO_SOURCE_ENDPOINT  0x00000002
#define NAT_LOOKUP_FLAG_PACKET_RECEIVED             0x00000004
#define NAT_LOOKUP_FLAG_PACKET_LOOPBACK             0x00000008

NTSTATUS
NatQueryInformationRedirect(
    PIP_NAT_LOOKUP_REDIRECT QueryRedirect,
    OUT PVOID Information,
    ULONG InformationLength,
    NAT_REDIRECT_INFORMATION_CLASS InformationClass
    );

VOID
NatShutdownRedirectManagement(
    VOID
    );

NTSTATUS
NatStartRedirectManagement(
    VOID
    );

#endif // _NAT_REDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\resource.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This header holds declarations for a shared-resource synchronization object.

Author:

    Abolade Gbadegesin (t-abolag)   11-July-1997

Revision History:

--*/


#ifndef _NAT_RESOURCE_H_
#define _NAT_RESOURCE_H_


//
// NAT_RESOURCE
//
// This structure contains the fields used for shared-exclusive synchronization.
//

typedef struct _NAT_RESOURCE {

    KSPIN_LOCK  ReaderSpinLock;
    LONG        ReaderCount;
    KSPIN_LOCK  WriterSpinLock;
    KIRQL       WriterIrql;

} NAT_RESOURCE, *PNAT_RESOURCE;


//
// RESOURCE ROUTINES
//


#define USES_NAT_RESOURCE() \
    KIRQL _ReaderIrql; \
    KIRQL _WriterIrql


// 
// VOID
// NatInitializeResource(
//    PNAT_RESOURCE   Resource
//    );
//

#define NatInitializeResource(Resource) { \
    (Resource)->ReaderCount = 0; \
    KeInitializeSpinLock(&(Resource)->ReaderSpinLock); \
    KeInitializeSpinLock(&(Resource)->WriterSpinLock); \
}


//
// VOID
// NatAcquireResourceShared(
//     PNAT_RESOURCE   Resource
//     );
//

#define NatAcquireResourceShared(Resource) { \
    KeAcquireSpinLock(&(Resource)->ReaderSpinLock, &_ReaderIrql); \
    if (InterlockedIncrement(&(Resource)->ReaderCount) == 1) { \
        KeAcquireSpinLockAtDpcLevel(&(Resource)->WriterSpinLock); \
    } \
    KeReleaseSpinLockFromDpcLevel(&(Resource)->ReaderSpinLock); \
}


//
// VOID
// NatReleaseResourceShared(
//    PNAT_RESOURCE   Resource
//    );
//

#define NatReleaseResourceShared(Resource) { \
    if (InterlockedDecrement(&(Resource)->ReaderCount) == 0) { \
        KeReleaseSpinLockFromDpcLevel(&(Resource)->WriterSpinLock); \
    } \
    KeLowerIrql(_ReaderIrql); \
}


//
// VOID
// NatAcquireResourceExclusive(
//     PNAT_RESOURCE   Resource
//    );
//

#define NatAcquireResourceExclusive(Resource) \
    KeAcquireSpinLock(&(Resource)->WriterSpinLock, &(Resource)->WriterIrql)


//
// VOID
// NatReleaseResourceExclusive(
//     PNAT_RESOURCE   Resource
//     );
//

#define NatReleaseResourceExclusive(Resource) \
    KeReleaseSpinLock(&(Resource)->WriterSpinLock, (Resource)->WriterIrql)


//
// VOID
// NatConvertSharedToExclusive(
//      PNAT_RESOURCE   Resource
//      );
//

#define NatConvertSharedToExclusive(Resource) { \
    KeAcquireSpinLockAtDpcLevel(&(Resource)->ReaderSpinLock); \
    if (InterlockedDecrement(&(Resource)->ReaderCount) == 0) { \
        KeReleaseSpinLockFromDpcLevel(&(Resource)->ReaderSpinLock); \
    } \
    else { \
        KeReleaseSpinLockFromDpcLevel(&(Resource)->ReaderSpinLock); \
        KeAcquireSpinLockAtDpcLevel(&(Resource)->WriterSpinLock); \
    } \
}


//
// VOID
// NatConvertedExclusiveToShared(
//      PNAT_RESOURCE   Resource
//      );
//

#define NatConvertedExclusiveToShared(Resource) { \
    KeReleaseSpinLockFromDpcLevel(&(Resource)->WriterSpinLock); \
    KeAcquireSpinLockAtDpcLevel(&(Resource)->ReaderSpinLock); \
    if (InterlockedIncrement(&(Resource)->ReaderCount) == 1) { \
        KeAcquireSpinLockAtDpcLevel(&(Resource)->WriterSpinLock); \
    } \
    KeReleaseSpinLockFromDpcLevel(&(Resource)->ReaderSpinLock); \
}


//
// VOID
// NatReleaseConvertedExclusive(
//      PNAT_RESOURCE   Resource
//      );
//

#define NatReleaseConvertedExclusive(Resource) { \
    KeReleaseSpinLock(&(Resource)->WriterSpinLock, _ReaderIrql); \
}


#endif // _NAT_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\redirect.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    redirect.c

Abstract:

    This module contains the implementation of the director which supplies
    user-mode applications with the ability to redirect incoming sessions.

Author:

    Abolade Gbadegesin (aboladeg)   08-May-1998

Revision History:

    Jonathan Burstein (jonburs)     25-April-2000

    Conversion to use rhizome instead of lists for redirect lookup

--*/

#include "precomp.h"
#pragma hdrstop

extern POBJECT_TYPE* ExEventObjectType;

//
// RedirectLock protects all structures except for RedirectCompletionList
// and RedirectIoWorkItem, which are protected by RedirectCompletionLock.
// If both locks must be held at the same time, RedirectLock must be acquired
// first.
//

ULONG RedirectCount;
BOOLEAN RedirectIoCompletionPending;
PIO_WORKITEM RedirectIoWorkItem;
Rhizome RedirectActiveRhizome[NatMaximumPath + 1];
Rhizome RedirectRhizome;
LIST_ENTRY RedirectIrpList;
LIST_ENTRY RedirectCompletionList;
LIST_ENTRY RedirectActiveList;
LIST_ENTRY RedirectList;
KSPIN_LOCK RedirectLock;
KSPIN_LOCK RedirectCompletionLock;
KSPIN_LOCK RedirectInitializationLock;
IP_NAT_REGISTER_DIRECTOR RedirectRegisterDirector;

//
// FORWARD DECLARATIONS
//

VOID
NatpCleanupRedirect(
    PNAT_REDIRECT Redirectp,
    NTSTATUS Status
    );

VOID
NatpRedirectCancelRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
NatpRedirectCreateHandler(
    PVOID SessionHandle,
    PVOID DirectorContext,
    PVOID DirectorSessionContext
    );

VOID
NatpRedirectDelayedCleanupWorkerRoutine(
    PVOID DeviceObject,
    PVOID Context
    );

VOID
NatpRedirectDeleteHandler(
    PVOID SessionHandle,
    PVOID DirectorContext,
    PVOID DirectorSessionContext,
    IP_NAT_DELETE_REASON DeleteReason
    );

VOID
NatpRedirectIoCompletionWorkerRoutine(
    PVOID DeviceObject,
    PVOID Context
    );

NTSTATUS
NatpRedirectQueryHandler(
    PIP_NAT_DIRECTOR_QUERY DirectorQuery
    );

VOID
NatpRedirectUnloadHandler(
    PVOID DirectorContext
    );


NTSTATUS
NatCancelRedirect(
    PIP_NAT_LOOKUP_REDIRECT CancelRedirect,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to cancel a redirect.
    Only redirects with which an IRP is associated can be cancelled.

Arguments:

    CancelRedirect - describes the redirect to be removed

    FileObject - the caller's file-object

Return Value:

    NTSTATUS - NT status code.

--*/

{
    PVOID ApcContext;
    PatternHandle FoundPattern;
    PLIST_ENTRY InfoLink;    
    PNAT_REDIRECT_PATTERN_INFO Infop;
    PIO_COMPLETION_CONTEXT IoCompletion;
    PIRP Irp;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    NAT_REDIRECT_PATTERN Pattern;
    PNAT_REDIRECT Redirectp;

    CALLTRACE(("NatCancelRedirect\n"));

    //
    // Construct the keys used to locate the redirect
    //

    Pattern.DestinationKey[NatForwardPath] =
        MAKE_REDIRECT_KEY(
            CancelRedirect->Protocol,
            CancelRedirect->DestinationAddress,
            CancelRedirect->DestinationPort
            );
    if (!CancelRedirect->NewSourceAddress) {
        Pattern.SourceKey[NatForwardPath] = 0;
        Pattern.DestinationKey[NatReversePath] = 0;
    } else {
        Pattern.SourceKey[NatForwardPath] =
            MAKE_REDIRECT_KEY(
                CancelRedirect->Protocol,
                CancelRedirect->SourceAddress,
                CancelRedirect->SourcePort
                );
        Pattern.DestinationKey[NatReversePath] =
            MAKE_REDIRECT_KEY(
                CancelRedirect->Protocol,
                CancelRedirect->NewSourceAddress,
                CancelRedirect->NewSourcePort
                );
    }
    Pattern.SourceKey[NatReversePath] =
        MAKE_REDIRECT_KEY(
            CancelRedirect->Protocol,
            CancelRedirect->NewDestinationAddress,
            CancelRedirect->NewDestinationPort
            );

    //
    // Search the list of IRP-associated redirects.
    //

    KeAcquireSpinLock(&MappingLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);

    FoundPattern = searchRhizome(&RedirectRhizome, (char*) &Pattern);
    if (!FoundPattern) {
        KeReleaseSpinLockFromDpcLevel(&RedirectLock);
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_UNSUCCESSFUL;
    }

    Infop = GetReferenceFromPatternHandle(FoundPattern);
    
    for (Link = Infop->RedirectList.Flink;
         Link != &Infop->RedirectList;
         Link = Link->Flink
         ) {
        Redirectp = CONTAINING_RECORD(Link, NAT_REDIRECT, Link);
        if ((CancelRedirect->Flags &
                IP_NAT_LOOKUP_REDIRECT_FLAG_MATCH_APC_CONTEXT)
            && Redirectp->Irp
            && Redirectp->Irp->Overlay.AsynchronousParameters.UserApcContext !=
                CancelRedirect->RedirectApcContext) {
            continue;
        }

        if (FileObject != Redirectp->FileObject) {
            KeReleaseSpinLockFromDpcLevel(&RedirectLock);
            KeReleaseSpinLock(&MappingLock, Irql);
            return STATUS_ACCESS_DENIED;
        }
        Mapping = (PNAT_DYNAMIC_MAPPING)Redirectp->SessionHandle;

        if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_IO_COMPLETION) {

            //
            // When I/O completion is requested, the completion status
            // of the redirect's I/O request packet constitutes a guarantee
            // as to whether or not an activation I/O completion packet
            // will be (or has been) queued to the I/O completion port with
            // which a redirect is associated.
            // The code below ensures that STATUS_ABANDONED always indicates
            // that an activation packet will be (or has been) queued,
            // while STATUS_CANCELLED always indicates that no activation
            // packet will be (or has been) queued.
            //

            KeAcquireSpinLockAtDpcLevel(&RedirectCompletionLock);
            if (Redirectp->Flags & NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING) {

                //
                // The create handler has not yet been invoked for this
                // redirect since its activation. Since the call to
                // NatpCleanupRedirect below will schedule deletion,
                // treat this as a non-activated redirect.
                //
                // N.B. When it is eventually invoked, the create handler
                // will detect that deletion is already in progress and
                // it will suppress the activation I/O completion packet.
                //

                KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);
                IoCompletion = NULL;

                NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);

            } else if (Redirectp->Flags &
                        NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING) {

                //
                // The activation I/O completion packet has not yet been
                // queued for this redirect. Since the call to
                // NatpCleanupRedirect below will schedule deletion,
                // the worker routine responsible for queuing the packet
                // will never see this redirect. We will therefore queue
                // the packet ourselves below.
                //
                // Clear the pending-flag, remove the redirect from the 
                // worker routine's list, capture parameters required for
                // queuing the I/O completion packet, and update statistics.
                //

                Redirectp->Flags &= ~NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING;
                RemoveEntryList(&Redirectp->ActiveLink[NatReversePath]);
                InitializeListHead(&Redirectp->ActiveLink[NatReversePath]);
                KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);

                if (IoCompletion = Redirectp->FileObject->CompletionContext) {
                    ApcContext =
                        Redirectp->Irp->
                            Overlay.AsynchronousParameters.UserApcContext;
                    if (Mapping) {
                        NatQueryInformationMapping(
                            Mapping,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            (PIP_NAT_SESSION_MAPPING_STATISTICS)
                                &Redirectp->Statistics
                            );
                    }
                    NatpCleanupRedirect(Redirectp, STATUS_ABANDONED);
                } else {
                    NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);
                }
            } else if (Redirectp->Flags & NAT_REDIRECT_FLAG_ACTIVATED) {

                //
                // The activation I/O completion packet has been queued
                // for this redirect, or will be queued shortly.
                // Update statistics for this redirect, and initiate cleanup.
                //

                KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);
                IoCompletion = NULL;

                if (Mapping) {
                    NatQueryInformationMapping(
                        Mapping,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        (PIP_NAT_SESSION_MAPPING_STATISTICS)
                            &Redirectp->Statistics
                        );
                }
                NatpCleanupRedirect(Redirectp, STATUS_ABANDONED);
            } else {

                //
                // This redirect was never activated.
                //

                KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);
                IoCompletion = NULL;
                NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);
            }
        } else {
            IoCompletion = NULL;
            NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);
        }
        
        KeReleaseSpinLockFromDpcLevel(&RedirectLock);
        if (Mapping) {
            NatDeleteMapping(Mapping);
        }
        KeReleaseSpinLock(&MappingLock, Irql);

        if (IoCompletion) {
            PAGED_CODE();
            IoSetIoCompletion(
                IoCompletion->Port,
                IoCompletion->Key,
                ApcContext,
                STATUS_PENDING,
                0,
                FALSE
                );
        }

        return STATUS_SUCCESS;
    }

    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
    KeReleaseSpinLock(&MappingLock, Irql);
    return STATUS_UNSUCCESSFUL;
} // NatCancelRedirect


VOID
NatCleanupAnyAssociatedRedirect(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to clean up any redirect that is associated
    with the given file-object.

Arguments:

    FileObject - the file-object whose redirects are to be cleaned up

Return Value:

    none.

--*/

{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PLIST_ENTRY InfoLink;
    PLIST_ENTRY EndLink;
    PNAT_REDIRECT Redirectp;
    PNAT_REDIRECT_PATTERN_INFO Infop;
    PNAT_DYNAMIC_MAPPING Mapping;
    CALLTRACE(("NatCleanupAnyAssociatedRedirect\n"));

    //
    // Search the list of redirects for any associated with this file-object.
    // As NatpCleanupRedirect may delete the infoblock that the redirect was
    // associated with, we need to be a bit careful in our traversal routines
    // to ensure that we never touch freed memory.
    //

    KeAcquireSpinLock(&MappingLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);
    InfoLink = RedirectList.Flink;
    while (InfoLink != &RedirectList) {

        Infop = CONTAINING_RECORD(InfoLink, NAT_REDIRECT_PATTERN_INFO, Link);
        InfoLink = InfoLink->Flink;

        Link = Infop->RedirectList.Flink;
        EndLink = &Infop->RedirectList;
        while (Link != EndLink) {

            Redirectp = CONTAINING_RECORD(Link, NAT_REDIRECT, Link);
            Link = Link->Flink;
            
            if (Redirectp->FileObject != FileObject) { continue; }
            Mapping = (PNAT_DYNAMIC_MAPPING)Redirectp->SessionHandle;
            NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);
            if (Mapping) {
                NatDeleteMapping(Mapping);
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
    KeReleaseSpinLock(&MappingLock, Irql);
} // NatCleanupAnyAssociatedRedirect


NTSTATUS
NatCreateRedirect(
    PIP_NAT_CREATE_REDIRECT CreateRedirect,
    PIRP Irp,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to install a redirect in the list of redirects.

Arguments:

    CreateRedirect - describes the redirect to be installed

    Irp - optionally associates the IRP with the redirect

    FileObject - contains the file object of the redirect's owner;
        when this file-object is closed, all associated redirects are cancelled.

Return Value:

    NTSTATUS - NT status code.

--*/

{
    IP_NAT_CREATE_REDIRECT_EX CreateRedirectEx;

    CreateRedirectEx.Flags = CreateRedirect->Flags;
    CreateRedirectEx.NotifyEvent = CreateRedirect->NotifyEvent;
    CreateRedirectEx.RestrictSourceAddress =
        CreateRedirect->RestrictSourceAddress;
    CreateRedirectEx.RestrictAdapterIndex = INVALID_IF_INDEX;
    CreateRedirectEx.Protocol = CreateRedirect->Protocol;
    CreateRedirectEx.SourceAddress = CreateRedirect->SourceAddress;
    CreateRedirectEx.SourcePort = CreateRedirect->SourcePort;
    CreateRedirectEx.DestinationAddress = CreateRedirect->DestinationAddress;
    CreateRedirectEx.DestinationPort = CreateRedirect->DestinationPort;
    CreateRedirectEx.NewSourceAddress = CreateRedirect->NewSourceAddress;
    CreateRedirectEx.NewSourcePort = CreateRedirect->NewSourcePort;
    CreateRedirectEx.NewDestinationAddress =
        CreateRedirect->NewDestinationAddress;
    CreateRedirectEx.NewDestinationPort = CreateRedirect->NewDestinationPort;
    

    return NatCreateRedirectEx(
                &CreateRedirectEx,
                Irp,
                FileObject
                );
                
} // NatCreateRedirect


NTSTATUS
NatCreateRedirectEx(
    PIP_NAT_CREATE_REDIRECT_EX CreateRedirect,
    PIRP Irp,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to install a redirect in the list of redirects.

Arguments:

    CreateRedirect - describes the redirect to be installed

    Irp - optionally associates the IRP with the redirect

    FileObject - contains the file object of the redirect's owner;
        when this file-object is closed, all associated redirects are cancelled.

Return Value:

    NTSTATUS - NT status code.

--*/

{
    ULONG64 DestinationKey[NatMaximumPath];
    PNAT_REDIRECT Duplicate;
    PKEVENT EventObject;
    PLIST_ENTRY InsertionPoint[NatMaximumPath];
    KIRQL Irql;
    PNAT_REDIRECT Redirectp;
    ULONG64 SourceKey[NatMaximumPath];
    NAT_REDIRECT_ACTIVE_PATTERN Pattern;
    NAT_REDIRECT_ACTIVE_PATTERN Mask;
    NAT_REDIRECT_ACTIVE_PATTERN MaskedPattern;
    NAT_REDIRECT_PATTERN InfoPattern;
    NAT_REDIRECT_PATTERN InfoMask;
    PNAT_REDIRECT_PATTERN_INFO ForwardInfop = NULL;
    PNAT_REDIRECT_PATTERN_INFO ReverseInfop = NULL;
    PNAT_REDIRECT_PATTERN_INFO Infop = NULL;
    Rhizome *ForwardPathRhizomep;
    PatternHandle ResultPattern;
    BOOLEAN ForwardInstalled = FALSE;
    BOOLEAN GlobalInstalled = FALSE;
    ULONG i;
    NTSTATUS status;

    CALLTRACE(("NatCreateRedirect\n"));

    //
    // Validate parameters;
    // We only handle TCP and UDP
    //

    if ((CreateRedirect->Protocol != NAT_PROTOCOL_TCP &&
         CreateRedirect->Protocol != NAT_PROTOCOL_UDP)) {
         
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verification of source and destination parameters depends on
    // if this is marked as a source redirect.
    //

    if (!(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_SOURCE_REDIRECT)) {

        // All destination fields must be present, except in the case
        // of a port-redirect wherein the destination address
        // may be absent.

        if ((!CreateRedirect->DestinationAddress &&
             !(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_PORT_REDIRECT)) ||
            !CreateRedirect->NewDestinationAddress ||
            !CreateRedirect->DestinationPort ||
            !CreateRedirect->NewDestinationPort) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        // N.B. The source port may be unspecified to support H.323 proxy.
        // See 'NatLookupRedirect' below for further notes on this support,
        // noting the 'MATCH_ZERO_SOURCE_ENDPOINT' flag.
        // Also see 'NatpRedirectQueryHandler' where the source-port is recorded
        // at instantiation-time.
        //

        if (!CreateRedirect->SourceAddress && CreateRedirect->SourcePort) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // The replacement source may be left unspecified, e.g. for a ticket.
        // This means the address and port may be both specified or both zero,
        // but nothing else.
        // If the replacement source is unspecified then the source must also
        // be unspecified.
        //

        if ((!!CreateRedirect->NewSourceAddress ^ !!CreateRedirect->NewSourcePort)
            || (!CreateRedirect->NewSourceAddress &&
            (CreateRedirect->SourceAddress || CreateRedirect->SourcePort))) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // If the port-redirect flag is specified, only the destination-port
        // and replacement destination endpoint may be specified.
        //

        if ((CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_PORT_REDIRECT) &&
            (CreateRedirect->DestinationAddress ||
             CreateRedirect->SourceAddress || CreateRedirect->SourcePort ||
             CreateRedirect->NewSourceAddress || CreateRedirect->NewSourcePort)) {
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // * The source address must be specified, unless
        //   NatRedirectFlagPortRedirect is specified
        // * The source port must be specified
        // * No destination information may be specified
        //

        if ((!CreateRedirect->SourceAddress
             && !(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_PORT_REDIRECT))
            || !CreateRedirect->SourcePort
            || CreateRedirect->DestinationAddress
            || CreateRedirect->DestinationPort) {
            
            return STATUS_INVALID_PARAMETER;
        }

        //
        // The replacement destination address and port are both specified
        // or unspecified
        //

        if (!!CreateRedirect->NewDestinationAddress
            ^ !!CreateRedirect->NewDestinationPort) {
            return STATUS_INVALID_PARAMETER;
        }

        // The replacement source address and port must be specified,
        // unless the port-redirect flag is set
        //

        if ((!CreateRedirect->NewSourceAddress
             || !CreateRedirect->NewSourcePort)
            && !(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_PORT_REDIRECT)) {

            return STATUS_INVALID_PARAMETER;
        }



        //
        // If the port-redirect flag is specified, the caller is specifying
        // only the source port, replacement destination address, and
        // replacement destination port
        //

        if ((CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_PORT_REDIRECT)
            && (CreateRedirect->SourceAddress
                || CreateRedirect->DestinationAddress
                || CreateRedirect->DestinationPort
                || CreateRedirect->NewSourceAddress
                || CreateRedirect->NewSourcePort)) {
                
            return STATUS_INVALID_PARAMETER;
        }

        //
        // The restrict-source-address flag is invalid
        //

        if (CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_RESTRICT_SOURCE) {
            return STATUS_INVALID_PARAMETER;
        }

    }

    //
    // Unidirectional flows are only supported for UDP
    //

    if ((CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_UNIDIRECTIONAL) &&
        CreateRedirect->Protocol != NAT_PROTOCOL_UDP) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the restrict-source flag is specified, the restrict-source-address
    // must be specified.
    //

    if  ((CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_RESTRICT_SOURCE) &&
        !CreateRedirect->RestrictSourceAddress) {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // If the restrict adapter index flag is specified, the specified index
    // must not equal INVALID_IF_INDEX
    //

    if ((CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_RESTRICT_ADAPTER) &&
        CreateRedirect->RestrictAdapterIndex == INVALID_IF_INDEX) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the caller wants the request to complete asynchronously,
    // make sure we arrive here via the slow-path with an IRP supplied.
    // If the caller wants notification when the redirect is used,
    // make sure that the request is asynchronous.
    //

    if (!CreateRedirect->NotifyEvent) {
        EventObject = NULL;
    } else if (!Irp) {
        return STATUS_PENDING;
    } else {
        status =
            ObReferenceObjectByHandle(
                CreateRedirect->NotifyEvent,
                EVENT_MODIFY_STATE,
                *ExEventObjectType,
                Irp->RequestorMode,
                &EventObject,
                NULL
                );
        if (!NT_SUCCESS(status)) {
            return status;
        } else {
            KeClearEvent(EventObject);
        }
    }

    //
    // Ensure redirect-management is started
    //

    status = NatStartRedirectManagement();
    if (!NT_SUCCESS(status)) {
        TRACE(
            REDIRECT, (
            "NatCreateRedirect: NatStartRedirectManagement=%x\n", status
            ));
        if (EventObject) { ObDereferenceObject(EventObject); }
        return status;
    }

    TRACE(
        REDIRECT, (
        "NatCreateRedirect: Fwd=%u.%u.%u.%u/%u %u.%u.%u.%u/%u\n",
        ADDRESS_BYTES(CreateRedirect->DestinationAddress),
        NTOHS(CreateRedirect->DestinationPort),
        ADDRESS_BYTES(CreateRedirect->SourceAddress),
        NTOHS(CreateRedirect->SourcePort)
        ));
    TRACE(
        REDIRECT, (
        "NatCreateRedirect: Rev=%u.%u.%u.%u/%u %u.%u.%u.%u/%u\n",
        ADDRESS_BYTES(CreateRedirect->NewSourceAddress),
        NTOHS(CreateRedirect->NewSourcePort),
        ADDRESS_BYTES(CreateRedirect->NewDestinationAddress),
        NTOHS(CreateRedirect->NewDestinationPort)
        ));
    TRACE(
        REDIRECT, (
        "NatCreateRedirect: Flags=0x%x, RestrictAdapter=0x%x\n",
        CreateRedirect->Flags,
        CreateRedirect->RestrictAdapterIndex
        ));

    //
    // Construct the search keys for the redirect.
    //

    if (!(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_SOURCE_REDIRECT)) {

        DestinationKey[NatForwardPath] =
            MAKE_REDIRECT_KEY(
                CreateRedirect->Protocol,
                CreateRedirect->DestinationAddress,
                CreateRedirect->DestinationPort
                );
        if (!CreateRedirect->NewSourceAddress) {
            SourceKey[NatForwardPath] = 0;
            DestinationKey[NatReversePath] = 0;
        } else {
            SourceKey[NatForwardPath] =
                MAKE_REDIRECT_KEY(
                    CreateRedirect->Protocol,
                    CreateRedirect->SourceAddress,
                    CreateRedirect->SourcePort
                    );
            DestinationKey[NatReversePath] =
                MAKE_REDIRECT_KEY(
                    CreateRedirect->Protocol,
                    CreateRedirect->NewSourceAddress,
                    CreateRedirect->NewSourcePort
                    );
        }
        SourceKey[NatReversePath] =
            MAKE_REDIRECT_KEY(
                CreateRedirect->Protocol,
                CreateRedirect->NewDestinationAddress,
                CreateRedirect->NewDestinationPort
                );

        ForwardPathRhizomep = &RedirectActiveRhizome[NatForwardPath];

    } else {

        SourceKey[NatForwardPath] =
            MAKE_REDIRECT_KEY(
                CreateRedirect->Protocol,
                CreateRedirect->SourceAddress,
                CreateRedirect->SourcePort
                );

        if (!CreateRedirect->NewDestinationAddress) {
            DestinationKey[NatForwardPath] = 0;
            SourceKey[NatReversePath] = 0;
        } else {
            DestinationKey[NatForwardPath] =
                MAKE_REDIRECT_KEY(
                    CreateRedirect->Protocol,
                    CreateRedirect->DestinationAddress,
                    CreateRedirect->DestinationPort
                    );
            SourceKey[NatReversePath] =
                MAKE_REDIRECT_KEY(
                    CreateRedirect->Protocol,
                    CreateRedirect->NewDestinationAddress,
                    CreateRedirect->NewDestinationPort
                    );
        }

        DestinationKey[NatReversePath] =
            MAKE_REDIRECT_KEY(
                CreateRedirect->Protocol,
                CreateRedirect->NewSourceAddress,
                CreateRedirect->NewSourcePort
                );

        ForwardPathRhizomep = &RedirectActiveRhizome[NatMaximumPath];
    }

    //
    // Make sure there is no duplicate of the redirect.
    // We allow redirects to have the same key in the forward path
    // to support H.323 proxy which receives multiple sessions
    // on the same local endpoint. However, all such redirects
    // must translate to a different session in the reverse path.
    //

    RtlZeroMemory(&Pattern, sizeof(Pattern));
    RtlZeroMemory(&Mask, sizeof(Mask));
    
    Mask.SourceKey = MAKE_REDIRECT_KEY((UCHAR)~0, (ULONG)~0, (USHORT)~0);
    Mask.DestinationKey = MAKE_REDIRECT_KEY((UCHAR)~0, (ULONG)~0, (USHORT)~0);

    KeAcquireSpinLock(&RedirectLock, &Irql);

    //
    // Install the redirect on the reverse path. We skip this step for
    // redirects that don't have a specified source address (ticket),
    // or that are source-redirects
    //

    if (!(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_SOURCE_REDIRECT)
        && CreateRedirect->NewSourceAddress) {

        Pattern.SourceKey = SourceKey[NatReversePath];
        Pattern.DestinationKey = DestinationKey[NatReversePath];
        
        if (ResultPattern =
                searchRhizome(
                    &RedirectActiveRhizome[NatReversePath],
                    (char*) &Pattern)
                    ) {

            //
            // We got a match. However, the pattern for the new redirect may
            // be more specific than what we matched, so we need to compare
            // the patterns to see if they are actually identical.
            //
            // We can't compare directly with our pattern, though, as the
            // stored pattern has already been masked. This means that we
            // must compare with a masked version of our pattern.
            //

            for (i = 0; i < sizeof(Pattern) / sizeof(char); i++) {
                ((char*)&MaskedPattern)[i] =
                    ((char*)&Pattern)[i] & ((char*)&Mask)[i];
            }

            if (!memcmp(
                    &MaskedPattern,
                    GetKeyPtrFromPatternHandle(
                        &RedirectActiveRhizome[NatReversePath], 
                        ResultPattern
                        ),
                    sizeof(Pattern)
                    )) {
                KeReleaseSpinLock(&RedirectLock, Irql);
                TRACE(REDIRECT, ("NatCreateRedirect: duplicate found\n"));
                if (EventObject) { ObDereferenceObject(EventObject); }
                return STATUS_UNSUCCESSFUL;
            }
        }

        //
        // The redirect is unique on the reverse path. Allocate memory for
        // the reverse path info block.
        //

        ReverseInfop =
            ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(NAT_REDIRECT_PATTERN_INFO),
                NAT_TAG_REDIRECT
                );
        if (!ReverseInfop) {
            KeReleaseSpinLock(&RedirectLock, Irql);
            TRACE(REDIRECT, ("NatCreateRedirect: allocation failed\n"));
            if (EventObject) { ObDereferenceObject(EventObject); }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Install the correct pattern
        //

        ReverseInfop->Pattern = 
            insertRhizome(
                &RedirectActiveRhizome[NatReversePath],
                (char*) &Pattern,
                (char*) &Mask,
                ReverseInfop,
                &status
                );
        if (!ReverseInfop->Pattern) {
            KeReleaseSpinLock(&RedirectLock, Irql);
            TRACE(REDIRECT, ("NatCreateRedirect: Reverse 0x%08x\n", status));
            if (EventObject) { ObDereferenceObject(EventObject); }
            ExFreePool(ReverseInfop);
            return status;
        }

        InitializeListHead(&ReverseInfop->RedirectList);
        InitializeListHead(&ReverseInfop->Link);
    }

    //
    // See if we already have a pattern installed for the forward path
    //

    Pattern.SourceKey = SourceKey[NatForwardPath];
    Pattern.DestinationKey = DestinationKey[NatForwardPath];

    if (!Pattern.SourceKey) {
        Mask.SourceKey = 0;
    } else {
        if (!REDIRECT_ADDRESS(Pattern.SourceKey)) {
            Mask.SourceKey &=
                MAKE_REDIRECT_KEY((UCHAR)~0, 0, (USHORT)~0);
        }
        if (!REDIRECT_PORT(Pattern.SourceKey)) {
            Mask.SourceKey &=
                MAKE_REDIRECT_KEY((UCHAR)~0, (ULONG)~0, 0);
        }
        if (!REDIRECT_PROTOCOL(Pattern.SourceKey)) {
            Mask.SourceKey &=
                MAKE_REDIRECT_KEY(0, (ULONG)~0, (USHORT)~0);
        }
    }

    if (!Pattern.DestinationKey) {
        Mask.DestinationKey = 0;
    } else {
        if (!REDIRECT_ADDRESS(Pattern.DestinationKey)) {
            Mask.DestinationKey &=
                MAKE_REDIRECT_KEY((UCHAR)~0, 0, (USHORT)~0);
        }
        if (!REDIRECT_PORT(Pattern.DestinationKey)) {
            Mask.DestinationKey &=
                MAKE_REDIRECT_KEY((UCHAR)~0, (ULONG)~0, 0);
        }
        if (!REDIRECT_PROTOCOL(Pattern.DestinationKey)) {
            Mask.DestinationKey &=
                MAKE_REDIRECT_KEY(0, (ULONG)~0, (USHORT)~0);
        }
    }

    if (ResultPattern =
            searchRhizome(
                ForwardPathRhizomep,
                (char*) &Pattern)
                ) {

        //
        // We got a match. However, the pattern for the new redirect may
        // be more specific than what we matched, so we need to compare
        // the patterns to see if they are actually identical
        //
        // We can't compare directly with our pattern, though, as the
        // stored pattern has already been masked. This means that we
        // must compare with a masked version of our pattern.
        //

        for (i = 0; i < sizeof(Pattern) / sizeof(char); i++) {
            ((char*)&MaskedPattern)[i] =
                ((char*)&Pattern)[i] & ((char*)&Mask)[i];
        }

        if (!memcmp(
                &MaskedPattern,
                GetKeyPtrFromPatternHandle(
                    ForwardPathRhizomep,
                    ResultPattern
                    ),
                sizeof(Pattern)
                )) {

            //
            // The patterns are identical -- can use the same info block
            //

            ForwardInfop = GetReferenceFromPatternHandle(ResultPattern);
        }
    }

    if (!ForwardInfop) {

        //
        // Forward pattern doesn't exist -- install now
        //

        ForwardInfop =
            ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(NAT_REDIRECT_PATTERN_INFO),
                NAT_TAG_REDIRECT
                );
        if (!ForwardInfop) {
            KeReleaseSpinLock(&RedirectLock, Irql);
            TRACE(REDIRECT, ("NatCreateRedirect: allocation failed\n"));
            if (EventObject) { ObDereferenceObject(EventObject); }
            if (ReverseInfop) {
                removeRhizome(
                    &RedirectActiveRhizome[NatReversePath],
                    ReverseInfop->Pattern
                    );
                ExFreePool(ReverseInfop);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ForwardInfop->Pattern = 
            insertRhizome(
                ForwardPathRhizomep,
                (char*) &Pattern,
                (char*) &Mask,
                ForwardInfop,
                &status
                );
        if (!ForwardInfop->Pattern) {
            KeReleaseSpinLock(&RedirectLock, Irql);
            TRACE(REDIRECT, ("NatCreateRedirect: Forward 0x%08x\n", status));
            if (EventObject) { ObDereferenceObject(EventObject); }
            if (ReverseInfop) {
                removeRhizome(
                    &RedirectActiveRhizome[NatReversePath],
                    ReverseInfop->Pattern
                    );
                ExFreePool(ReverseInfop);
            }
            ExFreePool(ForwardInfop);
            return status;
        }

        InitializeListHead(&ForwardInfop->RedirectList);
        InsertTailList(&RedirectActiveList, &ForwardInfop->Link);
        ForwardInstalled = TRUE;
    }

    //
    // See if we already have a pattern installed for the global list
    //

    RtlCopyMemory(InfoPattern.SourceKey, SourceKey, sizeof(SourceKey));
    RtlCopyMemory(InfoPattern.DestinationKey, DestinationKey, sizeof(DestinationKey));

    if (ResultPattern =
            searchRhizome(&RedirectRhizome, (char*) &InfoPattern)) {

        //
        // We got a match. For global blocks, we don't need to perform
        // any masking or check for a less specific pattern, as we're
        // using all of the bits in the pattern.
        //

        Infop = GetReferenceFromPatternHandle(ResultPattern);
    }

    if (!Infop) {

        //
        // Global pattern doesn't exist -- install now
        //

       Infop =
            ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(NAT_REDIRECT_PATTERN_INFO),
                NAT_TAG_REDIRECT
                );
        if (!Infop) {
            KeReleaseSpinLock(&RedirectLock, Irql);
            TRACE(REDIRECT, ("NatCreateRedirect: allocation failed\n"));
            if (EventObject) { ObDereferenceObject(EventObject); }
            if (ReverseInfop) {
                removeRhizome(
                    &RedirectActiveRhizome[NatReversePath],
                    ReverseInfop->Pattern
                    );
                ExFreePool(ReverseInfop);
            }
            if (ForwardInstalled) {
                removeRhizome(
                    ForwardPathRhizomep,
                    ForwardInfop->Pattern
                    );
                RemoveEntryList(&ForwardInfop->Link);
                ExFreePool(ForwardInfop);
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlFillMemory(&InfoMask, sizeof(InfoMask), 1);

        Infop->Pattern = 
            insertRhizome(
                &RedirectRhizome,
                (char*) &InfoPattern,
                (char*) &InfoMask,
                Infop,
                &status
                );
        if (!Infop->Pattern) {
            KeReleaseSpinLock(&RedirectLock, Irql);
            TRACE(REDIRECT, ("NatCreateRedirect: global pattern install\n"));
            if (EventObject) { ObDereferenceObject(EventObject); }
            if (ReverseInfop) {
                removeRhizome(
                    &RedirectActiveRhizome[NatReversePath],
                    ReverseInfop->Pattern
                    );
                ExFreePool(ReverseInfop);
            }
            if (ForwardInstalled) {
                removeRhizome(
                    ForwardPathRhizomep,
                    ForwardInfop->Pattern
                    );
                RemoveEntryList(&ForwardInfop->Link);
                ExFreePool(ForwardInfop);
            }
            ExFreePool(Infop);
            return status;
        }

        InitializeListHead(&Infop->RedirectList);
        InsertTailList(&RedirectList, &Infop->Link);
        GlobalInstalled = TRUE;
    }
    
    //
    // Allocate memory for the redirect
    //

    Redirectp =
        ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(*Redirectp),
            NAT_TAG_REDIRECT
            );
    if (!Redirectp) {
        KeReleaseSpinLock(&RedirectLock, Irql);
        TRACE(REDIRECT, ("NatCreateRedirect: allocation failed\n"));
        if (EventObject) { ObDereferenceObject(EventObject); }
        if (ReverseInfop) {
            removeRhizome(
                &RedirectActiveRhizome[NatReversePath],
                ReverseInfop->Pattern
                );
            ExFreePool(ReverseInfop);
        }
        if (ForwardInstalled) {
            removeRhizome(
                ForwardPathRhizomep,
                ForwardInfop->Pattern
                );
            RemoveEntryList(&ForwardInfop->Link);
            ExFreePool(ForwardInfop);
        }
        if (GlobalInstalled) {
            removeRhizome(&RedirectRhizome, Infop->Pattern);
            RemoveEntryList(&Infop->Link);
            ExFreePool(Infop);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the redirect
    //

    RtlZeroMemory(Redirectp, sizeof(*Redirectp));
    if (Irp) {
        KIRQL CancelIrql;

        //
        // Store the IRP in the redirect, ensuring first that the IRP
        // has not already been cancelled.
        //

        IoAcquireCancelSpinLock(&CancelIrql);
        if (Irp->Cancel || !REFERENCE_NAT()) {
            IoReleaseCancelSpinLock(CancelIrql);
            KeReleaseSpinLock(&RedirectLock, Irql);
            ExFreePool(Redirectp);
            if (EventObject) { ObDereferenceObject(EventObject); }
            if (ReverseInfop) {
                removeRhizome(
                    &RedirectActiveRhizome[NatReversePath],
                    ReverseInfop->Pattern
                    );
                ExFreePool(ReverseInfop);
            }
            if (ForwardInstalled) {
                removeRhizome(
                    ForwardPathRhizomep,
                    ForwardInfop->Pattern
                    );
                RemoveEntryList(&ForwardInfop->Link);
                ExFreePool(ForwardInfop);
            }
            if (GlobalInstalled) {
                removeRhizome(&RedirectRhizome, Infop->Pattern);
                RemoveEntryList(&Infop->Link);
                ExFreePool(Infop);
            }
            return STATUS_CANCELLED;
        }

        //
        // Mark the IRP as pending and install our cancel-routine
        //

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, NatpRedirectCancelRoutine);
        IoReleaseCancelSpinLock(CancelIrql);

        //
        // Store the redirect in the IRP's 'DriverContext' field
        // and store the IRP in the redirect's 'Irp' field.
        //

        InsertTailList(&RedirectIrpList, &Irp->Tail.Overlay.ListEntry);
        Irp->Tail.Overlay.DriverContext[0] = Redirectp;
        Redirectp->Irp = Irp;
    }
    Redirectp->Flags = CreateRedirect->Flags;
    Redirectp->FileObject = FileObject;
    Redirectp->EventObject = EventObject;
    RtlCopyMemory(
        Redirectp->DestinationKey,
        DestinationKey,
        sizeof(DestinationKey)
        );
    RtlCopyMemory(
        Redirectp->SourceKey,
        SourceKey,
        sizeof(SourceKey)
        );
    Redirectp->RestrictSourceAddress = CreateRedirect->RestrictSourceAddress;
    Redirectp->DestinationMapping.DestinationAddress =
        CreateRedirect->DestinationAddress;
    Redirectp->DestinationMapping.DestinationPort =
        CreateRedirect->DestinationPort;
    Redirectp->DestinationMapping.NewDestinationAddress =
        CreateRedirect->NewDestinationAddress;
    Redirectp->DestinationMapping.NewDestinationPort =
        CreateRedirect->NewDestinationPort;
    Redirectp->SourceMapping.SourceAddress = CreateRedirect->SourceAddress;
    Redirectp->SourceMapping.SourcePort = CreateRedirect->SourcePort;
    Redirectp->SourceMapping.NewSourceAddress =
        CreateRedirect->NewSourceAddress;
    Redirectp->SourceMapping.NewSourcePort = CreateRedirect->NewSourcePort;
    Redirectp->RestrictAdapterIndex = CreateRedirect->RestrictAdapterIndex;

    //
    // Record which forward rhizome we're on.
    //

    Redirectp->ForwardPathRhizome = ForwardPathRhizomep;

    //
    // Insert onto the correct infoblock lists
    //

    Redirectp->ActiveInfo[NatForwardPath] = ForwardInfop;
    InsertHeadList(
        &ForwardInfop->RedirectList,
        &Redirectp->ActiveLink[NatForwardPath]
        );
    
    if (!(CreateRedirect->Flags & IP_NAT_REDIRECT_FLAG_SOURCE_REDIRECT)
        && CreateRedirect->NewSourceAddress) {    
        Redirectp->ActiveInfo[NatReversePath] = ReverseInfop;
        InsertHeadList(
            &ReverseInfop->RedirectList,
            &Redirectp->ActiveLink[NatReversePath]
            );
    } else {
        InitializeListHead(&Redirectp->ActiveLink[NatReversePath]);
    }

    Redirectp->Info = Infop;
    InsertHeadList(&Infop->RedirectList, &Redirectp->Link);

    KeReleaseSpinLock(&RedirectLock, Irql);
    InterlockedIncrement(&RedirectCount);

    return (Irp ? STATUS_PENDING : STATUS_SUCCESS);

} // NatCreateRedirect


VOID
NatInitializeRedirectManagement(
    VOID
    )

/*++

Routine Description:

    This routine initializes state for the redirect-manager.

Arguments:

    none.

Return Value:

    none.

--*/

{
    NTSTATUS Status;
    CALLTRACE(("NatInitializeRedirectManagement\n"));

    RedirectCount = 0;
    RedirectIoCompletionPending = FALSE;
    RedirectIoWorkItem = NULL;
    InitializeListHead(&RedirectIrpList);
    InitializeListHead(&RedirectCompletionList);
    InitializeListHead(&RedirectActiveList);
    InitializeListHead(&RedirectList);
    KeInitializeSpinLock(&RedirectLock);
    KeInitializeSpinLock(&RedirectCompletionLock);
    KeInitializeSpinLock(&RedirectInitializationLock);
    constructRhizome(
        &RedirectActiveRhizome[NatForwardPath],
        sizeof(NAT_REDIRECT_ACTIVE_PATTERN) * 8
        );
    constructRhizome(
        &RedirectActiveRhizome[NatReversePath],
        sizeof(NAT_REDIRECT_ACTIVE_PATTERN) * 8
        );
    constructRhizome(
        &RedirectActiveRhizome[NatMaximumPath],
        sizeof(NAT_REDIRECT_ACTIVE_PATTERN) * 8
        );
    constructRhizome(&RedirectRhizome, sizeof(NAT_REDIRECT_PATTERN) * 8);

} // NatInitializeRedirectManagement


PNAT_REDIRECT
NatLookupRedirect(
    IP_NAT_PATH Path,
    PNAT_REDIRECT_ACTIVE_PATTERN SearchKey,
    ULONG ReceiveIndex,
    ULONG SendIndex,
    ULONG LookupFlags
    )

/*++

Routine Description:

    This routine is invoked to search for a redirect matching the given pattern.

Arguments:

    Path - which list (rhizome) to search -- forward or reverse
    
    SearchKey - identifies the redirect to match.

    LookupFlags - indicates what constitutes a match; see NAT_LOOKUP_FLAG_*.

    *Index - send and receive adapter indexes.

Return Value:

    PNAT_REDIRECT - the matching redirect, or NULL if no match is found.

Environment:

    Invoked with 'RedirectLock' held by the caller.

--*/

{
    PNAT_REDIRECT Redirectp;
    PNAT_REDIRECT_PATTERN_INFO Infop;
    PatternHandle Pattern;
    ULONG SourceAddress;
    PLIST_ENTRY Link;
    NTSTATUS Status;
    

    TRACE(PER_PACKET, ("NatLookupRedirect\n"));

    //
    // Search for the pattern in the active rhizome
    //

    Pattern = searchRhizome(&RedirectActiveRhizome[Path], (char*)SearchKey);
    SourceAddress = REDIRECT_ADDRESS(SearchKey->SourceKey);

    while (Pattern) {

        //
        // Get the info block from the pattern handle
        //

        Infop = GetReferenceFromPatternHandle(Pattern);

        //
        // Walk the redirects attached to this info block, checking if
        // they match the lookup flags
        //

        for (Link = Infop->RedirectList.Flink;
             Link != &Infop->RedirectList; Link = Link->Flink) {
             
            Redirectp = CONTAINING_RECORD(
                            Link,
                            NAT_REDIRECT,
                            ActiveLink[NatReversePath == Path
                                        ? Path : NatForwardPath]
                            );

            //
            // Check read only, loopback, send only, and zero-source flags,
            // and restricted source address
            //

            if (((Redirectp->Flags & IP_NAT_REDIRECT_FLAG_RECEIVE_ONLY)
                    && !(LookupFlags & NAT_LOOKUP_FLAG_PACKET_RECEIVED))
                || (!(Redirectp->Flags & IP_NAT_REDIRECT_FLAG_LOOPBACK)
                    && (LookupFlags & NAT_LOOKUP_FLAG_PACKET_LOOPBACK))
                || ((Redirectp->Flags & IP_NAT_REDIRECT_FLAG_SEND_ONLY)
                    && (LookupFlags & NAT_LOOKUP_FLAG_PACKET_RECEIVED))
                || ((Redirectp->Flags & IP_NAT_REDIRECT_FLAG_RESTRICT_SOURCE)
                    && SourceAddress != Redirectp->RestrictSourceAddress)) {
                continue;
            }

            //
            // Check for restricted adapter
            //

            if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_RESTRICT_ADAPTER) {
                ULONG IndexToUse =
                    ((Redirectp->Flags & IP_NAT_REDIRECT_FLAG_SEND_ONLY)
                        ? SendIndex
                        : ReceiveIndex);

                if (Redirectp->RestrictAdapterIndex != IndexToUse) {
                    continue;
                }
            }

            //
            // Redirect matched
            //

            return Redirectp;
        }

        //
        // None of the redirects attached to this info block matched. Move to
        // the next less-specific info block in the rhizome
        //

        Pattern = GetNextMostSpecificMatchingPatternHandle(Pattern);
    }
    
    return NULL;

} // NatLookupRedirect
        

VOID
NatpCleanupRedirect(
    PNAT_REDIRECT Redirectp,
    NTSTATUS Status
    )

/*++

Routine Description:

    This routine is invoked to cleanup a redirect.

Arguments:

    Redirectp - the redirect to be cleaned up

    Status - optional status with which any associated IRP should be completed

Return Value:

    none.

Environment:

    Invoked with 'RedirectLock' held by the caller.

--*/

{
    PNAT_REDIRECT_PATTERN_INFO Infop;
    CALLTRACE(("NatpCleanupRedirect\n"));

    //
    // Check to see if it's safe to cleanup the redirect at this point
    //

    if (Redirectp->Flags & NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING) {

        //
        // This redirect is either:
        // 1) about the be attached to a mapping (CreateHandler), or
        // 2) about to be deleted (DeleteHandler)
        //
        // Mark that deletion is required and return
        //

        Redirectp->Flags |= NAT_REDIRECT_FLAG_DELETION_REQUIRED;
        Redirectp->CleanupStatus = Status;
        return;

    } else if (Redirectp->Flags & NAT_REDIRECT_FLAG_DELETION_PENDING) {

        //
        // This redirect will be cleaned up by a pending work item.
        //

        return;
    }

    //
    // Take the redirect off the forward- and reverse-path lists
    //

    if (!IsListEmpty(&Redirectp->ActiveLink[NatForwardPath])) {
        InterlockedDecrement(&RedirectCount);
    }
    RemoveEntryList(&Redirectp->ActiveLink[NatForwardPath]);

    //
    // If this redirect is marked as pending completion, we need to
    // grab the completion lock before removing it the completion
    // list.
    //

    if (Redirectp->Flags & NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING) {
        KeAcquireSpinLockAtDpcLevel(&RedirectCompletionLock);
        RemoveEntryList(&Redirectp->ActiveLink[NatReversePath]);
        KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);
    } else {
        RemoveEntryList(&Redirectp->ActiveLink[NatReversePath]);
    }
    
    RemoveEntryList(&Redirectp->Link);
    InitializeListHead(&Redirectp->ActiveLink[NatForwardPath]);
    InitializeListHead(&Redirectp->ActiveLink[NatReversePath]);
    InitializeListHead(&Redirectp->Link);

    //
    // Check to see if we need to remove any entries from the rhizomes
    //

    Infop = Redirectp->ActiveInfo[NatForwardPath];
    Redirectp->ActiveInfo[NatForwardPath] = NULL;
    if (Infop && IsListEmpty(&Infop->RedirectList)) {
        removeRhizome(
            Redirectp->ForwardPathRhizome,
            Infop->Pattern
            );

        RemoveEntryList(&Infop->Link);
        ExFreePool(Infop);
    }

    Infop = Redirectp->ActiveInfo[NatReversePath];
    Redirectp->ActiveInfo[NatReversePath] = NULL;
    if (Infop && IsListEmpty(&Infop->RedirectList)) {
        removeRhizome(
            &RedirectActiveRhizome[NatReversePath],
            Infop->Pattern
            );

        //
        // Reverse-path infoblocks aren't on a list
        //

        ExFreePool(Infop);
    }

    Infop = Redirectp->Info;
    Redirectp->Info = NULL;
    if (Infop && IsListEmpty(&Infop->RedirectList)) {
        removeRhizome(
            &RedirectRhizome,
            Infop->Pattern
            );

        RemoveEntryList(&Infop->Link);
        ExFreePool(Infop);
    }
    
    //
    // Dissociate the redirect from its session, if any
    //

    if (Redirectp->SessionHandle) {
        RedirectRegisterDirector.DissociateSession(
            RedirectRegisterDirector.DirectorHandle,
            Redirectp->SessionHandle
            );
    }

    //
    // If the redirect is associated with an event,
    // dereference the event before final cleanup.
    //

    if (Redirectp->EventObject) {
        ObDereferenceObject(Redirectp->EventObject);
    }

    //
    // If the redirect is associated with an IRP,
    // we may need to complete the IRP now.
    //

    if (Redirectp->Irp) {

        //
        // Take the IRP off 'RedirectIrpList',
        // and see if it has been cancelled.
        //

        RemoveEntryList(&Redirectp->Irp->Tail.Overlay.ListEntry);
        InitializeListHead(&Redirectp->Irp->Tail.Overlay.ListEntry);
        if (NULL != IoSetCancelRoutine(Redirectp->Irp, NULL)) {

            //
            // Our cancel routine has not been run, so we need to
            // complete the IRP now. (If the IO manager had canceled our
            // IRP, the cancel routine would already be null.)
            //

            //
            // Pick up the statistics stored in the redirect, if any.
            //

            RtlCopyMemory(
                Redirectp->Irp->AssociatedIrp.SystemBuffer,
                &Redirectp->Statistics,
                sizeof(Redirectp->Statistics)
                );

            //
            // Complete the IRP.
            //

            Redirectp->Irp->IoStatus.Status = Status;
            Redirectp->Irp->IoStatus.Information =
                sizeof(Redirectp->Statistics);
            IoCompleteRequest(Redirectp->Irp, IO_NO_INCREMENT);
            DEREFERENCE_NAT();
        }
    }
    ExFreePool(Redirectp);
} // NatpCleanupRedirect


VOID
NatpRedirectCancelRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to cancel an outstanding IRP.
    The only IRPs which are cancellable are those associated with
    an outstanding create-redirect request.

Arguments:

    DeviceObject - identifies the NAT driver's device object

    Irp - identifies the IRP to be cancelled.

Return Value:

    none.

Environment:

    Invoked with the cancel spin-lock held by the I/O manager.
    It is this routine's responsibility to release the lock.

--*/

{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_REDIRECT Redirectp;
    PNAT_DYNAMIC_MAPPING Mapping = NULL;
    CALLTRACE(("NatpRedirectCancelRoutine\n"));
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Retrieve the redirect, if any, from the IRP's 'DriverContext',
    // and clean up the redirect.
    //
    // N.B. The 'Cancel' bit is already set in the IRP,
    // so 'NatpCleanupRedirect' will leave IRP-completion up to us.
    //

    KeAcquireSpinLock(&MappingLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);
    Redirectp = Irp->Tail.Overlay.DriverContext[0];
    if (Redirectp) {
        Mapping = (PNAT_DYNAMIC_MAPPING)Redirectp->SessionHandle;
        NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);
    }
    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
    if (Mapping) {
        NatDeleteMapping(Mapping);
    }
    KeReleaseSpinLock(&MappingLock, Irql);

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    DEREFERENCE_NAT();
} // NatpRedirectCancelRoutine


VOID
NatpRedirectCreateHandler(
    PVOID SessionHandle,
    PVOID DirectorContext,
    PVOID DirectorSessionContext
    )

/*++

Routine Description:

    This routine is invoked upon creation of a session for a redirect.

Arguments:

    SessionHandle - identifies the session to the NAT driver.

    DirectorContext - identifies the director; unused

    DirectorSessionContext - identifies the session to us, i.e. PNAT_REDIRECT

Return Value:

    none.

Environment:

    Always invoked at dispatch level.

--*/

{
    PNAT_REDIRECT Redirectp;
    CALLTRACE(("NatpRedirectCreateHandler\n"));
    if (!DirectorSessionContext) { return; }

    //
    // Record the session handle.
    //

    KeAcquireSpinLockAtDpcLevel(&RedirectLock);
    Redirectp = (PNAT_REDIRECT)DirectorSessionContext;
    Redirectp->SessionHandle = SessionHandle;

    //
    // Notify the requestor that the session is now active.
    // There are two notification mechanisms;
    // first, via an event object specified at creation time,
    // and second, via a completion packet queued to the file-object
    // on which the redirect was requested. This latter notification
    // is only enabled when the file-object in question is associated
    // with a completion-port and the caller explicitly requests it.
    //

    if (Redirectp->EventObject) {
        KeSetEvent(Redirectp->EventObject, 0, FALSE);
    }
    if (Redirectp->Irp &&
        (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_IO_COMPLETION) &&
        !(Redirectp->Flags & NAT_REDIRECT_FLAG_DELETION_REQUIRED)) {
        
        KeAcquireSpinLockAtDpcLevel(&RedirectCompletionLock);
        Redirectp->Flags |= NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING;

        //
        // Add this redirect to the completion-pending list
        //

        InsertTailList(
            &RedirectCompletionList,
            &Redirectp->ActiveLink[NatReversePath]
            );
        
        //
        // Queue a worker-routine, if necessary, to issue the completion packet
        // at passive IRQL.
        //

        if (!RedirectIoCompletionPending) {
            if (!RedirectIoWorkItem) {
                RedirectIoWorkItem = IoAllocateWorkItem(NatDeviceObject);
            }
            if (RedirectIoWorkItem) {
                IoQueueWorkItem(
                    RedirectIoWorkItem,
                    NatpRedirectIoCompletionWorkerRoutine,
                    DelayedWorkQueue,
                    RedirectIoWorkItem
                    );
                RedirectIoCompletionPending = TRUE;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);
    }

    //
    // Clear the creation pending flag
    //

    Redirectp->Flags &= ~NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING;

    //
    // Check to see if this redirect has been cancelled, and, if so, schedule
    // a work item to do the actual cleanup. We can't do the cleanup directly
    // from here as it would result in a recursive attempt to acquire
    // DirectorLock and DirectorMappingLock.
    //

    if (Redirectp->Flags & NAT_REDIRECT_FLAG_DELETION_REQUIRED) {
        PIO_WORKITEM DeleteWorkItem;
        PNAT_REDIRECT_DELAYED_CLEANUP_CONTEXT Contextp;
        
        DeleteWorkItem = IoAllocateWorkItem(NatDeviceObject);
        if (DeleteWorkItem) {
            Contextp =
                ExAllocatePoolWithTag(
                    NonPagedPool,
			        sizeof(*Contextp),
			        NAT_TAG_REDIRECT
			    );
            if (Contextp) {
                Redirectp->Flags |= NAT_REDIRECT_FLAG_DELETION_PENDING;
                Contextp->DeleteWorkItem = DeleteWorkItem;
                Contextp->Redirectp = Redirectp;
                IoQueueWorkItem(
                    DeleteWorkItem,
                    NatpRedirectDelayedCleanupWorkerRoutine,
                    DelayedWorkQueue,
                    Contextp
                    );
            } else {
                IoFreeWorkItem(DeleteWorkItem);
            }
        }

        Redirectp->Flags &= ~NAT_REDIRECT_FLAG_DELETION_REQUIRED;
    }
    
    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
} // NatpRedirectCreateHandler


VOID
NatpRedirectDelayedCleanupWorkerRoutine(
    PVOID DeviceObject,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to perform a delayed deletion of a redirect. A
    delayed deletion is necessary when a redirect in cancelled in the time
    between the execution of NatpRedirectQueryHandler and
    NatpRedirectCreateHandler for the same redirect.

Arguments:

    DeviceObject - device-object for the NAT driver

    Context - pointer to a NAT_REDIRECT_DELAYED_CLEANUP_CONTEXT instance

Return Value:

    none.

Environment:

    Invoked at passive IRQL in the context of an executive worker thread.

--*/

{
    KIRQL Irql;
    PNAT_REDIRECT_DELAYED_CLEANUP_CONTEXT DelayedContextp;
    PNAT_REDIRECT Redirectp;
    PNAT_DYNAMIC_MAPPING Mapping;

    DelayedContextp = (PNAT_REDIRECT_DELAYED_CLEANUP_CONTEXT) Context;
    Redirectp = DelayedContextp->Redirectp;

    KeAcquireSpinLock(&MappingLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);

    Redirectp->Flags &= ~NAT_REDIRECT_FLAG_DELETION_PENDING;
    Mapping = (PNAT_DYNAMIC_MAPPING) Redirectp->SessionHandle;
    NatpCleanupRedirect(Redirectp, Redirectp->CleanupStatus);
    
    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
    
    if (Mapping) {
        NatDeleteMapping(Mapping);
    }
    
    KeReleaseSpinLock(&MappingLock, Irql);

    IoFreeWorkItem(DelayedContextp->DeleteWorkItem);
    ExFreePool(DelayedContextp);

} // NatpRedirectDelayedCleanupWorkerRoutine



VOID
NatpRedirectDeleteHandler(
    PVOID SessionHandle,
    PVOID DirectorContext,
    PVOID DirectorSessionContext,
    IP_NAT_DELETE_REASON DeleteReason
    )

/*++

Routine Description:

    This routine is invoked upon deletion of a session created
    for a redirect. It copies the session's statistics, and cleans up
    the redirect. (This results in completion of its IRP, if any.)

Arguments:

    SessionHandle - identifies the session to the NAT driver.

    DirectorContext - identifies the director; unused

    DirectorSessionContext - identifies the session to us, i.e. PNAT_REDIRECT

    DeleteReason - indicates why the session is being deleted.

Return Value:

    none.

Environment:

    Always invoked at dispatch level.

--*/

{
    PNAT_REDIRECT Redirectp;
    CALLTRACE(("NatpRedirectDeleteHandler\n"));

    //
    // If we are being called because of a 'dissociate',
    // we will have already cleaned up the redirect.
    //

    if (!DirectorSessionContext ||
        DeleteReason == NatDissociateDirectorDeleteReason) {
        return;
    }

    //
    // Retrieve the statistics for the redirect's session, and clean it up.
    // This will complete the redirect's IRP, if any.
    //

    Redirectp = (PNAT_REDIRECT)DirectorSessionContext;
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);
    if (Redirectp->SessionHandle) {
        NatQueryInformationMapping(
            (PNAT_DYNAMIC_MAPPING)Redirectp->SessionHandle,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            (PIP_NAT_SESSION_MAPPING_STATISTICS)&Redirectp->Statistics
            );
        Redirectp->SessionHandle = NULL;
    }

    //
    // Make sure that NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING is cleared.
    // (It would be set if NatCreateMapping failed for the mapping that
    // was to be created off of this redirect.)
    //

    Redirectp->Flags &= ~NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING;
    
    NatpCleanupRedirect(Redirectp, STATUS_SUCCESS);
    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
} // NatpRedirectDeleteHandler


VOID
NatpRedirectIoCompletionWorkerRoutine(
    PVOID DeviceObject,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to issue completion packets for all redirects
    which have I/O completion notifications pending. In the process
    it clears the 'pending' flag on each redirect. It synchronizes with the
    shutdown routine via the nullity of 'RedirectIoWorkItem' which
    is also passed as the context to this routine. In the event of shutdown,
    the work-item is deallocated here.

Arguments:

    DeviceObject - device-object for the NAT driver

    Context - the I/O work-item allocated for this routine

Return Value:

    none.

Environment:

    Invoked at passive IRQL in the context of an executive worker thread.

--*/

{
    PVOID ApcContext;
    PIO_COMPLETION_CONTEXT IoCompletion;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_REDIRECT Redirectp;
    
    KeAcquireSpinLock(&RedirectCompletionLock, &Irql);
    if (!RedirectIoWorkItem) {
        IoFreeWorkItem((PIO_WORKITEM)Context);
        RedirectIoCompletionPending = FALSE;
        KeReleaseSpinLock(&RedirectCompletionLock, Irql);
        return;
    }

    //
    // Examine the list of redirects and issue completion notifications
    // for each one that is pending.
    //

    while (!IsListEmpty(&RedirectCompletionList)) {
        Link = RemoveHeadList(&RedirectCompletionList);
        Redirectp = CONTAINING_RECORD(Link, NAT_REDIRECT, ActiveLink[NatReversePath]);
        InitializeListHead(&Redirectp->ActiveLink[NatReversePath]);
        if (!Redirectp->Irp ||
            !(Redirectp->Flags & IP_NAT_REDIRECT_FLAG_IO_COMPLETION) ||
            !(Redirectp->Flags & NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING)) {
            continue;
        }
        IoCompletion = Redirectp->FileObject->CompletionContext;
        ApcContext =
            Redirectp->Irp->Overlay.AsynchronousParameters.UserApcContext;
        Redirectp->Flags &= ~NAT_REDIRECT_FLAG_IO_COMPLETION_PENDING;

        KeReleaseSpinLock(&RedirectCompletionLock, Irql);
        if (IoCompletion) {
            IoSetIoCompletion(
                IoCompletion->Port,
                IoCompletion->Key,
                ApcContext,
                STATUS_PENDING,
                0,
                FALSE
                );
        }
        KeAcquireSpinLock(&RedirectCompletionLock, &Irql);
    }
    
    RedirectIoCompletionPending = FALSE;
    if (!RedirectIoWorkItem) {
        IoFreeWorkItem((PIO_WORKITEM)Context);
    }
    KeReleaseSpinLock(&RedirectCompletionLock, Irql);
} // NatpRedirectIoCompletionWorkerRoutine


NTSTATUS
NatpRedirectQueryHandler(
    PIP_NAT_DIRECTOR_QUERY DirectorQuery
    )

/*++

Routine Description:

    This routine is invoked in the translation path to obtain a destination
    and source for an incoming packet.

Arguments:

    DirectorQuery - contains information on the incoming packet,
        and on output receives translation information

Return Value:

    NTSTATUS - NT status code.

Environment:

    Always invoked at dispatch IRQL.

--*/

{
    NAT_REDIRECT_ACTIVE_PATTERN Pattern;
    PNAT_REDIRECT Redirectp;
    PNAT_REDIRECT_PATTERN_INFO Infop;
    ULONG LookupFlags;
    ULONG PacketFlags;

    TRACE(PER_PACKET, ("NatpRedirectQueryHandler\n"));

    if (!RedirectCount) { return STATUS_UNSUCCESSFUL; }
    
    if (NAT_PROTOCOL_TCP != DirectorQuery->Protocol
        && NAT_PROTOCOL_UDP != DirectorQuery->Protocol) {

        //
        // Since redirects can only be created for TCP and UDP,
        // exit early if this packet is not one of those protocols.
        //
        
        return STATUS_UNSUCCESSFUL;
    }

    DirectorQuery->DirectorSessionContext = NULL;

    //
    // Search for a forward-path match
    //

    RtlZeroMemory(&Pattern, sizeof(Pattern));

    Pattern.DestinationKey =
        MAKE_REDIRECT_KEY(
            DirectorQuery->Protocol,
            DirectorQuery->DestinationAddress,
            DirectorQuery->DestinationPort
            );
    Pattern.SourceKey =
        MAKE_REDIRECT_KEY(
            DirectorQuery->Protocol,
            DirectorQuery->SourceAddress,
            DirectorQuery->SourcePort
            );
    TRACE(
        REDIRECT, (
        "NatRedirectQueryHandler: (%u) %u.%u.%u.%u/%u %u.%u.%u.%u/%u\n",
        DirectorQuery->Protocol,
        ADDRESS_BYTES(DirectorQuery->DestinationAddress),
        NTOHS(DirectorQuery->DestinationPort),
        ADDRESS_BYTES(DirectorQuery->SourceAddress),
        NTOHS(DirectorQuery->SourcePort)
        ));

    LookupFlags =
        NAT_LOOKUP_FLAG_MATCH_ZERO_SOURCE |
        NAT_LOOKUP_FLAG_MATCH_ZERO_SOURCE_ENDPOINT;
    PacketFlags = 0;
    if (DirectorQuery->ReceiveIndex != LOCAL_IF_INDEX) {
        PacketFlags |= NAT_LOOKUP_FLAG_PACKET_RECEIVED;
    }
    if (DirectorQuery->Flags & IP_NAT_DIRECTOR_QUERY_FLAG_LOOPBACK) {
        PacketFlags |= NAT_LOOKUP_FLAG_PACKET_LOOPBACK;
    }
    
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);
    if (Redirectp = NatLookupRedirect(
                        NatForwardPath,
                        &Pattern,
                        DirectorQuery->ReceiveIndex,
                        DirectorQuery->SendIndex,
                        LookupFlags | PacketFlags
                        )) {

        //
        // We have a match. Supply the new destination endpoint.
        //

        DirectorQuery->NewDestinationAddress =
            REDIRECT_ADDRESS(Redirectp->SourceKey[NatReversePath]);
        DirectorQuery->NewDestinationPort =
            REDIRECT_PORT(Redirectp->SourceKey[NatReversePath]);

        if (!Redirectp->DestinationKey[NatReversePath]) {

            //
            // This is a ticket; we don't modify the source-address.
            //

            DirectorQuery->NewSourceAddress = DirectorQuery->SourceAddress;
            DirectorQuery->NewSourcePort = DirectorQuery->SourcePort;
        } else {

            //
            // The source endpoint must be modified.
            //

            DirectorQuery->NewSourceAddress =
                REDIRECT_ADDRESS(Redirectp->DestinationKey[NatReversePath]);
            DirectorQuery->NewSourcePort =
                REDIRECT_PORT(Redirectp->DestinationKey[NatReversePath]);
        }

        if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_NO_TIMEOUT) {
            DirectorQuery->Flags |= IP_NAT_DIRECTOR_QUERY_FLAG_NO_TIMEOUT;
        }
        if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_UNIDIRECTIONAL) {
            DirectorQuery->Flags |= IP_NAT_DIRECTOR_QUERY_FLAG_UNIDIRECTIONAL;
        }

    } else if (Redirectp = NatLookupRedirect(
                        NatMaximumPath,
                        &Pattern,
                        DirectorQuery->ReceiveIndex,
                        DirectorQuery->SendIndex,
                        LookupFlags | PacketFlags
                        )) {

        //
        // We have a match on a source-redirect. Supply the new
        // source endpoint, unless this is a port redirect.
        //

        if (!(Redirectp->Flags & IP_NAT_REDIRECT_FLAG_PORT_REDIRECT)) {
        
            DirectorQuery->NewSourceAddress =
                REDIRECT_ADDRESS(Redirectp->DestinationKey[NatReversePath]);
            DirectorQuery->NewSourcePort =
                REDIRECT_PORT(Redirectp->DestinationKey[NatReversePath]);

        } else {

            DirectorQuery->NewSourceAddress = DirectorQuery->SourceAddress;
            DirectorQuery->NewSourcePort = DirectorQuery->SourcePort;

        }

        if (!Redirectp->SourceKey[NatReversePath]) {

            //
            // The destination endpoint is not modified.
            //

            DirectorQuery->NewDestinationAddress =
                DirectorQuery->DestinationAddress;
            DirectorQuery->NewDestinationPort =
                DirectorQuery->DestinationPort;
                
        } else {

            //
            // Provide new destination endpoint
            //

            DirectorQuery->NewDestinationAddress =
                REDIRECT_ADDRESS(Redirectp->SourceKey[NatReversePath]);
            DirectorQuery->NewDestinationPort =
                REDIRECT_PORT(Redirectp->SourceKey[NatReversePath]);
        }

        if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_NO_TIMEOUT) {
            DirectorQuery->Flags |= IP_NAT_DIRECTOR_QUERY_FLAG_NO_TIMEOUT;
        }
        if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_UNIDIRECTIONAL) {
            DirectorQuery->Flags |= IP_NAT_DIRECTOR_QUERY_FLAG_UNIDIRECTIONAL;
        }
        
    } else {

        //
        // Now see if this could be a return packet for a redirect,
        // i.e. if it is destined for the endpoint which is the replacement
        // of some redirect.
        //

        Redirectp = NatLookupRedirect(
                        NatReversePath,
                        &Pattern,
                        DirectorQuery->ReceiveIndex,
                        DirectorQuery->SendIndex,
                        PacketFlags
                        );
        
        if (!Redirectp ||
            (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_UNIDIRECTIONAL)) {
            KeReleaseSpinLockFromDpcLevel(&RedirectLock);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // We have a matching redirect;
        // Supply the new destination and source.
        //

        DirectorQuery->NewDestinationAddress =
            REDIRECT_ADDRESS(Redirectp->SourceKey[NatForwardPath]);
        DirectorQuery->NewDestinationPort =
            REDIRECT_PORT(Redirectp->SourceKey[NatForwardPath]);
        DirectorQuery->NewSourceAddress =
            REDIRECT_ADDRESS(Redirectp->DestinationKey[NatForwardPath]);
        DirectorQuery->NewSourcePort =
            REDIRECT_PORT(Redirectp->DestinationKey[NatForwardPath]);
        if (Redirectp->Flags & IP_NAT_REDIRECT_FLAG_NO_TIMEOUT) {
            DirectorQuery->Flags |= IP_NAT_DIRECTOR_QUERY_FLAG_NO_TIMEOUT;
        }
    }

    Redirectp->DestinationMapping.DestinationAddress =
        DirectorQuery->DestinationAddress;
    Redirectp->DestinationMapping.DestinationPort =
        DirectorQuery->DestinationPort;
    Redirectp->DestinationMapping.NewDestinationAddress =
        DirectorQuery->NewDestinationAddress;
    Redirectp->DestinationMapping.NewDestinationPort =
        DirectorQuery->NewDestinationPort;
    Redirectp->SourceMapping.SourceAddress = DirectorQuery->SourceAddress;
    Redirectp->SourceMapping.SourcePort = DirectorQuery->SourcePort;
    Redirectp->SourceMapping.NewSourceAddress = DirectorQuery->NewSourceAddress;
    Redirectp->SourceMapping.NewSourcePort = DirectorQuery->NewSourcePort;

    if (!(Redirectp->Flags & IP_NAT_REDIRECT_FLAG_RESTRICT_ADAPTER)) {
    
        //
        // Since this wasn't an adapter-restricted redirect, store the
        // index of the adapter we triggered on within the redirect structure,
        // so that we can return the index if it is queried for.
        //
        
        Redirectp->RestrictAdapterIndex =
            ((Redirectp->Flags & IP_NAT_REDIRECT_FLAG_SEND_ONLY)
                ? DirectorQuery->SendIndex
                : DirectorQuery->ReceiveIndex);
    }

    InterlockedDecrement(&RedirectCount);

    //
    // Remove the redirect from the active lists of the associated
    // info blocks.
    //
    
    RemoveEntryList(&Redirectp->ActiveLink[NatForwardPath]);
    RemoveEntryList(&Redirectp->ActiveLink[NatReversePath]);
    InitializeListHead(&Redirectp->ActiveLink[NatForwardPath]);
    InitializeListHead(&Redirectp->ActiveLink[NatReversePath]);

    //
    // Check to see if any of the active patterns should be
    // removed
    //

    Infop = Redirectp->ActiveInfo[NatForwardPath];
    Redirectp->ActiveInfo[NatForwardPath] = NULL;
    if (Infop && IsListEmpty(&Infop->RedirectList)) {
        removeRhizome(
            Redirectp->ForwardPathRhizome,
            Infop->Pattern
            );

        RemoveEntryList(&Infop->Link);
        ExFreePool(Infop);
    }

    Infop = Redirectp->ActiveInfo[NatReversePath];
    Redirectp->ActiveInfo[NatReversePath] = NULL;
    if (Infop && IsListEmpty(&Infop->RedirectList)) {
        removeRhizome(
            &RedirectActiveRhizome[NatReversePath],
            Infop->Pattern
            );

        //
        // The reverse-path infoblock is not on a list.
        //

        ExFreePool(Infop);
    }

    //
    // Set NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING -- this prevents a
    // race condition in which the redirect is cancelled before the
    // mapping is created for this redirect.
    //

    Redirectp->Flags |=
        (NAT_REDIRECT_FLAG_ACTIVATED|NAT_REDIRECT_FLAG_CREATE_HANDLER_PENDING);

    DirectorQuery->DirectorSessionContext = (PVOID)Redirectp;

    KeReleaseSpinLockFromDpcLevel(&RedirectLock);

    return STATUS_SUCCESS;

} // NatpRedirectQueryHandler


VOID
NatpRedirectUnloadHandler(
    PVOID DirectorContext
    )

/*++

Routine Description:

    This routine is invoked when the module is unloaded by the NAT.
    As a result, we cleanup the module.

Arguments:

    DirectorContext - unused.

Return Value:

    none.

--*/

{
    NatShutdownRedirectManagement();
} // NatpRedirectUnloadHandler


NTSTATUS
NatQueryInformationRedirect(
    PIP_NAT_LOOKUP_REDIRECT QueryRedirect,
    OUT PVOID Information,
    ULONG InformationLength,
    NAT_REDIRECT_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine is called to retrieve information about an active redirect.

Arguments:

    QueryRedirect - specifies the redirect for which information is required

    Information - receives information appropriate to 'InformationClass'.
        N.B. this may be the same buffer as 'QueryRedirect',
        hence contents of 'QueryRedirect' must be captured immediately.

    InformationLength - indicates the length of 'Information'

    InformationClass - indicates the information required about the redirect.

Return Value:

    NTSTATUS - indicates whether the required information was retrieved

--*/

{
    NAT_REDIRECT_PATTERN Pattern;
    PatternHandle FoundPattern;
    PNAT_REDIRECT_PATTERN_INFO Infop;
    PIRP Irp;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_REDIRECT Redirectp;
    CALLTRACE(("NatQueryInformationRedirect\n"));

    //
    // Construct the keys used to locate the redirect
    //

    Pattern.DestinationKey[NatForwardPath] =
        MAKE_REDIRECT_KEY(
            QueryRedirect->Protocol,
            QueryRedirect->DestinationAddress,
            QueryRedirect->DestinationPort
            );
    if (!QueryRedirect->NewSourceAddress) {
        Pattern.SourceKey[NatForwardPath] = 0;
        Pattern.DestinationKey[NatReversePath] = 0;
    } else {
        Pattern.SourceKey[NatForwardPath] =
            MAKE_REDIRECT_KEY(
                QueryRedirect->Protocol,
                QueryRedirect->SourceAddress,
                QueryRedirect->SourcePort
                );
        Pattern.DestinationKey[NatReversePath] =
            MAKE_REDIRECT_KEY(
                QueryRedirect->Protocol,
                QueryRedirect->NewSourceAddress,
                QueryRedirect->NewSourcePort
                );
    }
    Pattern.SourceKey[NatReversePath] =
        MAKE_REDIRECT_KEY(
            QueryRedirect->Protocol,
            QueryRedirect->NewDestinationAddress,
            QueryRedirect->NewDestinationPort
            );

    //
    // Search the redirect list
    //

    KeAcquireSpinLock(&MappingLock, &Irql);
    KeAcquireSpinLockAtDpcLevel(&RedirectLock);

    FoundPattern = searchRhizome(&RedirectRhizome, (char*) &Pattern);
    if (!FoundPattern) {
        KeReleaseSpinLockFromDpcLevel(&RedirectLock);
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_UNSUCCESSFUL;
    }

    Infop = GetReferenceFromPatternHandle(FoundPattern);
    
    for (Link = Infop->RedirectList.Flink;
         Link != &Infop->RedirectList;
         Link = Link->Flink
         ) {
        Redirectp = CONTAINING_RECORD(Link, NAT_REDIRECT, Link);
        if ((QueryRedirect->Flags &
                IP_NAT_LOOKUP_REDIRECT_FLAG_MATCH_APC_CONTEXT)
            && Redirectp->Irp
            && Redirectp->Irp->Overlay.AsynchronousParameters.UserApcContext !=
                QueryRedirect->RedirectApcContext) {
            continue;
        }
        switch(InformationClass) {
            case NatStatisticsRedirectInformation: {
                if (!Redirectp->SessionHandle) {
                    RtlZeroMemory(Information, InformationLength);
                } else {
                    NatQueryInformationMapping(
                        (PNAT_DYNAMIC_MAPPING)Redirectp->SessionHandle,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        (PIP_NAT_SESSION_MAPPING_STATISTICS)Information
                        );
                }
                break;
            }
            case NatDestinationMappingRedirectInformation: {
                *(PIP_NAT_REDIRECT_DESTINATION_MAPPING)Information =
                    Redirectp->DestinationMapping;
                break;
            }
            case NatSourceMappingRedirectInformation: {
                *(PIP_NAT_REDIRECT_SOURCE_MAPPING)Information =
                    Redirectp->SourceMapping;
                break;
            }
            default: {
                KeReleaseSpinLockFromDpcLevel(&RedirectLock);
                KeReleaseSpinLock(&MappingLock, Irql);
                return STATUS_INVALID_PARAMETER;
            }
        }
        KeReleaseSpinLockFromDpcLevel(&RedirectLock);
        KeReleaseSpinLock(&MappingLock, Irql);
        return STATUS_SUCCESS;
    }
    KeReleaseSpinLockFromDpcLevel(&RedirectLock);
    KeReleaseSpinLock(&MappingLock, Irql);
    return STATUS_UNSUCCESSFUL;
} // NatQueryInformationRedirect


VOID
NatShutdownRedirectManagement(
    VOID
    )

/*++

Routine Description:

    This routine cleans up state for the redirect-manager

Arguments:

    none.

Return Value:

    none.

--*/

{
    HANDLE DirectorHandle;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PLIST_ENTRY InfoLink;
    PNAT_REDIRECT_PATTERN_INFO Infop;
    PNAT_REDIRECT Redirectp;
    CALLTRACE(("NatShutdownRedirectManagement\n"));

    //
    // Deregister as a director.
    //

    if (RedirectRegisterDirector.Deregister) {
        DirectorHandle =
            InterlockedExchangePointer(
                &RedirectRegisterDirector.DirectorHandle,
                NULL
                );
        RedirectRegisterDirector.Deregister(DirectorHandle);
    }

    //
    // Clean up all outstanding redirects.
    //

    KeAcquireSpinLock(&RedirectLock, &Irql);
    while (!IsListEmpty(&RedirectActiveList)) {
        InfoLink = RemoveHeadList(&RedirectActiveList);
        Infop = CONTAINING_RECORD(InfoLink, NAT_REDIRECT_PATTERN_INFO, Link);
        while (IsListEmpty(&Infop->RedirectList)) {
            Link = RemoveHeadList(&Infop->RedirectList);
            Redirectp =
                CONTAINING_RECORD(
                    Link,
                    NAT_REDIRECT,
                    ActiveLink[NatForwardPath]
                    );
            RemoveEntryList(&Redirectp->ActiveLink[NatForwardPath]);
            InitializeListHead(&Redirectp->ActiveLink[NatForwardPath]);
            Redirectp->ActiveInfo[NatForwardPath] = NULL;
            NatpCleanupRedirect(Redirectp, STATUS_CANCELLED);
        }
        removeRhizome(Redirectp->ForwardPathRhizome, Infop->Pattern);
        ExFreePool(Infop);
    }
    RedirectCount = 0;

    //
    // Clean up the rhizomes.
    //

    destructRhizome(&RedirectActiveRhizome[NatForwardPath]);
    destructRhizome(&RedirectActiveRhizome[NatReversePath]);
    destructRhizome(&RedirectActiveRhizome[NatMaximumPath]);
    destructRhizome(&RedirectRhizome);

    //
    // Stop processing the pending completion list and clean up
    // our work item. If the completion routine is currently running,
    // it will free the work item.
    //

    KeAcquireSpinLockAtDpcLevel(&RedirectCompletionLock);
    InitializeListHead(&RedirectCompletionList);
    if (RedirectIoCompletionPending) {
        RedirectIoWorkItem = NULL;
    } else if (RedirectIoWorkItem) {
        IoFreeWorkItem(RedirectIoWorkItem);
        RedirectIoWorkItem = NULL;
    }
    KeReleaseSpinLockFromDpcLevel(&RedirectCompletionLock);


    KeReleaseSpinLock(&RedirectLock, Irql);

} // NatShutdownRedirectManagement


NTSTATUS
NatStartRedirectManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initiate handling of redirects,
    by registering the default director.

Arguments:

    none.

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    KIRQL Irql;
    NTSTATUS status;
    CALLTRACE(("NatStartRedirectManagement\n"));
    KeAcquireSpinLock(&RedirectInitializationLock, &Irql);
    if (RedirectRegisterDirector.DirectorHandle) {
        KeReleaseSpinLock(&RedirectInitializationLock, Irql);
        return STATUS_SUCCESS;
    }

    //
    // Register as a director.
    //

    RedirectRegisterDirector.Version = IP_NAT_VERSION;
    RedirectRegisterDirector.Port = 0;
    RedirectRegisterDirector.Protocol = 0;
    RedirectRegisterDirector.CreateHandler = NatpRedirectCreateHandler;
    RedirectRegisterDirector.DeleteHandler = NatpRedirectDeleteHandler;
    RedirectRegisterDirector.QueryHandler = NatpRedirectQueryHandler;
    status = NatCreateDirector(&RedirectRegisterDirector);
    KeReleaseSpinLock(&RedirectInitializationLock, Irql);
    return status;

} // NatStartRedirectManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\rhizome.c ===
/*
 *  rhizome.c
 *
 *  author:	John R. Douceur
 *  date:	28 April 1997
 *
 *  This source file provides functions that implement insertion, removal, and
 *  search operations on the rhizome database.  The code is object-oriented C,
 *  transliterated from a C++ implementation.
 *
 *  The rhizome is a database that stores patterns containing wildcards.
 *  Each pattern defines a set of keys that it matches; if a pattern contains
 *  N wildcards, then it matches 2^N keys.  Since each pattern can match
 *  multiple keys, it is possible for a given key to match multiple patterns
 *  in the database.  The rhizome requires that all patterns stored therein
 *  have a strict hierarchical interrelationship.  Two patterns may match no
 *  common keys (in which case the patterns are said to be independent), or
 *  one pattern may match all the keys matched by a second pattern as well as
 *  additonal keys (in which case the second pattern is said to be more general
 *  than the first, and the first more specific than the second).  The database
 *  will not accept two patterns which match some keys in common but each of
 *  which also matches additional keys that the other does not.
 *
 *  The database can be searched for patterns that match a given search key.
 *  When the database is searched for a given key, the most specifically
 *  matching pattern is found.  If no patterns in the database match the key,
 *  an appropriate indication is returned.
 *
 *  None of the code or comments in this file needs to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, rhizome.h.
 *
 */

#include "precomp.h"
#pragma hdrstop

// The fields of the RhizomeNode structure are accessed through the following
// macros.  The first three are obvious; the subsequent three rely on an agreed
// usage of the cdata array in the RhizomeNode.  The first keybytes locations
// of the cdata array are used to store the value field of the node; the second
// keybytes locations store the mask field; and the third keybytes locations
// store the imask field.
//
#define CHILDREN udata.branch.children
#define REFERENCE udata.leaf.reference
#define GODPARENT udata.leaf.godparent
#define VALUE(pointer) (pointer->cdata)
#define MASK(pointer) (pointer->cdata + rhizome->keybytes)
#define IMASK(pointer) (pointer->cdata + 2 * rhizome->keybytes)

// This macro allocates a new rhizome node structure.  The size of the structure
// is a function of the value of keybytes, since three bytes of information
// need to be stored in the structure for each byte of pattern length.  The
// cdata array, which is the last field in the structure, is declared as a
// having a single element, but this array will actually extend beyond the
// defined end of the structure into additional space that is allocated for it
// by the following macro.
//
#define NEW_RhizomeNode(_pa) \
	GpcAllocMem((_pa),\
                sizeof(RhizomeNode) + 3 * rhizome->keybytes - 1,\
                NAT_TAG_RHIZOME)/*;\
    TRACE(RHIZOME, *_pa, sizeof(RhizomeNode) + 3 * rhizome->keybytes - 1, "NEW_RhizomeNode")*/


// This macro gets the indexed bit of the value, where the most-significant bit
// is defined as bit 0.
//
#define BIT_OF(value, index) \
	(((value)[(index) >> 3] >> (7 - ((index) & 0x7))) & 0x1)

// Following are prototypes for static functions that are used internally by
// the implementation of the rhizome routines.

static int
node_insert(
	Rhizome *rhizome,
	RhizomeNode *new_leaf,
	RhizomeNode **ppoint,
	int prev_bit);

static void
node_remove(
	Rhizome *rhizome,
	RhizomeNode *leaf,
	RhizomeNode **ppoint);

static RhizomeNode *
replicate(
	Rhizome *rhizome,
	RhizomeNode *source,
	int pivot_bit);

static void
eliminate(
	Rhizome *rhizome,
	RhizomeNode *point);

static void
coalesce(
	Rhizome *rhizome,
	RhizomeNode **leaf_list,
	RhizomeNode *point);


// Since this is not C++, the Rhizome structure is not self-constructing;
// therefore, the following constructor code must be called on the Rhizome
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.
//
void
constructRhizome(
	Rhizome *rhizome,
	int keybits)
{
	rhizome->keybits = keybits;
	rhizome->keybytes = (keybits - 1) / 8 + 1;
	rhizome->root = 0;
}

// Since this is not C++, the Rhizome structure is not self-destructing;
// therefore, the following destructor code must be called on the Rhizome
// structure before it is deallocated.
//
// If the structure is non-empty, call coalesce() to eliminate
// all branch nodes and to string leaf nodes into a list; then delete list.
//
void
destructRhizome(
	Rhizome *rhizome)
{
	RhizomeNode *leaf_list, *next;
	if (rhizome->root != 0)
	{
		leaf_list = 0;
		coalesce(rhizome, &leaf_list, rhizome->root);
		while (leaf_list != 0)
		{
			next = leaf_list->GODPARENT;
			GpcFreeMem(leaf_list, NAT_TAG_RHIZOME);
			leaf_list = next;
		}
	}
}

// This function searches the database for the pattern that most specifically
// matches the given key.  The key is passed as an array of bytes.  When the
// most specific match is found, the PatternHandle of that matching pattern is
// returned.  From the PatternHandle can be gotten the reference value via the
// macro GetReferenceFromPatternHandle.  If no pattern in the database is found
// to match the key, then a value of 0 is returned as the PatternHandle.
//
PatternHandle
searchRhizome(
	Rhizome *rhizome,
	char *key)
{
	int index;
	RhizomeNode *point;
	// If tree is empty, search fails.
	if (rhizome->root == 0)
	{
		return 0;
	}
	// Otherwise, start at rhizome->root and navigate tree until reaching a leaf.
	point = rhizome->root;
	while (point->pivot_bit < rhizome->keybits)
	{
		point = point->CHILDREN[BIT_OF(key, point->pivot_bit)];
	}
	// Check value for match, one byte at a time.  If any byte fails to match,
	// continue checking godparent with same byte; since previous bytes matched
	// godchild, they are guaranteed to match godparent also.
	index = 0;
	while (index < rhizome->keybytes)
	{
		if ((((key)[index]) & MASK(point)[index]) != VALUE(point)[index])
		{
			if (point->GODPARENT != 0)
			{
				point = point->GODPARENT;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			index++;
		}
	}
	return point;
}

// This function inserts a new pattern into the database.  The pattern is
// specified by a value and a mask.  Each bit of the mask determines whether
// the bit position is specified or is a wildcard:  A 1 in a mask bit indicates
// that the value of that bit is specified by the pattern; a 0 indicates that
// the value of that bit is a wildcard.  If a mask bit is 1, then the
// corresponding bit in the value field indicates the specified value of that
// bit.  Value and mask fields are passed as arrays of bytes.
//
// The client specifies a void pointer reference value to associate with the
// pattern.  When the pattern is installed, the insertRhizome function returns
// a pointer to a PatternHandle.
//
// If the new pattern conflicts with a pattern already installed in the
// database, meaning that the two patterns match some keys in common but each
// also matches additional keys that the other does not, then the new pattern
// is not inserted, and a value of 0 is returned as the PatternHandle.
//
PatternHandle
insertRhizome(
	Rhizome *rhizome,
	char *value,
	char *mask,
	void *reference,
    ulong *status)
{
	RhizomeNode *new_leaf;
	int index0, insert_status;
    
    *status = GPC_STATUS_SUCCESS;

	// Create new leaf and copy data into it; restrict set bits of value to
	// those set in mask, since later code assumes this is the case.  Add new
	// leaf to reference table.
	NEW_RhizomeNode(&new_leaf);
	if (new_leaf == 0)
	{
		// Memory could not be allocated for this new node.  Therefore, we
		// return an indication of failure to the client.
        *status = GPC_STATUS_RESOURCES;
		return 0;
	}
	for (index0 = 0; index0 < rhizome->keybytes; index0++)
	{
		VALUE(new_leaf)[index0] = value[index0] & mask[index0];
		MASK(new_leaf)[index0] = mask[index0];
		IMASK(new_leaf)[index0] = mask[index0];
	}
	new_leaf->REFERENCE = reference;
	new_leaf->pivot_bit = rhizome->keybits;
	new_leaf->GODPARENT = 0;
	// If tree is empty, leaf becomes first node; otherwise, attempt to insert
	// using recursive node_insert() routine.  If new leaf conflicts with
	// existing leaf, node_insert() throws exception; then remove new leaf and
	// return failure code.
	if (rhizome->root == 0)
	{
		rhizome->root = new_leaf;
	}
	else
	{
		insert_status = node_insert(rhizome, new_leaf, &rhizome->root, -1);
		if (insert_status != GPC_STATUS_SUCCESS)
		{
			removeRhizome(rhizome, new_leaf);
            *status = GPC_STATUS_CONFLICT;
			return 0;                                     // return null pointer
		};
	}
	return new_leaf;
}

// This function removes a pattern from the rhizome.  The pattern is specified
// by the PatternHandle that was returned by the insertRhizome function.  No
// checks are performed to insure that this is a valid handle.
//
void
removeRhizome(
	Rhizome *rhizome,
	PatternHandle phandle)
{
	// Call recursive node_remove() routine to remove all references to leaf;
	// then delete leaf.
	node_remove(rhizome, phandle, &rhizome->root);
    //TRACE(RHIZOME, rhizome, phandle, "removeRhizome")
	GpcFreeMem(phandle, NAT_TAG_RHIZOME);
}

// Insert new_leaf into subtree pointed to by *ppoint.  Update *ppoint to point
// to newly created nodes if necessary.  Index of most recently examined bit
// is given by prev_bit.  The return value is a status code:  Normally, it
// returns GPC_STATUS_SUCCESS; if there is a conflict, then it returns NDIS_STATUS_CONFLICT;
// if there is insufficient memory available to perform the insertion, then it
// returns GPC_STATUS_RESOURCES.
//
static int
node_insert(
	Rhizome *rhizome,
	RhizomeNode *new_leaf,
	RhizomeNode **ppoint,
	int prev_bit)
{
	int index, index0, bit_value, insert_status;
	char sub, super;
	RhizomeNode *point, *child, *new_branch;
	// This routine has a recursive structure, but unnecessary recursions have
	// been replaced by iteration, in order to improve performance.  This
	// recursion removal has introduced a forever loop which encloses the
	// entirety of the routine; looping back to the beginning of this loop is
	// thus the equivalent of recursing.
	while (1)
	{
		point = *ppoint;
		// Examine each bit index beginnig with that following last bit index
		// examined previously.  Continue examining bits until pivot bit of
		// current node is reached (unless loop is terminated prematurely).
		for (index = prev_bit + 1; index < point->pivot_bit; index++)
		{
			// If some leaf in the current subtree cares about the value of the
			// current bit, and if the new leaf cares about the value of the
			// current bit, and these two leaves disagree about the value of
			// this bit, then a new branch node should be inserted here.
			if (BIT_OF(MASK(new_leaf), index) == 1 &&
				BIT_OF(MASK(point), index) == 1 &&
				BIT_OF(VALUE(new_leaf), index) != BIT_OF(VALUE(point), index))
			{
				// Create new branch node; insert into tree; and set fields.
				bit_value = BIT_OF(VALUE(new_leaf), index);
				NEW_RhizomeNode(&new_branch);
				if (new_branch == 0)
				{
					// Memory could not be allocated for this new node.
					// Therefore, we pass an indication of failure up the stack.
					return GPC_STATUS_RESOURCES;
				}
				*ppoint = new_branch;
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					VALUE(new_branch)[index0] =
						VALUE(point)[index0] | VALUE(new_leaf)[index0];
					MASK(new_branch)[index0] =
						MASK(point)[index0] | MASK(new_leaf)[index0];
					IMASK(new_branch)[index0] =
						IMASK(point)[index0] & IMASK(new_leaf)[index0];
				}
				// Pivot bit of new branch node is the bit that inspired the
				// creation of this branch.
				new_branch->pivot_bit = index;
				// The earlier subtree becomes the child whose bit disagreed
				// with that of the new leaf.
				new_branch->CHILDREN[1 - bit_value] = point;
				// If every leaf in the subtree cares about the value of this
				// bit, then we can insert the new leaf as the other child of
				// this branch.
				if (BIT_OF(IMASK(point), index) == 1)
				{
					// Insert new leaf here and return.
					new_branch->CHILDREN[bit_value] = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Otherwise, at least one leaf in the earlier subtree does not
				// care about the value of this bit.  Copy all such leaves
				// (and necessary branches) to the other child of the new
				// branch node.
				child = replicate(rhizome, point, index);
				if (child == 0)
				{
					// Memory could not be allocated for the replica.
					// Therefore, we remove the new node from the structure,
					// delete the new node, and pass an indication of failure
					// up the stack.
					*ppoint = point;
					GpcFreeMem(new_branch, NAT_TAG_RHIZOME);
					return GPC_STATUS_RESOURCES;
				}
				new_branch->CHILDREN[bit_value] = child;
				// Continue search on newly copied subtree.
				ppoint = &new_branch->CHILDREN[bit_value];
				point = *ppoint;
			}
		}
		// All bits have been examined up to the pivot bit of the current node.
		// If this node is a leaf, then we have found a leaf with which the new
		// leaf has no disagreements over bit values.
		if (point->pivot_bit >= rhizome->keybits)
		{
			// Loop up the chain of godparents until one of the four cases
			// below causes an exit from the subroutine.
			while (1)
			{
				// Case 1:  We have reached the end of the godparent chain.
				if (point == 0)
				{
					// Insert new leaf at this point and return.
					*ppoint = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Case 2:  We discover that we have already inserted this leaf
				// at the appropriate location.  This can happen because two
				// leaves in separate parts of the tree may have a common god-
				// ancestor, and a leaf which is a further god-ancestor of that
				// leaf will be reached more than once.  Since the first
				// occasion inserted the leaf, the second one can return without
				// performing any action.
				if (point == new_leaf)
				{
					return GPC_STATUS_SUCCESS;
				}
				// Compare mask bits of the new leaf to the current leaf.
				sub = 0;
				super = 0;
				for (index = 0; index < rhizome->keybytes; index++)
				{
					sub |= MASK(new_leaf)[index] & ~MASK(point)[index];
					super |= ~MASK(new_leaf)[index] & MASK(point)[index];
				}
				// Case 3:  The new leaf cares about at least one bit that the
				// current leaf does not; and the current leaf does not care
				// about any bits that the new leaf does not; thus, the new leaf
				// should be a godchild of the current leaf.
				if (sub != 0 && super == 0)
				{
					// Update imask field of new leaf; insert into chain;
					// and return.
					for (index0 = 0; index0 < rhizome->keybytes; index0++)
					{
						IMASK(new_leaf)[index0] &= IMASK(point)[index0];
					}
					new_leaf->GODPARENT = point;
					*ppoint = new_leaf;
					return GPC_STATUS_SUCCESS;
				}
				// Case 4:  Either the new leaf has the same value and mask as
				// the current leaf, or there is a hierarchy conflict between
				// the two leaves.  In either case, terminate the insertion
				// process and clean up (in insert() routine) anything done
				// already.
				if (sub != 0 || super == 0)
				{
					return GPC_STATUS_CONFLICT;
				}
				// None of the above cases occurred; thus, the new leaf should
				// be a god-ancestor of the current leaf.  Update the imask
				// field of the current leaf, and continue with godparent of
				// current leaf.
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] &= IMASK(new_leaf)[index0];
				}
				ppoint = &point->GODPARENT;
				point = *ppoint;
			}
		}
		// The current node is not a leaf node.  Thus, we recurse on one or both
		// of the child nodes of the current node.  First, update the fields of
		// the current node to reflect the insertion of the new leaf into the
		// subtree.
		for (index0 = 0; index0 < rhizome->keybytes; index0++)
		{
			VALUE(point)[index0] |= VALUE(new_leaf)[index0];
			MASK(point)[index0] |= MASK(new_leaf)[index0];
			IMASK(point)[index0] &= IMASK(new_leaf)[index0];
		}
		// If the new leaf doesn't care about the value of the pivot bit of the
		// current leaf, then we must recurse on both children.  We can only
		// replace a single recursive call with iteration, so we perform a true
		// recursion in this case, and we recurse on child 1.
		if (BIT_OF(MASK(new_leaf), point->pivot_bit) == 0)
		{
			insert_status =
				node_insert(rhizome, new_leaf, &point->CHILDREN[1],
				point->pivot_bit);
			if (insert_status != GPC_STATUS_SUCCESS)
			{
				return insert_status;
			}
		}
		// Update the values of prev_bit and ppoint to reflect the same
		// conditions that would hold in a recursive call.  The pseudo-recursion
		// is performed on the bit indicated by the value of the pivot bit of
		// the new leaf.  If the new leaf does not care about this bit, then
		// this value will be a 0, and we recursed on child 1 above.  If the new
		// leaf does care about the value of this bit, then we continue down the
		// appropriate path.
		prev_bit = point->pivot_bit;
		ppoint = &point->CHILDREN[BIT_OF(VALUE(new_leaf), point->pivot_bit)];
	}
}

// Remove references to leaf from subtree pointed to by *ppoint.  Update *ppoint
// if necessary due to removal of branch nodes.
//
static void
node_remove(
	Rhizome *rhizome,
	RhizomeNode *leaf,
	RhizomeNode **ppoint)
{
	int pivot_bit, bit_value, index0;
	RhizomeNode *point, *child, *child0, *child1;
	point = *ppoint;
	pivot_bit = point->pivot_bit;
	if (pivot_bit < rhizome->keybits)
	{
		// The current node is a branch node.
		if (BIT_OF(MASK(leaf), pivot_bit) == 1)
		{
			// The leaf to be removed cares about this node's pivot bit;
			// therefore, we need only recurse on one of the current node's
			// children.
			bit_value = BIT_OF(VALUE(leaf), pivot_bit);
			node_remove(rhizome, leaf, &point->CHILDREN[bit_value]);
			child = point->CHILDREN[bit_value];
			if (child != 0 && BIT_OF(MASK(child), pivot_bit) == 1)
			{
				// Some leaf in the same subtree as the removed leaf cares about
				// the value of this node's pivot bit; therefore, this node
				// still has reason to exist.  Update its fields to reflect the
				// change in one of its subtrees.
				child0 = point->CHILDREN[0];
				child1 = point->CHILDREN[1];
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					VALUE(point)[index0] =
						VALUE(child0)[index0] | VALUE(child1)[index0];
					MASK(point)[index0] =
						MASK(child0)[index0] | MASK(child1)[index0];
					IMASK(point)[index0] =
						IMASK(child0)[index0] & IMASK(child1)[index0];
				}
			}
			else
			{
				// No leaf in the same subtree as the removed leaf cares about
				// the value of this node's pivot bit; therefore, there is no
				// longer any reason for this node to exist.  Have the other
				// subtree take the current node's place in the tree; call
				// remove() to remove the unneeded subtree; and delete the
				// current node.
				*ppoint = point->CHILDREN[1 - bit_value];
				if (child != 0)
				{
					eliminate(rhizome, child);
				}
				GpcFreeMem(point, NAT_TAG_RHIZOME);
			}
		}
		else
		{
			// The leaf to be removed does not care about this node's pivot bit;
			// therefore, we must recurse on both of the current node's
			// children.  This node must still be necessary, since we have not
			// removed any leaf which cares about this node's value.  So we
			// update its fields to reflect the change in its two subtrees.
			node_remove(rhizome, leaf, &point->CHILDREN[0]);
			node_remove(rhizome, leaf, &point->CHILDREN[1]);
			child0 = point->CHILDREN[0];
			child1 = point->CHILDREN[1];
			for (index0 = 0; index0 < rhizome->keybytes; index0++)
			{
				VALUE(point)[index0] =
					VALUE(child0)[index0] | VALUE(child1)[index0];
				MASK(point)[index0] =
					MASK(child0)[index0] | MASK(child1)[index0];
				IMASK(point)[index0] =
					IMASK(child0)[index0] & IMASK(child1)[index0];
			}
		}
	}
	else
	{
		// The current node is a leaf node.
		if (point == leaf)
		{
			// The current node is the leaf to be removed; therefore, remove it
			// from chain of godparents.
			*ppoint = leaf->GODPARENT;
		}
		else
		{
			// The current node is not leaf to be removed.  Therefore, if this
			// node has a godparent, then recurse on that godparent.  If this
			// node does not have a godparent, then the to-be-removed leaf
			// either already was removed by a different path, or it was never
			// inserted to begin with.  The latter might be the case if remove()
			// was called from the catch clause of insert().
			if (point->GODPARENT != 0)
			{
				node_remove(rhizome, leaf, &point->GODPARENT);
			}
			// We are now popping back up the recursion stack.  If this node
			// does not have a godparent, or if it did but it does not anymore,
			// then initialize imask to mask; otherwise, copy the godparent's
			// value of imask.  Since the godparent chain follows a strict
			// hierarchy, and since imask is formed by successive conjunction,
			// all leaves in any given godparent chain will have the same value
			// of imask, namely the mask value of the highest god-ancestor.
			if (point->GODPARENT == 0)
			{
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] = MASK(point)[index0];
				}
			}
			else
			{
				for (index0 = 0; index0 < rhizome->keybytes; index0++)
				{
					IMASK(point)[index0] = IMASK(point->GODPARENT)[index0];
				}
			}
		}
	}
}

// Replicate all nodes in a subtree which do not care about the value of
// pivot_bit.
//
static RhizomeNode *
replicate(
	Rhizome *rhizome,
	RhizomeNode *source,
	int pivot_bit)
{
	int index0, current_bit;
	RhizomeNode *new_node, *child0, *child1;
	// If this routine were fully recursive, the following while statement
	// would be an if statement.  However, recursion has been replaced by
	// iteration where possible, so the following code loops until bottoming
	// out when a leaf node is reached.
	while (source->pivot_bit < rhizome->keybits)
	{
		if (BIT_OF(IMASK(source->CHILDREN[0]), pivot_bit) == 0)
		{
			if (BIT_OF(IMASK(source->CHILDREN[1]), pivot_bit) == 0)
			{
				// Both subtrees contain leaves which do not care about the
				// pivot bit; therefore, we may need to make a copy of the
				// current node.  It is not guaranteed that we need to make
				// a copy, since it may be a common leaf in both subtrees
				// that does not care about the pivot bit.  This may happen
				// for a leaf which is a godparent of two leaves, one in each
				// subtree.  Recurse on each child and examine results.
				child0 = replicate(rhizome, source->CHILDREN[0], pivot_bit);
				if (child0 == 0)
				{
					// Memory could not be allocated for the child replica.
					// Therefore, we abort the replication process and pass an
					// indication of failure op the stack.
					return 0;
				}
				child1 = replicate(rhizome, source->CHILDREN[1], pivot_bit);
				if (child1 == 0)
				{
					// Memory could not be allocated for the child replica.
					// Therefore, we abort the replication process, eliminate
					// the other child replica, and pass an indication of
					// failure op the stack.
					eliminate(rhizome, child0);
					return 0;                             // return null pointer
				}
				current_bit = source->pivot_bit;
				if (BIT_OF(MASK(child0), current_bit) == 1)
				{
					if (BIT_OF(MASK(child1), current_bit) == 1)
					{
						// Both replicated child subtrees contain leaves which
						// care about the current node's bit.  Since any node
						// which is a godparent of nodes in both subtrees could
						// not possibly care about the current node's bit, we
						// know that we need to make a copy of the current node.
						NEW_RhizomeNode(&new_node);
						if (new_node == 0)
						{
							// Memory could not be allocated for this new node.
							// Therefore, we have to eliminate both children
							// and pass an indication of failure up the stack.
							eliminate(rhizome, child0);
							eliminate(rhizome, child1);
							return 0;                     // return null pointer
						}
						for (index0 = 0; index0 < rhizome->keybytes; index0++)
						{
							VALUE(new_node)[index0] =
								VALUE(child0)[index0] | VALUE(child1)[index0];
							MASK(new_node)[index0] =
								MASK(child0)[index0] | MASK(child1)[index0];
							IMASK(new_node)[index0] =
								IMASK(child0)[index0] & IMASK(child1)[index0];
						}
						new_node->pivot_bit = current_bit;
						new_node->CHILDREN[0] = child0;
						new_node->CHILDREN[1] = child1;
						return new_node;
					}
					// Child 0's subtree contains a leaf that cares about the
					// current bit; however, child 1's subtree does not.  Thus,
					// all leaves which are in child 1's subtree are also in
					// child 0's subtree, so we only need to keep the latter.
					// We therefore eliminate child 1's subtree, and we return
					// child 0 as the new subtree at this location, since we
					// do not need to create a new branch node here.
					eliminate(rhizome, child1);
					return child0;
				}
				// Child 0's subtree does not contain a leaf that cares about
				// the current node's bit.  Thus, all leaves which are in child
				// 0's subtree are also in child 1's subtree, so we only need to
				// keep the latter.  We therefore eliminate child 0's subtree,
				// and we return child 1 as the new subtree at this location,
				// since we do not need to create a new branch node here.
				eliminate(rhizome, child0);
				return child1;
			}
			// Child 0's subtree contains a leaf which does not care about the
			// pivot bit; however, child 1's subtree does not.  Therefore, we
			// recurse on child 0.  Rather than truly recursing, we update the
			// value of source and iterate once through the while loop.
			source = source->CHILDREN[0];
		}
		else
		{
			// Child 0's subtree does not contain a leaf which does not care
			// about the pivot bit.  Child 1's subtree must contain such a leaf,
			// since the current node's subtree contains such a leaf.  Thus, we
			// recurse on child 1.  Rather than truly recursing, we update the
			// value of source and iterate once through the while loop.
			source = source->CHILDREN[1];
		}
	}
	// A leaf node has been reached.  We now iterate through the godparents of
	// the leaf until we find one which does not care about the pivot bit.
	// Once we find it, we know that all godparents of that leaf also do not
	// care about the pivot bit, since the godparents are arranged in a strict
	// hierarchy.  We thus return the first leaf found which does not care about
	// the value of the pivot bit.
	while (BIT_OF(MASK(source), pivot_bit) == 1)
	{
		source = source->GODPARENT;
	}
	return source;
}

// Eliminate an entire subtree.
//
static void
eliminate(
	Rhizome *rhizome,
	RhizomeNode *point)
{
	RhizomeNode *child;
	// Partial recursion removal.  The while loop takes the place of one of the
	// recursive calls to eliminate().  We eliminate each node and recursively
	// eleminate each subtree under the node.  We do not eliminate leaves, since
	// there is only one copy of each leaf stored in the entire structure.
	while (point->pivot_bit < rhizome->keybits)
	{
		eliminate(rhizome, point->CHILDREN[0]);
		child = point->CHILDREN[1];
		GpcFreeMem(point, NAT_TAG_RHIZOME);
		point = child;
	}
}

// Coalesce leaves of subtree into a linked list and eliminate subtree.  This
// routine is called by the destructor so that it can deallocate the leaf nodes
// after the branch nodes are eliminated.
//
static void
coalesce(
	Rhizome *rhizome,
	RhizomeNode **leaf_list,
	RhizomeNode *point)
{
	RhizomeNode *child, *godparent;
	// Partial recursion removal.  This while loop takes the place of one of
	// the recursive calls to coalesce().  This performs an inorder traversal.
	// We delete each branch node after we have visited it, just as in the
	// eliminate() routine.
	while (point->pivot_bit < rhizome->keybits && point->pivot_bit >= 0)
	{
		coalesce(rhizome, leaf_list, point->CHILDREN[0]);
		child = point->CHILDREN[1];
		GpcFreeMem(point, NAT_TAG_RHIZOME);
		point = child;
	}
	// Once we have found a leaf, we search through the chain of godparents,
	// adding to the list each leaf node that is not already in the list.
	// A pivot_bit of -1 indicates that the leaf is already in the list.
	// If a leaf is in the list, then so are all of its godparents.
	while (point != 0 && point->pivot_bit >= 0)
	{
		godparent = point->GODPARENT;
		point->pivot_bit = -1;
		point->GODPARENT = *leaf_list;
		*leaf_list = point;
		point = godparent;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\sort.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    sort.c

Abstract:

    This module contains routines used for efficiently sorting information.

Author:

    Abolade Gbadegesin  (aboladeg)  18-Feb-1998

    Based on version written for user-mode RAS user-interface.
    (net\routing\ras\ui\common\nouiutil\noui.c).

Revision History:

--*/

#ifndef _SHELLSORT_H_
#define _SHELLSORT_H_


typedef
LONG
(FASTCALL* PCOMPARE_CALLBACK)(
    VOID* ,
    VOID*
    );


NTSTATUS
ShellSort(
    VOID* pItemTable,
    ULONG dwItemSize,
    ULONG dwItemCount,
    PCOMPARE_CALLBACK CompareCallback,
    VOID* pDestinationTable OPTIONAL
    );

VOID
ShellSortIndirect(
    VOID* pItemTable,
    VOID** ppItemTable,
    ULONG dwItemSize,
    ULONG dwItemCount,
    PCOMPARE_CALLBACK CompareCallback
    );


#endif // _SHELLSORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\rhizome.h ===
/*
 *  rhizome.h
 *
 *  author:	John R. Douceur
 *  date:	28 April 1997
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the rhizome database.  The code is object-oriented C, transliterated from
 *  a C++ implementation.
 *
 *  The rhizome is a database that stores patterns containing wildcards.
 *  Each pattern defines a set of keys that it matches; if a pattern contains
 *  N wildcards, then it matches 2^N keys.  Since each pattern can match
 *  multiple keys, it is possible for a given key to match multiple patterns
 *  in the database.  The rhizome requires that all patterns stored therein
 *  have a strict hierarchical interrelationship.  Two patterns may match no
 *  common keys (in which case the patterns are said to be independent), or
 *  one pattern may match all the keys matched by a second pattern as well as
 *  additonal keys (in which case the second pattern is said to be more general
 *  than the first, and the first more specific than the second).  The database
 *  will not accept two patterns which match some keys in common but each of
 *  which also matches additional keys that the other does not.
 *
 *  The database can be searched for patterns that match a given search key.
 *  When the database is searched for a given key, the most specifically
 *  matching pattern is found.  If no patterns in the database match the key,
 *  an appropriate indication is returned.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the rhizome database.
 *
 */

#ifndef _INC_RHIZOME

#define _INC_RHIZOME

#ifdef __cplusplus
extern "C" {
#endif

//
// Macros and definitions needed to duplicate GPC environment
//

#define GpcAllocMem(Addr, Len, _Tag)                                \
    *(Addr) = ExAllocatePoolWithTag(NonPagedPool, (Len), (_Tag))

#define GpcFreeMem(Address, _Tag)   \
    ExFreePool((Address))

typedef NTSTATUS  GPC_STATUS;
#define GPC_STATUS_SUCCESS				STATUS_SUCCESS
#define GPC_STATUS_PENDING				STATUS_PENDING
#define GPC_STATUS_FAILURE				STATUS_UNSUCCESSFUL
#define GPC_STATUS_RESOURCES			STATUS_INSUFFICIENT_RESOURCES
#define GPC_STATUS_NOTREADY				STATUS_DEVICE_NOT_READY 
#define GPC_STATUS_NOT_FOUND			STATUS_NOT_FOUND
#define GPC_STATUS_CONFLICT				STATUS_DUPLICATE_NAME
#define GPC_STATUS_INVALID_HANDLE		STATUS_INVALID_HANDLE
#define GPC_STATUS_INVALID_PARAMETER	STATUS_INVALID_PARAMETER
#define GPC_STATUS_NOT_SUPPORTED    	STATUS_NOT_SUPPORTED
#define GPC_STATUS_NOT_EMPTY            STATUS_DIRECTORY_NOT_EMPTY
#define GPC_STATUS_TOO_MANY_HANDLES     STATUS_TOO_MANY_OPENED_FILES
#define GPC_STATUS_NOT_IMPLEMENTED      STATUS_NOT_IMPLEMENTED
#define GPC_STATUS_INSUFFICIENT_BUFFER	STATUS_BUFFER_TOO_SMALL
#define GPC_STATUS_NO_MEMORY			STATUS_NO_MEMORY
#define GPC_STATUS_IGNORED				1L

/*
 *  There are two basic structures employed: the RhizomeNode and the Rhizome.
 *  Ideally, these would be completely hidden from the client, but the macro
 *  GetReferenceFromPatternHandle requires knowledge of the structure's
 *  definition.  It is strongly urged that the client not directly refer to any
 *  of the fields of either of these structures.  To support the documentation
 *  of the accompanying rhizome.c file, these structures are annotated with
 *  internal comments, but these can be ignored by the reader who wishes only
 *  to understand how to write client code for the rhizome.
 *
 *  The client refers to a pattern by its PatternHandle.  This is typedefed to
 *  a pointer to RhizomeNode, but this fact should be ignored by the client,
 *  since it is an implementation detail.
 *
 */

    //#include <stdlib.h>
    //#include <malloc.h>

struct _RhizomeNode
{
	// This structure is used for both branch nodes and leaf nodes.  The two
	// are distinguished by the value of the pivot_bit field.  For branch
	// nodes, pivot_bit < keybits, and for leaf nodes, pivot_bit == keybits.

	int pivot_bit;            // for branch nodes, bit of key on which to branch
	union
	{
		struct                                           // data for branch node
		{
			struct _RhizomeNode *children[2];  // pointers to children in search
		} branch;
		struct                                             // data for leaf node
		{
			void *reference;               // reference value supplied by client
			struct _RhizomeNode *godparent;   // pointer to more general pattern
		} leaf;
	} udata;
	char cdata[1];            // space for storing value, mask, and imask fields
};

typedef struct _RhizomeNode RhizomeNode;

struct _Rhizome
{
	int keybits;          // number of bits in key
	int keybytes;         // number of bytes in key, calculated from keybits
	RhizomeNode *root;    // root of search trie
};

typedef struct _Rhizome Rhizome;

// The client uses PatternHandle to refer to patterns stored in the database.
typedef RhizomeNode *PatternHandle;

/*
 *  The client interface to the rhizome is provided by five functions and two
 *  macros.  It is expected that the client will first instantiate a database,
 *  either on the stack or the heap, and then insert patterns with corresponding
 *  reference information into the database.  When the client then performs a
 *  search on a key, the client wishes to know which pattern most specifically
 *  matches the key, and it ultimately wants the reference information
 *  associated with the most specifically matching pattern.
 *
 */

// A rhizome may be allocated on the stack simply by declaring a variable of
// type Rhizome.  To allocate it on the heap, the following macro returns a
// pointer to a new Rhizome structure.  If this macro is used, a corresponding
// call to free() must be made to deallocate the structure from the heap.
//
//#define NEW_Rhizome ((Rhizome *)malloc(sizeof(Rhizome)))

#define AllocateRhizome(_r)   GpcAllocMem(&(_r), sizeof(Rhizome), NAT_TAG_RHIZOME)
#define FreeRhizome(_r)       GpcFreeMem((_r), NAT_TAG_RHIZOME)

// Since this is not C++, the Rhizome structure is not self-constructing;
// therefore, the following constructor code must be called on the Rhizome
// structure after it is allocated.  The argument keybits specifies the size
// (in bits) of each pattern that will be stored in the database.
//
void
constructRhizome(
	Rhizome *rhizome,
	int keybits);

// Since this is not C++, the Rhizome structure is not self-destructing;
// therefore, the following destructor code must be called on the Rhizome
// structure before it is deallocated.  However, if the client code can be
// sure, based upon its usage of the database, that all patterns have been
// removed before the structure is deallocated, then this function is
// unnecessary.
//
void
destructRhizome(
	Rhizome *rhizome);

// Once the Rhizome structure has been allocated and constructed, patterns can
// be inserted into the database.  Each pattern is specified by a value and a
// mask.  Each bit of the mask determines whether the bit position is specified
// or is a wildcard:  A 1 in a mask bit indicates that the value of that bit is
// specified by the pattern; a 0 indicates that the value of that bit is a
// wildcard.  If a mask bit is 1, then the corresponding bit in the value field
// indicates the specified value of that bit.  Value and mask fields are passed
// as arrays of bytes.
//
// The client also specifies a reference value, as a void pointer, that it
// wishes to associate with this pattern.  When the pattern is installed, the
// insertRhizome function returns a pointer to a PatternHandle.  From the
// PatternHandle can be gotten the reference value via the macro
// GetReferenceFromPatternHandle.
//
// If the new pattern conflicts with a pattern already installed in the
// database, meaning that the two patterns match some keys in common but each
// also matches additional keys that the other does not, then the new pattern
// is not inserted, and a value of 0 is returned as the PatternHandle.
//
PatternHandle
insertRhizome(
	Rhizome *rhizome,
	char *value,
	char *mask,
	void *reference,
    ulong *status);

// This function removes a pattern from the rhizome.  The pattern is specified
// by the PatternHandle that was returned by the insertRhizome function.  No
// checks are performed to insure that this is a valid handle, so the client
// must discard the handle after it has called removeRhizome.
//
void
removeRhizome(
	Rhizome *rhizome,
	PatternHandle phandle);

// This function searches the database for the pattern that most specifically
// matches the given key.  The key is passed as an array of bytes.  When the
// most specific match is found, the PatternHandle of that matching pattern is
// returned.  From the PatternHandle can be gotten the reference value via the
// macro GetReferenceFromPatternHandle.  If no pattern in the database is found
// to match the key, then a value of 0 is returned as the PatternHandle.
//
PatternHandle
searchRhizome(
	Rhizome *rhizome,
	char *key);

// To get the client-supplied reference value from a PatternHandle, the
// following macro should be used.  The client should not make assumptions
// about the details of the RhizomeNode structure, nor should it even assume
// that the PatternHandle is a pointer to a RhizomeNode.
//
#define GetReferenceFromPatternHandle(phandle) ((PatternHandle)phandle)->udata.leaf.reference
#define GetKeyPtrFromPatternHandle(_r,phandle) (((PatternHandle)phandle)->cdata)
#define GetMaskPtrFromPatternHandle(_r,phandle) (((PatternHandle)phandle)->cdata + (_r)->keybytes)
#define GetKeySizeBytes(_r) ((_r)->keybytes)
#define GetNextMostSpecificMatchingPatternHandle(phandle) ((phandle)->udata.leaf.godparent)

#ifdef __cplusplus
}
#endif

#endif	/* _INC_RHIZOME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\sort.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    sort.c

Abstract:

    This module contains routines used for efficiently sorting information.

Author:

    Abolade Gbadegesin  (aboladeg)  18-Feb-1998

    Based on version written for user-mode RAS user-interface.
    (net\routing\ras\ui\common\nouiutil\noui.c).

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
ShellSort(
    VOID* pItemTable,
    ULONG dwItemSize,
    ULONG dwItemCount,
    PCOMPARE_CALLBACK CompareCallback,
    VOID* pDestinationTable OPTIONAL
    )

    /* Sort an array of items in-place using shell-sort.
    ** This function calls ShellSortIndirect to sort a table of pointers
    ** to table items. We then move the items into place by copying.
    ** This algorithm allows us to guarantee that the number
    ** of copies necessary in the worst case is N + 1.
    **
    ** Note that if the caller merely needs to know the sorted order
    ** of the array, ShellSortIndirect should be called since that function
    ** avoids moving items altogether, and instead fills an array with pointers
    ** to the array items in the correct order. The array items can then
    ** be accessed through the array of pointers.
    */
{

    VOID** ppItemTable;

    LONG N;
    LONG i;
    UCHAR *a, **p, *t = NULL;

    if (!dwItemCount) { return STATUS_SUCCESS; }


    /* allocate space for the table of pointers.
    */
    ppItemTable =
        ExAllocatePoolWithTag(
            NonPagedPool,
            dwItemCount * sizeof(VOID*),
            NAT_TAG_SORT
            );

    if (!ppItemTable) { return STATUS_NO_MEMORY; }


    /* call ShellSortIndirect to fill our table of pointers
    ** with the sorted positions for each table element.
    */
    ShellSortIndirect(
        pItemTable, ppItemTable, dwItemSize, dwItemCount, CompareCallback );


    /* now that we know the sort order, move each table item into place.
    ** This is easy if we are sorting to a different array.
    */

    if (pDestinationTable) {
        for (i = 0; i < (LONG)dwItemCount; i++)
        {
            RtlCopyMemory(
                (PUCHAR)pDestinationTable + i * dwItemSize,
                ppItemTable[i],
                dwItemSize
                );
        }
        ExFreePool(ppItemTable);
        return STATUS_SUCCESS;
    }


    /* We are sorting in-place, which is a little more involved.
    ** This involves going through the table of pointers making sure
    ** that the item which should be in 'i' is in fact in 'i', moving
    ** things around if necessary to achieve this condition.
    */

    a = (UCHAR*)pItemTable;
    p = (UCHAR**)ppItemTable;
    N = (LONG)dwItemCount;

    for (i = 0; i < N; i++)
    {
        LONG j, k;
        UCHAR* ai =  (a + i * dwItemSize), *ak, *aj;

        /* see if item 'i' is not in-place
        */
        if (p[i] != ai)
        {


            /* item 'i' isn't in-place, so we'll have to move it.
            ** if we've delayed allocating a temporary buffer so far,
            ** we'll need one now.
            */

            if (!t) {
                t =
                    ExAllocatePoolWithTag(
                        NonPagedPool,
                        dwItemSize, 
                        NAT_TAG_SORT
                        );
                if (!t) { return STATUS_NO_MEMORY; }
            }

            /* save a copy of the item to be overwritten
            */
            RtlCopyMemory(t, ai, dwItemSize);

            k = i;
            ak = ai;


            /* Now move whatever item is occupying the space where it should be.
            ** This may involve moving the item occupying the space where
            ** it should be, etc.
            */

            do
            {

                /* copy the item which should be in position 'j'
                ** over the item which is currently in position 'j'.
                */
                j = k;
                aj = ak;
                RtlCopyMemory(aj, p[j], dwItemSize);

                /* set 'k' to the position from which we copied
                ** into position 'j'; this is where we will copy
                ** the next out-of-place item in the array.
                */
                ak = p[j];
                k = (ULONG)(ak - a) / dwItemSize;

                /* keep the array of position pointers up-to-date;
                ** the contents of 'aj' are now in their sorted position.
                */
                p[j] = aj;

            } while (ak != ai);


            /* now write the item which we first overwrote.
            */
            RtlCopyMemory(aj, t, dwItemSize);
        }
    }

    if (t) { ExFreePool(t); }
    ExFreePool(ppItemTable);

    return STATUS_SUCCESS;
}


VOID
ShellSortIndirect(
    VOID* pItemTable,
    VOID** ppItemTable,
    ULONG dwItemSize,
    ULONG dwItemCount,
    PCOMPARE_CALLBACK CompareCallback
    )

    /* Sorts an array of items indirectly using shell-sort.
    ** 'pItemTable' points to the table of items, 'dwItemCount' is the number
    ** of items in the table,  and 'CompareCallback' is a function called
    ** to compare items.
    **
    ** Rather than sort the items by moving them around,
    ** we sort them by initializing the table of pointers 'ppItemTable'
    ** with pointers such that 'ppItemTable[i]' contains a pointer
    ** into 'pItemTable' for the item which would be in position 'i'
    ** if 'pItemTable' were sorted.
    **
    ** For instance, given an array pItemTable of 5 strings as follows
    **
    **      pItemTable[0]:      "xyz"
    **      pItemTable[1]:      "abc"
    **      pItemTable[2]:      "mno"
    **      pItemTable[3]:      "qrs"
    **      pItemTable[4]:      "def"
    **
    ** on output ppItemTable contains the following pointers
    **
    **      ppItemTable[0]:     &pItemTable[1]  ("abc")
    **      ppItemTable[1]:     &pItemTable[4]  ("def")
    **      ppItemTable[2]:     &pItemTable[2]  ("mno")
    **      ppItemTable[3]:     &pItemTable[3]  ("qrs")
    **      ppItemTable[4]:     &pItemTable[0]  ("xyz")
    **
    ** and the contents of pItemTable are untouched.
    ** And the caller can print out the array in sorted order using
    **      for (i = 0; i < 4; i++) {
    **          printf("%s\n", (char *)*ppItemTable[i]);
    **      }
    */
{

    /* The following algorithm is derived from Sedgewick's Shellsort,
    ** as given in "Algorithms in C++".
    **
    ** The Shellsort algorithm sorts the table by viewing it as
    ** a number of interleaved arrays, each of whose elements are 'h'
    ** spaces apart for some 'h'. Each array is sorted separately,
    ** starting with the array whose elements are farthest apart and
    ** ending with the array whose elements are closest together.
    ** Since the 'last' such array always has elements next to each other,
    ** this degenerates to Insertion sort, but by the time we get down
    ** to the 'last' array, the table is pretty much sorted.
    **
    ** The sequence of values chosen below for 'h' is 1, 4, 13, 40, 121, ...
    ** and the worst-case running time for the sequence is N^(3/2), where
    ** the running time is measured in number of comparisons.
    */

    ULONG dwErr;
    LONG i, j, h, N;
    UCHAR* a, *v, **p;


    a = (UCHAR*)pItemTable;
    p = (UCHAR**)ppItemTable;
    N = (LONG)dwItemCount;

    /* Initialize the table of position pointers.
    */
    for (i = 0; i < N; i++) { p[i] = (a + i * dwItemSize); }


    /* Move 'h' to the largest increment in our series
    */
    for (h = 1; h < N/9; h = 3 * h + 1) { }


    /* For each increment in our series, sort the 'array' for that increment
    */
    for ( ; h > 0; h /= 3)
    {

        /* For each element in the 'array', get the pointer to its
        ** sorted position.
        */
        for (i = h; i < N; i++)
        {
            /* save the pointer to be inserted
            */
            v = p[i]; j = i;

            /* Move all the larger elements to the right
            */
            while (j >= h && CompareCallback(p[j - h], v) > 0)
            {
                p[j] = p[j - h]; j -= h;
            }

            /* put the saved pointer in the position where we stopped.
            */
            p[j] = v;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\timer.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module:

    timer.c

Abstract:

    Contains code for the NAT's periodic-timer routine.

Author:

    Abolade Gbadegesin (t-abolag)   22-July-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Defines the interval at which the timer fires, in 100-nanosecond intervals
//

#define TIMER_INTERVAL              (60 * 1000 * 1000 * 10)

//
// DPC object for stress-triggered invocations of NatTimerRoutine
//

KDPC CleanupDpcObject;

//
// Flag indicating whether stress-triggered cleanup has been scheduled.
//

ULONG CleanupDpcPending;

//
// Return-value of KeQueryTimeIncrement, used for normalizing tick-counts
//

ULONG TimeIncrement;

//
// DPC object for NatTimerRoutine
//

KDPC TimerDpcObject;

//
// Timer object for NatTimerRoutine
//

KTIMER TimerObject;

//
// FORWARD DECLARATIONS
//

VOID
NatCleanupDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
NatTimerRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );


VOID
NatCleanupDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;

    KeAcquireSpinLock(&MappingLock, &Irql);
    for (Link = MappingList.Flink; Link != &MappingList; Link = Link->Flink) {
        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, Link);
        if (NAT_MAPPING_EXPIRED(Mapping)) {
            Link = Link->Blink;
            NatDeleteMapping(Mapping);
        }
    }
    KeReleaseSpinLock(&MappingLock, Irql);

    InterlockedExchange(&CleanupDpcPending, FALSE);
}


VOID
NatInitializeTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the timer-management module,
    in preparation for active operation.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeTimerManagement\n"));
    TimeIncrement = KeQueryTimeIncrement();
    KeInitializeDpc(&TimerDpcObject, NatTimerRoutine, NULL);
    KeInitializeTimer(&TimerObject);
    CleanupDpcPending = FALSE;
    KeInitializeDpc(&CleanupDpcObject, NatCleanupDpcRoutine, NULL);
} // NatInitializeTimerManagement


VOID
NatShutdownTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the timer management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatShutdownTimerManagement\n"));
    NatStopTimer();
} // NatShutdownTimerManagement


VOID
NatStartTimer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to start the periodic timer.

Arguments:

    none.

Return Value:

    none.

--*/

{
    LARGE_INTEGER DueTime;

    //
    // Launch the periodic timer
    //

    DueTime.LowPart = TIMER_INTERVAL;
    DueTime.HighPart = 0;
    DueTime = RtlLargeIntegerNegate(DueTime);
    KeSetTimerEx(
        &TimerObject,
        DueTime,
        TIMER_INTERVAL / 10000,
        &TimerDpcObject
        );
}


VOID
NatStopTimer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the periodic timer.

Arguments:

    none.

Return Value:

    none.

--*/

{
    KeCancelTimer(&TimerObject);
}


VOID
NatTimerRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is invoked periodically to garbage-collect expired mappings.

Arguments:

    Dpc - associated DPC object

    DeferredContext - unused.

    SystemArgument1 - unused.

    SystemArgument2 - unused.

Return Value:

    none.

--*/

{
    LONG64 CurrentTime;
    PNAT_EDITOR Editor;
    PNAT_ICMP_MAPPING IcmpMapping;
    PNAT_INTERFACE Interfacep;
    PNAT_IP_MAPPING IpMapping;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    PNAT_PPTP_MAPPING PptpMapping;
    UCHAR Protocol;
    PRTL_SPLAY_LINKS SLink;
    PNAT_TICKET Ticketp;
    LONG64 Timeout;
    LONG64 TcpMinAccessTime;
    LONG64 UdpMinAccessTime;

    CALLTRACE(("NatTimerRoutine\n"));

    //
    // Compute the minimum values allowed in TCP/UDP 'LastAccessTime' fields;
    // any mappings last accessed before these thresholds will be eliminated.
    //

    KeQueryTickCount((PLARGE_INTEGER)&CurrentTime);
    TcpMinAccessTime = CurrentTime - SECONDS_TO_TICKS(TcpTimeoutSeconds);
    UdpMinAccessTime = CurrentTime - SECONDS_TO_TICKS(UdpTimeoutSeconds);

    //
    // Update mapping statistics and clean out expired mappings,
    // using the above precomputed minimum access times
    //

    KeAcquireSpinLock(&MappingLock, &Irql);
    for (Link = MappingList.Flink; Link != &MappingList; Link = Link->Flink) {

        Mapping = CONTAINING_RECORD(Link, NAT_DYNAMIC_MAPPING, Link);
        NatUpdateStatisticsMapping(Mapping);

        //
        // Don't check for expiration if the mapping is marked no-timeout;
        // however, if it is detached from its director, then go ahead
        // with the expiration-check.
        //

        if (!NAT_MAPPING_EXPIRED(Mapping) && NAT_MAPPING_NO_TIMEOUT(Mapping) &&
            Mapping->Director) {
            continue;
        }

        //
        // See if the mapping has expired
        //

        KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);
        Protocol = MAPPING_PROTOCOL(Mapping->SourceKey[NatForwardPath]);
        if (!NAT_MAPPING_EXPIRED(Mapping)) {
            //
            // The mapping is not explicitly marked for expiration;
            // see if its last access time is too long ago
            //
            if (Protocol == NAT_PROTOCOL_TCP) {
                if (!NAT_MAPPING_INBOUND(Mapping)) {
                    if ((Mapping->Flags & NAT_MAPPING_FLAG_FWD_SYN)
                        && !(Mapping->Flags & NAT_MAPPING_FLAG_REV_SYN)) {

                        //
                        // This is an outbound connection for which we've seen
                        // the outbound SYN (which means we've been tracking
                        // it from the beginning), but not an inbound SYN. We
                        // want to use a smaller timeout here so that we may
                        // reclaim memory for mappings created for connection
                        // attempts to non-existant servers. (A large number
                        // of these types of mappings would exist if a machine
                        // on the private network is performing some sort of a
                        // network scan; e.g., a machine infected w/ nimda.)
                        //
                        
                        if (Mapping->LastAccessTime >= UdpMinAccessTime) {
                            KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
                            continue;
                        }
                    }
                    else if (Mapping->LastAccessTime >= TcpMinAccessTime) {
                        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
                        continue;
                    }
                } else if (!NAT_MAPPING_TCP_OPEN(Mapping)) {

                    //
                    // This is an inbound connection for which we have not
                    // yet completed the 3-way handshake. We want to use
                    // a shorter timeout here to reduce memory consumption
                    // in those cases where someone is performing a synflood
                    // against us.
                    //

                    if (Mapping->LastAccessTime >= UdpMinAccessTime) {
                        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
                        continue;
                    }                    
                } else if (Mapping->LastAccessTime >= TcpMinAccessTime) {
                    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
                    continue;
                }
            }
            else
            if (Mapping->LastAccessTime >= UdpMinAccessTime) {
                KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
                continue;
            }
        }
        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

        //
        // The mapping has expired; remove it
        //

        TRACE(
            MAPPING, (
            "NatTimerRoutine: >Source,Destination=%016I64X:%016I64X\n",
            Mapping->SourceKey[NatForwardPath],
            Mapping->DestinationKey[NatForwardPath]
            ));
        TRACE(
            MAPPING, (
            "NatTimerRoutine: <Source,Destination=%016I64X:%016I64X\n",
            Mapping->SourceKey[NatReversePath],
            Mapping->DestinationKey[NatReversePath]
            ));

        Link = Link->Blink;
        NatDeleteMapping(Mapping);
    }
    KeReleaseSpinLockFromDpcLevel(&MappingLock);

    //
    // Traverse the PPTP-mapping list and remove all expired entries.
    //

    KeAcquireSpinLockAtDpcLevel(&PptpMappingLock);
    for (Link = PptpMappingList[NatInboundDirection].Flink;
         Link != &PptpMappingList[NatInboundDirection]; Link = Link->Flink) {
        PptpMapping =
            CONTAINING_RECORD(
                Link, NAT_PPTP_MAPPING, Link[NatInboundDirection]
                );
        if (!NAT_PPTP_DISCONNECTED(PptpMapping) ||
            PptpMapping->LastAccessTime >= UdpMinAccessTime) {
            continue;
        }
        Link = Link->Blink;
        RemoveEntryList(&PptpMapping->Link[NatInboundDirection]);
        RemoveEntryList(&PptpMapping->Link[NatOutboundDirection]);
        TRACE(
            MAPPING, ("NatTimerRoutine: Pptp=%016I64X:%016I64X:%d:%d:%d\n",
            PptpMapping->PrivateKey,
            PptpMapping->PublicKey,
            PptpMapping->PrivateCallId,
            PptpMapping->PublicCallId,
            PptpMapping->RemoteCallId
            ));
        FREE_PPTP_BLOCK(PptpMapping);
    }
    KeReleaseSpinLockFromDpcLevel(&PptpMappingLock);

    //
    // Traverse the ICMP-mapping list and remove each expired entry.
    //

    KeAcquireSpinLockAtDpcLevel(&IcmpMappingLock);
    for (Link = IcmpMappingList[NatInboundDirection].Flink;
         Link != &IcmpMappingList[NatInboundDirection]; Link = Link->Flink) {
        IcmpMapping =
            CONTAINING_RECORD(
                Link, NAT_ICMP_MAPPING, Link[NatInboundDirection]
                );
        if (IcmpMapping->LastAccessTime >= UdpMinAccessTime) { continue; }
        Link = Link->Blink;
        RemoveEntryList(&IcmpMapping->Link[NatInboundDirection]);
        RemoveEntryList(&IcmpMapping->Link[NatOutboundDirection]);
        TRACE(
            MAPPING,
            ("NatTimerRoutine: Icmp=%016I64X:%04X::%016I64X:%04X\n",
            IcmpMapping->PrivateKey, IcmpMapping->PrivateId,
            IcmpMapping->PublicKey, IcmpMapping->PublicId
            ));
        FREE_ICMP_BLOCK(IcmpMapping);
    }
    KeReleaseSpinLockFromDpcLevel(&IcmpMappingLock);

    //
    // Traverse the interface's IP-mapping list
    // and remove each expired entry.
    //

    KeAcquireSpinLockAtDpcLevel(&IpMappingLock);
    for (Link = IpMappingList[NatInboundDirection].Flink;
         Link != &IpMappingList[NatInboundDirection]; Link = Link->Flink) {
        IpMapping =
            CONTAINING_RECORD(
                Link, NAT_IP_MAPPING, Link[NatInboundDirection]
                );
        if (IpMapping->LastAccessTime >= UdpMinAccessTime) { continue; }
        Link = Link->Blink;
        RemoveEntryList(&IpMapping->Link[NatInboundDirection]);
        RemoveEntryList(&IpMapping->Link[NatOutboundDirection]);
        TRACE(
            MAPPING, (
            "NatTimerRoutine: Ip=%d:%016I64X:%016I64X\n",
            IpMapping->Protocol, IpMapping->PrivateKey, IpMapping->PublicKey
            ));
        FREE_IP_BLOCK(IpMapping);
    }
    KeReleaseSpinLockFromDpcLevel(&IpMappingLock);

    //
    // Garbage collect all interfaces' structures
    //

    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);

    for (Link = InterfaceList.Flink; Link != &InterfaceList;
         Link = Link->Flink) {

        Interfacep = CONTAINING_RECORD(Link, NAT_INTERFACE, Link);

        //
        // Traverse the interface's ticket list
        //

        KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
        for (Link = Interfacep->TicketList.Flink;
             Link != &Interfacep->TicketList; Link = Link->Flink) {
            Ticketp = CONTAINING_RECORD(Link, NAT_TICKET, Link);
            if (NAT_TICKET_PERSISTENT(Ticketp)) { continue; }
            if (Ticketp->LastAccessTime >= UdpMinAccessTime) { continue; }
            Link = Link->Blink;
            NatDeleteTicket(Interfacep, Ticketp);
        }
        KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
        Link = &Interfacep->Link;
    }
    KeReleaseSpinLock(&InterfaceLock, Irql);
    return;

} // NatTimerRoutine


VOID
NatTriggerTimer(
    VOID
    )
{
    if (!InterlockedCompareExchange(&CleanupDpcPending, TRUE, FALSE)) {
#if DBG
        DbgPrint("NatTriggerTimer: scheduling DPC\n");
#endif
        KeInsertQueueDpc(&CleanupDpcObject, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\ticket.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    ticket.h

Abstract:

    This module contains declarations for the NAT's ticket-management.

    A NAT ticket is a dynamically-created token which allows any external
    endpoint to establish a session to an internal endpoint using an allocated
    public address/port pair. For instance, a streaming protocol might create
    a ticket for a dynamically-negotiated secondary session to be established.

Author:

    Abolade Gbadegesin (t-abolag)   21-Aug-1997

Revision History:

    Abolade Gbadegesin (aboladeg)   16-Apr-1998

    Allow wildcard tickets to be created by specifying zero for a field.
    'NatLookupAndRemoveTicket' may be used to retrieve such tickets.

    Abolade Gbadegesin (aboladeg)   17-Oct-1998

    Eliminated wildcard ticket support. Created dynamic ticket support.
    (See 'NAT_DYNAMIC_TICKET' below.)

--*/

#ifndef _NAT_TICKET_H_
#define _NAT_TICKET_H_


//
// Structure:   NAT_TICKET
//
// This structure holds all the information we need about a ticket.
// Each instance is linked into a sorted per-interface list of tickets
// which is protected by the interface's lock.
//

typedef struct _NAT_TICKET {
    LIST_ENTRY Link;
    ULONG64 Key;
    ULONG64 RemoteKey;
    PNAT_USED_ADDRESS UsedAddress;
    ULONG PrivateAddress;
    USHORT PrivateOrHostOrderEndPort;
    ULONG Flags;
    LONG64 LastAccessTime;
} NAT_TICKET, *PNAT_TICKET;

//
// Structure:   NAT_DYNAMIC_TICKET
//
// This structure holds the description of a dynamic ticket.
// Such a ticket is created so that when an outbound session is translated
// with a given destination port, a ticket can be created for a corresponding
// inbound session to a predetermined port, or to one of a range of ports.
//

typedef struct _NAT_DYNAMIC_TICKET {
    LIST_ENTRY Link;
    ULONG Key;
    ULONG ResponseCount;
    struct {
        UCHAR Protocol;
        USHORT StartPort;
        USHORT EndPort;
    }* ResponseArray;
    PFILE_OBJECT FileObject;
} NAT_DYNAMIC_TICKET, *PNAT_DYNAMIC_TICKET;

//
// Ticket flags
//

#define NAT_TICKET_FLAG_PERSISTENT      0x00000001
#define NAT_TICKET_PERSISTENT(t) \
    ((t)->Flags & NAT_TICKET_FLAG_PERSISTENT)

#define NAT_TICKET_FLAG_PORT_MAPPING    0x00000002
#define NAT_TICKET_PORT_MAPPING(t) \
    ((t)->Flags & NAT_TICKET_FLAG_PORT_MAPPING)

#define NAT_TICKET_FLAG_IS_RANGE        0x00000004
#define NAT_TICKET_IS_RANGE(t) \
    ((t)->Flags & NAT_TICKET_FLAG_IS_RANGE)

//
// Ticket-key manipulation macros
//

#define MAKE_TICKET_KEY(Protocol,Address,Port) \
    ((Address) | \
    ((ULONG64)((Port) & 0xFFFF) << 32) | \
    ((ULONG64)((Protocol) & 0xFF) << 48))

#define TICKET_PROTOCOL(Key)            ((UCHAR)(((Key) >> 48) & 0xFF))
#define TICKET_PORT(Key)                ((USHORT)(((Key) >> 32) & 0xFFFF))
#define TICKET_ADDRESS(Key)             ((ULONG)(Key))

#define MAKE_DYNAMIC_TICKET_KEY(Protocol, Port) \
    ((ULONG)((Port) & 0xFFFF) | ((ULONG)((Protocol) & 0xFF) << 16))

#define DYNAMIC_TICKET_PROTOCOL(Key)    ((UCHAR)(((Key) >> 16) & 0xFF))
#define DYNAMIC_TICKET_PORT(Key)        ((USHORT)((Key) & 0xFFFF))

//
// Ticket allocation macros
//

#define ALLOCATE_TICKET_BLOCK() \
    (PNAT_TICKET)ExAllocatePoolWithTag( \
        NonPagedPool,sizeof(NAT_TICKET), NAT_TAG_TICKET \
        )

#define FREE_TICKET_BLOCK(Block) \
    ExFreePool(Block)

//
// GLOBAL DATA DECLARATIONS
//

ULONG DynamicTicketCount;
ULONG TicketCount;


//
// TICKET MANAGEMENT ROUTINES
//

NTSTATUS
NatCreateDynamicTicket(
    PIP_NAT_CREATE_DYNAMIC_TICKET CreateTicket,
    ULONG InputBufferLength,
    PFILE_OBJECT FileObject
    );

NTSTATUS
NatCreateTicket(
    PNAT_INTERFACE Interfacep,
    UCHAR Protocol,
    ULONG PrivateAddress,
    USHORT PrivatePort,
    ULONG RemoteAddress OPTIONAL,
    ULONG RemotePort OPTIONAL,
    ULONG Flags,
    PNAT_USED_ADDRESS AddressToUse OPTIONAL,
    USHORT PortToUse OPTIONAL,
    PULONG PublicAddress,
    PUSHORT PublicPort
    );

VOID
NatDeleteAnyAssociatedDynamicTicket(
    PFILE_OBJECT FileObject
    );

NTSTATUS
NatDeleteDynamicTicket(
    PIP_NAT_DELETE_DYNAMIC_TICKET DeleteTicket,
    PFILE_OBJECT FileObject
    );

VOID
NatDeleteTicket(
    PNAT_INTERFACE Interfacep,
    PNAT_TICKET Ticketp
    );

VOID
NatInitializeDynamicTicketManagement(
    VOID
    );

BOOLEAN
NatIsPortUsedByTicket(
    PNAT_INTERFACE Interfacep,
    UCHAR Protocol,
    USHORT PublicPort
    );

VOID
NatLookupAndApplyDynamicTicket(
    UCHAR Protocol,
    USHORT DestinationPort,
    PNAT_INTERFACE Interfacep,
    ULONG PublicAddress,
    ULONG PrivateAddress
    );

NTSTATUS
NatLookupAndDeleteTicket(
    PNAT_INTERFACE Interfacep,
    ULONG64 Key,
    ULONG64 RemoteKey
    );

NTSTATUS
NatLookupAndRemoveTicket(
    PNAT_INTERFACE Interfacep,
    ULONG64 Key,
    ULONG64 RemoteKey,
    PNAT_USED_ADDRESS* UsedAddress,
    PULONG PrivateAddress,
    PUSHORT PrivatePort
    );

PNAT_TICKET
NatLookupFirewallTicket(
    PNAT_INTERFACE Interfacep,
    UCHAR Protocol,
    USHORT Port
    );

PNAT_TICKET
NatLookupTicket(
    PNAT_INTERFACE Interfacep,
    ULONG64 Key,
    ULONG64 RemoteKey,
    PLIST_ENTRY* InsertionPoint
    );

PNAT_DYNAMIC_TICKET
NatLookupDynamicTicket(
    ULONG Key,
    PLIST_ENTRY* InsertionPoint
    );

NTSTATUS
NatProcessCreateTicket(
    PIP_NAT_CREATE_TICKET CreateTicket,
    PFILE_OBJECT FileObject
    );

NTSTATUS
NatProcessDeleteTicket(
    PIP_NAT_CREATE_TICKET DeleteTicket,
    PFILE_OBJECT FileObject
    );

NTSTATUS
NatProcessLookupTicket(
    PIP_NAT_CREATE_TICKET LookupTicket,
    PIP_NAT_PORT_MAPPING Ticket,
    PFILE_OBJECT FileObject
    );

VOID
NatShutdownDynamicTicketManagement(
    VOID
    );

#endif // _NAT_TICKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\xlate.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    xlate.c

Abstract:

    This module contains the code for translation of IP datagrams.
    'NatTranslatePacket' is the routine directly invoked by TCPIP.SYS
    for every locally-received and locally-generated packet.
    Also included here is the cache of routes used to optimize forwarding.

Author:

    Abolade Gbadegesin (t-abolag)   16-July-1997

Revision History:

    Abolade Gbadegesin (aboladeg)   15-Apr-1998

    Added route-lookup cache; first stable version of multiple-client
    firewall hook.

--*/

#include "precomp.h"
#pragma hdrstop

//
// GLOBAL DATA DECLARATIONS
//

//
// Index of TCP/IP loopback interface
//

ULONG LoopbackIndex;

//
// Cache of routing-information
//

CACHE_ENTRY RouteCache[CACHE_SIZE];

//
// I/O request packet for notification of changes to the IP routing table.
//

PIRP RouteCacheIrp;

//
// Spin-lock controlling access to all route-cache information
//

KSPIN_LOCK RouteCacheLock;

//
// Array of entries corresponding to locations in 'RouteCache'
//

NAT_CACHED_ROUTE RouteCacheTable[CACHE_SIZE];

//
// Array of translation routines, indexed by IP protocol
//

PNAT_IP_TRANSLATE_ROUTINE TranslateRoutineTable[256];

//
// CONSTANTS
//

//
// The boundary for UDP loose source matching. A mapping must
// have private port greater than this to allow another session
// to be created by a UDP packet that matches only the public
// endpoint.
//

#define NAT_XLATE_UDP_LSM_LOW_PORT 1024

//
// FORWARD DECLARATIONS
//

NTSTATUS
NatpDirectPacket(
    ULONG ReceiveIndex,
    ULONG SendIndex,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer,
    FORWARD_ACTION* ForwardAction
    );

FORWARD_ACTION
NatpForwardPacket(
    ULONG ReceiveIndex,
    ULONG SendIndex,
    PNAT_XLATE_CONTEXT Contextp,
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    );

BOOLEAN
FASTCALL
NatpIsUnicastPacket(
    ULONG Address
    );

FORWARD_ACTION
NatpReceiveNonUnicastPacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp
    );

FORWARD_ACTION
NatpReceivePacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp,
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    );

NTSTATUS
NatpRouteChangeCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

ULONG
FASTCALL
NatpRoutePacket(
    ULONG DestinationAddress,
    PNAT_XLATE_CONTEXT Contextp OPTIONAL,
    PNTSTATUS Status
    );

FORWARD_ACTION
NatpSendNonUnicastPacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp
    );

FORWARD_ACTION
NatpSendPacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp,
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    );

FORWARD_ACTION
NatpTranslateLocalTraffic(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InRecvBuffer,
    IPRcvBuf** OutRecvBuffer
    );



FORWARD_ACTION
NatForwardTcpStateCheck(
    PNAT_DYNAMIC_MAPPING pMapping,
    PTCP_HEADER pTcpHeader
    )

/*++

Routine Description:

    This routine validates that packets for a TCP active open are valid:
    -- only SYN at first
    -- after the SYN/ACK, either only SYN (SYN/ACK lost) or only ACK
    -- after the ACK of SYN/ACK (connection open), no SYN

Arguments:

    pMapping -- the mapping this packet belongs to

    pTcpHeader -- the TCP header of the packet

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

Environment:

    Invoked with pMapping->Lock held by the caller

--*/

{
    USHORT Flags = TCP_ALL_FLAGS(pTcpHeader);

    if (NAT_MAPPING_TCP_OPEN(pMapping)) {

        //
        // Connection open -- SYN not allowed
        //

        return (Flags & TCP_FLAG_SYN) ? DROP : FORWARD;

    } else if( pMapping->Flags & NAT_MAPPING_FLAG_REV_SYN ) {
    
        ASSERT( pMapping->Flags & NAT_MAPPING_FLAG_FWD_SYN );
        
        if ((Flags & TCP_FLAG_ACK) && !(Flags & TCP_FLAG_SYN)) {
        
            //
            // This is the ACK of the SYN/ACK -- connection now open
            //
            
            pMapping->Flags |= NAT_MAPPING_FLAG_TCP_OPEN;
        } else if (TCP_FLAG_SYN != Flags
                   && TCP_FLAG_RST != Flags
                   && (TCP_FLAG_ACK | TCP_FLAG_RST) != Flags) {

            //
            // It's not an ACK of the SYN/ACK, it's not a RST (or ACK/RST),
            // and it's not a retransmittal of the SYN (possible
            // in this state, though rare) -- drop.
            //

            return DROP;
        }
        
    } else {

        //
        // We've yet to receive a SYN/ACK -- this packet can have only a SYN
        //

        if (TCP_FLAG_SYN != Flags) {
            return DROP;
        }

        pMapping->Flags |= NAT_MAPPING_FLAG_FWD_SYN;
    }

    return FORWARD;
}



VOID
NatInitializePacketManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the packet-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked at passive level.

--*/

{
    ULONG Length;
    IPRouteLookupData RouteLookupData;
    NTSTATUS status;

    PAGED_CODE();

    CALLTRACE(("NatInitializePacketManagement\n"));

    //
    // Initialize our route-cache and set up the table of translation-routines
    // indexed by IP protocol numbers.
    //

    InitializeCache(RouteCache);
    RouteCacheIrp = NULL;
    KeInitializeSpinLock(&RouteCacheLock);
    RtlZeroMemory(RouteCacheTable, sizeof(RouteCacheTable));

    RtlZeroMemory(TranslateRoutineTable, sizeof(TranslateRoutineTable));
    TranslateRoutineTable[NAT_PROTOCOL_ICMP] = NatTranslateIcmp;
    TranslateRoutineTable[NAT_PROTOCOL_PPTP] = NatTranslatePptp;
    TranslateRoutineTable[NAT_PROTOCOL_IP6IN4] = NatpTranslateLocalTraffic;
    TranslateRoutineTable[NAT_PROTOCOL_IPSEC_ESP] = NatpTranslateLocalTraffic;
    TranslateRoutineTable[NAT_PROTOCOL_IPSEC_AH] = NatpTranslateLocalTraffic;
    TranslateRoutineTable[NAT_PROTOCOL_TCP] =
        (PNAT_IP_TRANSLATE_ROUTINE)NatTranslatePacket;
    TranslateRoutineTable[NAT_PROTOCOL_UDP] =
        (PNAT_IP_TRANSLATE_ROUTINE)NatTranslatePacket;

    //
    // Retrieve the index of the loopback interface, which we will use
    // to detect and ignore loopback packets in 'NatTranslatePacket' below.
    //

    RouteLookupData.Version = 0;
    RouteLookupData.SrcAdd = 0;
    RouteLookupData.DestAdd = 0x0100007f;
    Length = sizeof(LoopbackIndex);
    status =
        LookupRouteInformation(
            &RouteLookupData,
            NULL,
            IPRouteOutgoingFirewallContext,
            &LoopbackIndex,
            &Length
            );
    if (!NT_SUCCESS(status)) {
        LoopbackIndex = INVALID_IF_INDEX;
    } else {
        TRACE(
            XLATE, (
            "NatInitializePacketManagement: Loopback=%d\n", LoopbackIndex
            ));
    }

    //
    // Obtain a reference to the module on the completion routine's behalf,
    // set up the IRP which will be used to request route-change notification,
    // and issue the first route-change notification request.
    //

    if (!REFERENCE_NAT()) { return; }

    RouteCacheIrp =
        IoBuildDeviceIoControlRequest(
            IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
            IpDeviceObject,
            NULL,
            0,
            NULL,
            0,
            FALSE,
            NULL,
            NULL
            );

    if (!RouteCacheIrp) {
        ERROR((
            "NatInitializePacketManagement: IoBuildDeviceIoControlRequest==0\n"
            ));
        DEREFERENCE_NAT();
    } else {
        IoSetCompletionRoutine(
            RouteCacheIrp,
            NatpRouteChangeCompletionRoutine,
            NULL,
            TRUE,
            TRUE,
            TRUE
            );
        status = IoCallDriver(IpDeviceObject, RouteCacheIrp);
        if (!NT_SUCCESS(status)) {
            ERROR(("NatInitializePacketManagement: IoCallDriver=%x\n", status));
        }
    }

} // NatInitializePacketManagement


NTSTATUS
NatpDirectPacket(
    ULONG ReceiveIndex,
    ULONG SendIndex,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer,
    FORWARD_ACTION* ForwardAction
    )

/*++

Routine Description:

    This routine is invoked to process packets which might be subject
    to control by a director.

Arguments:

    ReceiveIndex - the interface on which the packet was received,
        for locally received packets

    SendIndex - the interface on which the packet is to be sent,
        for non-locally destined packets

    Contextp - contains context information about the packet

    InReceiveBuffer -  points to the packet's buffer chain

    OutReceiveBuffer - receives the packet buffer chain if translation occurs

    ForwardAction - contains the action to take on the packet,
        if a director applies.

Return Value:

    STATUS_SUCCESS if the packet was directed elsewhere, STATUS_UNSUCCESSFUL
        otherwise.

--*/

{
    ULONG64 DestinationKey[NatMaximumPath];
    USHORT DestinationPort;
    PNAT_DIRECTOR Director;
    IP_NAT_DIRECTOR_QUERY DirectorQuery;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG MappingFlags;
    UCHAR Protocol;
    PNAT_DIRECTOR RedirectDirector;
    ULONG64 SourceKey[NatMaximumPath];
    USHORT SourcePort;
    NTSTATUS status;
    PNAT_INTERFACE Interfacep = NULL;
    USHORT MaxMSS = 0;

    TRACE(PER_PACKET, ("NatpDirectPacket\n"));

    Protocol = Contextp->Header->Protocol;
    if (Protocol == NAT_PROTOCOL_TCP || Protocol == NAT_PROTOCOL_UDP) {
        SourcePort = ((PUSHORT)Contextp->ProtocolHeader)[0];
        DestinationPort = ((PUSHORT)Contextp->ProtocolHeader)[1];
    } else {
        SourcePort = 0;
        DestinationPort = 0;
    }

    //
    // Choose a director to examine the packet.
    // If any redirects exist, we first allow the redirect-director
    // to look at the packet. Otherwise, we look for a specific director.
    // Prepare for any eventuality by retrieving and referencing
    // both the redirect-director (if any) and the specific director (if any).
    //

    if (!RedirectCount) {
        Director = NatLookupAndReferenceDirector(Protocol, DestinationPort);
        RedirectDirector = NULL;
    } else {
        Director = NatLookupAndReferenceDirector(Protocol, DestinationPort);
        RedirectDirector =
            (PNAT_DIRECTOR)RedirectRegisterDirector.DirectorHandle;
        if (!NatReferenceDirector(RedirectDirector)) {
            RedirectDirector = NULL;
        }
    }

    if (!Director && !RedirectDirector) { return STATUS_UNSUCCESSFUL; }

    DirectorQuery.ReceiveIndex = ReceiveIndex;
    DirectorQuery.SendIndex = SendIndex;
    DirectorQuery.Protocol = Protocol;
    DirectorQuery.DestinationAddress = Contextp->DestinationAddress;
    DirectorQuery.DestinationPort = DestinationPort;
    DirectorQuery.SourceAddress = Contextp->SourceAddress;
    DirectorQuery.SourcePort = SourcePort;
    if (Contextp->Flags & NAT_XLATE_FLAG_LOOPBACK) {
        DirectorQuery.Flags = IP_NAT_DIRECTOR_QUERY_FLAG_LOOPBACK;
    } else {
        DirectorQuery.Flags = 0;
    }

    //
    // Consult a director to get a private address/port
    // to which the incoming session should be directed:
    //
    //  If there is a redirect director, try that first.
    //      If that succeeds, release the specific director (if any)
    //          and retain the redirect director in 'Director'.
    //      Otherwise, release the redirect director,
    //          and try the specific director next, if any.
    //  Otherwise, try the specific director right away.
    //

    if (RedirectDirector) {
        DirectorQuery.DirectorContext = RedirectDirector->Context;
        status = RedirectDirector->QueryHandler(&DirectorQuery);
        if (NT_SUCCESS(status)) {
            if (Director) { NatDereferenceDirector(Director); }
            Director = RedirectDirector;
        } else {
            NatDereferenceDirector(RedirectDirector);
            if (Director && Director != RedirectDirector) {
                DirectorQuery.DirectorContext = Director->Context;
                if (Contextp->Flags & NAT_XLATE_FLAG_LOOPBACK) {
                    DirectorQuery.Flags = IP_NAT_DIRECTOR_QUERY_FLAG_LOOPBACK;
                } else {
                    DirectorQuery.Flags = 0;
                }
                status = Director->QueryHandler(&DirectorQuery);
            }
        }
    } else {
        DirectorQuery.DirectorContext = Director->Context;
        status = Director->QueryHandler(&DirectorQuery);
    }

    if (!NT_SUCCESS(status)) {
        if (Director) { NatDereferenceDirector(Director); }
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Either the primary director or the redirect-director
    // has told us what to do with the session; see now if it should be dropped
    // or directed.
    //

    if (DirectorQuery.Flags & IP_NAT_DIRECTOR_QUERY_FLAG_DROP) {
        NatDereferenceDirector(Director);
        *ForwardAction = DROP;
        return STATUS_SUCCESS;
    } else if (Protocol != NAT_PROTOCOL_TCP && Protocol != NAT_PROTOCOL_UDP) {
        ULONG Checksum;
        ULONG ChecksumDelta = 0;

        NatDereferenceDirector(Director);

        //
        // Translate the packet as instructed by the director.
        // N.B. The director must specify both the destination and source
        // addresses.
        //

        CHECKSUM_LONG(ChecksumDelta, ~Contextp->Header->DestinationAddress);
        CHECKSUM_LONG(ChecksumDelta, ~Contextp->Header->SourceAddress);
        Contextp->Header->DestinationAddress =
            DirectorQuery.NewDestinationAddress;
        Contextp->Header->SourceAddress =
            DirectorQuery.NewSourceAddress;
        CHECKSUM_LONG(ChecksumDelta, Contextp->Header->DestinationAddress);
        CHECKSUM_LONG(ChecksumDelta, Contextp->Header->SourceAddress);
        CHECKSUM_UPDATE(Contextp->Header->Checksum);
        *ForwardAction = FORWARD;
        return STATUS_SUCCESS;
    }

    TRACE(
        XLATE, (
        "NatpDirectPacket: directed %d.%d.%d.%d/%d:%d.%d.%d.%d/%d to %d.%d.%d.%d/%d:%d.%d.%d.%d/%d\n",
        ADDRESS_BYTES(DirectorQuery.DestinationAddress),
        NTOHS(DirectorQuery.DestinationPort),
        ADDRESS_BYTES(DirectorQuery.SourceAddress),
        NTOHS(DirectorQuery.SourcePort),
        ADDRESS_BYTES(DirectorQuery.NewDestinationAddress),
        NTOHS(DirectorQuery.NewDestinationPort),
        ADDRESS_BYTES(DirectorQuery.NewSourceAddress),
        NTOHS(DirectorQuery.NewSourcePort)
        ));

    MAKE_MAPPING_KEY(
        SourceKey[NatForwardPath],
        Protocol,
        Contextp->SourceAddress,
        SourcePort
        );
    MAKE_MAPPING_KEY(
        DestinationKey[NatForwardPath],
        Protocol,
        Contextp->DestinationAddress,
        DestinationPort
        );
    MAKE_MAPPING_KEY(
        SourceKey[NatReversePath],
        Protocol,
        DirectorQuery.NewDestinationAddress,
        DirectorQuery.NewDestinationPort
        );
    MAKE_MAPPING_KEY(
        DestinationKey[NatReversePath],
        Protocol,
        DirectorQuery.NewSourceAddress,
        DirectorQuery.NewSourcePort
        );

    //
    // A director requested that a mapping be established for a session.
    // Create a mapping using the director's private endpoint.
    //


    MappingFlags =
        NAT_MAPPING_FLAG_INBOUND |
        NAT_MAPPING_FLAG_DO_NOT_LOG |
        ((DirectorQuery.Flags &
            IP_NAT_DIRECTOR_QUERY_FLAG_NO_TIMEOUT)
            ? NAT_MAPPING_FLAG_NO_TIMEOUT : 0) |
        ((DirectorQuery.Flags &
            IP_NAT_DIRECTOR_QUERY_FLAG_UNIDIRECTIONAL)
            ? NAT_MAPPING_FLAG_UNIDIRECTIONAL : 0) |
        ((DirectorQuery.Flags &
            IP_NAT_DIRECTOR_QUERY_FLAG_DELETE_ON_DISSOCIATE)
            ? NAT_MAPPING_FLAG_DELETE_ON_DISSOCIATE_DIRECTOR : 0);

#ifdef NAT_WMI

    //
    // Determine if this mapping should be logged. We only want to log
    // mappings that are crossing a boundary or firewalled interface.
    // Furthermore, we only want to perform those checks if connection
    // logging is actually enabled.
    //

    if (NatWmiEnabledEvents[NAT_WMI_CONNECTION_CREATION_EVENT]) {
        BOOLEAN LogConnection = FALSE; 
        
        KeAcquireSpinLockAtDpcLevel(&InterfaceLock);

        if (NatLookupCachedInterface(ReceiveIndex, Interfacep)) {
            LogConnection =
                NAT_INTERFACE_BOUNDARY(Interfacep)
                || NAT_INTERFACE_FW(Interfacep);
        }

        if (!LogConnection
            && NatLookupCachedInterface(SendIndex, Interfacep)) {

            if (NAT_INTERFACE_BOUNDARY(Interfacep)
                || NAT_INTERFACE_FW(Interfacep)) {

                //
                // This isn't an inbound connection
                //

                MappingFlags &= ~NAT_MAPPING_FLAG_INBOUND;
                LogConnection = TRUE;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

        if (LogConnection) {
            MappingFlags &= ~NAT_MAPPING_FLAG_DO_NOT_LOG;
        }
    }

#endif
                
    //
    // Record maximum MSS value in case it needs to be set in the mapping.
    //
    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);                
    if (NatLookupCachedInterface(SendIndex, Interfacep) && NAT_INTERFACE_BOUNDARY(Interfacep)) {

        MaxMSS = MAX_MSSOPTION(Interfacep->MTU);
    } else if (NatLookupCachedInterface(ReceiveIndex, Interfacep) && 

        NAT_INTERFACE_BOUNDARY(Interfacep)) {
        MaxMSS = MAX_MSSOPTION(Interfacep->MTU);
    }
    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

    KeAcquireSpinLockAtDpcLevel(&MappingLock);
    status =
        NatCreateMapping(
            MappingFlags,
            DestinationKey,
            SourceKey,
            NULL,
            NULL,
            MaxMSS,
            Director,
            DirectorQuery.DirectorSessionContext,
            NULL,
            NULL,
            &Mapping
            );

    KeReleaseSpinLockFromDpcLevel(&MappingLock);
    if (!NT_SUCCESS(status)) {
        TRACE(XLATE, ("NatpDirectPacket: mapping not created\n"));
        NatDereferenceDirector(Director);
        return STATUS_UNSUCCESSFUL;
    }

    NatDereferenceDirector(Director);

    //
    // Perform the actual translation.
    // This replaces the destination endpoint
    // with whatever the director provided as a destination.
    //

    *ForwardAction =
        Mapping->TranslateRoutine[NatForwardPath](
            Mapping,
            Contextp,
            InReceiveBuffer,
            OutReceiveBuffer
            );

    NatDereferenceMapping(Mapping);
    return STATUS_SUCCESS;

} // NatpDirectPacket


FORWARD_ACTION
NatpForwardPacket(
    ULONG ReceiveIndex,
    ULONG SendIndex,
    PNAT_XLATE_CONTEXT Contextp,
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )

/*++

Routine Description:

    This routine is invoked to process packets to be forwarded.
    Such packets are not locally-destined, and hence we care about them
    only if the outgoing interface is a NAT boundary interface, in which case
    the packets must be automatically translated using a public IP address.
    In the process, a mapping is created so that translation of the packet's
    successors is handled in the fast path in 'NatTranslatePacket'.

Arguments:

    ReceiveIndex - the interface on which the packet was received

    SendIndex - the interface on which the packet is to be forwarded

    Contextp - contains context information about the packet

    TranslateRoutine - points to the routine which performs translation

    InReceiveBuffer - points to the packet buffer chain

    OutReceiveBuffer - receives the packet buffer chain if translation occurs

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

--*/

{
    FORWARD_ACTION act;
    PNAT_USED_ADDRESS Addressp;
    ULONG64 DestinationKey[NatMaximumPath];
    USHORT DestinationPort;
    PNAT_DYNAMIC_MAPPING InsertionPoint;
    PNAT_INTERFACE Interfacep;
    PNAT_DYNAMIC_MAPPING Mapping;
    USHORT PortAcquired;
    UCHAR Protocol;
    ULONG PublicAddress;
    PNAT_INTERFACE ReceiveInterface;
    ULONG ReverseSourceAddress;
    ULONG64 SourceKey[NatMaximumPath];
    USHORT SourcePort;
    PNAT_USED_ADDRESS StaticAddressp;
    NTSTATUS status;
    ULONG i;
    USHORT MaxMSS = 0;

    TRACE(PER_PACKET, ("NatpForwardPacket\n"));

    //
    // Look up the sending and receiving interfaces, and set the default action
    // in 'act'. If the sending interface is a boundary interface,
    // then if we are unable to translate for any reason, the packet must be
    // dropped since it contains a private address.
    // Otherwise, we allow the stack to see the packet even if we cannot
    // translate it.
    //

    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
    if (!NatLookupCachedInterface(SendIndex, Interfacep)) {
        act = FORWARD;

        //
        // We need to see if this packet was received on a firewalled
        // interface, and, if so, drop the packet.
        //

        if (NatLookupCachedInterface(ReceiveIndex, ReceiveInterface)
            && NAT_INTERFACE_FW(ReceiveInterface)) {
            act = DROP;
        }
        
    } else {
        if (!NatLookupCachedInterface(ReceiveIndex, ReceiveInterface)) {

            //
            // The receiving interface has not been added.
            // This packet will not be translated, and should furthermore
            // be dropped if the outgoing interface is a boundary or
            // firewalled interface.
            // This prevents unauthorized access to the remote network.
            //

            act =
                (NAT_INTERFACE_BOUNDARY(Interfacep)
                 || NAT_INTERFACE_FW(Interfacep))
                ? DROP
                : FORWARD;
            Interfacep = NULL;
            
        } else if (NAT_INTERFACE_BOUNDARY(ReceiveInterface)) {

            KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

            //
            // Treat this packet like a received packet.
            // This case may occur when we have an address pool and someone
            // on the public network sends a packet to an address in the pool.
            // The destination will be non-local, as for a transit packet,
            // (hence the invocation of 'NatpForwardPacket') when actually
            // the packet should be treated as a receipt
            // (via 'NatpReceivePacket').
            //

            return
                NatpReceivePacket(
                    ReceiveIndex,
                    Contextp,
                    TranslateRoutine,
                    InReceiveBuffer,
                    OutReceiveBuffer
                    );

        } else if (NAT_INTERFACE_FW(ReceiveInterface)) {

            //
            // We've received a packet on a non-translating firewalled
            // interface that is not directly addressed to us.
            //

            Interfacep = NULL;
            act = DROP;
                    
        } else if (NAT_INTERFACE_BOUNDARY(Interfacep)) {

            //
            // The outgoing interface is a boundary interface,
            // and the receiving interface is permitted access.
            // If translation fails, the packet must be dropped.
            //

            NatReferenceInterface(Interfacep);
            act = DROP;

        } else if (NAT_INTERFACE_FW(Interfacep)) {

            //
            // The outgoing interface is a non-boundary firewalled
            // interface; transit traffic is not permitted through
            // such an interface.
            //

            Interfacep = NULL;    
            act = DROP;
            
        } else {

            //
            // The outgoing interface is not a boundary or firewalled
            // interface.
            //

            Interfacep = NULL;
            act = FORWARD;
        }
    }
    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

    if (!Interfacep) { return act; }

    if ((PVOID)TranslateRoutine == (PVOID)NatTranslatePacket) {

        //
        // This is either a TCP or a UDP packet.
        //

        Protocol = Contextp->Header->Protocol;
        SourcePort = ((PUSHORT)Contextp->ProtocolHeader)[0];
        DestinationPort = ((PUSHORT)Contextp->ProtocolHeader)[1];

        MAKE_MAPPING_KEY(
            SourceKey[NatForwardPath],
            Protocol,
            Contextp->SourceAddress,
            SourcePort
            );
        MAKE_MAPPING_KEY(
            DestinationKey[NatForwardPath],
            Protocol,
            Contextp->DestinationAddress,
            DestinationPort
            );

        //
        // We now generate an outbound mapping and translate the packet.
        //
        // First, acquire an endpoint for the mapping;
        // note that this must be done with the interface's lock held,
        // since it involves consulting the interface's address-pool.
        //

        KeAcquireSpinLockAtDpcLevel(&MappingLock);
        KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
        status =
            NatAcquireEndpointFromAddressPool(
                Interfacep,
                SourceKey[NatForwardPath],
                DestinationKey[NatForwardPath],
                0,
                MAPPING_PORT(SourceKey[NatForwardPath]),
                TRUE,
                &Addressp, 
                &PortAcquired
                );
        if (!NT_SUCCESS(status)) {
            KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
            KeReleaseSpinLockFromDpcLevel(&MappingLock);
            ExInterlockedAddLargeStatistic(
                (PLARGE_INTEGER)&Interfacep->Statistics.RejectsForward, 1
                );
            NatDereferenceInterface(Interfacep);
            return DROP;
        }

        PublicAddress = Addressp->PublicAddress;

        //
        // Next, if there are static mappings for the interface,
        // handle the special case where a client A behind the NAT
        // is attempting to send to another client B behind the NAT,
        // using the *statically-mapped* address for B.
        // We detect this case by looking for a static address mapping 
        // from 'Contextp->DestinationAddress' to a private address.
        //

        if (Interfacep->NoStaticMappingExists) {
            KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
            ReverseSourceAddress = Contextp->DestinationAddress;
        } else {
            StaticAddressp =
                NatLookupStaticAddressPoolEntry(
                    Interfacep,
                    Contextp->DestinationAddress,
                    FALSE
                    );
            if (StaticAddressp) {
                ReverseSourceAddress = StaticAddressp->PrivateAddress;
            } else {
                ReverseSourceAddress = Contextp->DestinationAddress;
            }
            KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
        }

        MAKE_MAPPING_KEY(
            SourceKey[NatReversePath],
            Protocol,
            ReverseSourceAddress,
            DestinationPort
            );
        MAKE_MAPPING_KEY(
            DestinationKey[NatReversePath],
            Protocol,
            PublicAddress,
            PortAcquired
            );


        // 
        // Set Maximum MSS value on the mapping of the sending interface.  
        //
        if (NAT_INTERFACE_BOUNDARY(Interfacep)) {
            MaxMSS = MAX_MSSOPTION(Interfacep->MTU);
        } 

        //
        // Allocate a mapping.
        //

        status =
            NatCreateMapping(
                0,
                DestinationKey,
                SourceKey,
                Interfacep,
                (PVOID)Addressp,
                MaxMSS,
                NULL,
                NULL,
                NULL,
                NULL,
                &Mapping
                );

        KeReleaseSpinLockFromDpcLevel(&MappingLock);
        if (!NT_SUCCESS(status)) {
            ExInterlockedAddLargeStatistic(
                (PLARGE_INTEGER)&Interfacep->Statistics.RejectsForward, 1
                );
            NatDereferenceInterface(Interfacep);
            return DROP;
        }

        //
        // Activate any applicable dynamic tickets
        //

        if (DynamicTicketCount) {
            NatLookupAndApplyDynamicTicket(
                Protocol,
                DestinationPort,
                Interfacep,
                PublicAddress,
                Contextp->SourceAddress
                );
        }
    
        
        //
        // Perform the actual translation
        //
    
        act =
            Mapping->TranslateRoutine[NatForwardPath](
                Mapping,
                Contextp,
                InReceiveBuffer,
                OutReceiveBuffer
                );

        NatDereferenceMapping(Mapping);
        NatDereferenceInterface(Interfacep);
        return act;

    } // TranslateRoutine != NatTranslatePacket

    //
    // The packet is neither a TCP nor a UDP packet.
    // Only translate if the outgoing interface is a boundary interface.
    //
    // N.B. The translation routine must be invoked with a reference made
    // to the boundary interface, and without holding the mapping lock.
    //

    if (TranslateRoutine) {
        act =
            TranslateRoutine(
                Interfacep,
                NatOutboundDirection,
                Contextp,
                InReceiveBuffer,
                OutReceiveBuffer
                );
    }
    NatDereferenceInterface(Interfacep);

    return act;

} // NatpForwardPacket

void
FASTCALL
NatAdjustMSSOption(
    PNAT_XLATE_CONTEXT Contextp,
    USHORT MaxMSS
    )
/*++

Routine Description:

   This routine lowers MSS option in a TCP SYN packet if that MSS value is too large 
   for the outgoing link.   It also updates the TCP checksum accordingly.  
   It assumes that IP and TCP checksums have been computed so it has to be called after
   the translation route completes.
   TCP options follow the general format of one byte type, one byte length, zero or more 
   data indicated by the length field.  The exception to this general format are one byte 
   NOP and ENDOFOPTION option types.

Arguments:

    Contextp - contains context information about the packet

    MaxMSS - the maximum MSS value on the sending interface which is equal to the 
             interface MTU minus IP and TCP fixed header size

Return Value:

--*/

{
    USHORT tempMSS;
    PTCP_HEADER TcpHeader = (PTCP_HEADER)Contextp->ProtocolHeader;
    PUCHAR OptionsPtr = (PUCHAR)(TcpHeader + 1);
    PUCHAR OptionsEnd = NULL, TcpBufEnd = NULL; 
    ULONG tcpChecksumDelta;
    UNALIGNED MSSOption *MSSPtr = NULL;

    CALLTRACE(("NatpAdjustMSSOption\n"));
    //
    // Only TCP SYN has MSS options.
    //
    ASSERT(TCP_FLAG(TcpHeader, SYN) && MaxMSS > 0);

    // 
    // Do some bound checking
    //
    TcpBufEnd = Contextp->ProtocolRecvBuffer->ipr_buffer + Contextp->ProtocolRecvBuffer->ipr_size;
    if ((TcpBufEnd - (PUCHAR)TcpHeader) >= TCP_DATA_OFFSET( TcpHeader )) {
        OptionsEnd = (PUCHAR)TcpHeader + TCP_DATA_OFFSET( TcpHeader );
        }
    else {
        return;
        }

    //
    // MSS option is not the first option so it is necessary to do a complete parsing.  
    //
    while (OptionsPtr < OptionsEnd) {

        switch (*OptionsPtr) {

            case TCP_OPTION_ENDOFOPTIONS:
                return;

            case TCP_OPTION_NOP:
                OptionsPtr++;
                break;

            case TCP_OPTION_MSS:

                MSSPtr = (UNALIGNED MSSOption *)OptionsPtr;
                //
                // Found malformed MSS option so quit and do nothing.
                //
                if (MSS_OPTION_SIZE > (OptionsEnd - OptionsPtr) || 
                    MSS_OPTION_SIZE != MSSPtr->OptionLen) {
                    return;
                }
 
                tempMSS = MSSPtr->MSSValue;
                //
                // if the current MSS option is smaller than sndMTU - (IP Header + TCP header), 
                // nothing needs to be done.
                // 
                if (RtlUshortByteSwap( tempMSS ) <= MaxMSS) {
                    OptionsPtr += MSS_OPTION_SIZE;
                    break; 
                }

                // 
                // Adjust the MSS option.
                //
                MSSPtr->MSSValue = RtlUshortByteSwap( MaxMSS ); 
                
                //
                // Update the TCP check sum.  It assumes that this routine is always called 
                // after translation so that even in the case of off-loading both IP and TCP 
                // checksums are already calculated.
                //
                CHECKSUM_XFER(tcpChecksumDelta, TcpHeader->Checksum); 

                // 
                // Check to see if the MSS option starts at 16 bit boundary.  If not then need
                // to byte swap the 16-bit MSS value when updating the check sum.
                // 
                if (0 == (OptionsPtr - (PUCHAR)TcpHeader) % 2) {
                    tcpChecksumDelta += (USHORT)~tempMSS;
                    tcpChecksumDelta += MSSPtr->MSSValue;
                } else {
                    //
                    // The MSS option does not sit on a 16 bit boundary, so the packets is like this:
                    // [MSS Option Size][MSS' high byte][MSS' low byte][one byte pointed by OptionPtr]
                    // Use these two 16-bit fields to update the checksum.
                    //
                    tcpChecksumDelta += (USHORT)~((USHORT)((tempMSS & 0xFF00) >> 8) | (MSS_OPTION_SIZE << 8));
                    tcpChecksumDelta += (USHORT)((MSSPtr->MSSValue & 0xFF00) >> 8) | (MSS_OPTION_SIZE << 8);
					
                    tcpChecksumDelta += (USHORT)~((USHORT)((tempMSS & 0xFF) <<8) | (USHORT)*OptionsPtr);
                    tcpChecksumDelta += (USHORT)((MSSPtr->MSSValue & 0xFF) <<8) | (USHORT)*OptionsPtr;
                    }

                CHECKSUM_FOLD(tcpChecksumDelta);
                CHECKSUM_XFER(TcpHeader->Checksum, tcpChecksumDelta);
            
                OptionsPtr += MSS_OPTION_SIZE;

                TRACE(
                    XLATE, 
                    ("NatpAdjustMSSOption: Adjusted TCP MSS Option from %d to %d\n", 
                        RtlUshortByteSwap( tempMSS ), 
                        MaxMSS));

                break;

            case TCP_OPTION_WSCALE:
                //
                // Found malformed WS options so quit and do nothing.
                //
                if (WS_OPTION_SIZE > OptionsPtr - OptionsEnd || WS_OPTION_SIZE != OptionsPtr[1]) {
                    return;
                }

                OptionsPtr += WS_OPTION_SIZE;
                break;

            case TCP_OPTION_TIMESTAMPS:
                //
                // Found malformed Time Stamp options so quit and do nothing.
                //
                if (TS_OPTION_SIZE > OptionsPtr - OptionsEnd || TS_OPTION_SIZE != OptionsPtr[1]) {
                    return;
                }

                OptionsPtr += TS_OPTION_SIZE;
                break;

            case TCP_OPTION_SACK_PERMITTED:
                //
                // Found malformed Sack Permitted options so quit and do nothing.
                //
                if (SP_OPTION_SIZE > OptionsPtr - OptionsEnd || SP_OPTION_SIZE != OptionsPtr[1]) {
                    return;
                }

                OptionsPtr += SP_OPTION_SIZE;
                break;

            default:	
                //
                // unknown option. Check to see if it has a valid length field.
                //
                if (OptionsEnd > OptionsPtr + 1) {
                    // Found malformed unknown options so quit and do nothing.
                    if (OptionsPtr[1] < 2 || OptionsPtr[1] > OptionsEnd - OptionsPtr)
                        return;
                
                    OptionsPtr += OptionsPtr[1];
                } else {
                    return;
                }
                break;
        } // switch
    } // while
}

BOOLEAN
FASTCALL
NatpIsUnicastPacket(
    ULONG Address
    )

/*++

Routine Description:

    This routine is called to determine whether or not a packet is a unicast
    packet, based on its address.

Arguments:

    Address - the destination address of the packet

Return Value:

    BOOLEAN - TRUE if the packet appears to be a unicast, FALSE otherwise.

--*/

{
    //
    // See if the packet is multicast or all-ones broadcast
    //

    if (ADDRESS_CLASS_D(Address) || ADDRESS_CLASS_E(Address)) {
        return FALSE;
    }

    //
    // See if the address is a network-class directed broadcast
    //

    if ((Address | ~GET_CLASS_MASK(Address)) == Address) {
        return FALSE;
    }

    return TRUE;
}

FORWARD_ACTION
NatpReceiveNonUnicastPacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp
    )

/*++

Routine Description:
    
    This routine is invoked to process locally destined non-unicast packets.
    If the packet was received on a firewalled interface, it will be dropped
    unless an exemption exists.

Arguments:
   
    Index - index of the interface on which the packet was received

    Contextp - the context for this packet

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

--*/

{
    FORWARD_ACTION act;
    USHORT DestinationPort;
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    USHORT SourcePort;
    PNAT_TICKET Ticketp;
    UCHAR Type;

    TRACE(PER_PACKET, ("NatpReceiveNonUnicastPacket\n"));

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    
    if (!NatLookupCachedInterface(Index, Interfacep)
        || !NAT_INTERFACE_FW(Interfacep)) {

        //
        // The packet was not received on a firewalled interface
        //

        KeReleaseSpinLock(&InterfaceLock, Irql);
        act = FORWARD;
        
    } else {

        NatReferenceInterface(Interfacep);
        KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
        
        //
        // This packet was received on a firealled interface. Drop it,
        // unless:
        // * it appears to be a DHCP response packet
        // * it's a UDP packet, and there exist a firewall port mapping
        //   (i.e., one that does not change the destination address
        //   or port) for the destination port
        // * it's an IGMP packet
        // * it's a permitted ICMP type
        //

        act = DROP;

        switch (Contextp->Header->Protocol) {

            case NAT_PROTOCOL_ICMP: {
                Type = ((PICMP_HEADER)Contextp->ProtocolHeader)->Type;

                switch (Type) {
                    case ICMP_ECHO_REQUEST:
                    case ICMP_TIMESTAMP_REQUEST:
                    case ICMP_ROUTER_REQUEST:
                    case ICMP_MASK_REQUEST: {

                        //
                        // These types are allowed in based on the interface's
                        // configuration.
                        //

                        if (NAT_INTERFACE_ALLOW_ICMP(Interfacep, Type)) {
                            act = FORWARD;
                        }
                        break;
                    }

                    //
                    // Any other inbound ICMP type is always dropped.
                    //
                }
                
                break;
            }

            case NAT_PROTOCOL_IGMP: {
                act = FORWARD;
                break;
            }

            case NAT_PROTOCOL_UDP: {
                SourcePort = ((PUSHORT)Contextp->ProtocolHeader)[0];
                DestinationPort = ((PUSHORT)Contextp->ProtocolHeader)[1];

                if (NTOHS(DHCP_SERVER_PORT) == SourcePort
                    && NTOHS(DHCP_CLIENT_PORT) == DestinationPort) {

                    act = FORWARD;
                } else {
                    KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
                    Ticketp =
                        NatLookupFirewallTicket(
                            Interfacep,
                            NAT_PROTOCOL_UDP,
                            DestinationPort
                            );

                    if (NULL != Ticketp) {
                        act = FORWARD;
                    }
                    KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                }

                break;
            }
        }

        NatDereferenceInterface(Interfacep);
        KeLowerIrql(Irql);
    }

    return act;
} // NatpReceiveNonUnicastPacket

FORWARD_ACTION
NatpReceivePacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp,
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )

/*++

Routine Description:

    This routine is invoked to process locally destined packets.
    All initial automatic translation of such packets occurs here,
    based on destination of the packet, which may be a local IP address
    or an IP address from the pool assigned to a boundary interface.
    In the process, a mapping is created so that translation of the packet's
    successors is handled in the fast path in 'NatTranslatePacket'.

Arguments:

    Index - index of the interface on which the packet was received

    DestinationType - receives 'DEST_INVALID' if destination changed

    TranslateRoutine - points to the routine which performs translation

    InReceiveBuffer - points to the packet buffer chain

    OutReceiveBuffer - receives the packet buffer chain if translation occurs

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

--*/

{
    FORWARD_ACTION act;
    PNAT_USED_ADDRESS Addressp;
    ULONG64 DestinationKey[NatMaximumPath];
    USHORT DestinationPort;
    ULONG i;
    PNAT_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_MAPPING Mapping;
    ULONG NewDestinationAddress;
    USHORT NewDestinationPort;
    UCHAR Protocol;
    ULONG64 SourceKey[NatMaximumPath];
    USHORT SourcePort;
    NTSTATUS status;
    BOOLEAN TicketProcessingOnly;
    USHORT MaxMSS = 0;

    TRACE(PER_PACKET, ("NatpReceivePacket\n"));

    //
    // Look up the receiving interface.
    // If the receiving interface is a boundary interface,
    // then if we are unable to translate for any reason, the packet must be
    // dropped as a matter of policy, unless it is locally-destined.
    // Otherwise, we allow the stack to see the packet even if we cannot
    // translate it.
    // 

    KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
    if (!NatLookupCachedInterface(Index, Interfacep)) {
        act = FORWARD;
    } else {
        if (!NAT_INTERFACE_BOUNDARY(Interfacep)
            && !NAT_INTERFACE_FW(Interfacep)) {
            Interfacep = NULL;
            act = FORWARD;
        } else {
            NatReferenceInterface(Interfacep);

            if(NAT_INTERFACE_FW(Interfacep)) {
                act = DROP;
            } else {
                //
                // See if the packet is locally-destined
                //
                
                if (Interfacep->AddressArray[0].Address ==
                        Contextp->DestinationAddress) {
                    act = FORWARD;
                } else {
                    act = DROP;
                    for (i = 1; i < Interfacep->AddressCount; i++) {
                        if (Interfacep->AddressArray[i].Address ==
                                Contextp->DestinationAddress) {
                            //
                            // The packet's destination-address is local.
                            //
                            act = FORWARD;
                            break;
                        }
                    }
                }
            }
            // 
            // Set MaxMSS for the receiving interface so that SYN/ACK's MSS option might 
            // be adjusted if necessary.
            //
            if (NAT_INTERFACE_BOUNDARY(Interfacep)) {
                MaxMSS = MAX_MSSOPTION(Interfacep->MTU);
            }
        }
    }

    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

    if ((PVOID)TranslateRoutine == (PVOID)NatTranslatePacket) {

        //
        // If we don't recognize the receiving interface, return right away,
        // unless someone has created a ticket somewhere. In the latter case,
        // the packet to which the ticket must be applied may be received
        // on a different interface than the interface to which the ticket
        // is attached. (This may happen with one-way cable-modems or other
        // asymmetric routes.) We catch that case here by using the ticket's
        // interface for translation.
        //

        if (!Interfacep && !TicketCount) { return act; }

        //
        // This is either a TCP or a UDP packet.
        //

        Protocol = Contextp->Header->Protocol;
        SourcePort = ((PUSHORT)Contextp->ProtocolHeader)[0];
        DestinationPort = ((PUSHORT)Contextp->ProtocolHeader)[1];

        //
        // We allow the packet through if one of the following is true:
        // (a) a ticket exists for the packet (e.g. a static port mapping)
        // (b) a static address mapping exists for the packet's destination
        // (c) this appears to be a DHCP unicast response:
        //     -- UDP
        //     -- source port 67
        //     -- destination port 68
        // (d) this is a UDP packet that is destined for the local endpoint
        //     of some other mapping ("loose source matching")
        //

        MAKE_MAPPING_KEY(
            SourceKey[NatForwardPath],
            Protocol,
            Contextp->SourceAddress,
            SourcePort
            );
        MAKE_MAPPING_KEY(
            DestinationKey[NatForwardPath],
            Protocol,
            Contextp->DestinationAddress,
            DestinationPort
            );

        if (Interfacep) {
            TicketProcessingOnly = FALSE;
        } else {

            //
            // We only reach this point if a ticket exists and we want to check
            // if it applies to this packet even though this packet was not
            // received on this interface. We now scan the interface list
            // (again) to see if we can find one which has this ticket.
            //

            KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
            for (Link = InterfaceList.Flink; Link != &InterfaceList;
                 Link = Link->Flink) {
                Interfacep = CONTAINING_RECORD(Link, NAT_INTERFACE, Link);
                if (NAT_INTERFACE_DELETED(Interfacep) ||
                    IsListEmpty(&Interfacep->TicketList)) {
                    Interfacep = NULL;
                    continue;
                }
                KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
                if (NatLookupTicket(
                        Interfacep,
                        DestinationKey[NatForwardPath],
                        SourceKey[NatForwardPath],
                        NULL
                        )) {

                    //
                    // This interface has a ticket for the packet;
                    // make a reference to it and end the search.
                    //

                    KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                    NatReferenceInterface(Interfacep);
                    break;
                }
                KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                Interfacep = NULL;
            }
            KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
            if (!Interfacep) { return act; }
            TicketProcessingOnly = TRUE;
        }

        Mapping = NULL;

        do {

            //
            // First see if we can quickly determine that this packet won't
            // meet any of the allow in criteria.
            //

            if (!TicketCount
                && Interfacep->NoStaticMappingExists
                && NAT_PROTOCOL_UDP != Protocol
                ) {

                //
                // There's no way for this packet to meet any of the criteria
                // that would allow it in:
                // a) no tickets exist
                // b) no static mappings exist for this interface
                // c) it's not a UDP packet, and thus cannot be a unicast DHCP
                //    response. nor will it match a local UDP session endpoint
                //

                NatDereferenceInterface(Interfacep);
                return act;
            }

            //
            // See if a ticket exists which applies to this session.
            //

            KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);

            if (!IsListEmpty(&Interfacep->TicketList)) {

                status =
                    NatLookupAndRemoveTicket(
                        Interfacep,
                        DestinationKey[NatForwardPath],
                        SourceKey[NatForwardPath],
                        &Addressp,
                        &NewDestinationAddress,
                        &NewDestinationPort
                        );
    
                if (NT_SUCCESS(status)) {

                    KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);

                    //
                    // A ticket was found. Create a mapping for it.
                    //

                    TRACE(
                        XLATE, (
                        "NatpReceivePacket: using ticket to %d.%d.%d.%d/%d\n",
                        ADDRESS_BYTES(NewDestinationAddress),
                        NTOHS(NewDestinationPort)
                        ));

                    MAKE_MAPPING_KEY(
                        SourceKey[NatReversePath],
                        Protocol,
                        NewDestinationAddress,
                        NewDestinationPort
                        );
                    MAKE_MAPPING_KEY(
                        DestinationKey[NatReversePath],
                        Protocol,
                        Contextp->SourceAddress,
                        SourcePort
                        );

                    KeAcquireSpinLockAtDpcLevel(&MappingLock);
                    status =
                        NatCreateMapping(
                            NAT_MAPPING_FLAG_INBOUND,
                            DestinationKey,
                            SourceKey,
                            Interfacep,
                            Addressp,
                            MaxMSS,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &Mapping
                            );
                    KeReleaseSpinLockFromDpcLevel(&MappingLock);
    
                    if (!NT_SUCCESS(status)) {
                        NatDereferenceInterface(Interfacep);
                        return act;
                    }

                    //
                    // We have a mapping now in 'Mapping';
                    // Drop to the translation code below.
                    //

                    TicketProcessingOnly = FALSE;
                    break;
                }

                //
                // No ticket, or failure creating mapping.
                // Try other possibilities.
                //

            } // !IsListEmpty(TicketList)

            //
            // If we only reached this point because of a ticket,
            // stop here, since the packet was not really received on
            // 'Interfacep'.
            //

            if (TicketProcessingOnly) {
                KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                NatDereferenceInterface(Interfacep);
                return act;
            }

            //
            // Since this is an inbound packet, we now look for
            // a static-address mapping which allows inbound sessions.
            //

            if ((Addressp =
                    NatLookupStaticAddressPoolEntry(
                        Interfacep,
                        Contextp->DestinationAddress,
                        TRUE
                        ))
                && NatReferenceAddressPoolEntry(Addressp)) {
                KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);

                TRACE(
                    XLATE, (
                    "NatpReceivePacket: using static address to %d.%d.%d.%d/%d\n",
                    ADDRESS_BYTES(Addressp->PrivateAddress),
                    NTOHS(DestinationPort)
                    ));

                MAKE_MAPPING_KEY(
                    SourceKey[NatReversePath],
                    Protocol,
                    Addressp->PrivateAddress,
                    DestinationPort
                    );
                MAKE_MAPPING_KEY(
                    DestinationKey[NatReversePath],
                    Protocol,
                    Contextp->SourceAddress,
                    SourcePort
                    );

                //
                // We will allow the packet through if we can reserve
                // its destination port, i.e. if no existing session
                // from the same remote endpoint is using that destination.
                // Initialize a new dynamic mapping for the packet,
                // and note that this will fail if such a duplicate exists.
                //

                KeAcquireSpinLockAtDpcLevel(&MappingLock);
                status =
                    NatCreateMapping(
                        NAT_MAPPING_FLAG_INBOUND,
                        DestinationKey,
                        SourceKey,
                        Interfacep,
                        Addressp,
                        MaxMSS,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &Mapping
                        );
                KeReleaseSpinLockFromDpcLevel(&MappingLock);
                if (!NT_SUCCESS(status)) {
                    NatDereferenceInterface(Interfacep);
                    return act;
                }

                //
                // On reaching here, we will have created a mapping
                // from a static address mapping.
                //

                break;
            }

            //
            // If this is a UDP packet, see if its destination matches
            // the public endpoint of an already existing mapping (i.e.,
            // perform a mapping lookup ignoring the packet's source
            // address and port).
            //

            if (NAT_PROTOCOL_UDP == Protocol) {

                ULONG PrivateAddress;
                USHORT PrivatePort;

                KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
                KeAcquireSpinLockAtDpcLevel(&MappingLock);

                //
                // First search for a forward path (sessions that
                // were originally outbound) match.
                //

                Mapping =
                    NatDestinationLookupForwardMapping(
                        DestinationKey[NatForwardPath]
                        );

                if (NULL == Mapping) {

                    //
                    // No forward path match was found; attempt to
                    // locate a reverse path (sessions that were
                    // originally inbound) match.
                    //

                    Mapping =
                        NatDestinationLookupReverseMapping(
                            DestinationKey[NatForwardPath]
                            );
                }

                if (NULL != Mapping) {

                    IP_NAT_PATH Path;

                    //
                    // Determine the private address and port
                    //

                    Path =
                        NAT_MAPPING_INBOUND(Mapping)
                        ? NatReversePath
                        : NatForwardPath;

                    PrivateAddress = MAPPING_ADDRESS(Mapping->SourceKey[Path]);
                    PrivatePort = MAPPING_PORT(Mapping->SourceKey[Path]);
                }

                KeReleaseSpinLockFromDpcLevel(&MappingLock);

                if (NULL != Mapping
                    && NTOHS(PrivatePort) > NAT_XLATE_UDP_LSM_LOW_PORT) {

                    //
                    // A partial-match mapping exists, and the private port
                    // is within the allowed rage. Get the address
                    // object for the private endpoint
                    //

                    KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);

                    status = 
                        NatAcquireFromAddressPool(
                            Interfacep,
                            PrivateAddress,
                            MAPPING_ADDRESS(DestinationKey[NatForwardPath]),
                            &Addressp
                            );

                    KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);

                    if (NT_SUCCESS(status)) {

                        //
                        // Create the new mapping.
                        //

                        TRACE(
                            XLATE, (
                            "NatpReceivePacket: UDP LSM to %d.%d.%d.%d/%d\n",
                            ADDRESS_BYTES(PrivateAddress),
                            NTOHS(PrivatePort)
                            ));

                        MAKE_MAPPING_KEY(
                            SourceKey[NatReversePath],
                            Protocol,
                            PrivateAddress,
                            PrivatePort
                            );
                        MAKE_MAPPING_KEY(
                            DestinationKey[NatReversePath],
                            Protocol,
                            Contextp->SourceAddress,
                            SourcePort
                            );

                        KeAcquireSpinLockAtDpcLevel(&MappingLock);
                        status =
                            NatCreateMapping(
                                NAT_MAPPING_FLAG_INBOUND,
                                DestinationKey,
                                SourceKey,
                                Interfacep,
                                Addressp,
                                0,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &Mapping
                                );
                        KeReleaseSpinLockFromDpcLevel(&MappingLock);
                        if (!NT_SUCCESS(status)) {
                            NatDereferenceInterface(Interfacep);
                            return act;
                        }

                        //
                        // On reaching here, we will have created a mapping
                        // due to a loose UDP source match.
                        //

                        break;
                    }
                }

                //
                // The code below assumes that this lock is held.
                //

                KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
            }

            //
            // Check if this is may be a DHCP response packet. If the
            // request that elicited this response was broadcast we
            // won't have a corresponding mapping to allow the packet
            // in; dropping the packet, though, will cause connectivity
            // problems.
            //
            
            if (NAT_PROTOCOL_UDP == Protocol
                && NTOHS(DHCP_SERVER_PORT) == SourcePort
                && NTOHS(DHCP_CLIENT_PORT) == DestinationPort
                && NAT_INTERFACE_FW(Interfacep)) {

                //
                // What appears to be a unicast DHCP response was received
                // on a firewalled interface. We need to always let such
                // packets through to prevent an interruption in network
                // connectivity.
                //

                act = FORWARD;
            }

            //
            // This packet doesn't meet any criteria that allow for
            // the creation of a mapping. Return the default action.
            //

            KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
            NatDereferenceInterface(Interfacep);
            return act;

        } while (FALSE); // !Mapping

        if (Interfacep) { NatDereferenceInterface(Interfacep); }

        //
        // Somewhere above a mapping was found or created.
        // Translate the packet using that mapping
        //

        act =
            Mapping->TranslateRoutine[NatForwardPath](
                Mapping,
                Contextp,
                InReceiveBuffer,
                OutReceiveBuffer
                );

        //
        // Release our reference on the mapping and the interface
        //

        NatDereferenceMapping(Mapping);
        return act;

    } // TranslateRoutine != NatTranslatePacket

    //
    // This is neither a TCP nor a UDP packet.
    // If it is coming in on a boundary interface, translate it;
    // otherwise let it pass through unscathed.
    //
    // N.B. The translation routine must be invoked with a reference made
    // to the boundary interface, and without holding the mapping lock.
    //

    if (TranslateRoutine) {
        act =
            TranslateRoutine(
                Interfacep,
                NatInboundDirection,
                Contextp,
                InReceiveBuffer,
                OutReceiveBuffer
                );
    }

    if (Interfacep) { NatDereferenceInterface(Interfacep); }
    return act;

} // NatpReceivePacket


NTSTATUS
NatpRouteChangeCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by the I/O manager upon completion of
    a route-change-notification request. It invalidates our route-cache and,
    unless shutdown is in progress, re-issues the route-change-notification
    request.

Arguments:

    DeviceObject - the device object of the IP driver

    Irp - the completed I/O request packet

    Context - unused

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - indication that the IRP should be freed.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    KIRQL Irql;
    NTSTATUS status;

    CALLTRACE(("NatpRouteChangeCompletionRoutine\n"));

    //
    // Invalidate the entire route-cache.
    //

    KeAcquireSpinLock(&RouteCacheLock, &Irql);
    InitializeCache(RouteCache);

    //
    // If we cannot re-reference the module, relinquish the IRP.
    //

    if (!RouteCacheIrp || !REFERENCE_NAT()) {
        KeReleaseSpinLock(&RouteCacheLock, Irql);
        DEREFERENCE_NAT_AND_RETURN(STATUS_SUCCESS);
    }

    Irp->Cancel = FALSE;
    KeReleaseSpinLock(&RouteCacheLock, Irql);

    //
    // Reinitialize the IRP structure and submit it again
    // for further notification.
    //

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;
    Irp->AssociatedIrp.SystemBuffer = NULL;
    IoSetCompletionRoutine(
        Irp,
        NatpRouteChangeCompletionRoutine,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );
    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpSp->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_IP_RTCHANGE_NOTIFY_REQUEST;
    IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;

    status = IoCallDriver(IpDeviceObject, Irp);

    if (!NT_SUCCESS(status)) {
        ERROR(("NatpRouteChangeWorkerRoutine: IoCallDriver=0x%08X\n", status));
    }

    DEREFERENCE_NAT_AND_RETURN(STATUS_MORE_PROCESSING_REQUIRED);

} // NatpRouteChangeCompletionRoutine


ULONG
FASTCALL
NatpRoutePacket(
    ULONG DestinationAddress,
    PNAT_XLATE_CONTEXT Contextp,
    PNTSTATUS Status
    )

/*++

Routine Description:

    This routine is invoked to determine the index of the outgoing adapter
    for a given source/destination pair.
    It attempts to retrieve the required information from our route-table
    cache, and if unsuccessful consults the IP routing tables.

Arguments:

    DestinationAddress - the destination address for the packet

    Contextp - optionally supplies the context of the packet on whose
        behalf a route-lookup is being requested. If demand-dial were required
        in order to forward the packet, this data would be needed in order
        for demand-dial filters to function correctly.

    Status - receives the status of the lookup in the event of a failure

Return Value:

    ULONG - the index of the outgoing interface, or INVALID_IF_INDEX if none.

--*/

{
    PUCHAR Buffer;
    ULONG BufferLength;
    PNAT_CACHED_ROUTE CachedRoute;
    ULONG Index;
    KIRQL Irql;
    ULONG Length;
    IPRouteLookupData RouteLookupData;

    TRACE(PER_PACKET, ("NatpRoutePacket\n"));

    //
    // Probe the cache for the destination IP address specified.
    //

    KeAcquireSpinLock(&RouteCacheLock, &Irql);
    if ((CachedRoute = ProbeCache(RouteCache, DestinationAddress)) &&
        CachedRoute->DestinationAddress == DestinationAddress) {
        Index = CachedRoute->Index;
        KeReleaseSpinLock(&RouteCacheLock, Irql);
        TRACE(PER_PACKET, ("NatpRoutePacket: cache hit\n"));
        return Index;
    }
    KeReleaseSpinLockFromDpcLevel(&RouteCacheLock);

    //
    // The cache did not have the value requested,
    // so consult the TCP/IP driver directly.
    //

    RouteLookupData.Version = 0;
    RouteLookupData.DestAdd = DestinationAddress;
    if (Contextp) {
        RouteLookupData.SrcAdd = Contextp->SourceAddress;
        RouteLookupData.Info[0] = (Contextp->Header)->Protocol;

        if (NAT_PROTOCOL_TCP == RouteLookupData.Info[0]) {
            Buffer = Contextp->ProtocolHeader;
            BufferLength = sizeof(TCP_HEADER);
        } else if (NAT_PROTOCOL_UDP == RouteLookupData.Info[0]) {
            Buffer = Contextp->ProtocolHeader;
            BufferLength = sizeof(UDP_HEADER);
        } else if (NAT_PROTOCOL_ICMP == RouteLookupData.Info[0]) {
            Buffer = Contextp->ProtocolHeader;
            BufferLength = sizeof(ICMP_HEADER);
        } else {
            Buffer = Contextp->RecvBuffer->ipr_buffer;
            BufferLength = Contextp->RecvBuffer->ipr_size;
        }   
    } else {
        RouteLookupData.SrcAdd = 0;
        Buffer = NULL;
        BufferLength = 0;
    }
    Length = sizeof(Index);

    *Status =
        LookupRouteInformationWithBuffer(
            &RouteLookupData,
            Buffer,
            BufferLength,
            NULL,
            IPRouteOutgoingFirewallContext,
            &Index,
            &Length
            );

    if (!NT_SUCCESS(*Status) || *Status == STATUS_PENDING) {
        KeLowerIrql(Irql);
        return INVALID_IF_INDEX;
    }

    //
    // Update the cache with the entry retrieved,
    // assuming we've had enough misses to warrant
    // replacement of the cache-index's current contents.
    //

    KeAcquireSpinLockAtDpcLevel(&RouteCacheLock);
    CachedRoute = &RouteCacheTable[CACHE_INDEX(DestinationAddress)];
    if (UpdateCache(RouteCache, DestinationAddress, CachedRoute)) {
        CachedRoute->DestinationAddress = DestinationAddress;
        CachedRoute->Index = Index;
    }
    KeReleaseSpinLock(&RouteCacheLock, Irql);

    return Index;

} // NatpRoutePacket


FORWARD_ACTION
NatpSendNonUnicastPacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp
    )

/*++

Routine Description:

    This routine is invoked to process locally sent non-unicast packets.
    If the packet is to be sent on a firewalled interface it must have a valid
    source address for that interface.

Arguments:

    Index - index of the interface on which the packet is to be sent

    Contextp - the context for this packet

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

--*/

{
    FORWARD_ACTION act;
    PNAT_INTERFACE Interfacep;
    ULONG i;
    KIRQL Irql;

    TRACE(PER_PACKET, ("NatpSendNonUnicastPacket\n"));

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    
    if (!NatLookupCachedInterface(Index, Interfacep)
        || !NAT_INTERFACE_FW(Interfacep)) {

        //
        // The packet is not to be sent on a firewalled interface
        //

        KeReleaseSpinLock(&InterfaceLock, Irql);
        act = FORWARD;
        
    } else {

        NatReferenceInterface(Interfacep);
        KeReleaseSpinLock(&InterfaceLock, Irql);

        //
        // Make sure the packet has a valid source address
        //

        act = DROP;

        if (Interfacep->AddressArray[0].Address == Contextp->SourceAddress) {
            act = FORWARD;
        } else {
            for (i = 1; i < Interfacep->AddressCount; i++) {
                if (Contextp->SourceAddress ==
                        Interfacep->AddressArray[i].Address) {

                    act = FORWARD;
                    break;
                }
            }
        }

        if (DROP == act
            && 0 == Contextp->SourceAddress
            && NAT_PROTOCOL_UDP == Contextp->Header->Protocol
            && NTOHS(DHCP_CLIENT_PORT) ==
                ((PUDP_HEADER)Contextp->ProtocolHeader)->SourcePort
            && NTOHS(DHCP_SERVER_PORT) ==
                ((PUDP_HEADER)Contextp->ProtocolHeader)->DestinationPort) {

            //
            // This appears to be a DHCP request sent from an adapter that
            // has a non-DHCP allocated address (e.g., an autonet address). In
            // this situation the DHCP client will use a source address of
            // 0.0.0.0. These packets should always be forwarded.
            //
            
            act = FORWARD;
        }

        NatDereferenceInterface(Interfacep);
    }

    return act;

} // NatpSendNonUnicastPacket

FORWARD_ACTION
NatpSendPacket(
    ULONG Index,
    PNAT_XLATE_CONTEXT Contextp,
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )

/*++

Routine Description:

    This routine is invoked to process locally generated packets.
    Most locally-generated packets do not require translation at all.
    The exceptions arise with applications that bind to a private IP address
    but then send packets to the public network, as well as with certain
    applications (PPTP, ICMP) which must be forced through the translation
    path to ensure that certain fields are unique for all sessions sharing
    the public IP address(es). (E.g. the PPTP GRE call-identifier.)

Arguments:

    Index - the interface on which the packet is to be sent

    DestinationType - receives 'DEST_INVALID' if destination changed

    TranslateRoutine - points to the routine which performs translation

    InReceiveBuffer - points to the packet buffer chain

    OutReceiveBuffer - receives the packet buffer chain if translation occurs

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

--*/

{
    FORWARD_ACTION act;
    PNAT_USED_ADDRESS Addressp;
    ULONG64 DestinationKey[NatMaximumPath];
    USHORT DestinationPort;
    ULONG i;
    PNAT_DYNAMIC_MAPPING InsertionPoint;
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    PNAT_DYNAMIC_MAPPING Mapping;
    USHORT PortAcquired;
    UCHAR Protocol;
    ULONG64 SourceKey[NatMaximumPath];
    USHORT SourcePort;
    NTSTATUS status;

    TRACE(PER_PACKET, ("NatpSendPacket\n"));

    //
    // Look up the sending interface, and set the default action
    // in 'act'. If the packet's source address is not on the sending interface,
    // then we must translate it like any other outbound packet.
    // Otherwise, we may let the packet through unchanged, so long as
    // there is no mapping for it created by a director.
    // N.B. We record the original IRQL since local-sends are not guaranteed
    // to be passed to us at dispatch level.
    // 

    KeAcquireSpinLock(&InterfaceLock, &Irql);
    if (!NatLookupCachedInterface(Index, Interfacep) ||
        (!NAT_INTERFACE_BOUNDARY(Interfacep)
         && !NAT_INTERFACE_FW(Interfacep))) {
         
        //
        // This packet is not being sent on a boundary or firewalled interface,
        // so we won't normally translate it.
        //
        // However, a special case arises when a local MTU mismatch results in
        // the forwarder generating an ICMP path MTU error message.
        // The forwarder generates the error based on the *translated* packet
        // which has the public IP address as its source, and so the error
        // ends up being sent on the loopback interface to the local machine.
        // When we see an ICMP message on the loopback interface, give the
        // ICMP translator a chance to modify it *if there are any mappings*.
        //

        if (LoopbackIndex == Index &&
            TranslateRoutine == NatTranslateIcmp &&
            MappingCount) {
            KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
            act =
                NatTranslateIcmp(
                    NULL,
                    NatInboundDirection,
                    Contextp,
                    InReceiveBuffer,
                    OutReceiveBuffer
                    );
            KeLowerIrql(Irql);
            return act;
        } else {
            KeReleaseSpinLock(&InterfaceLock, Irql);
            return FORWARD;
        }
    }
    NatReferenceInterface(Interfacep);
    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);

    Protocol = Contextp->Header->Protocol;

    if (Interfacep->AddressArray[0].Address == Contextp->SourceAddress) {
        act = FORWARD;
    } else {

        //
        // The outgoing interface is a boundary interface.
        // This means that if the packet's source-address is the address
        // of an interface other than 'Interfacep', it is a private address,
        // and we'll need to discard the packet if it cannot be translated.
        // Therefore, see whether the packet's source-address is public.
        //

        act = DROP;
        for (i = 1; i < Interfacep->AddressCount; i++) {
            if (Contextp->SourceAddress ==
                    Interfacep->AddressArray[i].Address) {

                //
                // The packet's source-address is public,
                // so the packet will be allowed to go out untranslated.
                //

                act = FORWARD;
                break;
            }
        }
    }

    //
    // If the packet's source-address is not private, we can avoid
    // translating it unless
    // (a) it's an ICMP packet
    // (b) it's a PPTP data packet
    // (c) it's a PPTP control-session packet.
    // (d) the interface is in FW mode -- need to generate a mapping so
    //     that inbound packets for this connection won't be dropped
    //

    if (act == FORWARD &&
        !NAT_INTERFACE_FW(Interfacep) &&
        Protocol != NAT_PROTOCOL_ICMP &&
        Protocol != NAT_PROTOCOL_PPTP &&
        (Protocol != NAT_PROTOCOL_TCP ||
         ((PUSHORT)Contextp->ProtocolHeader)[1] != NTOHS(PPTP_CONTROL_PORT))) {
        KeLowerIrql(Irql);
        NatDereferenceInterface(Interfacep);
        return FORWARD;
    }

    //
    // The packet may require some form of translation.
    //

    if ((PVOID)TranslateRoutine == (PVOID)NatTranslatePacket) {

        SourcePort = ((PUSHORT)Contextp->ProtocolHeader)[0];
        DestinationPort = ((PUSHORT)Contextp->ProtocolHeader)[1];

        //
        // The packet is either TCP or UDP.
        // Generate a mapping for the packet's session.
        //

        MAKE_MAPPING_KEY(
            SourceKey[NatForwardPath],
            Protocol,
            Contextp->SourceAddress,
            SourcePort
            );
        MAKE_MAPPING_KEY(
            DestinationKey[NatForwardPath],
            Protocol,
            Contextp->DestinationAddress,
            DestinationPort
            );

        //
        // Acquire an endpoint for the mapping. If the interface
        // is in FW mode and act == FORWARD, however, we only
        // want to get the address structure corresponding to the
        // source address of the packet
        //

        KeAcquireSpinLockAtDpcLevel(&MappingLock);
        KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);

        if(act != FORWARD || !NAT_INTERFACE_FW(Interfacep)) {
            status =
                NatAcquireEndpointFromAddressPool(
                    Interfacep,
                    SourceKey[NatForwardPath],
                    DestinationKey[NatForwardPath],
                    0,
                    MAPPING_PORT(SourceKey[NatForwardPath]),
                    TRUE,
                    &Addressp, 
                    &PortAcquired
                    );

        } else {

            PortAcquired = SourcePort;
            status = 
                NatAcquireFromAddressPool(
                    Interfacep,
                    Contextp->SourceAddress,
                    Contextp->SourceAddress,
                    &Addressp
                    );
        }
        
        KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
        if (!NT_SUCCESS(status)) {
            KeReleaseSpinLock(&MappingLock, Irql);
            ExInterlockedAddLargeStatistic(
                (PLARGE_INTEGER)&Interfacep->Statistics.RejectsForward, 1
                );
            NatDereferenceInterface(Interfacep);
            return DROP;
        }

        MAKE_MAPPING_KEY(
            SourceKey[NatReversePath],
            Protocol,
            Contextp->DestinationAddress,
            DestinationPort
            );
        MAKE_MAPPING_KEY(
            DestinationKey[NatReversePath],
            Protocol,
            Addressp->PublicAddress,
            PortAcquired
            );

        //
        // Allocate a mapping.
        //

        status =
            NatCreateMapping(
                0,
                DestinationKey,
                SourceKey,
                Interfacep,
                (PVOID)Addressp,
                0,
                NULL,
                NULL,
                NULL,
                NULL,
                &Mapping
                );
        KeReleaseSpinLockFromDpcLevel(&MappingLock);
        if (!NT_SUCCESS(status)) {
            KeLowerIrql(Irql);
            ExInterlockedAddLargeStatistic(
                (PLARGE_INTEGER)&Interfacep->Statistics.RejectsForward, 1
                );
            NatDereferenceInterface(Interfacep);
            return DROP;
        }

        //
        // Activate any applicable dynamic tickets
        //

        if (DynamicTicketCount) {
            NatLookupAndApplyDynamicTicket(
                Protocol,
                DestinationPort,
                Interfacep,
                Addressp->PublicAddress,
                Contextp->SourceAddress
                );
        }

        //
        // Perform the actual translation
        // This replaces the source endpoint with a globally-valid
        // endpoint.
        //

        act =
            Mapping->TranslateRoutine[NatForwardPath](
                Mapping,
                Contextp,
                InReceiveBuffer,
                OutReceiveBuffer
                );

        //
        // Release our reference on the mapping and the interface
        //

        KeLowerIrql(Irql);
        NatDereferenceMapping(Mapping);
        NatDereferenceInterface(Interfacep);
        return act;

    } // TranslateRoutine != NatTranslatePacket

    //
    // Perform ICMP/PPTP translation.
    //
    // N.B. The translation routine must be invoked with a reference made
    // to the boundary interface, and without holding the mapping lock.
    //

    if (TranslateRoutine) {
        act =
            TranslateRoutine(
                Interfacep,
                NatOutboundDirection,
                Contextp,
                InReceiveBuffer,
                OutReceiveBuffer
                );
    }
    KeLowerIrql(Irql);
    NatDereferenceInterface(Interfacep);
    return act;

} // NatpSendPacket


FORWARD_ACTION
NatpTranslateLocalTraffic(
    PNAT_INTERFACE Interfacep OPTIONAL,
    IP_NAT_DIRECTION Direction,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InRecvBuffer,
    IPRcvBuf** OutRecvBuffer
    )

/*++

Routine Description:

    This routine will forward unmodified traffic that is either:
    * received by the local machine
    * sent by the local machine

Arguments:

    Interfacep - the boundary interface over which to translate, or NULL
        if the packet is inbound and the receiving interface has not been
        added to the NAT.

    Direction - the direction in which the packet is traveling

    Contextp - initialized with context-information for the packet

    InRecvBuffer - input buffer-chain

    OutRecvBuffer - receives modified buffer-chain.

Return Value:

    FORWARD_ACTION - indicates action to take on packet.

Environment:

    Invoked with a reference made to 'Interfacep' by the caller.

--*/

{
    FORWARD_ACTION act;
    ULONG i;

    TRACE(PER_PACKET, ("NatpTranslateLocalTraffic\n"));

    if (NatInboundDirection == Direction) {

        //
        // Inbound traffic must be directed to the local machine, and thus
        // is always forwarded.
        //
        
        act = FORWARD;
        
    } else {

        //
        // This is an outgoing packet. We only allow packets that have the
        // same source address as the interface that they are being sent
        // on. This prevents a packet from the private network from being
        // sent to the public network.
        //
        
        if (Interfacep->AddressArray[0].Address == Contextp->SourceAddress) {
            act = FORWARD;
        } else {
            act = DROP;
            for (i = 1; i < Interfacep->AddressCount; i++) {
                if (Contextp->SourceAddress ==
                        Interfacep->AddressArray[i].Address) {

                    //
                    // The packet's source-address is valid,
                    // so the packet will be allowed to go out.
                    //

                    act = FORWARD;
                    break;
                }
            }
        }
    }

    return act;
} // NatpTranslateLocalTraffic



FORWARD_ACTION
NatReverseTcpStateCheck(
    PNAT_DYNAMIC_MAPPING pMapping,
    PTCP_HEADER pTcpHeader
    )

/*++

Routine Description:

    This routine validates that packets for a TCP passive open are valid:
    -- only SYN/ACK (or RST) at first
    -- no SYN after connection is opened (ACK of SYN/ACK)

Arguments:

    pMapping -- the mapping this packet belongs to

    pTcpHeader -- the TCP header of the packet

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

Environment:

    Invoked with pMapping->Lock held by the caller

--*/

{
    USHORT Flags = TCP_ALL_FLAGS(pTcpHeader);

    if (NAT_MAPPING_TCP_OPEN(pMapping)) {
    
        //
        // Connection open -- SYN not allowed
        //

        return (Flags & TCP_FLAG_SYN) ? DROP : FORWARD;

    } else {
    
        ASSERT(pMapping->Flags & NAT_MAPPING_FLAG_FWD_SYN);

        //
        // SYN received, can only send SYN/ACK, RST, or ACK/RST
        //

        if (Flags == (TCP_FLAG_SYN | TCP_FLAG_ACK)) {
            pMapping->Flags |= NAT_MAPPING_FLAG_REV_SYN;
        } else if (Flags != TCP_FLAG_RST
                   && Flags != (TCP_FLAG_ACK | TCP_FLAG_RST)) {
            return DROP;
        }
    }   

    return FORWARD;
}


VOID
NatShutdownPacketManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to shutdown the packet-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked at passive level.

--*/

{
    KIRQL Irql;
    CALLTRACE(("NatShutdownPacketManagement\n"));

    KeAcquireSpinLock(&RouteCacheLock, &Irql);
    if (RouteCacheIrp) {
        PIRP Irp = RouteCacheIrp;
        RouteCacheIrp = NULL;
        KeReleaseSpinLock(&RouteCacheLock, Irql);
        IoCancelIrp(Irp);
        KeAcquireSpinLock(&RouteCacheLock, &Irql);
    }
    KeReleaseSpinLock(&RouteCacheLock, Irql);

} // NatShutdownPacketManagement


FORWARD_ACTION
NatTranslatePacket(
    IPRcvBuf** InReceiveBuffer,
    ULONG ReceiveIndex,
    PULONG SendIndex,
    PUCHAR DestinationType,
    PVOID Unused,
    ULONG UnusedLength,
    IPRcvBuf** OutReceiveBuffer
    )

/*++

Routine Description:

    This routine is invoked to translate a packet just received or a packet
    about to be transmitted. This is the entrypoint into the NAT from TCP/IP,
    invoked for every locally-received and locally-generated IP packet,
    including loopback and transit packets. It is therefore critical
    that a decision be made on each packet as early as possible.

Arguments:

    InReceiveBuffer - points to the packet buffer chain

    ReceiveIndex - index of the adapter on which the packet arrived

    SendIndex - index of the adapter on which the packet is to be sent

    DestinationType - indicates type of packet (broadcast/multicast/unicast)

    Unused - unused

    UnusedLength - unused

    OutReceiveBuffer - receives packet buffer chain if translation occurs.

Return Value:

    FORWARD_ACTION - indicates whether to 'FORWARD' or 'DROP' the packet.

--*/

{
    FORWARD_ACTION act;
    NAT_XLATE_CONTEXT Context;
    ULONG64 DestinationKey;
    PIP_HEADER IpHeader;
    KIRQL Irql;
    ULONG Length;
    USHORT TcpFlags;
    PNAT_DYNAMIC_MAPPING Mapping;
    IPRouteLookupData RouteLookupData;
    ULONG64 SourceKey;
    NTSTATUS status;
    PNAT_IP_TRANSLATE_ROUTINE TranslateRoutine;
  
    TRACE(
        PER_PACKET, (
        "NatTranslatePacket(r=%d,s=%d,t=%d)\n",
        ReceiveIndex,
        *SendIndex,
        *DestinationType
        ));

    //
    // See if the packet is a unicast, and if not, return immediately.
    //

    if (IS_BCAST_DEST(*DestinationType)) {

        //
        // Double-check the dest-type flag,
        // which will appear to be set if the dest-type has been invalidated.
        // If the dest-type has been invalidated, we'll need to guess
        // whether the packet is a unicast.
        //

        if (*DestinationType != DEST_INVALID ||
            !NatpIsUnicastPacket(
                ((PIP_HEADER)(*InReceiveBuffer)->ipr_buffer)->DestinationAddress
                )) {
         
            //
            // We process non-unicast packets if
            // * It is locally-destined or locally-sent
            // * There is at least one firewalled interface
            // * AllowInboundNonUnicastTraffic is FALSE
            //

            if (!AllowInboundNonUnicastTraffic
                && FirewalledInterfaceCount > 0
                && (LOCAL_IF_INDEX == *SendIndex
                    || LOCAL_IF_INDEX ==  ReceiveIndex)) {

                //
                // Build the context for this packet and, if successful, call
                // the non-unicast processing routine.
                //

                IpHeader = (PIP_HEADER)(*InReceiveBuffer)->ipr_buffer;
                NAT_BUILD_XLATE_CONTEXT(
                    &Context,
                    IpHeader,
                    DestinationType,
                    *InReceiveBuffer,
                    IpHeader->SourceAddress,
                    IpHeader->DestinationAddress
                    );
                if (!Context.ProtocolRecvBuffer) { return DROP; }

                if (LOCAL_IF_INDEX == *SendIndex) {
                    act = NatpReceiveNonUnicastPacket(ReceiveIndex, &Context);
                } else {
                    act = NatpSendNonUnicastPacket(*SendIndex, &Context);
                }

#if NAT_WMI
                if (DROP == act) {
                    NatLogDroppedPacket(&Context);
                }
#endif
                return act;

            } else {
                TRACE(PER_PACKET, ("NatTranslatePacket: non-unicast ignored\n"));
                return FORWARD;
            }
       }

        //
        // We guessed the packet is a unicast; process it below.
        //
    }

    

    //
    // This is a unicast packet;
    // Determine which translation routine should handle it,
    // based on the packet's IP-layer protocol number.
    //
    // N.B. This determination is made with *one* access to the table
    // of translation routines. Interlocked changes may be made to this table
    // as the global configuration changes, so we must read from it
    // using a single access.
    //

    IpHeader = (PIP_HEADER)(*InReceiveBuffer)->ipr_buffer;
    TranslateRoutine = TranslateRoutineTable[IpHeader->Protocol];

    //
    // Return quickly if we have nothing to do, that is,
    // if this is a TCP/UDP packet but there are no interfaces,
    // no registered directors, and no mappings.
    //

    if ((PVOID)TranslateRoutine == (PVOID)NatTranslatePacket &&
        !InterfaceCount &&
        !DirectorCount &&
        !MappingCount) {
        return FORWARD;
    }

    //
    // Prepare to translate the packet by building a translation context
    // that encapsulates all the information we'll be using in the remainder
    // of the translation path. If this fails, the packet must be malformed
    // in some way, and we return control right away.
    //

    NAT_BUILD_XLATE_CONTEXT(
        &Context,
        IpHeader,
        DestinationType,
        *InReceiveBuffer,
        IpHeader->SourceAddress,
        IpHeader->DestinationAddress
        );
    if (!Context.ProtocolRecvBuffer) { return DROP; }

    //
    // The packet is a loopback, so return control right away unless there is
    // at least one director. Loopback packets are never translated unless a
    // director specifically asks us to do so. One director that might request
    // a loopback translation is the redirect-director.
    // (See 'REDIRECT.C' and the flag 'IP_NAT_REDIRECT_FLAG_LOOPBACK'.)
    //

    if (LoopbackIndex != INVALID_IF_INDEX &&
        ((ReceiveIndex == LOCAL_IF_INDEX && *SendIndex == LoopbackIndex) ||
         (*SendIndex == LOCAL_IF_INDEX && ReceiveIndex == LoopbackIndex))) {

        if (!DirectorCount && TranslateRoutine != NatTranslateIcmp) {
            TRACE(
                PER_PACKET, (
                "NatTranslatePacket: ignoring loopback (r=%d,s=%d,t=%d)\n",
                ReceiveIndex,
                *SendIndex,
                *DestinationType
                ));
            return FORWARD;
        }
        Context.Flags = NAT_XLATE_FLAG_LOOPBACK;
    } else {
        Context.Flags = 0;
    }

    //
    // Now we are at the fast-path for translation of TCP/UDP session packets.
    // From here on we need to execute at dispatch IRQL, so raise the IRQL
    // in case we were entered at passive IRQL (e.g. during a local send).
    // We then perform a mapping lookup and attempt to use that to translate
    // this packet.
    //

    if ((PVOID)TranslateRoutine != (PVOID)NatTranslatePacket || !MappingCount) {
        KeRaiseIrql(DISPATCH_LEVEL, &Irql);
    } else {

        //
        // If this is a TCP packet, check for invalid TCP flags combinations:
        // * no flag bit sets
        // * none of SYN, ACK, or RST are set
        // * RST w/ anything except ACK
        // * SYN w/ anything except ACK
        //
        // These checks need to happen before searching the mapping trees to
        // prevents certain classes of denial of service attacks (e.g.,
        // 'stream.c').
        //

        if (NAT_PROTOCOL_TCP == IpHeader->Protocol) {
            TcpFlags = TCP_ALL_FLAGS((PTCP_HEADER)Context.ProtocolHeader);
            if (!TcpFlags
                || !(TcpFlags & (TCP_FLAG_SYN | TCP_FLAG_ACK | TCP_FLAG_RST))
                || ((TcpFlags & TCP_FLAG_RST)
                    && (TcpFlags & ~(TCP_FLAG_RST | TCP_FLAG_ACK)))
                || ((TcpFlags & TCP_FLAG_SYN)
                    && (TcpFlags & ~(TCP_FLAG_SYN | TCP_FLAG_ACK)))) {

#if NAT_WMI
                NatLogDroppedPacket(&Context);
#endif
                return DROP;
            }
        }

        //
        // Build a mapping lookup key
        //

        MAKE_MAPPING_KEY(
            DestinationKey,
            IpHeader->Protocol,
            Context.DestinationAddress,
            ((PUSHORT)Context.ProtocolHeader)[1]
            );
        MAKE_MAPPING_KEY(
            SourceKey,
            IpHeader->Protocol,
            Context.SourceAddress,
            ((PUSHORT)Context.ProtocolHeader)[0]
            );

        //
        // Look for a mapping, and translate if found.
        //
        // N.B. We expect to receive more data than we send,
        // and so we first look for a reverse mapping (i.e., incoming).
        //

        KeAcquireSpinLock(&MappingLock, &Irql);
        if (Mapping =
                NatLookupReverseMapping(
                    DestinationKey,
                    SourceKey,
                    NULL
                    )) {
            NatReferenceMapping(Mapping);
            KeReleaseSpinLockFromDpcLevel(&MappingLock);
            *SendIndex = INVALID_IF_INDEX;
            
            act =
                Mapping->TranslateRoutine[NatReversePath](
                    Mapping,
                    &Context,
                    InReceiveBuffer,
                    OutReceiveBuffer
                    );

            NatDereferenceMapping(Mapping);
            KeLowerIrql(Irql);
#if NAT_WMI
            if (DROP == act) {
                NatLogDroppedPacket(&Context);
            }
#endif
            return act;
        } else if (Mapping =
                        NatLookupForwardMapping(
                            DestinationKey,
                            SourceKey,
                            NULL
                            )) {
            NatReferenceMapping(Mapping);
            KeReleaseSpinLockFromDpcLevel(&MappingLock);
            *SendIndex = INVALID_IF_INDEX;
    
            act =
                Mapping->TranslateRoutine[NatForwardPath](
                    Mapping, 
                    &Context,
                    InReceiveBuffer,
                    OutReceiveBuffer
                    );                  

            NatDereferenceMapping(Mapping);
            KeLowerIrql(Irql);
#if NAT_WMI
            if (DROP == act) {
                NatLogDroppedPacket(&Context);
            }
#endif
            return act;
        }
        KeReleaseSpinLockFromDpcLevel(&MappingLock);

        //
        // No mapping was found; go through the process of establishing one.
        //
    }

    //
    // The packet could not be dispensed with in the fast path,
    // so now we enter the second stage of processing.
    // We will first look for a director who knows what to do with the packet,
    // then we will attempt to automatically translate the packet,
    // if it will cross a boundary interface.
    //
    // N.B. If we have neither local interfaces nor installed directors,
    // we know we will make no changes, so return quickly.
    //

    if (!InterfaceCount && !DirectorCount) {
        KeLowerIrql(Irql);
        return FORWARD;
    }

    //
    // Look first of all for a director.
    // If no director is found, or if the director found supplies no mapping,
    // proceed to the automatic-translation code, which is performed
    // for packets which cross boundary interfaces. Note, therefore,
    // that we never do automatic translation for loopback packets.
    //

    if (DirectorCount) {
        status =
            NatpDirectPacket(
                ReceiveIndex,
                *SendIndex,
                &Context,
                InReceiveBuffer,
                OutReceiveBuffer,
                &act
                );
        if (NT_SUCCESS(status)) {
            KeLowerIrql(Irql);
#if NAT_WMI
            if (DROP == act) {
                NatLogDroppedPacket(&Context);
            }
#endif
            return act;
        }
    }

    KeLowerIrql(Irql);

    if (!InterfaceCount ||
        ((Context.Flags & NAT_XLATE_FLAG_LOOPBACK) &&
         !(*SendIndex == LoopbackIndex &&
           TranslateRoutine == NatTranslateIcmp &&
           MappingCount))) {
        return FORWARD;
    }

    //
    // Now decide whether the packet should be automatically translated.
    // We classify the packet as local-send, local-receive, or transit.
    // The action taken depends on which of the three cases is applicable:
    //
    // Locally-sent packets are not translated, with a few exceptions
    // (see 'NatpSendPacket').
    //
    // Locally-received packets are translated if they match the inbound-path
    // of a previously established mapping, or if they match a configured
    // static port-mapping, or a static address-mapping with inbound sessions
    // enabled.
    //
    // Transit packets are translated if their outgoing interface
    // is a boundary interface; transit packets whose incoming interface
    // is a boundary interface are dropped.
    //

    if (ReceiveIndex != LOCAL_IF_INDEX) {

        //
        // The packet is either a locally-destined packet or a transit packet.
        //

        if (*SendIndex == LOCAL_IF_INDEX) {

            //
            // The packet is locally destined.
            // We assume this will happen mostly when packets are received
            // from the public network, and since we expect more incoming
            // packets than outgoing ones, this is our fast path.
            //

            act =
                NatpReceivePacket(
                    ReceiveIndex,
                    &Context,
                    TranslateRoutine,
                    InReceiveBuffer,
                    OutReceiveBuffer
                    );
#if NAT_WMI
            if (DROP == act) {
                NatLogDroppedPacket(&Context);
            }
#endif
            return act;
        }

        //
        // The packet is a transit packet.
        // This will happen when packets are sent to the public network
        // from a private client. Since we expect fewer outgoing packets
        // than incoming ones, this will be hit less often.
        //
        // Unfortunately, it requires a route-lookup.
        // To mitigate this unpleasantness, we use a cache of routes.
        // In cases where there are a few high-volume connections,
        // this will be a big win since we won't have to go through
        // IP's routing table lock to retrieve the outgoing interface.
        //

        *SendIndex =
            NatpRoutePacket(
                Context.DestinationAddress,
                &Context,
                &status
                );

        //
        // If we can't route the packet, neither can IP; drop it early.
        //

        if (*SendIndex == INVALID_IF_INDEX) {
            TRACE(XLATE, ("NatTranslatePacket: dropping unroutable packet\n"));
            if (status != STATUS_PENDING) {
                NatSendRoutingFailureNotification(
                    Context.DestinationAddress,
                    Context.SourceAddress
                    );
            }
#if NAT_WMI
            NatLogDroppedPacket(&Context);
#endif
            return DROP;
        }

        act = 
            NatpForwardPacket(
                ReceiveIndex,
                *SendIndex,
                &Context,
                TranslateRoutine,
                InReceiveBuffer,
                OutReceiveBuffer
                );
                
#if NAT_WMI
        if (DROP == act) {
            NatLogDroppedPacket(&Context);
        }
#endif

        return act;
    }

    //
    // The packet is an outgoing locally-generated packet.
    //

    if (*SendIndex != INVALID_IF_INDEX) {
        act =  
            NatpSendPacket(
                *SendIndex,
                &Context,
                TranslateRoutine,
                InReceiveBuffer,
                OutReceiveBuffer
                );
                
#if NAT_WMI
        if (DROP == act) {
            NatLogDroppedPacket(&Context);
        }
#endif

        return act;
    }

    //
    // 'SendIndex' has been invalidated.
    // Use a route-lookup to get the sending adapter index.
    //

    *SendIndex = NatpRoutePacket(Context.DestinationAddress, NULL, &status);

    //
    // Drop unroutable packets early.
    //

    if (*SendIndex == INVALID_IF_INDEX) {
        TRACE(XLATE, ("NatTranslatePacket: dropping unroutable packet\n"));
        if (status != STATUS_PENDING) {
            NatSendRoutingFailureNotification(
                Context.DestinationAddress,
                Context.SourceAddress
                );
        }

#if NAT_WMI
        NatLogDroppedPacket(&Context);
#endif

        return DROP;
    }

    act =  
        NatpSendPacket(
            *SendIndex,
            &Context,
            TranslateRoutine,
            InReceiveBuffer,
            OutReceiveBuffer
            );

#if NAT_WMI
    if (DROP == act) {
        NatLogDroppedPacket(&Context);
    }
#endif

    return act;

} // NatTranslatePacket


//
// Now include the code for the translation routines;
// See XLATE.H for more details.
//

#define XLATE_CODE

#define XLATE_FORWARD
#include "xlate.h"
#undef XLATE_FORWARD

#define XLATE_REVERSE
#include "xlate.h"
#undef XLATE_REVERSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\xlate.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    xlate.h

Abstract:

    This file contains the code for the translation-routines used for
    mappings.

    The forward routines have the exact same logic as the reverse routines.
    However, for reasons of efficiency the two are separate routines,
    to avoid the cost of indexing on 'NAT_PATH' for every packet
    processed.

    To avoid duplicating the code, then, this header file consolidates the code
    in one location. This file is included twice in XLATE.C, and before each
    inclusion, either 'XLATE_FORWARD' or 'XLATE_REVERSE' is defined.

    This causes the compiler to generate the code for separate functions,
    as desired, while avoiding the unpleasantness of code-duplication.

    The translation routines are as follows:

    NatTranslate?Tcp            - no editor for either direction
    NatTranslate?Udp            - no editor for either direction
    NatTranslate?TcpEdit        - an editor for at least one direction
    NatTranslate?UdpEdit        - an editor for the given direction
    NatTranslate?TcpResize      - a resizing editor for at least one direction

    Each routine is invoked from 'NatTranslatePacket' at dispatch level
    with no locks held and with a reference acquired for the mapping.

Author:

    Abolade Gbadegesin (t-abolag)   July-30-1997

Revision History:

    Abolade Gbadegesin (aboladeg)   July-15-1997

    Reworked to deal with a global splay-tree of mappings, rather than
    a per-interface splay-tree.

--*/


#ifndef XLATE_CODE // Just provide declarations.

//
// Structure:   NAT_CACHED_ROUTE
//
// This structure holds information for a cached route.
//

typedef struct _NAT_CACHED_ROUTE {
    ULONG DestinationAddress;
    ULONG Index;
} NAT_CACHED_ROUTE, *PNAT_CACHED_ROUTE;


//
// Structure:   NAT_XLATE_CONTEXT
//
// This structure holds context-information for a packet as it is passed thru
// the translation code. This context is passed to the translation routines,
// and handed to 'NatEditorEditSession' when it is invoked by an editor to
// make changes to the packet.
//
// Included are the original IP header, the checksum-delta to be updated if
// an editor makes any changes to the packet, and the TCP sequence number delta
// to be set if an editor resizes a TCP segment.
//

typedef struct _NAT_XLATE_CONTEXT {
    IPRcvBuf* RecvBuffer;
    PIP_HEADER Header;
    PUCHAR DestinationType;
    ULONG SourceAddress;
    ULONG DestinationAddress;
    IPRcvBuf* ProtocolRecvBuffer;
    PUCHAR ProtocolHeader;
    ULONG ProtocolDataOffset;
    ULONG Flags;
    PULONG ChecksumDelta;
    LONG TcpSeqNumDelta;
    BOOLEAN ChecksumOffloaded;
} NAT_XLATE_CONTEXT, *PNAT_XLATE_CONTEXT;


//
// Definitions of flags for the field NAT_XLATE_CONTEXT.Flags
//

#define NAT_XLATE_FLAG_EDITED       0x00000001
#define NAT_XLATE_EDITED(h)         ((h)->Flags & NAT_XLATE_FLAG_EDITED)
#define NAT_XLATE_FLAG_LOOPBACK     0x00000002
#define NAT_XLATE_LOOPBACK(h)       ((h)->Flags & NAT_XLATE_FLAG_LOOPBACK)
#if NAT_WMI
#define NAT_XLATE_FLAG_LOGGED       0x00000004
#define NAT_XLATE_LOGGED(h)         ((h)->Flags & NAT_XLATE_FLAG_LOGGED)
#endif

//
// Inline routine to initialize a translation context
// given appropriate arguments.
//

#define \
NAT_BUILD_XLATE_CONTEXT( \
    _Context, \
    _Header, \
    _DestinationType, \
    _RecvBuffer, \
    _SourceAddress, \
    _DestinationAddress \
    ) \
    (_Context)->Header = (PIP_HEADER)_Header; \
    (_Context)->DestinationType = _DestinationType; \
    (_Context)->RecvBuffer = (_RecvBuffer); \
    (_Context)->SourceAddress = _SourceAddress; \
    (_Context)->DestinationAddress = _DestinationAddress; \
    (_Context)->ChecksumOffloaded = \
        ((_RecvBuffer)->ipr_flags & IPR_FLAG_CHECKSUM_OFFLOAD) \
            == IPR_FLAG_CHECKSUM_OFFLOAD; \
    if ((_RecvBuffer)->ipr_size == (ULONG)IP_DATA_OFFSET(_Header)) {\
        if ((_Context)->ProtocolRecvBuffer = (_RecvBuffer)->ipr_next) { \
            (_Context)->ProtocolHeader = (_RecvBuffer)->ipr_next->ipr_buffer; \
        } \
    } \
    else if (IP_DATA_OFFSET(_Header) < (_RecvBuffer)->ipr_size) { \
        (_Context)->ProtocolRecvBuffer = (_RecvBuffer); \
        (_Context)->ProtocolHeader = \
            (_RecvBuffer)->ipr_buffer + IP_DATA_OFFSET(_Header); \
    } else { \
        (_Context)->ProtocolRecvBuffer = NULL; \
        (_Context)->ProtocolHeader = NULL; \
    } \
    if ((_Context)->ProtocolHeader) { \
        UINT ProtocolHeaderSize = 0; \
        UINT HeaderSize = \
            (_Context)->ProtocolRecvBuffer->ipr_size \
                - (UINT) ((_Context)->ProtocolHeader \
                    - (_Context)->ProtocolRecvBuffer->ipr_buffer); \
        switch ((_Context)->Header->Protocol) { \
            case NAT_PROTOCOL_TCP: { \
                ProtocolHeaderSize = sizeof(TCP_HEADER); \
                break; \
            } \
            case NAT_PROTOCOL_UDP: { \
                ProtocolHeaderSize = sizeof(UDP_HEADER); \
                break; \
            } \
            case NAT_PROTOCOL_ICMP: { \
                ProtocolHeaderSize = \
                    FIELD_OFFSET(ICMP_HEADER, EncapsulatedIpHeader); \
                break; \
            } \
            case NAT_PROTOCOL_PPTP: { \
                ProtocolHeaderSize = sizeof(GRE_HEADER); \
                break; \
            } \
        } \
        if (HeaderSize < ProtocolHeaderSize) { \
            (_Context)->ProtocolRecvBuffer = NULL; \
            (_Context)->ProtocolHeader = NULL; \
        } \
    }


//
// Checksum manipulation macros
//

//
// Fold carry-bits of a checksum into the low-order word
//
#define CHECKSUM_FOLD(xsum) \
    (xsum) = (USHORT)(xsum) + ((xsum) >> 16); \
    (xsum) += ((xsum) >> 16)

//
// Sum the words of a 32-bit value into a checksum
//
#define CHECKSUM_LONG(xsum,l) \
    (xsum) += (USHORT)(l) + (USHORT)((l) >> 16)

//
// Transfer a checksum to or from the negated format sent on the network
//
#define CHECKSUM_XFER(dst,src) \
    (dst) = (USHORT)~(src)

//
// Update the checksum field 'x' using standard variables 'Checksum' and
// 'ChecksumDelta'
//
#define CHECKSUM_UPDATE(x) \
    CHECKSUM_XFER(Checksum, (x)); \
    Checksum += ChecksumDelta; \
    CHECKSUM_FOLD(Checksum); \
    CHECKSUM_XFER((x), Checksum)


//
// Checksum computation routines (inlined)
//

__forceinline
VOID
NatComputeIpChecksum(
    PIP_HEADER IpHeader
    )

/*++

Routine Description:

    Computes the IP Checksum for a packet, and places that checksum
    into the packet header.

Arguments:

    IpHeader - pointer to the IP header for which the checksum is to
        be computed. The checksum field of this header will be modified.

Return Value:

    None.
    
--*/

{
    ULONG IpChecksum;

    IpHeader->Checksum = 0;
    IpChecksum = 
        tcpxsum(
            0,
            (PUCHAR)IpHeader,
            IP_DATA_OFFSET(IpHeader)
            );

    CHECKSUM_FOLD(IpChecksum);
    CHECKSUM_XFER(IpHeader->Checksum, IpChecksum);
    
} // NatComputeIpChecksum

__forceinline
VOID
NatComputeTcpChecksum(
    PIP_HEADER IpHeader,
    PTCP_HEADER TcpHeader,
    IPRcvBuf *TcpRcvBuffer
    )

/*++

Routine Description:

    Computes the TCP checksum for a packet, and places that checksum
    into the TCP header.

Arguments:

    IpHeader - pointer to the IP header for the packet.

    TcpHeader - pointer to the TCP for the packet. The checksum field
        in this header will be modified.

    TcpRcvBuffer - the IPRcvBuf containing the TCP header.

Return Value:

    None.
    
--*/

{
    ULONG TcpChecksum;
    IPRcvBuf* Temp;

    TcpChecksum = NTOHS(IpHeader->TotalLength);
    TcpChecksum -= IP_DATA_OFFSET(IpHeader);
    TcpChecksum = NTOHS(TcpChecksum);
    CHECKSUM_LONG(TcpChecksum, IpHeader->SourceAddress);
    CHECKSUM_LONG(TcpChecksum, IpHeader->DestinationAddress);
    TcpChecksum += (NAT_PROTOCOL_TCP << 8);

    TcpHeader->Checksum = 0;
    TcpChecksum +=
        tcpxsum(
            0,
            (PUCHAR)TcpHeader,
            TcpRcvBuffer->ipr_size -
                (ULONG)((PUCHAR)TcpHeader - TcpRcvBuffer->ipr_buffer)
            );

    for (Temp = TcpRcvBuffer->ipr_next;
         Temp;
         Temp = Temp->ipr_next
         ) {
        TcpChecksum +=
            tcpxsum(
                0,
                Temp->ipr_buffer,
                Temp->ipr_size
                );
    }

    CHECKSUM_FOLD(TcpChecksum);
    CHECKSUM_XFER(TcpHeader->Checksum, TcpChecksum);
    
} // NatComputeTcpChecksum

__forceinline
VOID
NatComputeUdpChecksum(
    PIP_HEADER IpHeader,
    PUDP_HEADER UdpHeader,
    IPRcvBuf *UdpRcvBuffer
    )

/*++

Routine Description:

    Computes the UDP checksum for a packet, and places that checksum
    into the UDP header.

Arguments:

    IpHeader - pointer to the IP header for the packet.

    UdpHeader - pointer to the UDP for the packet. The checksum field
        in this header will be modified.

    UdpRcvBuffer - the IPRcvBuf containing the UDP header.

Return Value:

    None.
    
--*/

{
    ULONG UdpChecksum;
    IPRcvBuf* Temp;

    UdpChecksum = UdpHeader->Length;
    CHECKSUM_LONG(UdpChecksum, IpHeader->SourceAddress);
    CHECKSUM_LONG(UdpChecksum, IpHeader->DestinationAddress);
    UdpChecksum += (NAT_PROTOCOL_UDP << 8);

    UdpHeader->Checksum = 0;
    UdpChecksum +=
        tcpxsum(
            0,
            (PUCHAR)UdpHeader,
            UdpRcvBuffer->ipr_size -
                (ULONG)((PUCHAR)UdpHeader - UdpRcvBuffer->ipr_buffer)
            );

    for (Temp = UdpRcvBuffer->ipr_next;
         Temp;
         Temp = Temp->ipr_next
         ) {
        UdpChecksum +=
            tcpxsum(
                0,
                Temp->ipr_buffer,
                Temp->ipr_size
                );
    }

    CHECKSUM_FOLD(UdpChecksum);
    CHECKSUM_XFER(UdpHeader->Checksum, UdpChecksum);
    
} // NatComputeUdpChecksum


//
// Forward declarations of structures defined elsewhere.
//

struct _NAT_INTERFACE;
#define PNAT_INTERFACE          struct _NAT_INTERFACE*

struct _NAT_DYNAMIC_MAPPING;
#define PNAT_DYNAMIC_MAPPING    struct _NAT_DYNAMIC_MAPPING*

//
// Functional signature macro
//

#define XLATE_ROUTINE(Name) \
    FORWARD_ACTION  \
    Name( \
        PNAT_DYNAMIC_MAPPING Mapping, \
        PNAT_XLATE_CONTEXT Contextp, \
        IPRcvBuf** InReceiveBuffer, \
        IPRcvBuf** OutReceiveBuffer \
        );

//
// Prototype:   PNAT_TRANSLATE_ROUTINE
//
// This is the prototype for the routines which handle translation for
// different classes of sessions. Each mapping's 'TranslateRoutine' field
// is initialized with a pointer to such a routine.
//
// This allows us to take advantage of our foreknowledge about sessions.
// For instance, a TCP connection which has no editor registered will never
// have to take the editor-lock, and can skip the check for an editor.
// Similarly, a TCP connection whose editor never resizes a packet does not
// need to ever adjust sequence numbers.
//

typedef XLATE_ROUTINE((FASTCALL*PNAT_TRANSLATE_ROUTINE))

XLATE_ROUTINE(FASTCALL NatTranslateForwardTcp)
XLATE_ROUTINE(FASTCALL NatTranslateReverseTcp)
XLATE_ROUTINE(FASTCALL NatTranslateForwardUdp)
XLATE_ROUTINE(FASTCALL NatTranslateReverseUdp)
XLATE_ROUTINE(FASTCALL NatTranslateForwardTcpEdit)
XLATE_ROUTINE(FASTCALL NatTranslateReverseTcpEdit)
XLATE_ROUTINE(FASTCALL NatTranslateForwardUdpEdit)
XLATE_ROUTINE(FASTCALL NatTranslateReverseUdpEdit)
XLATE_ROUTINE(FASTCALL NatTranslateForwardTcpResize)
XLATE_ROUTINE(FASTCALL NatTranslateReverseTcpResize)

//
// NatTranslate?Null is used for firewall-only mappings (i.e., mappings that
// don't perform any actual translation). These routines never have to modify
// any of the packet data; they only update the bookkeeping...
//

XLATE_ROUTINE(FASTCALL NatTranslateForwardTcpNull)
XLATE_ROUTINE(FASTCALL NatTranslateReverseTcpNull)
XLATE_ROUTINE(FASTCALL NatTranslateForwardUdpNull)
XLATE_ROUTINE(FASTCALL NatTranslateReverseUdpNull)


//
// Functional signature macro
//

#define XLATE_IP_ROUTINE(Name) \
FORWARD_ACTION \
Name( \
    PNAT_INTERFACE Interfacep OPTIONAL, \
    IP_NAT_DIRECTION Direction, \
    PNAT_XLATE_CONTEXT Contextp, \
    IPRcvBuf** InRecvBuffer, \
    IPRcvBuf** OutRecvBuffer \
    );

//
// Prototype:   PNAT_IP_TRANSLATE_ROUTINE
//
// This is the prototype for the routines which handle translation for
// protocols other than TCP and UDP, i.e. for IP-layer protocols.
//
// All such routines are responsible for updating the IP header checksum,
// and updating 'InRecvBuffer' and 'OutRecvBuffer' in the event of any change
// to the packet being processed.
//

typedef XLATE_IP_ROUTINE((*PNAT_IP_TRANSLATE_ROUTINE))

//
// Prototype: Nat?TCPStateCheck
//
// These routines are used in FW mode to protect against various forms of
// constructed packets (e.g., SYN/FIN).
//
void
FASTCALL
NatAdjustMSSOption(
    PNAT_XLATE_CONTEXT Contextp,
    USHORT maxMSS
    );

FORWARD_ACTION
NatForwardTcpStateCheck(
    PNAT_DYNAMIC_MAPPING pMapping,
    PTCP_HEADER pTcpHeader
    );

FORWARD_ACTION
NatReverseTcpStateCheck(
    PNAT_DYNAMIC_MAPPING pMapping,
    PTCP_HEADER pTcpHeader
    );

#undef PNAT_INTERFACE
#undef PNAT_DYNAMIC_MAPPING

PNAT_IP_TRANSLATE_ROUTINE TranslateRoutineTable[256];


//
// FUNCTION PROTOTYPES
//

VOID
NatInitializePacketManagement(
    VOID
    );

VOID
NatShutdownPacketManagement(
    VOID
    );

FORWARD_ACTION
NatTranslatePacket(
    IPRcvBuf** InReceiveBuffer,
    ULONG ReceiveAdapterIndex,
    PULONG SendAdapterIndex,
    PUCHAR DestinationType,
    PVOID Unused,
    ULONG UnusedLength,
    IPRcvBuf** OutReceiveBuffer
    );


#else // XLATE_CODE

//
// Produce code for the protocol-layer translation routines.
// Produce forward-routines if 'XLATE_FORWARD' is defined,
// and reverse routines otherwise.
//

#ifdef XLATE_FORWARD
#define XLATE_POSITIVE                  NatForwardPath
#define XLATE_NEGATIVE                  NatReversePath
#define NAT_TRANSLATE_TCP               NatTranslateForwardTcp
#define NAT_TRANSLATE_UDP               NatTranslateForwardUdp
#define NAT_TRANSLATE_TCP_EDIT          NatTranslateForwardTcpEdit
#define NAT_TRANSLATE_UDP_EDIT          NatTranslateForwardUdpEdit
#define NAT_TRANSLATE_TCP_RESIZE        NatTranslateForwardTcpResize
#define NAT_TRANSLATE_TCP_NULL          NatTranslateForwardTcpNull
#define NAT_TRANSLATE_UDP_NULL          NatTranslateForwardUdpNull
#define NAT_TRANSLATE_SYN               NAT_MAPPING_FLAG_FWD_SYN
#define NAT_TRANSLATE_FIN               NAT_MAPPING_FLAG_FWD_FIN
#define NAT_TRANSLATE_TCP_STATE_CHECK   NatForwardTcpStateCheck
#define DATA_HANDLER                    ForwardDataHandler
#define BYTE_COUNT                      BytesForward
#define PACKET_COUNT                    PacketsForward
#define REJECT_COUNT                    RejectsForward
#define NAT_TRANSLATE_HEADER() \
    Contextp->Header->DestinationAddress = \
        MAPPING_ADDRESS(Mapping->SourceKey[NatReversePath]); \
    ((PUSHORT)Contextp->ProtocolHeader)[1] = \
        MAPPING_PORT(Mapping->SourceKey[NatReversePath]); \
    Contextp->Header->SourceAddress = \
        MAPPING_ADDRESS(Mapping->DestinationKey[NatReversePath]); \
    ((PUSHORT)Contextp->ProtocolHeader)[0] = \
        MAPPING_PORT(Mapping->DestinationKey[NatReversePath])
#define NAT_DROP_IF_UNIDIRECTIONAL()
#else
#define XLATE_POSITIVE                  NatReversePath
#define XLATE_NEGATIVE                  NatForwardPath
#define NAT_TRANSLATE_TCP               NatTranslateReverseTcp
#define NAT_TRANSLATE_UDP               NatTranslateReverseUdp
#define NAT_TRANSLATE_TCP_EDIT          NatTranslateReverseTcpEdit
#define NAT_TRANSLATE_UDP_EDIT          NatTranslateReverseUdpEdit
#define NAT_TRANSLATE_TCP_RESIZE        NatTranslateReverseTcpResize
#define NAT_TRANSLATE_TCP_NULL          NatTranslateReverseTcpNull
#define NAT_TRANSLATE_UDP_NULL          NatTranslateReverseUdpNull
#define NAT_TRANSLATE_SYN               NAT_MAPPING_FLAG_REV_SYN
#define NAT_TRANSLATE_FIN               NAT_MAPPING_FLAG_REV_FIN
#define NAT_TRANSLATE_TCP_STATE_CHECK   NatReverseTcpStateCheck
#define DATA_HANDLER                    ReverseDataHandler
#define BYTE_COUNT                      BytesReverse
#define PACKET_COUNT                    PacketsReverse
#define REJECT_COUNT                    RejectsReverse
#define NAT_TRANSLATE_HEADER() \
    Contextp->Header->DestinationAddress = \
        MAPPING_ADDRESS(Mapping->SourceKey[NatForwardPath]); \
    ((PUSHORT)Contextp->ProtocolHeader)[1] = \
        MAPPING_PORT(Mapping->SourceKey[NatForwardPath]); \
    Contextp->Header->SourceAddress = \
        MAPPING_ADDRESS(Mapping->DestinationKey[NatForwardPath]); \
    ((PUSHORT)Contextp->ProtocolHeader)[0] = \
        MAPPING_PORT(Mapping->DestinationKey[NatForwardPath])
#define NAT_DROP_IF_UNIDIRECTIONAL() \
    if (NAT_MAPPING_UNIDIRECTIONAL(Mapping)) { return DROP; }
#endif

FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_TCP(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    ULONG IpChecksumDelta;
    PIP_HEADER IpHeader = Contextp->Header;
    ULONG ProtocolChecksumDelta;
    PRTL_SPLAY_LINKS SLink;

    PTCP_HEADER TcpHeader = (PTCP_HEADER)Contextp->ProtocolHeader;

    //
    // We know we will make changes to the buffer-chain,
    // so move the head of the list to 'OutReceiveBuffer'.
    //

    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;

    //
    // Update the IP and protocol headers with the translated address/port
    //

    NAT_TRANSLATE_HEADER();

    if (!Contextp->ChecksumOffloaded) {

        //
        // Now add the checksum-delta incurred by changes to the IP header
        //

        CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
        CHECKSUM_XFER(
            ProtocolChecksumDelta,
            ((PTCP_HEADER)Contextp->ProtocolHeader)->Checksum
            );

        IpChecksumDelta += Mapping->IpChecksumDelta[XLATE_POSITIVE];
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);

        ProtocolChecksumDelta += Mapping->ProtocolChecksumDelta[XLATE_POSITIVE];
        CHECKSUM_FOLD(ProtocolChecksumDelta);
        CHECKSUM_XFER(
            ((PTCP_HEADER)Contextp->ProtocolHeader)->Checksum,
            ProtocolChecksumDelta
            );

    } else {

        //
        // Compute the IP and TCP checksums
        //

        NatComputeIpChecksum(IpHeader);
        NatComputeTcpChecksum(
            IpHeader,
            (PTCP_HEADER)Contextp->ProtocolHeader,
            Contextp->ProtocolRecvBuffer
            );
    }

    if (NAT_MAPPING_CLEAR_DF_BIT(Mapping) &&
        (IpHeader->OffsetAndFlags & IP_DF_FLAG)) {

        //
        // Clear the DF bit from this packet and adjust the IP
        // checksum accordingly.
        //

        IpHeader->OffsetAndFlags &= ~IP_DF_FLAG;

        CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
        IpChecksumDelta += ~IP_DF_FLAG;
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
    }

    //
    // Check if need to adjust MSS options in TCP SYNs
    //
    if (TCP_FLAG(TcpHeader, SYN) && (Mapping->MaxMSS > 0)) {
        NatAdjustMSSOption(Contextp, Mapping->MaxMSS);
    }    

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);

    //
    // Perform state validation for inbound mappings.
    //

    if (NAT_MAPPING_INBOUND(Mapping)
        && DROP == NAT_TRANSLATE_TCP_STATE_CHECK(
                    Mapping,
                    TcpHeader
                    )) {
                    
        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
        return DROP;
    } else if (TCP_FLAG(TcpHeader, SYN)) {

        //
        // Record that we've seen a SYN in this direction
        //

        Mapping->Flags |= NAT_TRANSLATE_SYN;
    }


    //
    // Now we need to update the connection state for the sender
    // based on the flags in the packet:
    //
    // When a RST is seen, we close both ends of the connection.
    // As each FIN is seen, we mark the mapping appropriately.
    // When both FINs have been seen, we mark the mapping for deletion.
    //
    
    if (TCP_FLAG(((PTCP_HEADER)Contextp->ProtocolHeader), RST)) {
        NatExpireMapping(Mapping);
    }
    else
    if (TCP_FLAG(((PTCP_HEADER)Contextp->ProtocolHeader), FIN)) {
        Mapping->Flags |= NAT_TRANSLATE_FIN;
        if (NAT_MAPPING_FIN(Mapping)) {
            NatExpireMapping(Mapping);
        }
    }

    //
    // Update the mapping's timestamp and statistics 
    //

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        TCP_DATA_OFFSET(((PTCP_HEADER)Contextp->ProtocolHeader))
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically), and indicate the change
    // by invalidating 'DestinationType'
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NAT_TRANSLATE_TCP


FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_UDP(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    ULONG IpChecksumDelta;
    PIP_HEADER IpHeader = Contextp->Header;
    ULONG ProtocolChecksumDelta;
    PRTL_SPLAY_LINKS SLink;
    PUDP_HEADER UdpHeader = (PUDP_HEADER)Contextp->ProtocolHeader;
    BOOLEAN UpdateXsum;

    //
    // We know we will make changes to the buffer-chain,
    // so move the head of the list to 'OutReceiveBuffer'.
    //

    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;

    //
    // Unidirectional flows require that reverse packets be dropped;
    // This is primarily to support H.323 proxy.
    // 

    NAT_DROP_IF_UNIDIRECTIONAL();

    //
    // We have to handle the fact that the UDP checksum is optional;
    // if the checksum in the header is zero, then no checksum was sent
    // and we will make no changes to the field.
    //

    CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
    if (!UdpHeader->Checksum) {
        UpdateXsum = FALSE;
    }
    else {
        UpdateXsum = TRUE;
        CHECKSUM_XFER(ProtocolChecksumDelta, UdpHeader->Checksum);
    }

    //
    // Update the IP and protocol headers with the translated address/port
    //

    NAT_TRANSLATE_HEADER();

    if (!Contextp->ChecksumOffloaded) {

        //
        // Update the checksums
        //

        IpChecksumDelta += Mapping->IpChecksumDelta[XLATE_POSITIVE];
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);

        if (UpdateXsum) {
            ProtocolChecksumDelta += Mapping->ProtocolChecksumDelta[XLATE_POSITIVE];
            CHECKSUM_FOLD(ProtocolChecksumDelta);
            CHECKSUM_XFER(UdpHeader->Checksum, ProtocolChecksumDelta);
        }

    } else {

        //
        // Compute the IP and (optionally) UDP checksums
        //

        NatComputeIpChecksum(IpHeader);

        if (UpdateXsum) {
            NatComputeUdpChecksum(
                IpHeader,
                (PUDP_HEADER)Contextp->ProtocolHeader,
                Contextp->ProtocolRecvBuffer
                );
        }
    }

    if (NAT_MAPPING_CLEAR_DF_BIT(Mapping) &&
        (IpHeader->OffsetAndFlags & IP_DF_FLAG)) {

        //
        // Clear the DF bit from this packet and adjust the IP
        // checksum accordingly.
        //

        IpHeader->OffsetAndFlags &= ~IP_DF_FLAG;

        CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
        IpChecksumDelta += ~IP_DF_FLAG;
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
    }

    //
    // Update the mapping's statistics and timestamp
    //

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);
    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        sizeof(UDP_HEADER)
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically), and indicate the change
    // by invalidating 'DestinationType'
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NAT_TRANSLATE_UDP


FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_TCP_EDIT(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    PNAT_EDITOR Editor;
    PVOID EditorContext;
    PNAT_INTERFACE Interfacep;
    ULONG IpChecksumDelta;
    PIP_HEADER IpHeader = Contextp->Header;
    BOOLEAN IsReset;
    ULONG ProtocolChecksumDelta;
    PRTL_SPLAY_LINKS SLink;
    NTSTATUS status;
    PTCP_HEADER TcpHeader = (PTCP_HEADER)Contextp->ProtocolHeader;

    //
    // We know we will make changes to the buffer-chain,
    // so move the head of the list to 'OutReceiveBuffer'.
    //

    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;

    CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
    CHECKSUM_XFER(ProtocolChecksumDelta, TcpHeader->Checksum);

    IsReset = !!TCP_FLAG(TcpHeader, RST);

    //
    // Call the editor for this session, if there is one.
    // Note that the mapping's cached pointers to the editor and interface
    // are referenced within the appropriate lock before being used.
    // See the synchronization rules governing 'Mapping->Editor*'
    // and 'Mapping->Interface*' in 'MAPPING.H' for the logic behind
    // the operations below.
    //

    KeAcquireSpinLockAtDpcLevel(&EditorLock);
    if (!(Editor = Mapping->Editor) ||
        !Editor->DATA_HANDLER ||
        !NatReferenceEditor(Editor)) {
        KeReleaseSpinLockFromDpcLevel(&EditorLock);
    }
    else {
        EditorContext = Mapping->EditorContext;
        KeReleaseSpinLockFromDpcLevel(&EditorLock);

        //
        // Set up context fields for the editor
        //

        Contextp->ProtocolDataOffset = 
            (ULONG)((PUCHAR)TcpHeader -
            (PUCHAR)Contextp->ProtocolRecvBuffer->ipr_buffer) +
            TCP_DATA_OFFSET(TcpHeader);
        Contextp->ChecksumDelta = &ProtocolChecksumDelta;

        //
        // Invoke the editor's receive handler
        // if this is not a TCP RST segment.
        //

        if (!IsReset) {

            //
            // The editor-helper functions require that
            // 'Interfacep', 'Editor' and 'Mapping' be referenced
            // but not locked.
            //

            KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
            if (!(Interfacep = Mapping->Interfacep) ||
                !NatReferenceInterface(Interfacep)
                ) {
                KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
            }
            else {
                KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
                status =
                    Editor->DATA_HANDLER(
                        Interfacep,
                        (PVOID)Mapping,
                        (PVOID)Contextp,
                        Editor->Context,
                        EditorContext,
                        (PVOID)Contextp->ProtocolRecvBuffer,
                        Contextp->ProtocolDataOffset
                        );
                NatDereferenceInterface(Interfacep);
                if (!NT_SUCCESS(status)) {
                    NatDereferenceEditor(Editor);
                    InterlockedIncrement(&Mapping->REJECT_COUNT);
                    return DROP;
                }

                //
                // Reset the fields formerly retrieved from the context,
                // which may now point to memory that has been freed.
                // (see 'NatHelperEditSession').
                //
    
                IpHeader = Contextp->Header;
                TcpHeader = (PTCP_HEADER)Contextp->ProtocolHeader;
            }
        }
    }

    //
    // Update the IP and protocol headers with the translated address/port
    //

    NAT_TRANSLATE_HEADER();

    //
    // Now add the checksum-delta incurred by changes to the IP header
    //

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);

    //
    // Perform state validation for inbound mappings.
    //

    if (NAT_MAPPING_INBOUND(Mapping)
        && DROP == NAT_TRANSLATE_TCP_STATE_CHECK(
                    Mapping,
                    TcpHeader
                    )) {
                    
        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
        return DROP;
    } else if (TCP_FLAG(TcpHeader, SYN)) {

        //
        // Record that we've seen a SYN in this direction
        //

        Mapping->Flags |= NAT_TRANSLATE_SYN;
    }

    if (!Contextp->ChecksumOffloaded) {

        IpChecksumDelta += Mapping->IpChecksumDelta[XLATE_POSITIVE];
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
        
        if (!NAT_XLATE_EDITED(Contextp)) {
            ProtocolChecksumDelta += Mapping->ProtocolChecksumDelta[XLATE_POSITIVE];
            CHECKSUM_FOLD(ProtocolChecksumDelta);
            CHECKSUM_XFER(TcpHeader->Checksum, ProtocolChecksumDelta);

        } else {

            //
            // NatEditorEditSession was called on the packet;
            // Completely recompute the TCP checksum.
            //
            
            NatComputeTcpChecksum(
                IpHeader,
                (PTCP_HEADER)Contextp->ProtocolHeader,
                Contextp->ProtocolRecvBuffer
                );
        }

    } else {

        //
        // Compute the IP and TCP checksums
        //

        NatComputeIpChecksum(IpHeader);
        NatComputeTcpChecksum(
            IpHeader,
            (PTCP_HEADER)Contextp->ProtocolHeader,
            Contextp->ProtocolRecvBuffer
            );
    }

    if (NAT_MAPPING_CLEAR_DF_BIT(Mapping) &&
        (IpHeader->OffsetAndFlags & IP_DF_FLAG)) {

        //
        // Clear the DF bit from this packet and adjust the IP
        // checksum accordingly.
        //

        IpHeader->OffsetAndFlags &= ~IP_DF_FLAG;

        CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
        IpChecksumDelta += ~IP_DF_FLAG;
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
    }

    //
    // Check if need to adjust MSS options in TCP SYNs
    //
    if (TCP_FLAG(TcpHeader, SYN) && (Mapping->MaxMSS > 0)) {
        NatAdjustMSSOption(Contextp, Mapping->MaxMSS);
    }    

    //
    // Now we need to update the connection state for the sender
    // based on the flags in the packet:
    //
    // When a RST is seen, we close both ends of the connection.
    // As each FIN is seen, we mark the mapping appropriately.
    // When both FINs have been seen, we mark the mapping for deletion.
    //

    if (IsReset) {
        NatExpireMapping(Mapping);
    }
    else
    if (TCP_FLAG(TcpHeader, FIN)) {
        Mapping->Flags |= NAT_TRANSLATE_FIN;
        if (NAT_MAPPING_FIN(Mapping)) {
            NatExpireMapping(Mapping);
        }
    }

    //
    // Update the mapping's statistics and timestamp
    //

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        TCP_DATA_OFFSET(TcpHeader)
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically), and indicate the change
    // by invalidating 'DestinationType'
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NAT_TRANSLATE_TCP_EDIT


FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_UDP_EDIT(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    PNAT_EDITOR Editor;
    PVOID EditorContext;
    PNAT_INTERFACE Interfacep;
    ULONG IpChecksumDelta;
    PIP_HEADER IpHeader = Contextp->Header;
    BOOLEAN IsReset;
    ULONG ProtocolChecksumDelta;
    PRTL_SPLAY_LINKS SLink;
    NTSTATUS status;
    BOOLEAN UpdateXsum;
    PUDP_HEADER UdpHeader = (PUDP_HEADER)Contextp->ProtocolHeader;

    //
    // We know we will make changes to the buffer-chain,
    // so move the head of the list to 'OutReceiveBuffer'.
    //

    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;

    //
    // We have to handle the fact that the UDP checksum is optional;
    // if the checksum in the header is zero, then no checksum was sent
    // and we will make no changes to the field.
    //

    CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);

    if (!UdpHeader->Checksum) {
        UpdateXsum = FALSE;
    }
    else {
        UpdateXsum = TRUE;
        CHECKSUM_XFER(ProtocolChecksumDelta, UdpHeader->Checksum);
    }

    //
    // Call the editor for this session, if there is one.
    // Note that the mapping's cached pointers to the editor and interface
    // are referenced within the appropriate lock before being used.
    // See the synchronization rules governing 'Mapping->Editor*'
    // and 'Mapping->Interface*' in 'MAPPING.H' for the logic behind
    // the operations below.
    //

    KeAcquireSpinLockAtDpcLevel(&EditorLock);
    if (!(Editor = Mapping->Editor) ||
        !Editor->DATA_HANDLER ||
        !NatReferenceEditor(Editor)) {
        KeReleaseSpinLockFromDpcLevel(&EditorLock);
    }
    else {
        EditorContext = Mapping->EditorContext;
        KeReleaseSpinLockFromDpcLevel(&EditorLock);

        //
        // Set up the context fields to be used for editing
        //

        Contextp->ProtocolDataOffset =
            (ULONG)((PUCHAR)UdpHeader -
            Contextp->ProtocolRecvBuffer->ipr_buffer) +
            sizeof(UDP_HEADER);
        Contextp->ChecksumDelta = UpdateXsum ? &ProtocolChecksumDelta : NULL;

        //
        // Invoke the editor's receive handler
        //
        // The editor-helper functions require that
        // 'Interfacep', 'Editor' and 'Mapping' be referenced
        // but not locked.
        //

        KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
        if (!(Interfacep = Mapping->Interfacep) ||
            !NatReferenceInterface(Interfacep)
            ) {
            KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
        }
        else {
            KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
            status =
                Editor->DATA_HANDLER(
                    Interfacep,
                    (PVOID)Mapping,
                    (PVOID)Contextp,
                    Editor->Context,
                    EditorContext,
                    (PVOID)Contextp->ProtocolRecvBuffer,
                    Contextp->ProtocolDataOffset
                    );
            NatDereferenceInterface(Interfacep);
            if (!NT_SUCCESS(status)) {
                NatDereferenceEditor(Editor);
                InterlockedIncrement(&Mapping->REJECT_COUNT);
                return DROP;
            }

            //
            // Reset the fields formerly retrieved from the context,
            // which may now point to memory that has been freed.
            // (see 'NatHelperEditSession').
            //

            IpHeader = Contextp->Header;
            UdpHeader = (PUDP_HEADER)Contextp->ProtocolHeader;
        }

        NatDereferenceEditor(Editor);
    }

    //
    // Update the IP and protocol headers with the translated address/port
    //

    NAT_TRANSLATE_HEADER();

    if (!Contextp->ChecksumOffloaded) {

        //
        // Update the checksums
        //

        IpChecksumDelta += Mapping->IpChecksumDelta[XLATE_POSITIVE];
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);

        if (UpdateXsum) {
        
            if (!NAT_XLATE_EDITED(Contextp)) {
                ProtocolChecksumDelta +=
                    Mapping->ProtocolChecksumDelta[XLATE_POSITIVE];
                CHECKSUM_FOLD(ProtocolChecksumDelta);
                CHECKSUM_XFER(UdpHeader->Checksum, ProtocolChecksumDelta);
            }
            else {
                //
                // NatEditorEditSession was called on the packet;
                // Completely recompute the UDP checksum.
                //
                
                NatComputeUdpChecksum(
                    IpHeader,
                    (PUDP_HEADER)Contextp->ProtocolHeader,
                    Contextp->ProtocolRecvBuffer
                    );
            }
        }

    } else {

        //
        // Compute the IP and (optionally) UDP checksums
        //

        NatComputeIpChecksum(IpHeader);

        if (UpdateXsum) {
            NatComputeUdpChecksum(
                IpHeader,
                (PUDP_HEADER)Contextp->ProtocolHeader,
                Contextp->ProtocolRecvBuffer
                );
        }

    }

    if (NAT_MAPPING_CLEAR_DF_BIT(Mapping) &&
        (IpHeader->OffsetAndFlags & IP_DF_FLAG)) {

        //
        // Clear the DF bit from this packet and adjust the IP
        // checksum accordingly.
        //

        IpHeader->OffsetAndFlags &= ~IP_DF_FLAG;

        CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
        IpChecksumDelta += ~IP_DF_FLAG;
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
    }

    //
    // Update the mapping's statistics and timestamp
    //

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);
    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        sizeof(UDP_HEADER)
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically), and indicate the change
    // by invalidating 'DestinationType'
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NAT_TRANSLATE_UDP_EDIT


FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_TCP_RESIZE(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    PNAT_EDITOR Editor;
    PVOID EditorContext;
    PNAT_INTERFACE Interfacep;
    ULONG IpChecksumDelta;
    PIP_HEADER IpHeader = Contextp->Header;
    BOOLEAN IsResend;
    BOOLEAN IsReset;
    BOOLEAN IsSyn;
    ULONG ProtocolChecksumDelta;
    PRTL_SPLAY_LINKS SLink;
    NTSTATUS status;
    PTCP_HEADER TcpHeader = (PTCP_HEADER)Contextp->ProtocolHeader;

    //
    // We know we will make changes to the buffer-chain,
    // so move the head of the list to 'OutReceiveBuffer'.
    //

    *OutReceiveBuffer = *InReceiveBuffer; *InReceiveBuffer = NULL;

    CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
    CHECKSUM_XFER(ProtocolChecksumDelta, TcpHeader->Checksum);

    IsResend = FALSE;
    IsReset = !!TCP_FLAG(TcpHeader, RST);
    IsSyn = !!TCP_FLAG(TcpHeader, SYN);

    //
    // Set up context fields for the editor
    //

    Contextp->ProtocolDataOffset =
        (ULONG)((PUCHAR)TcpHeader -
        Contextp->ProtocolRecvBuffer->ipr_buffer) +
        TCP_DATA_OFFSET(TcpHeader);
    Contextp->ChecksumDelta = &ProtocolChecksumDelta;
    Contextp->TcpSeqNumDelta = 0;

    //
    // Call the editor for this session, if there is one.
    // Note that the mapping's cached pointers to the editor and interface
    // are referenced within the appropriate lock before being used.
    // See the synchronization rules governing 'Mapping->Editor*'
    // and 'Mapping->Interface*' in 'MAPPING.H' for the logic behind
    // the operations below.
    //

    KeAcquireSpinLockAtDpcLevel(&EditorLock);
    if (!(Editor = Mapping->Editor) ||
        !NatReferenceEditor(Editor)) {
        KeReleaseSpinLockFromDpcLevel(&EditorLock);
    }
    else {
        EditorContext = Mapping->EditorContext;
        KeReleaseSpinLockFromDpcLevel(&EditorLock);

        //
        // On a SYN packet, just record the sequence number
        // On a RST packet, the sequence number is ignored
        // On other packets, make sure the packet is in sequence.
        // If the packet is a retransmission, we try to apply 
        // the sequence number delta. If the packet is too old
        // (i.e. we don't have the delta which would apply to it)
        // then we drop the packet.
        //
        // N.B. With resized TCP sessions the checksum-delta may change,
        // and so we only touch it under cover of the mapping's lock.
        //

        KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);

        //
        // Perform state validation for inbound mappings.
        //

        if (NAT_MAPPING_INBOUND(Mapping)
            && DROP == NAT_TRANSLATE_TCP_STATE_CHECK(
                        Mapping,
                        TcpHeader
                        )) {
                        
            KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
            return DROP;
        } else if (IsSyn) {

            //
            // Record that we've seen a SYN in this direction
            //

            Mapping->Flags |= NAT_TRANSLATE_SYN;
        }


        if (IsSyn || !(Mapping->Flags & NAT_TRANSLATE_SYN)) {

            //
            // First packet for this direction;
            // just record the sequence number as if it were expected.
            //

            Mapping->TcpSeqNumBase[XLATE_POSITIVE] =
                TcpHeader->SequenceNumber;
            Mapping->TcpSeqNumExpected[XLATE_POSITIVE] =
                RtlUlongByteSwap(
                    RtlUlongByteSwap(TcpHeader->SequenceNumber) + 1
                    );
        }
        else
        if (TcpHeader->SequenceNumber ==
            Mapping->TcpSeqNumExpected[XLATE_POSITIVE] || IsReset
            ) {

            //
            // The packet is in sequence, which is the most common case,
            // or the segment has the reset bit set.
            // No action is required.
            //

        }
        else {

            ULONG Sn =
                RtlUlongByteSwap(TcpHeader->SequenceNumber);
            ULONG SnE =
                RtlUlongByteSwap(Mapping->TcpSeqNumExpected[XLATE_POSITIVE]);
            ULONG Base =
                RtlUlongByteSwap(Mapping->TcpSeqNumBase[XLATE_POSITIVE]);

            //
            // The packet is out of sequence.
            // See if the current delta applies to it,
            // i.e. if it is a retransmission of a packet
            // which appears *after* the sequence number at which
            // the current delta was computed.
            // N.B. When comparing sequence numbers, account for wraparound
            // by adding half the sequence-number space.
            //

            if ((Sn < SnE || (Sn + MAXLONG) < (SnE + MAXLONG)) &&
                (Sn >= Base || (Sn + MAXLONG) > (Base + MAXLONG))
                ) {
    
                //
                // The packet is a retransmission, and our delta applies.
                //
    
                IsResend = TRUE;

                TRACE(
                    XLATE, ("NatTranslate: retransmission %u, expected %u\n",
                    Sn, SnE
                    ));
            }
            else {
    
                //
                // The packet is an old retransmission or it is out-of-order.
                // We have no choice but to drop it.
                //
    
                KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
                NatDereferenceEditor(Editor);

                TRACE(
                    XLATE, ("NatTranslate: out-of-order %u, expected %u\n",
                    Sn, SnE
                    ));
    
                InterlockedIncrement(&Mapping->REJECT_COUNT);
                return DROP;
            }
        }

        if (!IsResend) {
    
            //
            // Compute the next expected sequence number
            //
    
            Mapping->TcpSeqNumExpected[XLATE_POSITIVE] = 
                RtlUlongByteSwap(Mapping->TcpSeqNumExpected[XLATE_POSITIVE]) +
                NTOHS(IpHeader->TotalLength) -
                IP_DATA_OFFSET(IpHeader) -
                TCP_DATA_OFFSET(TcpHeader);
    
            Mapping->TcpSeqNumExpected[XLATE_POSITIVE] = 
                RtlUlongByteSwap(Mapping->TcpSeqNumExpected[XLATE_POSITIVE]);
        }

        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

        //
        // Invoke the editor's receive handler
        // if this is not a TCP SYN or RST segment.
        //

        if (!IsSyn && !IsReset) {
            if (Editor->DATA_HANDLER) {
        
                //
                // The editor-helper functions require that
                // 'Interfacep', 'Editor' and 'Mapping' be referenced
                // but not locked.
                //
    
                KeAcquireSpinLockAtDpcLevel(&InterfaceLock);
                if (!(Interfacep = Mapping->Interfacep) ||
                    !NatReferenceInterface(Interfacep)
                    ) {
                    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
                }
                else {
                    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
                    status =
                        Editor->DATA_HANDLER(
                            Interfacep,
                            (PVOID)Mapping,
                            (PVOID)Contextp,
                            Editor->Context,
                            EditorContext,
                            (PVOID)Contextp->ProtocolRecvBuffer,
                            Contextp->ProtocolDataOffset
                            );
                    NatDereferenceInterface(Interfacep);
                    if (!NT_SUCCESS(status)) {
                        NatDereferenceEditor(Editor);
                        InterlockedIncrement(&Mapping->REJECT_COUNT);
                        return DROP;
                    }

                    //
                    // Reset the fields formerly retrieved from the context,
                    // which may now point to memory that has been freed.
                    // (see 'NatHelperEditSession').
                    //

                    IpHeader = Contextp->Header;
                    TcpHeader = (PTCP_HEADER)Contextp->ProtocolHeader;
    
                    //
                    // We can't allow editors to edit retransmitted packets,
                    // since they wouldn't be able to guarantee that they make
                    // exactly the same changes to the retransmission as they
                    // made to the original.
                    //
    
                    if (IsResend && NAT_XLATE_EDITED(Contextp)) {
                        NatDereferenceEditor(Editor);
                        InterlockedIncrement(&Mapping->REJECT_COUNT);
                        return DROP;
                    }
                }
            }
        }

        NatDereferenceEditor(Editor);
    }

    if (!IsReset) {

        //
        // The editor is done doing the things that it does,
        // including changing the packet size, possibly,
        // so now adjust the TCP header's sequence number if necessary.
        // Again the exclusion is RST segments.
        //

        KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);

        //
        // If necessary, apply a delta value to the sequence number
        // in the header of the TCP segment.
        //

        if (Mapping->TcpSeqNumDelta[XLATE_POSITIVE]) {

            //
            // Update the checksum (see RFC1624):
            //
            // Take out ones-complement sum of old sequence number
            //

            CHECKSUM_LONG(ProtocolChecksumDelta, ~TcpHeader->SequenceNumber);

            //
            // Store new sequence number
            //

            TcpHeader->SequenceNumber =
                RtlUlongByteSwap(TcpHeader->SequenceNumber) +
                Mapping->TcpSeqNumDelta[XLATE_POSITIVE];
            TcpHeader->SequenceNumber =
                RtlUlongByteSwap(TcpHeader->SequenceNumber);

            //
            // Add in new sequence number
            //

            CHECKSUM_LONG(ProtocolChecksumDelta, TcpHeader->SequenceNumber);
        }

        //
        // The editor may have just modified the packet-size.
        // Pick up any sequence-number delta it set for us,
        // and update the basis of the new sequence-number delta
        // in the sequence-number space
        //

        if (Contextp->TcpSeqNumDelta) {
            Mapping->TcpSeqNumBase[XLATE_POSITIVE] =
                Mapping->TcpSeqNumExpected[XLATE_POSITIVE];
            Mapping->TcpSeqNumDelta[XLATE_POSITIVE] +=
                Contextp->TcpSeqNumDelta;
        }

        //
        // Adjust the ACK numbers
        //

        if (!TCP_FLAG(TcpHeader, ACK)) {
            KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
        }
        else {
    
            if (!Mapping->TcpSeqNumDelta[XLATE_NEGATIVE]) {
                KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
            }
            else {
    
                //
                // Update the checksum (see RFC 1624)
                //
                // Take old ACK number out of checksum
                //
    
                CHECKSUM_LONG(ProtocolChecksumDelta, ~TcpHeader->AckNumber);
    
                //
                // Store new ACK number (note we *subtract* the delta)
                //
    
                TcpHeader->AckNumber =
                    RtlUlongByteSwap(TcpHeader->AckNumber) -
                    Mapping->TcpSeqNumDelta[XLATE_NEGATIVE];
    
                KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
    
                TcpHeader->AckNumber = RtlUlongByteSwap(TcpHeader->AckNumber);
    
                //
                // Add new ACK number to checksum
                //
    
                CHECKSUM_LONG(ProtocolChecksumDelta, TcpHeader->AckNumber);
            }
        }
    }

    //
    // Update the IP and protocol headers with the translated address/port
    //

    NAT_TRANSLATE_HEADER();

    //
    // Now add the checksum-delta incurred by changes to the IP header
    //

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);

    if (!Contextp->ChecksumOffloaded) {

        IpChecksumDelta += Mapping->IpChecksumDelta[XLATE_POSITIVE];
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
        
        if (!NAT_XLATE_EDITED(Contextp)) {
            ProtocolChecksumDelta += Mapping->ProtocolChecksumDelta[XLATE_POSITIVE];
            CHECKSUM_FOLD(ProtocolChecksumDelta);
            CHECKSUM_XFER(TcpHeader->Checksum, ProtocolChecksumDelta);
        }
        else {

            //
            // NatEditorEditSession was called on the packet;
            // Completely recompute the TCP checksum.
            //
            
            NatComputeTcpChecksum(
                IpHeader,
                (PTCP_HEADER)Contextp->ProtocolHeader,
                Contextp->ProtocolRecvBuffer
                );
        }
        
    } else {

        //
        // Compute the IP and TCP checksums
        //

        NatComputeIpChecksum(IpHeader);
        NatComputeTcpChecksum(
            IpHeader,
            (PTCP_HEADER)Contextp->ProtocolHeader,
            Contextp->ProtocolRecvBuffer
            );
    }

    if (NAT_MAPPING_CLEAR_DF_BIT(Mapping) &&
        (IpHeader->OffsetAndFlags & IP_DF_FLAG)) {

        //
        // Clear the DF bit from this packet and adjust the IP
        // checksum accordingly.
        //

        IpHeader->OffsetAndFlags &= ~IP_DF_FLAG;

        CHECKSUM_XFER(IpChecksumDelta, IpHeader->Checksum);
        IpChecksumDelta += ~IP_DF_FLAG;
        CHECKSUM_FOLD(IpChecksumDelta);
        CHECKSUM_XFER(IpHeader->Checksum, IpChecksumDelta);
    }

    //
    // Check if need to adjust MSS options in TCP SYNs
    //

    if (TCP_FLAG(TcpHeader, SYN) && (Mapping->MaxMSS > 0)) {
        NatAdjustMSSOption(Contextp, Mapping->MaxMSS);
    } 


    //
    // Now we need to update the connection state for the sender
    // based on the flags in the packet:
    //
    // When a RST is seen, we close both ends of the connection.
    // As each FIN is seen, we mark the mapping appropriately.
    // When both FINs have been seen, we mark the mapping for deletion.
    //

    if (IsReset) {
        NatExpireMapping(Mapping);
    }
    else
    if (TCP_FLAG(TcpHeader, FIN)) {
        Mapping->Flags |= NAT_TRANSLATE_FIN;
        if (NAT_MAPPING_FIN(Mapping)) {
            NatExpireMapping(Mapping);
        }
    }

    //
    // Update the mapping's statistics and timestamp
    //

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        TCP_DATA_OFFSET(TcpHeader)
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically), and indicate the change
    // by invalidating 'DestinationType'
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    *Contextp->DestinationType = DEST_INVALID;
    return FORWARD;

} // NAT_TRANSLATE_TCP_RESIZE


FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_TCP_NULL(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    PIP_HEADER IpHeader = Contextp->Header;

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);

    //
    // Perform state validation for inbound mappings.
    //

    if (NAT_MAPPING_INBOUND(Mapping)
        && DROP == NAT_TRANSLATE_TCP_STATE_CHECK(
                    Mapping,
                    ((PTCP_HEADER)Contextp->ProtocolHeader)
                    )) {
                    
        KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);
        return DROP;
    } else if (TCP_FLAG(((PTCP_HEADER)Contextp->ProtocolHeader), SYN)) {

        //
        // Record that we've seen a SYN in this direction
        //

        Mapping->Flags |= NAT_TRANSLATE_SYN;
    }
    
    //
    // Now we need to update the connection state for the sender
    // based on the flags in the packet:
    //
    // When a RST is seen, we close both ends of the connection.
    // As each FIN is seen, we mark the mapping appropriately.
    // When both FINs have been seen, we mark the mapping for deletion.
    //

    
    if (TCP_FLAG(((PTCP_HEADER)Contextp->ProtocolHeader), RST)) {
        NatExpireMapping(Mapping);
    }
    else
    if (TCP_FLAG(((PTCP_HEADER)Contextp->ProtocolHeader), FIN)) {
        Mapping->Flags |= NAT_TRANSLATE_FIN;
        if (NAT_MAPPING_FIN(Mapping)) {
            NatExpireMapping(Mapping);
        }
    }

    //
    // Update the mapping's timestamp and statistics 
    //

    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        TCP_DATA_OFFSET(((PTCP_HEADER)Contextp->ProtocolHeader))
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically).
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    return FORWARD;

} // NAT_TRANSLATE_TCP_NULL


FORWARD_ACTION
FASTCALL
NAT_TRANSLATE_UDP_NULL(
    PNAT_DYNAMIC_MAPPING Mapping,
    PNAT_XLATE_CONTEXT Contextp,
    IPRcvBuf** InReceiveBuffer,
    IPRcvBuf** OutReceiveBuffer
    )
{
    PIP_HEADER IpHeader = Contextp->Header;
    PUDP_HEADER UdpHeader = (PUDP_HEADER)Contextp->ProtocolHeader;

    //
    // Unidirectional flows require that reverse packets be dropped;
    // This is primarily to support H.323 proxy.
    // 

    NAT_DROP_IF_UNIDIRECTIONAL();

    //
    // Update the mapping's statistics and timestamp
    //

    KeAcquireSpinLockAtDpcLevel(&Mapping->Lock);
    KeQueryTickCount((PLARGE_INTEGER)&Mapping->LastAccessTime);
    KeReleaseSpinLockFromDpcLevel(&Mapping->Lock);

    InterlockedExchangeAdd(
        &Mapping->BYTE_COUNT,
        NTOHS(IpHeader->TotalLength) -
        IP_DATA_OFFSET(IpHeader) -
        sizeof(UDP_HEADER)
        );
    InterlockedIncrement(&Mapping->PACKET_COUNT);

    //
    // Resplay the mapping (periodically).
    //

    NatTryToResplayMapping(Mapping, XLATE_POSITIVE);
    return FORWARD;

} // NAT_TRANSLATE_UDP_NULL


#undef XLATE_FORWARD
#undef XLATE_REVERSE
#undef XLATE_POSITIVE
#undef XLATE_NEGATIVE
#undef NAT_TRANSLATE_TCP
#undef NAT_TRANSLATE_UDP
#undef NAT_TRANSLATE_TCP_EDIT
#undef NAT_TRANSLATE_UDP_EDIT
#undef NAT_TRANSLATE_TCP_RESIZE
#undef NAT_TRANSLATE_TCP_NULL
#undef NAT_TRANSLATE_UDP_NULL
#undef NAT_TRANSLATE_SYN
#undef NAT_TRANSLATE_FIN
#undef NAT_TRANSLATE_TCP_STATE_CHECK
#undef DATA_HANDLER
#undef BYTE_COUNT
#undef PACKET_COUNT
#undef REJECT_COUNT
#undef NAT_TRANSLATE_HEADER
#undef NAT_DROP_IF_UNIDIRECTIONAL

#endif // XLATE_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\direct\direct.c ===
/*++

Module Name:

    director.c

Abstract:

    This module implements a driver which demonstrates the use of
    the IP NAT's support for directing incoming sessions.

    The driver reads a protocol, port and server-list from its 'Parameters'
    subkey, and directs all sessions on the specified protocol and port
    to the servers in the list, in a round-robin fashion.

    The expected registry configuration is as follows:

        IPNATDIR\Parameters
            ServerProtocol  REG_DWORD       0x6 (TCP) or 0x11 (UDP)
            ServerPort      REG_DWORD       1-65535
            ServerList      REG_MULTI_SZ    List of dotted-decimal IP addresses.

Author:

    Abolade Gbadegesin (aboladeg)   16-Feb-1998

Revision History:

--*/

#include <ntddk.h>
#include <ipnat.h>

#define NT_DEVICE_NAME      L"\\Device\\IPNATDIR"
#define DOS_DEVICE_NAME     L"\\DosDevices\\IPNATDIR"
#define ULONG_CHAR_LIST(a) \
    ((a) & 0x000000FF), (((a) & 0x0000FF00) >> 8), \
    (((a) & 0x00FF0000) >> 16), (((a) & 0xFF000000) >> 24)
#define NTOHS(p)            ((((p) & 0xFF00) >> 8) | (((UCHAR)(p) << 8)))

typedef struct _SERVER_ENTRY {
    LIST_ENTRY Link;
    ULONG Address;
    ULONG SessionCount;
} SERVER_ENTRY, *PSERVER_ENTRY;

//
// GLOBAL DATA
//

IP_NAT_REGISTER_DIRECTOR DirRegisterDirector;
LIST_ENTRY DirServerList;
KSPIN_LOCK DirServerLock;
USHORT DirServerPort = NTOHS(1000);
UCHAR DirServerProtocol = NAT_PROTOCOL_TCP;

//
// FORWARD DECLARATIONS
//

NTSTATUS
DirCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DirClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DirOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
InetAddr(
    PWCHAR String
    );

NTSTATUS
DirRegister(
    VOID
    );

VOID
DirUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine implements the standard driver-entry for an NT driver.
    It is responsible for reading configuration from the registry,
    and registering our entrypoints with the NAT driver.

Arguments:

    DriverObject - object to be initialized with NT driver entrypoints

    RegistryPath - contains path to this driver's registry key

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    PDEVICE_OBJECT DeviceObject = NULL;
    UNICODE_STRING NtDeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ServiceKey;
    NTSTATUS status;
    UNICODE_STRING Win32DeviceName;

    KdPrint(("DirDriverEntry\n"));

    InitializeListHead(&DirServerList);
    KeInitializeSpinLock(&DirServerLock);

    //
    // Create the device object
    //

    RtlInitUnicodeString(&NtDeviceName, NT_DEVICE_NAME);
    status =
        IoCreateDevice(
            DriverObject,
            0,
            &NtDeviceName,
            FILE_DEVICE_UNKNOWN,
            0,
            TRUE,
            &DeviceObject
            );
    if (!NT_SUCCESS(status)) {
        KdPrint(("DirDriverEntry: IoCreateDevice=%08x\n", status));
        return status;
    }

    //
    // Create dispatch points for create/open, close, unload.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = DirOpen;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DirCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DirClose;
    DriverObject->DriverUnload = DirUnload;

    //
    // Create counted string version of our Win32 device name.
    //

    RtlInitUnicodeString(&Win32DeviceName, DOS_DEVICE_NAME);

    //
    // Create a link from our device name to a name in the Win32 namespace.
    //
    
    status = IoCreateSymbolicLink(&Win32DeviceName, &NtDeviceName);

    if (!NT_SUCCESS(status)) {
        KdPrint(("DirDriverEntry: IoCreateSymbolLink=%08x\n", status));
        IoDeleteDevice(DriverObject->DeviceObject);
        return status;
    }

    //
    // Read registry configuration, if any.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status = ZwOpenKey(&ServiceKey, KEY_READ, &ObjectAttributes);
    if (NT_SUCCESS(status)) {
        HANDLE Key;
        UNICODE_STRING UnicodeString;
        RtlInitUnicodeString(&UnicodeString, L"Parameters");
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            ServiceKey,
            NULL
            );
        status = ZwOpenKey(&Key, KEY_READ, &ObjectAttributes);
        ZwClose(ServiceKey);
        if (NT_SUCCESS(status)) {
            UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 32];
            ULONG Length;
            PKEY_VALUE_PARTIAL_INFORMATION Value =
                (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
            //
            // Read the protocol name
            //
            RtlInitUnicodeString(&UnicodeString, L"ServerProtocol");
            status =
                ZwQueryValueKey(
                    Key,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                    sizeof(Buffer),
                    &Length
                    );
            if (NT_SUCCESS(status)) {
                if (_wcsicmp((PWCHAR)Value->Data, L"UDP") == 0) {
                    DirServerPort = NAT_PROTOCOL_UDP;
                    KdPrint(("DirDriverEntry: read protocol UDP\n"));
                } else {
                    DirServerPort = NAT_PROTOCOL_TCP;
                    KdPrint(("DirDriverEntry: read protocol TCP\n"));
                }
            }
            //
            // Read the destination port
            //
            RtlInitUnicodeString(&UnicodeString, L"ServerPort");
            status =
                ZwQueryValueKey(
                    Key,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                    sizeof(Buffer),
                    &Length
                    );
            if (NT_SUCCESS(status)) {
                DirServerPort = (USHORT)*(PULONG)Value->Data;
                KdPrint(("DirDriverEntry: read port %d\n", DirServerPort));
                DirServerPort = NTOHS(DirServerPort);
            }
            //
            // Read the list of servers
            //
            RtlInitUnicodeString(&UnicodeString, L"ServerList");
            status =
                ZwQueryValueKey(
                    Key,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                    sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                    &Length
                    );
            if (status == STATUS_BUFFER_OVERFLOW) {
                Value = ExAllocatePool(PagedPool, Length);
                if (Value) {
                    status =
                        ZwQueryValueKey(
                            Key,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            Value,
                            Length,
                            &Length
                            );
                    if (NT_SUCCESS(status)) {
                        //
                        // Parse the server-list
                        //
                        PWCHAR String;
                        PSERVER_ENTRY Entry;
                        for (String = (PWCHAR)Value->Data;
                             String[0];
                             String += wcslen(String) + 1
                             ) {
                            KdPrint(("DirDriverEntry: read %ls\n", String));
                            Entry = ExAllocatePool(PagedPool, sizeof(*Entry));
                            if (!Entry) { continue; }
                            Entry->Address = InetAddr(String);
                            if (!Entry->Address) {
                                ExFreePool(Entry);
                            } else {
                                Entry->SessionCount = 0;
                                InsertTailList(&DirServerList, &Entry->Link);
                            }
                        }
                    }
                    ExFreePool(Value);
                }
            }
        }
    }

    //
    // Register with the NAT
    //

    return DirRegister();
}


NTSTATUS
DirCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KdPrint(("DirCleanup\n"));
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
DirClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KdPrint(("DirClose\n"));
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
DirOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KdPrint(("DirOpen\n"));
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
DirpCreateHandler(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext
    )

/*++

Routine Description:

    This routine is invoked by the NAT when a session-mapping is successfully
    created after a query has been made.
    All we do here is increment the count of active sessions.

Arguments:

    SessionHandle - opaquely identifies the new session

    DirectorContext - our director-object context

    DirectorSessionContext - our session-mapping context

Return Value:

    STATUS_SUCCESS.

--*/

{
    PSERVER_ENTRY ServerEntry = (PSERVER_ENTRY)DirectorSessionContext;
    KdPrint((
        "DirCreateHandler: %d.%d.%d.%d [SessionCount=%d]\n",
        ULONG_CHAR_LIST(ServerEntry->Address),
        InterlockedIncrement(&ServerEntry->SessionCount)
        ));
    return STATUS_SUCCESS;
}


NTSTATUS
DirpDeleteHandler(
    IN PVOID SessionHandle,
    IN PVOID DirectorContext,
    IN PVOID DirectorSessionContext,
    IN IP_NAT_DELETE_REASON DeleteReason
    )

/*++

Routine Description:

    This routine is invoked by the NAT in the following cases:
    (a) when a session-mapping is deleted (SessionHandle != NULL)
    (b) when a session-mapping cannot be created using the information
    supplied by previous call to 'QueryHandler' (SessionHandle == NULL).

Arguments:

    SessionHandle - identifies the failed session

    DirectorContext - our director-object context

    DirectorSessionContext - our session-mapping context

    DeleteReason - the cause for session deletion

Return Value:

    STATUS_SUCCESS

--*/

{
    PSERVER_ENTRY ServerEntry = (PSERVER_ENTRY)DirectorSessionContext;
    ULONG SessionCount =
        SessionHandle
            ? InterlockedDecrement(&ServerEntry->SessionCount)
            : ServerEntry->SessionCount;
    KdPrint((
        "DirDeleteHandler: %d.%d.%d.%d [SessionCount=%d]\n",
        ULONG_CHAR_LIST(ServerEntry->Address),
        SessionCount
        ));
    return STATUS_SUCCESS;
}


NTSTATUS
DirpQueryHandler(
    PIP_NAT_DIRECTOR_QUERY DirectorQuery
    )

/*++

Routine Description:

    This routine is invoked by the NAT to determine whether a change
    should be made to an incoming packet which matches the protocol
    and port for which we are registered as a director.

    On input, 'DirectorQuery' contains the packets source and destination
    endpoints as well as flags which provide further information.
    On output, 'DirectorQuery' may be filled with replacement information
    and flags may be modified to control the creation of a mapping
    for the packet's session.

Arguments:

    DirectorQuery - describes the session on input,
        filled with information for a mapping on output.

Return Value:

    NTSTATUS - indicates whether a mapping should be created.

--*/

{
    PSERVER_ENTRY Entry;
    KdPrint((
        "DirQueryHandler:protocol=%d,%d.%d.%d.%d/%d-%d.%d.%d.%d/%d\n",
        DirectorQuery->Protocol,
        ULONG_CHAR_LIST(DirectorQuery->DestinationAddress),
        NTOHS(DirectorQuery->DestinationPort),
        ULONG_CHAR_LIST(DirectorQuery->SourceAddress),
        NTOHS(DirectorQuery->SourcePort)
        ));
    KeAcquireSpinLockAtDpcLevel(&DirServerLock);
    if (IsListEmpty(&DirServerList)) {
        KeReleaseSpinLockFromDpcLevel(&DirServerLock);
        return STATUS_UNSUCCESSFUL;
    }
    //
    // Direct the session to the first server-entry on the list
    //
    Entry = CONTAINING_RECORD(DirServerList.Flink, SERVER_ENTRY, Link);
    DirectorQuery->DirectorSessionContext = Entry;
    DirectorQuery->NewDestinationAddress = Entry->Address;
    DirectorQuery->NewDestinationPort = DirectorQuery->DestinationPort;
    DirectorQuery->NewSourceAddress = DirectorQuery->SourceAddress;
    DirectorQuery->NewSourcePort = DirectorQuery->SourcePort;
    //
    // Move the server-entry to the end of the list
    //
    RemoveEntryList(&Entry->Link);
    InsertTailList(&DirServerList, &Entry->Link);
    KeReleaseSpinLockFromDpcLevel(&DirServerLock);
    return STATUS_SUCCESS;
}


VOID
DirpUnloadHandler(
    IN PVOID DirectorContext
    )

/*++

Routine Description:

    This routine is invoked by the NAT when the NAT driver is being unloaded.

Arguments:

    DirectorContext - the context for this driver (unused)

Return Value:

    none.

--*/

{
    KdPrint(("DirpUnloadHandler\n"));
    return;
}


NTSTATUS
DirRegister(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to register this driver with the NAT
    as a director for the configured protocol and port.

Arguments:

    none.

Return Status:

    NTSTATUS - indicates success/failure

--*/

{
    PDEVICE_OBJECT DeviceObject;
    UNICODE_STRING  DeviceString;
    KEVENT Event;
    PFILE_OBJECT FileObject;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    NTSTATUS status;

    KdPrint(("DirRegisterDirector\n"));

    //
    // Initialize the registration information
    //

    RtlZeroMemory(&DirRegisterDirector, sizeof(DirRegisterDirector));
    DirRegisterDirector.Version = IP_NAT_VERSION;
    DirRegisterDirector.Protocol = NAT_PROTOCOL_TCP;
    DirRegisterDirector.Port = DirServerPort;
    DirRegisterDirector.CreateHandler = DirpCreateHandler;
    DirRegisterDirector.DeleteHandler = DirpDeleteHandler;
    DirRegisterDirector.QueryHandler = DirpQueryHandler;

    //
    // Retrieve a pointer to the NAT device object
    //

    RtlInitUnicodeString(&DeviceString, DD_IP_NAT_DEVICE_NAME);
    status =
        IoGetDeviceObjectPointer(
            &DeviceString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &FileObject,
            &DeviceObject
            );
    if (!NT_SUCCESS(status)) { return status; }

    //
    // Create an IRP and use it to register with the NAT
    //

    ObReferenceObject(DeviceObject);
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
    Irp =
        IoBuildDeviceIoControlRequest(
            IOCTL_IP_NAT_REGISTER_DIRECTOR,
            DeviceObject,
            (PVOID)&DirRegisterDirector,
            sizeof(DirRegisterDirector),
            (PVOID)&DirRegisterDirector,
            sizeof(DirRegisterDirector),
            FALSE,
            &Event,
            &IoStatus
            );
    if (!Irp) {
        status = STATUS_UNSUCCESSFUL;
    } else {
        status = IoCallDriver(DeviceObject, Irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            status = IoStatus.Status;
        }
    }

    ObDereferenceObject((PVOID)FileObject);
    ObDereferenceObject(DeviceObject);
    return status;

} // DirRegisterDirector


VOID
DirUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is invoked by the I/O manager to unload this driver.

Arguments:

    DriverObject - the object for this driver

Return Value:

    none.

--*/

{
    PSERVER_ENTRY Entry;
    UNICODE_STRING Win32DeviceName;
    KdPrint(("DirUnload\n"));

    //
    // Deregister with the NAT, and cleanup our list of servers
    //

    DirRegisterDirector.Deregister(DirRegisterDirector.DirectorHandle);

    while (!IsListEmpty(&DirServerList)) {
        Entry = CONTAINING_RECORD(DirServerList.Flink, SERVER_ENTRY, Link);
        RemoveEntryList(&Entry->Link);
        ExFreePool(Entry);
    }

    //
    // Delete the link from our device name to a name in the Win32 namespace,
    // and delete our device object
    //

    RtlInitUnicodeString(&Win32DeviceName, DOS_DEVICE_NAME);
    IoDeleteSymbolicLink(&Win32DeviceName);
    IoDeleteDevice( DriverObject->DeviceObject );
}


ULONG
InetAddr(
    PWCHAR String
    )
{
    ULONG Digit;
    ULONG Fields[4] = {0, 0, 0, 0};
    ULONG i = 0;
    for (Digit = (*String - L'0');
         Digit <= 9 && i < 4;
         Digit = (*String - L'0')
         ) {
        Fields[i] = Fields[i] * 10 + Digit;
        if (*(++String) == L'.') { ++i; ++String; }
    }
    if (*String != L'\0' ||
        i != 3 ||
        Fields[0] > 255 ||
        Fields[1] > 255 ||
        Fields[2] > 255 ||
        Fields[3] > 255
        ) {
        return 0;
    }
    return
        (Fields[0]) |
        (Fields[1] << 8) |
        (Fields[2] << 16) |
        (Fields[3] << 24);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\timer.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module:

    timer.h

Abstract:

    Contains declarations for the NAT's timer DPC routine,
    which is responsible for garbage-collecting expired mappings.

Author:

    Abolade Gbadegesin (t-abolag)   22-July-1997

Revision History:

--*/

#ifndef _NAT_TIMER_H_
#define _NAT_TIMER_H_

//
// Macro used to convert from seconds to tick-count units
//

#define SECONDS_TO_TICKS(s) \
    ((LONG64)(s) * 10000000 / TimeIncrement)

#define TICKS_TO_SECONDS(t) \
    ((LONG64)(t) * TimeIncrement / 10000000)

extern ULONG TimeIncrement;

VOID
NatInitializeTimerManagement(
    VOID
    );

VOID
NatShutdownTimerManagement(
    VOID
    );

VOID
NatStartTimer(
    VOID
    );

VOID
NatStopTimer(
    VOID
    );

VOID
NatTriggerTimer(
    VOID
    );

#endif // _NAT_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\ticket.c ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    ticket.c

Abstract:

    This module contains code for the NAT's ticket-management.

Author:

    Abolade Gbadegesin (t-abolag)   22-Aug-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG DynamicTicketCount;
LIST_ENTRY DynamicTicketList;
KSPIN_LOCK DynamicTicketLock;
ULONG TicketCount;


NTSTATUS
NatCreateDynamicTicket(
    PIP_NAT_CREATE_DYNAMIC_TICKET CreateTicket,
    ULONG InputBufferLength,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to create a dynamically-activated ticket
    in response to an 'IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET' request.

Arguments:

    CreateTicket - describes the dynamic ticket to be created

    InputBufferLength - the length of the buffer specified by 'CreateTicket'

    FileObject - file-object with which to associate the dynamic ticket

Return Value:

    NTSTATUS - status code.

--*/

{
    PLIST_ENTRY InsertionPoint;
    ULONG i;
    KIRQL Irql;
    ULONG Key;
    ULONG ResponseArrayLength;
    PNAT_DYNAMIC_TICKET Ticket;
    CALLTRACE(("NatCreateDynamicTicket\n"));

    //
    // Validate the parameters.
    //

    if ((CreateTicket->Protocol != NAT_PROTOCOL_TCP &&
         CreateTicket->Protocol != NAT_PROTOCOL_UDP) || !CreateTicket->Port) {
        return STATUS_INVALID_PARAMETER;
    } else if (CreateTicket->ResponseCount >
                MAXLONG / sizeof(CreateTicket->ResponseArray[0])) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    ResponseArrayLength =
        CreateTicket->ResponseCount *
        sizeof(CreateTicket->ResponseArray[0]) +
        FIELD_OFFSET(IP_NAT_CREATE_DYNAMIC_TICKET, ResponseArray);
    if (InputBufferLength < ResponseArrayLength) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    for (i = 0; i < CreateTicket->ResponseCount; i++) {
        if ((CreateTicket->ResponseArray[i].Protocol != NAT_PROTOCOL_TCP &&
            CreateTicket->ResponseArray[i].Protocol != NAT_PROTOCOL_UDP) ||
            !CreateTicket->ResponseArray[i].StartPort ||
            !CreateTicket->ResponseArray[i].EndPort ||
            NTOHS(CreateTicket->ResponseArray[i].StartPort) >
            NTOHS(CreateTicket->ResponseArray[i].EndPort)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Construct a key and search for a duplicate
    //

    Key = MAKE_DYNAMIC_TICKET_KEY(CreateTicket->Protocol, CreateTicket->Port);
    KeAcquireSpinLock(&DynamicTicketLock, &Irql);
    if (NatLookupDynamicTicket(Key, &InsertionPoint)) {
        KeReleaseSpinLock(&DynamicTicketLock, Irql);
        TRACE(TICKET, ("NatCreateDynamicTicket: collision %08X\n", Key));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate and initialize the new dynamic ticket
    //

    Ticket =
        ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(NAT_DYNAMIC_TICKET) + ResponseArrayLength,
            NAT_TAG_DYNAMIC_TICKET
            );
    if (!Ticket) {
        KeReleaseSpinLock(&DynamicTicketLock, Irql);
        ERROR(("NatCreateTicket: ticket could not be allocated\n"));
        return STATUS_NO_MEMORY;
    }

    Ticket->Key = Key;
    Ticket->FileObject = FileObject;
    Ticket->ResponseCount = CreateTicket->ResponseCount;
    Ticket->ResponseArray = (PVOID)(Ticket + 1);
    for (i = 0; i < CreateTicket->ResponseCount; i++) {
        Ticket->ResponseArray[i].Protocol =
            CreateTicket->ResponseArray[i].Protocol;
        Ticket->ResponseArray[i].StartPort =
            CreateTicket->ResponseArray[i].StartPort;
        Ticket->ResponseArray[i].EndPort =
            CreateTicket->ResponseArray[i].EndPort;
    }
    InsertTailList(InsertionPoint, &Ticket->Link);

    KeReleaseSpinLock(&DynamicTicketLock, Irql);
    InterlockedIncrement(&DynamicTicketCount);
    return STATUS_SUCCESS;

} // NatCreateDynamicTicket


NTSTATUS
NatCreateTicket(
    PNAT_INTERFACE Interfacep,
    UCHAR Protocol,
    ULONG PrivateAddress,
    USHORT PrivateOrEndPort,
    ULONG RemoteAddress OPTIONAL,
    ULONG RemotePort OPTIONAL,
    ULONG Flags,
    PNAT_USED_ADDRESS AddressToUse OPTIONAL,
    USHORT PortToUse OPTIONAL,
    PULONG PublicAddress,
    PUSHORT PublicPort
    )

/*++

Routine Description:

    This routine allocates and initializes a NAT ticket to allow a single
    inbound session to be established using 'Protocol'. The routine acquires
    an address and port to be advertised as the publicly-visible endpoint
    of the session, and sets the ticket to expire in 'TimeoutSeconds'.

Arguments:

    Interfacep - the interface on which the ticket is to be created

    Protocol - the protocol of the inbound session to be allowed

    PrivateAddress - the private address to which the inbound session
        should be directed when the ticket is used.

    PrivateOrEndPort - contains either
        (a) the private port to which the inbound session should be
        directed when the ticket is used, or
        (b) the end of a range of public ports which starts with 'PortToUse',
        if 'Flags' has 'NAT_TICKET_FLAG_IS_RANGE' set,
        in which case the *private* port to which the inbound session
        should be directed is determined when the ticket is used.

    Flags - the initial flags for the ticket;
        NAT_TICKET_FLAG_PERSISTENT - the ticket is reusable 
        NAT_TICKET_FLAG_PORT_MAPPING - the ticket is for a port-mapping
        NAT_TICKET_FLAG_IS_RANGE - the ticket is for a range of ports

    AddressToUse - optionally supplies the public address for the ticket

    PortToUse - if 'AddressToUse' is set, must supply the public-port

    PublicAddress - receives the public address assigned to the ticket.

    PublicPort - receives the public port assigned to the ticket.

Return Value:

    NTSTATUS - indicates success/failure.

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    PLIST_ENTRY InsertionPoint;
    ULONG64 Key;
    ULONG64 RemoteKey;
    NTSTATUS status;
    PNAT_TICKET Ticket;

    TRACE(TICKET, ("NatCreateTicket\n"));

    if (AddressToUse) {
        if (!NatReferenceAddressPoolEntry(AddressToUse)) {
            return STATUS_UNSUCCESSFUL;
        }
        *PublicAddress = AddressToUse->PublicAddress;
        *PublicPort = PortToUse;
    } else {

        //
        // Acquire a public address
        //
    
        status =
            NatAcquireFromAddressPool(
                Interfacep,
                PrivateAddress,
                0,
                &AddressToUse
                );
        if (!NT_SUCCESS(status)) { return status; }

        //
        // Acquire a unique public port
        //

        status =
            NatAcquireFromPortPool(
                Interfacep,
                AddressToUse,
                Protocol,
                PrivateOrEndPort,
                &PortToUse
                );

        if (!NT_SUCCESS(status)) {
            NatDereferenceAddressPoolEntry(Interfacep, AddressToUse);
            return status;
        }

        *PublicAddress = AddressToUse->PublicAddress;
        *PublicPort = PortToUse;
    }

    //
    // Look for a duplicate of the key
    //

    Key = MAKE_TICKET_KEY(Protocol, *PublicAddress, *PublicPort);
    RemoteKey = MAKE_TICKET_KEY(Protocol, RemoteAddress, RemotePort);
    if (NatLookupTicket(Interfacep, Key, RemoteKey, &InsertionPoint)) {
        //
        // Collision; fail
        //
        TRACE(TICKET, ("NatCreateTicket: collision %016I64X:%016I64X\n",
            Key, RemoteKey));
        NatDereferenceAddressPoolEntry(Interfacep, AddressToUse);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate and initialize the ticket
    //

    Ticket = ALLOCATE_TICKET_BLOCK();
    if (!Ticket) {
        ERROR(("NatCreateTicket: ticket could not be allocated\n"));
        NatDereferenceAddressPoolEntry(Interfacep, AddressToUse);
        return STATUS_NO_MEMORY;
    }

    Ticket->Key = Key;
    Ticket->RemoteKey = RemoteKey;
    Ticket->Flags = Flags;   
    Ticket->UsedAddress = AddressToUse;
    Ticket->PrivateAddress = PrivateAddress;
    if (NAT_TICKET_IS_RANGE(Ticket)) {
        Ticket->PrivateOrHostOrderEndPort = NTOHS(PrivateOrEndPort);
    } else {
        Ticket->PrivateOrHostOrderEndPort = PrivateOrEndPort;
    }
    InsertTailList(InsertionPoint, &Ticket->Link);
    KeQueryTickCount((PLARGE_INTEGER)&Ticket->LastAccessTime);

    InterlockedIncrement(&TicketCount);
    return STATUS_SUCCESS;

} // NatCreateTicket


VOID
NatDeleteAnyAssociatedDynamicTicket(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked when cleanup is in progress for a file-object
    opened for \Device\IpNat. It deletes any dynamic tickets associated with
    the file-object.

Arguments:

    FileObject - the file-object being cleaned up

Return Value:

    none.

--*/

{
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_TICKET Ticket;
    CALLTRACE(("NatDeleteAnyAssociatedDynamicTicket\n"));
    KeAcquireSpinLock(&DynamicTicketLock, &Irql);
    for (Link = DynamicTicketList.Flink; Link != &DynamicTicketList;
         Link = Link->Flink) {
        Ticket = CONTAINING_RECORD(Link, NAT_DYNAMIC_TICKET, Link);
        if (Ticket->FileObject != FileObject) { continue; }
        Link = Link->Blink;
        RemoveEntryList(&Ticket->Link);
        ExFreePool(Ticket);
        InterlockedDecrement(&DynamicTicketCount);
    }
    KeReleaseSpinLock(&DynamicTicketLock, Irql);
} // NatDeleteAnyAssociatedDynamicTicket


NTSTATUS
NatDeleteDynamicTicket(
    PIP_NAT_DELETE_DYNAMIC_TICKET DeleteTicket,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked when an 'IOCTL_IP_DELETE_DYNAMIC_TICKET' request
    is issued to delete a dynamic ticket.

Arguments:

    DeleteTicket - specifies the ticket to be deleted

    FileObject - specifies the file-object in which the request was issued

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    PLIST_ENTRY InsertionPoint;
    KIRQL Irql;
    ULONG Key;
    PNAT_DYNAMIC_TICKET Ticket;
    CALLTRACE(("NatDeleteDynamicTicket\n"));

    Key = MAKE_DYNAMIC_TICKET_KEY(DeleteTicket->Protocol, DeleteTicket->Port);
    KeAcquireSpinLock(&DynamicTicketLock, &Irql);
    if (!(Ticket = NatLookupDynamicTicket(Key, &InsertionPoint))) {
        KeReleaseSpinLock(&DynamicTicketLock, Irql);
        return STATUS_UNSUCCESSFUL;
    } else if (Ticket->FileObject != FileObject) {
        KeReleaseSpinLock(&DynamicTicketLock, Irql);
        return STATUS_ACCESS_DENIED;
    }

    RemoveEntryList(&Ticket->Link);
    ExFreePool(Ticket);
    KeReleaseSpinLock(&DynamicTicketLock, Irql);
    InterlockedDecrement(&DynamicTicketCount);
    return STATUS_SUCCESS;
    
} // NatDeleteDynamicTicket


VOID
NatDeleteTicket(
    PNAT_INTERFACE Interfacep,
    PNAT_TICKET Ticket
    )

/*++

Routine Description:

    This routine is called to delete a NAT ticket.

Arguments:

    Interfacep - the ticket's interface

    Ticket - the ticket to be deleted

Return Value:

    none.

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    InterlockedDecrement(&TicketCount);
    RemoveEntryList(&Ticket->Link);
    NatDereferenceAddressPoolEntry(Interfacep, Ticket->UsedAddress);
    FREE_TICKET_BLOCK(Ticket);

} // NatDeleteTicket


VOID
NatInitializeDynamicTicketManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize state used for managing
    dynamic tickets.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NatInitializeDynamicTicketManagement\n"));
    InitializeListHead(&DynamicTicketList);
    KeInitializeSpinLock(&DynamicTicketLock);
    DynamicTicketCount = 0;
} // NatInitializeDynamicTicketManagement


BOOLEAN
NatIsPortUsedByTicket(
    PNAT_INTERFACE Interfacep,
    UCHAR Protocol,
    USHORT PublicPort
    )

/*++

Routine Description:

    This routine searches the interface's ticket-list to see if the given port
    is in use as the public port of any ticket.

Arguments:

    Interfacep - the interface whose ticket list is to be searched

    Protocol - indicates either TCP or UDP

    PublicPort - the port for which to search

Return Value:

    BOOLEAN - TRUE if the port is in use, FALSE otherwise

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    USHORT HostOrderPort;
    ULONG64 Key;
    PNAT_TICKET Ticket;

    TRACE(TICKET, ("NatIsPortUsedByTicket\n"));

    HostOrderPort = NTOHS(PublicPort);
    Key = MAKE_TICKET_KEY(Protocol, 0, PublicPort);
    for (Link = Interfacep->TicketList.Flink; Link != &Interfacep->TicketList;
         Link = Link->Flink) {
        Ticket = CONTAINING_RECORD(Link, NAT_TICKET, Link);
        if (NAT_TICKET_IS_RANGE(Ticket)) {
            if (HostOrderPort > Ticket->PrivateOrHostOrderEndPort) {
                continue;
            } else if (HostOrderPort < NTOHS(TICKET_PORT(Ticket->Key))) {
                continue;
            }
        } else if (Key != (Ticket->Key & MAKE_TICKET_KEY(~0,0,~0))) {
            continue;
        }
        return TRUE;
    }
    return FALSE;
} // NatIsPortUsedByTicket


VOID
NatLookupAndApplyDynamicTicket(
    UCHAR Protocol,
    USHORT DestinationPort,
    PNAT_INTERFACE Interfacep,
    ULONG PublicAddress,
    ULONG PrivateAddress
    )

/*++

Routine Description:

    This routine is invoked to determine whether there is a dynamic ticket
    which should be activated for the given outbound session.

Arguments:

    Protocol - the protocol of the outbound session

    DestinationPort - the destination port of the outbound session

    Interfacep - the interface across which the outbound session
        will be translated

    PublicAddress - the public address used by the outbound session's mapping

    PrivateAddress - the private address of the outbound session's mapping

Return Value:

    none.

Environment:

    Invoked at dispatch level with neither 'Interfacep->Lock' nor
    'DynamicTicketLock' held by the caller.

--*/

{
    PNAT_USED_ADDRESS AddressToUse;
    ULONG i;
    ULONG Key;
    USHORT PublicPort;
    NTSTATUS status;
    PNAT_DYNAMIC_TICKET Ticket;

    Key = MAKE_DYNAMIC_TICKET_KEY(Protocol, DestinationPort);
    KeAcquireSpinLockAtDpcLevel(&DynamicTicketLock);
    if (!(Ticket = NatLookupDynamicTicket(Key, NULL))) {
        KeReleaseSpinLockFromDpcLevel(&DynamicTicketLock);
        return;
    }

    KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);
    for (i = 0; i < Ticket->ResponseCount; i++) {
        status =
            NatAcquireFromAddressPool(
                Interfacep,
                PrivateAddress,
                0,
                &AddressToUse
                );
        if (NT_SUCCESS(status)) {
            NatCreateTicket(
                Interfacep,
                Ticket->ResponseArray[i].Protocol,
                PrivateAddress,
                Ticket->ResponseArray[i].EndPort,
                0,
                0,
                NAT_TICKET_FLAG_IS_RANGE,
                AddressToUse,
                Ticket->ResponseArray[i].StartPort,
                &PublicAddress,
                &PublicPort
                );
        }
    }
    KeReleaseSpinLockFromDpcLevel(&Interfacep->Lock);
    KeReleaseSpinLockFromDpcLevel(&DynamicTicketLock);
} // NatLookupAndApplyDynamicTicket


NTSTATUS
NatLookupAndDeleteTicket(
    PNAT_INTERFACE Interfacep,
    ULONG64 Key,
    ULONG64 RemoteKey
    )

/*++

Routine Description:

    This routine looks for a ticket with the specified key and, if found,
    removes and deallocates the ticket after releasing its address and port.

Arguments:

    Interfacep - the interface on which to look for the ticket

    Key - the ticket to look for

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    PNAT_TICKET Ticket;

    TRACE(TICKET, ("NatLookupAndDeleteTicket\n"));

    //
    // Look for the ticket
    //

    Ticket = NatLookupTicket(Interfacep, Key, RemoteKey, NULL);
    if (Ticket) {
        NatDeleteTicket(Interfacep, Ticket);
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;

} // NatLookupAndDeleteTicket


NTSTATUS
NatLookupAndRemoveTicket(
    PNAT_INTERFACE Interfacep,
    ULONG64 Key,
    ULONG64 RemoteKey,
    PNAT_USED_ADDRESS* UsedAddress,
    PULONG PrivateAddress,
    PUSHORT PrivatePort
    )

/*++

Routine Description:

    This routine looks for a ticket with the specified key and, if found,
    removes and deallocates the ticket after storing the private address/port
    for the ticket in the caller's arguments.

Arguments:

    Interfacep - the interface on which to look for the ticket

    Key - the public key of the ticket to look for

    UsedAddress - receives a pointer to the public-address used by the ticket

    PrivateAddress - receives the address to which the ticket grants access

    PrivatePort - receives the port to which the ticket grants access

Return Value:

    NTSTATUS - indicates success/failure

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    USHORT HostOrderPort;
    PNAT_TICKET Ticket;
    ULONG RemoteAddress;
    USHORT RemotePort;

    TRACE(PER_PACKET, ("NatLookupAndRemoveTicket\n"));

    //
    // Look for the ticket.
    //

    HostOrderPort = NTOHS(TICKET_PORT(Key));
    for (Link = Interfacep->TicketList.Flink; Link != &Interfacep->TicketList;
         Link = Link->Flink) {
        Ticket = CONTAINING_RECORD(Link, NAT_TICKET, Link);
        if (NAT_TICKET_IS_RANGE(Ticket)) {
            if (HostOrderPort > Ticket->PrivateOrHostOrderEndPort) {
                continue;
            } else if (HostOrderPort < NTOHS(TICKET_PORT(Ticket->Key))) {
                continue;
            }
        } else if (Key != Ticket->Key) {
            continue;
        }

        //
        // Primary key matches, also need to check remote key.
        //

        if (RemoteKey != Ticket->RemoteKey) {

            //
            // Handle cases where remote key wasn't specified
            //

            RemoteAddress = TICKET_ADDRESS(Ticket->RemoteKey);
            if (RemoteAddress != 0
                && RemoteAddress != TICKET_ADDRESS(RemoteKey)) {
                continue;
            }

            RemotePort = TICKET_PORT(Ticket->RemoteKey);
            if (RemotePort != 0
                && RemotePort != TICKET_PORT(RemoteKey)) {
                continue;
            }
        }

        //
        // This is the ticket
        //

        *UsedAddress = Ticket->UsedAddress;
        *PrivateAddress = Ticket->PrivateAddress;
        if (NAT_TICKET_IS_RANGE(Ticket)) {
            *PrivatePort = TICKET_PORT(Key);
        } else {
            *PrivatePort = Ticket->PrivateOrHostOrderEndPort;
        }

        if (!NAT_TICKET_PERSISTENT(Ticket)) {
            InterlockedDecrement(&TicketCount);
            RemoveEntryList(&Ticket->Link);
            FREE_TICKET_BLOCK(Ticket);
        } else {

            //
            // Reference the ticket's address again for the next use
            //

            NatReferenceAddressPoolEntry(Ticket->UsedAddress);
        }

        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;

} // NatLookupAndRemoveTicket


PNAT_DYNAMIC_TICKET
NatLookupDynamicTicket(
    ULONG Key,
    PLIST_ENTRY *InsertionPoint
    )

/*++

Routine Description:

    This routine is invoked to look for a dynamic ticket with the given key.

Arguments:

    Key - the key for the dynamic ticket to be found

    InsertionPoint - if the ticket is not found, receives the insertion point

Return Value:

    PNAT_DYNAMIC_TICKET - the dynamic ticket, if found

Environment:

    Invoked with 'DynamicTicketLock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    PNAT_DYNAMIC_TICKET Ticket;
    TRACE(TICKET, ("NatLookupDynamicTicket\n"));

    for (Link = DynamicTicketList.Flink; Link != &DynamicTicketList;
         Link = Link->Flink) {
        Ticket = CONTAINING_RECORD(Link, NAT_DYNAMIC_TICKET, Link);
        if (Key > Ticket->Key) {
            continue;
        } else if (Key < Ticket->Key) {
            break;
        }
        return Ticket;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupDynamicTicket


PNAT_TICKET
NatLookupFirewallTicket(
    PNAT_INTERFACE Interfacep,
    UCHAR Protocol,
    USHORT Port
    )

/*++

Routine Description:

    This routine is invoked to look for a firewall ticket with the given
    protocol and port. A firewall ticket must:
    * have the same public and private address
    * have the same public and private port
    * be marked persistent
    * not be a range

Arguments:

    Interfacep - the interface on which to search for a ticket

    Protocol - the protocl for the ticket to be found

    Port - the port for the ticket to be found

Return Value:

    PNAT_TICKET - the ticket, if found

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    PNAT_TICKET Ticket;
    TRACE(TICKET, ("NatLookupFirewallTicket\n"));

    for (Link = Interfacep->TicketList.Flink; Link != &Interfacep->TicketList;
         Link = Link->Flink) {
        Ticket = CONTAINING_RECORD(Link, NAT_TICKET, Link);

        if (Protocol == TICKET_PROTOCOL(Ticket->Key)
            && Port == TICKET_PORT(Ticket->Key)
            && Port == Ticket->PrivateOrHostOrderEndPort
            && Ticket->PrivateAddress == TICKET_ADDRESS(Ticket->Key)
            && NAT_TICKET_PERSISTENT(Ticket)
            && !NAT_TICKET_IS_RANGE(Ticket)) {

            return Ticket;
        }
    }

    return NULL;    
} // NatLookupFirewallTicket


PNAT_TICKET
NatLookupTicket(
    PNAT_INTERFACE Interfacep,
    ULONG64 Key,
    ULONG64 RemoteKey,
    PLIST_ENTRY *InsertionPoint
    )

/*++

Routine Description:

    This routine is invoked to look for a ticket with the given key.

Arguments:

    Interfacep - the interface on which to search for a ticket

    Key - the key for the ticket to be found

    InsertionPoint - if the ticket is not found, receives the insertion point

Return Value:

    PNAT_TICKET - the ticket, if found

Environment:

    Invoked with 'Interfacep->Lock' held by the caller.

--*/

{
    PLIST_ENTRY Link;
    PNAT_TICKET Ticket;
    TRACE(TICKET, ("NatLookupTicket\n"));

    for (Link = Interfacep->TicketList.Flink; Link != &Interfacep->TicketList;
         Link = Link->Flink) {
        Ticket = CONTAINING_RECORD(Link, NAT_TICKET, Link);
        if (Key > Ticket->Key) {
            continue;
        } else if (Key < Ticket->Key) {
            break;
        }

        //
        // Primary keys match, check secondary.
        //

        if (RemoteKey > Ticket->RemoteKey) {
            continue;
        } else if (RemoteKey < Ticket->RemoteKey) {
            break;
        }
        
        return Ticket;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // NatLookupTicket


NTSTATUS
NatProcessCreateTicket(
    PIP_NAT_CREATE_TICKET CreateTicket,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked to create a ticket in response to an
    'IOCTL_IP_NAT_CREATE_TICKET' request.

Arguments:

    CreateTicket - describes the ticket to be created

Return Value:

    NTSTATUS - status code.

--*/

{
    PNAT_INTERFACE Interfacep;
    KIRQL Irql;
    NTSTATUS Status;
    
    TRACE(TICKET, ("NatProcessCreateTicket\n"));

    //
    // Validate the parameters
    //

    if (0 == CreateTicket->InterfaceIndex
        || INVALID_IF_INDEX == CreateTicket->InterfaceIndex
        || (NAT_PROTOCOL_TCP != CreateTicket->PortMapping.Protocol
            && NAT_PROTOCOL_UDP != CreateTicket->PortMapping.Protocol)
        || 0 == CreateTicket->PortMapping.PublicPort
        || 0 == CreateTicket->PortMapping.PrivatePort
        || 0 == CreateTicket->PortMapping.PrivateAddress) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Lookup and reference the interface
    //

    KeAcquireSpinLock(&InterfaceLock, &Irql);

    Interfacep = NatLookupInterface(CreateTicket->InterfaceIndex, NULL);

    if (NULL == Interfacep) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }

    if (Interfacep->FileObject != FileObject) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        return STATUS_ACCESS_DENIED;
    }
    
    if (!NatReferenceInterface(Interfacep)) {
        KeReleaseSpinLock(&InterfaceLock, Irql);
        return STATUS_INVALID_PARAMETER;
    }

    KeReleaseSpinLockFromDpcLevel(&InterfaceLock);
    KeAcquireSpinLockAtDpcLevel(&Interfacep->Lock);

    //
    // Create the actual ticket
    //

    Status =
        NatCreateStaticPortMapping(
            Interfacep,
            &CreateTicket->PortMapping
            );

    KeReleaseSpinLock(&Interfacep->Lock, Irql);
    NatDereferenceInterface(Interfacep);

    return Status;
} // NatProcessCreateTicket


NTSTATUS
NatProcessDeleteTicket(
    PIP_NAT_CREATE_TICKET DeleteTicket,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

 